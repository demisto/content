category: Data Enrichment & Threat Intelligence
commonfields:
  id: Recorded Future
  version: -1
configuration:
- defaultvalue: https://api.recordedfuture.com
  display: Server URL (e.g., https://api.recordedfuture.com)
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: API Token
  name: token
  required: true
  type: 4
- defaultvalue: "5"
  display: Suspicious Threshold. Minimum risk score to consider an indicator suspicious.
  name: suspicious_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: File Threshold. Minimum risk score from Recorded Future to consider the
    file malicious.
  name: file_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: IP Threshold. Minimum risk score from RF to consider the IP malicious.
  name: ip_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: Domain Threshold. Minimum risk score from Recorded Future to consider the
    domain malicious.
  name: domain_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: URL Threshold. Minimum risk score from Recorded Future to consider the
    URL malicious.
  name: url_threshold
  required: false
  type: 0
- defaultvalue: "65"
  display: Vulnerability Threshold. Minimum risk score from Recorded Future to consider
    the vulnerability critical.
  name: cve_threshold
  required: false
  type: 0
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: Global Trends, Trending Vulnerabilities;Global Trends, Trending Attackers
  display: Rule names to fetch alerts by, separated by semicolon. If empty, all alerts
    will be fetched
  name: rule_names
  required: false
  type: 12
- defaultvalue: 24 hours
  display: First fetch time (<number> <time unit>, e.g., 12 hours, 7 days, 3 months,
    1 year)
  name: triggered
  required: false
  type: 0
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
description: Unique threat intel technology that automatically serves up relevant
  insights in real time.
display: Recorded Future
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAC6NJREFUeAHtmH9wVNUVx+97+3Y3i0lIgOFnQiCEgEZQxB8EZyQwSrFVK85UOk5bq7VUpyJii7VOtRlFbRSdsSgF/QNELfUHrTqOtaAmtGIFxaFgtEACwfyAqCGJZLPJ7r73+jkvu0s2pomMg7Qz983c3HvPOff8+J5zf2yU0p9GQCOgEdAIaAQ0AhoBjYBGQCOgEdAIaAQ0AhoBjYBGQCOgEdAIaAQ0AhoBjYBGQCOgEdAIaAQEgZvfn6qWvJunwfj/QMA8ITdv3j7RDAQ2+6zQOrXsndAJrdXCpwSBwRN8YUWWKinP9Lwz3FGGofJdQ01RbXGPNvSmf+SqJfuDp8R7bXRQBIwBJQp/NdTIynlJ+cxu90jtVWrRkjMMZe9QpqpzbfecQNweHQ8GXlRuvNLJnrFUlRtOf/oKCwuHDhkyJEN4XV1dTjAYbK+uro72J/tN0AoKCmZgJ+PQoUP/PAF7PtZd5PP5Gg8cOLCv97opU6ZkEVPIcZwUnhJnTU1NG3Kx3rLf9Nga0GDQPxL+bGUbMeUfOUoZpq1cu2dJlPQGY6cbVrDEicZt1fJXP4zufvRl2ra9KRKJTAQA4ZudnZ3tEyZMWFNXV7eeudvPmpNKsixrMT6NwciVJ2AoZJrmPbRXWVORXFdSUpJJMtfGYrFZ0Lz4Xdc1+KLEuJwY/5aUTfZFRUWT4F8AJn9paGiIJOknox84waYl4MeV4cY944GAIsWG48RJ5qekJstVjpfwHn7/HvoJRgLaGI/H/wxAAcQW0j82adKkQ7W1tW/1v+ykUmWnpXbb17FEHBJfIbG9StE8Q3J9og+aTSGl7fSknWg0Wgrvt5wGldBOYYKTHkkfsvwq3FKrglnPGK7/oLt6a6daduVXAgkQvGA5st5PqHxv4sSJ8wlyLvNTkWAp3BM6OfLy8qSS+11DUh0SWsNu3JGIb8AOWdETpSC8HT+g8NdkfmkHFxUtCR4bErSad68Mp+n2B0y1atYXJRvm3+iPbI7uVMpRzhVfeqSN59FVOCp+rKp87kC7WsCyAcbb/hxZQYK9yO/3j6a63+NY+3fSNsfc6IyMjNnMg/B2Ju8/1mRTIHPQkQH97wcPHmyWNXL8UVBd0IV/LtfC23v37j0IvYT5Wey0XdDS3gqcJPmBQGA2azpFFzbaE/Yt3g+z8GtMd3f3HvievwnegB0FXMAOtSjqWhEkjgz0TMXOR+FwWOxn4ufl48ePb/rkk0+2FxcXj+WYb03GIUc/V9kk5tX4novvufjQDhZlYHVg3759740bN244b5s56LGIq4rTkGM1/UtP8FkrxtUagScQyVVF9/5QOdy9ya/ViKu3FkzZ44TWuc53G1VlzXVqk3U84OE7Yr6lH1xx2B+qOBy23ywpr76turwkmlwOOPmTJ08+XaqXQK6CPp7+NQLPwbm1OFlM30R/F0HfR9BP5efnn4fcBgKzWN8B7zSCXUSAR2nP0sZAj0K30fMTCmM7tLugnUkOTfTFGH8G2OdCX0U7iv1WaMPpd4tv8C5B9iF8+RT5LHjLsPvT+vr6OngPIHIt9puQ/4I2gXY8ZlHQ88mlW8QjrJT14k81CbkVeyPKy8uvpTnonwr9eXQtFBlaLglfjO1G7DRj+xFUvU5bKSopgnORfxydF6P7W9zzd7CmhfU59GvwMUIBPYnebnoXPXdAW4zfyVNS1PAe7v256hzD8n+bh1OpCvnPVDb3b/JryIizZ2e4oUApj66rVKB7lFKB4zuBIFxTXeKEMqc6VEB19FhuYqkYdwhgMY79kX4HDl3N+AaqU460GwmkCPo8ds53EL0f/t3Tp0/PA6Tb4TXwGJkNfza8HzGvZ+3dNIvdNof1pQD5MfSVpaWl8ts8A14BtOXov5AdswfaCkDaSLWfDyA/gy9HpDFt2rRchveydhM7bT40uTI6WXMLoMuO/gHtF9iWxD1COw1+2ifgQpAEL2T8KLpWICeFZ0EL8GvBu8bg+aAFE73c0w3E9z18vJqdWktsolveJ97HXDZfgN7Avg+9k4npZRJ/PmseY+398D+mqMvYuXORe5+C+QNXybAeDT1/03dwZ/Nm5YxZbpq+HMf4/A1OEZLovRmUKowEVGbra1ZH4N64pQ6rxpo6ZYXP4nLu0VRWafmjsVUqcszkJHvHDrz+WcKQgXMGPyMepfqew5Gnobfg2EvCB4QSWjvBn4dzPoLJBODstra2CYCRj8hzR44cSep6lx0cRH4GAW5ER4PoYMdvoFtNlY+EJ4Bv4QR4U3gAko/tISIP2B2QPuRI3oofI1paWkbBG8nYxvYCbCtsdzMvoC+mgOoB9VV56Y4dO3Yzsh/jZwIQ0c49Y9uSQB6ezmqOzMfw28VOmNNKEiq+pL6+c/A4vkF6iqS3vFc4shj8fNjZj3/rmpubw/KzkziLoB0QvxnLGyCO/tNJchZLjiaNpie4ZpVYXJmyWlJ+fIefxm6ftf2LuHp8da6yIq3qFVstNbzq9JRNi/i6V82VV+PPk8p79QLA51RaPUCtALyXcPJidixFpCTufIK4HBkfjkrlV5Cs/ZmZmXI0Hz9FEKbafQAthZGisy7O3CWJHviskUR6n+wYBvLbO3W0QrJZ4/GRNVk7C9pYsU+Te+w56AW0OH6lQJe5t+jLfwSHyLZt244lWVLU6HK5S90XXnhB/PUMoiOFWe8x64Segj4hbyRkmBqd3L/elYle2TQOPDaYtwOlmCxot4RCocNJH6RPT3BvTt+xa8XUmSvyDTNc1Wa5+9UHZZdRWimH+or3neOAB35TU1Mlya3C4TuRqaTJz4S9/NNhSe818ihhjY3To3vTeYxE2Z1hqrkgSadgJiIbZ0d0CBKMUyCSuGOSuI6OjnHI8zbkPw+x2AjpqfZuxCXZT2F/k9CSH/YXwRuBrhxobYzlqMoR9UmZPn3KptDxrwO9JevXr5djt4t1crr4uW46KEQR8eGHlzB2ZTenSgR5ObG8D9/ymEv1dwlBYmLu2eBkiZJs2bWvc7pU9Kzo/+9XTzAFqVxnpGG5hUTI7+DskOIw7l9tGlWckmQljzab4B8A+Ld4QFzBMfM0403cefII2kzwk5EvJrFLif9lxsvgtTL/DP4Ckvs4/RrmvycJchTJf4tuJ/gndu/e/SlAyX/MUj8/sLsP2a3QVsIbw9opjC+DvoWk1qP7NYCq4JiXZB7B/nzkd4DhFvwKw3sCOxvpF7BuOryN9KkvAbpcG2lYYudFZBciuBa779AvRbaSR9Ah9GXBG0JhPojdrYxfZv06ZB6SWJGTR9cvoT3f2Nh4FJoUSUbClmKTdELbwLrb0CVvnI/wdQ4y7cOGDavYuXOnVzjM+zyyhNL765YHhBGkBVSMBNvKcW3H7Xl8BV1lwLfEtknC+/+4IyIA9ycC/jApQZK24fzvqFKL8dvwrsHZ8cx/jcyltB08emLIPCIN3kKCuIm+DeAPkphnkbkV3jwCWwQYD3Ef3yf6sbWZVilj+aDL7lkGbQv99TS5BnhnmPIfpjhH/h3M12L7+7Tl0IZiaxeJaGLN9ciFsXEDMrsY3wX/X7TUl52dLfG9Qgy7UkQG2N1O92NaDvquS8jIKRWHJ7ISz1B0Xwovl3ifxsZt0C6kyK5h/CQnUjlysN090J9nnPqnCA+th5n/BrmLE7gVI/c2yU1dRfAH+W9O3rKQOXzUfZzytmPk3qm6ms/mlY3jZp3rtM5U864MmP6slcqNbXMePnuNKPw6H/eVvDpTP6166fLNnDnT7F2ZCZ6cDvJOSAuq17q0YVlZmVVVVfXf7lETG75+bIgOOX2+ko00g4nJIHb7LjmhmGTxALgNkuC+ps+45wIzI+NdV7n1rhE5R+0s/7yviJ7/byGQdm8M6pqvc5/r+N8wXGOvazW1DyqvBTQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AROCkI/Adox/h1F7lx8wAAAABJRU5ErkJggg==
name: Recorded Future
script:
  commands:
  - arguments:
    - default: true
      description: Domain to get the reputation of
      name: domain
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    description: Returns threat intelligence information for a domain or DNS in Recorded
      Future.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.RecordedFuture.Criticality
      description: Domain criticality label
      type: string
    - contextPath: Domain.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: Domain.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - default: true
      description: IP address to get the reputation of
      name: ip
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    description: Returns threat intelligence information for an IP address in Recorded
      Future.
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.RecordedFuture.Criticality
      description: Risk criticality label
      type: string
    - contextPath: IP.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: IP.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - default: true
      description: File hash to check the reputation of (MD5, SHA-1, SHA-256, SHA-512,
        CRC-32, CTPH)
      name: file
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    description: Returns threat intelligence information for a file in Recorded Future.
    name: file
    outputs:
    - contextPath: File.SHA256
      description: File SHA-256
      type: string
    - contextPath: File.SHA512
      description: File SHA-512
      type: string
    - contextPath: File.SHA1
      description: File SHA-1
      type: string
    - contextPath: File.MD5
      description: File MD-5
      type: string
    - contextPath: File.CRC32
      description: File CRC-32
      type: string
    - contextPath: File.CTPH
      description: File CTPH
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.Criticality
      description: Risk criticality label
      type: string
    - contextPath: File.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: File.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - auto: PREDEFINED
      description: The type of entity to fetch context for. (Should be provided with
        its value in entityValue argument)
      name: entityType
      predefined:
      - domain
      - ip
      - file
      - url
      required: true
    - description: 'The value of the entity to fetch context for. (Should be provided
        with its type in entityType argument, Hash types supported: MD5, SHA-1, SHA-256,
        SHA-512, CRC-32, CTPH)'
      name: entityValue
      required: true
    - auto: PREDEFINED
      defaultValue: All
      description: CSV list of related entity types to return in the result (e.g.,
        Hash,IP,Domain)
      name: resultEntityType
      predefined:
      - All
      - Hash
      - IP
      - Domain
      - Attacker
      - Malware
      - URL
    description: Returns threat intelligence context for an indicator in Recorded
      Future.
    name: recorded-future-get-related-entities
    outputs:
    - contextPath: File.SHA256
      description: File SHA-256
      type: string
    - contextPath: File.SHA512
      description: File SHA-512
      type: string
    - contextPath: File.SHA1
      description: File SHA-1
      type: string
    - contextPath: File.MD5
      description: File MD-5
      type: string
    - contextPath: File.CRC32
      description: File CRC-32
      type: string
    - contextPath: File.CTPH
      description: File CTPH
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.IPAddress.Count
      description: File related entity count (IP)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.IPAddress.ID
      description: File related entity ID (IP)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.IPAddress.Name
      description: File related entity name (IP)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Hash.Count
      description: File related entity count (Hash)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Hash.ID
      description: File related entity ID (Hash)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Hash.Name
      description: File related entity name (Hash)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Domain.Count
      description: File related entity count (Domain)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Domain.ID
      description: File related entity ID (Domain)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Domain.Name
      description: File related entity name (Domain)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Attacker.Count
      description: File related entity count (Attacker)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Attacker.ID
      description: File related entity ID (Attacker)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Attacker.Name
      description: File related entity name (Attacker)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Malware.Count
      description: File related entity count (Malware)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Malware.ID
      description: File related entity ID (Malware)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Malware.Name
      description: File related entity name (Malware)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.URL.Count
      description: File related entity count (URL)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.URL.ID
      description: File related entity ID (URL)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.URL.Data
      description: File related entity name (URL)
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.IPAddress.Count
      description: IP related entity count (IP)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.IPAddress.ID
      description: IP related entity ID (IP)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.IPAddress.Name
      description: IP related entity name (IP)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Hash.Count
      description: IP related entity count (Hash)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Hash.ID
      description: IP related entity ID (Hash)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Hash.Name
      description: IP related entity name (Hash)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Domain.Count
      description: IP related entity count (Domain)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Domain.ID
      description: IP related entity ID (Domain)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Domain.Name
      description: IP related entity name (Domain)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Attacker.Count
      description: IP related entity count (Attacker)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Attacker.ID
      description: IP related entity ID (Attacker)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Attacker.Name
      description: IP related entity name (Attacker)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Malware.Count
      description: IP related entity count (Malware)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Malware.ID
      description: IP related entity ID (Malware)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Malware.Name
      description: IP related entity name (Malware)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.URL.Count
      description: IP related entity count (URL)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.URL.ID
      description: IP related entity ID (URL)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.URL.Data
      description: IP related entity name (URL)
      type: string
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.IPAddress.Count
      description: Domain related entity count (IP)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.IPAddress.ID
      description: Domain related entity ID (IP)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.IPAddress.Name
      description: Domain related entity name (IP)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Hash.Count
      description: Domain related entity count (Hash)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Hash.ID
      description: Domain related entity ID (Hash)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Hash.Name
      description: Domain related entity name (Hash)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Domain.Count
      description: Domain related entity count (Domain)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Domain.ID
      description: Domain related entity ID (Domain)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Domain.Name
      description: Domain related entity name (Domain)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Attacker.Count
      description: Domain related entity count (Attacker)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Attacker.ID
      description: Domain related entity ID (Attacker)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Attacker.Name
      description: Domain related entity name (Attacker)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Malware.Count
      description: Domain related entity count (Malware)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Malware.ID
      description: Domain related entity ID (Malware)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Malware.Name
      description: Domain related entity name (Malware)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.URL.Count
      description: Domain related entity count (URL)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.URL.ID
      description: Domain related entity ID (URL)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.URL.Data
      description: Domain related entity name (URL)
      type: string
    - contextPath: URL.Data
      description: URL name
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.IPAddress.Count
      description: URL related entity count (IP)
      type: number
    - contextPath: URL.RecordedFuture.RelatedEntities.IPAddress.ID
      description: URL related entity ID (IP)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.IPAddress.Name
      description: URL related entity name (IP)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Hash.Count
      description: URL related entity count (Hash)
      type: number
    - contextPath: URL.RecordedFuture.RelatedEntities.Hash.ID
      description: URL related entity ID (Hash)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Hash.Name
      description: URL related entity name (Hash)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Domain.Count
      description: URL related entity count (Domain)
      type: number
    - contextPath: URL.RecordedFuture.RelatedEntities.Domain.ID
      description: URL related entity ID (Domain)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Domain.Name
      description: URL related entity name (Domain)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Attacker.Count
      description: URL related entity count (Attacker)
      type: number
    - contextPath: URL.RecordedFuture.RelatedEntities.Attacker.ID
      description: URL related entity ID (Attacker)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Attacker.Name
      description: URL related entity name (Attacker)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Malware.Count
      description: URL related entity count (Malware)
      type: number
    - contextPath: URL.RecordedFuture.RelatedEntities.Malware.ID
      description: URL related entity ID (Malware)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.Malware.Name
      description: URL related entity name (Malware)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.URL.Count
      description: URL related entity count (URL)
      type: number
    - contextPath: URL.RecordedFuture.RelatedEntities.URL.ID
      description: URL related entity ID (URL)
      type: string
    - contextPath: URL.RecordedFuture.RelatedEntities.URL.Data
      description: URL related entity name (URL)
      type: string
  - arguments:
    - default: true
      description: URL to get the reputation of
      name: url
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    description: Returns threat intelligence information for a URL in Recorded Future.
    name: url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: URL.Data
      description: URL name
      type: string
    - contextPath: URL.RecordedFuture.Criticality
      description: URL criticality label
      type: string
    - contextPath: URL.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: URL.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    - defaultValue: "1"
      description: Number of results to return
      name: limit
    - defaultValue: "65"
      description: Minimum threshold score to return results for
      name: risk_lower
    - defaultValue: "99"
      description: Maximum threshold score to return results for
      name: risk_higher
    - auto: PREDEFINED
      defaultValue: sevendayshits
      description: Category to sort results by
      name: orderby
      predefined:
      - created
      - criticality
      - firstseen
      - lastseen
      - modified
      - riskscore
      - rules
      - sevendayshits
      - sixtydayshits
      - totalhits
    - description: Sort direction
      name: direction
    description: Returns hash threats from Recorded Future
    name: recorded-future-get-threats-hash
    outputs:
    - contextPath: File.SHA256
      description: File SHA-256
      type: string
    - contextPath: File.SHA512
      description: File SHA-512
      type: string
    - contextPath: File.SHA1
      description: File SHA-1
      type: string
    - contextPath: File.MD5
      description: File MD-5
      type: string
    - contextPath: File.CRC32
      description: File CRC-32
      type: string
    - contextPath: File.CTPH
      description: File CTPH
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.RecordedFuture.Criticality
      description: Risk criticality label
      type: string
    - contextPath: File.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: File.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    - defaultValue: "1"
      description: Number of results to return
      name: limit
    - defaultValue: "65"
      description: Minimum threshold score to return results for
      name: risk_lower
    - defaultValue: "99"
      description: Maximum threshold score to return results for
      name: risk_higher
    - auto: PREDEFINED
      defaultValue: sevendayshits
      description: Category to sort by
      name: orderby
      predefined:
      - created
      - criticality
      - firstseen
      - lastseen
      - modified
      - riskscore
      - rules
      - sevendayshits
      - sixtydayshits
      - totalhits
    - auto: PREDEFINED
      description: Sort direction
      name: direction
      predefined:
      - asc
      - desc
    description: Returns IP threats from Recorded Future
    name: recorded-future-get-threats-ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.RecordedFuture.Criticality
      description: Risk criticality label
      type: string
    - contextPath: IP.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: string
    - contextPath: IP.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    - defaultValue: "1"
      description: Number of results to return
      name: limit
    - defaultValue: "65"
      description: Minimum threshold score to return results for
      name: risk_lower
    - defaultValue: "99"
      description: Maximum threshold score to return results for
      name: risk_higher
    - auto: PREDEFINED
      defaultValue: sevendayshits
      description: Category to sort by
      name: orderby
      predefined:
      - created
      - criticality
      - firstseen
      - lastseen
      - modified
      - riskscore
      - rules
      - sevendayshits
      - sixtydayshits
      - totalhits
    - auto: PREDEFINED
      description: Sort direction
      name: direction
      predefined:
      - asc
      - desc
    description: Returns URL threats from Recorded Future
    name: recorded-future-get-threats-url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: URL.Data
      description: URL name
      type: string
    - contextPath: URL.RecordedFuture.Criticality
      description: URL criticality label
      type: string
    - contextPath: URL.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: URL.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    - defaultValue: "1"
      description: Limit number of results returned
      name: limit
    - defaultValue: "65"
      description: Minimum threshold score to return results for
      name: risk_lower
    - defaultValue: "99"
      description: Maximum threshold score to return results for
      name: risk_higher
    - auto: PREDEFINED
      defaultValue: sevendayshits
      description: Category to sort by
      name: orderby
      predefined:
      - created
      - criticality
      - firstseen
      - lastseen
      - modified
      - riskscore
      - rules
      - sevendayshits
      - sixtydayshits
      - totalhits
    - auto: PREDEFINED
      description: Sort direction
      name: direction
      predefined:
      - asc
      - desc
    description: Returns domain threats from Recorded Future
    name: recorded-future-get-threats-domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.RecordedFuture.Criticality
      description: Domain criticality label
      type: string
    - contextPath: Domain.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: Domain.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - defaultValue: "1"
      description: Number of results to return
      name: limit
    - defaultValue: "65"
      description: Minimum threshold score to return results for
      name: risk_lower
    - defaultValue: "99"
      description: Maximum threshold score to return results for
      name: risk_higher
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, fetches evidence details. Evidence is a record that is
        generated if any of the risk rules in Recorded Future is triggered.
      name: detailed
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: sevendayshits
      description: Category to sort by
      name: orderby
      predefined:
      - created
      - criticality
      - firstseen
      - lastseen
      - modified
      - riskscore
      - rules
      - sevendayshits
      - sixtydayshits
      - totalhits
    - auto: PREDEFINED
      description: Sort direction
      name: direction
      predefined:
      - asc
      - desc
    description: Returns vulnerability threats from Recorded Future.
    name: recorded-future-get-threats-vulnerabilities
    outputs:
    - contextPath: CVE.ID
      description: Vulnerability CVE ID
      type: string
    - contextPath: CVE.RecordedFuture.Criticality
      description: CVE criticality label
      type: string
    - contextPath: CVE.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: CVE.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
  - arguments:
    - description: Specify a domain list by a risk rule name, which can be retrieved
        by the get-domain-riskrules command.
      name: list
    description: Gets the domain risk list as a CSV file from Recorded Future.
    name: recorded-future-get-domain-risklist
    outputs:
    - contextPath: InfoFile.Name
      description: File name
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the file
      type: string
    - contextPath: InfoFile.Size
      description: File size
      type: number
    - contextPath: InfoFile.Type
      description: File type, e.g., "PE"
      type: string
    - contextPath: InfoFile.Info
      description: Basic information of the file
      type: string
    - contextPath: InfoFile.Extension
      description: File extension
      type: string
  - arguments:
    - description: Specify a URL list by a risk rule name, which can be retrieved
        from the get-url-riskrules command.
      name: list
    description: Gets the URL risk list as a CSV file from Recorded Future.
    name: recorded-future-get-url-risklist
    outputs:
    - contextPath: InfoFile.Name
      description: File name
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the file
      type: string
    - contextPath: InfoFile.Size
      description: File size
      type: number
    - contextPath: InfoFile.Type
      description: File type, e.g., "PE"
      type: string
    - contextPath: InfoFile.Info
      description: Basic information of the file
      type: string
    - contextPath: InfoFile.Extension
      description: File extension
      type: string
  - arguments:
    - description: Specify an IP list by a risk rule name, which can be retrieved
        from the get-ip-riskrules command.
      name: list
    description: Gets the IP risk list as a CSV file from Recorded Future.
    name: recorded-future-get-ip-risklist
    outputs:
    - contextPath: InfoFile.Name
      description: File name
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the file
      type: string
    - contextPath: InfoFile.Size
      description: File size
      type: number
    - contextPath: InfoFile.Type
      description: File type, e.g., "PE"
      type: string
    - contextPath: InfoFile.Info
      description: Basic information of the file
      type: string
    - contextPath: InfoFile.Extension
      description: File extension
      type: string
  - arguments:
    - description: Specify a vulnerability list by a risk rule name, which can be
        retrieved from the get-vulnerability-riskrules command.
      name: list
    description: Gets the vulnerability (CVE) risk list from Recorded Future.
    name: recorded-future-get-vulnerability-risklist
    outputs:
    - contextPath: InfoFile.Name
      description: File name
      type: string
    - contextPath: InfoFile.EntryID
      description: File entry ID
      type: string
    - contextPath: InfoFile.Size
      description: File size
      type: number
    - contextPath: InfoFile.Type
      description: File type, e.g., "PE"
      type: string
    - contextPath: InfoFile.Info
      description: Basic information of the file
      type: string
    - contextPath: InfoFile.Extension
      description: File extension
      type: string
  - arguments:
    - description: Specify a hash list by a riskrule name, which can be retrieved
        from the get-hash-riskrules command.
      name: list
    description: Gets the hash risk list from Recorded Future.
    name: recorded-future-get-hash-risklist
    outputs:
    - contextPath: InfoFile.Name
      description: File name
      type: string
    - contextPath: InfoFile.EntryID
      description: File entry ID
      type: string
    - contextPath: InfoFile.Size
      description: File size
      type: number
    - contextPath: InfoFile.Type
      description: File type, e.g., "PE"
      type: string
    - contextPath: InfoFile.Info
      description: Basic information of the file
      type: string
    - contextPath: InfoFile.Extension
      description: File extension
      type: string
  - arguments: []
    description: Gets the risk rules for domain data.
    name: recorded-future-get-domain-riskrules
    outputs:
    - contextPath: RecordedFuture.RiskRule.Domain.Name
      description: Risk rule name
      type: string
    - contextPath: RecordedFuture.RiskRule.Domain.Description
      description: Risk rule description
      type: string
    - contextPath: RecordedFuture.RiskRule.Domain.Count
      description: Risk rule indicator count
      type: number
    - contextPath: RecordedFuture.RiskRule.Domain.Criticality
      description: Risk rule criticality
      type: string
  - arguments: []
    description: Gets the risk rules for hash data.
    name: recorded-future-get-hash-riskrules
    outputs:
    - contextPath: RecordedFuture.RiskRule.Hash.Name
      description: Risk rule name
      type: string
    - contextPath: RecordedFuture.RiskRule.Hash.Description
      description: Risk rule description
      type: string
    - contextPath: RecordedFuture.RiskRule.Hash.Count
      description: Risk rule indicator count
      type: number
    - contextPath: RecordedFuture.RiskRule.Hash.Criticality
      description: Risk rule criticality
      type: string
  - arguments: []
    description: Gets the risk rules for IP data.
    name: recorded-future-get-ip-riskrules
    outputs:
    - contextPath: RecordedFuture.RiskRule.IP.Name
      description: Risk rule name
      type: string
    - contextPath: RecordedFuture.RiskRule.IP.Description
      description: Risk rule description
      type: string
    - contextPath: RecordedFuture.RiskRule.IP.Count
      description: Risk rule indicator count
      type: number
    - contextPath: RecordedFuture.RiskRule.IP.Criticality
      description: Risk rule criticality
      type: string
  - arguments: []
    description: Gets the risk rules for URL data.
    name: recorded-future-get-url-riskrules
    outputs:
    - contextPath: RecordedFuture.RiskRule.URL.Name
      description: Risk rule name
      type: string
    - contextPath: RecordedFuture.RiskRule.URL.Description
      description: Risk rule description
      type: string
    - contextPath: RecordedFuture.RiskRule.URL.Count
      description: Risk rule indicator count
      type: number
    - contextPath: RecordedFuture.RiskRule.URL.Criticality
      description: Risk rule criticality
      type: string
  - arguments: []
    description: Gets the risk rules for vulnerability data.
    name: recorded-future-get-vulnerability-riskrules
    outputs:
    - contextPath: RecordedFuture.RiskRule.Vulnerability.Name
      description: Risk rule name
      type: string
    - contextPath: RecordedFuture.RiskRule.Vulnerability.Description
      description: Risk rule description
      type: string
    - contextPath: RecordedFuture.RiskRule.Vulnerability.Count
      description: Risk rule indicator count
      type: number
    - contextPath: RecordedFuture.RiskRule.Vulnerability.Criticality
      description: Risk rule criticality
      type: string
  - arguments:
    - description: Rule name to search, can be a partial name
      name: rule_name
    - defaultValue: "10"
      description: Number of rules to return
      name: limit
    description: Gets Recorded Future alert rules.
    name: recorded-future-get-alert-rules
    outputs:
    - contextPath: RecordedFuture.AlertRule.ID
      description: Alert rule ID
      type: string
    - contextPath: RecordedFuture.AlertRule.Name
      description: Alert rule name
      type: string
  - arguments:
    - description: Alert rule ID
      name: rule_id
    - defaultValue: "10"
      description: Number of alerts to return
      name: limit
    - description: Alert triggered time, e.g., "1 hour" or "2 days"
      name: triggered_time
    - description: Alert assignee's email address
      name: assignee
    - auto: PREDEFINED
      description: Alert review status
      name: status
      predefined:
      - unassigned
      - assigned
      - actionable
      - no-action
      - tuning
    - description: Free text search
      name: freetext
    - description: Alerts from offset
      name: offset
    - auto: PREDEFINED
      description: Alerts sort order
      name: orderby
      predefined:
      - triggered
    - auto: PREDEFINED
      description: Alerts sort direction
      name: direction
      predefined:
      - asc
      - desc
    description: Gets alerts from Recorded Future.
    name: recorded-future-get-alerts
    outputs:
    - contextPath: RecordedFuture.Alert.ID
      description: Alert ID
      type: string
    - contextPath: RecordedFuture.Alert.Name
      description: Alert name
      type: string
    - contextPath: RecordedFuture.Alert.Type
      description: Alert type
      type: string
    - contextPath: RecordedFuture.Alert.Triggered
      description: Alert triggered time
      type: date
    - contextPath: RecordedFuture.Alert.Status
      description: Alert status
      type: string
    - contextPath: RecordedFuture.Alert.Assignee
      description: Alert assignee
      type: string
    - contextPath: RecordedFuture.Alert.Rule
      description: Alert rule name
      type: string
  isfetch: true
  runonce: false
  script: |2-



    ''' IMPORTS '''
    import requests
    import os
    import json
    import urllib
    from datetime import datetime

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    TOKEN = demisto.params()['token']
    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    BASE_URL = SERVER + '/v2/'
    USE_SSL = not demisto.params().get('unsecure', False)
    HEADERS = {
        'X-RFToken': TOKEN,
        'X-RF-User-Agent': 'DemistoIntegrations+v1.0'
    }
    FILE_THRESHOLD = int(demisto.params()['file_threshold'])
    IP_THRESHOLD = int(demisto.params()['ip_threshold'])
    DOMAIN_THRESHOLD = int(demisto.params()['domain_threshold'])
    URL_THRESHOLD = int(demisto.params()['url_threshold'])
    CVE_THRESHOLD = int(demisto.params()['cve_threshold'])
    SUSPICIOUS_THRESHOLD = int(demisto.params()['suspicious_threshold'])

    FETCH_TIME = demisto.params().get('triggered').strip()
    RULE_NAMES = demisto.params().get('rule_names').strip()

    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, params=None):
        LOG('running request with url=%s' % (BASE_URL + url_suffix))

        params = params if params is not None else {}

        try:
            res = requests.request(
                method,
                BASE_URL + url_suffix,
                params=params,
                headers=HEADERS,
                verify=USE_SSL
            )
            if res.status_code not in {200, 404}:
                if res.status_code == 401:
                    error_str = 'Request failed with status 401 - Authentication error'
                else:
                    error_str = 'Request failed, status: ' + str(res.status_code) + ', details: ' + res.text
                return_error(error_str)
        except Exception, e:
            LOG(e.message)
            return_error(e.message)
        return res.text


    def translate_score(score, threshold):
        '''
        Translates Recorded Future score to DBot score
        '''
        if score >= threshold:  # Bad
            return 3
        elif score >= SUSPICIOUS_THRESHOLD:  # Suspicious
            return 2
        else:
            return 0  # Unknown


    def determine_hash(hash):
        '''
        Determines hash type by length
        '''
        if len(hash) == 128:
            return 'SHA512'
        elif len(hash) == 64:
            return 'SHA256'
        elif len(hash) == 40:
            return 'SHA1'
        elif len(hash) == 32:
            return 'MD5'
        elif len(hash) == 8:
            return 'CRC32'
        else:
            return 'CTPH'


    ''' FUNCTIONS '''


    def domain_command():
        domain = demisto.args().get('domain')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(domain_lookup(domain))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            hr = '### Recorded Future domain reputation for ' + domain + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/idn:' + domain + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Evidence Summary', 'Rule Criticality', 'Rule Triggered', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this domain', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['domain']] = {
                'Name': domain,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, DOMAIN_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': domain,
                'Type': 'domain',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['domain']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }
        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': domain,
                    'Type': 'domain',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })


    def domain_lookup(domain):
        cmd_url = 'domain/' + domain
        params = {
            'fields': 'sightings,timestamps,risk'
        }

        response = http_request('get', cmd_url, params=params)
        return response


    def url_command():
        url = demisto.args().get('url')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(url_lookup(url))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            encoded_url = urllib.quote_plus(url)
            hr = '### Recorded Future url reputation for ' + url + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/url:' + encoded_url + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Evidence Summary', 'Rule Criticality', 'Rule Triggered', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this URL', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['url']] = {
                'Data': url,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, URL_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': url,
                'Type': 'url',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['url']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }
        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': url,
                    'Type': 'url',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })


    def url_lookup(url):
        encoded_url = urllib.quote_plus(url)
        cmd_url = 'url/' + encoded_url
        params = {
            'fields': 'sightings,timestamps,risk'
        }

        response = http_request('get', cmd_url, params=params)
        return response


    def ip_command():
        ip = demisto.args().get('ip')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(ip_lookup(ip))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            hr = '### Recorded Future IP address reputation for ' + ip + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/ip:' + ip + ')' + '\n'
            evidence_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    evidence_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', evidence_table,
                                      ['Evidence Summary', 'Rule Criticality', 'Rule Triggered', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this IP', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['ip']] = {
                'Address': ip,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, IP_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': ip,
                'Type': 'ip',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['ip']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': ip,
                    'Type': 'ip',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })


    def ip_lookup(ip):
        cmd_url = 'ip/' + ip

        params = {
            'fields': 'sightings,timestamps,risk'
        }

        response = http_request('get', cmd_url, params=params)
        return response


    def file_command():
        file = demisto.args().get('file')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(file_lookup(file))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            hr = '### Recorded Future file reputation for ' + file + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/hash:' + file + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this hash', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            hash_type = determine_hash(file)
            ec = {}
            ec[outputPaths['file']] = {
                hash_type: file,
                'RecordedFuture': {
                    'Criticality': risk['criticalityLabel'],
                    'FirstSeen': timestamps['firstSeen'],
                    'LastSeen': timestamps['lastSeen']
                }
            }
            dbot_score = translate_score(rf_score, FILE_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': file,
                'Type': 'file',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['file']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': file,
                    'Type': 'file',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })


    def file_lookup(file):
        cmd_url = 'hash/' + file

        params = {
            'fields': 'sightings,timestamps,risk'
        }
        response = http_request('get', cmd_url, params=params)
        return response


    def get_related_entities_command():
        entity_value = demisto.args().get('entityValue')
        entity_result_type = demisto.args().get('resultEntityType')
        entity_type = demisto.args().get('entityType').lower()
        if entity_type == 'file':
            entity_type = 'hash'
        if entity_type == 'url':
            entity_value = urllib.quote_plus(entity_value)
        response = json.loads(get_related_entities(entity_value, entity_type))

        ec = {}
        if response and ('error' not in response):
            hr = []  # type: list
            entity_result_type = entity_result_type.split(',')
            entity_types = []  # type: list
            if 'All' in entity_result_type:
                entity_types.extend(['RelatedIpAddress', 'RelatedInternetDomainName', 'RelatedHash', 'RelatedMalware',
                                     'RelatedAttackVector', 'RelatedURL'])
            else:
                if 'IP' in entity_result_type:
                    entity_types.append('RelatedIpAddress')
                if 'Hash' in entity_result_type:
                    entity_types.append('RelatedHash')
                if 'Domain' in entity_result_type:
                    entity_types.append('RelatedInternetDomainName')
                if 'Attacker' in entity_result_type:
                    entity_types.append('RelatedAttackVector')
                if 'Malware' in entity_result_type:
                    entity_types.append('RelatedMalware')
                if 'URL' in entity_result_type:
                    entity_types.append('RelatedURL')
            ip_outputs = []  # type: list
            hash_outputs = []  # type: list
            domain_outputs = []  # type: list
            attacker_outputs = []  # type: list
            malware_outputs = []  # type: list
            url_outputs = []  # type: list

            output_map = {
                'RelatedIpAddress': ip_outputs,
                'RelatedHash': hash_outputs,
                'RelatedInternetDomainName': domain_outputs,
                'RelatedAttackVector': attacker_outputs,
                'RelatedMalware': malware_outputs,
                'RelatedURL': url_outputs
            }
            related_entities = response['data']['relatedEntities']
            for related_entity in related_entities:
                if related_entity['type'] in entity_types:
                    entities = related_entity['entities']
                    for entity in entities:
                        hr_entity = {
                            'Count': entity['count'],
                            'ID': entity['entity']['id']
                        }

                        if related_entity['type'] == 'RelatedURL':
                            hr_entity['Data'] = entity['entity']['name']
                        else:
                            hr_entity['Name'] = entity['entity']['name']

                        output_map[related_entity['type']].append(hr_entity)
            hr_md = ''

            related_entities_ec = {}
            if ip_outputs:
                hr_md += tableToMarkdown('IP Address', ip_outputs)
                related_entities_ec['IPAddress'] = ip_outputs

            if hash_outputs:
                hr_md += tableToMarkdown('Hash', hash_outputs)
                related_entities_ec['Hash'] = hash_outputs

            if domain_outputs:
                hr_md += tableToMarkdown('Domain', domain_outputs)
                related_entities_ec['Domain'] = domain_outputs

            if attacker_outputs:
                hr_md += tableToMarkdown('Attacker', attacker_outputs)
                related_entities_ec['Attacker'] = attacker_outputs

            if malware_outputs:
                hr_md += tableToMarkdown('Malware', malware_outputs)
                related_entities_ec['Malware'] = malware_outputs

            if url_outputs:
                hr_md += tableToMarkdown('URL', url_outputs)
                related_entities_ec['URL'] = url_outputs

            if hr_md:
                hr_md = '### Recorded Future related entities to ' + entity_value + '\n' + hr
                if entity_type == 'ip':
                    ec[outputPaths['ip']] = {
                        'Address': entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
                elif entity_type == 'domain':
                    ec[outputPaths['domain']] = {
                        'Name': entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
                elif entity_type == 'hash':
                    ec[outputPaths['file']] = {
                        determine_hash(entity_value): entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
                elif entity_type == 'url':
                    ec[outputPaths['url']] = {
                        'Data': entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
            else:
                hr_md = 'No results found'
        else:
            hr_md = 'No results found'

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr_md,
            'EntryContext': ec
        })


    def get_related_entities(entity_value, entity_type):
        cmd_url = entity_type + '/' + entity_value

        params = {
            'fields': 'relatedEntities'
        }
        response = http_request('get', cmd_url, params=params)
        return response


    def hashlist_command():
        detailed = False if demisto.args().get('detailed') == 'false' else True
        limit = demisto.args().get('limit')
        risk_lower = demisto.args().get('risk_lower')
        risk_higher = demisto.args().get('risk_higher')
        orderby = demisto.args().get('orderby')
        direction = demisto.args().get('direction')

        response = json.loads(hashlist_lookup(limit, risk_lower, risk_higher, orderby, direction))
        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        resultlist = response['data'].get('results', [])
        if len(resultlist) == 0:
            demisto.results('No results found')
            return

        resultlist = response['data']['results']
        for result in resultlist:
            intelcard = result['intelCard']
            timestamps = result['timestamps']
            file = result['entity']['name']
            risk = result['risk']
            rf_score = risk['score']
            sightings = result['sightings']
            hr = '### Recorded Future file reputation for ' + file + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += '[Intelligence Card](' + intelcard + ')' + '\n'
            hr_table = []
            hash_type = determine_hash(file)
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this hash', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['file']] = {
                hash_type: file,
                'RecordedFuture': {
                    'Criticality': risk['criticalityLabel'],
                    'FirstSeen': timestamps['firstSeen'],
                    'LastSeen': timestamps['lastSeen']
                }
            }
            dbot_score = translate_score(rf_score, FILE_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': file,
                'Type': 'file',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['file']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            })


    def hashlist_lookup(limit, risk_lower, risk_higher, orderby, direction):
        cmd_url = 'hash/search'

        params = {
            'fields': 'entity,intelCard,risk,sightings,timestamps'
        }

        if limit:
            params['limit'] = limit
        if orderby:
            params['orderby'] = orderby
        if direction:
            params['direction'] = direction
        if risk_lower and risk_higher:
            params['riskScore'] = '[{},{}]'.format(risk_lower, risk_higher)

        response = http_request('get', cmd_url, params=params)
        return response


    def iplist_command():
        detailed = False if demisto.args().get('detailed') == 'false' else True
        limit = demisto.args().get('limit')
        risk_lower = demisto.args().get('risk_lower')
        risk_higher = demisto.args().get('risk_higher')
        orderby = demisto.args().get('orderby')
        direction = demisto.args().get('direction')

        response = json.loads(iplist_lookup(limit, risk_lower, risk_higher, orderby, direction))
        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        resultlist = response['data'].get('results', [])
        if len(resultlist) == 0:
            demisto.results('No results found')
            return

        for result in resultlist:
            intelcard = result['intelCard']
            timestamps = result['timestamps']
            ip = result['entity']['name']
            risk = result['risk']
            rf_score = risk['score']
            sightings = result['sightings']
            hr = '### Recorded Future IP reputation for ' + ip + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += '[Intelligence Card](' + intelcard + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    raw_sighting['url'] = raw_sighting['url']
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this IP', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['ip']] = {
                'Address': ip,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, IP_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': ip,
                'Type': 'ip',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['ip']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            })


    def iplist_lookup(limit, risk_lower, risk_higher, orderby, direction):
        cmd_url = 'ip/search'

        params = {
            'fields': 'entity,intelCard,risk,sightings,timestamps'
        }

        if limit:
            params['limit'] = limit
        if orderby:
            params['orderby'] = orderby
        if direction:
            params['direction'] = direction
        if risk_lower and risk_higher:
            params['riskScore'] = '[{},{}]'.format(risk_lower, risk_higher)

        response = http_request('get', cmd_url, params=params)
        return response


    def domainlist_command():
        detailed = False if demisto.args().get('detailed') == 'false' else True
        limit = demisto.args().get('limit')
        risk_lower = demisto.args().get('risk_lower')
        risk_higher = demisto.args().get('risk_higher')
        orderby = demisto.args().get('orderby')
        direction = demisto.args().get('direction')

        response = json.loads(domainlist_lookup(limit, risk_lower, risk_higher, orderby, direction))
        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        resultlist = response['data'].get('results', [])
        if len(resultlist) == 0:
            demisto.results('No results found')
            return

        for result in resultlist:
            timestamps = result['timestamps']
            domain = result['entity']['name']
            risk = result['risk']
            rf_score = risk['score']
            sightings = result['sightings']
            hr = '### Recorded Future Domain reputation for ' + domain + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/idn:' + domain + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this domain', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['domain']] = {
                'Name': domain,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, DOMAIN_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': domain,
                'Type': 'domain',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['domain']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            })


    def domainlist_lookup(limit, risk_lower, risk_higher, orderby, direction):
        cmd_url = 'domain/search'

        params = {
            'fields': 'entity,intelCard,risk,sightings,timestamps'
        }

        if limit:
            params['limit'] = limit
        if orderby:
            params['orderby'] = orderby
        if direction:
            params['direction'] = direction
        if risk_lower and risk_higher:
            params['riskScore'] = '[{},{}]'.format(risk_lower, risk_higher)

        response = http_request('get', cmd_url, params=params)
        return response


    def urllist_command():
        detailed = False if demisto.args().get('detailed') == 'false' else True
        limit = demisto.args().get('limit')
        risk_lower = demisto.args().get('risk_lower')
        risk_higher = demisto.args().get('risk_higher')
        orderby = demisto.args().get('orderby')
        direction = demisto.args().get('direction')

        response = json.loads(urllist_lookup(limit, risk_lower, risk_higher, orderby, direction))
        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        resultlist = response['data'].get('results', [])
        if len(resultlist) == 0:
            demisto.results('No results found')
            return

        for result in resultlist:
            timestamps = result['timestamps']
            url = result['entity']['name']
            intelcard = urllib.quote_plus(url)
            risk = result['risk']
            rf_score = risk['score']
            sightings = result['sightings']
            hr = '### Recorded Future URL reputation for ' + url + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/url:' + intelcard + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this URL', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['url']] = {
                'Data': url,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, URL_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': url,
                'Type': 'url',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['url']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            })


    def urllist_lookup(limit, risk_lower, risk_higher, orderby, direction):
        cmd_url = 'url/search'

        params = {
            'fields': 'entity,intelCard,risk,sightings,timestamps'
        }

        if limit:
            params['limit'] = limit
        if orderby:
            params['orderby'] = orderby
        if direction:
            params['direction'] = direction
        if risk_lower and risk_higher:
            params['riskScore'] = '[{},{}]'.format(risk_lower, risk_higher)

        response = http_request('get', cmd_url, params=params)
        return response


    def vulnlist_command():
        detailed = False if demisto.args().get('detailed') == 'false' else True
        limit = demisto.args().get('limit')
        risk_lower = demisto.args().get('risk_lower')
        risk_higher = demisto.args().get('risk_higher')
        orderby = demisto.args().get('orderby')
        direction = demisto.args().get('direction')

        response = json.loads(vulnlist_lookup(limit, risk_lower, risk_higher, orderby, direction))
        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        resultlist = response['data'].get('results', [])
        if len(resultlist) == 0:
            demisto.results('No results found')
            return

        for result in resultlist:
            timestamps = result['timestamps']
            vuln = result['entity']['name']
            entity_id = result['entity']['id']
            risk = result['risk']
            rf_score = risk['score']
            sightings = result['sightings']
            hr = '### Recorded Future Vulnerability info for ' + vuln + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/' + entity_id + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table,
                                      ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this vulnerability', sightings_table,
                                      ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['cve']] = {
                'ID': vuln,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })


    def vulnlist_lookup(limit, risk_lower, risk_higher, orderby, direction):
        cmd_url = 'vulnerability/search'

        params = {
            'fields': 'entity,intelCard,risk,sightings,timestamps'
        }

        if limit:
            params['limit'] = limit
        if orderby:
            params['orderby'] = orderby
        if direction:
            params['direction'] = direction
        if risk_lower and risk_higher:
            params['riskScore'] = '[{},{}]'.format(risk_lower, risk_higher)

        response = http_request('get', cmd_url, params=params)
        return response


    def get_url_risklist_command():
        specific_list = demisto.args().get('list')

        res = get_url_risklist(specific_list)

        if not res:
            return_error('Received empty response')

        demisto.results(
            fileResult(filename='url_risk_list.csv', data=res.encode('utf-8'), file_type=entryTypes['entryInfoFile']))


    def get_url_risklist(specific_list):
        cmd_url = 'url/risklist'

        params = {
            'format': 'csv/splunk'
        }

        if specific_list:
            params['list'] = specific_list

        return http_request('get', cmd_url, params=params)


    def get_domain_risklist_command():
        specific_list = demisto.args().get('list')

        res = get_domain_risklist(specific_list)

        if not res:
            return_error('Received empty response')

        demisto.results(
            fileResult(filename='domain_risk_list.csv', data=res.encode('utf-8'), file_type=entryTypes['entryInfoFile']))


    def get_domain_risklist(specific_list):
        cmd_url = 'domain/risklist'

        params = {
            'format': 'csv/splunk'
        }

        if specific_list:
            params['list'] = specific_list

        return http_request('get', cmd_url, params=params)


    def get_ip_risklist_command():
        specific_list = demisto.args().get('list')

        res = get_ip_risklist(specific_list)

        if not res:
            return_error('Received empty response')

        demisto.results(
            fileResult(filename='ip_risk_list.csv', data=res.encode('utf-8'), file_type=entryTypes['entryInfoFile']))


    def get_ip_risklist(specific_list):
        cmd_url = 'ip/risklist'

        params = {
            'format': 'csv/splunk'
        }

        if specific_list:
            params['list'] = specific_list

        return http_request('get', cmd_url, params=params)


    def get_hash_risklist_command():
        specific_list = demisto.args().get('list')

        res = get_hash_risklist(specific_list)

        if not res:
            return_error('Received empty response')

        demisto.results(
            fileResult(filename='hash_list.csv', data=res.encode('utf-8'), file_type=entryTypes['entryInfoFile']))


    def get_hash_risklist(specific_list):
        cmd_url = 'hash/risklist'

        params = {
            'format': 'csv/splunk'
        }

        if specific_list:
            params['list'] = specific_list

        return http_request('get', cmd_url, params=params)


    def get_vulnerability_risklist_command():
        specific_list = demisto.args().get('list')

        res = get_vulnerability_risklist(specific_list)

        if not res:
            return_error('Received empty response')

        demisto.results(
            fileResult(filename='cve_risk_list.csv', data=res.encode('utf-8'), file_type=entryTypes['entryInfoFile']))


    def get_vulnerability_risklist(specific_list):
        cmd_url = 'vulnerability/risklist'

        params = {
            'format': 'csv/splunk'
        }

        if specific_list:
            params['list'] = specific_list

        return http_request('get', cmd_url, params=params)


    def get_domain_riskrules_command():
        response = json.loads(get_hash_riskrules())

        if not response or 'data' not in response:
            'No data found'

        headers = ['Name', 'Description', 'Count', 'Criticality']

        mapped_rules = [{
            'Name': r.get('name'),
            'Description': r.get('description'),
            'Count': r.get('count'),
            'Criticality': r.get('criticalityLabel')
        } for r in response['data'].get('results', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future Domain risk rules', mapped_rules, headers=headers,
                                             removeNull=True),
            'EntryContext': {
                'RecordedFuture.RiskRule.Domain(val.Name === obj.Name)': createContext(mapped_rules)
            }
        })


    def get_domain_riskrules():
        cmd_url = 'domain/riskrules'

        res = http_request('get', cmd_url)

        return res


    def get_hash_riskrules_command():
        response = json.loads(get_hash_riskrules())

        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        headers = ['Name', 'Description', 'Count', 'Criticality']

        mapped_rules = [{
            'Name': r.get('name'),
            'Description': r.get('description'),
            'Count': r.get('count'),
            'Criticality': r.get('criticalityLabel')
        } for r in response['data'].get('results', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future Hash risk rules', mapped_rules, headers=headers,
                                             removeNull=True),
            'EntryContext': {
                'RecordedFuture.RiskRule.Hash(val.Name === obj.Name)': createContext(mapped_rules)
            }
        })


    def get_hash_riskrules():
        cmd_url = 'hash/riskrules'

        res = http_request('get', cmd_url)

        return res


    def get_ip_riskrules_command():
        response = json.loads(get_ip_riskrules())

        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        headers = ['Name', 'Description', 'Count', 'Criticality']

        mapped_rules = [{
            'Name': r.get('name'),
            'Description': r.get('description'),
            'Count': r.get('count'),
            'Criticality': r.get('criticalityLabel')
        } for r in response['data'].get('results', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future IP risk rules', mapped_rules, headers=headers,
                                             removeNull=True),
            'EntryContext': {
                'RecordedFuture.RiskRule.IP(val.Name === obj.Name)': createContext(mapped_rules)
            }
        })


    def get_ip_riskrules():
        cmd_url = 'ip/riskrules'

        res = http_request('get', cmd_url)

        return res


    def get_url_riskrules_command():
        response = json.loads(get_url_riskrules())

        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        headers = ['Name', 'Description', 'Count', 'Criticality']

        mapped_rules = [{
            'Name': r.get('name'),
            'Description': r.get('description'),
            'Count': r.get('count'),
            'Criticality': r.get('criticalityLabel')
        } for r in response['data'].get('results', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future URL risk rules', mapped_rules, headers=headers,
                                             removeNull=True),
            'EntryContext': {
                'RecordedFuture.RiskRule.URL(val.Name === obj.Name)': createContext(mapped_rules)
            }
        })


    def get_url_riskrules():
        cmd_url = 'url/riskrules'

        res = http_request('get', cmd_url)

        return res


    def get_vulnerability_riskrules_command():
        response = json.loads(get_vulnerability_riskrules())

        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        headers = ['Name', 'Description', 'Count', 'Criticality']

        mapped_rules = [{
            'Name': r.get('name'),
            'Description': r.get('description'),
            'Count': r.get('count'),
            'Criticality': r.get('criticalityLabel')
        } for r in response['data'].get('results', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future Vulnerability risk rules', mapped_rules, headers=headers,
                                             removeNull=True),
            'EntryContext': {
                'RecordedFuture.RiskRule.Vulnerability(val.Name === obj.Name)': createContext(mapped_rules)
            }
        })


    def get_vulnerability_riskrules():
        cmd_url = 'vulnerability/riskrules'

        res = http_request('get', cmd_url)

        return res


    def get_alert_rules_command():
        rule_name = demisto.args().get('rule_name')
        limit = demisto.args().get('limit')

        response = json.loads(get_alert_rules(rule_name, limit))

        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        mapped_rules = [{
            'Name': r['title'],
            'ID': r['id']
        } for r in response['data'].get('results', [])]

        if len(mapped_rules) == 0:
            demisto.results('No results found')
            return

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future Alert rules', mapped_rules, removeNull=True),
            'EntryContext': {
                'RecordedFuture.AlertRule(val.ID === obj.ID)': createContext(mapped_rules)
            }
        })


    def get_alert_rules(rule_name=None, limit=None):
        cmd_url = 'alert/rule'

        params = {}

        if rule_name:
            params['freetext'] = rule_name
        if limit:
            params['limit'] = limit

        return http_request('get', cmd_url, params=params)


    def get_alerts_command():
        rule_id = demisto.args().get('rule_id')
        limit = demisto.args().get('limit')
        triggered = demisto.args().get('triggered_time')
        assignee = demisto.args().get('assignee')
        status = demisto.args().get('status')
        freetext = demisto.args().get('freetext')
        offset = demisto.args().get('offset')
        orderby = demisto.args().get('orderby')
        direction = demisto.args().get('direction')

        triggered_time = None
        if triggered:
            date, _ = parse_date_range(triggered, date_format='%Y-%m-%d %H:%M:%S')
            triggered_time = '[{},)'.format(date)

        response = json.loads(
            get_alerts(rule_id, triggered_time, limit, assignee, status, freetext, offset, orderby, direction))

        if not response or 'data' not in response:
            demisto.results('No results found')
            return

        headers = ['ID', 'Name', 'Type', 'Triggered', 'Status', 'Assignee', 'Rule']

        mapped_alerts = [{
            'ID': a['id'],
            'Name': a['title'],
            'Type': a['type'],
            'Triggered': a['triggered'],
            'Status': a.get('review', {}).get('status'),
            'Assignee': a.get('review', {}).get('assignee'),
            'Rule': a.get('rule', {}).get('name')
        } for a in response['data'].get('results', [])]

        if len(mapped_alerts) == 0:
            demisto.results('No results found')
            return

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Recorded Future Alerts', mapped_alerts, headers=headers, removeNull=True),
            'EntryContext': {
                'RecordedFuture.Alert(val.ID === obj.ID)': createContext(mapped_alerts)
            }
        })


    def get_alerts(rule_id=None, triggered=None, limit=None, assignee=None, status=None, freetext=None, offset=None,
                   orderby=None, direction=None):
        cmd_url = 'alert/search'

        params = {}

        if rule_id:
            params['alertRule'] = rule_id
        if limit:
            params['limit'] = limit
        if triggered:
            params['triggered'] = triggered
        if assignee:
            params['assignee'] = assignee
        if status:
            params['status'] = status
        if freetext:
            params['freetext'] = freetext
        if offset:
            params['from'] = offset
        if orderby:
            params['orderby'] = orderby
        if direction:
            params['direction'] = direction

        return http_request('get', cmd_url, params=params)


    def get_alert(alert_id):
        cmd_url = 'alert/' + alert_id

        return http_request('get', cmd_url)


    def fetch_incidents():
        if RULE_NAMES:
            rule_names = RULE_NAMES.split(';')
        else:
            rule_names = []

        if FETCH_TIME:
            fetch_time = FETCH_TIME
        else:
            fetch_time = '24 hours'

        last_run = demisto.getLastRun()
        if not last_run:
            last_run = {}
        if 'time' not in last_run:
            time, _ = parse_date_range(fetch_time, date_format='%Y-%m-%dT%H:%M:%S.%fZ')
        else:
            time = last_run['time']

        current_time = datetime.strptime(time, '%Y-%m-%dT%H:%M:%S.%fZ')
        triggered_time = '[{},)'.format(datetime.strftime(current_time, '%Y-%m-%d %H:%M:%S'))
        max_time = current_time

        rule_ids = []  # type: list

        for rule in rule_names:
            rules = json.loads(get_alert_rules(rule))
            if rules and 'data' in rules:
                rule_ids += map(lambda r: r['id'], rules['data'].get('results', []))

        all_alerts = []  # type: list
        if rule_ids:
            for rule_id in rule_ids:
                alerts = json.loads(get_alerts(rule_id, triggered_time))
                if alerts and 'data' in alerts:
                    all_alerts += alerts['data'].get('results', [])
        else:
            alerts = json.loads(get_alerts(triggered=triggered_time))
            if alerts and 'data' in alerts:
                all_alerts += alerts['data'].get('results', [])

        incidents = []
        for alert in all_alerts:
            alert_time = datetime.strptime(alert['triggered'], '%Y-%m-%dT%H:%M:%S.%fZ')
            # The API returns also alerts that are triggered in the same time
            if alert_time > current_time:
                alert_data = json.loads(get_alert(alert['id']))
                if alert_data and 'data' in alert_data:
                    alert = alert_data['data']
                incidents.append({
                    'name': 'Recorded Future Alert - ' + alert['title'],
                    'occurred': datetime.strftime(alert_time, '%Y-%m-%dT%H:%M:%SZ'),
                    'rawJSON': json.dumps(alert)
                })

                if alert_time > max_time:
                    max_time = alert_time

        demisto.incidents(incidents)
        demisto.setLastRun({
            'time': datetime.strftime(max_time, '%Y-%m-%dT%H:%M:%S.%fZ')
        })


    ''' EXECUTION CODE '''
    LOG('command is %s' % (demisto.command(),))

    try:
        if demisto.command() == 'test-module':
            try:
                res = json.loads(ip_lookup('8.8.8.8'))
            except Exception as ex:
                return_error('Failed to get response. The URL might be incorrect.' + str(ex))
            demisto.results('ok')

        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()

        elif demisto.command() == 'domain':
            domain_command()

        elif demisto.command() == 'url':
            url_command()

        elif demisto.command() == 'ip':
            ip_command()

        elif demisto.command() == 'file':
            file_command()

        elif demisto.command() == 'recorded-future-get-related-entities':
            get_related_entities_command()

        elif demisto.command() == 'recorded-future-get-threats-hash':
            hashlist_command()

        elif demisto.command() == 'recorded-future-get-threats-ip':
            iplist_command()

        elif demisto.command() == 'recorded-future-get-threats-url':
            urllist_command()

        elif demisto.command() == 'recorded-future-get-threats-domain':
            domainlist_command()

        elif demisto.command() == 'recorded-future-get-threats-vulnerabilities':
            vulnlist_command()

        elif demisto.command() == 'recorded-future-get-url-risklist':
            get_url_risklist_command()

        elif demisto.command() == 'recorded-future-get-domain-risklist':
            get_domain_risklist_command()

        elif demisto.command() == 'recorded-future-get-ip-risklist':
            get_ip_risklist_command()

        elif demisto.command() == 'recorded-future-get-vulnerability-risklist':
            get_vulnerability_risklist_command()

        elif demisto.command() == 'recorded-future-get-hash-risklist':
            get_hash_risklist_command()

        elif demisto.command() == 'recorded-future-get-domain-riskrules':
            get_domain_riskrules_command()

        elif demisto.command() == 'recorded-future-get-hash-riskrules':
            get_hash_riskrules_command()

        elif demisto.command() == 'recorded-future-get-ip-riskrules':
            get_ip_riskrules_command()

        elif demisto.command() == 'recorded-future-get-url-riskrules':
            get_url_riskrules_command()

        elif demisto.command() == 'recorded-future-get-vulnerability-riskrules':
            get_vulnerability_riskrules_command()

        elif demisto.command() == 'recorded-future-get-alert-rules':
            get_alert_rules_command()

        elif demisto.command() == 'recorded-future-get-alerts':
            get_alerts_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
  subtype: python2
  type: python
system: true
