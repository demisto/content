category: Network Security
commonfields:
  id: FortiGate
  version: -1
configuration:
- defaultvalue: ""
  display: Server URL (e.g. https://192.168.0.1)
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: Account username
  name: credentials
  required: true
  type: 9
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Manage FortiGate Firewall
display: FortiGate
image: data:image/png;base64,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
name: FortiGate
script:
  commands:
  - arguments:
    - defaultValue: root
      description: Filter by address (ip or domain)
      name: address
    - description: Filter by address name
      name: name
    description: Get all address objects from your firewall
    name: fortigate-get-addresses
    outputs:
    - contextPath: Fortigate.Address.Name
      description: Address name
      type: string
    - contextPath: Fortigate.Address.Subnet
      description: Address subnet
      type: string
    - contextPath: Fortigate.Address.StartIP
      description: Address object start IP address
      type: string
    - contextPath: Fortigate.Address.EndIP
      description: Address object end IP address
      type: string
  - arguments:
    - description: Filter by group name
      name: name
    description: Get information about FortiGate service groups
    name: fortigate-get-service-groups
    outputs:
    - contextPath: Fortigate.ServiceGroup.Name
      description: Service Group name
      type: string
    - contextPath: Fortigate.ServiceGroup.Member.Name
      description: Service Group member name
      type: string
  - arguments:
    - description: Group name to update
      name: groupName
      required: true
    - description: Service name to update from the group (If providing data argument
        value does not matter)
      name: serviceName
      required: true
    - auto: PREDEFINED
      description: Action to take on the service
      name: action
      predefined:
      - add
      - remove
      required: true
    description: Update a FortiGate service group
    name: fortigate-update-service-group
    outputs:
    - contextPath: Fortigate.ServiceGroup.Name
      description: Service group name
      type: string
    - contextPath: Fortigate.ServiceGroup.Service.Name
      description: Service name
      type: string
  - arguments:
    - description: Group name of the group you would like to delete
      name: groupName
      required: true
    description: Delete a service group from FortiGate
    name: fortigate-delete-service-group
    outputs:
    - contextPath: Fortigate.ServiceGroup.Name
      description: Service group name
      type: string
    - contextPath: Fortigate.ServiceGroup.Deleted
      description: Was service group deleted
      type: boolean
  - arguments:
    - description: Service name
      name: serviceName
    description: Get information about a service from FortiGate Firewall
    name: fortigate-get-firewall-service
    outputs:
    - contextPath: Fortigate.Service.Name
      description: Service name
      type: string
    - contextPath: Fortigate.Service.Ports.TCP
      description: TCP Port range included for the service
      type: string
    - contextPath: Fortigate.Service.Ports.UDP
      description: UDP Port range included for the service
      type: string
  - arguments:
    - description: Service name
      name: serviceName
      required: true
    - description: 'TCP Port range for the service. Example: 100-120 or simply a single
        port.'
      name: tcpRange
    - description: 'UDP Port range for the service. Example: 100-120, or simply a
        single port.'
      name: udpRange
    description: Create a service in FortiGate firewall
    name: fortigate-create-firewall-service
    outputs:
    - contextPath: Fortigate.Service.Name
      description: Service name
      type: string
    - contextPath: Fortigate.Service.Ports.TCP
      description: TCP Port range included for the service
      type: string
    - contextPath: Fortigate.Service.Ports.UDP
      description: UDP Port range included for the service
      type: string
  - arguments:
    - description: Policy name
      name: policyName
    - description: Policy ID
      name: policyID
    description: Get information about a firewall policy on FortiGate
    name: fortigate-get-policy
    outputs:
    - contextPath: Fortigate.Policy.Name
      description: Policy name
      type: string
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: number
    - contextPath: Fortigate.Policy.Description
      description: Policy description
      type: string
    - contextPath: Fortigate.Policy.Status
      description: The status of the policy (Enabled or Disabled)
      type: string
    - contextPath: Fortigate.Policy.Source
      description: Source address
      type: string
    - contextPath: Fortigate.Policy.Destination
      description: Destination address
      type: string
    - contextPath: Fortigate.Policy.Service
      description: Service for the policy (for example HTTP)
      type: string
    - contextPath: Fortigate.Policy.Action
      description: Policy action (Allow, Block)
      type: string
    - contextPath: Fortigate.Policy.Log
      description: Does the policy log the traffic or not
      type: string
    - contextPath: Fortigate.Policy.Security
      description: Policy attached security profile
      type: string
  - arguments:
    - description: Policy ID
      name: policyID
      required: true
    - auto: PREDEFINED
      description: Field parameter to update
      name: field
      predefined:
      - description
      - status
      - source
      - destination
      - service
      - action
      - log
      - nat
      required: true
    - description: Value of field parameter to update
      name: value
      required: true
    - auto: PREDEFINED
      description: Whether to keep the original data or not. Only relevant if the
        updated field is "source" or "destination". If the supplied value is 'True',
        the current data will not be replaced. Instead, the supplied addresses will
        be added / removed from the existing data.
      name: keep_original_data
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether to add or remove the supplied addresses from the existing
        data. Only relevant in case the field to update is "source" or "destination",
        and keep_original_data is specified to 'True'.
      name: add_or_remove
      predefined:
      - add
      - remove
    description: Update a firewall policy on FortiGate
    execution: true
    name: fortigate-update-policy
    outputs:
    - contextPath: Fortigate.Policy.Name
      description: Policy name
      type: string
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: number
    - contextPath: Fortigate.Policy.Description
      description: Policy description
      type: string
    - contextPath: Fortigate.Policy.Status
      description: The status of the policy (Enabled or Disabled)
      type: string
    - contextPath: Fortigate.Policy.Source
      description: Source address
      type: string
    - contextPath: Fortigate.Policy.Destination
      description: Destination address
      type: string
    - contextPath: Fortigate.Policy.Service
      description: Service for the policy (for example HTTP)
      type: string
    - contextPath: Fortigate.Policy.Action
      description: Policy action (Allow, Block)
      type: string
    - contextPath: Fortigate.Policy.Log
      description: Does the policy log the traffic or not
      type: boolean
  - arguments:
    - description: Policy name
      name: policyName
      required: true
    - description: Description for the policy
      name: description
    - description: 'Source interface  (examples : port1, port2 or port3)'
      name: sourceIntf
      required: true
    - description: 'Destination interface (examples : port1, port2 or port3)'
      name: dstIntf
      required: true
    - description: 'Source IP address, range or domain (examples : all, update.microsoft.com)'
      name: source
      required: true
    - description: 'Destination IP address, range or domain (examples : all, update.microsoft.com)'
      name: destination
      required: true
    - description: Service for the policy (for example HTTP)
      name: service
      required: true
    - auto: PREDEFINED
      description: Action to take
      name: action
      predefined:
      - accept
      - block
      required: true
    - auto: PREDEFINED
      defaultValue: enable
      description: policy status
      name: status
      predefined:
      - enable
      - disable
    - auto: PREDEFINED
      defaultValue: enable
      description: Will the policy log the traffic or not
      name: log
      predefined:
      - all
      - utm
      - disable
    - auto: PREDEFINED
      defaultValue: enable
      description: enable/disable NAT
      name: nat
      predefined:
      - enable
      - disable
    description: Create a firewall policy (rule) on FortiGate
    execution: true
    name: fortigate-create-policy
    outputs:
    - contextPath: Fortigate.Policy.Name
      description: Policy name
      type: string
    - contextPath: Fortigate.Policy.Description
      description: Policy description
      type: string
    - contextPath: Fortigate.Policy.Status
      description: The status of the policy (Enabled or Disabled)
      type: string
    - contextPath: Fortigate.Policy.Source.Address
      description: Source address
      type: string
    - contextPath: Fortigate.Policy.Destination.Address
      description: Destination address
      type: string
    - contextPath: Fortigate.Policy.Service
      description: Service for the policy (for example HTTP)
      type: string
    - contextPath: Fortigate.Policy.Action
      description: Policy action (Allow, Block)
      type: string
    - contextPath: Fortigate.Policy.Log
      description: Does the policy log the traffic or not
      type: boolean
    - contextPath: Fortigate.Policy.Source.Intf
      description: Source interface
      type: string
    - contextPath: Fortigate.Policy.Destination.Intf
      description: Destination interface
      type: string
    - contextPath: Fortigate.Policy.NAT
      description: Policy NAT
      type: string
  - arguments:
    - description: Policy ID
      name: policyID
      required: true
    - auto: PREDEFINED
      description: Position for the policy (before or after)
      name: position
      predefined:
      - before
      - after
      required: true
    - description: The ID of the policy being used as a positional anchor
      name: neighbor
      required: true
    description: Move a firewall policy rule to a different position
    name: fortigate-move-policy
    outputs:
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: number
    - contextPath: Fortigate.Policy.Moved
      description: Was policy moved successfully
      type: boolean
  - arguments:
    - description: Policy ID
      name: policyID
      required: true
    description: Delete a policy from FortiGate firewall
    execution: true
    name: fortigate-delete-policy
    outputs:
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: number
    - contextPath: Fortigate.Policy.Deleted
      description: Was policy deleted successfully
      type: boolean
  - arguments:
    - description: Filter by group name
      name: groupName
    description: Get information about address groups from FortiGate
    name: fortigate-get-address-groups
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address Group name
      type: string
    - contextPath: Fortigate.AddressGroup.Member.Name
      description: Address Group member name
      type: string
    - contextPath: Fortigate.AddressGroup.UUID
      description: Address Group UUID
      type: string
  - arguments:
    - description: Group name
      name: groupName
      required: true
    - description: An address to add or remove from the group (If providing data argument,
        value does not matter)
      name: address
      required: true
    - auto: PREDEFINED
      description: Action to take on the service
      name: action
      predefined:
      - add
      - remove
      required: true
    description: Update an address group on FortiGate firewall
    name: fortigate-update-address-group
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address group name
      type: string
    - contextPath: Fortigate.AddressGroup.Address.Name
      description: Address name
      type: string
    - contextPath: Fortigate.AddressGroup.UUID
      description: Address group UUID
  - arguments:
    - description: Group name
      name: groupName
      required: true
    - description: Address member to add to the group
      name: address
      required: true
    description: Create an address group in FortiGate firewall
    name: fortigate-create-address-group
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address group name
      type: string
    - contextPath: Fortigate.AddressGroup.Address
      description: Address group member address
      type: string
  - arguments:
    - description: Address group name
      name: name
      required: true
    description: Delete an address group from FortiGate firewall
    name: fortigate-delete-address-group
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address group name
      type: string
    - contextPath: Fortigate.AddressGroup.Deleted
      description: Was address group deleted
      type: boolean
  - arguments:
    - description: CSV list of IP addresses to ban. IPv4 and IPv6 addresses are supported.
        For example, "1.1.1.1,6.7.8.9".
      isArray: true
      name: ip_address
      required: true
    - description: Time until ban expires in seconds. 0 for indefinite ban.
      name: expiry
    description: Adds IP addresses to the banned list.
    name: fortigate-ban-ip
  - arguments:
    - description: CSV list of banned user IP addresses to clear. IPv4 and IPv6 addresses
        are supported. For example, "1.1.1.1,6.7.8.9".
      isArray: true
      name: ip_address
      required: true
    description: Clears a list of specific banned IP addresses.
    name: fortigate-unban-ip
  - arguments: []
    description: Returns a list of banned IP addresses.
    name: fortigate-get-banned-ips
    outputs:
    - contextPath: Fortigate.BannedIP.IP
      description: The IP address.
      type: string
    - contextPath: Fortigate.BannedIP.Created
      description: Date/time the IP address was added to the banned list.
      type: string
    - contextPath: Fortigate.BannedIP.Expires
      description: Date/time the IP address expires from the banned list.
      type: string
    - contextPath: Fortigate.BannedIP.Source
      description: Source of the ban.
      type: string
  runonce: false
  script: |2-


    ''' IMPORTS '''

    import json
    import requests

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USER_NAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    SERVER = demisto.params()['server'][:-1] if (demisto.params()['server'] and demisto.params()
                                                 ['server'].endswith('/')) else demisto.params()['server']
    USE_SSL = not demisto.params().get('unsecure', False)
    BASE_URL = SERVER + '/api/v2/'


    # remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' HELPER FUNCTIONS '''


    def login():
        """
        Due to token not providing the right level of access, we are going to create a session
        and inject into its headers the csrf token provided with the service.
        This won't work with usual requests as the session must be kept alive during this time.
        """
        # create session.
        session = requests.session()
        url_suffix = '/logincheck'
        params = {
            'username': USER_NAME,
            'secretkey': PASSWORD,
            'ajax': 1
        }
        session.post(SERVER + url_suffix, data=params, verify=USE_SSL)  # type: ignore
        # check for the csrf token in cookies we got, add it to headers of session,
        # or else we can't perform HTTP request that is not get.
        for cookie in session.cookies:
            if cookie.name == 'ccsrftoken':  # type: ignore
                csrftoken = cookie.value[1:-1]  # type: ignore
                session.headers.update({'X-CSRFTOKEN': csrftoken})
        return session


    SESSION = login()


    def http_request(method, url_suffix, params={}, data=None):

        res = SESSION.request(
            method,
            BASE_URL + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data
        )
        if res.status_code not in {200}:
            return_error('Error in API call to FortiGate [%d] - %s' % (res.status_code, res.reason))
        if method.upper() != 'GET':
            return res.status_code
        return res.json()


    def does_path_exist(target_url):
        """
        Check if the path itself already exists in the instance, if it does we will not want to resume with certain requests.
        """
        res = SESSION.get(BASE_URL + target_url, verify=USE_SSL)
        if res.status_code == 200:
            return True
        return False


    def create_addr_string(list_of_addr_data_dicts):
        addr_string = ""
        for addr_index in range(0, len(list_of_addr_data_dicts)):
            cur_addr_data = list_of_addr_data_dicts[addr_index]
            cur_addr_name = cur_addr_data.get("name")
            if addr_index == len(list_of_addr_data_dicts) - 1:
                addr_string += "{}".format(cur_addr_name)
            else:
                addr_string += "{}\n".format(cur_addr_name)
        return addr_string


    def convert_arg_to_int(arg_str, arg_name_str):
        try:
            arg_int = int(arg_str)
        except ValueError:
            return_error("Error: {0} must have an integer value.".format(arg_name_str))
        return arg_int


    def prettify_date(date_string):
        """
        This function receives a string representing a date, for example 2018-07-28T10:47:55.000Z.
        It returns the same date in a readable format - for example, 2018-07-28 10:47:55.
        """
        date_string = date_string[:-5]  # remove the .000z at the end
        date_prettified = date_string.replace("T", " ")
        return date_prettified


    def create_banned_ips_entry_context(ips_data_array):
        ips_contexts_array = []
        for ip_data in ips_data_array:
            current_ip_context = {
                "IP": ip_data.get("ip_address"),
                "Source": ip_data.get("source")
            }
            if ip_data.get("expires"):
                expiration_in_ms = 1000 * int(ip_data.get("expires", 0))
                current_ip_context["Expires"] = prettify_date(timestamp_to_datestring(expiration_in_ms))
            if ip_data.get("created"):
                creation_in_ms = 1000 * int(ip_data.get("created", 0))
                current_ip_context["Created"] = prettify_date(timestamp_to_datestring(creation_in_ms))
            ips_contexts_array.append(current_ip_context)
        return ips_contexts_array


    def create_banned_ips_human_readable(entry_context):
        banned_ip_headers = ["IP", "Created", "Expires", "Source"]
        human_readable = tableToMarkdown("Banned IP Addresses", entry_context, banned_ip_headers)
        return human_readable


    def str_to_bool(str_representing_bool):
        return str_representing_bool and str_representing_bool.lower() == 'true'


    def generate_src_or_dst_request_data(policy_id, policy_field, policy_field_value, keep_original_data, add_or_remove):
        address_list_for_request = policy_field_value.split(",")
        if str_to_bool(keep_original_data):
            policy_data = get_policy_request(policy_id)[0]  # the return value is an array with one element
            existing_adresses_list = policy_data.get(policy_field)
            existing_adresses_list = [address_data["name"] for address_data in existing_adresses_list]
            if add_or_remove.lower() == "add":
                for address in existing_adresses_list:
                    if address not in address_list_for_request:
                        address_list_for_request.append(address)
            else:
                address_list_for_request = [address for address in existing_adresses_list if address not in address_list_for_request]

        address_data_dicts_for_request = policy_addr_array_from_arg(address_list_for_request, False)
        return address_data_dicts_for_request


    def logout(session):
        """
        Due to limited amount of simultaneous connections we log out after each API request.
        Simple post request to /logout endpoint without params.
        """
        url_suffix = '/logout'
        params = {}  # type: dict
        session.post(SERVER + url_suffix, data=params, verify=USE_SSL)


    def policy_addr_array_from_arg(policy_addr_data, is_data_string=True):
        # if the data isn't in string format, it's already an array and requires no formatting
        policy_adr_str_array = policy_addr_data.split(",") if is_data_string else policy_addr_data
        policy_addr_dict_array = []
        for src_addr_name in policy_adr_str_array:
            cur_addr_dict = {
                "name": src_addr_name
            }
            policy_addr_dict_array.append(cur_addr_dict)
        return policy_addr_dict_array


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Perform basic login and logout operation, validate connection.
        """
        http_request('GET', 'cmdb/system/vdom')
        return True


    def get_addresses_command():
        contents = []
        context = {}
        addresses_context = []
        address = demisto.args().get('address')
        name = demisto.args().get('name', '')

        addresses = get_addresses_request(address, name)
        for address in addresses:
            subnet = address.get('subnet')
            if subnet:
                subnet = subnet.replace(" ", "-")
            contents.append({
                'Name': address.get('name'),
                'Subnet': subnet,
                'StartIP': address.get('start-ip'),
                'EndIP': address.get('end-ip')
            })
            addresses_context.append({
                'Name': address.get('name'),
                'Subnet': subnet,
                'StartIP': address.get('start-ip'),
                'EndIP': address.get('end-ip')
            })

        context['Fortigate.Address(val.Name && val.Name === obj.Name)'] = addresses_context
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate addresses', contents),
            'EntryContext': context
        })


    def get_addresses_request(address, name):
        uri_suffix = 'cmdb/firewall/address/' + name
        params = {
            'vdom': address
        }
        response = http_request('GET', uri_suffix, params)
        # Different structure if we choose all domains
        if address == '*':
            return response[0].get('results')
        return response.get('results')


    def get_service_groups_command():
        contents = []
        context = {}
        service_groups_context = []
        name = demisto.args().get('name', '')

        service_groups = get_service_groups_request(name)
        for service_group in service_groups:
            service_group_members = []
            members = service_group.get('member')
            for member in members:
                service_group_members.append(member.get('name'))
            contents.append({
                'Name': service_group.get('name'),
                'Members': service_group_members
            })
            service_groups_context.append({
                'Name': service_group.get('name'),
                'Member': {'Name': service_group_members}
            })

        context['Fortigate.ServiceGroup(val.Name && val.Name === obj.Name)'] = service_groups_context
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate service groups', contents),
            'EntryContext': context
        })


    def get_service_groups_request(name):
        uri_suffix = 'cmdb/firewall.service/group/' + name
        response = http_request('GET', uri_suffix)
        return response.get('results')


    def update_service_group_command():
        context = {}

        group_name = demisto.args().get('groupName')
        service_name = demisto.args().get('serviceName')
        action = demisto.args().get('action')
        if action not in ['add', 'remove']:
            return_error('Action must be add or remove')

        old_service_groups = get_service_groups_request(group_name)
        service_group_members = []  # type: list
        new_service_group_members = []  # type: list

        if isinstance(old_service_groups, list):
            old_service_group = old_service_groups[0]
            service_group_members = old_service_group.get('member')
        if action == 'add':
            service_group_members.append({'name': service_name})
            new_service_group_members = service_group_members
        if action == 'remove':
            for service_group_member in service_group_members:
                if service_group_member.get('name') != service_name:
                    new_service_group_members.append(service_group_member)

        update_service_group_request(group_name, new_service_group_members)
        service_group = get_service_groups_request(group_name)[0]

        service_group_members = []
        members = service_group.get('member')
        for member in members:
            service_group_members.append(member.get('name'))

        contents = {
            'Name': service_group.get('name'),
            'Services': service_group_members
        }

        service_group_context = {
            'Name': service_group.get('name'),
            'Service': {
                'Name': service_group_members
            }
        }

        context['Fortigate.ServiceGroup(val.Name && val.Name === obj.Name)'] = service_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate service group: ' + group_name + ' was successfully updated', contents),
            'EntryContext': context
        })


    def update_service_group_request(group_name, members_list):
        uri_suffix = 'cmdb/firewall.service/group/' + group_name
        if not does_path_exist(uri_suffix):
            return_error('Requested service group ' + group_name + ' does not exist in Firewall config.')

        payload = {
            'member': members_list
        }

        response = http_request('PUT', uri_suffix, {}, json.dumps(payload))
        return response


    def delete_service_group_command():
        context = {}
        group_name = demisto.args().get('groupName').encode('utf-8')

        delete_service_group_request(group_name)

        service_group_context = {
            'Name': group_name,
            'Deleted': True
        }

        contents = service_group_context
        context['Fortigate.ServiceGroup(val.Name && val.Name === obj.Name)'] = service_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate service group: ' + group_name + ' was deleted successfully', contents),
            'EntryContext': context
        })


    def delete_service_group_request(group_name):
        uri_suffix = 'cmdb/firewall.service/group/' + group_name
        response = http_request('DELETE', uri_suffix)
        return response


    def get_firewall_service_command():
        contents = []
        context = {}
        service_context = []
        service_name = demisto.args().get('serviceName', '')
        service_title = service_name
        if not service_name:
            service_title = 'all services'

        services = get_firewall_service_request(service_name)
        for service in services:
            contents.append({
                'Name': service.get('name'),
                'Ports': {
                    'TCP': service.get('tcp-portrange'),
                    'UDP': service.get('udp-portrange')
                }
            })
            service_context.append({
                'Name': service.get('name'),
                'Ports': {
                    'TCP': service.get('tcp-portrange'),
                    'UDP': service.get('udp-portrange')
                }
            })

        context['Fortigate.Service(val.Name && val.Name === obj.Name)'] = service_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate firewall services ' + service_title, contents),
            'EntryContext': context
        })


    def get_firewall_service_request(service_name):
        uri_suffix = 'cmdb/firewall.service/custom/' + service_name
        response = http_request('GET', uri_suffix)
        return response.get('results')


    def create_firewall_service_command():
        contents = []
        context = {}
        service_context = []
        service_name = demisto.args().get('serviceName')
        tcp_range = demisto.args().get('tcpRange', '')
        udp_range = demisto.args().get('udpRange', '')

        create_firewall_service_request(service_name, tcp_range, udp_range)

        contents.append({
            'Name': service_name,
            'Ports': {
                'TCP': tcp_range,
                'UDP': udp_range
            }
        })
        service_context.append({
            'Name': service_name,
            'Ports': {
                'TCP': tcp_range,
                'UDP': udp_range
            }
        })

        context['Fortigate.Service(val.Name && val.Name === obj.Name)'] = service_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate firewall service ' + service_name + ' created successfully', contents),
            'EntryContext': context
        })


    def create_firewall_service_request(service_name, tcp_range, udp_range):
        uri_suffix = 'cmdb/firewall.service/custom/'
        if does_path_exist(uri_suffix + service_name):
            return_error('Firewall service already exists.')

        payload = {
            'name': service_name,
            'tcp-portrange': tcp_range,
            'udp-portrange': udp_range
        }

        response = http_request('POST', uri_suffix, {}, json.dumps(payload))
        return response


    def ban_ip(ip_addresses_array, time_to_expire=0):
        uri_suffix = 'monitor/user/banned/add_users/'

        payload = {
            'ip_addresses': ip_addresses_array,
            'expiry': time_to_expire
        }

        response = http_request('POST', uri_suffix, data=json.dumps(payload))
        return response


    def ban_ip_command():
        ip_addresses_string = demisto.args()['ip_address']
        ip_addresses_array = argToList(ip_addresses_string)
        for ip_address in ip_addresses_array:
            if not is_ip_valid(ip_address, accept_v6_ips=True):
                return_error('Error: invalid IP address sent as argument.')

        time_to_expire = demisto.args().get('expiry')
        if time_to_expire:
            time_to_expire = convert_arg_to_int(time_to_expire, 'expiry')
        else:
            # The default time to expiration is 0, which means infinite time (It will remain banned).
            time_to_expire = 0

        response = ban_ip(ip_addresses_array, time_to_expire)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'IPs {0} banned successfully'.format(ip_addresses_string)
        })


    def unban_ip(ip_addresses_array):
        uri_suffix = 'monitor/user/banned/clear_users/'

        payload = {
            'ip_addresses': ip_addresses_array
        }
        response = http_request('POST', uri_suffix, data=json.dumps(payload))
        return response


    def unban_ip_command():
        ip_addresses_string = demisto.args()['ip_address']
        ip_addresses_array = argToList(ip_addresses_string)
        for ip_address in ip_addresses_array:
            if not is_ip_valid(ip_address, accept_v6_ips=True):
                return_error('Error: invalid IP address sent as argument.')

        response = unban_ip(ip_addresses_array)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'IPs {0} un-banned successfully'.format(ip_addresses_string)
        })


    def get_banned_ips():
        uri_suffix = 'monitor/user/banned/select/'
        response = http_request('GET', uri_suffix)
        return response


    def get_banned_ips_command():
        response = get_banned_ips()
        ips_data_array = response.get('results')
        entry_context = create_banned_ips_entry_context(ips_data_array)
        human_readable = create_banned_ips_human_readable(entry_context)
        return_outputs(
            raw_response=response,
            readable_output=human_readable,
            outputs={
                'Fortigate.BannedIP(val.IP===obj.IP)': entry_context
            }
        )


    def get_policy_command():
        contents = []
        context = {}
        policy_context = []
        policy_name = demisto.args().get('policyName')
        policy_id = demisto.args().get('policyID')
        policy_title = 'all policies'

        policies = get_policy_request(policy_id)

        for policy in policies:
            if policy_name == policy.get('name') or not policy_name:
                if policy_name or policy_id:
                    policy_title = policy.get('name')
                security_profiles = []
                all_security_profiles = [policy.get('webfilter-profile'), policy.get('ssl-ssh-profile'),
                                         policy.get('dnsfilter-profile'), policy.get('profile-protocol-options'),
                                         policy.get('profile-type'), policy.get('av-profile')]
                for security_profile in all_security_profiles:
                    if security_profile:
                        security_profiles.append(security_profile)

                src_address = policy.get('srcaddr')
                if src_address and isinstance(src_address, list) and isinstance(src_address[0], dict):
                    src_address = create_addr_string(src_address)
                dest_address = policy.get('dstaddr')
                if dest_address and isinstance(dest_address, list) and isinstance(dest_address[0], dict):
                    dest_address = create_addr_string(dest_address)
                service = policy.get('service')
                if service and isinstance(service, list) and isinstance(service[0], dict):
                    service = service[0].get('name')

                contents.append({
                    'Name': policy.get('name'),
                    'ID': int(policy.get('policyid')),
                    'Description': policy.get('comments'),
                    'Status': policy.get('status'),
                    'Source': src_address,
                    'Destination': dest_address,
                    'Service': service,
                    'Action': policy.get('action'),
                    'Log': policy.get('logtraffic'),
                    'Security': security_profiles,
                    'NAT': policy.get('nat')
                })
                policy_context.append({
                    'Name': policy.get('name'),
                    'ID': int(policy.get('policyid')),
                    'Description': policy.get('comments'),
                    'Status': policy.get('status'),
                    'Source': src_address,
                    'Destination': dest_address,
                    'Service': service,
                    'Action': policy.get('action'),
                    'Log': policy.get('logtraffic'),
                    'Security': security_profiles,
                    'NAT': policy.get('nat')
                })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy details for ' + policy_title, contents),
            'EntryContext': context
        })


    def get_policy_request(policy_id):
        uri_suffix = 'cmdb/firewall/policy/'
        if policy_id:
            uri_suffix = uri_suffix + policy_id + '/'
        # We have the option to filter only the data we need from each policy,
        # reducing by over 80% the amount of data we need to read.
        params = {
            'format': 'policyid|action|name|comments|status|service|logtraffic|srcaddr|'
                      'dstaddr|webfilter-profile|ssl-ssh-profile|dnsfilter-profile|'
                      'profile-protocol-options|profile-type|av-profile|nat'
        }
        response = http_request('GET', uri_suffix, params)
        return response.get('results')


    def update_policy_command():
        contents = []
        context = {}
        policy_context = []
        security_profiles = []

        policy_id = demisto.args().get('policyID')
        policy_field = demisto.args().get('field')
        policy_field_value = demisto.args().get('value')
        keep_original_data = demisto.args().get('keep_original_data')
        add_or_remove = demisto.args().get('add_or_remove')

        if keep_original_data and keep_original_data.lower() == 'true' and not add_or_remove:
            return_error('Error: add_or_remove must be specified if keep_original_data is true.')

        update_policy_request(policy_id, policy_field, policy_field_value, keep_original_data, add_or_remove)
        policy = get_policy_request(policy_id)[0]
        all_security_profiles = [policy.get('webfilter-profile'), policy.get('ssl-ssh-profile'), policy.get(
            'dnsfilter-profile'), policy.get('profile-protocol-options'), policy.get('profile-type'), policy.get('av-profile')]

        for security_profile in all_security_profiles:
            if security_profile:
                security_profiles.append(security_profile)

        src_address = policy.get('srcaddr')
        if src_address and isinstance(src_address, list) and isinstance(src_address[0], dict):
            src_address = src_address[0].get('name')
        dest_address = policy.get('dstaddr')
        if dest_address and isinstance(dest_address, list) and isinstance(dest_address[0], dict):
            dest_address = dest_address[0].get('name')
        service = policy.get('service')
        if service and isinstance(service, list) and isinstance(service[0], dict):
            service = service[0].get('name')

        contents.append({
            'Name': policy.get('name'),
            'ID': policy.get('policyid'),
            'Description': policy.get('comments'),
            'Status': policy.get('status'),
            'Source': src_address,
            'Destination': dest_address,
            'Service': service,
            'Action': policy.get('action'),
            'Log': policy.get('logtraffic'),
            'Security': security_profiles,
            'NAT': policy.get('nat')
        })
        policy_context.append({
            'Name': policy.get('name'),
            'ID': policy.get('policyid'),
            'Description': policy.get('comments'),
            'Status': policy.get('status'),
            'Source': src_address,
            'Destination': dest_address,
            'Service': service,
            'Action': policy.get('action'),
            'Log': policy.get('logtraffic'),
            'Security': security_profiles,
            'NAT': policy.get('nat')
        })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy ID ' + policy_id + ' has been updated successfully.', contents),
            'EntryContext': context
        })


    def update_policy_request(policy_id, policy_field, policy_field_value, keep_original_data, add_or_remove):
        uri_suffix = 'cmdb/firewall/policy/' + policy_id
        if not does_path_exist(uri_suffix):
            return_error('Requested policy ID ' + policy_id + ' does not exist in Firewall config.')

        field_to_api_key = {
            'description': 'comments',
            'source': 'srcaddr',
            'destination': 'dstaddr',
            'log': 'logtraffic'
        }

        if policy_field in field_to_api_key:
            policy_field = field_to_api_key[policy_field]

        if policy_field in {'srcaddr', 'dstaddr'}:
            policy_field_value = generate_src_or_dst_request_data(
                policy_id, policy_field, policy_field_value, keep_original_data, add_or_remove)

        payload = {
            'policyid': int(policy_id),
            'q_origin_key': int(policy_id),
            policy_field: policy_field_value
        }

        response = http_request('PUT', uri_suffix, {}, json.dumps(payload))
        return response


    def create_policy_command():
        contents = []
        context = {}
        policy_context = []

        policy_name = demisto.args().get('policyName')
        policy_description = demisto.args().get('description', '')
        policy_srcintf = demisto.args().get('sourceIntf')
        policy_dstintf = demisto.args().get('dstIntf')
        policy_source_address = policy_addr_array_from_arg(demisto.args().get('source'))
        policy_destination_address = policy_addr_array_from_arg(demisto.args().get('destination'))
        policy_service = demisto.args().get('service')
        policy_action = demisto.args().get('action')
        policy_status = demisto.args().get('status')
        policy_log = demisto.args().get('log')
        policy_nat = demisto.args().get('nat')

        create_policy_request(policy_name, policy_description, policy_srcintf, policy_dstintf,
                              policy_source_address, policy_destination_address, policy_service,
                              policy_action, policy_status, policy_log, policy_nat)
        contents.append({
            'Name': policy_name,
            'Description': policy_description,
            'Status': policy_status,
            'Service': policy_service,
            'Action': policy_action,
            'Log': policy_log,
            'Source': {
                'Interface': policy_srcintf,
                'Address': policy_source_address
            },
            'Destination': {
                'Interface': policy_dstintf,
                'Address': policy_destination_address
            },
            'NAT': policy_nat
        })

        policy_context.append({
            'Name': policy_name,
            'Description': policy_description,
            'Status': policy_status,
            'Service': policy_service,
            'Action': policy_action,
            'Log': policy_log,
            'Source': {
                'Interface': policy_srcintf,
                'Address': policy_source_address
            },
            'Destination': {
                'Interface': policy_dstintf,
                'Address': policy_destination_address
            },
            'NAT': policy_nat
        })

        context['Fortigate.Policy(val.Name && val.Name === obj.Name)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy ' + policy_name + ' created successfully', contents),
            'EntryContext': context
        })


    def create_policy_request(policy_name, policy_description, policy_srcintf, policy_dstintf,
                              policy_source_address, policy_destination_address, policy_service,
                              policy_action, policy_status, policy_log, policy_nat):

        uri_suffix = 'cmdb/firewall/policy/'

        payload = {
            'json': {
                'name': policy_name,
                'srcintf': [{'name': policy_srcintf}],
                'dstintf': [{'name': policy_dstintf}],
                'srcaddr': policy_source_address,
                'dstaddr': policy_destination_address,
                'action': policy_action,
                'status': policy_status,
                'schedule': 'always',
                'service': [{'name': policy_service}],
                'comments': policy_description,
                'logtraffic': policy_log,
                'nat': policy_nat
            }
        }

        response = http_request('POST', uri_suffix, {}, json.dumps(payload))
        return response


    def move_policy_command():
        contents = []
        context = {}
        policy_id = demisto.args().get('policyID')
        position = demisto.args().get('position')
        neighbour = demisto.args().get('neighbor')

        move_policy_request(policy_id, position, neighbour)

        policy_context = {
            'ID': int(policy_id),
            'Moved': True
        }
        contents.append({
            'ID': policy_id,
            'Moved': True
        })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy with ID ' + policy_id + ' moved successfully', contents),
            'EntryContext': context
        })


    def move_policy_request(policy_id, position, neighbour):
        uri_suffix = 'cmdb/firewall/policy/' + policy_id
        params = {
            'action': 'move',
            position: neighbour
        }

        response = http_request('PUT', uri_suffix, params)
        return response


    def delete_policy_command():
        contents = []
        context = {}
        policy_id = demisto.args().get('policyID')

        delete_policy_request(policy_id)

        policy_context = {
            'ID': policy_id,
            'Deleted': True
        }
        contents.append({
            'ID': policy_id,
            'Deleted': True
        })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy with ID ' + policy_id + ' deleted successfully', contents),
            'EntryContext': context
        })


    def delete_policy_request(policy_id):
        uri_suffix = 'cmdb/firewall/policy/' + policy_id
        response = http_request('DELETE', uri_suffix)
        return response


    def get_address_groups_command():
        contents = []
        context = {}
        address_groups_context = []
        address_group_name = demisto.args().get('groupName', '')
        title = address_group_name if address_group_name else 'all'

        address_groups = get_address_groups_request(address_group_name)
        for address_group in address_groups:
            members = address_group.get('member')
            members_list = []
            for member in members:
                members_list.append(member.get('name'))
            contents.append({
                'Name': address_group.get('name'),
                'Members': members_list,
                'UUID': address_group.get('uuid')
            })
            address_groups_context.append({
                'Name': address_group.get('name'),
                'Member': {
                    'Name': members_list
                },
                'UUID': address_group.get('uuid')
            })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_groups_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address groups ' + title, contents),
            'EntryContext': context
        })


    def get_address_groups_request(address_group_name):
        uri_suffix = 'cmdb/firewall/addrgrp/' + address_group_name
        response = http_request('GET', uri_suffix)
        return response.get('results')


    def update_address_group_command():
        contents = []
        context = {}
        address_group_context = []
        group_name = demisto.args().get('groupName', '')
        address = demisto.args().get('address', '')
        action = demisto.args().get('action')
        if action not in ['add', 'remove']:
            return_error('Action must be add or remove')

        old_address_groups = get_address_groups_request(group_name)
        address_group_members = []  # type: list
        new_address_group_members = []  # type: list

        if isinstance(old_address_groups, list):
            old_address_group = old_address_groups[0]
            address_group_members = old_address_group.get('member')
        if action == 'add':
            address_group_members.append({'name': address})
            new_address_group_members = address_group_members
        if action == 'remove':
            for address_group_member in address_group_members:
                if address_group_member.get('name') != address:
                    new_address_group_members.append(address_group_member)

        update_address_group_request(group_name, new_address_group_members)
        address_group = get_address_groups_request(group_name)[0]
        members = address_group.get('member')
        members_list = []
        for member in members:
            members_list.append(member.get('name'))
        contents.append({
            'Name': address_group.get('name'),
            'Members': members_list,
            'UUID': address_group.get('uuid')
        })
        address_group_context.append({
            'Name': address_group.get('name'),
            'Address': {
                'Name': members_list
            },
            'UUID': address_group.get('uuid')
        })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address group ' + group_name + ' updated successfully', contents),
            'EntryContext': context
        })


    def update_address_group_request(group_name, new_address_group_members):
        uri_suffix = 'cmdb/firewall/addrgrp/' + group_name
        # Check whether target object already exists
        if not does_path_exist(uri_suffix):
            return_error('Requested address group' + group_name + 'does not exist in Firewall config.')
        payload = {
            'member': new_address_group_members
        }
        result = http_request('PUT', uri_suffix, {}, json.dumps(payload))
        return result


    def create_address_group_command():
        contents = []
        context = {}
        address_group_context = []
        group_name = demisto.args().get('groupName', '')
        address = demisto.args().get('address', '')

        create_address_group_request(group_name, address)

        contents.append({
            'Name': group_name,
            'Address': address,
        })
        address_group_context.append({
            'Name': group_name,
            'Address': address
        })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address group ' + group_name + ' created successfully', contents),
            'EntryContext': context
        })


    def create_address_group_request(group_name, address):
        uri_suffix = 'cmdb/firewall/addrgrp/'
        if does_path_exist(uri_suffix + group_name):
            return_error('Address group already exists.')
        payload = {
            'name': group_name, 'member': [{'name': address}]
        }
        result = http_request('POST', uri_suffix, {}, json.dumps(payload))
        return result


    def delete_address_group_command():
        contents = []
        context = {}
        address_group_context = []
        name = demisto.args().get('name', '')

        delete_address_group_request(name)

        contents.append({
            'Name': name,
            'Deleted': True
        })
        address_group_context.append({
            'Name': name,
            'Deleted': True
        })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address group ' + name + ' deleted successfully', contents),
            'EntryContext': context
        })


    def delete_address_group_request(name):
        uri_suffix = 'cmdb/firewall/addrgrp/' + name
        response = http_request('DELETE', uri_suffix)
        return response


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
        elif demisto.command() == 'fortigate-get-addresses':
            get_addresses_command()
        elif demisto.command() == 'fortigate-get-service-groups':
            get_service_groups_command()
        elif demisto.command() == 'fortigate-update-service-group':
            update_service_group_command()
        elif demisto.command() == 'fortigate-delete-service-group':
            delete_service_group_command()
        elif demisto.command() == 'fortigate-get-firewall-service':
            get_firewall_service_command()
        elif demisto.command() == 'fortigate-create-firewall-service':
            create_firewall_service_command()
        elif demisto.command() == 'fortigate-get-policy':
            get_policy_command()
        elif demisto.command() == 'fortigate-update-policy':
            update_policy_command()
        elif demisto.command() == 'fortigate-create-policy':
            create_policy_command()
        elif demisto.command() == 'fortigate-move-policy':
            move_policy_command()
        elif demisto.command() == 'fortigate-delete-policy':
            delete_policy_command()
        elif demisto.command() == 'fortigate-get-address-groups':
            get_address_groups_command()
        elif demisto.command() == 'fortigate-update-address-group':
            update_address_group_command()
        elif demisto.command() == 'fortigate-create-address-group':
            create_address_group_command()
        elif demisto.command() == 'fortigate-delete-address-group':
            delete_address_group_command()
        elif demisto.command() == 'fortigate-ban-ip':
            ban_ip_command()
        elif demisto.command() == 'fortigate-unban-ip':
            unban_ip_command()
        elif demisto.command() == 'fortigate-get-banned-ips':
            get_banned_ips_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise

    finally:
        logout(SESSION)
  subtype: python2
  type: python
system: true
