commonfields:
  id: CTIX_V3
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: CTIX_V3
display: CTIX_V3
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: This is Cyware Threat Intelligence eXhange(CTIX) integration which enriches
  IP/Domain/URL/File Data.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: Cyware Labs
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [connector-dev@cyware.com](mailto:connector-dev@cyware.com)
  - **URL**: [https://cyware.com/](https://cyware.com/)
  ***
  1. Navigate to Administration > Integrations management > CTIX Integrators.
  2. Click “Add New” to create and configure a new integration instance and download the key files.
  3. Login to the Cortex XSOAR application and go to the App Configuration page.
  4. Fill in the following details.
      a. Name: Give a name for the integration instance.
      b. Endpoint URL: Enter the endpoint URL of your CTIX Instance. The Endpoint URL can be generated by a licensed user from the CTIX application. For example, https://<domain_name>/ctixapi/openapi/
      c. Access Key: Enter the Access Key from the CTIX application. The Access Key can be generated by a licensed user from the CTIX application. For example, “74xxxxx7-xxxb-4xxa-xxxx-0xxxxxxxxxx2“.
      d. Secret Key: Enter the Secret Key from the CTIX application. The Secret Key can be generated by a licensed user from the CTIX application. For example, “0xxxxxx8-xxxx-4xx4-xxx6-5xxxxxxxxxxc”.
  5.  After finishing, click the “Test“ button to validate the URL, Token, and Connection.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/ctix)
configuration:
- display: Endpoint URL
  name: base_url
  type: 0
  required: true
  additionalinfo: Enter the endpoint URL of your CTIX Instance.
- display: Access Key
  name: access_id
  type: 4
  required: true
  additionalinfo: Enter the Access Key from the CTIX application.
- display: Secret Key
  name: secret_key
  type: 4
  required: true
  additionalinfo: Enter the Secret Key from the CTIX application.
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- display: Incidents Fetch Interval
  name: incidentFetchInterval
  defaultvalue: "1"
  type: 19
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
script:
  script: |
    #import demistomock as demisto
    # from CommonServerPython import (
    #     Common,
    #     urlRegex,
    #     re,
    #     regexFlags,
    #     hashRegex,
    #     BaseClient,
    #     DemistoException,
    #     CommandResults,
    #     List,
    #     tableToMarkdown,
    #     argToList,
    #     return_warning,
    #     handle_proxy,
    #     return_results,
    #     traceback,
    #     return_error,
    # )

    """IMPORTS"""


    import base64
    import hashlib
    import hmac
    import time

    import requests
    import urllib.parse
    import urllib3
    from typing import Any, Dict
    import json

    # Disable insecure warnings
    urllib3.disable_warnings()

    """GLOBALS"""

    domain_regex = (
        "([a-z¡-\uffff0-9](?:[a-z¡-\uffff0-9-]{0,61}"
        "[a-z¡-\uffff0-9])?(?:\\.(?!-)[a-z¡-\uffff0-9-]{1,63}(?<!-))*"
        "\\.(?!-)(?!(jpg|jpeg|exif|tiff|tif|png|gif|otf|ttf|fnt|dtd|xhtml|css"
        "|html)$)(?:[a-z¡-\uffff-]{2,63}|xn--[a-z0-9]{1,59})(?<!-)\\.?$"
        "|localhost)"
    )

    REGEX_MAP = {
        "url": re.compile(urlRegex, regexFlags),
        "domain": re.compile(domain_regex, regexFlags),
        "hash": re.compile(hashRegex, regexFlags),
    }

    """ CLIENT CLASS """


    class Client(BaseClient):
        """
        Client to use in the CTIX integration. Overrides BaseClient
        """

        def __init__(
            self,
            base_url: str,
            access_id: str,
            secret_key: str,
            verify: bool,
            proxies: dict,
        ) -> None:
            self.base_url = base_url
            self.access_id = access_id
            self.secret_key = secret_key
            self.verify = verify
            self.proxies = proxies

        def signature(self, expires:int):
            '''
            Signature Generation

            :param int expires: Epoch time in which time when signature will expire
            :return str signature : signature queryset
            '''
            to_sign = "%s\n%i" % (self.access_id, expires)
            return base64.b64encode(
                hmac.new(
                    self.secret_key.encode("utf-8"), to_sign.encode("utf-8"), hashlib.sha1
                ).digest()
            ).decode("utf-8")

        def add_common_params(self, params: dict):
            '''
            Add Common Params

            :param dict params: Paramters to be added in request
            :return dict: Params dictionary with AccessID, Expires and Signature
            '''
            expires = int(time.time() + 5)
            params["AccessID"] = self.access_id
            params["Expires"] = expires
            params["Signature"] = self.signature(expires)
            return params

        def get_http_request(self, full_url: str, payload: dict = None, **kwargs):
            '''
            GET HTTP Request

            :param str full_url: URL to be called
            :param dict payload: Request body, defaults to None
            :raises DemistoException: If Any error is found will be raised on XSOAR
            :return dict: Response object
            '''
            kwargs = self.add_common_params(kwargs)
            full_url = full_url + "?" + urllib.parse.urlencode(kwargs)
            headers = {"content-type": "application/json"}
            resp = requests.get(
                full_url,
                verify=self.verify,
                proxies=self.proxies,
                timeout=5,
                headers=headers,
                json=payload,
            )
            status_code = resp.status_code
            try:
                resp.raise_for_status()  # Raising an exception for non-200 status code
            except requests.exceptions.HTTPError as e:
                err_msg = "Error in API call [{}: {}], payload sent: {}, \
                url tried: {}".format(
                    resp.status_code, resp.reason, resp.request.body, full_url
                )
                raise DemistoException(err_msg, e)
            json_data = resp.json()
            response = {"data": json_data, "status": status_code}
            return response

        def post_http_request(self, full_url: str, payload: dict, params):
            '''
            POST HTTP Request

            :param str full_url: URL to be called
            :param dict payload: Request body, defaults to None
            :raises DemistoException: If Any error is found will be raised on XSOAR
            :return dict: Response object
            '''
            headers = {"content-type": "application/json"}
            params = self.add_common_params(params)
            full_url = full_url + "?" + urllib.parse.urlencode(params)
            response = requests.post(
                full_url,
                verify=self.verify,
                proxies=self.proxies,
                json=payload,
                headers=headers,
                timeout=5,
            )
            status_code = response.status_code
            try:
                response.raise_for_status()  # Raising an exception for non-200 status code
            except requests.exceptions.HTTPError as e:
                err_msg = "Error in API call [{}: {}], payload sent: {}, \
                url tried: {} response body: {}".format(
                    response.status_code,
                    response.reason,
                    response.request.body,
                    full_url,
                    response.text,
                )
                raise DemistoException(err_msg, e)
            json_data = response.json()
            response = {"data": json_data, "status": status_code}
            return response

        def delete_http_request(self, full_url: str, object_id: str, params):
            '''
            DELETE HTTP Request

            :param str full_url: URL to be called
            :param dict payload: Request body, defaults to None
            :raises DemistoException: If Any error is found will be raised on XSOAR
            :return dict: Response object
            '''
            params = self.add_common_params(params)
            full_url = full_url + object_id + "/?" + urllib.parse.urlencode(params)
            response = requests.delete(full_url, verify=self.verify, proxies=self.proxies)
            status_code = response.status_code
            try:
                response.raise_for_status()  # Raising an exception for non-200 status code
            except requests.exceptions.HTTPError as e:
                err_msg = "Error in API call [{}]".format(status_code)
                raise DemistoException(err_msg, e)
            json_data = response.json()
            response = {"data": json_data, "status": status_code}
            return response

        def test_auth(self):
            '''
            Test authentication

            :return dict: Returns result for ping
            '''
            client_url = self.base_url + "ping/"
            return self.get_http_request(client_url)

        def create_tag(self, name: str, color_code: str):
            """Creates a tag in ctix platform
            :type name: ``str``
            :param name: Name of the tag

            :type color_code: ``str``
            :param color_code: Hex color code of the tag e.g #111111

            :return: dict containing the details of newly created tag
            :rtype: ``Dict[str, Any]``
            """
            url_suffix = "ingestion/tags/"
            client_url = self.base_url + url_suffix
            payload = {"name": name, "color_code": color_code}
            return self.post_http_request(full_url=client_url, payload=payload, params={})

        def get_tags(self, page: int, page_size: int, q: str):
            """Paginated list of tags from ctix platform using page_number and page_size
            :type page: int
            :param page: page number for the pagination for list api

            :type page_size: int
            :param page_size: page size for the pagination for list api

            :type q: str
            :param q: search query string for the list api
            """
            url_suffix = "ingestion/tags/"
            client_url = self.base_url + url_suffix
            params = {"page": page, "page_size": page_size}
            if q:
                params["q"] = q
            return self.get_http_request(client_url, params)

        def delete_tag(self, tag_id: str):
            """Deletes a tag from the ctix instance
            :type tag_id: ``str``
            :param name: id of the tag to be deleted
            """
            url_suffix = "ingestion/tags/bulk-actions/"
            client_url = self.base_url + url_suffix
            return self.post_http_request(
                client_url, {"ids": tag_id, "action": "delete"}, {}
            )

        def whitelist_iocs(self, ioc_type, values, reason):
            url_suffix = "conversion/whitelist/"
            client_url = self.base_url + url_suffix
            payload = {"type": ioc_type, "values": values, "reason": reason}
            return self.post_http_request(client_url, payload, {})

        def get_whitelist_iocs(self, page: int, page_size: int, q: str):
            """Paginated list of tags from ctix platform using page_number and page_size
            :type page: int
            :param page: page number for the pagination for list api

            :type page_size: int
            :param page_size: page size for the pagination for list api

            :type q: str
            :param q: search query string for the list api
            """
            url_suffix = "conversion/whitelist/"
            client_url = self.base_url + url_suffix
            params = {"page": page, "page_size": page_size}
            if q:
                params["q"] = q
            return self.get_http_request(client_url, {}, **params)

        def remove_whitelisted_ioc(self, whitelist_id: str):
            """Removes whitelisted ioc with given `whitelist_id`
            :type whitelist_id: str
            :param whitelist_id: id of the whitelisted ioc to be removed
            """
            url_suffix = "conversion/whitelist/bulk-actions/"
            client_url = self.base_url + url_suffix
            return self.post_http_request(
                client_url, {"ids": whitelist_id, "action": "delete"}, {}
            )

        def get_threat_data(self, page: int, page_size: int, query: str):
            '''
            Get Threat Data

            :param int page: Paginated number from where data will be polled
            :param int page_size: Size of the result
            :param str query: CQL query for polling specific result
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/list/"
            client_url = self.base_url + url_suffix
            params = {"page": page, "page_size": page_size}
            payload = {"query": query}
            return self.post_http_request(client_url, payload=payload, params=params)

        def get_saved_searches(self, page: int, page_size: int):
            '''
            Get Saved Searches

            :param int page: Paginated number from where data will be polled
            :param int page_size: Size of the result
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/saved-searches/"
            client_url = self.base_url + url_suffix
            params = {"page": page, "page_size": page_size}
            return self.get_http_request(client_url, {}, **params)

        def get_server_collections(self, page: int, page_size: int):
            '''
            Get Server Collections

            :param int page: Paginated number from where data will be polled
            :param int page_size: Size of the result
            :return dict: Returns response for query
            '''
            url_suffix = "publishing/collection/"
            client_url = self.base_url + url_suffix
            params = {"page": page, "page_size": page_size}
            return self.get_http_request(client_url, {}, **params)

        def get_actions(self, page: int, page_size: int, params: Dict[str, Any]):
            '''
            Get Actions

            :param int page: Paginated number from where data will be polled
            :param int page_size: Size of the result
            :param Dict[str, Any] params: Params to be send with request
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/actions/"
            client_url = self.base_url + url_suffix
            params["page"] = page
            params["page_size"] = page_size
            return self.get_http_request(client_url, **params)

        def add_indicator_as_false_positive(self, object_ids: list[str], object_type: str):
            '''
            Add Indicator as False Positive

            :param list[str] object_ids: Object IDs of the IOCs
            :param str object_type: Object type of the IOCs
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/bulk-action/false_positive/"
            client_url = self.base_url + url_suffix
            payload = {"object_ids": object_ids, "object_type": object_type, "data": {}}

            return self.post_http_request(client_url, payload, {})

        def add_ioc_to_manual_review(self, object_ids: list[str], object_type: str):
            '''
            Add IOC to Manual Review

            :param list[str] object_ids: Object IDs of the IOCs
            :param str object_type: Object type of the IOCs
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/bulk-action/manual_review/"
            client_url = self.base_url + url_suffix
            payload = {"object_ids": object_ids, "object_type": object_type, "data": {}}

            return self.post_http_request(client_url, payload, {})

        def deprecate_ioc(self, object_ids:str, object_type:str):
            '''
            Deprecate IOC

            :param str object_ids: Object ID of the IOC
            :param str object_type: Object type of the IOC
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/bulk-action/deprecate/"
            client_url = self.base_url + url_suffix
            payload = {"object_ids": object_ids, "object_type": object_type, "data": {}}

            return self.post_http_request(client_url, payload, {})

        def add_analyst_tlp(self, object_id:str, object_type:str, data):
            '''
            Add Analyst TLP

            :param str object_id: Object ID of the IOCs
            :param str object_type: _Object type of the IOCs
            :param dict data: data to be send over POST request
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/action/analyst_tlp/"
            client_url = self.base_url + url_suffix
            payload = {"object_id": object_id, "object_type": object_type, "data": data}

            return self.post_http_request(client_url, payload, {})

        def add_analyst_score(self, object_id:str, object_type, data):
            '''
            Add Analyst Score

            :param str object_id: Object ID of the IOCs
            :param str object_type: Object type of the IOCs
            :param dict data: Request body to be send over POST request
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/action/analyst_score/"
            client_url = self.base_url + url_suffix
            payload = {"object_id": object_id, "object_type": object_type, "data": data}

            return self.post_http_request(client_url, payload, {})

        def saved_result_set(self, page: int, page_size: int, label_name: str, query: str):
            '''
            Saved Result Set

            :param int page: Paginated number from where data will be polled
            :param int page_size: Size of the result
            :param str label_name: Label name used to get the data from the rule
            :param str query: CQL query to get specific data
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/list/"
            client_url = self.base_url + url_suffix
            params = {}
            params.update({"page": page})
            params.update({"page_size": page_size})
            if query is None:
                query = "type=indicator"
            payload = {"label_name": label_name, "query": query}
            return self.post_http_request(client_url, payload, params)

        def tag_indicator_updation(
            self,
            q: str,
            page: int,
            page_size: int,
            object_id: str,
            object_type: str,
            tag_id: str,
            operation: str,
        ):
            '''
            Tag Indicator Updation

            :param str q: query to be send
            :param int page: Paginated number from where data will be polled
            :param int page_size: Size of the result
            :param str object_id: Object ID of the IOCs
            :param str object_type: Object type of the IOCs
            :param str tag_id: Tag ID that will be removed or added
            :param str operation: Addition or Removal of tag operation
            :return dict: Returns response for query
            '''
            tags_data = self.get_indicator_tags(
                object_type, object_id, {"page": page, "page_size": page_size}
            )["data"]
            tags = [_["id"] for _ in tags_data["tags"]]
            if operation == "add_tag_indicator":
                tags.extend([_.strip() for _ in tag_id.split(",")])
            elif operation == "remove_tag_from_indicator":
                removable_tags = [_.strip() for _ in tag_id.split(",")]
                for r_tag in removable_tags:
                    if r_tag in tags:
                        tags.remove(r_tag)
            final_tags = list(set(tags))
            url_suffix = "ingestion/threat-data/action/add_tag/"
            client_url = self.base_url + url_suffix
            params = {"page": page, "page_size": page_size, "q": q}
            payload = {
                "object_id": object_id,
                "object_type": object_type,
                "data": {"tag_id": final_tags},
            }
            return self.post_http_request(client_url, payload, params)

        def search_for_tag(self, params: dict):
            '''
            Search for tag

            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/tags/"
            client_url = self.base_url + url_suffix
            return self.get_http_request(client_url, **params)

        def get_indicator_details(self, object_type: str, object_id: str, params: dict):
            '''
            Get Indicator Details

            :param str object_type: Object type of the IOCs
            :param str object_id: Object ID of the IOCs
            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = f"ingestion/threat-data/{object_type}/{object_id}/basic/"
            client_url = self.base_url + url_suffix
            return self.get_http_request(client_url, **params)

        def get_indicator_tags(self, object_type: str, object_id: str, params: dict):
            '''
            Get Indicator Tags

            :param str object_type: Object type of the IOCs
            :param str object_id: Object ID of the IOCs
            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = f"ingestion/threat-data/{object_type}/{object_id}/quick-actions/"
            client_url = self.base_url + url_suffix
            return self.get_http_request(client_url, **params)

        def get_indicator_relations(self, object_type: str, object_id: str, params: dict):
            '''
            Get Indicator Relations

            :param str object_type: Object type of the IOCs
            :param str object_id: Object ID of the IOCs
            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = f"ingestion/threat-data/{object_type}/{object_id}/relations/"
            client_url = self.base_url + url_suffix
            return self.get_http_request(client_url, **params)

        def get_indicator_observations(self, params: dict):
            '''
            Get Indicator Observations

            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/source-references/"
            client_url = self.base_url + url_suffix
            return self.get_http_request(client_url, **params)

        def get_conversion_feed_source(self, params: dict):
            '''
            Get Conversion Feed Source

            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = "conversion/feed-sources/"
            client_url = self.base_url + url_suffix
            return self.get_http_request(client_url, **params)

        def get_lookup_threat_data(
            self, object_type: str, object_names: list, params: dict
        ):
            '''
            Get Lookup Threat Data

            :param str object_type: Object type of the IOCs
            :param list object_names: Indicator/IOCs names
            :param dict params: Paramters to be added in request
            :return dict: Returns response for query
            '''
            url_suffix = "ingestion/threat-data/list/"
            query = f"type={object_type} AND value IN {tuple(object_names)}"
            payload = {"query": query}
            client_url = self.base_url + url_suffix
            return self.post_http_request(client_url, payload, params)


    """ HELPER FUNCTIONS """


    def to_dbot_score(ctix_score: int) -> int:
        """
        Maps CTIX Score to DBotScore
        """
        if ctix_score == 0:
            dbot_score = Common.DBotScore.NONE  # unknown
        elif ctix_score <= 30:
            dbot_score = Common.DBotScore.GOOD  # good
        elif ctix_score <= 70:
            dbot_score = Common.DBotScore.SUSPICIOUS  # suspicious
        else:
            dbot_score = Common.DBotScore.BAD
        return dbot_score


    """ COMMAND FUNCTIONS """


    def test_module(client: Client):
        """
        Performs basic get request to get sample ip details.
        """
        client.test_auth()
        # test was successful
        demisto.results("ok")


    def create_tag_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        create_tag command: Creates a new tag in the CTIX platform
        """
        name = args.get("tag_name")
        color_code = args.get("color_code")

        if color_code is not None:
            if not color_code.startswith("#") or len(color_code) != 7:
                return_warning(
                    "Color code is invalid, it should be a hex code: {}".format(color_code)
                )

        response = client.create_tag(name, color_code)
        data = response.get("data")
        results = CommandResults(
            readable_output=tableToMarkdown("Tag Data", data, removeNull=True),
            outputs_prefix="CTIX.Tag",
            outputs_key_field="name",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_tags_command(client: Client, args=Dict[str, Any]) -> List[CommandResults]:
        """
        get_tags commands: Returns paginated list of tags
        """
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 10))
        query = args.get("q")
        response = client.get_tags(page, page_size, query)
        tags_list = response.get("data", {}).get("results", [])
        results = []
        for tag in tags_list:
            results.append(
                CommandResults(
                    readable_output=tableToMarkdown("Tag Data", tag, removeNull=True),
                    outputs_prefix="CTIX.Tag",
                    outputs_key_field="name",
                    outputs=tag,
                )
            )
        return results


    def delete_tag_command(client: Client, args: dict) -> CommandResults:
        """
        delete_tag command: Deletes a tag with given tag_name
        """
        tag_name = argToList(args.get("tag_name"))
        final_result = []
        for tag in tag_name:
            search_result = client.get_tags(1, 10, tag)
            tags = search_result.get("data", {}).get("results", [])
            response = client.delete_tag(tags[0]["id"])
            final_result.append(response.get("data"))
        data = final_result
        results = CommandResults(
            readable_output=tableToMarkdown("Tag Response", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs_key_field="result",
            outputs=data,
            raw_response=data,
        )
        return results


    def whitelist_iocs_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        '''
        Whitelist IOCs command

        :Description Whitelist IOCs for a given value
        :param Dict[str, Any] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        ioc_type = args.get("type")
        values = args.get("values")
        values = argToList(values)
        reason = args.get("reason")

        data = (
            client.whitelist_iocs(ioc_type, values, reason)
            .get("data", {})
            .get("details", {})
        )
        results = CommandResults(
            readable_output=tableToMarkdown("Whitelist IOC", data, removeNull=True),
            outputs_prefix="CTIX.Detail",
            outputs=data,
            raw_response=data,
        )
        return results


    def get_whitelist_iocs_command(
        client: Client, args=Dict[str, Any]
    ) -> List[CommandResults]:
        """
        get_tags commands: Returns paginated list of tags
        """
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 10))
        query = args.get("q")
        response = client.get_whitelist_iocs(page, page_size, query)
        ioc_list = response.get("data", {}).get("results", [])
        results = []
        for ioc in ioc_list:
            results.append(
                CommandResults(
                    readable_output=tableToMarkdown("Whitelist IOC", ioc, removeNull=True),
                    outputs_prefix="CTIX.IOC",
                    outputs_key_field="value",
                    outputs=ioc,
                )
            )
        return results


    def remove_whitelisted_ioc_command(
        client: Client, args=Dict[str, Any]
    ) -> CommandResults:
        """
        remove_whitelist_ioc: Deletes a whitelisted ioc with given id
        """
        whitelist_id = argToList(args.get("ids"))
        response = client.remove_whitelisted_ioc(whitelist_id)
        data = response.get("data")
        results = CommandResults(
            readable_output=tableToMarkdown("Details", data, removeNull=True),
            outputs_prefix="CTIX.Detail",
            outputs_key_field="detail",
            outputs=data,
            raw_response=data,
        )
        return results


    def get_threat_data_command(client: Client, args=Dict[str, Any]) -> CommandResults:
        """
        get_threat_data: List thread data and allow query
        """
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 1))
        query = args.get("query", "type=indicator")
        response = client.get_threat_data(page, page_size, query)
        threat_data_list = response.get("data", {}).get("results", [])
        results = [data for data in threat_data_list]
        result = CommandResults(
            readable_output=tableToMarkdown("Threat Data", results, removeNull=True),
            outputs_prefix="CTIX.ThreatData",
            outputs_key_field="id",
            outputs=results,
            raw_response=results,
        )
        return result


    def get_saved_searches_command(client: Client, args=Dict[str, Any]) -> CommandResults:
        """
        get_saved_searches: List saved search data
        """
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 10))
        response = client.get_saved_searches(page, page_size)
        data_list = response.get("data", {}).get("results", [])
        results = [data for data in data_list]
        result = CommandResults(
            readable_output=tableToMarkdown("Saved Search", results, removeNull=True),
            outputs_prefix="CTIX.SavedSearch",
            outputs_key_field="id",
            outputs=results,
            raw_response=results,
        )
        return result


    def get_server_collections_command(
        client: Client, args=Dict[str, Any]
    ) -> CommandResults:
        """
        get_server_collections: List server collections
        """
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 10))
        response = client.get_server_collections(page, page_size)
        data_list = response.get("data", {}).get("results", [])
        results = [data for data in data_list]
        result = CommandResults(
            readable_output=tableToMarkdown("Server Collection", results, removeNull=True),
            outputs_prefix="CTIX.ServerCollection",
            outputs_key_field="id",
            outputs=results,
            raw_response=results,
        )
        return result


    def get_actions_command(client: Client, args=Dict[str, Any]) -> CommandResults:
        """
        get_actions: List Actions
        """
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 10))
        object_type = args.get("object_type")
        action_type = args.get("actions_type")
        params = {}
        if action_type:
            params["action_type"] = action_type
        if object_type:
            params["object_type"] = object_type
        response = client.get_actions(page, page_size, params)
        data_list = response.get("data", {}).get("results", [])
        results = [data for data in data_list]
        result = CommandResults(
            readable_output=tableToMarkdown("Actions", results, removeNull=True),
            outputs_prefix="CTIX.Action",
            outputs_key_field="id",
            outputs=results,
            raw_response=results,
        )
        return result


    def add_indicator_as_false_positive_command(
        client: Client, args: Dict[str, str]
    ) -> CommandResults:
        '''
        Add Indicator as False Positive Command

        :Description Add Indicator as False Positive for a given Indicator
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        object_ids = args.get("object_ids")
        object_type = args.get("object_type", "indicator")
        object_ids = argToList(object_ids)
        response = client.add_indicator_as_false_positive(object_ids, object_type)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def add_ioc_manual_review_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        '''
        Add IOC for Manual Review Command

        :Description Add IOC for Manual Review for a given Indicator
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        object_ids = args.get("object_ids")
        object_type = args.get("object_type", "indicator")
        object_ids = argToList(object_ids)
        response = client.add_ioc_to_manual_review(object_ids, object_type)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def deprecate_ioc_command(client: Client, args: dict) -> CommandResults:
        """
        deprecate_ioc command: Deprecate indicators bulk api
        """
        object_ids = args.get("object_ids")
        object_type = args.get("object_type")
        object_ids = argToList(object_ids)
        response = client.deprecate_ioc(object_ids, object_type)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def add_analyst_tlp_command(client: Client, args: dict) -> CommandResults:
        '''
        Add Analyst TLP Command

        :Description Add Analyst TLP for a given Indicator
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        object_id = args.get("object_id")
        object_type = args.get("object_type")
        data = json.loads(args.get("data"))

        analyst_tlp = data.get("analyst_tlp")
        if not analyst_tlp:
            raise DemistoException("analyst_tlp not provided")

        response = client.add_analyst_tlp(object_id, object_type, data)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def add_analyst_score_command(client: Client, args: dict) -> CommandResults:
        '''
        Add Analyst Score Command

        :Description Add Analyst Score for a given Indicator
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        object_id = args.get("object_id")
        object_type = args.get("object_type")
        data = json.loads(args.get("data", "{}"))

        analyst_tlp = data.get("analyst_score")
        if not analyst_tlp:
            raise DemistoException("analyst_score not provided")

        response = client.add_analyst_score(object_id, object_type, data)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def saved_result_set_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        '''
        Get Saved Result Set data Command

        :Description Get Saved Result Set data
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = int(args.get("page", 1))
        page_size = int(args.get("page_size", 10))
        label_name = args.get("label_name", "test")
        query = args.get("query", "type=indicator")
        response = client.saved_result_set(page, page_size, label_name, query)
        data_dump = response.get("data", {})
        results = data_dump.get('results', [])
        result = CommandResults(
            readable_output=tableToMarkdown("SavedResultSet", results, removeNull=True),
            outputs_prefix="CTIX.SavedResultSet",
            outputs_key_field="id",
            outputs=results,
            raw_response=results,
        )
        return result


    def tag_indicator_updation_command(
        client: Client, args: Dict[str, Any], operation: str
    ) -> CommandResults:
        '''
        Tag Indicator Updation Command

        :Description Updating Tag of a given Indicator
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        object_id = args["object_id"]
        object_type = args["object_type"]
        tag_id = args["tag_id"]
        query = args["q"]

        response = client.tag_indicator_updation(
            query, page, page_size, object_id, object_type, tag_id, operation
        )
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def search_for_tag_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        '''
        Search for Tag Command

        :Description Search for Tag
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        q = args.get("q")
        params = {"page": page, "page_size": page_size, "q": q}

        response = client.search_for_tag(params)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_indicator_details_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        '''
        Get Indicator Details Command

        :Description Get Indicator Details
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        object_id = args["object_id"]
        object_type = args["object_type"]
        params = {"page": page, "page_size": page_size}

        response = client.get_indicator_details(object_type, object_id, params)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_indicator_tags_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        '''
        Get Indicator Tags  Command

        :Description Get Tags Details
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        object_id = args.get("object_id")
        object_type = args["object_type"]
        params = {"page": page, "page_size": page_size}

        response = client.get_indicator_tags(object_type, object_id, params)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_indicator_relations_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        '''
        Get Indicator Relations Command

        :Description Get Relations Details
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        object_id = args["object_id"]
        object_type = args["object_type"]
        params = {"page": page, "page_size": page_size}

        response = client.get_indicator_relations(object_type, object_id, params)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_indicator_observations_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        '''
        Get Indicator Observations Command

        :Description Get Indicator Observations
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        object_id = args.get("object_id")
        object_type = args.get("object_type")
        params = {
            "page": page,
            "page_size": page_size,
            "object_id": object_id,
            "object_type": object_type,
        }

        response = client.get_indicator_observations(params)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_conversion_feed_source_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        '''
        Get Conversion Feed Source Command

        :Description Get Conversion Feed Source
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        page = args.get("page", 1)
        page_size = args.get("page_size", 10)
        object_id = args.get("object_id")
        object_type = args.get("object_type")
        params = {
            "page": page,
            "page_size": page_size,
            "object_id": object_id,
            "object_type": object_type,
        }
        q = args.get("q")
        if q is not None:
            params.update({"q": q})

        response = client.get_conversion_feed_source(params)
        data = response.get("data")
        data = {"result": data}
        results = CommandResults(
            readable_output=tableToMarkdown("Result", data, removeNull=True),
            outputs_prefix="CTIX.Result",
            outputs=data,
            raw_response=data,
        )

        return results


    def get_lookup_threat_data_command(
        client: Client, args: Dict[str, Any]
    ) -> CommandResults:
        '''
        Get Lookup Threat Data Command

        :Description Get Lookup Threat Data
        :param Dict[str, str] args: Paramters to be send to in request
        :return CommandResults: XSOAR based result
        '''
        object_type = args.get("object_type", "indicator")
        object_names = argToList(args.get("object_names"))
        page_size = args.get("page_size", 10)
        params = {"page_size": page_size}
        response = client.get_lookup_threat_data(object_type, object_names, params)
        data_set = response.get("data").get("results")
        results = [data for data in data_set]
        results = CommandResults(
            readable_output=tableToMarkdown("Result", results, removeNull=True),
            outputs_prefix="CTIX.ThreatDataLookup",
            outputs=results,
            raw_response=results,
        )

        return results


    def main() -> None:

        base_url = demisto.params().get("base_url")
        access_id = demisto.params().get("access_id")
        secret_key = demisto.params().get("secret_key")
        verify = not demisto.params().get("insecure", False)
        proxies = handle_proxy(proxy_param_name="proxy")

        demisto.debug(f"Command being called is {demisto.command()}")
        try:

            client = Client(
                base_url=base_url,
                access_id=access_id,
                secret_key=secret_key,
                verify=verify,
                proxies=proxies,
            )

            if demisto.command() == "test-module":
                test_module(client)
            elif demisto.command() == "create_tag":
                return_results(create_tag_command(client, demisto.args()))
            elif demisto.command() == "get_tags":
                return_results(get_tags_command(client, demisto.args()))
            elif demisto.command() == "delete_tag":
                return_results(delete_tag_command(client, demisto.args()))
            elif demisto.command() == "whitelist_iocs":
                return_results(whitelist_iocs_command(client, demisto.args()))
            elif demisto.command() == "get_whitelist_iocs":
                return_results(get_whitelist_iocs_command(client, demisto.args()))
            elif demisto.command() == "remove_whitelist_ioc":
                return_results(remove_whitelisted_ioc_command(client, demisto.args()))
            elif demisto.command() == "get_threat_data":
                return_results(get_threat_data_command(client, demisto.args()))
            elif demisto.command() == "get_saved_searches":
                return_results(get_saved_searches_command(client, demisto.args()))
            elif demisto.command() == "get_server_collections":
                return_results(get_server_collections_command(client, demisto.args()))
            elif demisto.command() == "get_actions":
                return_results(get_actions_command(client, demisto.args()))
            elif demisto.command() == "ioc_manual_review":
                return_results(add_ioc_manual_review_command(client, demisto.args()))
            elif demisto.command() == "deprecate_ioc":
                return_results(deprecate_ioc_command(client, demisto.args()))
            elif demisto.command() == "add_analyst_tlp":
                return_results(add_analyst_tlp_command(client, demisto.args()))
            elif demisto.command() == "add_analyst_score":
                return_results(add_analyst_score_command(client, demisto.args()))
            elif demisto.command() == "saved_result_set":
                return_results(saved_result_set_command(client, demisto.args()))
            elif demisto.command() == "add_tag_indicator":
                return_results(
                    tag_indicator_updation_command(
                        client, demisto.args(), "add_tag_indicator"
                    )
                )
            elif demisto.command() == "remove_tag_from_indicator":
                return_results(
                    tag_indicator_updation_command(
                        client, demisto.args(), "remove_tag_from_indicator"
                    )
                )
            elif demisto.command() == "search_for_tag":
                return_results(search_for_tag_command(client, demisto.args()))
            elif demisto.command() == "get_indicator_details":
                return_results(get_indicator_details_command(client, demisto.args()))
            elif demisto.command() == "get_indicator_tags":
                return_results(get_indicator_tags_command(client, demisto.args()))
            elif demisto.command() == "get_indicator_relations":
                return_results(get_indicator_relations_command(client, demisto.args()))
            elif demisto.command() == "get_indicator_observations":
                return_results(get_indicator_observations_command(client, demisto.args()))
            elif demisto.command() == "get_conversion_feed_source":
                return_results(get_conversion_feed_source_command(client, demisto.args()))
            elif demisto.command() == "get_lookup_threat_data":
                return_results(get_lookup_threat_data_command(client, demisto.args()))
            elif demisto.command() == "add_indicator_as_false_positive":
                return_results(
                    add_indicator_as_false_positive_command(client, demisto.args())
                )

        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(
                f"Failed to execute {demisto.command()} command.\nError:\n{str(e)} \
                {traceback.format_exc()}"
            )


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()
  type: python
  commands:
  - name: create_tag
    arguments:
    - name: tag_name
      required: true
      description: New tag's name
    - name: color_code
      required: true
      description: 'New tag''s hex colour code e.g #111111'
    outputs:
    - contextPath: CTIX.Tag.name
      description: Name of the tag
      type: string
    - contextPath: CTIX.Tag.tag_type
      description: Type of the tag (manual)
      type: string
    - contextPath: CTIX.Tag.colour_code
      description: Colour Code of the tag
      type: string
    - contextPath: CTIX.Tag.id
      description: Id of the Created Tag
      type: string
    - contextPath: CTIX.Tag.created
      description: Created at timestamp
      type: number
    - contextPath: CTIX.Tag.modified
      description: Modified at timestamp
      type: number
    description: Create new tag in the ctix platform
  - name: get_tags
    arguments:
    - name: page
      description: Page number for pagination
      defaultValue: "1"
    - name: page_size
      description: Page size for pagination
      defaultValue: "10"
    - name: q
      description: search query parameter
    outputs:
    - contextPath: CTIX.Tag.name
      description: Name of the tag
      type: string
    - contextPath: CTIX.Tag.id
      description: ID of the tag
      type: string
    - contextPath: CTIX.Tag.colour_code
      description: Hex colour code associated with tag
      type: string
    - contextPath: CTIX.Tag.tag_type
      description: Type of the tag
      type: string
    - contextPath: CTIX.Tag.created
      description: Created at timestamp
      type: number
    - contextPath: CTIX.Tag.modified
      description: Modified at timestamp
      type: number
    description: Get paginated list of tags
  - name: delete_tag
    arguments:
    - name: tag_name
      required: true
      description: Name of the tag
    outputs:
    - contextPath: CTIX.Result.result
      description: Status
      type: string
    description: Delete a tag with given tag_name
    execution: true
  - name: whitelist_iocs
    arguments:
    - name: type
      required: true
      auto: PREDEFINED
      predefined:
      - ipv4-addr
      - ipv6-addr
      - autonomous-system
      - email-addr
      - MD5
      - SHA-1
      - SHA-224
      - SHA-256
      - SHA-384
      - SHA-512
      - SSDEEP
      - url
      - cidr
      - domain-name
      - mutex
      - windows-registry-key
      - user-agent
      description: Type of ioc
    - name: values
      required: true
      description: Values of the given type
      isArray: true
    - name: reason
      required: true
      description: Descriptive reason
    outputs:
    - contextPath: CTIX.Details.invalid
      description: Invalid iocs sent in request
      type: unknown
    - contextPath: CTIX.Details.new_created
      description: List of iocs added to whitelist
    - contextPath: CTIX.Details.already_exists
      description: List of iocs already existing
    description: Adds list of same type of iocs to whitelist
    execution: true
  - name: get_whitelist_iocs
    arguments:
    - name: page
      description: 'Page number '
      defaultValue: "1"
    - name: page_size
      description: Page size
      defaultValue: "10"
    - name: q
      description: query param for searching
    outputs:
    - contextPath: CTIX.IOC.id
      description: ID of the object
      type: string
    - contextPath: CTIX.IOC.include_emails
      type: boolean
    - contextPath: CTIX.IOC.include_sub_domains
      type: boolean
    - contextPath: CTIX.IOC.include_urls
      type: boolean
    - contextPath: CTIX.IOC.type
      description: Type of the ioc
      type: string
    - contextPath: CTIX.IOC.value
      description: Value of the ioc
      type: string
    - contextPath: CTIX.IOC.created
      description: Created at timestamp
      type: number
    - contextPath: CTIX.IOC.modified
      description: Modified at timestamp
      type: number
    description: get paginated list of whitelist iocs
  - name: remove_whitelist_ioc
    arguments:
    - name: ids
      required: true
      description: Whitelist IOC ids
    outputs:
    - contextPath: details
      description: Operation result
      type: string
    description: Removes a whitelisted ioc with given id
  - name: get_threat_data
    arguments:
    - name: query
      required: true
      description: Query statement for the thread data, please refer to the documentation
    - name: page
      defaultValue: "1"
    - name: page_size
      defaultValue: "1"
    outputs:
    - contextPath: CTIX.ThreatData.confidence_score
      description: Confidence Score
      type: number
    - contextPath: CTIX.ThreatData.confidence_type
      description: Confidence Type
    - contextPath: CTIX.ThreatData.created
      description: Created
    - contextPath: CTIX.ThreatData.ctix_created
      description: CTIX Created
    - contextPath: CTIX.ThreatData.ctix_modified
      description: CTIX Modified
    - contextPath: CTIX.ThreatData.id
      description: ' ID'
    - contextPath: CTIX.ThreatData.indicator_type
      description: Indicator Type
    - contextPath: CTIX.ThreatData.ioc_type
      description: IOC Type
    - contextPath: CTIX.ThreatData.is_actioned
      description: IS Actioned
    - contextPath: CTIX.ThreatData.is_deprecated
      description: IS Deprecated
    - contextPath: CTIX.ThreatData.is_false_positive
      description: IS False Positive
    - contextPath: CTIX.ThreatData.is_reviewed
      description: is_reviewed
    - contextPath: CTIX.ThreatData.is_revoked
      description: IS Revoked
    - contextPath: CTIX.ThreatData.is_watchlist
      description: is_watchlist
    - contextPath: CTIX.ThreatData.is_whitelisted
      description: is_whitelisted
    - contextPath: CTIX.ThreatData.modified
      description: modified
    - contextPath: CTIX.ThreatData.name
      description: name
    - contextPath: CTIX.ThreatData.risk_severity
      description: risk_severity
    - contextPath: CTIX.ThreatData.source_collections
      description: source_collections
    - contextPath: CTIX.ThreatData.source_confidence
      description: source_confidence
    - contextPath: CTIX.ThreatData.sources
      description: sources
    - contextPath: CTIX.ThreatData.sub_type
      description: sub_type
    - contextPath: CTIX.ThreatData.tlp
      description: tlp
    - contextPath: CTIX.ThreatData.type
      description: type
    - contextPath: CTIX.ThreatData.valid_from
      description: valid_from
    description: Command for querying and listing threat data
  - name: get_saved_searches
    arguments:
    - name: page
    - name: page_size
    outputs:
    - contextPath: CTIX.SavedSearch.id
      description: ID of the object
      type: string
    - contextPath: CTIX.SavedSearch.editable
      type: boolean
    - contextPath: CTIX.SavedSearch. is_threat_data_search
      type: boolean
    - contextPath: CTIX.SavedSearch.name
      type: string
    - contextPath: CTIX.SavedSearch.order
      type: number
    - contextPath: CTIX.SavedSearch.pinned
      type: boolean
    - contextPath: CTIX.SavedSearch.query
      type: string
    - contextPath: CTIX.SavedSearch.shared_type
      type: string
    - contextPath: CTIX.SavedSearch.type
      type: string
    - contextPath: CTIX.SavedSearch.meta_data
    description: Saved Search listing api with pagination
  - name: get_server_collections
    arguments:
    - name: page
    - name: page_size
    outputs:
    - contextPath: CTIX.ServerCollection.name
      description: Name of the server
      type: string
    - contextPath: CTIX.ServerCollection.id
      description: ID of the object
      type: string
    - contextPath: CTIX.ServerCollection.inbox
      type: boolean
    - contextPath: CTIX.ServerCollection.is_active
      type: boolean
    - contextPath: CTIX.ServerCollection.is_editable
      type: boolean
    - contextPath: CTIX.ServerCollection.polling
      type: boolean
    - contextPath: CTIX.ServerCollection.type
      type: string
    - contextPath: CTIX.ServerCollection.description
      type: string
    - contextPath: CTIX.ServerCollection.created
      description: Created timestamp
      type: number
    description: Source Collection listing api with pagination
  - name: get_actions
    arguments:
    - name: page
    - name: page_size
    - name: object_type
    - name: action_type
    outputs:
    - contextPath: CTIX.Action.action_name
      description: Name of the Action
      type: string
    - contextPath: CTIX.Action.action_type
      description: Description of the action
    - contextPath: CTIX.Action.actioned_on
      description: 'timestamp '
      type: number
    - contextPath: CTIX.Action.app_name
      type: string
    - contextPath: CTIX.app_type
      type: string
    - contextPath: CTIX.Action.id
      type: string
    - contextPath: CTIX.Action.object_type
      type: string
    description: Enrichment tools listing API
  - name: add_indicator_as_false_positive
    arguments:
    - name: object_ids
      required: true
      description: ', seperated list of indicator ids'
      isArray: true
    - name: object_type
      required: true
      auto: PREDEFINED
      predefined:
      - attack-pattern
      - campaign
      - course-of-action
      - custom-object
      - grouping
      - identity
      - indicator
      - infrastructure
      - intrusion-set
      - location
      - malware
      - malware-analysis
      - observed-data
      - opinion
      - report
      - threat-actor
      - tool
      - note
      - vulnerability
      - artifact
      - directory
      - email-addr
      - user-account
      - email-message
      - file
      - ipv4-addr
      - ipv6-addr
      - mac-addr
      - autonomous-system
      - network-traffic
      - domain-name
      - process
      - software
      - windows-registry-key
      - mutex
      - url
      - observable
      - x509-certificate
      description: Type of object
    outputs:
    - contextPath: CTIX.Result.message
      description: Indicator change result
  - name: ioc_manual_review
    arguments:
    - name: object_ids
      required: true
      description: Object ids of the items to be added for manual review
      isArray: true
    - name: object_type
      required: true
      auto: PREDEFINED
      predefined:
      - attack-pattern
      - campaign
      - course-of-action
      - custom-object
      - grouping
      - identity
      - indicator
      - infrastructure
      - intrusion-set
      - location
      - malware
      - malware-analysis
      - observed-data
      - opinion
      - report
      - threat-actor
      - tool
      - note
      - vulnerability
      - artifact
      - directory
      - email-addr
      - user-account
      - email-message
      - file
      - ipv4-addr
      - ipv6-addr
      - mac-addr
      - autonomous-system
      - network-traffic
      - domain-name
      - process
      - software
      - windows-registry-key
      - mutex
      - url
      - observable
      - x509-certificate
    outputs:
    - contextPath: CTIX.Result.message
    description: Adds ioc to manual review bulk api
  - name: deprecate_ioc
    arguments:
    - name: object_ids
      required: true
      isArray: true
    - name: object_type
      required: true
    outputs:
    - contextPath: CTIX.Result
    description: Deprecate ioc bulk api
  - name: add_analyst_tlp
    arguments:
    - name: object_id
      required: true
      default: true
    - name: object_type
      required: true
    - name: data
      required: true
    outputs:
    - contextPath: CTIX.Result
    description: Add Analyst TLP
  - name: add_analyst_score
    arguments:
    - name: object_id
      required: true
    - name: object_type
      required: true
    - name: data
      required: true
    outputs:
    - contextPath: CTIX.Result
    description: Add Analyst Score for a Threat data
  - name: saved_result_set
    arguments:
    - name: page
      defaultValue: "1"
    - name: page_size
      default: true
      defaultValue: "10"
    - name: label_name
    - name: query
    outputs:
    - contextPath: CTIX.SavedResultSet.analyst_score
      type: number
    - contextPath: CTIX.SavedResultSet.analyst_tlp
      type: string
    - contextPath: CTIX.SavedResultSet.confidence_score
      type: number
    - contextPath: CTIX.SavedResultSet.confidence_type
      type: string
    - contextPath: CTIX.SavedResultSet.country
      type: string
    - contextPath: CTIX.SavedResultSet.created
      type: number
    - contextPath: CTIX.SavedResultSet.ctix_created
      type: number
    - contextPath: CTIX.SavedResultSet.ctix_modified
      type: number
    - contextPath: CTIX.SavedResultSet.first_seen
      type: date
    - contextPath: CTIX.SavedResultSet.id
      type: number
    - contextPath: CTIX.SavedResultSet.indicator_type
      type: string
    - contextPath: CTIX.SavedResultSet.ioc_type
      type: string
    - contextPath: CTIX.SavedResultSet.is_actioned
      type: boolean
    - contextPath: CTIX.SavedResultSet.is_deprecated
      type: boolean
    - contextPath: CTIX.SavedResultSet.is_false_positive
      type: boolean
    - contextPath: CTIX.SavedResultSet.is_reviewed
      type: boolean
    - contextPath: CTIX.SavedResultSet.is_revoked
      type: boolean
    - contextPath: CTIX.SavedResultSet.is_watchlist
      type: boolean
    - contextPath: CTIX.SavedResultSet.is_whitelisted
      type: boolean
    - contextPath: CTIX.SavedResultSet.last_seen
      type: date
    - contextPath: CTIX.SavedResultSet.modified
      type: date
    - contextPath: CTIX.SavedResultSet.name
      type: string
    - contextPath: CTIX.SavedResultSet.null
    - contextPath: CTIX.SavedResultSet.primary_attribute
      type: string
    - contextPath: CTIX.SavedResultSet.published_collections
      type: unknown
    - contextPath: CTIX.SavedResultSet.risk_severity
    - contextPath: CTIX.SavedResultSet.source_collections
    - contextPath: CTIX.SavedResultSet.name
      type: string
    - contextPath: CTIX.SavedResultSet.sources
    - contextPath: CTIX.SavedResultSet.sub_type
    - contextPath: CTIX.SavedResultSet.subscriber_collections
    - contextPath: CTIX.SavedResultSet.subscribers
    - contextPath: CTIX.SavedResultSet.tags
    - contextPath: CTIX.SavedResultSet.tlp
    - contextPath: CTIX.SavedResultSet.type
    - contextPath: CTIX.SavedResultSet.valid_from
    - contextPath: CTIX.SavedResultSet.valid_until
    description: Saved Result Set
  - name: add_tag_indicator
    arguments:
    - name: page
      description: page from where data will be taken
      defaultValue: "1"
    - name: page_size
      default: true
      description: total number of results to be fetched
      defaultValue: "10"
    - name: q
    - name: object_id
    - name: object_type
    - name: tag_id
      isArray: true
    outputs:
    - contextPath: CTIX.Result.meesage
    description: Adding Tag to Indicator
  - name: remove_tag_from_indicator
    arguments:
    - name: page
      description: which page to bring the data from
      defaultValue: "1"
    - name: page_size
      default: true
      description: number of pages to bring data from
      defaultValue: "10"
    - name: q
      description: query
    - name: object_id
    - name: object_type
    - name: tag_id
      isArray: true
    outputs:
    - contextPath: CTIX.Result.message
    description: Remove Tag From Indicator
  - name: search_for_tag
    arguments:
    - name: page
      description: number of page from where data needs to brought
      defaultValue: "1"
    - name: page_size
      default: true
      description: size of the result
      defaultValue: "10"
    - name: q
      description: query
    outputs:
    - contextPath: CTIX.Result.colour_code
      description: ""
      type: unknown
    - contextPath: CTIX.Result.created
      description: ""
      type: number
    - contextPath: CTIX.Result.created_by
      description: ""
      type: unknown
    - contextPath: CTIX.Result.id
    - contextPath: CTIX.Result.modified
    - contextPath: CTIX.Result.modified_by
    - contextPath: CTIX.Result.name
    - contextPath: CTIX.Result.type
    description: Search for tag
  - name: get_indicator_details
    arguments:
    - name: page
      description: from where data has to be brought
      defaultValue: "1"
    - name: page_size
      default: true
      description: total number of results
      defaultValue: "10"
    - name: object_id
    - name: object_type
    outputs:
    - contextPath: CTIX.Result.aliases
    - contextPath: CTIX.Result.analyst_description
    - contextPath: CTIX.Result.analyst_score
    - contextPath: CTIX.Result.analyst_tlp
    - contextPath: CTIX.Result.asn
    - contextPath: CTIX.Result.attribute_field
    - contextPath: CTIX.Result.attribute_value
    - contextPath: CTIX.Result.base_type
    - contextPath: CTIX.Result.confidence_score
    - contextPath: CTIX.Result.confidence_type
    - contextPath: CTIX.Result.country
    - contextPath: CTIX.Result.created
    - contextPath: CTIX.Result.ctix_created
    - contextPath: CTIX.Result.ctix_modified
    - contextPath: CTIX.Result.ctix_score
    - contextPath: CTIX.Result.ctix_tlp
    - contextPath: CTIX.Result.defang_analyst_description
    - contextPath: CTIX.Result.description
    - contextPath: CTIX.Result.fang_analyst_description
    - contextPath: CTIX.Result.first_seen
    - contextPath: CTIX.Result.last_seen
    - contextPath: CTIX.Result.modified
    - contextPath: CTIX.Result.name
    - contextPath: CTIX.Result.pattern
    - contextPath: CTIX.Result.pattern_type
    - contextPath: CTIX.Result.pattern_version
    - contextPath: CTIX.Result.sources
    - contextPath: CTIX.Result.sub_type
    - contextPath: CTIX.Result.tld
    - contextPath: CTIX.Result.tlp
    - contextPath: CTIX.Result.type
    - contextPath: CTIX.Result.types
    - contextPath: CTIX.Result.valid_from
    - contextPath: CTIX.Result.valid_until
    description: Get Indicator Details
  - name: get_indicator_tags
    arguments:
    - name: object_id
    - name: object_type
    - name: page
      default: true
      defaultValue: "1"
    - name: page_size
      defaultValue: "10"
    outputs:
    - contextPath: CTIX.Result.notes
    - contextPath: CTIX.Result.is_deprecated
    - contextPath: CTIX.Result.is_revoked
    - contextPath: CTIX.Result.ctix_created
    - contextPath: CTIX.Result.is_false_positive
    - contextPath: CTIX.Result.name
    - contextPath: CTIX.Result.is_reviewed
    - contextPath: CTIX.Result.is_whitelisted
    - contextPath: CTIX.Result.is_under_review
    - contextPath: CTIX.Result.is_watchlist
    - contextPath: CTIX.Result.tags
    - contextPath: CTIX.Result.sub_type
    - contextPath: CTIX.Result.type
    description: Get Indicator Tags
  - name: get_indicator_relations
    arguments:
    - name: page
      defaultValue: "1"
    - name: page_size
      defaultValue: "10"
    - name: object_id
    - name: object_type
    outputs:
    - contextPath: CTIX.Result.relationship_type
    - contextPath: CTIX.Result.sources
    - contextPath: CTIX.Result.target_ref
    description: Get Indicator Relations
  - name: get_indicator_observations
    arguments:
    - name: page
    - name: page_size
    - name: object_id
    - name: object_type
    outputs:
    - contextPath: CTIX.Result.custom_attributes
    - contextPath: CTIX.Result.ctix_modified
    - contextPath: CTIX.Result.created
    - contextPath: CTIX.Result.pattern_type
    - contextPath: CTIX.Result.modified
    - contextPath: CTIX.Result.ctix_created
    - contextPath: CTIX.Result.pattern_version
    - contextPath: CTIX.Result.confidence
    - contextPath: CTIX.Result.valid_from
    - contextPath: CTIX.Result.pattern
    - contextPath: CTIX.Result.fang_description
    - contextPath: CTIX.Result.defang_description
    - contextPath: CTIX.Result.spec_version
    - contextPath: CTIX.Result.tags
    - contextPath: CTIX.Result.received_id
    - contextPath: CTIX.Result.types
    - contextPath: CTIX.Result.source
    - contextPath: CTIX.Result.id
    - contextPath: CTIX.Result.valid_until
    - contextPath: CTIX.Result.sco_object_id
    - contextPath: CTIX.Result.unique_hash
    - contextPath: CTIX.Result.description
    - contextPath: CTIX.Result.granular_markings
    - contextPath: CTIX.Result.collection
    description: Get Indicator Observations
  - name: get_conversion_feed_source
    arguments:
    - name: page
      defaultValue: "1"
    - name: page_size
      defaultValue: "10"
    - name: object_id
    - name: object_type
    outputs:
    - contextPath: CTIX.Result.created
    - contextPath: CTIX.Result.id
    - contextPath: CTIX.Result.name
    - contextPath: CTIX.Result.taxii_option
  - name: get_lookup_threat_data
    arguments:
    - name: object_type
    - name: object_names
      description: 'Will contain the SDO values. Example: If you need to get the object_ids
        of indicator 127.0.0.1 then the value will be 127.0.0.1'
      isArray: true
    - name: page_size
      description: size of the page
      defaultValue: "10"
    outputs:
    - contextPath: CTIX.ThreatDataLookup.analyst_score
    - contextPath: CTIX.ThreatDataLookup.analyst_tlp
    - contextPath: CTIX.ThreatDataLookup.confidence_score
    - contextPath: CTIX.ThreatDataLookup.confidence_type
    - contextPath: CTIX.ThreatDataLookup.country
    - contextPath: CTIX.ThreatDataLookup.created
    - contextPath: CTIX.ThreatDataLookup.ctix_created
    - contextPath: CTIX.ThreatDataLookup.ctix_modified
    - contextPath: CTIX.ThreatDataLookup.first_seen
    - contextPath: CTIX.ThreatDataLookup.id
    - contextPath: CTIX.ThreatDataLookup.indicator_type
    - contextPath: CTIX.ThreatDataLookup.ioc_type
    - contextPath: CTIX.ThreatDataLookup.is_actioned
    - contextPath: CTIX.ThreatDataLookup.is_deprecated
    - contextPath: CTIX.ThreatDataLookup.is_false_positive
    - contextPath: CTIX.ThreatDataLookup.is_reviewed
    - contextPath: CTIX.ThreatDataLookup.is_revoked
    - contextPath: CTIX.ThreatDataLookup.is_watchlist
    - contextPath: CTIX.ThreatDataLookup.is_whitelisted
    - contextPath: CTIX.ThreatDataLookup.last_seen
    - contextPath: CTIX.ThreatDataLookup.modified
    - contextPath: CTIX.ThreatDataLookup.name
    - contextPath: CTIX.ThreatDataLookup.null
    - contextPath: CTIX.ThreatDataLookup.primary_attribute
    - contextPath: CTIX.ThreatDataLookup.published_collections
    - contextPath: CTIX.ThreatDataLookup.risk_severity
    - contextPath: CTIX.ThreatDataLookup.source_collections
    - contextPath: CTIX.ThreatDataLookup.source_confidence
    - contextPath: CTIX.ThreatDataLookup.sources
    - contextPath: CTIX.ThreatDataLookup.sub_type
    - contextPath: CTIX.ThreatDataLookup.subscriber_collections
    - contextPath: CTIX.ThreatDataLookup.subscribers
    - contextPath: CTIX.ThreatDataLookup.tags
    - contextPath: CTIX.ThreatDataLookup.tlp
    - contextPath: CTIX.ThreatDataLookup.type
    - contextPath: CTIX.ThreatDataLookup.valid_from
    - contextPath: CTIX.ThreatDataLookup.valid_until
    description: Lookup to get threat data
  dockerimage: demisto/python3:3.9.8.24399
  isfetch: true
  runonce: false
  subtype: python3
sourcemoduleid: CTIX
