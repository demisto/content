
#### Integrations
##### SentinelOne V2
- Added 5 commands:
    - ***sentinelone-get-blocklist***
    - ***sentinelone-add-hash-to-blocklist***
    - ***sentinelone-remove-hash-from-blocklist***
    - ***sentinelone-fetch-file***
    - ***sentinelone-download-fetched-file***

#### Playbooks
##### New: SentinelOne - Check for New File Upload Activity
- Playbook to abstract out process of polling for  an Activity to appear in the SentinelOne Activity feed after a file upload has been requested.

We did not use GenericPolling due to a difference in semantics. GenericPolling expects a value to show up in the context when results are incomplete, and then for that value to disappear when results are present or the action is incomplete.

SentinelOne returns *no* results when incompleted, then results when complete - the opposite of GenericPolling semantics. This seemed to be the cleanest way to implement this contract.



##### New: SentinelOne - Check for New File Upload Activity - Inner Loop
- Playbook called inside a loop by  "SentinelOne - Check for New File Upload Activity". Does the actual poll of the SentinelOne Activity feed, then sleeps for 15 seconds if no result is found.

##### New: SentinelOne - Fetch File from Endpoint
- # Collect endpoint information based on SentinelOne commands.

Input:
* Hostname (Default: ${Endpoint.Hostname})
* Password (Used for protecting zip file that file is stored in)
* Path (Full path of the file)
* Timeout - how long to poll for the file to appear in the activity feed. For example, if a host is offline

Notes:
The SentinelOne API for downloading files is aynchronous. At the time this was written there is no way to correlate a request for a file to the file entry that shows up in the activities feed. So, if two requests were submitted simultaneously to download two different files from the same host, there is no way to determine which file entry in the activity entry corresponds to which request.  So this playbook *assumes* that the most recent file upload from a given agent ID that occurs *after* we submit a file fetch request is our request. It uses locks to ensure that this is the case *if* the only source of file upload request is this XSOAR playbook. If analysts on XSOAR, other playbooks, or other systems are also submitting file fetches, this logic will fail.

If a file does not exist on an endpoint, the fetch-files API will still return success, and a zip file of the upload will still be uploaded to SentinelOne. However, the zip contents will be empty, except for a metadata.json file


