commonfields:
  id: Cofense Intelligence
  version: -1
name: Cofense Intelligence
display: Cofense Intelligence (Deprecated)
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Deprecated. Use Cofense Intelligence v2 instead. Use the Cofense Intelligence integration to check the reputation of URLs, IP addresses, file hashes, and email addresses.
detaileddescription: |-
  Deprecated. Use CofenseIntelligence v2 instead.
  How to get the API key:
  1. Log in to your PhishMe account.
  2. Navigate to **Settings > API Tokens**.
  3. Click **Add a new api token**.
configuration:
- display: Server URL (e.g., https://www.threathq.com/apiv1)
  name: url
  defaultvalue: https://www.threathq.com/apiv1
  type: 0
  required: true
- display: API username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: B - Usually reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: URL Threshold (None, Minor, Moderate, or Major). Minimum severity to consider the URL malicious
  name: urlThreshold
  defaultvalue: Major
  type: 0
  required: false
- display: File Threshold (None, Minor, Moderate, or Major). Minimum severity to consider the file malicious
  name: fileThreshold
  defaultvalue: Major
  type: 0
  required: false
- display: IP Threshold (None, Minor, Moderate, or Major). Minimum severity to consider the IP malicious
  name: ipThreshold
  defaultvalue: Major
  type: 0
  required: false
- display: Email Threshold (None, Minor, Moderate, or Major). Minimum severity to consider the email malicious
  name: emailThreshold
  defaultvalue: Major
  type: 0
  required: false
script:
  script: >2-
     var reliability = params.integrationReliability;

     if(!reliability){
         reliability = 'B - Usually reliable';
     }
     var isValidReliability = function(reliability) {
         var reliability_options = ['A+ - 3rd party enrichment', 'A - Completely reliable', 'B - Usually reliable', 'C - Fairly reliable', 'D - Not usually reliable', 'E - Unreliable', 'F - Reliability cannot be judged'];
         return reliability_options.indexOf(reliability) >= 0;}
     if(!isValidReliability(reliability)) {
         return 'Error, Source Reliability value is invalid. Please choose from available reliability options.';}

      var auth = 'Basic ' + Base64.encode(params.credentials.identifier + ':' + params.credentials.password);
         var sendRequest = function(method,api,urlargs) {
             var url = params.url;
             if (url[url.length - 1] === '/') {
                 url = url.substring(0, url.length - 1);
             }
             var requestUrl = url + '/' + api + encodeToURLQuery(urlargs);
             var res = http(
                 requestUrl,
                 {
                     Method: method,
                     Headers: {
                         'Authorization': [auth]
                     }
                 },
                 params.insecure,
                 params.proxy
             );
             if ((res.StatusCode < 200 || res.StatusCode >= 300) && res.success === false) {
                 throw 'Cofense Request Failed.\nStatus code: ' + res.StatusCode + '.\nBody: ' + JSON.stringify(res) + '.';
             }
             try{
                 return JSON.parse(res.Body);
             }
             catch(exc){
                 throw "Cofense Error: JSON parse error\n" + res;
             }
         };
         var addMD = function(threat) {
             var md = "";
             md += '### Threat ID: ' + threat.id + '\n';
             if (threat.label !== undefined) {
                 md += "Name of the campaign: **" + threat.label + "**\n";
             }
             if (threat.blockSet[0].ipDetail !== undefined) {
                 md += "ASN: **" + threat.blockSet[0].ipDetail.asn + " " + threat.blockSet[0].ipDetail.asnOrganization+"**\n";
             }
             if (threat.blockSet[0].ipDetail !== undefined) {
                 md += "Country: **" + threat.blockSet[0].ipDetail.countryName + "**\n";
             }
             if (threat.executiveSummary !== undefined) {
                 md += "#### Executive Summary: \n";
             }
             if (threat.executiveSummary !== undefined) {
                 md += threat.executiveSummary + "\n";
             }
             md += "#### Threat Types:\n";
             for (var j = 0; j < threat.malwareFamilySet.length; j++){
                 md += "* " + threat.malwareFamilySet[j].description + "\n";
             }
             md += '##### Last published: ' + new Date(threat.lastPublished) +'\n';
             return md;
         };
         // Returns {severityScore: 'The severity score found', md: 'The markdown for the threat', indicatorFound: 'set to true if indicator was found in threat'}
         var checkThreat = function(threat, threshold, indicator) {
             var severityLevel = 0;
             var md = '';
             var threshold_score = calcScore(threshold);
             if (threshold_score === -1) {
                 throw "Cofense error: Invalid threshold value: " + threshold + ". Valid values are: None, Minor, Moderate or Major.";
             }
             res = {}
             for (var i = 0; i < threat.blockSet.length; i++){
                 if (threat.blockSet[i]['impact']) {
                     var threat_score = calcScore(threat.blockSet[i]['impact']);
                     var adjusted_score = threshold_score <= threat_score ? 3 : threat_score;
                     // if the queried indicator has a severity level, we'll take it
                     if (threat.blockSet[i]['data'] === indicator) {
                         severityLevel = adjusted_score;
                         res.indicatorFound = true;
                         break;
                     }
                     severityLevel = Math.max(severityLevel, adjusted_score);
                 }
             }
             var threatLevel = calcVerdict(severityLevel);
             md += 'Verdict: ' + threatLevel +'\n';
             md += addMD(threat);
             res.severityScore = severityLevel;
             res.md = md;
             return res;
         }
         var searchUrl = function(url) {
             var tmpargs = {};
             tmpargs.urlSearch = url;
             var res = sendRequest("POST","threat/search",tmpargs);
             var threats = res.data.threats;
             var ec = {};
             var md = "## Cofense URL Reputation for: "+url+"\n";
             var dbotScore = 0;
             var threatArray = [];
             var threshold = params.urlThreshold;
             var indicatorFnd = false;
             if (threats.length && threats.length !== 0) {
                 ec[outputPaths.url] = {
                     Data: url
                 };
                 for (var k = 0; k < threats.length; k++) {
                     threatAnalysis = checkThreat(threats[k], threshold, url);
                     threatArray[k] = threats[k].id;
                     md += threatAnalysis['md'];
                     if (threatAnalysis.indicatorFound) {
                         indicatorFnd = true;
                         dbotScore = threatAnalysis['severityScore'];
                     } else if (!indicatorFnd) {
                         dbotScore = Math.max(dbotScore, threatAnalysis['severityScore']);
                     }
                 }
                 ec[outputPaths.url]['Cofense'] = {};
                 ec[outputPaths.url].Cofense['ThreatIDs'] = threatArray;
                 ec["Cofense." + outputPaths.url] = {
                     Data: url,
                     ThreatIDs: threatArray
                 };
                 if (dbotScore === 3) {
                     ec[outputPaths.url].Malicious = {
                         Vendor: 'Cofense',
                         Description: 'Match found in Cofense database'
                     };
                     ec["Cofense." + outputPaths.url].Malicious = ec[outputPaths.url].Malicious;
                 }
             } else {
                 md += "No information found for this url";
             }
             ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'Cofense', Score: dbotScore, Reliability: reliability};
             return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
         };
         var extractedString = function(str,limit) {
             var tmpargs = {};
             tmpargs.extractedString = str;
             var res = sendRequest("POST","threat/search",tmpargs);
             var threats = res.data.threats;
             var countThreats = 0;
             var md = "## Cofense Search Reputation for: "+str+"\n";
             var mdBody = "";
             var ec = {};
             if (threats.length !== 0) {
                 if(limit === undefined){
                     limit = 10;
                 }
                 for(var i = 0; i < threats.length && (countThreats<limit); i++){
                     if (threats[i].hasReport === true){
                         countThreats += 1;
                         mdBody += addMD(threats[i]);
                     }
                 }
                 md += "There are " + countThreats + " threats regarding your string search.\n";
                 md += "### Details from the last campaign\n";
                 md += mdBody;
                 ec = {"Cofense" : {}};
                 ec.Cofense = {"String": str, "NumOfThreats": countThreats};
             } else {
                 md += "There are no results for this search\n";
                 ec = {"Cofense" : {}};
                 ec.Cofense = {"String": str, "NumOfThreats": 0};
             }
             return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
         };
         var checkEmail = function(sender_name) {
             var tmpargs = {};
             tmpargs.watchListEmail = sender_name;
             var res = sendRequest("POST","threat/search",tmpargs);
             var threats = res.data.threats;
             var ec = {};
             var md = "## Cofense email Reputation for: " + sender_name + "\n";
             var dbotScore = 0;
             var threatArray = [];
             var threshold = params.emailThreshold;
             var indicatorFnd = false;
             var contextEmailKey = 'Email(val.Data && val.Data === obj.Data)';
             if (threats.length && threats.length !== 0) {
                 ec[contextEmailKey] = {
                     'Data': sender_name
                 };
                 ec[outputPaths.email] = {
                     'Address': sender_name
                 };
                 for (var k = 0; k < threats.length; k++) {
                     threatAnalysis = checkThreat(threats[k], threshold, sender_name);
                     threatArray[k] = threats[k].id;
                     md += threatAnalysis['md'];
                     if (threatAnalysis.indicatorFound) {
                         indicatorFnd = true;
                         dbotScore = threatAnalysis['severityScore'];
                     } else if (!indicatorFnd) {
                         dbotScore = Math.max(dbotScore, threatAnalysis['severityScore']);
                     }
                 }
                 ec[contextEmailKey]['Cofense'] = {};
                 ec[contextEmailKey].Cofense['ThreatIDs'] = threatArray;
                 ec['Cofense.' + contextEmailKey] = {
                     Data: sender_name,
                     ThreatIDs: threatArray
                 };
                 if (dbotScore === 3) {
                     ec[outputPaths.email].Malicious = {
                         Vendor: 'Cofense',
                         Description: 'Match found in Cofense database'
                     };
                     ec["Cofense." + contextEmailKey].Malicious = ec[outputPaths.email].Malicious;
                 }
             } else {
                 md += "No infomation found for this email";
             }
             ec.DBotScore = {Indicator: sender_name, Type: 'email', Vendor: 'Cofense', Score: dbotScore, Reliability: reliability};
             return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
         };
         var checkMD5 = function(str) {
             var tmpargs = {};
             tmpargs.allMD5 = str;
             var res = sendRequest("POST","threat/search",tmpargs);
             var threats = res.data.threats;
             var ec = {};
             var md = "## Cofense Hash Reputation for: "+str+"\n";
             var dbotScore = 0;
             var threatArray = [];
             var threshold = params.fileThreshold;
             var indicatorFnd = false;
             var threshold_score = calcScore(threshold);
             if (threshold_score === -1) {
                 throw "Cofense error: Invalid threshold value: " + threshold + ". Valid values are: None, Minor, Moderate or Major.";
             }
             if (threats.length !== 0) {
                 ec[outputPaths.file] = {
                     MD5: str
                 };
                 for (var k = 0; k < threats.length; k++) {
                     var severityLevel = 0;
                     for (var i = 0; i < threats[k].blockSet.length; i++){
                         if (threats[k].blockSet[i]['impact']) {
                             var threat_score = calcScore(threats[k].blockSet[i]['impact']);
                             var adjusted_score = threshold_score <= threat_score ? 3 : threat_score;
                             // if the queried indicator has a severity level, we'll take it
                             if (threats[k].executableSet[i] && threats[k].executableSet[i]['md5Hex'] === str) {
                                 severityLevel = adjusted_score;
                                 dbotScore = severityLevel;
                                 indicatorFnd = true;
                                 break;
                             }
                             severityLevel = Math.max(severityLevel, adjusted_score);
                         }
                     }
                     var threatLevel = calcVerdict(severityLevel);
                     md += 'Verdict: ' + threatLevel +'\n';
                     md += addMD(threats[k]);
                     threatArray[k] = threats[k].id;
                     if (!indicatorFnd) {
                         dbotScore = Math.max(dbotScore, severityLevel);
                     }
                 }
                 ec[outputPaths.file]['Cofense'] = {};
                 ec[outputPaths.file]['ThreatIDs'] = threatArray;
                 ec['Cofense.' + outputPaths.file] = {
                         MD5: str,
                         ThreatIDs: threatArray
                 };
                 if (dbotScore === 3) {
                     ec[outputPaths.file].Malicious = {
                         Vendor: 'Cofense',
                         Description: 'Match found in Cofense database'
                     };
                     ec["Cofense." + outputPaths.file].Malicious = ec[outputPaths.file].Malicious;
                 }
             } else {
                 md += "No information found for this hash";
             }
             ec.DBotScore = {Indicator: str, Type: 'file', Vendor: 'Cofense', Score: dbotScore, Reliability: reliability};
             return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
         }
         var checkIP = function(ip) {
             var tmpargs = {};
             tmpargs.ip = ip;
             var res = sendRequest("POST","threat/search",tmpargs);
             var threats = res.data.threats;
             var ec = {};
             var md = "## Cofense IP Reputation for: "+ip+"\n";
             var dbotScore = 0;
             var threatArray = [];
             var threshold = params.ipThreshold;
             var indicatorFnd = false;
             var threshold_score = calcScore(threshold);
             if (threshold_score === -1) {
                 throw "Cofense error: Invalid threshold value: " + threshold + ". Valid values are: None, Minor, Moderate or Major.";
             }
             if (threats.length && threats.length !== 0) {
                 ec[outputPaths.ip] = {
                     Data: ip,
                     'Address': ip
                 };
                 for (var k = 0; k < threats.length; k++) {
                     var severityLevel = 0;
                     for (var i = 0; i < threats[k].blockSet.length; i++){
                         if (threats[k].blockSet[i].data === ip && threats[k].blockSet[i].ipDetail) {
                             ec[outputPaths.ip].ASN = threats[k].blockSet[i].ipDetail.asn;
                             ec[outputPaths.ip].GEO = {
                                 "Location": (threats[k].blockSet[i].ipDetail.latitude + ', ' + threats[k].blockSet[i].ipDetail.longitude),
                                 "Country": threats[k].blockSet[i].ipDetail.countryIsoCode
                             };
                         }
                         if (threats[k].blockSet[i]['impact']) {
                             var threat_score = calcScore(threats[k].blockSet[i]['impact']);
                             var adjusted_score = threshold_score <= threat_score ? 3 : threat_score;
                             // if the queried indicator has a severity level, we'll take it
                             if (threats[k].blockSet[i]['ipDetail'] && threats[k].blockSet[i]['ipDetail']['ip']===ip) {
                                 severityLevel = adjusted_score;
                                 dbotScore = severityLevel;
                                 indicatorFnd = true;
                                 break;
                             }
                             severityLevel = Math.max(severityLevel, adjusted_score);
                         }
                     }
                     var threatLevel = calcVerdict(severityLevel);
                     md += 'Verdict: ' + threatLevel +'\n';
                     md += addMD(threats[k]);
                     threatArray[k] = threats[k].id;
                     if (!indicatorFnd) {
                         dbotScore = Math.max(dbotScore, severityLevel);
                     }
                 }
                 ec[outputPaths.ip]['Cofense'] = {};
                 ec[outputPaths.ip].Cofense['ThreatIDs'] = threatArray;
                 ec["Cofense." + outputPaths.ip] = {
                     Data: ip,
                     ThreatIDs: threatArray
                 };
                 if (dbotScore === 3) {
                     ec[outputPaths.ip].Malicious = {
                         Vendor: 'Cofense',
                         Description: 'Match found in Cofense database'
                     };
                     ec["Cofense." + outputPaths.ip].Malicious = ec[outputPaths.ip].Malicious;
                 }
             } else {
                 md += "No information found for this ip";
             }
             ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'Cofense', Score: dbotScore, Reliability: reliability};
             return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
         }
         var calcVerdict = function (dbotScore) {
             switch (dbotScore){
                 case 0:
                     return 'Unknown';
                 case 2:
                     return 'Suspicious';
                 case 3:
                     return 'Bad';
             }
         }
         var calcScore = function (severityLevel) {
             switch (severityLevel){
                 case 'None':
                     return 0;
                 case 'Minor':
                     return 2;
                 case 'Moderate':
                     return 2;
                 case 'Major':
                     return 3;
                 default:
                     return -1;
             }
         }
         function addDays(theDate, days) {
             return theDate.getTime() - days*24*60*60*1000;
         }
         var updates = function(){
             var newDate = addDays(new Date(), 50);
             var tmpargs = {};
             tmpargs.timestamp = newDate;
             var res = sendRequest("POST","threat/updates", tmpargs);
             var ec = {};
             var md = "";
             return res;
         }
         switch (command) {
             // This is the call made when pressing the integration test button.
             case 'test-module':
                 res = updates();
                 if (res.success === true){
                     return 'ok';
                 }else {
                     return JSON.stringify(res);
                 }
             case "url":
                 return searchUrl(args.url);
             case "cofense-search":
                 return extractedString(args.str, args.limit);
             case "email":
                 return checkEmail(args.email)
             case "file":
                 return checkMD5(args.file);
             case "ip":
                 return checkIP(args.ip);
             default:
        }
  type: javascript
  commands:
  - name: url
    arguments:
    - name: url
      required: true
      default: true
      description: URL to check.
    outputs:
    - contextPath: URL.Data
      description: Bad URLs.
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: Cofense.URL.Data
      description: Bad URLs.
    - contextPath: Cofense.URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
    - contextPath: Cofense.URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
    - contextPath: Cofense.URL.Cofense.ThreatIDs
      description: The thread IDs retrieved by the vendor.
    description: Checks the reputation of a URL.
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: A CSV list of file hashes to check (MD5, SHA1, or SHA256).
    outputs:
    - contextPath: File.MD5
      description: File MD5
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: Cofense.File.MD5
      description: MD5 hash of the file.
    - contextPath: Cofense.File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
    - contextPath: Cofense.File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision.
    - contextPath: Cofense.File.ThreatIDs
      description: The thread IDs retrieved by the vendor.
    description: Checks the reputation of a file hash.
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check.
    outputs:
    - contextPath: IP.Data
      description: Bad IP Address found
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: Cofense.IP.Data
      description: Bad IP Address found
    - contextPath: Cofense.IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: Cofense.IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision
    - contextPath: Cofense.IP.Cofense.ThreatIDs
      description: The thread ids retrieved by the vendor.
    - contextPath: IP.ASN
      description: Autonomous System name for the IP.
    - contextPath: IP.GEO.Location
      description: Location in format latitude, longitude.
    - contextPath: IP.GEO.Country
      description: Country of the IP.
    - contextPath: IP.Address
      description: IP address.
      type: string
    description: Checks the reputation of an IP address.
  - name: email
    arguments:
    - name: email
      required: true
      default: true
      description: Sender email address to check.
    outputs:
    - contextPath: Email.Data
      description: Sender address to check.
    - contextPath: Account.Email.Address
      description: Sender email address to check.
    - contextPath: Account.Email.Malicious.Vendor
      description: For malicious emails, the vendor that made the decision.
    - contextPath: Account.Email.Malicious.Description
      description: For malicious emails, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: Cofense.Email.Data
      description: Sender address to check.
    - contextPath: Cofense.Email.Malicious.Vendor
      description: For malicious emails, the vendor that made the decision.
    - contextPath: Cofense.Email.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
    - contextPath: Cofense.Email.Cofense.ThreatIDs
      description: The thread ids retrieved by the vendor.
    description: Checks the reputation of an email address.
  - name: cofense-search
    arguments:
    - name: str
      required: true
      default: true
      description: String to search.
    - name: limit
      description: Maximum number of strings to search. Default is 10.
      defaultValue: "10"
    outputs:
    - contextPath: Cofense.NumOfThreats
      description: Number of threats.
    - contextPath: Cofense.String
      description: String that was searched.
    description: Searches for extracted strings identified within malware campaigns.
  runonce: false
deprecated: true
fromversion: 5.0.0
