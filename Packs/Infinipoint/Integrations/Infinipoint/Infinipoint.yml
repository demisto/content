commonfields:
  id: Infinipoint
  version: -1
name: Infinipoint
display: Infinipoint
category: Network Security
image: data:image/png;base64,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fZ1YWvulcBp7+94AJR3cKsxHTvfVmWCGd1EbeL3gG/0V0cc+RGBAIAAnNxM3/F1ljJGHDjJuL+BwCjk4sTWeoMZAZ9qiSZpTCsGXb9ZdFU9O/TR0JpQFHZzo/H48Clt5C6YkgutWd+dZCCmogt2IwMBEIMaL+SEsw0M4B07ucQ9HV9jBaXvhoGdA790eOos7uW51G1YtD9O6ixy9HRw+AAqdby+iy+wTz1Q9ErWbPOaJABHwRCCZ3+tSX4HDWZvD6ZR2cNo8ODkZKv8hh84iDu73kH+s1lXm6OHgHobOubK9p4w+9iUCRKACBJKIoUfNxkP6YzidF1McTzAHJ6eQzCt2qxOh81ro25qiM6+D2ww5/w46LuRKYxsHtwYR6cVlo8QKLidFEgEikIaAzFfBUXwID+9lOMoWlecazieogzP1J45EnFOPugg674S+dhHl02h3O9pfADom3hMvLlWQDAfXB5tE503QtwB0VEhHWoHpFEkEiEBeBJKh7IjkC555u5RuF49XY2WSHRHSW+BQDk+OUpav7NaUkj2EsqKJObGaVFINESACRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAgQASKQB4H/B08emnzJyKP9AAAAAElFTkSuQmCC
description: Use the Infinipoint integration to retrieve security and policy incompliance
  events, vulnerabilities or incidents. Investigate and respond to events in real-time.
detaileddescription: |-
  ## Hello World
  - This text is markdown
  - Here you should explain how to configure the instance in Demisto
configuration:
- display: Access Key
  name: access_key
  defaultvalue: ""
  type: 4
  required: true
- display: Private Key
  name: private_key
  defaultvalue: ""
  type: 4
  required: true
- display: Server URL (e.g. https://console.infinipoint.io)
  name: url
  defaultvalue: https://console.infinipoint.io/
  type: 0
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Maximum number of incidents per fetch
  name: max_fetch
  defaultvalue: "10"
  type: 0
  required: false
- display: First fetch time
  name: first_fetch
  defaultvalue: 3 days
  type: 0
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: page size
  name: page_size
  defaultvalue: "100"
  type: 0
  required: false
script:
  script: |-
    from typing import Any, Dict, List, Optional, cast



    ''' IMPORTS '''
    import jwt
    import math
    import struct
    import dateparser

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    '''HELPER FUNCTIONS'''


    def arg_to_timestamp(arg: Any, arg_name: str, required: bool = False) -> Optional[int]:
        """
        """

        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None

        if isinstance(arg, str) and arg.isdigit():
            # timestamp is a str containing digits - we just convert it to int
            return int(arg)
        if isinstance(arg, str):
            # we use dateparser to handle strings either in ISO8601 format, or
            # relative time stamps.
            # For example: format 2019-10-23T00:00:00 or "3 days", etc
            date = dateparser.parse(arg, settings={'TIMEZONE': 'UTC'})
            if date is None:
                # if d is None it means dateparser failed to parse it
                raise ValueError(f'Invalid date: {arg_name}')

            return int(date.timestamp())
        if isinstance(arg, (int, float)):
            # Convert to int if the input is a float
            return int(arg)
        raise ValueError(f'Invalid date: "{arg_name}"')


    def arg_to_int(arg: Any, arg_name: str, required: bool = False) -> Optional[int]:
        """
        """

        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None
        if isinstance(arg, str):
            if arg.isdigit():
                return int(arg)
            raise ValueError(f'Invalid number: "{arg_name}"="{arg}"')
        if isinstance(arg, int):
            return arg
        raise ValueError(f'Invalid number: "{arg_name}"')


    def http_request(method, token, route, page_index=0, content=None, use_pagination=True):
        """
        """
        body = None
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {token}",
        }

        if content and use_pagination:
            content['page'] = page_index

        if content is not None:
            body = json.dumps(content)

        r = requests.request(
            method,
            BASE_URL + route,
            data=body,
            headers=headers,
            verify=False
        )
        if r.status_code != 200:
            return_error('Error in API call [%d] - %s' % (r.status_code, r.reason))
        return r.json()


    def add_to_results(current_results_array, request_result):
        """
        function to add the current API call results to the results array
        input: original results array, request object as json
        output: merged arrays
        """
        try:
            return current_results_array + request_result['items']
        except Exception as e:
            # print(f"Failed to add results!\nError message:\n{e}")
            return_error(f"Failed to add results!\nError message:\n{e}")
            # sys.exit(1)


    def call_api(method, route, client, rules, use_pagination=True, condition='AND'):
        """
        loop pagination in case the total items count is bigger that PAGE_SIZE
        """

        if not use_pagination:
            res = http_request(method, client, route, content=rules, use_pagination=False)
            return res
        else:
            query = {
                'pageSize': PAGE_SIZE,
                'page': 0,
                'ruleSet': {
                    'condition': condition,
                    'rules': rules
                }
            }
            results: List[Dict[str, Any]] = []
            res = http_request(method, client, route, content=query)
            results = add_to_results(results, res)
            for i in range(1, math.ceil(res['itemsTotal'] / PAGE_SIZE)):
                res = http_request(method, client, route, i, query)
                results = add_to_results(results, res)
            return results


    def create_jwt_token(secret, access_key):
        """
        function to sign a jwt token with a jwt secret.
        input: jwt secret, jwt access-key
        output: a signed token.
        """
        try:
            jwt_payload = {
                "iat": int(time.time()),
                "sub": access_key
            }

            return jwt.encode(jwt_payload, secret.replace('\\n', '\n'), 'ES256').decode("utf-8")
        except Exception as e:
            # print(f"Error while signing JWT token - check your private/access keys!\nError message:\n{e}")
            # sys.exit(1)
            return_error(f"Error while signing JWT token - check your private/access keys!\nError message:\n{e}")


    def convert_string_to_ip(ip):
        """
        """
        convert_ip = struct.unpack("!I", socket.inet_aton(ip))[0]
        convert_ip -= (1 << 32)
        return convert_ip


    def fetch_incidents(token: Any, max_results: int, last_run: Dict[str, int],
                        first_fetch_time: Optional[int]):
        # Get the last fetch time, if exists
        # last_run is a dict with a single key, called last_fetch
        last_fetch = last_run.get('last_fetch', None)
        # Handle first fetch time
        if last_fetch is None:
            # if missing, use what provided via first_fetch_time
            last_fetch = first_fetch_time
        else:
            # otherwise use the stored last fetch
            last_fetch = int(last_fetch)

        # for type checking, making sure that latest_created_time is int
        latest_created_time = cast(int, last_fetch)

        # Initialize an empty list of incidents to return
        # Each incident is a dict with a string as a key
        incidents: List[Dict[str, Any]] = []

        args = {
            'limit': max_results,
            'offset': last_fetch
        }

        alerts = get_non_compliance_device_command(token, args)

        if not isinstance(alerts, List):
            for alert in alerts.outputs:
                # If no created_time set is as epoch (0). We use time in ms so we must
                # convert it from the HelloWorld API response
                incident_created_time = int(alert.get('timestamp', '0'))
                incident_created_time_ms = incident_created_time * 1000

                # If no name is present it will throw an exception
                incident_name = "infinipoint - non compliant device"

                incident = {
                    'name': incident_name + " - " + alert.get('hostname'),
                    'details': ', '.join([d.get('issueType', None) for d in alert['issues']]),
                    'occurred': timestamp_to_datestring(incident_created_time_ms),
                    'rawJSON': json.dumps(alert),
                    'severity': 2
                }

                incidents.append(incident)

                # Update last run and add incident if the incident is newer than last fetch
                if incident_created_time > latest_created_time:
                    latest_created_time = incident_created_time

        # Save the next_run as a dict with the last_fetch key to be stored
        next_run = {'last_fetch': latest_created_time}
        return next_run, incidents


    ''' GLOBALS/PARAMS '''

    PAGE_SIZE = arg_to_int(arg=demisto.params().get('page_size'), arg_name='page_size', required=False)
    PROXY = demisto.params().get('proxy')
    INSECURE = demisto.params().get('insecure', False)
    BASE_URL = demisto.params().get('url')
    ACCESS_KEY = demisto.params().get('access_key')
    PRIVATE_KEY = demisto.params().get('private_key')
    FIRST_FETCH_TIME = arg_to_timestamp(arg=demisto.params().get('first_fetch', '3 days'), \
                                        arg_name='First fetch time', required=True)
    MAX_INCIDENTS_TO_FETCH = 1000


    '''MAIN FUNCTIONS'''


    def test_module(token, json=None):
        """Tests API connectivity and authentication'
        Returning '200' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        """
        route = "/auth/health/"
        method = "POST"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {token}",
        }
        r = requests.request(
            method,
            BASE_URL + route,
            data=json,
            headers=headers,
            verify=INSECURE
        )
        if r.status_code != 200:
            return_error('Error in API call [%d] - %s' % (r.status_code, r.reason))


    def get_cve_command(token, args):
        cve_id = args.get('cve_id')
        method = "GET"
        route = f"/vulnerability/{cve_id}/details"
        res = http_request(method, token, route, use_pagination=False)
        LOG('res %s' % (res,))
        if "cve_id" in res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Cve.Details',
                outputs_key_field='ReportID',
                outputs=res)
            return command_results
            #   demisto.results(res)


    def get_assets_programs_command(token, args):
        name = args.get('name')
        publisher = args.get('publisher')
        version = args.get('version')
        method = "POST"
        route = "/assets/programs"
        rules = [{
            "field": "$type",
            "operator": "=",
            "value": "csv"
        }]

        if name:
            name_node = {
                "field": "name",
                "operator": "contains",
                "value": f"{name}"
            }
            rules.append(name_node)

        if publisher:
            publisher_node = {
                "field": "publisher",
                "operator": "contains",
                "value": f"{publisher}"
            }
            rules.append(publisher_node)

        if version:
            version_node = {
                "field": "version",
                "operator": "contains",
                "value": f"{version}"
            }
            rules.append(version_node)

        res = call_api(method, route, token, rules)
        LOG('results %s' % (res,))

        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Assets.Programs',
                outputs_key_field='itemsTotal',
                outputs=res)
            return command_results


    def get_assets_hardware_command(token, args):
        host = args.get('host')
        os_type = args.get('os_type')
        method = "POST"
        route = "/assets/hardware"
        rules = [{
            "field": "$type",
            "operator": "=",
            "value": "csv"
        }]

        if host:
            host_node = {
                "field": "$host",
                "operator": "contains",
                "value": f"{host}"
            }
            rules.append(host_node)

        if os_type:
            os_type_node = {
                "field": "os_type",
                "operator": "contains",
                "value": f"{os_type}"
            }
            rules.append(os_type_node)

        res = call_api(method, route, token, rules)
        LOG('results %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Assets.Hardware',
                outputs_key_field='itemsTotal',
                outputs=res)
            return command_results


    def get_assets_cloud_command(token, args):
        host = args.get('host')
        os_type = args.get('os_type')
        source = args.get('source')
        method = "POST"
        route = "/assets/cloud"
        rules = [{
            "field": "$type",
            "operator": "=",
            "value": "csv"
        }]

        if host:
            host_node = {
                "field": "$host",
                "operator": "contains",
                "value": f"{host}"
            }
            rules.append(host_node)

        if os_type:
            os_type_node = {
                "field": "os_type",
                "operator": "contains",
                "value": f"{os_type}"
            }
            rules.append(os_type_node)

        if source:
            source_node = {
                "field": "source",
                "operator": "contains",
                "value": f"{source}"
            }
            rules.append(source_node)

        res = call_api(method, route, token, rules)
        LOG('results %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Assets.Cloud',
                outputs_key_field='$host',
                outputs=res)
            return command_results


    def get_assets_user_command(token, args):
        host = args.get('host')
        username = args.get('username')
        method = "POST"
        route = "/assets/users"
        rules = [{
            "field": "$type",
            "operator": "=",
            "value": "csv"
        }]

        if host:
            host_node = {
                "field": "$host",
                "operator": "contains",
                "value": f"{host}"
            }
            rules.append(host_node)

        if username:
            username_node = {
                "field": "username",
                "operator": "contains",
                "value": f"{username}"
            }
            rules.append(username_node)

        res = call_api(method, route, token, rules)
        LOG('results %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Assets.User',
                outputs_key_field='$host',
                outputs=res)
            return command_results


    def get_devices_command(token, args):
        host = args.get('host')
        os_type = args.get('osType')
        os_name = args.get('osName')
        status = args.get('status')
        agent_version = args.get('agentVersion')
        method = "POST"
        # route = "/devices/search"
        route = "/devices"
        rules = []

        if host:
            host_node = {
                'field': 'host',
                'operator': 'contains',
                'value': f'{host}'
            }
            rules.append(host_node)

        if os_type:
            os_type_node = {
                'field': 'osType',
                'operator': '=',
                'value': f'{os_type}'
            }
            rules.append(os_type_node)

        if os_name:
            os_name_node = {
                'field': 'osName',
                'operator': 'contains',
                'value': f'{os_name}'
            }
            rules.append(os_name_node)

        if status:
            status_node = {
                'field': 'status',
                'operator': '=',
                'value': f'{status}'
            }
            rules.append(status_node)

        if agent_version:
            agent_version_node = {
                'field': 'agentVersion',
                'operator': '=',
                'value': f'{agent_version}'
            }
            rules.append(agent_version_node)

        res = call_api(method, route, token, rules)
        LOG('res %s' % (res,))

        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Devices',
                outputs_key_field='itemsTotal',
                outputs=res)
            return (command_results)
            #   demisto.results(res)


    def get_vulnerable_devices_command(token, args):
        device_os = args.get('device_os')
        device_risk = args.get('device_risk')
        method = "POST"
        route = "/vulnerability/devices"
        rules = []

        if device_os:
            device_os_node = {
                'field': 'device_os',
                'operator': '=',
                'value': f'{device_os}'
            }
            rules.append(device_os_node)

        if device_risk:
            device_risk_node = {
                'field': 'device_risk',
                'operator': '>=',
                'value': f'{device_risk}'
            }
            rules.append(device_risk_node)

        res = call_api(method, route, token, rules)
        LOG('res %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Vulnerability.Devices',
                outputs_key_field='$host',
                outputs=res)
            return command_results
            #   demisto.results(res)


    def get_tag_command(token, args):
        name = args.get('name')
        method = "POST"
        route = "/tags"
        rules = []

        if name:
            name_node = {
                'field': 'name',
                'operator': '=',
                'value': f'{name}'
            }
            rules.append(name_node)

        res = call_api(method, route, token, rules)
        LOG('res %s' % (res,))
        if res:
            # demisto.results(res)
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Tags',
                outputs_key_field='tagId',
                outputs=res)
            return command_results


    def get_networks_command(token, args):
        alias = args.get('alias')
        gateway_ip = args.get('gateway_ip')
        cidr = args.get('cidr')
        method = "POST"
        route = "/networks"
        rules = []

        if alias:
            alias_node = {
                'field': 'alias',
                'operator': '=',
                'value': f'{alias}'
            }
            rules.append(alias_node)

        if gateway_ip:
            gateway_ip_node = {
                'field': 'gatewayIp',
                'operator': '=',
                'value': f'{convert_string_to_ip(gateway_ip)}'
            }
            rules.append(gateway_ip_node)

        if cidr:
            cidr_node = {
                'field': 'cidr',
                'operator': '=',
                'value': f'{cidr}'
            }
            rules.append(cidr_node)

        res = call_api(method, route, token, rules)
        LOG('res %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Networks.Info',
                outputs_key_field='alias',
                outputs=res)
            return command_results


    def get_action_command(token, args):
        action_id = args.get('action_id')
        method = "POST"
        route = f"/responses/{action_id}"
        rules = [
            {
                "field": "$type",
                "operator": "=",
                "value": "csv"
            },
            {
                "field": "$type",
                "operator": "=",
                "value": "raw"
            }
        ]

        res = call_api(method, route, token, rules, condition='OR')
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Responses',
                outputs_key_field='$host',
                outputs=res)
            return command_results


    def get_queries_command(token, args):
        name = args.get('name')
        method = "POST"
        route = "/all-scripts/search"
        rules = []

        if name:
            name_node = {
                'field': 'name',
                'operator': 'contains',
                'value': f'{name}'
            }
            rules.append(name_node)

        res = call_api(method, route, token, rules)
        LOG('res %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Scripts.Search',
                outputs_key_field='actionId',
                outputs=res)
            return command_results


    def run_queries_command(token, args):
        id = args.get('id')
        target = args.get('target')
        method = "POST"
        route = "/all-scripts/execute"
        node = {'id': id}

        if target:
            node['target'] = {'ids': target}

        res = call_api(method, route, token, node, False)
        LOG('res %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Scripts.execute',
                outputs_key_field='actionId',
                outputs=res)
            return command_results


    def get_non_compliance_device_command(token, args):
        offset = args.get('offset')
        limit = args.get('limit')
        method = "POST"
        route = "/compliance/incidents"
        node = {'offset': offset,
                'limit': limit}

        res = call_api(method, route, token, node, False)
        LOG('res %s' % (res,))
        if res:
            command_results = CommandResults(
                outputs_prefix='Infinipoint.Compliance.Incidents',
                outputs_key_field='deviceID',
                outputs=res)
            return command_results

        return res


    ''' EXECUTION '''


    def main():

        # if not demisto.params().get('proxy', False):
        #     del os.environ['HTTP_PROXY']
        #     del os.environ['HTTPS_PROXY']
        #     del os.environ['http_proxy']
        #     del os.environ['https_proxy']

        demisto.info('command is %s' % (demisto.command(), ))

        try:
            token = create_jwt_token(PRIVATE_KEY, ACCESS_KEY)

            if demisto.command() == 'test-module':
                test_module(token)
                demisto.results('ok')

            elif demisto.command() == 'fetch-incidents':

                # Convert the argument to an int using helper function or set to MAX_INCIDENTS_TO_FETCH
                max_results = arg_to_int(
                    arg=demisto.params().get('max_fetch'),
                    arg_name='max_fetch',
                    required=False
                )
                if not max_results or max_results > MAX_INCIDENTS_TO_FETCH:
                    max_results = MAX_INCIDENTS_TO_FETCH

                next_run, incidents = fetch_incidents(
                    token,
                    max_results=max_results,
                    last_run=demisto.getLastRun(),  # getLastRun() gets the last run dict
                    first_fetch_time=FIRST_FETCH_TIME
                )
                # saves next_run for the time fetch-incidents is invoked
                demisto.setLastRun(next_run)
                # fetch-incidents calls ``demisto.incidents()`` to provide the list
                # of incidents to crate
                demisto.incidents(incidents)

            elif demisto.command() == 'infinipoint-get-cve':
                return_results(get_cve_command(token, demisto.args()))

            elif demisto.command() == 'infinipoint-get-assets-programs':
                return_results(get_assets_programs_command(token, demisto.args()))

            elif demisto.command() == 'infinipoint-get-assets-hardware':
                return_results(get_assets_hardware_command(token, demisto.args()))

            elif demisto.command() == 'infinipoint-get-assets-cloud':
                return_results(get_assets_cloud_command(token, demisto.args()))

            elif demisto.command() == 'infinipoint-get-assets-user':
                return_results(get_assets_user_command(token, demisto.args()))

            elif demisto.command() == 'infinipoint-get-device':
                return_results(get_devices_command(token, demisto.args()))

            elif demisto.command() == 'infinipoint-get-vulnerable-devices':
                return_results(get_vulnerable_devices_command(token, demisto.args()))

            elif demisto.command() == "infinipoint-get-tag":
                return_results(get_tag_command(token, demisto.args()))

            elif demisto.command() == "infinipoint-get-networks":
                return_results(get_networks_command(token, demisto.args()))

            # elif demisto.command() == "infinipoint-get-osquery":
            #     return_results(get_osquery_command(token, demisto.args()))

            # elif demisto.command() == "infinipoint-run-osquery":
            #     return_results(run_osquery_command(token, demisto.args()))

            elif demisto.command() == "infinipoint-get-queries":
                return_results(get_queries_command(token, demisto.args()))

            elif demisto.command() == "infinipoint-run-queries":
                return_results(run_queries_command(token, demisto.args()))

            # elif demisto.command() == "infinipoint-run-script":
            #     return_results(run_script_command(token, demisto.args()))

            elif demisto.command() == "infinipoint-get-action":
                return_results(get_action_command(token, demisto.args()))

            elif demisto.command() == "infinipoint-get-non-compliance":
                return_results(get_non_compliance_device_command(token, demisto.args()))

        except Exception as e:
            err_msg = f'Error - Infinipoint Integration [{e}]'
            return_error(err_msg, error=e)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  commands:
  - name: infinipoint-get-vulnerable-devices
    arguments:
    - name: device_os
    - name: device_risk
    outputs:
    - contextPath: Infinipoint.Vulnerability.Devices.$device
      type: String
    - contextPath: Infinipoint.Vulnerability.Devices.$host
      type: String
    - contextPath: Infinipoint.Vulnerability.Devices.cve_id
      type: Unknown
    - contextPath: Infinipoint.Vulnerability.Devices.device_risk
      type: Number
    - contextPath: Infinipoint.Vulnerability.Devices.device_risk_type
      type: Number
    - contextPath: Infinipoint.Vulnerability.Devices.software_name
      type: Unknown
    - contextPath: Infinipoint.Vulnerability.Devices.vulnerability_count
      type: Number
  - name: infinipoint-get-assets-programs
    arguments:
    - name: name
      auto: PREDEFINED
      predefined:
      - Software name
    - name: publisher
      auto: PREDEFINED
      predefined:
      - Software publisher name
    - name: version
      auto: PREDEFINED
      predefined:
      - Software version
    outputs:
    - contextPath: Infinipoint.Assets.Programs.items.$device
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.$host
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.$time
      type: Number
    - contextPath: Infinipoint.Assets.Programs.items.$type
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.name
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.os_type
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.program_exists
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.publisher
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.version
      type: String
    - contextPath: Infinipoint.Assets.Programs.items.install_update_date
      type: Date
    - contextPath: Infinipoint.Assets.Programs.itemsTotal
      type: Number
  - name: infinipoint-get-cve
    arguments:
    - name: cve_id
      required: true
    outputs:
    - contextPath: Infinipoint.Cve.Details.campaign_intelligence.apt
      type: String
    - contextPath: Infinipoint.Cve.Details.campaign_intelligence.description
      type: String
    - contextPath: Infinipoint.Cve.Details.campaign_intelligence.targeted_countries
      type: String
    - contextPath: Infinipoint.Cve.Details.campaign_intelligence.targeted_industries
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_description
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.ac_insuf_info
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.access_vector
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.attack_complexity
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.authentication
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.availability_impact
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.base_score
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.confidentiality_impact
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.exploitability_score
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.impact_score
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.integrity_impact
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.obtain_all_privilege
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.obtain_other_privilege
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.obtain_user_privilege
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.severity
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.user_interaction_required
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v2.vector_string
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.attack_complexity
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.attack_vector
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.availability_impact
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.base_score
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.base_severity
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.confidentiality_impact
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.exploitability_score
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.impact_score
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.integrity_impact
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.privileges_required
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.scope
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.user_interaction
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.base_metric_v3.vector_string
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.attack_complexity
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.campaigns
      type: Number
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.device_count
      type: Number
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.exploitability_risk
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.exploits
      type: Number
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.risk_label
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.risk_level
      type: Number
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.risk_type
      type: Number
    - contextPath: Infinipoint.Cve.Details.cve_dynamic_data.infinipoint_base_metric.trends_level
      type: String
    - contextPath: Infinipoint.Cve.Details.cve_id
      type: String
    - contextPath: Infinipoint.Cve.Details.cwe_description
      type: String
    - contextPath: Infinipoint.Cve.Details.cwe_id
      type: String
    - contextPath: Infinipoint.Cve.Details.devices.$device
      type: String
    - contextPath: Infinipoint.Cve.Details.devices.device_name_string
      type: String
    - contextPath: Infinipoint.Cve.Details.devices.device_os
      type: String
    - contextPath: Infinipoint.Cve.Details.devices.device_risk
      type: Number
    - contextPath: Infinipoint.Cve.Details.devices.map_id
      type: String
    - contextPath: Infinipoint.Cve.Details.devices.vulnerableProduct
      type: String
    - contextPath: Infinipoint.Cve.Details.devices.vulnerableVersion
      type: String
    - contextPath: Infinipoint.Cve.Details.scan_date
      type: Unknown
    - contextPath: Infinipoint.Cve.Details.software_list.cpe_name_string
      type: String
    - contextPath: Infinipoint.Cve.Details.software_list.cpe_type
      type: String
    - contextPath: Infinipoint.Cve.Details.top_devices.$device
      type: String
    - contextPath: Infinipoint.Cve.Details.top_devices.device_name_string
      type: String
    - contextPath: Infinipoint.Cve.Details.top_devices.device_os
      type: String
    - contextPath: Infinipoint.Cve.Details.top_devices.device_risk
      type: Number
    - contextPath: Infinipoint.Cve.Details.top_devices.map_id
      type: String
    - contextPath: Infinipoint.Cve.Details.top_devices.vulnerableProduct
      type: String
    - contextPath: Infinipoint.Cve.Details.top_devices.vulnerableVersion
      type: String
  - name: infinipoint-get-device
    arguments:
    - name: host
      auto: PREDEFINED
      predefined:
      - Devices hostname
    - name: osType
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      - "4"
      description: choose a OS type - 1 = Windows | 2 = Linux | 4 = macOS
    - name: osName
      description: Device operating system full name e.g. windows-10.0.18363.836
    - name: status
      auto: PREDEFINED
      predefined:
      - "0"
      - "1"
      description: Device current status:- 0 = Offline | 1 = Online
    - name: agentVersion
      auto: PREDEFINED
      predefined:
      - Device Infinipointâ€™s agent version
    outputs:
    - contextPath: Infinipoint.Devices.agentVersion
      type: String
    - contextPath: Infinipoint.Devices.clientType
      type: Number
    - contextPath: Infinipoint.Devices.discoveryId
      type: String
    - contextPath: Infinipoint.Devices.domain
      type: String
    - contextPath: Infinipoint.Devices.edge
      type: Number
    - contextPath: Infinipoint.Devices.ftDidRespond
      type: Number
    - contextPath: Infinipoint.Devices.ftIsSuccessful
      type: Number
    - contextPath: Infinipoint.Devices.ftResult
      type: String
    - contextPath: Infinipoint.Devices.gatewayIp
      type: Number
    - contextPath: Infinipoint.Devices.gatewayMACAddress
      type: Date
    - contextPath: Infinipoint.Devices.host
      type: String
    - contextPath: Infinipoint.Devices.id
      type: String
    - contextPath: Infinipoint.Devices.ip
      type: Number
    - contextPath: Infinipoint.Devices.lastSeen
      type: Date
    - contextPath: Infinipoint.Devices.macAddress
      type: String
    - contextPath: Infinipoint.Devices.networkId
      type: Number
    - contextPath: Infinipoint.Devices.networks.alias
      type: String
    - contextPath: Infinipoint.Devices.networks.cidr
      type: String
    - contextPath: Infinipoint.Devices.networks.gatewayIp
      type: Number
    - contextPath: Infinipoint.Devices.networks.gatewayMACAddress
      type: Date
    - contextPath: Infinipoint.Devices.osName
      type: String
    - contextPath: Infinipoint.Devices.osType
      type: Number
    - contextPath: Infinipoint.Devices.policyVersion
      type: String
    - contextPath: Infinipoint.Devices.productType
      type: String
    - contextPath: Infinipoint.Devices.regDate
      type: Date
    - contextPath: Infinipoint.Devices.status
      type: Number
    - contextPath: Infinipoint.Devices.statusCode
      type: Unknown
    - contextPath: Infinipoint.Devices.statusDescription
      type: Unknown
    - contextPath: Infinipoint.Devices.supportId
      type: Unknown
    - contextPath: Infinipoint.Devices.tags.color
      type: String
    - contextPath: Infinipoint.Devices.tags.name
      type: String
    - contextPath: Infinipoint.Devices.tags.tagId
      type: String
    - contextPath: Infinipoint.Devices.uniqueHostname
      type: String
  - name: infinipoint-get-tag
    arguments:
    - name: name
    outputs:
    - contextPath: Infinipoint.Tags.color
      type: String
    - contextPath: Infinipoint.Tags.count
      type: Number
    - contextPath: Infinipoint.Tags.description
      type: String
    - contextPath: Infinipoint.Tags.name
      type: String
    - contextPath: Infinipoint.Tags.tagId
      type: String
    - contextPath: Infinipoint.Tags.type
      type: Number
  - name: infinipoint-get-networks
    arguments:
    - name: alias
    - name: gateway_ip
    - name: cidr
    outputs:
    - contextPath: Infinipoint.Networks.Info.alias
      type: String
    - contextPath: Infinipoint.Networks.Info.cidr
      type: String
    - contextPath: Infinipoint.Networks.Info.city
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.country
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.cronExpression
      type: String
    - contextPath: Infinipoint.Networks.Info.dnsName
      type: String
    - contextPath: Infinipoint.Networks.Info.externalIp
      type: Number
    - contextPath: Infinipoint.Networks.Info.firstSeen
      type: Date
    - contextPath: Infinipoint.Networks.Info.floor
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.gatewayIp
      type: Number
    - contextPath: Infinipoint.Networks.Info.gatewayMacAddress
      type: String
    - contextPath: Infinipoint.Networks.Info.ip
      type: Number
    - contextPath: Infinipoint.Networks.Info.ipSubnetMask
      type: Number
    - contextPath: Infinipoint.Networks.Info.lastRun
      type: Date
    - contextPath: Infinipoint.Networks.Info.lastSeen
      type: Date
    - contextPath: Infinipoint.Networks.Info.latitude
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.longitude
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.managedCount
      type: Number
    - contextPath: Infinipoint.Networks.Info.name
      type: String
    - contextPath: Infinipoint.Networks.Info.networkId
      type: Number
    - contextPath: Infinipoint.Networks.Info.nextRun
      type: Date
    - contextPath: Infinipoint.Networks.Info.onPrem
      type: Number
    - contextPath: Infinipoint.Networks.Info.room
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.scheduleStatus
      type: Number
    - contextPath: Infinipoint.Networks.Info.state
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.street
      type: Unknown
    - contextPath: Infinipoint.Networks.Info.type
      type: Number
    - contextPath: Infinipoint.Networks.Info.unmanagedCount
      type: Number
  - name: infinipoint-get-assets-hardware
    arguments:
    - name: host
    - name: os_type
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      - "4"
      description: choose a OS type - 1 = Windows | 2 = Linux | 4 = macOS
    outputs:
    - contextPath: Infinipoint.Assets.Hardware.$device
      type: String
    - contextPath: Infinipoint.Assets.Hardware.$host
      type: String
    - contextPath: Infinipoint.Assets.Hardware.$time
      type: Number
    - contextPath: Infinipoint.Assets.Hardware.$type
      type: String
    - contextPath: Infinipoint.Assets.Hardware.cpu_brand
      type: String
    - contextPath: Infinipoint.Assets.Hardware.cpu_logical_cores
      type: String
    - contextPath: Infinipoint.Assets.Hardware.cpu_physical_cores
      type: String
    - contextPath: Infinipoint.Assets.Hardware.hardware_model
      type: String
    - contextPath: Infinipoint.Assets.Hardware.hardware_serial
      type: String
    - contextPath: Infinipoint.Assets.Hardware.hardware_vendor
      type: String
    - contextPath: Infinipoint.Assets.Hardware.kernel_version
      type: String
    - contextPath: Infinipoint.Assets.Hardware.os_build
      type: String
    - contextPath: Infinipoint.Assets.Hardware.os_name
      type: String
    - contextPath: Infinipoint.Assets.Hardware.os_patch_version
      type: String
    - contextPath: Infinipoint.Assets.Hardware.os_type
      type: String
    - contextPath: Infinipoint.Assets.Hardware.os_version
      type: String
    - contextPath: Infinipoint.Assets.Hardware.physical_memory
      type: String
    - contextPath: Infinipoint.Assets.Hardware.platform
      type: String
    - contextPath: Infinipoint.Assets.Hardware.user
      type: String
  - name: infinipoint-get-assets-cloud
    arguments:
    - name: host
    - name: os_type
    - name: source
      auto: PREDEFINED
      predefined:
      - AWS API
      - GCP API
      description: '"AWS API" | "GCP API"'
    outputs:
    - contextPath: Infinipoint.Assets.Cloud.$device
      type: String
    - contextPath: Infinipoint.Assets.Cloud.$host
      type: String
    - contextPath: Infinipoint.Assets.Cloud.$time
      type: Number
    - contextPath: Infinipoint.Assets.Cloud.$type
      type: String
    - contextPath: Infinipoint.Assets.Cloud.cloud_scan_timestamp
      type: Number
    - contextPath: Infinipoint.Assets.Cloud.cpu_brand
      type: String
    - contextPath: Infinipoint.Assets.Cloud.cpu_logical_cores
      type: String
    - contextPath: Infinipoint.Assets.Cloud.cpu_physical_cores
      type: String
    - contextPath: Infinipoint.Assets.Cloud.creation_time
      type: String
    - contextPath: Infinipoint.Assets.Cloud.hardware_model
      type: String
    - contextPath: Infinipoint.Assets.Cloud.hardware_serial
      type: String
    - contextPath: Infinipoint.Assets.Cloud.hardware_vendor
      type: String
    - contextPath: Infinipoint.Assets.Cloud.instance_id
      type: Date
    - contextPath: Infinipoint.Assets.Cloud.instance_state
      type: String
    - contextPath: Infinipoint.Assets.Cloud.instance_type
      type: String
    - contextPath: Infinipoint.Assets.Cloud.os_build
      type: String
    - contextPath: Infinipoint.Assets.Cloud.os_name
      type: String
    - contextPath: Infinipoint.Assets.Cloud.os_patch_version
      type: String
    - contextPath: Infinipoint.Assets.Cloud.os_type
      type: String
    - contextPath: Infinipoint.Assets.Cloud.physical_memory
      type: String
    - contextPath: Infinipoint.Assets.Cloud.platform
      type: String
    - contextPath: Infinipoint.Assets.Cloud.source
      type: String
    - contextPath: Infinipoint.Assets.Cloud.user
      type: String
    - contextPath: Infinipoint.Assets.Cloud.zone
      type: String
    - contextPath: Infinipoint.Assets.Cloud.open_ports
      type: Number
  - name: infinipoint-get-assets-user
    arguments:
    - name: host
    - name: username
    outputs:
    - contextPath: Infinipoint.Assets.User.$device
      type: String
    - contextPath: Infinipoint.Assets.User.$host
      type: String
    - contextPath: Infinipoint.Assets.User.$time
      type: Number
    - contextPath: Infinipoint.Assets.User.$type
      type: String
    - contextPath: Infinipoint.Assets.User.description
      type: String
    - contextPath: Infinipoint.Assets.User.directory
      type: String
    - contextPath: Infinipoint.Assets.User.username
      type: String
  - name: infinipoint-get-action
    arguments:
    - name: action_id
      required: true
    outputs:
    - contextPath: Infinipoint.Responses.$data
      type: String
    - contextPath: Infinipoint.Responses.$device
      type: String
    - contextPath: Infinipoint.Responses.$host
      type: String
    - contextPath: Infinipoint.Responses.$time
      type: Number
    - contextPath: Infinipoint.Responses.$type
      type: String
  - name: infinipoint-get-queries
    arguments:
    - name: name
      required: true
    outputs:
    - contextPath: Infinipoint.Scripts.Search.aggregation
      type: Number
    - contextPath: Infinipoint.Scripts.Search.createdOn
      type: Date
    - contextPath: Infinipoint.Scripts.Search.format
      type: Number
    - contextPath: Infinipoint.Scripts.Search.id
      type: String
    - contextPath: Infinipoint.Scripts.Search.interp
      type: Number
    - contextPath: Infinipoint.Scripts.Search.module
      type: Number
    - contextPath: Infinipoint.Scripts.Search.name
      type: String
    - contextPath: Infinipoint.Scripts.Search.osType
      type: Number
  - name: infinipoint-run-queries
    arguments:
    - name: id
      required: true
    - name: target
      isArray: true
    outputs:
    - contextPath: Infinipoint.Scripts.execute.actionId
      type: String
    - contextPath: Infinipoint.Scripts.execute.aggColumns
      type: String
    - contextPath: Infinipoint.Scripts.execute.devicesCount
      type: Number
    - contextPath: Infinipoint.Scripts.execute.name
      type: String
  - name: infinipoint-get-non-compliance
    arguments:
    - name: offset
      required: true
    - name: limit
      required: true
    outputs:
    - contextPath: Infinipoint.Compliance.Incidents.deviceID
      type: String
    - contextPath: Infinipoint.Compliance.Incidents.eventTime
      type: Number
    - contextPath: Infinipoint.Compliance.Incidents.hostname
      type: Date
    - contextPath: Infinipoint.Compliance.Incidents.issues.issueID
      type: String
    - contextPath: Infinipoint.Compliance.Incidents.issues.issueType
      type: String
    - contextPath: Infinipoint.Compliance.Incidents.issues.policyIdx
      type: Number
    - contextPath: Infinipoint.Compliance.Incidents.issues.ref
      type: String
    - contextPath: Infinipoint.Compliance.Incidents.policyID
      type: String
    - contextPath: Infinipoint.Compliance.Incidents.policyName
      type: String
    - contextPath: Infinipoint.Compliance.Incidents.policyVersion
      type: Number
    - contextPath: Infinipoint.Compliance.Incidents.timestamp
      type: Number
  dockerimage: demisto/pyjwt3:1.0.0.8871
  isfetch: true
  runonce: false
  subtype: python3
