//Created a generic mapping rule for fields relevant to most event types in IBM Security Verify.
[RULE: generic_fields_mapping]
alter
    src_ipv6 = arrayindex(regextract(data -> origin, "(?:[a-fA-F\d]{0,4}\:){7}[\wa-fA-F]{0,4}"),0)
| alter
    xdm.source.location.continent = geoip -> continent_name,
    xdm.source.asn.as_name = geoip -> as_org,
    xdm.source.location.city = geoip -> city_name,
    xdm.source.location.country = geoip -> country_name,
    xdm.source.location.region = geoip -> region_name,
    xdm.source.location.longitude = to_float(geoip -> location.lon),
    xdm.source.location.latitude = to_float(geoip -> location.lat),
    xdm.source.asn.as_number = to_integer(geoip -> asn),
    xdm.event.type = if(event_type = "sso", "authentication", event_type),
    xdm.event.id = id,
    xdm.source.ipv4 = if(incidr(data -> origin, "0.0.0.0/0"), data -> origin),
    xdm.source.ipv6 = src_ipv6,
    xdm.source.user_agent = data -> devicetype,
    xdm.observer.name = if(tenantname != null AND servicename != null, concat(tenantname, " - ", servicename), tenantname),
    xdm.observer.unique_identifier = tenantid;

[MODEL: dataset=ibm_security_verify_raw]
/*
Mapping of 'management' event types.
*/
filter event_type = "management"
| alter
    src_user1 = arrayindex(regextract(data -> performedby_username, "(.+)\@") ,0), // The username can sometimes appear as a username and other times as an email.
    src_user2 = arrayindex(regextract(data -> username, "(.+)\@") ,0),
    mod = if(data -> modified = "[]", null, data -> modified),
    res = lowercase(data -> result)
| alter
    xdm.event.outcome = if(res ~= "[Ss]uccess" OR res = "sent", XDM_CONST.OUTCOME_SUCCESS, res ~= "fail", XDM_CONST.OUTCOME_FAILED, res IN("pending", "sent"), XDM_CONST.OUTCOME_UNKNOWN, res = "skipped", XDM_CONST.OUTCOME_PARTIAL, res),
    xdm.event.operation_sub_type = coalesce(data -> dict_op, data -> action),
    xdm.target.application.name = data -> applicationname,
    xdm.event.description = if(data -> cause != null AND data -> modified != null, concat(rtrim(data -> cause, "."), ". modified properties: ", mod), coalesce(data -> cause, data -> modified)), // Checks if 'cause' and 'modified' are both populated. If so, appends the cause with a list of modified properties. If not, returns whichever field is available.
    xdm.event.original_event_type = data -> messageid,
    xdm.auth.mfa.method = data -> mfamethod,
    xdm.source.user.identifier = if(data -> performedby IN("System", "shared_apikey"), null, data -> performedby),
    xdm.source.application.name = coalesce(data -> performedby_clientname, if(data -> performedby IN("System", "shared_apikey"), data -> performedby)),
    xdm.source.user.username = coalesce(src_user2, data -> username, src_user1, data -> performedby_username), //2 possible username fields, performedby_username and username.
    xdm.source.user.upn = if(src_user2 != null, data -> username ,src_user1 != null, data -> performedby_username),
    xdm.target.resource.id = data -> entitlementid,
    xdm.target.resource.name = data -> entitlementname,
    xdm.target.resource.sub_type = data -> entitlementsubtype,
    xdm.target.resource.type = if(data -> entitlementtype != null AND data -> entitlementcategory != null, concat(data -> entitlementtype, " - ", data -> entitlementcategory), coalesce(data -> entitlementtype, data -> entitlementcategory, data -> resource )), // The "type" field represents the role, while the "category" field specifies the role type, e.g., "role - admin."
    xdm.source.user.groups = to_json_string(data -> entitlements) -> []
| call generic_fields_mapping;

/*
Mapping of 'sso' event types.
*/
filter event_type = "sso"
| alter
    res = lowercase(data -> result),
    src_user = arrayindex(regextract(data -> username, "(.+)\@") ,0) // The username can sometimes appear as a username and other times as an email.
| alter
    xdm.event.outcome = if(res ~= "[Ss]uccess" OR res = "sent", XDM_CONST.OUTCOME_SUCCESS, res ~= "fail", XDM_CONST.OUTCOME_FAILED, res),
    xdm.auth.service = data -> subtype,
    xdm.source.user.identifier = data -> userid,
    xdm.source.user.username = coalesce(src_user, data -> username),
    xdm.source.user.upn = if(src_user != null, data -> username),
    xdm.target.resource.id = data -> applicationid,
    xdm.target.resource.name = data -> applicationname,
    xdm.source.host.device_id = data -> deviceid, //valid only if its an Android or iPhone device.
    xdm.event.tags = arraycreate(XDM_CONST.EVENT_TAG_AUTHENTICATION),
    xdm.target.ipv4 = "", //For story 102, we hardcode the necessary fields since the data isn't available in the logs.
    xdm.source.port = 0, //For story 102, we hardcode the necessary fields since the data isn't available in the logs.
    xdm.target.port = 0, //For story 102, we hardcode the necessary fields since the data isn't available in the logs.
    xdm.event.original_event_type = event_type
| call generic_fields_mapping;

/*
Mapping of 'authentication' event types
*/
filter event_type = "authentication"
| alter
    res = lowercase(data -> result),
    src_user = arrayindex(regextract(data -> username, "(.+)\@") ,0) // The username can sometimes appear as a username and other times as an email.
| alter
    xdm.event.outcome = if(res ~= "[Ss]uccess" OR res = "sent", XDM_CONST.OUTCOME_SUCCESS, res ~= "fail", XDM_CONST.OUTCOME_FAILED, res),
    xdm.event.operation_sub_type = coalesce(data -> dict_op, data -> action),
    xdm.event.description = data -> cause,
    xdm.auth.service = data -> sourcetype,
    xdm.source.user.identifier = if(data -> subject = "UNKNOWN", null, coalesce(data -> subject, data -> performedby)),
    xdm.target.url = data -> ["target"],
    xdm.source.user.username = coalesce(src_user, data -> username),
    xdm.source.user.upn = if(src_user != null, data -> username),
    xdm.source.host.device_id = data -> deviceid,
    xdm.auth.mfa.method = data -> mfamethod,
    xdm.event.original_event_type = coalesce(data -> messageid, data -> messageId),
    xdm.session_context_id = data -> usersessionid,
    xdm.event.tags = arraycreate(XDM_CONST.EVENT_TAG_AUTHENTICATION),
    xdm.target.ipv4 = "", //For story 102, we hardcode the necessary fields since the data isn't available in the logs.
    xdm.source.port = 0, //For story 102, we hardcode the necessary fields since the data isn't available in the logs.
    xdm.target.port = 0 //For story 102, we hardcode the necessary fields since the data isn't available in the logs.
| call generic_fields_mapping;

/*
Mapping of 'slo' event types.
*/
filter event_type = "slo"
| alter
    res = lowercase(data -> result),
    src_user = arrayindex(regextract(data -> username, "(.+)\@") ,0) // The username can sometimes appear as a username and other times as an email.
| alter
    xdm.event.outcome = if(res ~= "[Ss]uccess" OR res = "sent", XDM_CONST.OUTCOME_SUCCESS, res ~= "fail", XDM_CONST.OUTCOME_FAILED, res IN("pending", "sent"), XDM_CONST.OUTCOME_UNKNOWN, res = "skipped", XDM_CONST.OUTCOME_PARTIAL, res),
    xdm.event.operation_sub_type = data -> action,
    xdm.target.application.name = data -> applicationname,
    xdm.event.description = data -> cause,
    xdm.event.outcome_reason = data -> logoutresultdetail,
    xdm.auth.service = data -> sourcetype,
    xdm.source.user.identifier = coalesce(data -> userid, data -> subject),
    xdm.source.user.username = coalesce(src_user, data -> username),
    xdm.source.user.upn = if(src_user != null, data -> username),
    xdm.target.url = data -> ["target"],
    xdm.network.session_id = data -> usersessionid
| call generic_fields_mapping;

/*
Mapping of 'access_request' event types.
*/
filter event_type = "access_request"
| alter
    inter_user1 = arrayindex(regextract(data -> approver_username, "(.+)\@") ,0), // The username can sometimes appear as a username and other times as an email.
    inter_user2 = arrayindex(regextract(data -> performedby_username, "(.+)\@") ,0),
    src_user1 = arrayindex(regextract(data -> requestor_username, "(.+)\@") ,0),
    src_user2 = arrayindex(regextract(data -> beneficiary_username, "(.+)\@") ,0),
    src_ipv6 = arrayindex(regextract(data -> origin, "(?:[a-fA-F\d]{0,4}\:){7}[\wa-fA-F]{0,4}"),0),
    action = lowercase(data -> action),
    stat = data -> status
| alter
    xdm.target.application.name = data -> applicationname,
    xdm.intermediate.user.identifier = coalesce(data -> approver, data -> performedby),
    xdm.intermediate.user.username = coalesce(inter_user1, inter_user2, data -> approver_username ,data -> performedby_username),
    xdm.intermediate.user.upn = if(inter_user1 != null, data -> approver_username, inter_user2 != null, data -> performedby_username),
    xdm.source.user.identifier = coalesce(data -> requestor, data -> beneficiary),
    xdm.source.user.username = coalesce(src_user1, src_user2, data -> username, data -> beneficiary_username),
    xdm.source.user.upn = if(src_user1 != null, data -> requestor_username, src_user2 != null, data -> beneficiary_username),
    xdm.event.description = data -> cause,
    xdm.source.user_agent = data -> devicetype,
    xdm.target.resource.name = data -> entitlement_name,
    xdm.target.resource.value = if(data -> entitlement_rights = "", null, data -> entitlement_rights),
    xdm.target.resource.type = data -> entitlement_type,
    xdm.source.ipv4 = if(incidr(data -> origin, "0.0.0.0/0"), data -> origin),
    xdm.source.ipv6 = src_ipv6,
    xdm.session_context_id = data -> request,
    xdm.event.operation_sub_type = data -> resource,
    xdm.event.type = event_type,
    xdm.event.id = id,
    xdm.event.is_completed = if(stat = "pending", False, stat IN ("invalidated", "completed"), True),
    xdm.event.outcome = if(action IN("complete", "approve"), XDM_CONST.OUTCOME_SUCCESS, action = "invalid", XDM_CONST.OUTCOME_FAILED, action = "submit", XDM_CONST.OUTCOME_PARTIAL, action),
    xdm.observer.name = if(tenantname != null AND servicename != null, concat(tenantname, " - ", servicename), tenantname),
    xdm.observer.unique_identifier = tenantid;