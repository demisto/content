commonfields:
  id: b59f86ab-d223-4ea5-81a7-82d0f9097e88
  version: 17
vcShouldKeepItemLegacyProdMachine: false
name: CortexXDRIncidentSetUp_AG-583
script: |-
  import traceback,datetime

  bypassdefaultvalues = {
      "bypassl1" : False,
      "bypassl2" : False,
      "bypasscustomer" : True
  }

  def commandExists(commandName):
      supportedcommands = demisto.getAllSupportedCommands()["CustomScripts"]
      commands = []
      for supportedcommand in supportedcommands:
          commands.append(supportedcommand["name"])
      if commandName in commands:
          return(True)
      else:
          return(False)


  # Protect the incident when the incident is not based on the proper source technology
  def checkbranderror(brand,labels=[]):
      if labels:
          for label in labels:
              if label["type"] == "Brand" and label["value"] == brand:
                      return(False)
      return(f"No \"{brand}\" brand label available. Are you sure you are in a security incident and you're running the good script ?")

  # bypass methods : check if securityIncident is created during working hours
  def checkWorkingHours(args:dict) -> dict:
      """ This method get check in the security incident is setup during woking hours
      """
      result = {}
      #return_results(args)
      # Check if the time parameters is used
      if args and "time" in args:
          #return_results(len(args))
          workingStatus = demisto.executeCommand("isWorkingHour",{"now":args["time"]})
          #return_results(workingStatus)
      else:
          workingStatus = demisto.executeCommand("isWorkingHour",{})

      if not workingStatus or isError(workingStatus[0]):
          return_error("ERROR : checkWorkingHours - error while executing script isWorkingHour")

      ### The script isWorkingHour retun a string concatenation, the fist step is to split the string to get each value (working hour/working day) sparated
      # Exemple output of is workignhours
      #       Working hour : True/False
      #       Working day : True/False
      res = workingStatus[0]["Contents"].split("\n")

      #The second step split the string to get "key" and the "value", and remove the spaces with strip() and lstrip()
      for elem in res:
          #return_results(elem)
          temp = elem.strip().split(":")
          # Convert the string data to boolean
          if temp[1].lstrip() == "True":
              result.update({temp[0].strip():True})
          else:
              result.update({temp[0].strip():False})

      #return_results(result)

      return result

  #bypass methode : get the
  def getBypassStatus(ruledata:dict) -> dict:
      """ this methode get the bypass satus set in the detection rule linked to the security incident
      """
      result = {}
      #return_results(ruledata["CustomFields"].keys())
      #return_results(ruledata["CustomFields"]["bypasscustomer"])


      # If the ticket field bypasscustomer is not set in the detectionRule Data, the default bypass value is applied
      if not "bypasscustomer" in ruledata["CustomFields"].keys():
          result = bypassdefaultvalues
      else:
      # get the value set in the detectionrule data
          for bypass_name in bypassdefaultvalues :
              result.update({bypass_name:ruledata["CustomFields"][bypass_name]})

      return result

  # bypass methode :  get the value of the workinghours bypass
  def getWorkingHoursBypass(ruledata:dict) -> bool:
      """ This methode get the workingHoursBypass value from the detection rule data, if the value is not set or not present by default its not enable
              - if the customerbypass is enabled in the detectionRule, the workingHoursbypass is set to false
      """
      bypassStatus = getBypassStatus(ruledata)
      #return_results(bypassStatus)
      # Check if the bypasscustomer is enabled =>  WorkingHoursbypass is desabled
      #   - bypasscustomer : False => bypasspass customer is enabled
      #   - bypasscustomer : True => bypass customer is desabled
      #return_results(bypassStatus["bypasscustomer"])

      if bypassStatus["bypasscustomer"] == False:
          workingHoursBypass = False
      elif not "workinghoursbypass" in ruledata["CustomFields"].keys() or not ruledata["CustomFields"]["workinghoursbypass"]:
          workingHoursBypass = False
      else:
          workingHoursBypass = ruledata["CustomFields"]["workinghoursbypass"]

      return workingHoursBypass




  def main():
      try:
          incident = demisto.incident()
          args = demisto.args()

          # Check if a tenant specific alternative to this automation exists AND it is not the current script, use it. Otherise, use the standard one coded here
          commandName = "CortexXDRIncidentSetUp_" + incident["account"]
          if commandExists(commandName):
              demisto.results(demisto.executeCommand(commandName, args))
              exit()

          # Check if the current execution context is a "Cortex XDR" security incident
          branderror = checkbranderror("Cortex XDR - IR",incident["labels"])
          if branderror:
              return_error(branderror)
              exit()

          # Get Cortex XDR configuration information
          resp = demisto.executeCommand("getList", {"listName":"Configuration - Cortex XDR"})
          if isError(resp[0]):
              return_error("Error getting list \"Configuration - Cortex XDR\" : " + resp[0]["Contents"])
              exit()
          else:
              xdrconfig = json.loads(resp[0]["Contents"])

          # Init values
          mycontext = {}
          myupdate = {}


          # Get the related rule ID
          severities = {"0":"Unknown","0.5":"informational","1":"Low","2":"Medium","3":"High","4":"Critical"}
          resp = demisto.executeCommand("getIncidents", {"query":"-status:closed type:\"Detection Rule\" detectionrulesource:\"Cortex XDR\" severity:" + severities[str(incident["severity"])]})
          if isError(resp[0]):
              return_error("Error getting the detection rule : " + resp[0]["Contents"])
          elif resp[0]["Contents"]["total"] == 0:
              return_error("Error getting the detection rule : Not found")
              exit()
          elif resp[0]["Contents"]["total"] > 1:
              return_error("Error getting the detection rule : {} found".format(resp[0]["Contents"]["total"]))
              exit()
          else:
              rule = resp[0]["Contents"]["data"][0]
              mycontext["DetectionRules"] = [rule["id"]]
              myupdate["detectionrules"] = "[{}](#/Details/{})".format(rule["name"],rule["id"])


          # Link rule with incident
          demisto.executeCommand("linkIncidents", {"linkedIncidentIDs":[rule["id"]]})


          # Manage bypass instructions
          workingHoursBypass = getWorkingHoursBypass(rule)
          workingHoursStatus = checkWorkingHours(args)
          #return_results(workingHoursBypass)
          if workingHoursBypass == False:
              return_results("Working Hours bypass isn't enabaled.")

              for bypass_name in ["bypassl1","bypassl2","bypasscustomer"] :
                  mycontext["Instructions.{}".format(bypass_name)] = rule["CustomFields"][bypass_name]

          else:
              # STEP 2 : Check the workign
              return_results("Working Hours bypass is enabaled.")

              #return_results(workingHoursStatus)
              if workingHoursStatus["Working hour"] == True and workingHoursStatus["Working day"] == True:
                  return_results("Working Hours seting : Enabaling bypass N1 and desabaling bypassN2")
                  bypassValues = {
                      "bypassl1" : True,
                      "bypassl2" : False,
                      "bypasscustomer" : True
                  }
                  """
                      bypassl1 = Pas de traitement du N1
                      bypassl2 = Traitement du N2
                      bypasscustomer = Pas d'escalade au client
                  """
              elif  workingHoursStatus["Working hour"] == False or workingHoursStatus["Working day"] == False:
                  return_results("Non-Woking Hours setting : Desabaling bypassN1 and bypassN2")
                  bypassValues = bypassdefaultvalues
                  """
                      bypassl1 = Desactivation du bypass N2
                      bypassl2 = Desactivation du bypass N2
                      bypasscustomer = pas d'escalade client
                  """
              bypass_context_key = "Instructions.{}".format(bypassValues)

              for value in bypassValues:
                  #return_results(value)
                  #return_results(bypassValues[value])
                  mycontext.update({"Instructions.{}".format(value):bypassValues[value]})

          # Manage L1 and L2 instructions
          if "reactionl1" in rule["CustomFields"] and rule["CustomFields"]["reactionl1"] :
              mycontext["Instructions.ReactionL1"] = rule["CustomFields"]["reactionl1"]
          else:
              mycontext["Instructions.ReactionL1"] = "Perform generic L1 analysis, then inform L2 that the rule documentation has to be updated"
          if "reactionl2" in rule["CustomFields"] and rule["CustomFields"]["reactionl2"] :
              mycontext["Instructions.ReactionL2"] = rule["CustomFields"]["reactionl2"]
          else:
              mycontext["Instructions.ReactionL2"] = "Perform generic L2 analysis, then update the rule documentation"


          # Manage SLAs
          demisto.executeCommand("setIncident",{"sla": int(rule["CustomFields"]["ticketcreationslavalue"]), "slaField":"ticketcreationsla"})
          demisto.executeCommand("setIncident",{"sla": int(rule["CustomFields"]["diagnosisslavalue"]), "slaField":"diagnosissla"})
          demisto.executeCommand("setIncident",{"sla": int(rule["CustomFields"]["diagnosisslal2value"]), "slaField":"diagnosisslal2"})
          demisto.executeCommand("setIncident",{"sla": int(rule["CustomFields"]["timetoassigntocustomerslavalue"]), "slaField":"timetoassigntocustomer"})


          # Manage SLA pause in NWH
          mycontext["WorkingHourOnlySLA.ticketcreationsla"] = rule["CustomFields"]["pauseticketcreationslainnwh"]
          mycontext["WorkingHourOnlySLA.diagnosissla"] = rule["CustomFields"]["pausediagnosisslainnwh"]
          mycontext["WorkingHourOnlySLA.diagnosisslal2"] = rule["CustomFields"]["pausediagnosisslal2innwh"]
          mycontext["WorkingHourOnlySLA.timetoassigntocustomer"] = rule["CustomFields"]["pausetimetoassigntocustomerinnwh"]


          # Manage assignment groups
          myupdate["l1assignmentgroup"] = rule["CustomFields"]["l1assignmentgroup"]
          myupdate["l2assignmentgroup"] = rule["CustomFields"]["l2assignmentgroup"]
          if "customerassignmentgroup" in rule["CustomFields"].keys() and rule["CustomFields"]["customerassignmentgroup"]:
              myupdate["customerassignmentgroup"] = rule["CustomFields"]["customerassignmentgroup"]
          else:
              myupdate["customerassignmentgroup"] = incident["account"]


          # Manage the production status
          if xdrconfig["productionstatus"]:
              myupdate["productionstatus"] = "Production"
          else:
              myupdate["productionstatus"] = "Integration"


          # Manage automatic response playbook
          if "automaticresponseplaybook" in rule["CustomFields"] and rule["CustomFields"]["automaticresponseplaybook"] != "None" :
              myupdate["automaticresponseplaybook"] = rule["CustomFields"]["automaticresponseplaybook"]
          else:
              myupdate["automaticresponseplaybook"] = ""


          # Set Mitre Attack
          if "mitreattcktactics" in rule["CustomFields"]:
              myupdate["mitreattcktactics"] = rule["CustomFields"]["mitreattcktactics"]
          if "mitreattcktechniques" in rule["CustomFields"]:
              myupdate["mitreattcktechniques"] = rule["CustomFields"]["mitreattcktechniques"]
          if "mitreattcksubtechniques" in rule["CustomFields"]:
              myupdate["mitreattcksubtechniques"] = rule["CustomFields"]["mitreattcksubtechniques"]


          return_results("====  FIELDS  ====\n\n" + json.dumps(myupdate,indent=4) + "\n\n====  CONTEXT  ====\n\n" + json.dumps(mycontext,indent=4))
          #exit()
          # Update incident
          # Pushing ticket update
          resp = demisto.executeCommand("setIncident", myupdate)
          if not resp :
              return_error("Error : 'setIncident' command did not respond.")
          elif isError(resp[0]) or resp[0]["Contents"] != "done" :
              return_error("Error : 'setIncident' command returned an error. Details : {}".format(resp[0]["Contents"]))
          for delContextKey in ["Instructions","WorkingHourOnlySLA","DetectionRules"]:
              demisto.executeCommand("delContext", {"key":delContextKey})
          return_results(CommandResults(outputs=mycontext))


      except Exception as ex:
          demisto.error(traceback.format_exc())  # print the traceback
          return_error(f'Failed to execute BaseScript. Error: {str(ex)}')


  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()
type: python
tags:
- Cortex XDR
- devamu
comment: |-
  Set up the incident when coming from Cortex XDR with the following pre-filling and properties.
  - Link the rule documentation
  - Set Severity according to the XDR alert's
  - Set the SLA
  - Get the workflow instructions
  - Get the instructions for analysts
  - Set the "details" and "diagnosis" value according to the templates
  - Check Working Hours bypass mecanism
enabled: true
args:
- name: time
  description: 'Use a custom time, default is now. Format : 2021-07-22T11:10:21.309271+00:00'
scripttarget: 0
subtype: python3
pswd: ""
runonce: false
dockerimage: demisto/python3:3.10.4.28442
runas: DBotWeakRole
engineinfo: {}
mainengineinfo: {}
