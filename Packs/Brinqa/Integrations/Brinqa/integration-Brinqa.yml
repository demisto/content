category: Vulnerability Management
commonfields:
  id: Brinqa
  version: -1
configuration:
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: false
  section: Collect
  type: 15
- display: username
  displaypassword: password
  name: credentials
  required: true
  type: 9
- defaultvalue: https://<instance-name>.brinqa.net
  display: Server URL (e.g., https://<instance-name>.brinqa.net
  name: url
  required: true
  section: Connect
  type: 0
- defaultvalue: "10"
  display: Maximum number of alerts per fetch
  name: max_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: Set this to determine the HelloWorld score that will determine if
    an IP is malicious (0-100)
  advanced: true
  defaultvalue: "65"
  display: Score threshold for IP reputation command
  name: threshold_ip
  required: false
  section: Collect
  type: 0
- defaultvalue: low
  display: Severity of alerts to fetch
  name: severity
  options:
  - low
  - medium
  - high
  - critical
  required: true
  section: Collect
  type: 15
- defaultvalue: 3 days
  display: First fetch time
  name: first_fetch
  required: false
  section: Collect
  type: 0
- advanced: true
  defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    isoverridable: false
    itemVersion: ""
    packID: 28988477-0d73-4eb3-8e56-54f7f31cd73e
    packName: Brinqa Contribution Pack
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: The Brinqa integration for Cortex XSOAR enables analysts to query cyber
  asset inventory and risk context from Brinqa Cyber Risk Platform (CAASM GraphQL
  API). This pack currently provides an operation to search Hosts by displayName with
  rich attributes—risk scores, profiles, owners, OS, IPs, DNS names, subnets, categories,
  compliance status, and more.
detaileddescription: |2-
    # BrinqaQL Integration
    https://docs.brinqa.com/docs/brinqa-api/

    Authentication & MFA Limitation
    The integration uses username/password authentication to obtain a token from Brinqa’s /api/auth/login endpoint.
    Important: If Multi-Factor Authentication (MFA) is enabled for the user or service account, this integration will not work, because MFA requires an interactive challenge that cannot be satisfied by API calls.
    Recommendation:

    Use a dedicated service account without MFA for automation purposes.
    Apply least-privilege principles and strong password policies for that account.

    Installation & Setup

    1.Install from Marketplace (or upload this pack manually).
    2.Add an instance of the integration:

    URL: Your Brinqa base URL (e.g., https://<instance>.brinqa.com).
    Credentials: Username/Password (a service account is recommended).
    Trust & Certificates:

    3.Configure proxy if your environment requires outbound proxy.

    4.Ensure MFA is disabled for the account used.
    5.Save and run Test from the Integration instance.
display: Brinqa
name: Brinqa
script:
  commands:
  - arguments:
    - name: display_name
      required: true
    - name: limit
    description: Queries hosts on brinqa
    name: brinqa-query-hosts
    outputs:
    - contextPath: Brinqa.Hosts
  - arguments: []
    name: test-brinqa-connection
  - arguments:
    - defaultValue: Empty by Default
      description: The "filter" string. ex.) "displayName CONTAINS <displayName>"
      name: search
    - defaultValue: id displayName
      description: 'Fields to return, not comma separated ex.) "id displayName" '
      name: fields
    - defaultValue: "10"
      name: limit
    - description: the table to query
      name: table
      required: true
    description: queries any table, use graphQL Explorer for queries
    name: brinqa-query
    outputs:
    - contextPath: Brinqa.QueryResults
    - {}
  - arguments:
    - defaultValue: id displayName
      description: fields to return ex:) id displayName
      name: fields
    - description: known as "filter" ex) "displayName CONTAINS <displayName>"
      name: search
    - defaultValue: "10"
      name: limit
    description: queries vulnerabilities
    name: brinqa-query-vulnerabilities
    outputs:
    - contextPath: Brinqa.Vulnerabilities
  dockerimage: demisto/python3:3.12.8.3296088
  runonce: false
  script: |-
    register_module_line('Brinqa', 'start', __line__())
    CONSTANT_PACK_VERSION = '1.0.0'
    demisto.debug('pack id = Brinqa, pack version = 1.0.0')

    import requests

    """HELPER FUNCTIONS"""

    def login_brinqa(base_url: str, username: str, password: str, verify: bool) -> str:
        # Login endpoint for token retrieval
        login_url = f"{base_url}/api/auth/login"
        headers = {
            "Accept": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "Content-Type": "application/json"
        }
        payload = {"username": username, "password": password}
        response = requests.post(login_url, headers=headers, json=payload, verify=False)
        response.raise_for_status()
        data = response.json()
        api_key = data.get("token") or data.get("api_key") or data.get("access_token")
        if not api_key:
            raise DemistoException("Login failed: No token returned.")
        return api_key

    class Client(BaseClient):
        def __init__(self, base_url: str, headers: dict, verify: bool, proxy: bool):
            super().__init__(base_url=base_url, verify=verify, headers=headers, proxy=proxy)

        # query hosts
        def query_hosts(self, display_name: str, limit: int = 10) -> dict:
            query = f'''
            query MyQuery {{
                hosts(filter: "displayName CONTAINS {display_name}", limit: {limit}) {{
                    id complianceStatus displayName firstSeen lastUpdated
                    type{{name}} riskScore profiles{{name}} riskOwner{{name}}
                    environments{{name}} categories description dnsNames ipAddresses
                    privateDnsName publicDnsName publicIpAddresses macAddresses
                    subnets{{name}} os owners{{name emails}}
                }}
            }}
            '''
            payload = {
                "query": query,
                "variables": None,
                "operationName": "MyQuery"
            }
            response = self._http_request(method='POST', json_data=payload)
            return response

        # query vulnerabilities
        def query_vulnerabilities(self, search: str, fields: str="description port riskScore results name displayName targets{{displayName}}",limit: int = 10) -> dict:
            if search is not None and search != "":
                search = f'''filter: "{search}", '''
                query = f'''
                query MyQuery {{
                    vulnerabilities({search}limit: {limit}){{
                        {fields}
                    }}
                }}
                '''
            else:
                query = f'''
                query MyQuery {{
                    vulnerabilities(limit: {limit}){{
                        {fields}
                    }}
                }}
                '''
            payload = {
                "query": query,
                "variables": None,
                "operationName": "MyQuery"
            }
            response = self._http_request(method='POST', json_data=payload)
            return response

        # regular request
        def query(self, table: str, search: str, fields: str="id displayName", limit: int = 10) -> dict:
            if search is not None and search != "":
                search = f'''filter: "{search}", '''
                query = f'''
                query MyQuery {{
                    {table}({search}limit: {limit}){{
                        {fields}
                    }}
                }}
                '''
            else:
                query = f'''
                query MyQuery {{
                    {table}(limit: {limit}){{
                        {fields}
                    }}
                }}
                '''
            payload = {
                "query": query,
                "variables": None,
                "operationName": "MyQuery"
            }
            response = self._http_request(method='POST', json_data=payload)
            return response

    def brinqa_query_command(client: Client, args: dict) -> CommandResults:
        table = args.get('table')
        fields = args.get('fields')
        search = args.get('search')
        limit = int(args.get('limit', 10))
        result = client.query(table, search, fields, limit)
        results = result.get('data', {}).get(table, [])
        readable_output = tableToMarkdown('Brinqa Query Results', results)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Brinqa.QueryResults',
            outputs_key_field='id',
            outputs=results
        )

    def brinqa_query_hosts_command(client: Client, args: dict) -> CommandResults:
        display_name = args.get('display_name')
        limit = int(args.get('limit', 10))
        result = client.query_hosts(display_name, limit)
        hosts = result.get('data', {}).get('hosts', [])
        readable_output = tableToMarkdown('Brinqa Hosts', hosts)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Brinqa.Host',
            outputs_key_field='id',
            outputs=hosts
        )

    def brinqa_query_vulnerabilities_command(client: Client, args: dict) -> CommandResults:
        fields = args.get('fields')
        search = args.get('search')
        limit = int(args.get('limit', 10))
        result = client.query_vulnerabilities(fields, search, limit)
        results = result.get('data', {}).get('vulnerabilities', [])
        readable_output = tableToMarkdown('Brinqa Query Results', results)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Brinqa.Vulnerabilities',
            outputs_key_field='id',
            outputs=results
        )

    def test_module(client: Client) -> str:
        try:
            client.query_hosts("")
            return 'ok'
        except Exception as e:
            return f"Test failed: {str(e)}"

    def main():
        params = demisto.params()
        args = demisto.args()

        base_url = params.get("url")
        verify_certificate = not params.get("insecure", False)
        proxy = params.get("proxy", False)


        credentials = params.get("credentials",{})

        username=credentials.get("identifier")
        password=credentials.get("password")
        if not username or not password:
            raise ValueError("Username or password is missing in integration parameters.")

        # Authenticate and get token
        api_key = login_brinqa(base_url, username, password, verify_certificate)

        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Accept-Encoding": "gzip, deflate"
        }

        graphql_url = f"{base_url}/graphql/caasm"
        client = Client(base_url=graphql_url, headers=headers, verify=verify_certificate, proxy=proxy)

        try:
            command = demisto.command()
            if command == "test-module":
                return_results(test_module(client))
            elif command == 'brinqa-query-hosts':
                return_results(brinqa_query_hosts_command(client, args))
            elif command == 'brinqa-query':
                return_results(brinqa_query_command(client, args))
            elif command == 'brinqa-query-vulnerabilities':
                return_results(brinqa_query_vulnerabilities_command(client, args))
            else:
                raise NotImplementedError(f"Command {command} is not implemented")
        except Exception as e:
            return_error(f"Failed to execute command. Error: {str(e)}")

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
    register_module_line('Brinqa', 'end', __line__())
  subtype: python3
  type: python
