commonfields:
  id: Atlassian Cloud IT Admin
  version: -1
name: Atlassian Cloud IT Admin
display: Atlassian Cloud IT Admin
category: IT Services
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACB1BMVEUAAAAAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUswAUsz///9RcTzXAAAAq3RSTlMAAF1SB/0EFBEJDxUWBhITARAlJiMnGhcMC1+biOYgRjDJrMXtnkyVsYXnN/EDgPdZDqCU4OKpLTT5vNJmdPYyavprk/CYtVxp31vbbL6aLK98nInEHH85kGK/1GCy9IN9+6OqGTby2nDQCDtBRf713q1EPgXGtIpvdmi9P6bZx+vBHUekdZfoux4N73pXcmRT86i5eVg9osAzknhtmZYKi1puZyEkro5NgpFkhSzDAAAAAWJLR0SsV2XyiwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+QIBg4YJ3mV5xEAAAKySURBVFjD7ZTXV1NBEMZ3ohJCkVAMijFIUxAEEzAaEQzESgkgKiixIk1UULBgV4odsWAXe8Hvn3T2bgJBJS9yDj7s93DP7J3y25m9d4XQ0tLS0tLS+v9ENF/ceSKTaUE4mIyNULim39OUIc0ZxlRqeImI4IVYFEVhXHO0hbPMMVJmoti4IDh+cYJVQRKTkhOMyvEpS2yyuiV1KanUZTI4KjYxhsNiEyKD04Dl03sjO7CCyAGldAuwUm0oA8iU5W1Z0pFtE5RjhKwSYjVypScPWCP3xhWRTzYUrI14woVGWGhpLUIB1pHTVVyC9cVuB4M3GI6N8AA27nMTSjeXucu3CC8qyip9WyuF2IbtcgDlnLqDK+3kirsoBp4IHVN8lZfDqkMtUw1qTSiV5+OHS44VqDMc9WjYjUaun4E9e43z24fsJnWczbJj2o8DVWjhZQAHW5BHOEQR+j0MVwWTjygyUTW3exSy4DG08jNagek4YKlDURRRWzvHd3QSObvkyH0nFJiog9v1oFuCfSeBU6d7IoCTgN4z8qQcCnwW6Os/h/O8kmAhGJwiu7qAEnNSDy5Ku2mgHoaVfMnlweUgmFlX+rPk0AO4Srm4hnaaveHrzOy+wY+b6keoDX5Ut4jBbgUejEsma7l630tUXOUk6sIQdQ7zyEdwOwi+E0y9SwHOvNcD3J8d/EBGWh7K56iMagMKH5WNPcYTErl4yq9SjWL0DDCNdtYA45St6j+nIWUMkHiBl/QqlOomL2fSGLuss4JHX9vtw0Rv7HbfWwkefNcoZzk+UUhizC+/0Pcf7I2+j/Rp4rN0NIyY6EuNv7614SsJZ6A589v3Ph7VD38apYdSJyk/x8SW9+dkhFH/dkGF3Uhixu30xyLsdvvLZRbyijnVzGt0bmtraWlpaWlpaWn9k34BV5TmeMKhwu0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMDZUMTQ6MjQ6MzkrMDA6MDBBisL4AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTA2VDE0OjI0OjM5KzAwOjAwMNd6RAAAABp0RVh0ZXhpZjpCaXRzUGVyU2FtcGxlADgsIDgsIDgS7T4nAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTg6MDk6MjQgMTE6NDg6MzL0WsJqAAAAFHRFWHRleGlmOkltYWdlTGVuZ3RoADYzMFP7bEMAAAAUdEVYdGV4aWY6SW1hZ2VXaWR0aAAxMjAwFJLlZAAAABl0RVh0ZXhpZjpTb2Z0d2FyZQBHSU1QIDIuMTAuNq40aUoAAAAjdEVYdHNvZnR3YXJlAGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3JnyvbSXAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABd0RVh0VGh1bWI6OkltYWdlOjpIZWlnaHQANTCQoD5eAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADEyMN5Wme8AAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAEXRFWHRUaHVtYjo6U2l6ZQA1MzUzQlQXVMYAAAAWdEVYdFRodW1iOjpVUkkAZmlsZTovL1BORzqmKmciAAAAAElFTkSuQmCC
description: "Atlassian Integration consists of set of endpoints that allows the customers\
  \ to do the following-\n1.\tGet / Retrieve user information from Atlassian Cloud\n\
  2.\tCreate a user in Atlassian Cloud\n3.\tUpdate a user in Atlassian Cloud \n4.\t\
  Disable a user in Atlassian Cloud\n5.\tEnable a user in Atlassian Cloud\n"
detaileddescription: "•\tFrom your organization at admin.atlassian.com, select Settings\
  \ and then API keys.\n•\tClick Create API key in the top right.\n•\tEnter a name\
  \ that you’ll remember to identify the API key.\n•\tBy default, the key expires\
  \ one week from today. If you’d like to change the expiration date, pick a new date\
  \ under Expires on. You’re unable to select a date longer than a year from the date\
  \ of creation.\n•\tClick Create to save the API key.\n•\tCopy the values for your\
  \ Organization ID and API key. You'll need those to access your organization later.\n\
  •\tClick Done and you’ll see the key in your list of API keys.\nFor any questions,\
  \ reach out to the #demisto-developers channel on the DFIR Community on Slack (https://dfircommunity.slack.com)\n"
configuration:
- display: Atlassian URL (e.g. https://example.net)
  name: url
  defaultvalue: ""
  type: 0
  required: true
  additionalinfo: URL to connect to the Atlassian Service
- display: token
  name: token
  defaultvalue: ""
  type: 4
  required: true
  additionalinfo: Authorization token to connect to the Atlassian API
- display: Directory Id
  name: directoryId
  defaultvalue: ""
  type: 0
  required: true
  additionalinfo: Directory id mapped to directory
- display: Custom Mapping For Create User
  name: customMappingCreateUser
  defaultvalue: ""
  type: 12
  required: false
  additionalinfo: An optional custom mapping that takes custom values in the SCIM
    data into the integration.
- display: Custom Mapping For Update User
  name: customMappingUpdateUser
  defaultvalue: ""
  type: 12
  required: false
  additionalinfo: An optional custom mapping that takes custom values in the SCIM
    data into the integration.
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
  additionalinfo: Whether to use the system proxy
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
  additionalinfo: Whether to accept insecure certificates
script:
  script: |-
    ''' IMPORTS '''

    import json
    import requests
    import traceback

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' CONSTANTS '''
    SCIM_EXTENSION_SCHEMA = "urn:scim:schemas:extension:custom:1.0:user"
    USER_NOT_FOUND = "User not found"
    USER_DISABLED = "User disabled"
    CUSTOM_MAPPING_CREATE = demisto.params().get('customMappingCreateUser')
    CUSTOM_MAPPING_UPDATE = demisto.params().get('customMappingUpdateUser')


    class Client(BaseClient):
        """
        Client will implement the service API,
        and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def __init__(self, base_url, token, directory_id, headers, verify=True, proxy=False):
            self.base_url = base_url
            self.token = token
            self.directory_id = directory_id
            self.verify = verify
            self.headers = headers
            self.session = requests.Session()
            if not proxy:
                self.session.trust_env = False
            self.headers['Authorization'] = 'Bearer ' + self.token

        def http_request(self, method, url_suffix, params=None, data=None, headers=None):

            if not headers:
                headers = self.headers
            full_url = self.base_url + url_suffix
            res = requests.request(
                method,
                full_url,
                verify=self.verify,
                params=params,
                json=data,
                headers=headers
            )

            return res

        def get_user(self, input_type, user_term):
            if input_type == 'id':
                uri = f'/scim/directory/{encode_string_results(self.directory_id)}/Users/{encode_string_results(user_term)}'
            else:
                user_term = "\"" + user_term + "\""
                uri = f'/scim/directory/{encode_string_results(self.directory_id)}' \
                      f'/Users?filter={encode_string_results(input_type)} eq {encode_string_results(user_term)}'
            return self.http_request(
                method='GET',
                url_suffix=uri,
            )

        def create_user(self, data):
            uri = f'/scim/directory/{encode_string_results(self.directory_id)}/Users/'
            return self.http_request(
                method='POST',
                url_suffix=uri,
                data=data
            )

        def update_user(self, user_term, data):
            uri = f'/scim/directory/{encode_string_results(self.directory_id)}/Users/{encode_string_results(user_term)}'
            return self.http_request(
                method='PUT',
                url_suffix=uri,
                data=data,
            )

        def enable_disable_user(self, user_term, data):
            uri = f'/scim/directory/{encode_string_results(self.directory_id)}/Users/{encode_string_results(user_term)}'
            return self.http_request(
                method='PATCH',
                url_suffix=uri,
                data=data,
            )

        # Builds a new user atlassian_user dict with pre-defined keys and custom mapping (for user)
        def build_atlassian_user(self, args, atlassian_user, scim, fn):
            extension_schema = scim.get(SCIM_EXTENSION_SCHEMA)
            custom_mapping = None

            if fn == 'create':
                custom_mapping_fromparams = CUSTOM_MAPPING_CREATE
            else:
                custom_mapping_fromparams = CUSTOM_MAPPING_UPDATE

            if args.get('customMapping'):
                custom_mapping = json.loads(args.get('customMapping'))
            elif custom_mapping_fromparams:
                custom_mapping = json.loads(custom_mapping_fromparams)

            if custom_mapping and extension_schema:
                for key, value in custom_mapping.items():
                    # key is the attribute name in input scim. value is the attribute name of app profile
                    user_extension_data = extension_schema.get(key)
                    if user_extension_data:
                        atlassian_user[value] = user_extension_data

            return atlassian_user


    class OutputContext:
        """
            Class to build a generic output and context.
        """

        def __init__(self, success=None, active=None, iden=None, username=None, email=None, errorCode=None,
                     errorMessage=None, details=None):
            self.instanceName = demisto.callingContext['context']['IntegrationInstance']
            self.brand = demisto.callingContext['context']['IntegrationBrand']
            self.command = demisto.command().replace('-', '_').title().replace('_', '')
            self.success = success
            self.active = active
            self.iden = iden
            self.username = username
            self.email = email
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.details = details
            self.data = {
                "brand": self.brand,
                "instanceName": self.instanceName,
                "success": success,
                "active": active,
                "id": iden,
                "username": username,
                "email": email,
                "errorCode": errorCode,
                "errorMessage": errorMessage,
                "details": details
            }


    def verify_and_load_scim_data(scim):
        try:
            scim = json.loads(scim)
        except Exception:
            pass
        if type(scim) != dict:
            raise Exception("SCIM data is not a valid JSON ")
        return scim


    def map_scim(scim):
        mapping = {
            "userName": "userName",
            "email": "emails(val.primary && val.primary==true).value",
            "first_name": "name.givenName",
            "last_name": "name.familyName",
            "active": "active",
            "id": "id",
        }

        parsed_scim = dict()
        for k, v in mapping.items():
            try:
                value = demisto.dt(scim, v)
                if type(value) == list:
                    parsed_scim[k] = value[0]
                else:
                    parsed_scim[k] = value
            except Exception:
                parsed_scim[k] = None
        return parsed_scim


    def map_changes_to_existing_user(existing_user, new_json):
        for key, value in new_json.items():
            if type(value) == list:
                # handle in specific way
                # as of now only emails needs to be handled
                if key == 'emails':
                    existing_email_list = existing_user.get(key)

                    # update
                    for new_json_item in value:
                        for existing_json_item in existing_email_list:
                            if existing_json_item.get('type') == new_json_item.get('type'):
                                if existing_json_item.get('value') != new_json_item.get('value'):
                                    existing_json_item['value'] = new_json_item.get('value')
                                if new_json_item.get('primary', None) is not None:
                                    existing_json_item['primary'] = new_json_item.get('primary')
                                else:
                                    if existing_json_item.get('primary', None) is not None:
                                        existing_json_item['primary'] = existing_json_item.get('primary')
                                break

                    # add
                    new_email_list = []
                    for new_json_item in value:
                        exist = False
                        for existing_json_item in existing_email_list:
                            if new_json_item.get('type') == existing_json_item.get('type', ''):
                                exist = True
                                break
                        if not exist:
                            new_email = {'type': new_json_item.get('type'),
                                         'value': new_json_item.get('value')}
                            if new_json_item.get('primary', None) is not None:
                                new_email.update({'primary': new_json_item.get('primary')})
                            new_email_list.append(new_email)
                    existing_email_list.extend(new_email_list)

            elif type(value) == dict:
                if key != SCIM_EXTENSION_SCHEMA:
                    map_changes_to_existing_user(existing_user.get(key), value)
            else:
                existing_user[key] = value


    ''' COMMAND FUNCTIONS '''


    def test_module(client, args):
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        Args:
            client: Atlassian client

        Returns:
            'ok' if test passed, anything else will fail the test.
        """

        """result = client.http_request('DBot')
        if res.status_code == 200:
            return 'ok'
        else:
            raise Exception"""

        uri = f'/scim/directory/{encode_string_results(client.directory_id)}/Users/1234'
        res = client.http_request(method='GET', url_suffix=uri)
        if res.status_code == 403:
            err_msg = 'Invalid url: '+ client.base_url + f'/scim/directory/{encode_string_results(client.directory_id)}'
            raise Exception(f"{res.status_code} - {err_msg}")
        elif res.status_code == 401:
            raise Exception(f"{res.status_code} - {res.json().get('message')}")
        else:
            return 'ok', None, None

    def get_user_command(client, args):
        """
            Returning user GET details and status of response.

            Args:   demisto command line argument
            client: Atlassian

            Returns:
                success : success=True, id, email, login as username, details, active status
                fail : success=False, id, login as username, errorCode, errorMessage, details
        """

        scim = verify_and_load_scim_data(args.get('scim'))
        scim_flat_data = map_scim(scim)
        user_id = scim_flat_data.get('id')
        username = scim_flat_data.get('userName')

        input_type = None
        if not (user_id or username):
            raise Exception('You must provide either the id or userName of the user')

        if user_id:
            user_term = user_id
            input_type = 'id'
        else:
            user_term = username
            input_type = 'userName'

        res = client.get_user(input_type, user_term)

        res_json = res.json()
        generic_iam_context_data_list = []

        if res.status_code == 404 or res_json.get('totalResults', '') == 0:
            if input_type == 'userName':
                generic_iam_context = OutputContext(success=False, iden=user_id, username=user_term,
                                                    errorCode=404,
                                                    errorMessage=USER_NOT_FOUND, details=res_json)
            else:
                generic_iam_context = OutputContext(success=False, iden=user_id,
                                                    errorCode=404,
                                                    errorMessage=USER_NOT_FOUND, details=res_json)
            generic_iam_context_data_list.append(generic_iam_context.data)

        elif res.status_code == 200:
            if input_type == 'id':
                id = res_json.get('id')
                emails = res_json.get('emails')
                email = None
                for each in emails:
                    if each.get('primary'):
                        email = each.get('value')
                active = res_json.get('active')
                username = res_json.get('userName')
                generic_iam_context = OutputContext(success=True, iden=id, username=username, email=email, details=res_json,
                                                    active=active)
            else:
                username = res_json.get("Resources")[0].get("userName")
                id = res_json.get("Resources")[0].get("id")
                emails = res_json.get("Resources")[0].get("emails")
                email = None
                for each in emails:
                    if each.get('primary'):
                        email = each.get('value')
                active = res_json.get("Resources")[0].get("active")
                generic_iam_context = OutputContext(success=True, iden=id, username=username, email=email, details=res_json,
                                                    active=active)
            generic_iam_context_data_list.append(generic_iam_context.data)
        else:
            generic_iam_context = OutputContext(success=False, iden=user_id, username=username,
                                                errorCode=res.status_code,
                                                errorMessage=res.headers.get('status'), details=res_json)
            generic_iam_context_data_list.append(generic_iam_context.data)

        generic_iam_context_dt = f'{generic_iam_context.command}(val.id == obj.id && val.instanceName == obj.instanceName)'
        outputs = {
            generic_iam_context_dt: generic_iam_context_data_list
        }

        readable_output = tableToMarkdown(name='Get Atlassian User:',
                                          t=generic_iam_context_data_list,
                                          headers=["brand", "instanceName", "success", "active", "id",
                                                   "username", "email",
                                                   "errorCode", "errorMessage", "details"],
                                          removeNull=True)
        return (
            readable_output,
            outputs,
            generic_iam_context_data_list
        )


    def create_user_command(client, args):
        """
            Create user using POST to Atlassian  API, if Connection to the service is successful.

            Args: demisto command line argument
            client: Atlassian

            Returns:
                success : success=True, id, email, login as username, details, active status
                fail : success=False, id, login as username, errorCode, errorMessage, details
        """

        scim = verify_and_load_scim_data(args.get('scim'))
        parsed_scim = map_scim(scim)
        atlassian_user = scim
        atlassian_user = client.build_atlassian_user(args, atlassian_user, scim, 'create')

        # Removing Elements from atlassian_user dictionary which was not sent as part of scim
        atlassian_user = {key: value for key, value in atlassian_user.items() if value is not None}

        res = client.create_user(atlassian_user)
        res_json = res.json()

        if res.status_code == 201:
            generic_iam_context = OutputContext(success=True,
                                                iden=res_json.get('id', None),
                                                email=parsed_scim.get('email'),
                                                details=res_json,
                                                username=parsed_scim.get('userName'),
                                                active=True)

        else:
            generic_iam_context = OutputContext(success=False,
                                                iden=parsed_scim.get('id'),
                                                email=parsed_scim.get('email'),
                                                errorCode=res.status_code,
                                                errorMessage=res_json.get('detail'),
                                                username=parsed_scim.get('userName'),
                                                details=res_json)

        generic_iam_context_dt = f'{generic_iam_context.command}(val.id == obj.id && val.instanceName == obj.instanceName)'

        outputs = {
            generic_iam_context_dt: generic_iam_context.data
        }

        readable_output = tableToMarkdown(name='Create Atlassian User:',
                                          t=generic_iam_context.data,
                                          headers=["brand", "instanceName", "success", "active", "id",
                                                   "username", "email",
                                                   "errorCode", "errorMessage", "details"],
                                          removeNull=True)

        return (
            readable_output,
            outputs,
            generic_iam_context.data
        )


    def update_user_command(client, args):
        """
            Update user using PUT to Atlassian API , if Connection to the service is successful.

            Args:   demisto command line argument
            client: Atlassian

            Returns:
                success : success=True, id, email, login as username, details, active status
                fail : success=False, id, login as username, errorCod, errorMessage, details
        """

        old_scim = verify_and_load_scim_data(args.get('oldScim'))
        new_scim = verify_and_load_scim_data(args.get('newScim'))

        parsed_old_scim = map_scim(old_scim)
        user_id = parsed_old_scim.get('id')
        userName = parsed_old_scim.get('userName')

        if not (user_id or userName):
            raise Exception('You must provide id or userName of the user')

        if user_id:
            input_type = 'id'
            user_term = user_id
        else:
            input_type = 'userName'
            user_term = userName

        res = client.get_user(input_type, user_term)
        existing_user = res.json()

        if (res.status_code == 200 and input_type == 'id') or \
                (existing_user.get('totalResults') != 0 and input_type == 'userName'):
            if input_type == 'userName':
                existing_user = existing_user.get('Resources')[0]
            map_changes_to_existing_user(existing_user, new_scim)
            # custom mapping
            atlassian_user = client.build_atlassian_user(args, existing_user, new_scim, 'update')
            # Removing Elements from github_user dictionary which was not sent as part of scim
            atlassian_user = {key: value for key, value in atlassian_user.items() if value is not None}
            res_update = client.update_user(user_term=existing_user.get('id'), data=atlassian_user)
            res_json_update = res_update.json()

            if res_update.status_code == 200:
                generic_iam_context = OutputContext(success=True,
                                                    iden=res_json_update.get('id'),
                                                    username=res_json_update.get('userName'),
                                                    email=res_json_update.get('emails')[0].get('value'),
                                                    details=res_json_update,
                                                    active=True)
            else:
                generic_iam_context = OutputContext(success=False,
                                                    iden=user_id,
                                                    username=userName,
                                                    errorCode=res_update.status_code,
                                                    errorMessage=res_json_update.get('detail'),
                                                    details=res_json_update)
        elif existing_user.get('totalResults') == 0:
            generic_iam_context = OutputContext(success=False, iden=user_id, username=userName,
                                                errorCode=404,
                                                errorMessage=USER_NOT_FOUND, details=existing_user)
        elif res.status_code != 200:
            # api returns 404, not found for user not found case.
            generic_iam_context = OutputContext(success=False, iden=user_id, username=userName,
                                                errorCode=res.status_code,
                                                errorMessage=res.headers.get('status'), details=existing_user)

        generic_iam_context_dt = f'{generic_iam_context.command}(val.id == obj.id && val.instanceName == obj.instanceName)'

        outputs = {
            generic_iam_context_dt: generic_iam_context.data
        }

        readable_output = tableToMarkdown(name='Updated Atlassian User:',
                                          t=generic_iam_context.data,
                                          headers=["brand", "instanceName", "success", "active", "id",
                                                   "username", "email",
                                                   "errorCode", "errorMessage", "details"],
                                          removeNull=True)

        return (
            readable_output,
            outputs,
            generic_iam_context.data
        )


    def disable_user_command(client, args):
       return enablee_disable_user_command(client, args, False)

    def enable_user_command(client, args):
       return enablee_disable_user_command(client, args, True)

    def enablee_disable_user_command(client, args, is_active):
        """
            Enable user by setting active = true in Atlassian API , if Connection to the service is successful.

            Args:   demisto command line argument
            client: Atlassian API

            Returns:
                success : success=True, id as iden, active status
                fail : success=False, id as iden, errorCod, errorMessage, details
        """
        scim = verify_and_load_scim_data(args.get('scim'))
        scim_flat_data = map_scim(scim)
        user_id = scim_flat_data.get('id')

        if not user_id:
            raise Exception('You must provide either the id of the user')

        data = {
                    "Operations":[
                       {
                        "op":"replace",
                        "value":
                         {
                             "active": is_active
                         }
                       }
                    ]
                }

        res = client.enable_disable_user(user_id, data)

        if res.status_code == 200:
            generic_iam_context = OutputContext(success=True,
                                                    iden=user_id,
                                                    details=USER_DISABLED,
                                                    active=False)
        else:
            generic_iam_context = OutputContext(success=False,
                                                    iden=user_id,
                                                    errorCode=res.status_code,
                                                    errorMessage=res.json().get('detail'),
                                                    details=res.json())

        generic_iam_context_dt = f'{generic_iam_context.command}(val.id == obj.id && val.instanceName == obj.instanceName)'
        outputs = {
            generic_iam_context_dt: generic_iam_context.data
        }

        readable_output = tableToMarkdown(name='Disable Atlassian User:',
                                          t=generic_iam_context.data,
                                          headers=["brand", "instanceName", "success", "active", "id",
                                                   "username", "email",
                                                   "errorCode", "errorMessage", "details"],
                                          removeNull=True)

        return (
            readable_output,
            outputs,
            generic_iam_context.data
        )


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """

        params = demisto.params()

        base_url = params.get('url')
        token = params.get('token')
        directory_id = params.get('directoryId')

        headers = {
            'accept': 'application/json',
            'content-type': 'application/json',
        }

        proxy = demisto.params().get('proxy', False)
        verify_certificate = not demisto.params().get('insecure', False)
        command = demisto.command()

        demisto.debug(f'Command being called is {demisto.command()}')

        # Commands supported for Atlassian API for user
        commands = {
            'test-module': test_module,
            'get-user': get_user_command,
            'create-user': create_user_command,
            'update-user': update_user_command,
            'enable-user': enable_user_command,
            'disable-user': disable_user_command
        }

        try:
            client = Client(
                base_url=base_url,
                token=token,
                directory_id=directory_id,
                verify=verify_certificate,
                proxy=proxy,
                headers=headers)

            if command in commands:
                human_readable, outputs, raw_response = commands[command](client, demisto.args())
                return_outputs(readable_output=human_readable, outputs=outputs, raw_response=raw_response)

        # Log exceptions
        except Exception:
            demisto.error(f'Failed to execute {demisto.command()} command. Traceback: {traceback.format_exc()}')
            return_error(f'Failed to execute {demisto.command()} command. Traceback: {traceback.format_exc()}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  commands:
  - name: get-user
    arguments:
    - name: scim
      required: true
      description: SCIM User JSON with id or email populated. User?s id or userName
        will be used for lookup.
    outputs:
    - contextPath: GetUser
      description: Command context path
      type: unknown
    - contextPath: GetUser.status
      description: 'User status, set to one of the following values:  trueor false'
      type: boolean
    - contextPath: GetUser.brand
      description: User's brand name.
      type: string
    - contextPath: GetUser.details
      description: Gives the user information if the API is success else error information
      type: string
    - contextPath: 'GetUser.email '
      description: 'User''3s email address. '
      type: string
    - contextPath: 'GetUser.errorCode '
      description: 'Error code in the case of exception.  Example: 404'
      type: number
    - contextPath: 'GetUser.errorMessage '
      description: 'Error message in the case of exception. Example: ?User not Found?'
      type: string
    - contextPath: 'GetUser.id '
      description: 'User''s id '
      type: string
    - contextPath: GetUser.instanceName
      description: Instance name for the Integration.
      type: string
    - contextPath: GetUser.success
      description: Success status. Can be True or False
      type: boolean
    description: Retrieve the user details based on id or username.
  - name: create-user
    arguments:
    - name: scim
      required: true
      description: SCIM content in JSON format
    - name: customMapping
      description: An optional custom mapping that takes custom values in the SCIM
        data into the integration.
    outputs:
    - contextPath: CreateUser
      description: Command context path
      type: Unknown
    - contextPath: CreateUser.brand
      description: Name of the Integration
      type: string
    - contextPath: CreateUser.instanceName
      description: Name of the instance used for testing
      type: string
    - contextPath: CreateUser.success
      description: Status of the result. Can be true or false.
      type: boolean
    - contextPath: CreateUser.active
      description: 'Gives the active status of user. Can be true of false. '
      type: boolean
    - contextPath: CreateUser.id
      description: Value of id passed as argument
      type: number
    - contextPath: CreateUser.email
      description: Value of email ID passed as argument
      type: string
    - contextPath: CreateUser.errorCode
      description: 'HTTP error response code '
      type: number
    - contextPath: CreateUser.errorMessage
      description: Reason why the API is failed
      type: string
    - contextPath: CreateUser.details
      description: Gives the user information if the API is success else error information
      type: string
    description: This command creates the user based on the scim and custom map passed
      in argument.
  - name: update-user
    arguments:
    - name: oldScim
      required: true
      description: Old SCIM content in JSON format
    - name: newScim
      required: true
      description: New SCIM content in JSON format
    - name: customMapping
      description: An optional custom mapping that takes custom values in the SCIM
        data into the integration.
    outputs:
    - contextPath: UpdateUser
      description: Command context path
      type: Unknown
    - contextPath: UpdateUser.brand
      description: Name of the Integration
      type: string
    - contextPath: UpdateUser.instanceName
      description: Name of the instance used for testing
      type: string
    - contextPath: UpdateUser.success
      description: Status of the result. Can be true or false.
      type: boolean
    - contextPath: UpdateUser.active
      description: 'Gives the active status of user. Can be true of false. '
      type: boolean
    - contextPath: UpdateUser.id
      description: Value of id passed as argument
      type: string
    - contextPath: UpdateUser.email
      description: Value of email ID passed as argument
      type: string
    - contextPath: UpdateUser.errorCode
      description: HTTP error response code
      type: number
    - contextPath: UpdateUser.errorMessage
      description: ' Reason why the API is failed'
      type: string
    - contextPath: UpdateUser.details
      description: Gives the user information if the API is success else error information
      type: string
    description: Update a user
  - name: disable-user
    arguments:
    - name: scim
      required: true
      description: SCIM User JSON with user_id whose user details needs to be removed.
    outputs:
    - contextPath: DisableUser
      description: Command context path
      type: Unknown
    - contextPath: DisableUser.status
      description: 'User status, set to one of the following values: '
      type: boolean
    - contextPath: DisableUser.brand
      description: User's brand name.
      type: string
    - contextPath: DisableUser.details
      description: User?s details including id, email, firtsName, lastName, groupAdmin
        etc.
      type: string
    - contextPath: 'DisableUser.email '
      description: 'User''s email address. '
      type: string
    - contextPath: 'DisableUser.errorCode '
      description: 'Error code in the case of exception.  Example: 404'
      type: number
    - contextPath: 'DisableUser.errorMessage '
      description: 'Error message in the case of exception. Example: ?User not Found?'
      type: string
    - contextPath: 'DisableUser.Users.id '
      description: 'User''s id '
      type: string
    - contextPath: DisableUser.instanceName
      description: Instance name for the Integration.
      type: string
    - contextPath: DisableUser.success
      description: Success status. Can be True or False
      type: boolean
    description: This command disables the user.
    execution: true
  - name: enable-user
    arguments:
    - name: scim
      required: true
      description: SCIM content in JSON format
    - name: customMapping
      description: An optional custom mapping that takes custom values in the SCIM
        data into the integration.
    outputs:
    - contextPath: EnableUser
      description: Command context path
      type: Unknown
    - contextPath: EnableUser.brand
      description: Name of the Integration
      type: string
    - contextPath: EnableUser.instanceName
      description: Name of the instance used for testing
      type: string
    - contextPath: EnableUser.success
      description: Status of the result. Can be true or false.
      type: boolean
    - contextPath: EnableUser.active
      description: 'Gives the active status of user. Can be true of false. '
      type: boolean
    - contextPath: EnableUser.id
      description: Value of id passed as argument
      type: string
    - contextPath: EnableUser.email
      description: Value of email ID passed as argument
      type: string
    - contextPath: EnableUser.errorCode
      description: 'HTTP error response code '
      type: number
    - contextPath: EnableUser.errorMessage
      description: Reason why the API is failed
      type: string
    - contextPath: EnableUser.details
      description: Gives the user information if the API is success else error information
      type: string
    description: This command enables the user.
  - name: test-module
    arguments: []
    description: test module
  dockerimage: demisto/python3:3.7.4.2245
  runonce: false
  subtype: python3
fromversion: 5.0.0
