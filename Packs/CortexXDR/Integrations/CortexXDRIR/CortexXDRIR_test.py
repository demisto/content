import json
import pytest
import copy
import demistomock as demisto

XDR_URL = 'https://api.xdrurl.com'


def load_test_data(json_path):
    with open(json_path) as f:
        return json.load(f)


def test_get_incident_list(requests_mock):
    from CortexXDRIR import get_incidents_command, Client

    get_incidents_list_response = load_test_data('./test_data/get_incidents_list.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incidents/', json=get_incidents_list_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'incident_id_list': '1 day'
    }
    _, outputs, _ = get_incidents_command(client, args)

    expected_output = {
        'PaloAltoNetworksXDR.Incident(val.incident_id==obj.incident_id)':
            get_incidents_list_response.get('reply').get('incidents')
    }
    assert expected_output == outputs


def test_fetch_incidents(requests_mock, mocker):
    from CortexXDRIR import fetch_incidents, Client, sort_all_list_incident_fields
    import copy

    get_incidents_list_response = load_test_data('./test_data/get_incidents_list.json')
    raw_incident = load_test_data('./test_data/get_incident_extra_data.json')
    modified_raw_incident = raw_incident['reply']['incident'].copy()
    modified_raw_incident['alerts'] = copy.deepcopy(raw_incident['reply'].get('alerts').get('data'))
    modified_raw_incident['file_artifacts'] = raw_incident['reply'].get('file_artifacts').get('data')
    modified_raw_incident['network_artifacts'] = raw_incident['reply'].get('network_artifacts').get('data')
    modified_raw_incident['mirror_direction'] = 'In'
    modified_raw_incident['mirror_instance'] = 'MyInstance'

    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incidents/', json=get_incidents_list_response)
    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/', json=raw_incident)
    mocker.patch.object(demisto, 'params', return_value={"extra_data": True, "mirror_direction": "Incoming"})

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    modified_raw_incident.get('alerts')[0]['host_ip_list'] = \
        modified_raw_incident.get('alerts')[0].get('host_ip').split(',')

    next_run, incidents = fetch_incidents(client, '3 month', 'MyInstance')
    sort_all_list_incident_fields(modified_raw_incident)

    assert len(incidents) == 2
    assert incidents[0]['name'] == "#1 - 'Local Analysis Malware' generated by XDR Agent detected on host AAAAA " \
                                   "involving user Administrator"

    if 'network_artifacts' not in json.loads(incidents[0]['rawJSON']):
        assert False
    assert incidents[0]['rawJSON'] == json.dumps(modified_raw_incident)


def return_extra_data_result(*args):
    if args[1].get('incident_id') == '2':
        raise Exception("Rate limit exceeded")
    else:
        incident_from_extra_data_command = load_test_data('./test_data/incident_example_from_extra_data_command.json')
        return {}, {}, {"incident": incident_from_extra_data_command}


def test_fetch_incidents_with_rate_limit_error(requests_mock, mocker):
    """
    Given:
        - a Rate limit error occurs in the second call for 'get_extra_data_command'
    When
        - running fetch_incidents command
    Then
        - the first successful incident is being created
        - the second incident is saved for the next run
    """
    from CortexXDRIR import fetch_incidents, Client, sort_all_list_incident_fields
    get_incidents_list_response = load_test_data('./test_data/get_incidents_list.json')
    raw_incident = load_test_data('./test_data/get_incident_extra_data.json')
    modified_raw_incident = raw_incident['reply']['incident'].copy()
    modified_raw_incident['alerts'] = raw_incident['reply'].get('alerts').get('data')
    modified_raw_incident['file_artifacts'] = raw_incident['reply'].get('file_artifacts').get('data')
    modified_raw_incident['network_artifacts'] = raw_incident['reply'].get('network_artifacts').get('data')
    modified_raw_incident['mirror_direction'] = 'In'
    modified_raw_incident['mirror_instance'] = 'MyInstance'

    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incidents/', json=get_incidents_list_response)
    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/', json=raw_incident)

    mocker.patch('CortexXDRIR.get_incident_extra_data_command', side_effect=return_extra_data_result)

    mocker.patch.object(demisto, 'params', return_value={"extra_data": True, "mirror_direction": "Incoming"})

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    next_run, incidents = fetch_incidents(client, '3 month', 'MyInstance')
    sort_all_list_incident_fields(modified_raw_incident)

    assert len(incidents) == 1  # because the second one raised a rate limit error
    assert incidents[0]['name'] == "#1 - 'Local Analysis Malware' generated by XDR Agent detected on host AAAAA " \
                                   "involving user Administrator"
    incidents_from_previous_run = next_run.get('incidents_from_previous_run')
    assert incidents_from_previous_run
    assert len(incidents_from_previous_run) == 1
    assert incidents_from_previous_run[0].get('incident_id') == '2'
    if 'network_artifacts' not in json.loads(incidents[0]['rawJSON']):
        assert False
    assert incidents[0]['rawJSON'] == json.dumps(modified_raw_incident)


def test_get_incident_extra_data(requests_mock):
    from CortexXDRIR import get_incident_extra_data_command, Client

    get_incident_extra_data_response = load_test_data('./test_data/get_incident_extra_data_host_id_array.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/',
                       json=get_incident_extra_data_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'incident_id': '1'
    }
    _, outputs, _ = get_incident_extra_data_command(client, args)

    expected_incident = get_incident_extra_data_response.get('reply').get('incident')
    excepted_alert_modified = get_incident_extra_data_response.get('reply').get('alerts').get('data').copy()

    excepted_alert_modified[0]['host_ip_list'] = excepted_alert_modified[0].get('host_ip').split(',')

    expected_incident.update({
        'alerts': excepted_alert_modified,
        'network_artifacts': get_incident_extra_data_response.get('reply').get('network_artifacts').get('data', []),
        'file_artifacts': get_incident_extra_data_response.get('reply').get('file_artifacts').get('data')
    })

    expected_output = {
        'PaloAltoNetworksXDR.Incident(val.incident_id==obj.incident_id)': expected_incident
    }
    assert expected_output == outputs


def test_update_incident(requests_mock):
    from CortexXDRIR import update_incident_command, Client

    update_incident_response = load_test_data('./test_data/update_incident.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/update_incident/', json=update_incident_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'incident_id': '1',
        'status': 'new'
    }
    readable_output, outputs, _ = update_incident_command(client, args)

    assert outputs is None
    assert readable_output == 'Incident 1 has been updated'


def test_get_endpoints(requests_mock):
    from CortexXDRIR import get_endpoints_command, Client

    get_endpoints_response = load_test_data('./test_data/get_endpoints.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_endpoint/', json=get_endpoints_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'hostname': 'foo',
        'page': 1,
        'limit': 3
    }

    _, outputs, _ = get_endpoints_command(client, args)
    assert get_endpoints_response.get('reply').get('endpoints') == \
           outputs['PaloAltoNetworksXDR.Endpoint(val.endpoint_id == obj.endpoint_id)']


def test_get_all_endpoints_using_limit(requests_mock):
    from CortexXDRIR import get_endpoints_command, Client

    get_endpoints_response = load_test_data('./test_data/get_all_endpoints.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_endpoints/', json=get_endpoints_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'limit': 1,
        'page': 0,
        'sort_order': 'asc'
    }

    _, outputs, _ = get_endpoints_command(client, args)
    expected_endpoint = get_endpoints_response.get('reply')[0]

    assert [expected_endpoint] == outputs['PaloAltoNetworksXDR.Endpoint(val.endpoint_id == obj.endpoint_id)']


def test_insert_parsed_alert(requests_mock):
    from CortexXDRIR import insert_parsed_alert_command, Client

    insert_alerts_response = load_test_data('./test_data/create_alerts.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/alerts/insert_parsed_alerts/', json=insert_alerts_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        "product": "VPN & Firewall-1",
        "vendor": "Check Point",
        "local_ip": "192.168.1.254",
        "local_port": "35398",
        "remote_ip": "0.0.0.0",
        "remote_port": "0",
        "event_timestamp": "1543270652000",
        "severity": "Low",
        "alert_name": "Alert Name Example",
        "alert_description": "Alert Description"
    }

    readable_output, outputs, _ = insert_parsed_alert_command(client, args)
    assert outputs is None
    assert readable_output == 'Alert inserted successfully'


def test_isolate_endpoint(requests_mock):
    from CortexXDRIR import isolate_endpoint_command, Client

    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_endpoint/', json={
        'reply': {
            'endpoints': [
                {
                    'endpoint_id': '1111',
                    "endpoint_status": "CONNECTED"
                }
            ]
        }
    })

    isolate_endpoint_response = load_test_data('./test_data/isolate_endpoint.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/isolate', json=isolate_endpoint_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        "endpoint_id": "1111"
    }

    readable_output, _, _ = isolate_endpoint_command(client, args)
    assert readable_output == 'The isolation request has been submitted successfully on Endpoint 1111.\n' \
                              'To check the endpoint isolation status please run:' \
                              ' !xdr-get-endpoints endpoint_id_list=1111 and look at the [is_isolated] field.'


def test_isolate_endpoint_unconnected_machine(requests_mock, mocker):
    from CortexXDRIR import isolate_endpoint_command, Client
    #    return_error_mock = mocker.patch(RETURN_ERROR_TARGET)

    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_endpoint/', json={
        'reply': {
            'endpoints': [
                {
                    'endpoint_id': '1111',
                    "endpoint_status": "DISCONNECTED"
                }
            ]
        }
    })

    isolate_endpoint_response = load_test_data('./test_data/isolate_endpoint.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/isolate', json=isolate_endpoint_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        "endpoint_id": "1111"
    }
    with pytest.raises(ValueError, match='Error: Endpoint 1111 is disconnected and therefore can not be isolated.'):
        isolate_endpoint_command(client, args)


def test_unisolate_endpoint(requests_mock):
    from CortexXDRIR import unisolate_endpoint_command, Client

    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_endpoint/', json={
        'reply': {
            'endpoints': [
                {
                    'endpoint_id': '1111',
                    "endpoint_status": "CONNECTED"
                }
            ]
        }
    })

    unisolate_endpoint_response = load_test_data('./test_data/unisolate_endpoint.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/unisolate', json=unisolate_endpoint_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        "endpoint_id": "1111"
    }

    readable_output, _, _ = unisolate_endpoint_command(client, args)
    assert readable_output == 'The un-isolation request has been submitted successfully on Endpoint 1111.\n' \
                              'To check the endpoint isolation status please run:' \
                              ' !xdr-get-endpoints endpoint_id_list=1111 and look at the [is_isolated] field.'


def test_unisolate_endpoint_pending_isolation(requests_mock):
    from CortexXDRIR import unisolate_endpoint_command, Client

    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_endpoint/', json={
        'reply': {
            'endpoints': [
                {
                    'endpoint_id': '1111',
                    "is_isolated": "AGENT_PENDING_ISOLATION"
                }
            ]
        }
    })

    unisolate_endpoint_response = load_test_data('./test_data/unisolate_endpoint.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/unisolate', json=unisolate_endpoint_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        "endpoint_id": "1111"
    }
    with pytest.raises(ValueError, match='Error: Endpoint 1111 is pending isolation and therefore can not be'
                                         ' un-isolated.'):
        unisolate_endpoint_command(client, args)


def test_get_distribution_url(requests_mock):
    from CortexXDRIR import get_distribution_url_command, Client

    get_distribution_url_response = load_test_data('./test_data/get_distribution_url.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/distributions/get_dist_url/', json=get_distribution_url_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        'distribution_id': '1111',
        'package_type': 'x86'
    }

    readable_output, outputs, _ = get_distribution_url_command(client, args)
    expected_url = get_distribution_url_response.get('reply').get('distribution_url')
    assert outputs == {
        'PaloAltoNetworksXDR.Distribution(val.id == obj.id)': {
            'id': '1111',
            'url': expected_url
        }
    }

    assert readable_output == f'[Distribution URL]({expected_url})'


def test_get_audit_management_logs(requests_mock):
    from CortexXDRIR import get_audit_management_logs_command, Client

    get_audit_management_logs_response = load_test_data('./test_data/get_audit_management_logs.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/audits/management_logs/', json=get_audit_management_logs_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        'email': 'woo@demisto.com',
        'limit': '3',
        'timestamp_gte': '3 month'
    }

    readable_output, outputs, _ = get_audit_management_logs_command(client, args)

    expected_outputs = get_audit_management_logs_response.get('reply').get('data')
    assert outputs['PaloAltoNetworksXDR.AuditManagementLogs(val.AUDIT_ID == obj.AUDIT_ID)'] == expected_outputs


def test_get_audit_agent_reports(requests_mock):
    from CortexXDRIR import get_audit_agent_reports_command, Client

    get_audit_agent_reports_response = load_test_data('./test_data/get_audit_agent_report.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/audits/agents_reports/', json=get_audit_agent_reports_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        'endpoint_names': 'woo.demisto',
        'limit': '3',
        'timestamp_gte': '3 month'
    }

    readable_output, outputs, _ = get_audit_agent_reports_command(client, args)
    expected_outputs = get_audit_agent_reports_response.get('reply').get('data')
    assert outputs['PaloAltoNetworksXDR.AuditAgentReports'] == expected_outputs


def test_insert_cef_alerts(requests_mock):
    from CortexXDRIR import insert_cef_alerts_command, Client

    insert_cef_alerts_response = load_test_data('./test_data/insert_cef_alerts.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/alerts/insert_cef_alerts/', json=insert_cef_alerts_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        'cef_alerts': [
            'CEF:0|Check Point|VPN-1 & FireWall-1|Check Point|Log|microsoft-ds|Unknown|act=AcceptdeviceDirection=0 '
            'rt=1569477512000 spt=56957 dpt=445 cs2Label=Rule Name cs2=ADPrimery '
            'layer_name=FW_Device_blackened Securitylayer_uuid=07693fc7-1a5c-4f31-8afe-77ae96c71b8c match_id=1806 '
            'parent_rule=0rule_action=Accept rule_uid=8e45f36b-d106-4d81-a1f0-9d1ed9a6be5c ifname=bond2logid=0 '
            'loguid={0x5d8c5388,0x61,0x29321fac,0xc0000022} origin=1.1.1.1originsicname=CN=DWdeviceBlackend,'
            'O=Blackend sequencenum=363 version=5dst=1.1.1.1 inzone=External outzone=Internal product=VPN-1 & '
            'FireWall-1 proto=6service_id=microsoft-ds src=1.1.1.1',

            'CEF:0|Check Point|VPN-1 & FireWall-1|Check Point|Log|Log|Unknown|act=AcceptdeviceDirection=0 '
            'rt=1569477501000 spt=63088 dpt=5985 cs2Label=Rule Namelayer_name=FW_Device_blackened Securitylayer_'
            'uuid=07693fc7-1a5c-4f31-8afe-77ae96c71b8c match_id=8899 parent_rule=0rule_action=Accept rule_'
            'uid=ae987933-82c0-470f-ab1c-1ad552c82369conn_direction=Internal ifname=bond1.12 '
            'logid=0loguid={0x5d8c537d,0xbb,0x29321fac,0xc0000014} origin=1.1.1.1originsicname=CN=DWdeviceBlackend,'
            'O=Blackend sequencenum=899 version=5dst=1.1.1.1 product=VPN-1 & FireWall-1 proto=6 src=1.1.1.1'
        ]
    }

    readable_output, _, _ = insert_cef_alerts_command(client, args)

    assert readable_output == 'Alerts inserted successfully'


def test_get_distribution_status(requests_mock):
    from CortexXDRIR import get_distribution_status_command, Client

    get_distribution_status_response = load_test_data('./test_data/get_distribution_status.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/distributions/get_status/', json=get_distribution_status_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        "distribution_ids": "588a56de313549b49d70d14d4c1fd0e3"
    }

    readable_output, outputs, _ = get_distribution_status_command(client, args)

    assert outputs == {
        'PaloAltoNetworksXDR.Distribution(val.id == obj.id)': [
            {
                'id': '588a56de313549b49d70d14d4c1fd0e3',
                'status': 'Completed'
            }
        ]
    }


def test_get_distribution_versions(requests_mock):
    from CortexXDRIR import get_distribution_versions_command, Client

    get_distribution_versions_response = load_test_data('./test_data/get_distribution_versions.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/distributions/get_versions/', json=get_distribution_versions_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    readable_output, outputs, _ = get_distribution_versions_command(client)

    assert outputs == {
        'PaloAltoNetworksXDR.DistributionVersions': {
            "windows": [
                "7.0.0.27797"
            ],
            "linux": [
                "7.0.0.1915"
            ],
            "macos": [
                "7.0.0.1914"
            ]
        }
    }


def test_create_distribution(requests_mock):
    from CortexXDRIR import create_distribution_command, Client

    create_distribution_response = load_test_data('./test_data/create_distribution.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/distributions/create/', json=create_distribution_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )

    args = {
        "name": "dfslcxe",
        "platform": "windows",
        "package_type": "standalone",
        "agent_version": "7.0.0.28644"
    }

    readable_output, outputs, _ = create_distribution_command(client, args)

    expected_distribution_id = create_distribution_response.get('reply').get('distribution_id')
    assert outputs == {
        'PaloAltoNetworksXDR.Distribution(val.id == obj.id)': {
            'id': expected_distribution_id,
            "name": "dfslcxe",
            "platform": "windows",
            "package_type": "standalone",
            "agent_version": "7.0.0.28644",
            'description': None
        }
    }
    assert readable_output == f'Distribution {expected_distribution_id} created successfully'


def test_blacklist_files_command_with_more_than_one_file(requests_mock):
    """
    Given:
        - List of files' hashes to put in blacklist
    When
        - A user desires to mark more than one file
    Then
        - returns markdown, context data and raw response.
    """

    from CortexXDRIR import blacklist_files_command, Client
    test_data = load_test_data('test_data/blacklist_whitelist_files_success.json')
    expected_command_result = {'PaloAltoNetworksXDR.blackList.fileHash(val.fileHash == obj.fileHash)': test_data[
        'multi_command_args']['hash_list']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/hash_exceptions/blacklist/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = blacklist_files_command(client, test_data['multi_command_args'])

    assert expected_command_result == context


def test_blacklist_files_command_with_single_file(requests_mock):
    """
    Given:
        - List of a file hashes to put in blacklist.
    When
        - A user desires to blacklist one file.
    Then
        - returns markdown, context data and raw response.
    """

    from CortexXDRIR import blacklist_files_command, Client
    test_data = load_test_data('test_data/blacklist_whitelist_files_success.json')
    expected_command_result = {
        'PaloAltoNetworksXDR.blackList.fileHash(val.fileHash == obj.fileHash)':
            test_data['single_command_args']['hash_list']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/hash_exceptions/blacklist/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = blacklist_files_command(client, test_data['single_command_args'])

    assert expected_command_result == context


def test_blacklist_files_command_with_no_comment_file(requests_mock):
    """
    Given:
        - ￿List of files' hashes to put in blacklist without passing the comment argument.
    When
        - A user desires to blacklist files without adding a comment.
    Then
        - returns markdown, context data and raw response.
    """

    from CortexXDRIR import blacklist_files_command, Client
    test_data = load_test_data('test_data/blacklist_whitelist_files_success.json')
    expected_command_result = {
        'PaloAltoNetworksXDR.blackList.fileHash(val.fileHash == obj.fileHash)':
            test_data['no_comment_command_args']['hash_list']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/hash_exceptions/blacklist/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = blacklist_files_command(client, test_data['no_comment_command_args'])

    assert expected_command_result == context


def test_whitelist_files_command_with_more_than_one_file(requests_mock):
    """
    Given:
        - ￿List of files' hashes to put in whitelist
    When
        - A user desires to mark more than one file
    Then
        - returns markdown, context data and raw response.
    """

    from CortexXDRIR import whitelist_files_command, Client
    test_data = load_test_data('test_data/blacklist_whitelist_files_success.json')
    expected_command_result = {'PaloAltoNetworksXDR.whiteList.fileHash(val.fileHash == obj.fileHash)': test_data[
        'multi_command_args']['hash_list']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/hash_exceptions/whitelist/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = whitelist_files_command(client, test_data['multi_command_args'])

    assert expected_command_result == context


def test_whitelist_files_command_with_single_file(requests_mock):
    """
    Given:
        - List of a file hashes to put in whitelist.
    When
        - A user desires to whitelist one file.
    Then
        - returns markdown, context data and raw response.
    """

    from CortexXDRIR import whitelist_files_command, Client
    test_data = load_test_data('test_data/blacklist_whitelist_files_success.json')
    expected_command_result = {
        'PaloAltoNetworksXDR.whiteList.fileHash(val.fileHash == obj.fileHash)':
            test_data['single_command_args']['hash_list']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/hash_exceptions/whitelist/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = whitelist_files_command(client, test_data['single_command_args'])

    assert expected_command_result == context


def test_whitelist_files_command_with_no_comment_file(requests_mock):
    """
    Given:
        - List of files' hashes to put in whitelist without passing the comment argument.
    When
        - A user desires to whitelist files without adding a comment.
    Then
        - returns markdown, context data and raw response.
    """

    from CortexXDRIR import whitelist_files_command, Client
    test_data = load_test_data('test_data/blacklist_whitelist_files_success.json')
    expected_command_result = {
        'PaloAltoNetworksXDR.whiteList.fileHash(val.fileHash == obj.fileHash)': test_data['no_comment_command_args'][
            'hash_list']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/hash_exceptions/whitelist/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = whitelist_files_command(client, test_data['no_comment_command_args'])

    assert expected_command_result == context


def test_quarantine_files_command(requests_mock):
    """
    Given:
        - List of files' hashes to put in quarantine
    When
        - A user desires to quarantine files.
    Then
        - returns markdown, context data and raw response.
    """
    from CortexXDRIR import quarantine_files_command, Client
    test_data = load_test_data('test_data/quarantine_files.json')
    quarantine_files_expected_tesult = {
        'PaloAltoNetworksXDR.quarantineFiles.actionIds(val.actionId === obj.actionId)': test_data['context_data']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/quarantine/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = quarantine_files_command(client, test_data['command_args'])

    assert quarantine_files_expected_tesult == context


def test_get_quarantine_status_command(requests_mock):
    """
    Given:
        - Endpoint_id, file_path, file_hash
    When
        - A user desires to check a file's quarantine status.
    Then
        - returns markdown, context data and raw response.
    """
    from CortexXDRIR import get_quarantine_status_command, Client
    test_data = load_test_data('test_data/get_quarantine_status.json')
    quarantine_files_expected_tesult = {
        'PaloAltoNetworksXDR.quarantineFiles.status(val.fileHash === obj.fileHash &&val.endpointId'
        ' === obj.endpointId && val.filePath === obj.filePath)':
            test_data['context_data']}
    requests_mock.post(f'{XDR_URL}/public_api/v1/quarantine/status/', json=test_data['api_response'])

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = get_quarantine_status_command(client, test_data['command_args'])

    assert quarantine_files_expected_tesult == context


def test_restore_file_command(requests_mock):
    """
    Given:
        - file_hash
    When
        - A user desires to restore a file.
    Then
        - returns markdown, context data and raw response.
    """
    from CortexXDRIR import restore_file_command, Client

    restore_expected_tesult = {'PaloAltoNetworksXDR.restoredFiles.actionId(val.actionId == obj.actionId)': 123}
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/restore/', json={"reply": {"action_id": 123}})

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = restore_file_command(client, {"file_hash": "123"})

    assert restore_expected_tesult == context


def test_endpoint_scan_command(requests_mock):
    """
    Given:
    -   endpoint_id_list, dist_name, gte_first_seen, gte_last_seen, lte_first_seen, lte_last_seen, ip_list,
    group_name, platform, alias, isolate, hostname
    When
        - A user desires to scan endpoint.
    Then
        - returns markdown, context data and raw response.
    """
    from CortexXDRIR import endpoint_scan_command, Client
    test_data = load_test_data('test_data/scan_endpoints.json')
    scan_expected_tesult = {'PaloAltoNetworksXDR.endpointScan.actionId(val.actionId == obj.actionId)': 123}
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/scan/', json={"reply": {"action_id": 123}})

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = endpoint_scan_command(client, test_data['command_args'])

    assert scan_expected_tesult == context


def test_endpoint_scan_command_scan_all_endpoints(requests_mock):
    """
    Given:
    -  no filters.
    When
        - A user desires to scan all endpoints.
    Then
        - returns markdown, context data and raw response.
    """
    from CortexXDRIR import endpoint_scan_command, Client
    scan_expected_tesult = {'PaloAltoNetworksXDR.endpointScan.actionId(val.actionId == obj.actionId)': 123}
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/scan/', json={"reply": {"action_id": 123}})

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    client._headers = {}
    markdown, context, raw = endpoint_scan_command(client, {})

    assert scan_expected_tesult == context


def test_sort_all_list_incident_fields():
    """
    Given:
        -  A raw incident
    When
        - running sort_all_list_incident_fields on it
    Then
        - the list fields (alerts for example) are sorted
    """
    from CortexXDRIR import sort_all_list_incident_fields
    raw_incident = load_test_data('test_data/raw_fetched_incident.json')
    sort_all_list_incident_fields(raw_incident)
    assert raw_incident.get('alerts')[0].get('alertid') == "42"
    assert raw_incident.get('alerts')[1].get('alertid') == "55"
    assert raw_incident.get('alerts')[2].get('alertid') == "60"

    assert raw_incident.get('hosts')[0] == 'HOST1'
    assert raw_incident.get('hosts')[1] == 'HOST2'

    assert raw_incident.get('file_artifacts')[0].get('filename') == 'file.exe'
    assert raw_incident.get('file_artifacts')[1].get('filename') == 'file2.exe'


def test_get_mapping_fields_command():
    """
    Given:
        -  nothing
    When
        - running get_mapping_fields_command
    Then
        - the result fits the expected mapping.
    """
    from CortexXDRIR import get_mapping_fields_command
    expected_mapping = [{"Cortex XDR Incident": {
        "status": "Current status of the incident: \"new\",\"under_investigation\",\"resolved_threat_handled\","
                  "\"resolved_known_issue\",\"resolved_duplicate\",\"resolved_false_positive\",\"resolved_other\"",
        "assigned_user_mail": "Email address of the assigned user.",
        "assigned_user_pretty_name": "Full name of the user assigned to the incident.",
        "resolve_comment": "Comments entered by the user when the incident was resolved.",
        "manual_severity": "Incident severity assigned by the user. This does not "
                           "affect the calculated severity low medium high"
    }}]
    res = get_mapping_fields_command()
    assert expected_mapping == res.extract_mapping()


def test_get_remote_data_command_should_update(requests_mock):
    """
    Given:
        -  an XDR client
        - arguments (id and lastUpdate time set to a lower than incident modification time)
        - a raw incident (get-extra-data results)
    When
        - running get_remote_data_command
    Then
        - the mirrored_object in the GetRemoteDataResponse is the same as the modified raw incident
        - the entries in the GetRemoteDataResponse in empty
    """
    from CortexXDRIR import get_remote_data_command, Client, sort_all_list_incident_fields
    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'id': 1,
        'lastUpdate': 0
    }
    raw_incident = load_test_data('./test_data/get_incident_extra_data.json')
    expected_modified_incident = raw_incident['reply']['incident'].copy()
    expected_modified_incident['alerts'] = copy.deepcopy(raw_incident['reply'].get('alerts').get('data'))
    expected_modified_incident['network_artifacts'] = raw_incident['reply'].get('network_artifacts').get('data')
    expected_modified_incident['file_artifacts'] = raw_incident['reply'].get('file_artifacts').get('data')
    expected_modified_incident['id'] = expected_modified_incident.get('incident_id')
    expected_modified_incident['assigned_user_mail'] = ''
    expected_modified_incident['assigned_user_pretty_name'] = ''
    expected_modified_incident['in_mirror_error'] = ''
    del expected_modified_incident['creation_time']

    expected_modified_incident.get('alerts')[0]['host_ip_list'] = \
        expected_modified_incident.get('alerts')[0].get('host_ip').split(',')

    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/', json=raw_incident)
    response = get_remote_data_command(client, args)
    sort_all_list_incident_fields(expected_modified_incident)

    assert response.mirrored_object == expected_modified_incident
    assert response.entries == []


def test_get_remote_data_command_with_rate_limit_exception(mocker):
    """
    Given:
        -  an XDR client
        - arguments (id and lastUpdate time set to a lower than incident modification time)
        - a Rate limit exception is raises from get_extra_data_command method
    When
        - running get_remote_data_command
    Then
        - an "API rate limit" error is thrown so that the server will stop the sync loop and will resume from the last
        incident.
    """
    from CortexXDRIR import get_remote_data_command, Client
    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'id': 1,
        'lastUpdate': 0
    }

    mocker.patch.object(demisto, 'results')
    mocker.patch('CortexXDRIR.get_incident_extra_data_command', side_effect=Exception("Rate limit exceeded"))
    with pytest.raises(SystemExit):
        _ = get_remote_data_command(client, args)

    assert demisto.results.call_args[0][0].get('Contents') == "API rate limit"


def test_get_remote_data_command_should_not_update(requests_mock):
    """
    Given:
        -  an XDR client
        - arguments (id and lastUpdate time set to a higher than incident modification time)
        - a raw incident (get-extra-data results)
    When
        - running get_remote_data_command
    Then
        - returns an empty dict
    """
    from CortexXDRIR import get_remote_data_command, Client, sort_all_list_incident_fields
    import copy
    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'id': 1,
        'lastUpdate': '2020-07-31T00:00:00Z'
    }
    raw_incident = load_test_data('./test_data/get_incident_extra_data.json')
    expected_modified_incident = raw_incident['reply']['incident'].copy()
    expected_modified_incident['alerts'] = copy.deepcopy(raw_incident['reply'].get('alerts').get('data'))
    expected_modified_incident['network_artifacts'] = raw_incident['reply'].get('network_artifacts').get('data')
    expected_modified_incident['file_artifacts'] = raw_incident['reply'].get('file_artifacts').get('data')
    expected_modified_incident['id'] = expected_modified_incident.get('incident_id')
    expected_modified_incident['assigned_user_mail'] = ''
    expected_modified_incident['assigned_user_pretty_name'] = ''
    expected_modified_incident['in_mirror_error'] = ''
    del expected_modified_incident['creation_time']
    expected_modified_incident.get('alerts')[0]['host_ip_list'] = \
        expected_modified_incident.get('alerts')[0].get('host_ip').split(',')
    sort_all_list_incident_fields(expected_modified_incident)

    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/', json=raw_incident)

    response = get_remote_data_command(client, args)
    assert response.mirrored_object == expected_modified_incident
    assert response.entries == []


def test_get_remote_data_command_should_close_issue(requests_mock):
    """
    Given:
        -  an XDR client
        - arguments (id and lastUpdate time set to a lower than incident modification time)
        - a raw incident (get-extra-data results) indicating the incident was closed on XDR side
    When
        - running get_remote_data_command
    Then
        - the mirrored_object in the GetRemoteDataResponse is the same as the modified raw incident
        - the entries in the GetRemoteDataResponse holds the closing entry
    """
    import copy
    from CortexXDRIR import get_remote_data_command, Client, sort_all_list_incident_fields
    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'id': 1,
        'lastUpdate': 0
    }
    raw_incident = load_test_data('./test_data/get_incident_extra_data.json')
    raw_incident['reply']['incident']['status'] = 'resolved_threat_handled'
    raw_incident['reply']['incident']['resolve_comment'] = 'Handled'

    expected_modified_incident = raw_incident['reply']['incident'].copy()
    expected_modified_incident['alerts'] = copy.deepcopy(raw_incident['reply'].get('alerts').get('data'))
    expected_modified_incident['network_artifacts'] = raw_incident['reply'].get('network_artifacts').get('data')
    expected_modified_incident['file_artifacts'] = raw_incident['reply'].get('file_artifacts').get('data')
    expected_modified_incident['id'] = expected_modified_incident.get('incident_id')
    expected_modified_incident['assigned_user_mail'] = ''
    expected_modified_incident['assigned_user_pretty_name'] = ''
    expected_modified_incident['closeReason'] = 'Resolved'
    expected_modified_incident['closeNotes'] = 'Handled'
    expected_modified_incident['in_mirror_error'] = ''
    del expected_modified_incident['creation_time']
    expected_modified_incident.get('alerts')[0]['host_ip_list'] = \
        expected_modified_incident.get('alerts')[0].get('host_ip').split(',')

    expected_closing_entry = {
        'Type': 1,
        'Contents': {
            'dbotIncidentClose': True,
            'closeReason': 'Resolved',
            'closeNotes': 'Handled'
        },
        'ContentsFormat': 'json'
    }

    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/', json=raw_incident)

    response = get_remote_data_command(client, args)
    sort_all_list_incident_fields(expected_modified_incident)

    assert response.mirrored_object == expected_modified_incident
    assert expected_closing_entry in response.entries


def test_get_remote_data_command_sync_owners(requests_mock, mocker):
    """
    Given:
        -  an XDR client
        - arguments (id and lastUpdate time set to a lower than incident modification time)
        - a raw incident (get-extra-data results) with assigned mail moo@demisto.com
    When
        - running get_remote_data_command
    Then
        - the mirrored_object in the GetRemoteDataResponse is the same as the modified raw incident with the equivalent
        owner of the assigned mail
        - the entries in the GetRemoteDataResponse in empty
    """
    from CortexXDRIR import get_remote_data_command, Client, sort_all_list_incident_fields
    import copy
    mocker.patch.object(demisto, 'params', return_value={"sync_owners": True})
    mocker.patch.object(demisto, 'findUser', return_value={"email": "moo@demisto.com", 'username': 'username'})
    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'id': 1,
        'lastUpdate': 0
    }
    raw_incident = load_test_data('./test_data/get_incident_extra_data.json')
    raw_incident['reply']['incident']['assigned_user_mail'] = 'moo@demisto.com'

    expected_modified_incident = raw_incident['reply']['incident'].copy()
    expected_modified_incident['alerts'] = copy.deepcopy(raw_incident['reply'].get('alerts').get('data'))
    expected_modified_incident['network_artifacts'] = raw_incident['reply'].get('network_artifacts').get('data')
    expected_modified_incident['file_artifacts'] = raw_incident['reply'].get('file_artifacts').get('data')
    expected_modified_incident['id'] = expected_modified_incident.get('incident_id')
    expected_modified_incident['assigned_user_mail'] = 'moo@demisto.com'
    expected_modified_incident['assigned_user_pretty_name'] = None
    expected_modified_incident['owner'] = 'username'
    expected_modified_incident['in_mirror_error'] = ''
    del expected_modified_incident['creation_time']
    expected_modified_incident.get('alerts')[0]['host_ip_list'] = \
        expected_modified_incident.get('alerts')[0].get('host_ip').split(',')

    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incident_extra_data/', json=raw_incident)
    response = get_remote_data_command(client, args)
    sort_all_list_incident_fields(expected_modified_incident)

    assert response.mirrored_object == expected_modified_incident
    assert response.entries == []


def test_get_update_args_unassgning_user():
    """
    Given:
        -  a dict indicating changed fields (delta) with assigned_user_mail set to "None"
        - the incident status - set to 1 == Active
    When
        - running get_update_args
    Then
        - update_args have assigned_user_mail and assigned_user_pretty_name set to None and unassign_user set to 'true'
    """
    from CortexXDRIR import get_update_args
    delta = {'assigned_user_mail': 'None'}
    update_args = get_update_args(delta, 1)
    assert update_args.get('assigned_user_mail') is None
    assert update_args.get('assigned_user_pretty_name') is None
    assert update_args.get('unassign_user') == 'true'


def test_get_update_args_close_incident():
    """
    Given:
        -  a dict indicating changed fields (delta) with a change in owner
        - the incident status - set to 1 == Active
    When
        - running get_update_args
    Then
        - update_args assigned_user_mail has the correct associated mail
    """
    from CortexXDRIR import get_update_args
    delta = {'closeReason': 'Other', "closeNotes": "Not Relevant"}
    update_args = get_update_args(delta, 2)
    assert update_args.get('status') == 'resolved_other'
    assert update_args.get('resolve_comment') == 'Not Relevant'


def test_get_update_args_owner_sync(mocker):
    """
    Given:
        -  a dict indicating changed fields (delta) with closeReason set to Other and a closeNotes
        - the incident status - set to 2 == Closed
    When
        - running get_update_args
    Then
        - update_args status has the correct status (resolved_other)
        - the resolve_comment is the same as the closeNotes
    """
    from CortexXDRIR import get_update_args
    mocker.patch.object(demisto, 'params', return_value={"sync_owners": True, "mirror_direction": "Incoming"})
    mocker.patch.object(demisto, 'findUser', return_value={"email": "moo@demisto.com", 'username': 'username'})
    delta = {'owner': 'username'}

    update_args = get_update_args(delta, 1)

    assert update_args.get('assigned_user_mail') == 'moo@demisto.com'


def test_get_policy(requests_mock):
    """
        Given:
            -endpoint_id

        When:
            -Retrieving the policy name of the requested actions according to the specific endpoint.

        Then:
            - Assert the returned markdown, context data and raw response are as expected.
        """
    from CortexXDRIR import get_policy_command, Client

    expected_context = {
        'endpoint_id': 'aeec6a2cc92e46fab3b6f621722e9916',
        'policy_name': 'test'
    }
    run_script_expected_result = {'PaloAltoNetworksXDR.Policy(val.endpoint_id == obj.endpoint_id)': expected_context}
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/get_policy/', json={'reply': {
        'policy_name': 'test'}})

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'endpoint_id': 'aeec6a2cc92e46fab3b6f621722e9916'
    }

    hr, context, raw_response = get_policy_command(client, args)
    assert hr == 'The policy name of endpoint: aeec6a2cc92e46fab3b6f621722e9916 is: test.'
    assert run_script_expected_result == context
    assert raw_response == {'policy_name': 'test'}


def test_get_endpoint_device_control_violations_command(requests_mock):
    """
        Given:
            - violation_id_list='100'
        When:
            -Request for list of device control violations filtered by selected fields. You can retrieve up to 100 violations.
        Then:
            - Assert the returned markdown, context data and raw response are as expected.
        """
    from CortexXDRIR import get_endpoint_device_control_violations_command, Client
    from CommonServerPython import timestamp_to_datestring, tableToMarkdown, string_to_table_header

    get_endpoint_violations_reply = load_test_data('./test_data/get_endpoint_violations.json')
    violations = get_endpoint_violations_reply.get('reply').get('violations')
    for violation in violations:
        timestamp = violation.get('timestamp')
        violation['date'] = timestamp_to_datestring(timestamp, '%Y-%m-%dT%H:%M:%S')
    get_endpoint_violations_expected_result = {
        'PaloAltoNetworksXDR.EndpointViolations(val.violation_id==obj.violation_id)':
            violations
    }
    headers = ['date', 'hostname', 'platform', 'username', 'ip', 'type', 'violation_id', 'vendor', 'product',
               'serial']
    requests_mock.post(f'{XDR_URL}/public_api/v1/device_control/get_violations/', json=get_endpoint_violations_reply)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'violation_id_list': '100'
    }

    hr, context, raw_response = get_endpoint_device_control_violations_command(client, args)

    assert hr == tableToMarkdown(name='Endpoint Device Control Violation', t=violations, headers=headers,
                                 headerTransform=string_to_table_header, removeNull=True)
    assert context == get_endpoint_violations_expected_result
    assert raw_response == get_endpoint_violations_reply.get('reply')


def test_retrieve_files_command(requests_mock):
    """
    Given:
        - endpoint_ids
        - windows_file_paths
    When
        - A user desires to retrieve a file.
    Then
        - Assert the returned markdown, context data and raw response are as expected.
    """
    from CortexXDRIR import retrieve_files_command, Client
    from CommonServerPython import tableToMarkdown, string_to_table_header

    retrieve_expected_result = {'PaloAltoNetworksXDR.RetrievedFiles(val.action_id == obj.action_id)': {'action_id': 1773}}
    requests_mock.post(f'{XDR_URL}/public_api/v1/endpoints/file_retrieval/', json={'reply': {'action_id': 1773}})
    result = {'action_id': 1773}

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    hr, context, raw_response = retrieve_files_command(client, {'endpoint_ids': 'aeec6a2cc92e46fab3b6f621722e9916',
                                                                'windows_file_paths': 'C:\\Users\\demisto\\Desktop\\demisto.txt'})

    assert hr == tableToMarkdown(name='Retrieve files', t=result, headerTransform=string_to_table_header)
    assert context == retrieve_expected_result
    assert raw_response == {'action_id': 1773}


def test_retrieve_file_details_command(requests_mock):
    """
    Given:
        - action_id
    When
        - Requesting to view the file retrieved by the Retrieve File request according to the action ID.
    Then
        - Assert the returned markdown, file result are as expected.
    """
    from CortexXDRIR import retrieve_file_details_command, Client

    data = load_test_data('./test_data/retrieve_file_details.json')
    data1 = 'test_file'
    retrieve_expected_hr = {
        'Type': 1,
        'ContentsFormat': 'json',
        'Contents': [data.get('reply').get('data')],
        'HumanReadable': '### Action id : 1788 \n Retrieved 1 files from 1 endpoints. \n '
                         'To get the exact action status run the xdr-action-status-get command',
        'ReadableContentsFormat': 'markdown',
        'EntryContext': {}
    }

    requests_mock.post(f'{XDR_URL}/public_api/v1/actions/file_retrieval_details/', json=data)
    requests_mock.post(f'{XDR_URL}', json=data1)
    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'action_id': '1788'
    }
    results, file_result = retrieve_file_details_command(client, args)
    assert results == retrieve_expected_hr
    assert file_result[0]['File'] == 'endpoint_test_1.zip'


def test_get_scripts_command(requests_mock):
    """
        Given:
            - script_name
        When:
            - Requesting for a list of scripts available in the scripts library.
        Then:
            - Assert the returned markdown, context data and raw response are as expected.
        """
    from CortexXDRIR import get_scripts_command, Client
    from CommonServerPython import timestamp_to_datestring, tableToMarkdown, string_to_table_header

    get_scripts_response = load_test_data('./test_data/get_scripts.json')
    scripts = copy.deepcopy(get_scripts_response.get('reply').get('scripts')[0::50])
    for script in scripts:
        timestamp = script.get('modification_date')
        script['modification_date_timestamp'] = timestamp
        script['modification_date'] = timestamp_to_datestring(timestamp, '%Y-%m-%dT%H:%M:%S')
    headers: list = ['name', 'description', 'script_uid', 'modification_date', 'created_by',
                     'windows_supported', 'linux_supported', 'macos_supported', 'is_high_risk']
    get_scripts_expected_result = {
        'PaloAltoNetworksXDR.Scripts(val.script_uid == obj.script_uid)': scripts
    }
    requests_mock.post(f'{XDR_URL}/public_api/v1/scripts/get_scripts/', json=get_scripts_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'script_name': 'process_get'
    }

    hr, context, raw_response = get_scripts_command(client, args)

    assert hr == tableToMarkdown(name='Scripts', t=scripts, headers=headers, removeNull=True,
                                 headerTransform=string_to_table_header)
    assert context == get_scripts_expected_result
    assert raw_response == get_scripts_response.get('reply')


def test_get_script_metadata_command(requests_mock):
    """
        Given:
            - A script_uid
        When:
            - Requesting for a given script metadata.
        Then:
            - Assert the returned markdown, context data and raw response are as expected.
        """
    from CortexXDRIR import get_script_metadata_command, Client
    from CommonServerPython import timestamp_to_datestring, tableToMarkdown, string_to_table_header

    get_script_metadata_response = load_test_data('./test_data/get_script_metadata.json')
    get_scripts_expected_result = {
        'PaloAltoNetworksXDR.ScriptMetadata(val.script_uid == obj.script_uid)': get_script_metadata_response.get('reply')
    }
    script_metadata = copy.deepcopy(get_script_metadata_response).get('reply')
    timestamp = script_metadata.get('modification_date')
    script_metadata['modification_date_timestamp'] = timestamp
    script_metadata['modification_date'] = timestamp_to_datestring(timestamp, '%Y-%m-%dT%H:%M:%S')

    requests_mock.post(f'{XDR_URL}/public_api/v1/scripts/get_script_metadata/', json=get_script_metadata_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'script_uid': '956e8989f67ebcb2c71c4635311e47e4'
    }

    hr, context, raw_response = get_script_metadata_command(client, args)

    assert hr == tableToMarkdown(name='Script Metadata', t=script_metadata,
                                 removeNull=True, headerTransform=string_to_table_header)
    assert context == get_scripts_expected_result
    assert raw_response == get_script_metadata_response.get('reply')


def test_get_script_code_command(requests_mock):
    """
        Given:
            - A script_uid.
        When:
            - Requesting the code of a specific script in the script library.
        Then:
            - Assert the returned markdown, context data and raw response are as expected.
        """
    from CortexXDRIR import get_script_code_command, Client

    get_script_code_command_reply = load_test_data('./test_data/get_script_code.json')
    context = {
        'script_uid': '548023b6e4a01ec51a495ba6e5d2a15d',
        'code': get_script_code_command_reply.get('reply')
    }
    get_script_code_command_expected_result = {
        'PaloAltoNetworksXDR.ScriptCode(val.script_uid == obj.script_uid)':
            context}
    requests_mock.post(f'{XDR_URL}/public_api/v1/scripts/get_script_code/',
                       json=get_script_code_command_reply)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'script_uid': '548023b6e4a01ec51a495ba6e5d2a15d'
    }

    hr, context, raw_response = get_script_code_command(client, args)

    assert hr == f'### Script code: \n ``` {str(get_script_code_command_reply.get("reply"))} ```'
    assert context == get_script_code_command_expected_result
    assert raw_response == get_script_code_command_reply.get("reply")


def test_action_status_get_command(requests_mock):
    """
        Given:
            - An action_id
        When:
            - Retrieving the status of the requested actions according to the action ID.
        Then:
            - Assert the returned markdown, context data and raw response are as expected.
        """
    from CortexXDRIR import action_status_get_command, Client
    from CommonServerPython import tableToMarkdown

    action_status_get_command_command_reply = load_test_data('./test_data/action_status_get.json')

    data = action_status_get_command_command_reply.get('reply').get('data')
    result = []
    for item in data:
        result.append({
            'action_id': 1810,
            'endpoint_id': item,
            'status': data.get(item)
        })
    action_status_get_command_expected_result = {
        'PaloAltoNetworksXDR.GetActionStatus(val.action_id == obj.action_id)':
            result}

    requests_mock.post(f'{XDR_URL}/public_api/v1/actions/get_action_status/',
                       json=action_status_get_command_command_reply)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'action_id': '1810'
    }

    hr, context, raw_response = action_status_get_command(client, args)
    assert hr == tableToMarkdown(name='Get Action Status', t=result, removeNull=True)
    assert context == action_status_get_command_expected_result
    assert raw_response == result


def test_sort_by_key__only_main_key():
    """
    Given:
        -  a list of dicts to sort where main key is entered for all elements
        -  the main key to sort by
        -  the fallback key to sort by
    When
        - running sort_by_key
    Then
        - resulting list is sorted by main key only.
    """
    from CortexXDRIR import sort_by_key
    list_to_sort = [
        {
            "name": "element2",
            "main_key": 2,
            "fallback_key": 4
        },
        {
            "name": "element1",
            "main_key": 1,
            "fallback_key": 3
        },

        {
            "name": "element4",
            "main_key": 4,
            "fallback_key": 2
        },
        {
            "name": "element3",
            "main_key": 3,
            "fallback_key": 1
        }
    ]

    expected_result = [
        {
            "name": "element1",
            "main_key": 1,
            "fallback_key": 3
        },
        {
            "name": "element2",
            "main_key": 2,
            "fallback_key": 4
        },
        {
            "name": "element3",
            "main_key": 3,
            "fallback_key": 1
        },
        {
            "name": "element4",
            "main_key": 4,
            "fallback_key": 2
        }
    ]

    assert expected_result == sort_by_key(list_to_sort, "main_key", "fallback_key")


def test_sort_by_key__main_key_and_fallback_key():
    """
    Given:
        -  a list of dicts to sort where some elements have main key and some don't but they have fallback key
        -  the main key to sort by
        -  the fallback key to sort by
    When
        - running sort_by_key
    Then
        - resulting list is sorted by main key on elements with the main key and
          then sorted by fallback key for elements who dont have it
    """
    from CortexXDRIR import sort_by_key
    list_to_sort = [
        {
            "name": "element2",
            "fallback_key": 4
        },
        {
            "name": "element1",
            "main_key": 1,
            "fallback_key": 3
        },

        {
            "name": "element4",
            "main_key": None,
            "fallback_key": 2
        },
        {
            "name": "element3",
            "main_key": 3,
            "fallback_key": 1
        }
    ]

    expected_result = [
        {
            "name": "element1",
            "main_key": 1,
            "fallback_key": 3
        },
        {
            "name": "element3",
            "main_key": 3,
            "fallback_key": 1
        },
        {
            "name": "element4",
            "main_key": None,
            "fallback_key": 2
        },
        {
            "name": "element2",
            "fallback_key": 4
        },
    ]

    assert expected_result == sort_by_key(list_to_sort, "main_key", "fallback_key")


def test_sort_by_key__only_fallback_key():
    """
    Given:
        -  a list of dicts to sort where main key is not entered for all elements and fallback key is.
        -  the main key to sort by
        -  the fallback key to sort by
    When
        - running sort_by_key
    Then
        - resulting list is sorted by fallback key only.
    """
    from CortexXDRIR import sort_by_key
    list_to_sort = [
        {
            "name": "element2",
            "fallback_key": 4
        },
        {
            "name": "element1",
            "fallback_key": 3
        },
        {
            "name": "element4",
            "fallback_key": 2
        },
        {
            "name": "element3",
            "fallback_key": 1
        }
    ]

    expected_result = [
        {
            "name": "element3",
            "fallback_key": 1
        },
        {
            "name": "element4",
            "fallback_key": 2
        },
        {
            "name": "element1",
            "fallback_key": 3
        },
        {
            "name": "element2",
            "fallback_key": 4
        },
    ]

    assert expected_result == sort_by_key(list_to_sort, "main_key", "fallback_key")


def test_sort_by_key__main_key_and_fallback_key_and_additional():
    """
    Given:
        -  a list of dicts to sort where main key is entered for some elements, fallback for others
           and some dont have either
        -  the main key to sort by
        -  the fallback key to sort by
    When
        - running sort_by_key
    Then
        - resulting list is sorted by main key for elements with main key,
          then by fallback key for those with fallback key and then the rest of the elements that dont have either key.
    """
    from CortexXDRIR import sort_by_key
    list_to_sort = [
        {
            "name": "element2",
            "fallback_key": 4
        },
        {
            "name": "element1",
            "main_key": 1,
            "fallback_key": 3
        },

        {
            "name": "element4",
            "main_key": None,
            "fallback_key": None
        },
        {
            "name": "element3",
            "main_key": 3,
            "fallback_key": 1
        }
    ]

    expected_result = [
        {
            "name": "element1",
            "main_key": 1,
            "fallback_key": 3
        },
        {
            "name": "element3",
            "main_key": 3,
            "fallback_key": 1
        },
        {
            "name": "element2",
            "fallback_key": 4
        },
        {
            "name": "element4",
            "main_key": None,
            "fallback_key": None
        },
    ]

    assert expected_result == sort_by_key(list_to_sort, "main_key", "fallback_key")


def test_get_modified_remote_data_command(requests_mock):
    """
    Given:
        - an XDR client
        - arguments - lastUpdate time
        - raw incidents (result of client.get_incidents)
    When
        - running get_modified_remote_data_command
    Then
        - the method is returning a list of incidents IDs that were modified
    """
    from CortexXDRIR import get_modified_remote_data_command, Client

    get_incidents_list_response = load_test_data('./test_data/get_incidents_list.json')
    requests_mock.post(f'{XDR_URL}/public_api/v1/incidents/get_incidents/', json=get_incidents_list_response)

    client = Client(
        base_url=f'{XDR_URL}/public_api/v1', headers={}
    )
    args = {
        'lastUpdate': '2020-11-18T13:16:52.005381+02:00'
    }

    response = get_modified_remote_data_command(client, args)

    assert response.modified_incident_ids == ['1', '2']
