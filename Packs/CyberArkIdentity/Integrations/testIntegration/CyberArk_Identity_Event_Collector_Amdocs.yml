commonfields:
  id: CyberArk Identity Event Collector Amdocs
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: CyberArk Identity Event Collector Amdocs
display: CyberArk Identity Event Collector Amdocs
category: Analytics & SIEM
image: data:image/png;base64,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
description: This integration collects events from the Idaptive Next-Gen Access (INGA)
  using REST APIs.
detaileddescription: "Use the CyberArk Identity integration to get Audit and Auth
  logs for an application using REST APIs.\n\nBefore you start, you need to get the
  tenant ID, app ID, username, and password. For more information, see [CyberArk Identity
  Documentation](https://docs.cyberark.com/Product-Doc/OnlineHelp/Idaptive/Latest/en/Content/Integrations/SIEM-PlatformEvents/Identity%20Platform%20API%20Usage%20Guide%20for%20ArcSight.pdf),
  **Prerequisite for Accessing INGA Events** section (pages 4-10).\n\n## Configuration
  Parameters\n\n**Server URL**    \nThe CyberArk Identity URL to get the logs from.
  For example, https://{{tenant}}.my.idaptive.app/\n\n**App ID**  \nThe application
  ID to fetch the logs from.\n\n**User name and Password** \n\nThe user that was created
  in CyberArk for XSIAM integration.\n\n**First fetch time**\n\nThe period to retrieve
  events for.\nFormat: <number> <time unit>, for example 12 hours, 1 day, 3 months.\nDefault
  is 3 days.\n  \n**Maximum number of events per fetch**\n  \nThe maximum number of
  items to retrieve per request from CyberArk's API.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/cyber-ark-identity-event-collector)"
configuration:
- section: Connect
  display: Server URL
  name: url
  defaultvalue: https://<tenant>.my.idaptive.app
  type: 0
  required: true
- section: Collect
  display: App ID
  name: app_id
  defaultvalue: oauthsiem
  type: 0
  required: true
- section: Connect
  display: User name
  name: credentials
  type: 9
  required: true
  additionalinfo: The user name (admin@example.com) and password.
- section: Collect
  display: First fetch time
  name: from
  defaultvalue: 3 days
  type: 0
  required: true
- section: Collect
  display: Maximum number of events per fetch
  name: limit
  defaultvalue: "1000"
  type: 0
  required: true
- section: Connect
  advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- section: Connect
  advanced: true
  display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- section: Collect
  display: Fetch Events
  name: isFetchEvents
  type: 8
  required: false
- section: Collect
  advanced: true
  display: Events Fetch Interval
  name: eventFetchInterval
  defaultvalue: "1"
  type: 19
  required: false
script:
  script: |
    register_module_line('CyberArk Identity Event Collector', 'start', __line__())
    ### pack version: 1.1.0
    # pylint: disable=no-name-in-module
    # pylint: disable=no-self-argument
    import urllib3

    ### GENERATED CODE ###: from SiemApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('SiemApiModule', 'start', __line__(), wrapper=-3)


    # pylint: disable=no-name-in-module
    # pylint: disable=no-self-argument

    from abc import ABC
    from typing import Any, Callable, Optional


    from enum import Enum
    from pydantic import BaseConfig, BaseModel, AnyUrl, validator, Field
    from requests.auth import HTTPBasicAuth


    class Method(str, Enum):
        GET = 'GET'
        POST = 'POST'
        PUT = 'PUT'
        HEAD = 'HEAD'
        PATCH = 'PATCH'
        DELETE = 'DELETE'


    def load_json(v: Any) -> dict:
        if not isinstance(v, (dict, str)):
            raise ValueError('headers are not dict or a valid json')
        if isinstance(v, str):
            try:
                v = json.loads(v)
                if not isinstance(v, dict):
                    raise ValueError('headers are not from dict type')
            except json.decoder.JSONDecodeError as exc:
                raise ValueError('headers are not valid Json object') from exc
        if isinstance(v, dict):
            return v
        return dict()


    class IntegrationHTTPRequest(BaseModel):
        method: Method
        url: AnyUrl
        verify: bool = True
        headers: dict = {}  # type: ignore[type-arg]
        auth: Optional[HTTPBasicAuth] = None
        data: Any = None
        params: dict = {}  # type: ignore[type-arg]

        class Config(BaseConfig):
            arbitrary_types_allowed = True

        _normalize_headers = validator('headers', pre=True, allow_reuse=True)(
            load_json
        )


    class Credentials(BaseModel):
        identifier: Optional[str]
        password: str


    def set_authorization(request: IntegrationHTTPRequest, auth_credendtials):
        """Automatic authorization.
        Supports {Authorization: Bearer __token__}
        or Basic Auth.
        """
        creds = Credentials.parse_obj(auth_credendtials)
        if creds.password and creds.identifier:
            request.auth = HTTPBasicAuth(creds.identifier, creds.password)
        auth = {'Authorization': f'Bearer {creds.password}'}
        if request.headers:
            request.headers |= auth  # type: ignore[assignment, operator]
        else:
            request.headers = auth  # type: ignore[assignment]


    class IntegrationOptions(BaseModel):
        """Add here any option you need to add to the logic"""

        proxy: Optional[bool] = False
        limit: Optional[int] = Field(None, ge=1)


    class IntegrationEventsClient(ABC):
        def __init__(
            self,
            request: IntegrationHTTPRequest,
            options: IntegrationOptions,
            session=requests.Session(),
        ):
            self.request = request
            self.options = options
            self.session = session
            self._set_proxy()
            self._skip_cert_verification()

        @abstractmethod
        def set_request_filter(self, after: Any):
            """TODO: set the next request's filter.
            Example:
            """
            self.request.headers['after'] = after

        def __del__(self):
            try:
                self.session.close()
            except AttributeError as err:
                demisto.debug(
                    f'ignore exceptions raised due to session not used by the client. {err=}'
                )

        def call(self, request: IntegrationHTTPRequest) -> requests.Response:
            try:
                response = self.session.request(**request.dict())
                response.raise_for_status()
                return response
            except Exception as exc:
                msg = f'something went wrong with the http call {exc}'
                demisto.debug(msg)
                raise DemistoException(msg) from exc

        def _skip_cert_verification(
            self, skip_cert_verification: Callable = skip_cert_verification
        ):
            if not self.request.verify:
                skip_cert_verification()

        def _set_proxy(self):
            if self.options.proxy:
                ensure_proxy_has_http_prefix()
            else:
                skip_proxy()


    class IntegrationGetEvents(ABC):
        def __init__(
            self, client: IntegrationEventsClient, options: IntegrationOptions
        ) -> None:
            self.client = client
            self.options = options

        def run(self):
            stored = []
            for logs in self._iter_events():
                stored.extend(logs)
                if self.options.limit:
                    demisto.debug(
                        f'{self.options.limit=} reached. \
                        slicing from {len(logs)=}. \
                        limit must be presented ONLY in commands and not in fetch-events.'
                    )
                    if len(stored) >= self.options.limit:
                        return stored[: self.options.limit]
            return stored

        def call(self) -> requests.Response:
            return self.client.call(self.client.request)

        @staticmethod
        @abstractmethod
        def get_last_run(events: list) -> dict:
            """Logic to get the last run from the events
            Example:
            """
            return {'after': events[-1]['created']}

        @abstractmethod
        def _iter_events(self):
            """Create iterators with Yield"""

    register_module_line('SiemApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    urllib3.disable_warnings()

    # -----------------------------------------  GLOBAL VARIABLES  -----------------------------------------
    DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%f'
    EVENT_FIELDS = [
        'ID',
        'EventType',
        'AuthMethod',
        'DirectoryServiceUuid',
        'DirectoryServicePartnerName',
        'EntityName',
        'EntityType',
        'EntityUuid',
        'FromIPAddress',
        'ImpersonatorUuid',
        'Level',
        'NewEntity',
        'NormalizedUser',
        'OldEntity',
        'RequestDeviceOS',
        'RequestHostName',
        'RequestIsMobileDevice',
        'Tenant',
        'UserGuid',
        'WhenLogged',
        'WhenOccurred',
        'ObjectName',
        'ObjectType',
        'RoleId',
        'Role',
        'Changer',
        'ChangerUuid',
        'Result',
        'Alias',
        'ReplaceDomain',
        'Type',
        'Id',
        'ProfileName',
        'Thumbprint',
        'TargetUserID',
        'TargetUser',
        'Uuid',
        'Key',
        'Value',
        'UserState',
        'PreviousUserState',
        'FailedMessage',
        'Exception',
        'DSType',
        'DSName',
        'DSUuid',
        'ImpersonateTargetUuid',
        'ImpersonateTargetName',
        'EmailAddress',
        'Session',
        'MfaResult',
        'MfaReason',
        'SetPath',
        'ProxyId',
        'MachineName',
        'ClientAddress',
        'ConnectorUuid',
        'HostAddress',
        'UserName',
        'Target',
        'Cname',
        'OldState',
        'NewState',
        'AffectedTenant',
        'OU',
        'DeviceID',
        'EnrollProfileUser',
        'LocalAccountUuid',
        'DeviceName',
        'FailureReason',
        'From',
        'To',
        'Description',
        'DeleteReason',
        'LicenseType',
        'NewLicenseType',
        'OldLicenseType',
        'ApplicationType',
        'ApplicationName',
        'ApplicationID',
        'MobileAppType',
        'AppId',
        'AppName',
        'JobUniqueId',
        'SyncAction',
        'SyncActionReason',
        'SyncResult',
        'SessionId',
    ]
    PRODUCT = 'identity'
    VENDOR = 'cyberark'


    class CyberArkIdentityEventsOptions(IntegrationOptions):
        app_id: str


    class CyberArkIdentityEventsRequest(IntegrationHTTPRequest):
        method: Method = Method.POST
        headers: dict = {'Accept': '*/*', 'Content-Type': 'application/json'}


    class CyberArkIdentityEventsClient(IntegrationEventsClient):
        request: IntegrationHTTPRequest
        options: CyberArkIdentityEventsOptions

        def __init__(
            self,
            request: CyberArkIdentityEventsRequest,
            options: CyberArkIdentityEventsOptions,
            credentials: Credentials,
            session=requests.Session(),
        ) -> None:
            self.access_token = None
            self.credentials = credentials
            super().__init__(request, options, session)

        def set_request_filter(self, after: Any):
            return after

        def authenticate(self):
            credentials = base64.b64encode(f'{self.credentials.identifier}:{self.credentials.password}'.encode()).decode()
            request = IntegrationHTTPRequest(
                method=Method.POST,
                url=f"{str(self.request.url).removesuffix('/RedRock/Query')}/oauth2/platformtoken",
                headers={'Authorization': f"Basic {credentials}"},
                data={'grant_type': 'client_credentials', 'scope': 'siem'},
                verify=not self.request.verify,
            )

            response = self.call(request)
            if response.ok:
                demisto.debug('authenticated successfully')
                self.access_token = response.json()['access_token']
                self.request.headers['Authorization'] = f'Bearer {self.access_token}'
            else:
                demisto.debug(f'authentication failed: {response.json()}')


    class CyberArkIdentityGetEvents(IntegrationGetEvents):
        client: CyberArkIdentityEventsClient

        @staticmethod
        def get_last_run_ids(events: list) -> list:
            return [event.get('ID') for event in events]

        @staticmethod
        def get_last_run_time(events: list) -> str:
            # The date is in timestamp format and looks like {'WhenOccurred': '/Date(1651483379362)/'}
            last_timestamp = max([int(e.get('WhenOccurred', '').removesuffix(')/').removeprefix('/Date(')) for e in events])

            return datetime.utcfromtimestamp(last_timestamp / 1000).strftime(DATETIME_FORMAT)

        def get_last_run(self, events: list) -> dict:  # type: ignore
            return {'from': self.get_last_run_time(events), 'ids': self.get_last_run_ids(events)}

        def _iter_events(self):
            self.client.authenticate()

            result = self.client.call(self.client.request).json()['Result']

            events = result.get('Results')
            if events:
                fetched_events_ids = demisto.getLastRun().get('ids', [])
                yield [event.get('Row') for event in events if event.get('Row', {}).get('ID') not in fetched_events_ids]


    def get_request_params(**kwargs: dict) -> dict:
        fetch_from = str(kwargs.get('from', '3 days'))
        default_from_day = datetime.now() - timedelta(days=3)
        from_time = datetime.strftime(dateparser.parse(fetch_from, settings={'TIMEZONE': 'UTC'}) or default_from_day, DATETIME_FORMAT)

        params = {
            'url': f"{str(kwargs.get('url', '')).removesuffix('/')}/RedRock/Query",
            'data': json.dumps({
                'Script': f"Select {', '.join(EVENT_FIELDS)} from Event where WhenOccurred > '{from_time}'",
                'args': {
                    'PageNumber': 1,
                    'PageSize': kwargs.get('limit', 1000)
                }
            }),
            'verify': not kwargs.get('insecure')
        }
        return params


    def main(command: str, demisto_params: dict):
        credentials = Credentials(**demisto_params.get('credentials', {}))
        options = CyberArkIdentityEventsOptions(**demisto_params)
        request_params = get_request_params(**demisto_params)
        request = CyberArkIdentityEventsRequest(**request_params)
        client = CyberArkIdentityEventsClient(request, options, credentials)
        get_events = CyberArkIdentityGetEvents(client, options)

        try:
            if command == 'test-module':
                get_events.run()
                demisto.results('ok')

            if command in ('fetch-events', 'cyberarkidentity-get-events'):
                events = get_events.run()

                if command == 'fetch-events' or demisto_params.get('should_push_events'):
                    send_events_to_xsiam(events, vendor=VENDOR,
                                         product=PRODUCT)
                    if events:
                        last_run = get_events.get_last_run(events)
                        demisto.debug(f'Set last run to {last_run}')
                        demisto.setLastRun(last_run)

                if command == 'cyberarkidentity-get-events':
                    command_results = CommandResults(
                        readable_output=tableToMarkdown(
                            'CyberArk Identity RedRock records', events, removeNull=True, headerTransform=pascalToSpace
                        ),
                        raw_response=events,
                    )
                    return_results(command_results)

        except Exception as e:
            return_error(str(e))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        # Args is always stronger. Get getIntegrationContext even stronger
        demisto_params_ = demisto.params() | demisto.args() | demisto.getLastRun()
        main(demisto.command(), demisto_params_)

    register_module_line('CyberArk Identity Event Collector', 'end', __line__())
  type: python
  commands:
  - name: cyberarkidentity-get-events
    arguments:
    - name: limit
      description: The maximum number of events per fetch. Default is 1000.
      isArray: true
      defaultValue: "1000"
    - name: should_push_events
      required: true
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Set this argument to True to create events, otherwise events will
        only be displayed.
      defaultValue: "False"
    - name: from
      description: First fetch time (<number> <time unit>, for example 12 hours, 1
        day, 3 months). Default is 3 days.
      isArray: true
    description: Returns a list of events
  dockerimage: demisto/py3-tools:1.0.0.94051
  isfetchevents: true
  runonce: false
  subtype: python3
sourcemoduleid: CyberArk Identity Event Collector
