commonfields:
  id: carbonblack-v2
  version: -1
name: carbonblack-v2
display: VMware Carbon Black EDR
fromversion: 5.0.0
category: Endpoint
image: data:image/png;base64,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
description: Query and response with Carbon Black endpoint detection and response.
configuration:
- display: Server URL
  name: serverurl
  defaultvalue: ""
  type: 0
  required: true
- display: API Token
  name: apitoken
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Fetch Alert Severity Threshold Higher Than
  name: fetchAlertsSeverityThreshold
  defaultvalue: ""
  type: 0
  required: false
- display: Maximum Number Of Incidents To Fetch
  name: rows
  defaultvalue: "10"
  type: 0
  required: false
script:
  script: >-
    "use strict";


    /// Base Functions


    function sendRequest(path, method, requestParams, headers, ignoredStatusCodes) {
        let baseUrl = params.serverurl + '/api';

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [params.apitoken];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: method,
            Headers: headers
        };
        let querystring = '';
        if (requestParams) {
            if (typeof requestParams === 'string') {
                querystring = requestParams;
            } else {
                request.Body = JSON.stringify(requestParams);
            }
        }

        //logInfo("Request:\n" + JSON.stringify({path: path + querystring, req: request}));

        let result = http(baseUrl + path + querystring, request, params.insecure, params.proxy);

        if (!ignoredStatusCodes || ignoredStatusCodes.indexOf(result.StatusCode) === -1) {
            if (result.StatusCode < 200 || result.StatusCode >= 300) {
                if (result.StatusCode === 404) {
                    throw 'Cannot find the requested resource (Status Code: 404)';
                }
                throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${JSON.stringify(result.Body)}`;
            }
        }

        //logInfo("Body:\n" + result.Body);

        return result;
    }


    /// Commands


    function testModule() {
        let res = sendRequest('/v1/license', 'GET');
        if (res.StatusCode === 200) {
            return 'ok';
        }
        return `Test failed. Status Code: ${res.StatusCode}`
    }


    function getSensorByIdRequest(sensorId) {
        let response = sendRequest(`/v1/sensor/${sensorId}`, 'GET');
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function quarantineSensorRequest(sensorId, sensorDetails) {
        return sendRequest(`/v1/sensor/${sensorId}`, 'PUT', sensorDetails);
    }


    function quarantineDevice(doQuarantine) {
        let result = getSensorByIdRequest(args.sensor);
        result.network_isolation_enabled = doQuarantine;
        result = quarantineSensorRequest(args.sensor, result);
        if (result.StatusCode === 204) {
            let quarantinedStr = (doQuarantine) ? 'quarantined' : 'unquarantined';
            return {
                Type: entryTypes.note,
                Contents: {success: true},
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: "Success: " + quarantinedStr + " sensor " + args.sensor,
                EntryContext: {
                    "Endpoint(val.CbSensorID == obj.CbSensorID)": {
                        "CbSensorID": args.sensor,
                        "LastAction": (doQuarantine) ? "Blocked" : "Unblocked"
                    }
                }
            }
        } else {
            throw result.Body;
        }
    }


    function getAlertsRequest(query, rows, start, sort, facets) {
        let queryParams = {};
        if (query) {
            queryParams.q = query;
        }
        if (rows) {
            queryParams.rows = rows;
        }
        if (start) {
            queryParams.start = start;
        }
        if (sort) {
            queryParams.sort = sort;
        }
        if (facets) {
            queryParams.facets = facets;
        }
        let response = sendRequest('/v2/alert', 'GET', encodeToURLQuery(queryParams));
        try {
            return JSON.parse(response.Body).results;
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function fetchIncidents() {
        let lastRun = getLastRun();

        let fetchAlertsSeverityThreshold = (args['fetchAlertsSeverityThreshold']) ? args['fetchAlertsSeverityThreshold'] : 0;
        let defaultRunTime = (new Date().getTime()) - (24 * 60 * 60 * 1000); // Decrease one day if it's the first run, to get some alerts.
        let defaultRunTimeStr = unixToString(defaultRunTime);
        let lastRunStr = (lastRun.time) ? unixToString(lastRun.time + 1000) : defaultRunTimeStr;
        let result = getAlertsRequest(`alert_severity:[${fetchAlertsSeverityThreshold} TO *] and created_time:[${lastRunStr} TO *]`, params.rows);

        let latestTime = 0;
        let incidents = result.map(curAlert => {
            let createdTime = stringToUnix(curAlert['created_time']);
            latestTime = Math.max(latestTime, createdTime);  // Save latest time from current fetch to query
            return {
                name: curAlert['description'] + ' : ' + curAlert['created_time'],
                occurred: curAlert['created_time'],
                rawJSON: JSON.stringify(curAlert),
            };
        });

        if (incidents.length > 0) {
            logInfo('Ingested ' + incidents.length + ' alerts into incidents');
            setLastRun({'time': latestTime});  // Update last run
        }

        return JSON.stringify(incidents);
    }


    function version() {
        let response = sendRequest('/v1/builds', 'GET');
        let result;
        try {
            result = JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json
        };
    }


    function showAlerts() {
        let query = '';
        if (args.query) {
            query = '(' + args.query + ')';
        }
        if (args.status) {
            query += ' AND status:' + args.status;
        }
        if (args.username) {
            query += ' AND username:' + args.username;
        }
        if (args.hostname) {
            query += ' AND hostname:' + args.hostname;
        }
        if (args.feedname) {
            query += ' AND feed_name:' + args.feedname;
        }
        if (args.report) {
            query += ' AND watchlist_id:' + args.report;
        }
        let alerts = getAlertsRequest(query, args.rows, args.start, args.sort, args.facets);

        let title = 'CB Response - Show Alerts';
        let changeNames = [
            {from: 'unique_id', to: 'CbAlertID'},
            {from: 'process_path', to: 'ProcessPath'},
            {from: 'hostname', to: 'Hostname'},
            {from: 'interface_ip', to: 'InterfaceIP'},
            {from: 'comms_ip', to: 'CommsIP'},
            {from: 'md5', to: 'MD5'},
            {from: 'description', to: 'Description'},
            {from: 'feed_name', to: 'FeedName'},
            {from: 'alert_severity', to: 'Severity'},
            {from: 'created_time', to: 'Time'},
            {from: 'status', to: 'Status'}
        ];
        let headers = changeNames.map(cn => cn.to);
        let translatedData = mapObjFunction(changeNames)(alerts);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Alerts(val.CbAlertID==obj.CbAlertID)': createContext(translatedData)
        };
        return {
            Type: entryTypes.note,
            Contents: alerts,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context
        };
    }


    function updateAlertRequest(alertUniqueId, status, setIgnored) {
        let queryParams = {};
        if (alertUniqueId) {
            queryParams.alert_ids = [alertUniqueId];
        }
        if (status) {
            queryParams.requested_status = status;
        }
        if (setIgnored) {
            queryParams.set_ignored = setIgnored;
        }
        let response = sendRequest('/v1/alerts', 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function updateAlert() {
        let response = updateAlertRequest(args.uniqueId, args.status, args.setIgnored);
        if (response.result && response.result === 'success') {
            return {
                Type: entryTypes.note,
                Contents: response,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: 'Alert updated successfully'
            }
        } else {
            throw `Command failed.\nOutput: ${JSON.stringify(response)}`;
        }
    }


    const processData = [
        {from: 'process_name', to: 'Name'},
        {from: 'hostname', to: 'Endpoint'},
        {from: 'last_update', to: 'Update'},
        {from: 'start', to: 'Start Time'},
        {from: 'process_pid', to: 'PID'},
        {from: 'username', to: 'Username'},
        {from: 'process_md5', to: 'MD5'},
        {from: 'cmdline', to: 'CommandLine'},
        {from: 'path', to: 'Path'},
        {from: 'id', to: 'CbID'},
        {from: 'segment_id', to: 'CbSegmentID'},
        {from: 'group', to: 'Group'},
        {from: 'start', to: 'StartTime'}
    ];


    const processDataForFileContext = [
        {from: 'process_name', to: 'Name'},
        {from: 'process_md5', to: 'MD5'},
        {from: 'path', to: 'Path'}
    ];


    const processDataForEndpointContext = [
      {from: 'hostname', to: 'Hostname'}
    ];


    function getProcessesRequest(query, rows, start, sort, facets) {
        let queryParams = {};
        if (query) {
            queryParams.q = query;
        }
        if (rows) {
            queryParams.rows = rows;
        }
        if (start) {
            queryParams.start = start;
        }
        if (sort) {
            queryParams.sort = sort;
        }
        if (facets) {
            queryParams.facets = facets;
        }
        let response = sendRequest('/v1/process', 'GET', encodeToURLQuery(queryParams));
        try {
            return JSON.parse(response.Body).results;
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function getProcesses() {
        let query = '';
        if (args.query) {
            query = '(' + args.query + ')';
        }
        if (args.name) {
            query += ' AND process_name:' + args.name
        }
        if (args.group) {
            query += ' AND group:' + args.group;
        }
        if (args.hostname) {
            query += ' AND hostname:' + args.hostname;
        }
        if (args['parent-process-name']) {
            query += ' AND parent_name:' + args['parent-process-name'];
        }
        if (args['process-path']) {
            query += ' AND path:' + args['process-path'];
        }
        if (args.md5) {
            query += ' AND md5:' + args.md5;
        }
        let processes = getProcessesRequest(query, args.rows, args.start, args.sort, args.facets);
        let title = 'CB Response - Get Processes';
        let processDataMap = processData;
        let fileDataMap = processDataForFileContext;
        let endpointDataMap = processDataForEndpointContext;
        let headers = processDataMap.map(cn => cn.to);
        let processTranslatedData = mapObjFunction(processDataMap)(processes);
        let fileTranslatedData = mapObjFunction(fileDataMap)(processes);
        let endpointTranslatedData = mapObjFunction(endpointDataMap)(processes);
        let humanReadable = tableToMarkdown(title, processTranslatedData, headers, undefined, dotToSpace);
        let context = {
            'Process(val.CbID==obj.CbID)': createContext(processTranslatedData),
            'File(val.MD5==obj.MD5)': createContext(fileTranslatedData),
            'Endpoint(val.Hostname==obj.Hostname)': createContext(endpointTranslatedData)
        };
        return {
            Type: entryTypes.note,
            Contents: processes,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    function getProcessRequest(processId, segmentId) {
        let response = sendRequest(`/v2/process/${processId}/${segmentId}`, 'GET');
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function getFullProcessRequest(processId, segmentId) {
        let response = sendRequest(`/v1/process/${processId}/${segmentId}`, 'GET');
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function getProcess() {
        let entries = [];
        let title = 'CB Response - Process';
        let dataMap = processData;
        let headers = dataMap.map(cn => cn.to);
        let result;
        let processTranslatedData;
        let context;

        if (args.get_related === 'true') {
            result = getFullProcessRequest(args.pid, args.segid)
            processTranslatedData = mapObjFunction(dataMap)(result.process);
            let parentProcessTranslatedData = mapObjFunction(dataMap)(result.parent);
            let siblingsProcessTranslatedData = [];
            for (var i = 0; i < result.siblings.length; i++) {
                siblingsProcessTranslatedData.push(mapObjFunction(dataMap)(result.siblings[i]));
            }
            let childrenProcessTranslatedData = []
            for (var i = 0; i < result.children.length; i++) {
                childrenProcessTranslatedData.push(mapObjFunction(dataMap)(result.children[i]));
            }
            context = processTranslatedData;
            context.Siblings = siblingsProcessTranslatedData
            context.Parent = parentProcessTranslatedData
            context.Children = childrenProcessTranslatedData
        } else {
            result = getProcessRequest(args.pid, args.segid);
            processTranslatedData = mapObjFunction(dataMap)(result);
            context = processTranslatedData;
        }
        let humanReadable = tableToMarkdown(title, processTranslatedData, headers, undefined, dotToSpace);
        entries.push({
            Type: entryTypes.note,
            Contents: result.process,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable
        });

        entries[0].EntryContext = {
            'Process(val.CbID==obj.CbID)': createContext(context)
        };

        return entries;
    }


    function getProcessEventsRequest(processId, segmentId) {
        let response = sendRequest(`/v1/process/${processId}/${segmentId}/event`, 'GET');
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function getProcessEvents() {
        let result = getProcessEventsRequest(args.pid, args.segid);

        let entries = [];

        let title = 'CB Response - Process Event';
        let dataMap = processData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result.process);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let contextData = translatedData;
        entries.push({
            Type: entryTypes.note,
            Contents: result.process,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable
        });

        title = 'Cross Process';
        let crossProcDataMap = [
            {to: 'Action', from: ".=(val.split('|')[0])"},
            {to: 'Time', from: ".=(val.split('|')[1])"},
            {to: 'OtherProcessCbID', from: ".=(val.split('|')[2])"},
            {to: 'OtherProcessMD5', from: ".=(val.split('|')[3])"},
            {to: 'OtherProcessBinary', from: ".=(val.split('|')[4])"}
        ];
        headers = crossProcDataMap.map(cn => cn.to);
        translatedData = [];
        if ('process' in result) {
          if (result.process.crossproc_complete) {
            translatedData = mapObjFunction(crossProcDataMap)(result.process.crossproc_complete);
          }
        }
        humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        contextData['CrossProc'] = translatedData;
        entries.push({
            Type: entryTypes.note,
            Contents: result.process.crossproc_complete,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable
        });

        title = 'Modules';
        let modulesDataMap = [
            {to: 'Time', from: ".=(val.split('|')[0])"},
            {to: 'MD5', from: ".=(val.split('|')[1])"},
            {to: 'Filepath', from: ".=(val.split('|')[2])"}
        ];
        headers = modulesDataMap.map(cn => cn.to);
        let modulesResult = dq(result, 'process.modload_complete(val.MD5==obj.MD5)');
        translatedData = mapObjFunction(modulesDataMap)(modulesResult);
        humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        contextData['Modules'] = translatedData;
        entries.push({
            Type: entryTypes.note,
            Contents: modulesResult,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable
        });

        title = 'Registry';
        let registryDataMap = [
            {to: 'Time', from: ".=(val.split('|')[1])"},
            {to: 'RegistryPath', from: ".=(val.split('|')[2])"}
        ];
        headers = registryDataMap.map(cn => cn.to);
        translatedData = [];
        if ('process' in result) {
          if (result.process.regmod_complete) {
            translatedData = mapObjFunction(registryDataMap)(result.process.regmod_complete);
          }
        }
        humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        contextData['Registry'] = translatedData;
        entries.push({
            Type: entryTypes.note,
            Contents: result.process.regmod_complete,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable
        });

        title = 'Binaries';
        headers = ['MD5', 'Publisher', 'Result'];
        translatedData = [];
        if ('process' in result) {
          if (result.process.binaries) {
            let keys = Object.keys(result.process.binaries);
            translatedData = keys.map(md5 => ({
                'MD5': md5,
                'Publisher': result.process.binaries[md5]['digsig_publisher'],
                'Result': result.process.binaries[md5]['digsig_result']
            }));
          }
        }
        humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        contextData['Binaries'] = translatedData.map(binary => ({
            'MD5': binary.MD5,
            'DigSig.Publisher': binary['Publisher'],
            'DigSig.Result': binary['Result']
        }));
        entries.push({
            Type: entryTypes.note,
            Contents: result.process.binaries,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable
        });

        entries[0].EntryContext = {
            'Process(val.CbID==obj.CbID)': createContext(contextData)
        };

        return entries;
    }


    const binaryData = [
        {to: 'Name', from: 'original_filename'},
        {to: 'MD5', from: 'md5'},
        {to: 'Timestamp', from: 'timestamp'},
        {
            to: 'Extension',
            from: '.=(val.original_filename.indexOf(".")>=0 ? val.original_filename.split(".")[1] : "")'
        },
        {to: 'Hostname', from: "endpoint"},
        {to: 'Path', from: 'observed_filename'},
        {to: 'LastSeen', from: 'last_seen'},
        {to: 'ServerAddedTimestamp', from: 'server_added_timestamp'},
        {to: 'Description', from: 'file_desc'},
        {to: 'InternalName', from: 'internal_name'},
        {to: 'ProductName', from: 'product_name'},
        {to: 'OS', from: 'os_type'},
        {to: 'DigSig.Result', from: 'digsig_result'},
        {to: 'DigSig.Publisher', from: 'digsig_publisher'},
        {to: 'Company', from: 'company_name'},
        {to: 'DigitalSignature.Publisher', from: 'digsig_publisher'},
        {to: 'Name', from: 'original_filename'},
        {to: 'Signature.OriginalName', from: 'original_filename'},
        {to: 'Signature.InternalName', from: 'internal_name'},
        {to: 'Signature.FileVersion', from: 'file_version'},
        {to: 'Signature.Description', from: 'file_desc'}
    ];


    function getBinariesRequest(query, rows, start, sort, facets) {
        let queryParams = {};
        if (query) {
            queryParams.q = query;
        }
        if (rows) {
            queryParams.rows = rows;
        }
        if (start) {
            queryParams.start = start;
        }
        if (sort) {
            queryParams.sort = sort;
        }
        if (facets) {
            queryParams.facets = facets;
        }
        let response = sendRequest('/v1/binary', 'GET', encodeToURLQuery(queryParams));
        try {
            return JSON.parse(response.Body).results;
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function getBinaries() {
        let query = '';
        if (args.query) {
            query = '(' + args.query + ')';
        }
        if (args['digital-signature']) {
            query += ' AND digsig_result:' + args['digital-signature'];
        }
        if (args['publisher']) {
            query += ' AND digsig_publisher:' + args['publisher'];
        }
        if (args['company-name']) {
            query += ' AND company_name:' + args['company-name'];
        }
        if (args['product-name']) {
            query += ` AND product_name: "${args['product-name']}"`;
        }
        if (args['filepath']) {
            query += ` AND observed_filename:"${args['filepath']}"`;
        }
        if (args['group']) {
            query += ` AND group:"${args['group']}"`
        }
        if (args['hostname']) {
            query += ` AND hostname:"${args['hostname']}"`
        }
        let result = getBinariesRequest(query, args.rows, args.start, args.sort, args.facets);

        let title = 'CB Response - Get Binaries';
        let dataMap = binaryData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        // format results - "|" char disturbing markdown representation
        for (let i = 0; i < translatedData.length; i++) {
            let data = translatedData[i];
            if (data['Hostname']) {
                translatedData[i]['Hostname'] = data['Hostname'].join().replace(/\|/gi," ");
            }
        }
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'File(val.MD5==obj.MD5)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    function getBinarySummaryRequest(md5) {
        let response = sendRequest('/v1/binary/' + md5 + '/summary', 'GET');
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function getBinaryRequest(md5) {
        return sendRequest('/v1/binary/' + md5, 'GET');
    }


    function getBinary() {
        let entries = [];

        if (args.summary && args.summary === 'yes') {
            let result = getBinarySummaryRequest(args.md5);
            let title = 'CB Response - Binary Summary';
            let dataMap = binaryData;
            let headers = dataMap.map(cn => cn.to);
            let translatedData = mapObjFunction(dataMap)(result);
            let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
            let context = {
                'File(val.MD5==obj.MD5)': createContext(translatedData)
            };
            entries.push({
                Type: entryTypes.note,
                Contents: result,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: humanReadable,
                EntryContext: context,
            });
        }

        let res = getBinaryRequest(args.md5);
        let fileEntryId = saveFile(res.Bytes);

        if (args.decompress && args.decompress === 'no') {
            return {
                Type: entryTypes.file,
                FileID: fileEntryId,
                File: 'results.zip',
                Contents: ""
            };
        }

        else {
            let fileEntries = decompressFile(fileEntryId);

            fileEntries.forEach(fileEntry => {
                entries.push({
                    Type: fileEntry.Type,
                    FileID: fileEntry.FileID,
                    File: fileEntry.File,
                    Contents: ''
                });
            });
        }

        return entries;
    }


    function getBinaryZip() {
        let entries = [];

        if (args.summary && args.summary === 'yes') {
            let result = getBinarySummaryRequest(args.md5);
            let title = 'CB Response - Binary Summary';
            let dataMap = binaryData;
            let headers = dataMap.map(cn => cn.to);
            let translatedData = mapObjFunction(dataMap)(result);
            let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
            let context = {
                'File(val.MD5==obj.MD5)': createContext(translatedData)
            };
            entries.push({
                Type: entryTypes.note,
                Contents: result,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: humanReadable,
                EntryContext: context,
            });
        }

        let res = getBinaryRequest(args.md5);
        let fileEntryId = saveFile(res.Bytes);

        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: 'results.zip',
            Contents: ""
        };
    }


    function getSensorsRequest(sensorId, hostname, ip, groupId) {
        let queryParams = {};
        if (hostname) {
            queryParams.hostname = hostname;
        }
        if (ip) {
            queryParams.ip = ip;
        }
        if (groupId) {
            queryParams.groupid = groupId;
        }
        let path = '/v1/sensor';
        if (sensorId) {
            path += '/' + sensorId;
        }
        let response = sendRequest(path, 'GET', encodeToURLQuery(queryParams)).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function getSensors() {
        let ipAddressDQ = '.=(val.network_adapters.split("|").slice(0, val.network_adapters.split("|").length-1))';
        let result = getSensorsRequest(args.sensor, args.hostname, args.ip, args.groupid);

        let entries = [];
        let title = 'CB Response - Get Sensors';
        let dataMap = [
            {to: 'CbSensorID', from: 'id'},
            {to: 'Hostname', from: 'computer_name'},
            {to: 'Status', from: 'status'},
            {to: 'IPAddresses', from: ipAddressDQ},
            {to: 'IPAddress', from: 'network_adapters'},
            {to: 'Notes', from: 'notes'},
            {to: 'Isolated', from: 'network_isolation_enabled'},
            {to: 'OS', from: 'os_environment_display_string'},
            {to: 'Uptime', from: 'sensor_uptime'},
            {to: 'LastUpdate', from: 'last_update'},
            {to: 'SupportsCbLive', from: 'supports_cblr'}
        ];
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Sensors(val.CbSensorID==obj.CbSensorID)': createContext(translatedData)
        };

        entries.push({
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        });

        title = 'Endpoints';
        dataMap = [
            {to: 'Hostname', from: 'computer_name'},
            {to: 'OS', from: 'os_environment_display_string'},
            {to: 'IPAddresses', from: ipAddressDQ},
            {to: 'CbSensorID', from: 'id'},
        ];
        headers = dataMap.map(cn => cn.to);
        translatedData = mapObjFunction(dataMap)(result);
        humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        context = {
            'Endpoint': createContext(translatedData)
        };

        entries.push({
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        });

        return entries;
    }


    function getHashBlacklistRequest(filter) {
        let queryParams = {};
        if (filter) {
            queryParams.filter = filter;
        }
        let response = sendRequest('/v1/banning/blacklist', 'GET', encodeToURLQuery(queryParams)).Body;
        try {
            if (response === '') {
                return [];
            } else {
                return JSON.parse(response);
            }
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function getHashBlacklist() {
        let result = getHashBlacklistRequest(args.filter);

        let title = 'CB Response - Hash Blacklist';
        let dataMap = [
            {to: 'MD5', from: 'md5hash'},
            {to: 'Enabled', from: 'enabled'},
            {to: 'Description', from: 'text'},
            {to: 'Timestamp', from: 'timestamp'},
            {to: 'BlockCount', from: 'block_count'},
            {to: 'Username', from: 'username'},
            {to: 'LastBlock.Time', from: 'last_block_time'},
            {to: 'LastBlock.Hostname', from: 'last_block_hostname'},
            {to: 'LastBlock.CbSensorID', from: 'last_block_sensor_id'}
        ];
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.BlockedHashes(val.MD5==obj.MD5)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    function blockHashRequest(md5, text, enabled, lastBanTime, banCount, lastBanHost) {
        let queryParams = {};
        if (md5) {
            queryParams.md5hash = md5;
        }
        if (text) {
            queryParams.text = text;
        }
        if (enabled) {
            queryParams.enabled = enabled;
        }
        if (lastBanTime) {
            queryParams.last_ban_time = lastBanTime;
        }
        if (banCount) {
            queryParams.ban_count = banCount;
        }
        if (lastBanHost) {
            queryParams.last_ban_host = lastBanHost;
        }
        let response = sendRequest('/v1/banning/blacklist', 'POST', queryParams);
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function unblockHashRequest(md5, text) {
        let queryParams = {};
        if (text) {
            queryParams.text = text;
        }
        let response = sendRequest(`/v1/banning/blacklist/${md5}`, 'DELETE', queryParams);
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function blockHash(doBlock) {
        let result;

        if (doBlock) {
            // Get banning list
            result = getHashBlacklistRequest(`md5hash==${args.md5hash} && enabled==true`);
            if (result.length === 0 || isEmpty(result)) {
                // New hash so create a block
                result = blockHashRequest(args.md5hash, args.text, true,
                    args.lastBanTime, args.banCount, args.lastBanHost);
            } else {
                // Existing hash so just update
                result = blockHashRequest(result[0].md5hash, result[0].text, true,
                    result[0].lastBanTime, result[0].banCount, result[0].lastBanHost);
            }
        } else {
            result = unblockHashRequest(args.md5hash, args.text);
        }

        let blockedStr = (doBlock) ? 'blocked' : 'unblocked';

        let entry = {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: "Failed to " + blockedStr + " " + args.sensor,
            EntryContext: {
                "Endpoint(val.CbSensorID == obj.CbSensorID)": {
                    "CbSensorID": args.sensor,
                    "LastAction": (doBlock) ? "Blocked" : "Unblocked"
                }
            }
        };

        if (result.result === 'success') {
            entry.HumanReadable = "Success: " + blockedStr + " " + args['md5hash'];
            entry.EntryContext = {
                "File(val.MD5 && val.MD5==obj.MD5)": {
                    "MD5": args['md5hash'],
                    "LastAction": (doBlock) ? "Blocked" : "Unblocked"
                }
            };
        }

        return entry;
    }


    const watchlistData = [
        {to: 'CbWatchlistID', from: 'id'},
        {to: 'Name', from: 'name'},
        {to: 'SearchQuery', from: 'search_query'},
        {to: 'Enabled', from: 'enabled'},
        {to: 'LastHit', from: 'last_hit'},
        {to: 'LastHitCount', from: 'last_hit_count'},
        {to: 'SearchTimestamp', from: 'search_timestamp'},
        {to: 'TotalHits', from: 'total_hits'},
        {to: 'DateAdded', from: 'date_added'}
    ];


    function getWatchlistRequest(watchlistId) {
        let path = '/v1/watchlist';
        if (watchlistId) {
            path += '/' + watchlistId;
        }

        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function getWatchlist() {
        let result = getWatchlistRequest(args['watchlist-id']);

        let title = 'CB Response - List Watchlists';
        let dataMap = watchlistData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Watchlists(val.CbWatchlistID==obj.CbWatchlistID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    function createWatchlistRequest(name, searchQuery, indexType) {
        let queryParams = {};
        if (name) {
            queryParams.name = name;
        }
        if (searchQuery) {
            queryParams.search_query = searchQuery;
        }
        if (indexType) {
            queryParams.index_type = indexType;
        }

        let response = sendRequest(`/v1/watchlist`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function createWatchlist() {
        let result = createWatchlistRequest(args.name, args['search-query'], args.indexType);

        let title = `CB Response - New Watchlist`;
        let dataMap = [{to: 'CbWatchlistID', from: 'id'}];
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Watchlists(val.CbWatchlistID==obj.CbWatchlistID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    function updateWatchlistRequest(watchlistId, watchlistObject) {
        let response = sendRequest(`/v1/watchlist/${watchlistId}`, 'PUT', watchlistObject).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function setWatchlist() {
        let watchlistObject = getWatchlistRequest(args['watchlist-id']);

        if (args['search-query']) {
            watchlistObject.search_query = args['search-query'];
        }
        if (args.name) {
            watchlistObject.name = args.name;
        }
        if (args.indexType) {
            watchlistObject.index_type = args.indexType;
        }

        let result = updateWatchlistRequest(args['watchlist-id'], watchlistObject);

        if (!result.result || result.result !== 'success') {
            throw `Failed updating watchlist.\nResponse: ${response}`;
        }

        let title = `CB Response - Set Watchlist`;
        let dataMap = watchlistData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(watchlistObject);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Watchlists(val.CbWatchlistID==obj.CbWatchlistID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: watchlistObject,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    function deleteWatchlistRequest(watchlistId) {
        let response = sendRequest(`/v1/watchlist/${watchlistId}`, 'DELETE').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function deleteWatch() {
        let result = deleteWatchlistRequest(args['watchlist-id']);

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: "Success - deleted watchlist " + args["watchlist-id"]
        };
    }


    try {
        switch (command) {
            case 'test-module':
                return testModule();
            case 'cb-version':
                return version();
            case 'fetch-incidents':
                return fetchIncidents();
            case 'cb-alert':
                return showAlerts(); // Tested
            case 'cb-alert-update':
                return updateAlert(); // Tested
            case 'cb-quarantine-device':
                return quarantineDevice(true); // Tested
            case 'cb-unquarantine-device':
                return quarantineDevice(false); // Tested
            case 'cb-get-processes':
                return getProcesses(); // Tested
            case 'cb-get-process':
                return getProcess(); // Tested
            case 'cb-process-events':
                return getProcessEvents(); // Tested
            case 'cb-binary':
                return getBinaries(); // Tested
            case 'cb-binary-get':
                return getBinary(); // Tested
            case 'cb-list-sensors':
            case 'cb-sensor-info':
                return getSensors(); // Tested
            case 'cb-block-hash':
                return blockHash(true); // Tested
            case 'cb-unblock-hash':
                return blockHash(false); // Tested
            case 'cb-get-hash-blacklist':
                return getHashBlacklist(); // Tested
            case 'cb-watchlist':
            case 'cb-watchlist-get':
                return getWatchlist(); // Tested
            case 'cb-watchlist-new':
                return createWatchlist(); // Tested
            case 'cb-watchlist-set':
                return setWatchlist(); // Tested
            case 'cb-watchlist-del':
                return deleteWatch(); // Tested
            case 'cb-binary-download':
                return getBinaryZip();
            default:
                throw `Unknown Command: ${command}`;
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: err
        }
    }


    /// Global Utils


    /**
     * Returns whether a given object 'obj' is empty (has no properties)
     */
    function isEmpty(obj) {
        return Object.keys(obj).length === 0 && obj.constructor === Object
    }


    /**
     * Converts UNIX timestamp to format: YYYY-MM-DD HH:MM:SS
     */
    function unixToString(unixTime) {
        let timeStr = convertTimestampToString(unixTime);
        return timeStr.substring(0, timeStr.length - 5);
    }


    /**
     * Converts a string timestamp (ISO String tested) to UNIX.
     */
    function stringToUnix(dateString) {
        return new Date(dateString).getTime();
    }
  type: javascript
  commands:
  - name: cb-alert
    arguments:
    - name: status
      auto: PREDEFINED
      predefined:
      - Unresolved
      - In Progress
      - Resolved
      - False Positive
      description: Alert status to filter by
    - name: username
      description: Alert username to filter by
    - name: feedname
      description: Alert feedname to filter by
    - name: hostname
      description: Alert hostname to filter by
    - name: report
      description: Alert report name (watchlist_id) to filter by
    - name: query
      default: true
      description: Query string. Accepts the same data as the search box on the Binary Search page. See https://github.com/carbonblack/cbapi/blob/master/client_apis/docs/query_overview.pdf
    - name: rows
      description: Return this many rows, 10 by default.
    - name: start
      description: Start at this row, 0 by default.
    - name: sort
      description: Sort rows by this field and order. server_added_timestamp desc by default.
    - name: facet
      description: Return facet results. 'false' by default, set to 'true' for facets.
    outputs:
    - contextPath: CbResponse.Alerts.CbAlertID
      description: Alert unique id
    - contextPath: CbResponse.Alerts.ProcessPath
      description: Alert Process Path
      type: string
    - contextPath: CbResponse.Alerts.Hostname
      description: Alert Hostname
      type: string
    - contextPath: CbResponse.Alerts.InterfaceIP
      description: Alert interface IP
      type: string
    - contextPath: CbResponse.Alerts.CommsIP
      description: Communications IP
      type: string
    - contextPath: CbResponse.Alerts.MD5
      description: Alert process MD5
      type: string
    - contextPath: CbResponse.Alerts.Description
      description: Alert description
    - contextPath: CbResponse.Alerts.FeedName
      description: Alert feed name
    - contextPath: CbResponse.Alerts.Severity
      description: Alert severity
    - contextPath: CbResponse.Alerts.Time
      description: Alert created time
    - contextPath: CbResponse.Alerts.Status
      description: 'Alert status. One of: Unresolved, Resolved, False Positive'
    description: Retrieve alerts from Carbon Black Response.
  - name: cb-binary
    arguments:
    - name: digital-signature
      auto: PREDEFINED
      predefined:
      - Signed
      - Unsigned
      description: Whether digital signature is signed or not
    - name: publisher
      description: Filter binary by publisher
    - name: company-name
      description: Filter binary by company name
    - name: product-name
      description: Filter binary by product name
    - name: filepath
      description: Filter binary by file path
    - name: group
      description: Filter binary by group
    - name: hostname
      description: Filter binary by hostname
    - name: query
      default: true
      description: Query string. Accepts the same data as the search box on the Binary Search page. See https://github.com/carbonblack/cbapi/blob/master/client_apis/docs/query_overview.pdf
    - name: rows
      description: Return this many rows, 10 by default.
    - name: start
      description: Start at this row, 0 by default.
    - name: sort
      description: Sort rows by this field and order. server_added_timestamp desc by default.
    - name: facet
      description: Return facet results. 'false' by default, set to 'true' for facets.
    outputs:
    - contextPath: File.DigSig.Publisher
      description: The publisher of the Digital Signature
    - contextPath: File.InternalName
      description: The Internal Name
    - contextPath: File.ServerAddedTimestamp
      description: The server added timestamp
    - contextPath: File.Name
      description: Binary Name
    - contextPath: File.Extension
      description: Binary Extension
    - contextPath: File.Timestamp
      description: Binary Timestamp
    - contextPath: File.Hostname
      description: Binary Hostname
    - contextPath: File.Description
      description: The description
    - contextPath: File.DigSig.Result
      description: Cb's decision after checking this binary's Digital Signature
    - contextPath: File.LastSeen
      description: Last time binary was seen
    - contextPath: File.Path
      description: Binary Path
    - contextPath: File.ProductName
      description: The Product Name
    - contextPath: File.OS
      description: The OS
    - contextPath: File.MD5
      description: Binary MD5
    - contextPath: File.Company
      description: Name of the company that released a binary
      type: string
    - contextPath: File.DigitalSignature.Publisher
      description: Publisher of the digital signature for the file.
      type: string
    - contextPath: File.Name
      description: Full Filename e.g. data.xls.
      type: string
    - contextPath: File.Signature.OriginalName
      description: File's original name.
      type: string
    - contextPath: File.Signature.InternalName
      description: File's internal name.
      type: string
    - contextPath: File.Signature.FileVersion
      description: File version.
      type: string
    - contextPath: File.Signature.Description
      description: Description of the signature.
      type: string
    description: Query for binaries based on given parameters
  - name: cb-binary-get
    arguments:
    - name: md5
      required: true
      default: true
      description: MD5 File Hash
    - name: summary
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Whether to include summary
    - name: decompress
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Whether to decompress results
      defaultValue: "yes"
    outputs:
    - contextPath: File.DigSig.Publisher
      description: The publisher of the Digital Signature
    - contextPath: File.InternalName
      description: The Internal Name
    - contextPath: File.ServerAddedTimestamp
      description: The server added timestamp
    - contextPath: File.Name
      description: Binary Name
    - contextPath: File.Extension
      description: Binary Extension
    - contextPath: File.Timestamp
      description: Binary Timestamp
    - contextPath: File.Hostname
      description: Binary Hostname
    - contextPath: File.Description
      description: The description
    - contextPath: File.DigSig.Result
      description: Cb's decision after checking this binary's Digital Signature
    - contextPath: File.LastSeen
      description: Last time binary was seen
    - contextPath: File.Path
      description: Binary Path
    - contextPath: File.ProductName
      description: The Product Name
    - contextPath: File.OS
      description: The OS
    - contextPath: File.MD5
      description: Binary MD5
    - contextPath: File.Company
      description: Name of the company that released a binary
      type: string
    - contextPath: File.DigitalSignature.Publisher
      description: Publisher of the digital signature for the file.
      type: string
    - contextPath: File.Name
      description: Full Filename e.g. data.xls.
      type: string
    - contextPath: File.Signature.OriginalName
      description: File's original name.
      type: string
    - contextPath: File.Signature.InternalName
      description: File's internal name.
      type: string
    - contextPath: File.Signature.FileVersion
      description: File version.
      type: string
    - contextPath: File.Signature.Description
      description: Description of the signature.
      type: string
    description: Deprecated. Use the cb-binary-download command instead.
    deprecated: true
  - name: cb-block-hash
    arguments:
    - name: md5hash
      required: true
      description: the blacklisted hash
    - name: text
      required: true
      description: text description of blacklist
    - name: lastBanTime
      description: the last time the hash was blocked or prevented from being executed
    - name: banCount
      description: total number of blocks on this blacklist
    - name: lastBanHost
      description: last hostname to block this hash
    outputs:
    - contextPath: File.LastAction
      description: Last action taken on this file
    important:
    - contextPath: File(val.LastAction)
      description: File Actions
      related: ""
    description: Blocking hash
  - name: cb-get-hash-blacklist
    arguments:
    - name: filter
      description: 'OPTIONAL filters blacklist by fields. Example: filter="md5hash == put_your_hash_here"'
    outputs:
    - contextPath: CbResponse.BlockedHashes.MD5
      description: Blocked MD5
    - contextPath: CbResponse.BlockedHashes.Enabled
      description: Is Enabled
    - contextPath: CbResponse.BlockedHashes.Description
      description: Blocked Description
    - contextPath: CbResponse.BlockedHashes.Timestamp
      description: Blocked Timestamp
    - contextPath: CbResponse.BlockedHashes.BlockCount
      description: Blocked Count
    - contextPath: CbResponse.BlockedHashes.Username
      description: Blocked hash username
    - contextPath: CbResponse.BlockedHashes.LastBlock.Time
      description: Last block time
    - contextPath: CbResponse.BlockedHashes.LastBlock.Hostname
      description: Last block hostname
    - contextPath: CbResponse.BlockedHashes.LastBlock.CbSensorID
      description: Last block sensor ID
    description: Returns a list of blacklisted hashes, with each list entry describing one blacklisted hash
  - name: cb-get-process
    arguments:
    - name: pid
      required: true
      description: the internal CB process id; this is the id field in search results
    - name: segid
      required: true
      description: the process segment id, the segment_id field in search results.
    - name: get_related
      auto: PREDEFINED
      predefined:
      - "false"
      - "true"
      description: If set to true, will get process siblings, parent and children.
      defaultValue: "false"
    outputs:
    - contextPath: Process.Siblings.MD5
      description: The sibling Process MD5
    - contextPath: Process.CbSegmentID
      description: Cb 'segment' where this process instance is stored. Required to fetch further info on a process.
    - contextPath: Process.Parent.MD5
      description: The parent Process MD5
    - contextPath: Process.Children.CommandLine
      description: The children Process CommandLine
    - contextPath: Process.Hostname
      description: Process Hostname
    - contextPath: Process.Parent.CbSegmentID
      description: The parent Cb 'segment' where this process instance is stored. Required to fetch further info on a process.
    - contextPath: Process.CbID
      description: Cb unique ID for this process instance - required (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Siblings.CbSegmentID
      description: The sibling Cb 'segment' where this process instance is stored. Required to fetch further info on a process.
    - contextPath: Process.Children.Name
      description: The children Process Name
    - contextPath: Process.Parent.Name
      description: The parent Process Name
    - contextPath: Process.Siblings.Hostname
      description: The sibling Process Hostname
    - contextPath: Process.Parent.Path
      description: The parent Process Path
    - contextPath: Process.Children.Hostname
      description: The children Process Hostname
    - contextPath: Process.PID
      description: Process PID
    - contextPath: Process.Children.CbSegmentID
      description: The children Cb 'segment' where this process instance is stored. Required to fetch further info on a process.
    - contextPath: Process.Children.CbID
      description: The children Cb unique ID for this process instance - required (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Path
      description: Process Path
    - contextPath: Process.Parent.PID
      description: The parent Process PID
    - contextPath: Process.Children.Path
      description: The children Process Path
    - contextPath: Process.Name
      description: Process Name
    - contextPath: Process.Children.PID
      description: The children Process PID
    - contextPath: Process.Parent.CbID
      description: The parent Cb unique ID for this process instance - required (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.CommandLine
      description: Process CommandLine
    - contextPath: Process.Siblings.CommandLine
      description: The sibling Process CommandLine
    - contextPath: Process.Siblings.Name
      description: The sibling Process Name
    - contextPath: Process.Parent.CommandLine
      description: The parent Process CommandLine
    - contextPath: Process.Parent.Hostname
      description: The parent Process Hostname
    - contextPath: Process.MD5
      description: Process MD5
    - contextPath: Process.Children.MD5
      description: The children Process MD5
    - contextPath: Process.Siblings.CbID
      description: The sibling Cb unique ID for this process instance - required (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Siblings.Path
      description: The sibling Process Path
    - contextPath: Process.Siblings.PID
      description: The sibling Process PID
    - contextPath: Process.StartTime
      description: Start time of the process.
      type: date
    description: Gets basic process information for segment (segment_id) of process (process_id)
  - name: cb-get-processes
    arguments:
    - name: name
      description: Filter processes by name
    - name: group
      description: Filter processes by group
    - name: hostname
      description: Filter processes by hostname
    - name: parent-process-name
      description: Filter processes by parent process name
    - name: process-path
      description: 'Filter processes by process path (Example: "c:\windows\resources\spoolsv.exe")'
    - name: md5
      description: Filter processes by md5 hash
    - name: query
      default: true
      description: Query string. Accepts the same data as the search box on the Binary Search page. See https://github.com/carbonblack/cbapi/blob/master/client_apis/docs/query_overview.pdf
    - name: rows
      description: Return this many rows, 10 by default.
    - name: start
      description: Start at this row, 0 by default.
    - name: sort
      description: Sort rows by this field and order. server_added_timestamp desc by default.
    - name: facet
      description: Return facet results. 'false' by default, set to 'true' for facets.
    outputs:
    - contextPath: File.Name
      description: File Name
    - contextPath: File.MD5
      description: File MD5
    - contextPath: File.Path
      description: File Path
    - contextPath: Endpoint.Hostname
      description: Endpoint Hostname
    - contextPath: Process.CommandLine
      description: Process  Commandline
    - contextPath: Process.PID
      description: Process PID
    - contextPath: Process.CbID
      description: Cb unique ID for this process instance - required (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.CbSegmentId
      description: Cb "segment" where this process instance is stored. Required to fetch further info on a process.
    - contextPath: Process.Parent.PID
      description: Process Parent PID
    - contextPath: Process.Parent.Name
      description: Process Parent Name
    - contextPath: Process.StartTime
      description: Start time of the process.
      type: date
    description: Query processes based on given parameters
  - name: cb-list-sensors
    arguments: []
    outputs:
    - contextPath: CbResponse.Sensors.Status
      description: Sensor Status
    - contextPath: CbResponse.Sensors.LastUpdate
      description: Sensor Last Updated
    - contextPath: CbResponse.Sensors.Uptime
      description: The Sensor uptime
    - contextPath: CbResponse.Sensors.SupportsCbLive
      description: Sensor Support CB Live
    - contextPath: CbResponse.Sensors.Notes
      description: Sensor Notes
    - contextPath: CbResponse.Sensors.Hostname
      description: Hostname
    - contextPath: CbResponse.Sensors.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sensors.Isolated
      description: Sensor Isolated
    - contextPath: CbResponse.Sensors.IPAddresses
      description: Sensor IP Addresses
    - contextPath: CbResponse.Sensors.OS
      description: Sensor OS
    - contextPath: Endpoint.Hostname
      description: Sensor Hostname
    - contextPath: Endpoint.OS
      description: Sensor OS
    - contextPath: Endpoint.IPAddresses
      description: Sensor IP Addresses
    description: List the CarbonBlack sensors
  - name: cb-process-events
    arguments:
    - name: pid
      required: true
      description: the internal CB process id; this is the id field in search results
    - name: segid
      required: true
      description: the process segment id; this is the segment_id field in search results.
    outputs:
    - contextPath: Process.CrossProc.OtherProcessMD5
      description: Other process MD5
    - contextPath: Process.MD5
      description: Process MD5
    - contextPath: Process.Modules.MD5
      description: Module MD5
    - contextPath: Process.CommandLine
      description: Process CommandLine
    - contextPath: Process.Registry.RegistryPath
      description: Registry path
    - contextPath: Process.Path
      description: Process Path
    - contextPath: Process.CbID
      description: Cb unique ID for this process instance - required (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Parent.Name
      description: The parent Process Name
    - contextPath: Process.Hostname
      description: Process Hostname
    - contextPath: Process.Binaries.DigSig.Publisher
      description: The publisher of the Digital Signature
    - contextPath: Process.CrossProc.Action
      description: Cross process action
    - contextPath: Process.CrossProc.OtherProcessCbID
      description: Other process CbID
    - contextPath: Process.CbSegmentID
      description: Cb 'segment' where this process instance is stored. Required to fetch further info on a process.
    - contextPath: Process.Name
      description: Process Name
    - contextPath: Process.CrossProc.Time
      description: Time of action
    - contextPath: Process.PID
      description: Process PID
    - contextPath: Process.Modules.Filepath
      description: Module path
    - contextPath: Process.Binaries.DigSig.Result
      description: Cb's decision after checking this binary's Digital Signature
    - contextPath: Process.Parent.PID
      description: The parent Process PID
    - contextPath: Process.Binaries.MD5
      description: Binary MD5
    - contextPath: Process.CrossProc.OtherProcessBinary
      description: Other process binary
    - contextPath: Process.Registry.Time
      description: Registry time
    - contextPath: Process.Modules.Time
      description: Module time
    description: Retrieve all process events for a given process segmented by segment ID
  - name: cb-quarantine-device
    arguments:
    - name: sensor
      required: true
      default: true
      description: the sensor ID to quarantine
    outputs:
    - contextPath: Endpoint.LastAction
      description: Endpoint Actions
    important:
    - contextPath: Endpoint(val.LastAction)
      description: Endpoint Actions
      related: ""
    description: Isolate the endpoint from the network
  - name: cb-sensor-info
    arguments:
    - name: sensor
      default: true
      description: the sensor id
    - name: ip
      description: returns the sensor registration(s) with specified IP address
    - name: hostname
      description: returns the sensor registration(s) with matching hostname
    - name: groupid
      description: returns the sensor registration(s) in the specified sensor group id
    outputs:
    - contextPath: CbResponse.Sensors.Status
      description: Sensor Status
    - contextPath: CbResponse.Sensors.LastUpdate
      description: Sensor Last Updated
    - contextPath: CbResponse.Sensors.Uptime
      description: The Sensor uptime
    - contextPath: CbResponse.Sensors.SupportsCbLive
      description: Sensor Support CB Live
    - contextPath: CbResponse.Sensors.Notes
      description: Sensor Notes
    - contextPath: CbResponse.Sensors.Hostname
      description: Sensor Hostname
    - contextPath: CbResponse.Sensors.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sensors.Isolated
      description: Sensor Isolated
    - contextPath: CbResponse.Sensors.IPAddresses
      description: Sensor IP Addresses
    - contextPath: CbResponse.Sensors.OS
      description: Sensor OS
    description: Display information about the given sensor
  - name: cb-unblock-hash
    arguments:
    - name: md5hash
      required: true
      description: the blacklisted hash
    - name: text
      required: true
      description: text description of blacklist
    outputs:
    - contextPath: File.LastAction
      description: Last action taken on this file
    important:
    - contextPath: File(val.LastAction)
      description: File Actions
      related: ""
    description: Unblocking hash
  - name: cb-unquarantine-device
    arguments:
    - name: sensor
      required: true
      default: true
      description: the sensor ID to quarantine
    outputs:
    - contextPath: Endpoint.LastAction
      description: Endpoint Actions
    important:
    - contextPath: Endpoint(val.LastAction)
      description: Endpoint Actions
      related: ""
    description: Unquarantine the endpoint
  - name: cb-version
    arguments: []
    description: Display the CarbonBlack version
  - name: cb-watchlist-del
    arguments:
    - name: watchlist-id
      required: true
      description: Watchlist ID
    description: Delete a watchlist in Carbon black Response.
  - name: cb-watchlist-get
    arguments:
    - name: watchlist-id
      default: true
      description: Watchlist ID
    outputs:
    - contextPath: CbResponse.Watchlists.LastHit
      description: Watchlist last hit
    - contextPath: CbResponse.Watchlists.TotalHits
      description: Watchlist Total hits
    - contextPath: CbResponse.Watchlists.SearchQuery
      description: Cb search query used for the watchlist.
    - contextPath: CbResponse.Watchlists.Name
      description: Watchlist Name
    - contextPath: CbResponse.Watchlists.Enabled
      description: Watchlist is enabled
    - contextPath: CbResponse.Watchlists.LastHitCount
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.DateAdded
      description: Watchlist Date added
    - contextPath: CbResponse.Watchlists.SearchTimestamp
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.CbWatchlistID
      description: Watchlist ID
    description: Retrieve info for a watchlist in Carbon black Response.
  - name: cb-watchlist-new
    arguments:
    - name: search-query
      required: true
      description: the raw Carbon Black query that this watchlist matches
    - name: name
      required: true
      description: name of this watchlist
    outputs:
    - contextPath: CbResponse.Watchlists.LastHit
      description: Watchlist last hit
    - contextPath: CbResponse.Watchlists.TotalHits
      description: Watchlist Total hits
    - contextPath: CbResponse.Watchlists.SearchQuery
      description: Cb search query used for the watchlist.
    - contextPath: CbResponse.Watchlists.Name
      description: Watchlist Name
    - contextPath: CbResponse.Watchlists.Enabled
      description: Watchlist is enabled
    - contextPath: CbResponse.Watchlists.LastHitCount
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.DateAdded
      description: Watchlist Date added
    - contextPath: CbResponse.Watchlists.SearchTimestamp
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.CbWatchlistID
      description: Watchlist ID
    description: Create a new watchlist in Carbon black Response.
  - name: cb-watchlist-set
    arguments:
    - name: watchlist-id
      required: true
      description: Watchlist ID
    - name: search-query
      description: the raw Carbon Black query that this watchlist matches
    - name: name
      description: name of this watchlist
    - name: indexType
      description: the type of watchlist. Valid values are 'modules' and 'events' for binary and process watchlists, respectively
    description: Modify a watchlist in Carbon black Response.
  - name: cb-alert-update
    arguments:
    - name: uniqueId
      required: true
      description: Alert unique identifier
    - name: status
      required: true
      auto: PREDEFINED
      predefined:
      - Resolved
      - Unresolved
      - In Progress
      - False Positive
      description: 'Updated alert''s status: Resolved,Unresolved,In Progress or False Positive'
    - name: setIgnored
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to stop showing this type of alert
    description: Alert update and resolution
  - name: cb-watchlist
    arguments: []
    outputs:
    - contextPath: CbResponse.Watchlists.LastHit
      description: Watchlist last hit
    - contextPath: CbResponse.Watchlists.TotalHits
      description: Watchlist Total hits
    - contextPath: CbResponse.Watchlists.SearchQuery
      description: Cb search query used for the watchlist.
    - contextPath: CbResponse.Watchlists.Name
      description: Watchlist Name
    - contextPath: CbResponse.Watchlists.Enabled
      description: Watchlist is enabled
    - contextPath: CbResponse.Watchlists.LastHitCount
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.DateAdded
      description: Watchlist Date added
    - contextPath: CbResponse.Watchlists.SearchTimestamp
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.CbWatchlistID
      description: Watchlist ID
    description: Retrieve watchlist in Carbon black Response.
  - name: cb-binary-download
    arguments:
    - name: md5
      required: true
      default: true
      description: MD5 hash of the file.
    - name: summary
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Whether to include the summary.
    outputs:
    - contextPath: File.DigSig.Publisher
      description: The publisher of the digital signature.
    - contextPath: File.InternalName
      description: The internal name.
    - contextPath: File.ServerAddedTimestamp
      description: The timestamp when the server was added.
    - contextPath: File.Name
      description: The binary name.
    - contextPath: File.Extension
      description: The binary extension.
    - contextPath: File.Timestamp
      description: The binary timestamp.
    - contextPath: File.Hostname
      description: The binary hostname.
    - contextPath: File.Description
      description: The binary description.
    - contextPath: File.DigSig.Result
      description: The Carbon Black decision after checking this binary's digital signature.
    - contextPath: File.LastSeen
      description: LThe lst time the binary was seen.
    - contextPath: File.Path
      description: The binary path.
    - contextPath: File.ProductName
      description: The product name.
    - contextPath: File.OS
      description: The OS.
    - contextPath: File.MD5
      description: The MD5 hash of the binary.
    - contextPath: File.Company
      description: Name of the company that released a binary.
    - contextPath: File.DigitalSignature.Publisher
      description: Publisher of the digital signature for the file.
    - contextPath: File.Name
      description: Full filename, for example data.xls.
    - contextPath: File.Signature.OriginalName
      description: The file's original name.
    - contextPath: File.Signature.InternalName
      description: The file's internal name.
    - contextPath: File.Signature.FileVersion
      description: The file version.
    - contextPath: File.Signature.Description
      description: The description of the signature.
    description: Retrieve a binary from CarbonBlack based on hash. Returns a .zip file containing the requested file and it's metadata.
  isfetch: true
  runonce: false
  dockerimage: demisto/python:2.7.18.8715
tests:
- Carbon Black Response Test
