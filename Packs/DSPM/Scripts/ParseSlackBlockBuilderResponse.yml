commonfields:
  id: d93ce82d-4704-4d9a-887e-c8b59d472d74
  version: 18
vcShouldKeepItemLegacyProdMachine: false
name: ParseSlackBlockBuilderResponse
script: |
  from typing import Any
  import traceback
  import urllib.parse
  import requests
  from requests.auth import HTTPBasicAuth
  from datetime import datetime

  CREATE_JIRA_TICKET = "Create a Jira ticket"
  REMEDIATE_RISK = "Remediate a Risk"

  def get_jira_issue_type_id_and_project_name(issue_type_name, project_id) -> str:
      try:
          result = demisto.executeCommand("dspm-get-integration-cofig", {})
          integration_conf = result[0].get("Contents", {}).get("integration_config", {})

          # Extract Jira credentials and URL
          jira_url = integration_conf.get('jiraServerUrl')
          api_key = integration_conf.get('jiraApiToken')
          jiraEmail = integration_conf.get('jiraEmail')

          url = f"https://{jira_url}/rest/api/2/project/{project_id}"
          auth = HTTPBasicAuth(jiraEmail, api_key)
          headers = {
              "Accept": "application/json",
          }

          response = requests.request("GET", url, headers=headers, auth=auth)
          print("get_jira_issue_type_id res: ",response.text)
          res = response.json()
          project_name = res.get("name")
          if response.status_code == 200:
              issue_types = res['issueTypes']
              for issue_type in issue_types:
                  if issue_type['name'] == issue_type_name:
                      issue_type_id = issue_type['id']
                      return str(issue_type_id), str(project_name)

      except Exception as e:
          return_error(f"Error while fetching Jira Issue Type: {str(e)}")

  def parse_slack_block_builder_res():
      try:
          context_data = demisto.get(demisto.context(), 'SlackBlockState')
          if context_data is None:
              raise TypeError("SlackBlockState is None")
          print(context_data)
          if isinstance(context_data, list):
              context_data = context_data[0]
          user_input_data = context_data.get("values")
          if user_input_data is None:
              raise TypeError("values in SlackBlockState is None")

          action_name = user_input_data.get("radio_buttons_0", {}).get("actionId-0", {}).get("selected_option", {}).get("value")
          if action_name is None:
              raise TypeError("selected_option value is None")

          user_email = None
          project_name = None
          ticket_type = None

          if action_name == CREATE_JIRA_TICKET:
              user_email = user_input_data.get("plain_text_input_3", {}).get("plain_text_input-action", {}).get("value")
              project_key = user_input_data.get("static_select_1", {}).get("static_select-action", {}).get("selected_option", {}).get("value")
              ticket_type = user_input_data.get("static_select_2", {}).get("static_select-action", {}).get("selected_option", {}).get("value")

              ticket_type_id, project_name = get_jira_issue_type_id_and_project_name(ticket_type, project_key)
              print("ticket_type_id: ",ticket_type_id)

              demisto.setContext("User.Action", "jira")
              demisto.setContext("User.Email", user_email)
              demisto.setContext("User.JiraProjectName", project_name)
              demisto.setContext("User.JiraTicketTypeID", ticket_type_id)
          elif action_name == REMEDIATE_RISK:
              demisto.setContext("User.Action", 'remediate')
          else:
              raise Exception(f"Sorry!!, this '{action_name}' action type is not supported")

      except TypeError as ex:
          demisto.error(traceback.format_exc())  # log the traceback
          print(traceback.format_exc())
          print("Invalid response found.")
          demisto.setContext("User.Action", 'invalid_response')
      except Exception as ex:
          print(traceback.format_exc())  # log the traceback
          return_error(f'Failed to parse Slack block builder response: {str(ex)}')

  def timeDifferenceInHours(given_timestamp):
      """
        Function will fetch the time difference and
        if the difference is more than 48 hours then
        we will re-open the investigation.
      """
      time_duration = demisto.args().get("time_duration", 48.00)
      given_time = datetime.strptime(given_timestamp, "%Y-%m-%d %H:%M:%S.%f")
      current_time = datetime.now()
      difference = current_time - given_time
      hours_difference = difference.total_seconds() / 3600
      if hours_difference >= time_duration:
          return True
      return False

  def delete_incident_data(args):
      status = ""
      incident_object = args.get("incident_data")
      if isinstance(incident_object, list):
          incident_object = incident_object[0]
      incident_id = incident_object.get("incidentId")
      incident_list = demisto.executeCommand("getList", {"listName": "INCIDENT_LIST2"})
      if (
         incident_list[0].get("Contents") == "null"
         or incident_list[0].get("Contents") is None
         or 'Item not found' in incident_list[0].get("Contents")
      ):
          pass
      else:
          # Check if the value exists in any dictionary
          incident_list = json.loads(incident_list[0].get("Contents"))
          exists = any(data.get("incident_id") == incident_id for data in incident_list)
          differenceInHours = timeDifferenceInHours(incident_object.get("incidentCreated"))
          if exists and differenceInHours:
              # Remove the incident_data with the incident_id
              incident_list = [incident for incident in incident_list if incident["incident_id"] != incident_id]
              delete_incident = demisto.executeCommand("setList", {"listName":"INCIDENT_LIST2","listData": incident_list})
              status = f"Deleted incident data with incident id {incident_id} from the list."
      incident_list = demisto.executeCommand("getList", {"listName": "INCIDENT_LIST2"})
      return status

  ''' MAIN FUNCTION '''

  def main():  # pragma: no cover
      try:
          delete_incident_data(demisto.args())
          parse_slack_block_builder_res()
      except Exception as excep:
          demisto.error(traceback.format_exc())  # print the traceback
          return_error(f'Failed to execute ParseSlackBlockBuilderResponse. Error: {str(excep)}')

  ''' ENTRY POINT '''

  if __name__ in ('__main__', '__builtin__', 'builtins'):  # pragma: no cover
      main()
type: python
tags: []
enabled: true
args:
- name: incident_data
  required: true
  isArray: true
outputs:
- contextPath: User.Email
- contextPath: User.Action
- contextPath: User.JiraProjectName
- contextPath: User.JiraTicketTypeID
scripttarget: 0
subtype: python3
timeout: 362.88ms
pswd: ""
runonce: false
dockerimage: demisto/python3:3.11.9.104657
runas: DBotWeakRole
engineinfo: {}
mainengineinfo: {}