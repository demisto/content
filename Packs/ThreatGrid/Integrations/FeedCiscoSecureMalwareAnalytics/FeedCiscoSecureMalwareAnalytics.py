from typing import List, Dict
import demistomock as demisto
from CommonServerPython import *

# disable insecure warnings
requests.packages.urllib3.disable_warnings()


FEED_NAME = ['dga-dns', 'autorun-registry', 'banking-dns', 'dll-hijacking-dns', 'doc-net-com-dns',
             'downloaded-pe-dns', 'dynamic-dns', 'irc-dns', 'modified-hosts-dns', 'parked-dns',
             'public-ip-check-dns', 'ransomware-dns', 'rat-dns', 'scheduled-tasks', 'sinkholed-ip-dns',
             'stolen-cert-dns']


class Client(BaseClient):

    def __init__(self, api_key, verify, first_fetch, feed_name, feed_tags, tlp_color):
        """Implements class for the feed.

        Args:
            api_key: API Key.
            verify: boolean, if *false* feed HTTPS server certificate is verified. Default: *false*
            first_fetch: The date from which to start fetching feeds
            feed_name: The feed names to fetch
            feed_tags: feed tags.
            tlp_color: Traffic Light Protocol color.
        """
        super().__init__(base_url="https://panacea.threatgrid.com/api/v3/feeds/", verify=verify)
        self.first_fetch = first_fetch
        self.feed_name = feed_name
        self.feed_tags = feed_tags
        self.tlp_color = tlp_color
        self._api_key = api_key
        self._proxies = handle_proxy()

    def get_indicators(self, feed_name: str, time_stamp: Optional[str]):
        """Retrieves all indicators from the feed.

        Args:
            :param feed_name: the feed name to fetch
            :param time_stamp: Optional - fetch feeds only from this day

        """
        suffix = f'{feed_name}_{time_stamp}.json' if time_stamp else f'{feed_name}.json'
        try:
            return self._http_request('GET', suffix, params={"api_key": self._api_key}, timeout=70)
        except Exception as error:
            if 'Unauthorized' in str(error):
                raise DemistoException('Authorization Error: make sure the API Key is correctly set')
            else:
                raise DemistoException(error)


def test_module(client: Client) -> str:
    """Goes through all the code of the fetch.
    Args:
        client: Client object with request

    Returns:
        str: ok.
    """
    if fetch_date_string := demisto.getIntegrationContext().get('last_fetch'):
        client.first_fetch = arg_to_datetime(fetch_date_string)

    fetch_time_stamp = None
    if client.first_fetch and client.first_fetch.date() < dateparser.parse('now', settings={'TIMEZONE': 'UTC'}).date():
        fetch_time_stamp = client.first_fetch.date().isoformat()
    else:
        client.first_fetch = arg_to_datetime('now')

    fetch_indicators(client, fetch_time_stamp)
    return 'ok'


def fetch_indicators(client: Client, fetch_time_stamp: Optional[str], time_to_stop_fetch: Optional[datetime] = None) -> List:
    """Retrieves indicators from the feed

    Args:
        client: Client object with request
        fetch_time_stamp: The date to fetch and in case it is the current day it is None
        time_to_stop_fetch: Time to stop the fetch before it falls on timeout

    Returns:
        List. Processed indicator from feed.
    """

    indicators = []
    domains_map = {}
    for name in client.feed_name:
        if time_to_stop_fetch and dateparser.parse('now', settings={'TIMEZONE': 'UTC'}) > time_to_stop_fetch:
            indicators = ['time_out']
            break
        result = client.get_indicators(feed_name=name, time_stamp=fetch_time_stamp)
        for obj in result:
            feed_related_indicators = [{'type': 'IP', 'value': ip} for ip in obj.get('ips')]
            feed_related_indicators.append({'type': 'File', 'value': obj.get('sample_sha256')})
            current_domain = obj.get('domain')
            if current_domain in domains_map:
                if name not in domains_map[current_domain]['fields']['Tags']:
                    domains_map[current_domain]['fields']['Tags'].append(name)

                domains_map[current_domain]['fields']['FeedRelatedIndicators'].extend(
                    related for related in feed_related_indicators
                    if related not in domains_map[current_domain]['fields']['FeedRelatedIndicators'])

            else:
                domains_map[current_domain] = {
                    "value": current_domain,
                    "type": 'Domain',
                    "rawJSON": obj,
                    "fields": {
                        "Tags": [name],
                        "reportedby": 'CiscoSMA',
                        "FeedRelatedIndicators": feed_related_indicators,
                        "Description": obj.get('description'),
                        "FirstSeenBySource": obj.get('timestamp')
                    }
                }
            if client.tlp_color:
                domains_map[current_domain]['fields']['trafficlightprotocol'] = client.tlp_color
            if client.feed_tags:
                domains_map[current_domain]['fields']['Tags'] += client.feed_tags

            indicators.append({
                "value": obj.get('sample_sha256'),
                "type": 'File',
                "rawJSON": obj,
                "fields": {
                    "Tags": [name],
                    "reportedby": 'CiscoSMA',
                    "Description": obj.get('description'),
                    "FirstSeenBySource": obj.get('timestamp'),
                    "MD5": obj.get('sample_md5'),
                    "SHA1": obj.get('sample_sha1'),
                    "trafficlightprotocol": client.tlp_color
                }
            })
            for ip in obj.get('ips'):
                indicators.append({
                    "value": ip,
                    "type": 'IP',
                    "rawJSON": obj,
                    "fields": {
                        "Tags": [name],
                        "reportedby": 'CiscoSMA',
                        "Description": obj.get('description'),
                        "FirstSeenBySource": obj.get('timestamp')
                    }
                })
    indicators += list(domains_map.values())
    return indicators


def fetch_indicators_command(client: Client, time_to_stop_fetch: datetime = None):
    """Retrieves indicators from the feed

    Args:
        client: Client object with request
        time_to_stop_fetch: Time to stop the fetch before it falls on the docker timeout

    Returns:
        List. Processed indicator from feed.
    """
    current_time_stamp = arg_to_datetime('now')
    current_date = current_time_stamp.date()
    if fetch_date_string := demisto.getIntegrationContext().get('last_fetch'):
        client.first_fetch = arg_to_datetime(fetch_date_string)
    while client.first_fetch.date() <= current_date:
        fetch_time_stamp = None
        if client.first_fetch and client.first_fetch.date() < current_date:
            fetch_time_stamp = client.first_fetch.date().isoformat()
        else:
            client.first_fetch = current_time_stamp

        indicators = fetch_indicators(client, fetch_time_stamp, time_to_stop_fetch)
        if 'time_out' in indicators:
            break
        for iter_ in batch(indicators, batch_size=2000):
            demisto.createIndicators(iter_)
        # Each request returns one day's indicators, so we'll keep the date of the next day in IntegrationContext.
        next_fetch = (dateparser.parse('tomorrow', settings={'RELATIVE_BASE': client.first_fetch}))
        if client.first_fetch.date() < current_date:
            demisto.setIntegrationContext({'last_fetch': next_fetch.isoformat()})
        client.first_fetch = next_fetch
        demisto.debug(f'{len(indicators)} XSOAR Indicators were created.')
    return


def get_indicators_command(client: Client, args: Dict[str, str]) -> CommandResults:
    """Wrapper for retrieving indicators from the feed to the war-room.

    Args:
        client: Client object with request
        args: demisto.args()

    Returns:
        Demisto Outputs.
    """
    if fetch_date_string := demisto.getIntegrationContext().get('last_fetch'):
        client.first_fetch = arg_to_datetime(fetch_date_string)

    fetch_time_stamp = None
    if client.first_fetch and client.first_fetch.date() < arg_to_datetime('now').date():
        fetch_time_stamp = client.first_fetch.date().isoformat()
    else:
        client.first_fetch = arg_to_datetime('now')

    limit = int(args.get('limit', 50))
    indicators = fetch_indicators(client, fetch_time_stamp)

    limit_indicators = indicators[:limit]

    readable_output = tableToMarkdown('CiscoSMA Indicators:', t=limit_indicators, headers=['value', 'type'])
    command_results = CommandResults(
        outputs_prefix='CiscoSMA',
        outputs_key_field='value',
        outputs=limit_indicators,
        readable_output=readable_output,
        raw_response=indicators
    )
    return command_results


def reset_last_run():
    """
    Reset the last run from the integration context
    """
    demisto.setIntegrationContext({})
    return CommandResults(readable_output='Fetch history deleted successfully')


def main():
    """
    PARSE AND VALIDATE FEED PARAMS
    """
    time_to_stop_fetch = arg_to_datetime(arg='in 25 minutes')  # To stop before docker timeout.
    params = demisto.params()
    args = demisto.args()
    api_key = params.get('api_key').get('password')
    if not api_key:
        raise DemistoException('API Key was not given. Please insert your API Key.')
    verify = not params.get('insecure', False)
    feed_name = params.get('feed_name')
    if 'all' in feed_name:
        feed_name = FEED_NAME
    feed_tags = argToList(params.get('feedTags'))
    tlp_color = params.get('tlp_color')
    if not (first_fetch_param := params.get('first_fetch')):
        first_fetch_param = 'today'
    first_fetch = arg_to_datetime(arg=first_fetch_param, arg_name='First fetch')
    command = demisto.command()
    demisto.debug(f'Command being called is: {command}')

    try:
        client = Client(api_key=api_key, verify=verify, feed_name=feed_name, first_fetch=first_fetch,
                        feed_tags=feed_tags, tlp_color=tlp_color)

        if command == 'test-module':
            return_results(test_module(client))

        elif command == 'fetch-indicators':
            fetch_indicators_command(client, time_to_stop_fetch)

        elif command == 'cisco-sma-get-indicators':
            return_results(get_indicators_command(client, args))

        elif command == "cisco-sma-reset-fetch-indicators":
            return_results(reset_last_run())

        else:
            raise NotImplementedError(f'Command "{command}" is not implemented.')

    except Exception as err:
        demisto.log(traceback.format_exc())
        return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(err)}')


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
