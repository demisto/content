category: IT Services
commonfields:
  id: Microsoft Graph Groups
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Server URL
  name: url
  required: true
  type: 0
- display: ID
  name: _auth_id
  required: false
  type: 0
- display: Token
  name: _tenant_id
  required: false
  type: 0
- displaypassword: Key
  name: credentials
  required: false
  type: 9
  hiddenusername: true
- additionalinfo: Used for certificate authentication. As appears in the "Certificates & secrets" page of the app.
  display: Certificate Thumbprint
  name: certificate_thumbprint
  required: false
  type: 4
- additionalinfo: Used for certificate authentication. The private key of the registered certificate.
  display: Private Key
  name: private_key
  required: false
  type: 14
- additionalinfo: Relevant only if the integration is running on Azure VM. If selected, authenticates based on the value provided for the Azure Managed Identities Client ID field. If no value is provided for the Azure Managed Identities Client ID field, authenticates based on the System Assigned Managed Identity. For additional information, see the Help tab.
  display: Use Azure Managed Identities
  name: use_managed_identities
  required: false
  type: 8
- additionalinfo: The Managed Identities client ID for authentication - relevant only if the integration is running on Azure VM.
  displaypassword: Azure Managed Identities Client ID
  name: managed_identities_client_id
  required: false
  hiddenusername: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Use a self-deployed Azure Application
  name: self_deployed
  required: false
  type: 8
- display: Key (received from the admin consent - see Detailed Instructions (?) (Deprecated)
  name: enc_key
  required: false
  type: 4
  hidden: true
  additionalinfo: Use the "Key" parameter instead.
- display: ID (received from the admin consent - see Detailed Instructions (?) (Deprecated)
  name: auth_id
  required: false
  type: 4
  hidden: true
  additionalinfo: Use the "ID" parameter instead
- display: Token (received from the admin consent - see Detailed Instructions (?) (Deprecated) section)
  name: tenant_id
  required: false
  type: 4
  hidden: true
  additionalinfo: Use the "Token" parameter instead.
- display: Suppress Errors for Non Found Groups
  name: handle_error
  required: false
  defaultvalue: 'true'
  type: 8
- display: Application redirect URI (for Authorization Code flow mode)
  name: redirect_uri
  required: false
  type: 0
  section: Connect
- name: creds_auth_code
  type: 9
  displaypassword: Authorization code (for Authorization Code flow mode - received from the authorization step. see Detailed Instructions)
  hiddenusername: true
- display: Authorization code (for Authorization Code flow mode - received from the authorization step. see Detailed Instructions (?) section)
  name: auth_code
  required: false
  type: 4
  hidden: true
  section: Connect
- display: ""
  name: scope
  type: 16
  required: false
  options:
  - Group.Read.All
  - Group.ReadWrite.All
  - GroupMember.Read.All
  - GroupMember.ReadWrite.All
  - Directory.Read.All
  - Directory.ReadWrite.All
description: Microsoft Graph Groups enables you to create and manage different types of groups and group functionality according to your requirements.
display: Azure Active Directory Groups
name: Microsoft Graph Groups
script:
  commands:
  - arguments:
    - default: false
      description: 'Sorts groups in an organization by the field values. For example, displayName.'
      isArray: false
      name: order_by
      required: false
      secret: false
    - default: false
      description: The URL to the next results page.
      isArray: false
      name: next_link
      required: false
      secret: false
    - default: false
      defaultValue: '100'
      description: Sets the page size of the results.
      isArray: false
      name: top
      required: false
      secret: false
    - default: false
      description: 'Filters group results. For example, startswith(displayName,''J''), groupTypes/any(c:c+eq+''Unified'').'
      isArray: false
      name: filter
      required: false
      secret: false
    deprecated: false
    description: Provides a list of groups.
    execution: false
    name: msgraph-groups-list-groups
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, which is unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName, which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: 'Indicates the last time at which the group was synced with the on-premises directory. The Timestamp type represents date and time information using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019 is ''2019-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether this group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox. For example: ["SMTP: example@demisto.com", "smtp: example@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: 'Timestamp of when the group was last renewed, which represents the time and date information using ISO 8601 format. Always in UTC time. For example, midnight UTC on Jan 1, 2019 is ''2019-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Can be: "Private", "Public", or "Hiddenmembership". Blank values are treated as public.'
      type: String
    - contextPath: MSGraphGroupsNextLink.GroupsNextLink
      description: The URL of the next results page.
      type: String
  - arguments:
    - default: false
      description: The ID of the group.
      isArray: false
      name: group_id
      required: true
      secret: false
    deprecated: false
    description: Returns details of a group.
    execution: false
    name: msgraph-groups-get-group
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName, which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: 'Indicates the last time at which the group was synced with the on-premises directory.The Timestamp type represents date and time information using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019 is ''2019-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether the group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox. For example: ["SMTP: example@demisto.com", "smtp: example@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: 'The timestamp of when the group was last renewed. This cannot be modified directly and is only updated via the renew service action. The Timestamp type represents date and time information using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019 is ''2019-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Possible values are: Private, Public, or Hiddenmembership. Blank values are treated as public.'
      type: String
  - arguments:
    - default: false
      description: The display name of the group.
      isArray: false
      name: display_name
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Set to true for mail-enabled groups. False for groups without an email.
      isArray: false
      name: mail_enabled
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
    - default: false
      description: The mail alias for the group.
      isArray: false
      name: mail_nickname
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Set to true for security groups. False for non security groups (regular groups).
      isArray: false
      name: security_enabled
      predefined:
      - 'false'
      - 'true'
      required: true
      secret: false
    deprecated: false
    description: Create a group.
    execution: false
    name: msgraph-groups-create-group
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the group collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group is assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName, which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: 'Indicates the last time at which the group was synced with the on-premises directory.The Timestamp type represents date and time information using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019 is ''2019-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether this group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox. For example, ["SMTP: example@demisto.com", "smtp: example@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: 'Timestamp of when the group was last renewed. This cannot be modified directly and is only updated via the renew service action. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: ''2014-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Possible values are: Private, Public, or Hiddenmembership; blank values are treated as public.'
      type: String
  - arguments:
    - default: false
      description: The group ID.
      isArray: false
      name: group_id
      required: true
      secret: false
    deprecated: false
    description: Deletes a group.
    execution: false
    name: msgraph-groups-delete-group
    outputs:
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.Deleted
      description: Specifies whether the group was deleted.
      type: Boolean
  - arguments:
    - default: false
      description: The group ID.
      isArray: false
      name: group_id
      required: true
      secret: false
    - default: false
      description: The URL for the next results page.
      isArray: false
      name: next_link
      required: false
      secret: false
    - default: false
      defaultValue: '100'
      description: Sets the page size of results.
      isArray: false
      name: top
      required: false
      secret: false
    - default: false
      description: 'Filters members results. For example, startswith(displayName,''user'').'
      isArray: false
      name: filter
      required: false
      secret: false
    deprecated: false
    description: Lists group members.
    execution: false
    name: msgraph-groups-list-members
    outputs:
    - contextPath: MSGraphGroups.Members.BussinessPhones
      description: The telephone numbers for the user.
      type: String
    - contextPath: MSGraphGroups.Members.GivenName
      description: The given name (first name) of the user.
      type: String
    - contextPath: MSGraphGroups.Members.MobilePhone
      description: The primary mobile telephone number for the user.
      type: String
    - contextPath: MSGraphGroups.Members.DisplayName
      description: |-
        The name displayed in the address book for the user.
        Usually the combination of the user's first name, middle initial and last name.
      type: String
    - contextPath: MSGraphGroups.Members.UserPrincipalName
      description: |-
        The user principal name (UPN) of the user.
        The UPN is an Internet-style login name for the user based on the Internet standard RFC 822.
        By convention, this should map to the user's email name.
        The general format is alias@domain, where the domain must be present in the tenant’s collection of verified domains.
      type: Unknown
    - contextPath: MSGraphGroups.Members.OfficeLocation
      description: The office location in the user's place of business.
      type: String
    - contextPath: MSGraphGroups.Members.Mail
      description: The SMTP address for the user. For example, "jeff@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroups.Members.PreferredLanguage
      description: The preferred language for the user. Should follow ISO 639-1 Code. For example, "en-US".
      type: String
    - contextPath: MSGraphGroups.Members.Surname
      description: The user's surname (family name or last name).
      type: String
    - contextPath: MSGraphGroups.Members.JobTitle
      description: The user’s job title.
      type: String
    - contextPath: MSGraphGroups.Members.ID
      description: The unique identifier for the user.
      type: String
    - contextPath: MSGraphGroups.MembersNextLink
      description: The URL to the next results page.
      type: String
  - arguments:
    - default: false
      description: The group ID.
      isArray: false
      name: group_id
      required: true
      secret: false
    - default: false
      description: The user ID.
      isArray: false
      name: user_id
      required: true
      secret: false
    deprecated: false
    description: Add a member to a group.
    execution: false
    name: msgraph-groups-add-member
  - arguments:
    - default: false
      description: The group ID.
      isArray: false
      name: group_id
      required: true
      secret: false
    - default: false
      description: The user ID.
      isArray: false
      name: user_id
      required: true
      secret: false
    deprecated: false
    description: Removes a member from a group.
    execution: false
    name: msgraph-groups-remove-member
  - description: Generate the login url used for Authorization code flow.
    execution: false
    name: msgraph-groups-generate-login-url
    arguments: []
  dockerimage: demisto/crypto:1.0.0.48652
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >
    register_module_line('Microsoft Graph Groups', 'start', __line__())

    from typing import Dict, Tuple, Optional, Any


    import urllib3



    # Disable insecure warnings


    urllib3.disable_warnings()


    INTEGRATION_CONTEXT_NAME = 'MSGraphGroups'

    NO_OUTPUTS: dict = {}

    APP_NAME = 'ms-graph-groups'



    def camel_case_to_readable(text: str) -> str:
        """'camelCase' -> 'Camel Case'

        Args:
            text: the text to transform

        Returns:
            A Camel Cased string.
        """
        if text == 'id':
            return 'ID'
        return ''.join(' ' + char if char.isupper() else char.strip() for char in text).strip().title()


    def parse_outputs(groups_data: Dict[str, str]) -> Tuple[dict, dict]:
        """Parse group data as received from Microsoft Graph API into Demisto's conventions

        Args:
            groups_data: a dictionary containing the group data

        Returns:
            A Camel Cased dictionary with the relevant fields.
            groups_readable: for the human readable
            groups_outputs: for the entry context
        """
        # Unnecessary fields, dropping as to not load the incident context.
        fields_to_drop = ['@odata.context', '@odata.nextLink', '@odata.deltaLink', '@odata.type', '@removed',
                          'resourceProvisioningOptions', 'securityIdentifier', 'onPremisesSecurityIdentifier',
                          'onPremisesNetBiosName', 'onPremisesProvisioningErrors', 'onPremisesSamAccountName',
                          'resourceBehaviorOptions', 'creationOptions', 'preferredDataLocation']
        if isinstance(groups_data, list):
            groups_readable, groups_outputs = [], []
            for group_data in groups_data:
                group_readable = {camel_case_to_readable(i): j for i, j in group_data.items() if i not in fields_to_drop}
                if '@removed' in group_data:
                    group_readable['Status'] = 'deleted'
                groups_readable.append(group_readable)
                groups_outputs.append({k.replace(' ', ''): v for k, v in group_readable.copy().items()})

            return groups_readable, groups_outputs

        group_readable = {camel_case_to_readable(i): j for i, j in groups_data.items() if i not in fields_to_drop}
        if '@removed' in groups_data:
            group_readable['Status'] = 'deleted'
        group_outputs = {k.replace(' ', ''): v for k, v in group_readable.copy().items()}

        return group_readable, group_outputs


    class MsGraphClient:
        """
          Microsoft Graph Mail Client enables authorized access to a user's Office 365 mail data in a personal account.
          """

        def __init__(self, tenant_id, auth_id, enc_key, app_name, base_url, verify, proxy,
                     self_deployed, handle_error, scope=None, redirect_uri=None, auth_code=None,
                     certificate_thumbprint: Optional[str] = None, private_key: Optional[str] = None,
                     managed_identities_client_id: Optional[str] = None):
            grant_type = AUTHORIZATION_CODE if auth_code and redirect_uri else CLIENT_CREDENTIALS
            resource = None if self_deployed else ''
            if scope:
                scope = ' '.join(scope)
            self.ms_client = MicrosoftClient(tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key, app_name=app_name,
                                             base_url=base_url, verify=verify, proxy=proxy, self_deployed=self_deployed,
                                             redirect_uri=redirect_uri, auth_code=auth_code, grant_type=grant_type,
                                             resource=resource, certificate_thumbprint=certificate_thumbprint,
                                             private_key=private_key, scope=scope
                                             managed_identities_client_id=managed_identities_client_id,
                                             managed_identities_resource_uri=Resources.graph)
            self.handle_error = handle_error

        def test_function(self):
            """Performs basic GET request to check if the API is reachable and authentication is successful.

            Returns:
                ok if successful.
            """
            self.ms_client.http_request(method='GET', url_suffix='groups', params={'$orderby': 'displayName'})
            demisto.results('ok')

        def list_groups(self, order_by: str = None, next_link: str = None, top: int = None, filter_: str = None):
            """Returns all groups by sending a GET request.

            Args:
                order_by: the group fields to order by the response.
                next_link: the link for the next page of results, if exists. see Microsoft documentation for more details.
                    docs.microsoft.com/en-us/graph/api/group-list?view=graph-rest-1.0
                top: sets the page size of results.
                filter_: filters results.
            Returns:
                Response from API.
            """
            if next_link:  # pagination
                return self.ms_client.http_request(method='GET', full_url=next_link)
            # default value = 100
            params = {'$top': top}
            if order_by:
                params['$orderby'] = order_by  # type: ignore
            if filter_:
                params['$filter'] = filter_  # type: ignore
            return self.ms_client.http_request(
                method='GET',
                url_suffix='groups',
                params=params)

        def get_group(self, group_id: str) -> Dict:
            """Returns a single group by sending a GET request.

            Args:
                group_id: the group id.

            Returns:
                Response from API.
            """
            group = self.ms_client.http_request(method='GET', url_suffix=f'groups/{group_id}')
            return group

        def create_group(self, properties: Dict[str, Optional[Any]]) -> Dict:
            """Create a single group by sending a POST request.

            Args:
                properties: the group properties.

            Returns:
                Response from API.
            """
            group = self.ms_client.http_request(method='POST', url_suffix='groups', json_data=properties)
            return group

        def delete_group(self, group_id: str):
            """Delete a single group by sending a DELETE request.

            Args:
                group_id: the group id to delete.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            #  Using resp_type="text" to avoid parsing error in the calling method.
            self.ms_client.http_request(method='DELETE', url_suffix=f'groups/{group_id}', resp_type="text")

        def list_members(self, group_id: str, next_link: str = None, top: int = None, filter_: str = None):
            """List all group members by sending a GET request.

            Args:
                group_id: the group id to list its members.
                next_link: the link for the next page of results, if exists. see Microsoft documentation for more details.
                    docs.microsoft.com/en-us/graph/api/group-list-members?view=graph-rest-1.0
                top: sets the page size of results.
                filter_: filters results.
            Returns:
                Response from API.
            """
            if next_link:  # pagination
                return self.ms_client.http_request(method='GET', full_url=next_link)
            params = {'$top': top}
            if filter_:
                params['$filter'] = filter_  # type: ignore

            return self.ms_client.http_request(
                method='GET',
                url_suffix=f'groups/{group_id}/members',
                params=params)

        def add_member(self, group_id: str, properties: Dict[str, str]):
            """Add a single member to a group by sending a POST request.
            Args:
                group_id: the group id to add the member to.
                properties: the member properties.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            #  Using resp_type="text" to avoid parsing error in the calling method.
            self.ms_client.http_request(
                method='POST',
                url_suffix=f'groups/{group_id}/members/$ref',
                json_data=properties,
                resp_type="text")

        def remove_member(self, group_id: str, user_id: str):
            """Remove a single member to a group by sending a DELETE request.
            Args:
                group_id: the group id to add the member to.
                user_id: the user id to remove.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            #  Using resp_type="text" to avoid parsing error in the calling method.
            self.ms_client.http_request(
                method='DELETE',
                url_suffix=f'groups/{group_id}/members/{user_id}/$ref', resp_type="text")


    def suppress_errors_with_404_code(func):
        def wrapper(client: MsGraphClient, args: Dict):
            try:
                return func(client, args)
            except NotFoundError:
                if client.handle_error:
                    human_readable = f'#### Group id -> {args.get("group_id")} does not exist'
                    return human_readable, None, None
                raise
        return wrapper


    def test_function_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Performs a basic GET request to check if the API is reachable and authentication is successful.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Tuple.
        """
        client.test_function()
        return 'ok', {}, {}


    def list_groups_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Lists all groups and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        order_by = args.get('order_by')
        next_link = args.get('next_link')
        top = args.get('top')
        filter_ = args.get('filter')
        groups = client.list_groups(order_by, next_link, top, filter_)

        groups_readable, groups_outputs = parse_outputs(groups['value'])

        next_link_response = ''
        if '@odata.nextLink' in groups:
            next_link_response = groups['@odata.nextLink']

        if next_link_response:
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}NextLink': {'GroupsNextLink': next_link_response},
                             f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': groups_outputs}
            title = 'Groups (Note that there are more results. Please use the next_link argument to see them. The value ' \
                    'can be found in the context under MSGraphGroupsNextLink.GroupsNextLink): '
        else:
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': groups_outputs}
            title = 'Groups:'

        human_readable = tableToMarkdown(name=title, t=groups_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail'],
                                         removeNull=True)

        return human_readable, entry_context, groups


    @suppress_errors_with_404_code

    def get_group_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get a group by group id and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        group = client.get_group(group_id)

        group_readable, group_outputs = parse_outputs(group)
        human_readable = tableToMarkdown(name="Groups:", t=group_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail',
                                                  'Security Enabled', 'Visibility'],
                                         removeNull=True)
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(obj.ID === {group_id})': group_outputs}
        return human_readable, entry_context, group


    def create_group_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Create a group and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        required_properties = {
            'displayName': str(args.get('display_name')),
            'mailNickname': str(args.get('mail_nickname')),
            'mailEnabled': args.get('mail_enabled') == 'true',
            'securityEnabled': args.get('security_enabled')
        }

        # create the group
        group = client.create_group(required_properties)

        # display the new group and it's properties
        group_readable, group_outputs = parse_outputs(group)
        human_readable = tableToMarkdown(name=f"{required_properties['displayName']} was created successfully:",
                                         t=group_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail',
                                                  'Security Enabled', 'Mail Enabled'],
                                         removeNull=True)
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_outputs}
        return human_readable, entry_context, group


    @suppress_errors_with_404_code

    def delete_group_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Delete a group by group id and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        client.delete_group(group_id)

        # get the group data from the context
        group_data = demisto.dt(demisto.context(), f'{INTEGRATION_CONTEXT_NAME}(val.ID === "{group_id}")')
        if isinstance(group_data, list):
            group_data = group_data[0]

        # add a field that indicates that the group was deleted
        group_data['Deleted'] = True  # add a field with the members to the group
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}

        human_readable = f'Group: "{group_id}" was deleted successfully.'
        return human_readable, entry_context, NO_OUTPUTS


    @suppress_errors_with_404_code

    def list_members_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """List a group members by group id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        next_link = args.get('next_link')
        top = args.get('top')
        filter_ = args.get('filter')
        members = client.list_members(group_id, next_link, top, filter_)

        if not members['value']:
            human_readable = f'The group {group_id} has no members.'
            return human_readable, NO_OUTPUTS, NO_OUTPUTS

        members_readable, members_outputs = parse_outputs(members['value'])

        # get the group data from the context
        group_data = demisto.dt(demisto.context(), f'{INTEGRATION_CONTEXT_NAME}(val.ID === "{group_id}")')
        if not group_data:
            return_error('Could not find group data in the context, please run "!msgraph-groups-get-group" to retrieve group data.')
        if isinstance(group_data, list):
            group_data = group_data[0]

        if '@odata.nextLink' in members:
            next_link_response = members['@odata.nextLink']
            group_data['Members'] = members_outputs  # add a field with the members to the group
            group_data['MembersNextLink'] = next_link_response
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}
            title = f'Group {group_id} members ' \
                    f'(Note that there are more results. Please use the next_link argument to see them. The value can be ' \
                    f'found in the context under {INTEGRATION_CONTEXT_NAME}.MembersNextLink): '
        else:
            group_data['Members'] = members_outputs  # add a field with the members to the group
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}
            title = f'Group {group_id} members:'

        human_readable = tableToMarkdown(name=title, t=members_readable,
                                         headers=['ID', 'Display Name', 'Job Title', 'Mail'],
                                         removeNull=True)

        return human_readable, entry_context, members


    @suppress_errors_with_404_code

    def add_member_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Add a member to a group by group id and user id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        user_id = str(args.get('user_id'))
        required_properties = {
            "@odata.id": f'https://graph.microsoft.com/v1.0/users/{user_id}'}
        client.add_member(group_id, required_properties)

        human_readable = f'User {user_id} was added to the Group {group_id} successfully.'
        return human_readable, NO_OUTPUTS, NO_OUTPUTS


    @suppress_errors_with_404_code

    def remove_member_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Remove a member from a group by group id and user id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        user_id = str(args.get('user_id'))
        client.remove_member(group_id, user_id)

        human_readable = f'User {user_id} was removed from the Group "{group_id}" successfully.'
        return human_readable, NO_OUTPUTS, NO_OUTPUTS


    def main():
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params: dict = demisto.params()
        base_url = params.get('url', '').rstrip('/') + '/v1.0/'
        tenant = params.get('tenant_id') or params.get('_tenant_id')
        auth_and_token_url = params.get('auth_id') or params.get('_auth_id')
        enc_key = params.get('enc_key') or (params.get('credentials') or {}).get('password')
        verify = not params.get('insecure', False)
        redirect_uri = params.get('redirect_uri', '')
        auth_code = params.get('creds_auth_code', {}).get('password', '') or params.get('auth_code', '')
        proxy = params.get('proxy')
        handle_error: bool = argToBoolean(params.get('handle_error', 'true'))
        certificate_thumbprint = params.get('certificate_thumbprint')
        private_key = params.get('private_key')
        managed_identities_client_id = get_azure_managed_identities_client_id(params)
        self_deployed: bool = params.get('self_deployed', False) or managed_identities_client_id is not None
        scope = params.get('scope')

        if not managed_identities_client_id:
            if not self_deployed and not enc_key:
                raise DemistoException('Key must be provided. For further information see '
                                       'https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication')
            elif self_deployed and auth_code and not redirect_uri:
                raise DemistoException('Please provide both Application redirect URI and Authorization code '
                                       'for Authorization Code flow, or None for the Client Credentials flow')
            elif not enc_key and not (certificate_thumbprint and private_key):
                raise DemistoException('Key or Certificate Thumbprint and Private Key must be provided.')
            if not auth_and_token_url:
                raise Exception('Authentication ID must be provided.')
            if not tenant:
                raise Exception('Token must be provided.')

        commands = {
            'test-module': test_function_command,
            'msgraph-groups-list-groups': list_groups_command,
            'msgraph-groups-get-group': get_group_command,
            'msgraph-groups-create-group': create_group_command,
            'msgraph-groups-delete-group': delete_group_command,
            'msgraph-groups-list-members': list_members_command,
            'msgraph-groups-add-member': add_member_command,
            'msgraph-groups-remove-member': remove_member_command
        }
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            client: MsGraphClient = MsGraphClient(tenant_id=tenant, auth_id=auth_and_token_url, enc_key=enc_key,
                                                  app_name=APP_NAME, base_url=base_url, verify=verify, proxy=proxy,
                                                  self_deployed=self_deployed, redirect_uri=redirect_uri,
                                                  auth_code=auth_code, handle_error=handle_error,
                                                  certificate_thumbprint=certificate_thumbprint,
                                                  private_key=private_key, scope=scope,
                                                  managed_identities_client_id=managed_identities_client_id)
            if command == 'msgraph-groups-generate-login-url':
                return_results(generate_login_url(client.ms_client))
            else:
                human_readable, entry_context, raw_response = commands[command](client, demisto.args())  # type: ignore
                return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)

        except Exception as err:
            return_error(str(err))



    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402

    # This code was inserted in place of an API module.

    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)

    # pylint: disable=E9010, E9011

    import traceback





    import requests

    import re

    import base64

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    from typing import Dict, Tuple, List, Optional



    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'


    class Resources:
        graph = 'https://graph.microsoft.com/'
        security_center = 'https://api.securitycenter.microsoft.com/'
        management_azure = 'https://management.azure.com/'
        manage_office = 'https://manage.office.com/'


    # authorization types

    OPROXY_AUTH_TYPE = 'oproxy'

    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = 'client_credentials'

    AUTHORIZATION_CODE = 'authorization_code'

    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line

    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'

    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'

    SESSION_STATE = 'session_state'

    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }


    # Azure Managed Identities

    MANAGED_IDENTITIES_TOKEN_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01'

    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = 'SYSTEM_ASSIGNED'



    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: Optional[str] = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     refresh_token_param: Optional[str] = '',
                     auth_code: str = '',
                     scope: str = None,
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: Optional[str] = '',
                     multi_resource: bool = False,
                     resources: List[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: Optional[int] = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     endpoint: str = 'com',
                     certificate_thumbprint: Optional[str] = None,
                     retry_on_rate_limit: bool = False,
                     private_key: Optional[str] = None,
                     managed_identities_client_id: Optional[str] = None,
                     managed_identities_resource_uri: Optional[str] = None,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                refresh_token_param: The refresh token from the integration's parameters (i.e instance configuration).
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            self.endpoint = endpoint
            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token
                self.refresh_token_param = refresh_token_param

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                if scope is None:
                    scope = '{graph_endpoint}/.default',
                    self.scope = scope.format(graph_endpoint=GRAPH_ENDPOINTS[self.endpoint])
                else:
                    self.scope = scope
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: Dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        def is_command_executed_from_integration(self):
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: Optional[str] = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers.update(headers)

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and self.is_command_executed_from_integration():
                self.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(self.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self, resource: str = '', scope: Optional[str] = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource (str): The resource identifier for which the generated token will have access to.
                scope (str): A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            if self.multi_resource:
                access_token = integration_context.get(resource)
            else:
                access_token = integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    for resource_str in self.resources:
                        access_token, expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = 'Error in authentication. Try checking the credentials you entered.'
            try:
                demisto.info('Authentication failure from server: {} {} {}'.format(
                    oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                err_response = oproxy_response.json()
                server_msg = err_response.get('message')
                if not server_msg:
                    title = err_response.get('title')
                    detail = err_response.get('detail')
                    if title:
                        server_msg = f'{title}. {detail}'
                    elif detail:
                        server_msg = detail
                if server_msg:
                    msg += ' Server message: {}'.format(server_msg)
            except Exception as ex:
                demisto.error('Failed parsing error response - Exception: {}'.format(ex))
            raise Exception(msg)

        def _oproxy_authorize_build_request(self, headers: Dict[str, str], content: str,
                                            scope: Optional[str] = None, resource: str = ''
                                            ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

        def _oproxy_authorize(self, resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                # Try to send request to the Oproxy server with the refresh token from the integration parameters
                # (instance configuration).
                # Relevant for cases where the user re-generated his credentials therefore the refresh token was updated.
                if self.refresh_token_param:
                    demisto.error('Error in authentication: Oproxy server returned error, perform a second attempt'
                                  ' authorizing with the Oproxy, this time using the refresh token from the integration'
                                  ' parameters (instance configuration).')
                    content = self.refresh_token_param
                    oproxy_second_try_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

                    if not oproxy_second_try_response.ok:
                        demisto.error('Authentication failure from server (second attempt - using refresh token from the'
                                      ' integration parameters: {} {} {}'.format(oproxy_second_try_response.status_code,
                                                                                 oproxy_second_try_response.reason,
                                                                                 oproxy_second_try_response.text))
                        self._raise_authentication_error(oproxy_response)

                    else:  # Second try succeeded
                        oproxy_response = oproxy_second_try_response

                else:  # no refresh token for a second auth try
                    self._raise_authentication_error(oproxy_response)

            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: Optional[str] = None,
                                     integration_context: Optional[dict] = None
                                     ) -> Tuple[str, int, str]:
            if self.managed_identities_client_id:

                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return '', expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                else:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                          resource)
                        self.resource_to_access_token[resource] = access_token

                    return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: Optional[str] = None,
                                                        resource: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope if scope else self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=self.resource if not resource else resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = (self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED)
                resource = resource or self.managed_identities_resource_uri

                demisto.debug('try to get Managed Identities token')

                params = {'resource': resource}
                if not use_system_assigned:
                    params['client_id'] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={'Metadata': 'True'}).json()
                access_token = response_json.get('access_token')
                expires_in = int(response_json.get('expires_in', 3595))
                if access_token:
                    return access_token, expires_in, ''

                err = response_json.get('error_description')
            except Exception as e:
                err = f'{str(e)}'

            return_error(f'Error in Microsoft authorization with Azure Managed Identities: {err}')

        def _get_token_device_code(
                self, refresh_token: str = '', scope: Optional[str] = None, integration_context: Optional[dict] = None
        ) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        def run_retry_on_rate_limit(self, args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run))

        def handle_error_with_metrics(self, res):
            self.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        def create_api_metrics(self, status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: Optional[str]) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search.group('url') if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def get_azure_managed_identities_client_id(params: dict) -> Optional[str]:
        """"extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get('auth_type') or params.get('authentication_type')
        if params and (argToBoolean(params.get('use_managed_identities') or auth_type == 'Azure Managed Identities')):
            client_id = params.get('managed_identities_client_id', {}).get('password')
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient) -> CommandResults:

        assert client.tenant_id \
            and client.scope \
            and client.client_id \
            and client.redirect_uri, 'Please make sure you entered the Authorization configuration correctly.'

        login_url = f'https://login.microsoftonline.com/{client.tenant_id}/oauth2/v2.0/authorize?' \
                    f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}' \
                    f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}'

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.

    You will be automatically redirected to a link with the following structure:

    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```

    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)

    and paste it in your instance configuration under the **Authorization code** parameter.
        """
        return CommandResults(readable_output=result_msg)

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('Microsoft Graph Groups', 'end', __line__())
  subtype: python3
  type: python
  nativeimage:
  - '8.1'
tests:
- Microsoft Graph Groups - Test
fromversion: 5.0.0
image: data:image/png;base64,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
detaileddescription: "# Authentication\nYou can authenticate either by Azure Active Directory applications or by Azure Managed Identities.\n## Authentication based on Azure Active Directory applications\n\nMicrosoft integrations (Graph and Azure) in Cortex XSOAR use Azure Active Directory applications to authenticate with Microsoft APIs. These integrations use OAuth 2.0 and OpenID Connect standard compliant authentication services, which use an application to sign in or delegate authentication. For more information, see the Microsoft identity platform overview.\n\nThere are two application authentication methods available:\n\n * [Cortex XSOAR Application](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#cortex-xsoar-application)\n * [Self-Deployed Application](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#self-deployed-application)\n\nDepending on the authentication method that you use, the integration parameters might change.\n\nTo allow access to Azure Active Directory Groups, an administrator has to approve the Cortex XSOAR app using an admin consent flow, by clicking this [link](https://oproxy.demisto.ninja/ms-graph-groups).\nAfter authorizing the Cortex XSAOR app, you will get an ID, Token, and Key which needs to be added to the integration instance configuration's corresponding fields.\n\n\n## Authentication Based on Azure Managed Identities\n##### Note: This option is relevant only if the integration is running on Azure VM.\nFollow one of these steps for authentication based on Azure Managed Identities:\n\n- ##### To use System Assigned Managed Identity\n   - Select the **Use Azure Managed Identities** checkbox and leave the **Azure Managed Identities Client ID** field empty.\n\n- ##### To use User Assigned Managed Identity\n   1. Go to [Azure Portal](https://portal.azure.com/) -> **Managed Identities**.\n   2. Select your User Assigned Managed Identity -> copy the Client ID -> paste it in the **Azure Managed Identities Client ID** field in the instance settings.\n   3. Select the **Use Azure Managed Identities** checkbox.\n\nFor more information, see [Managed identities for Azure resources](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview).\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/microsoft-graph-groups)"
