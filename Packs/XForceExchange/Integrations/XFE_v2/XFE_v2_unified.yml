category: Data Enrichment & Threat Intelligence
commonfields:
  id: XFE_v2
  version: -1
configuration:
- defaultvalue: https://api.xforce.ibmcloud.com
  display: Server URL (e.g. https://api.xforce.ibmcloud.com)
  name: url
  required: true
  type: 0
- display: API Key
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: '7'
  display: IP Threshold. Minimum risk score for the IP to be consodered malicious
    (ranges from 1 to 10).
  hidden: false
  name: ip_threshold
  required: false
  type: 0
- defaultvalue: '7'
  display: URL Threshold. Minimum risk score for the URL to be consodered malicious
    (ranges from 1 to 10).
  hidden: false
  name: url_threshold
  required: false
  type: 0
- defaultvalue: '5'
  display: CVE Threshold. Minimum risk score for the URL to be consodered malicious
    (ranges from 1 to 10).
  hidden: false
  name: cve_threshold
  required: false
  type: 0
description: IBM X-Force Exchange lets you receive threat intelligence about applications,
  IP addresses, URls and hashes
detaileddescription: "# Configure API Credentials\r\n\r\nTo configure the credentials\
  \ of IBM X-Force Exchange, you should generate an API key and API password.\r\n\
  In order to generate those keys, you must have an IBM X-Force Exchange Account.\r\
  \nThen, follow the steps below:\r\n\r\n1. Log in to the IBM X-Force Exchange website.\r\
  \n2. Click on the profile icon, and go to Settings.\r\n3. Go to API Access tab,\
  \ and generate an API key.\r\n4. Copy your API key and API password, and enter it\
  \ inside the API key and password fields.\r\n\r\n**Note**: retain the API password\
  \ for your records. You cannot request the API password again.\r\nAlso, provide\
  \ a meaningful name for the API key."
display: IBM X-Force Exchange (v2)
name: XFE_v2
script:
  commands:
  - arguments:
    - default: true
      description: IP to check
      isArray: true
      name: ip
      required: true
      secret: false
    - default: false
      description: 'score treshold '
      isArray: false
      name: threshold
      required: false
      secret: false
    - default: false
      defaultValue: 'false'
      description: Should we return full response
      isArray: false
      name: long
      required: false
      secret: false
    deprecated: false
    description: IP to check
    execution: false
    name: ip
    outputs:
    - contextPath: IP.Address
      description: The IP address
      type: Unknown
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
      type: Unknown
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
      type: Unknown
    - contextPath: IP.Malicious.Score
      description: For malicious IPs, the score from the vendor
      type: Unknown
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: Unknown
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: String
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: Unknown
    - contextPath: DBotScore.Score
      description: The actual score
      type: Unknown
    - contextPath: XFE.IP.Reason
      description: The reason for the given score from X-Force Exchange
      type: String
    - contextPath: XFE.IP.Reasondescription
      description: Additional details of the score's reason
      type: String
    - contextPath: XFE.IP.Subnets
      description: The subnets of the IP
      type: Unknown
  - arguments:
    - default: false
      description: If the score is above the given threshold, will be considered malicious.
        If threshold is not specified, the default URL threshold, as configured in
        the instance settings, will be used.
      isArray: false
      name: threshold
      required: false
      secret: false
    - default: false
      description: Should we return full response with detected malware on the URLs
      isArray: false
      name: long
      required: false
      secret: false
    - default: true
      description: The URL to check
      isArray: true
      name: url
      required: true
      secret: false
    deprecated: false
    description: Check the given URL reputation
    execution: false
    name: url
    outputs:
    - contextPath: URL.Data
      description: The given URL from the user
      type: String
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: String
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: String
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: String
    - contextPath: DBotScore.Score
      description: The actual score
      type: Number
  - arguments:
    - auto: PREDEFINED
      default: true
      description: The file hash md5/sha1/sha256 to check
      isArray: true
      name: file
      predefined:
      - comma seperated optional values
      required: true
      secret: false
    - default: false
      description: Should we return full response
      isArray: false
      name: long
      required: false
      secret: false
    deprecated: false
    description: Check file reputation
    execution: false
    name: file
    outputs:
    - contextPath: File.MD5
      description: The file's MD5
      type: String
    - contextPath: File.SHA1
      description: The file's SHA1
      type: String
    - contextPath: File.SHA256
      description: The file's SHA256
      type: String
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: String
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: String
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: String
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: String
    - contextPath: DBotScore.Score
      description: The actual score
      type: Number
    - contextPath: XFE.File.CnCServers
      description: C&C servers related to the given file
      type: Unknown
    - contextPath: XFE.File.emails
      description: Emails related to the given file
      type: Unknown
    - contextPath: XFE.File.downloadServers
      description: Download servers related to the given file
      type: Unknown
    - contextPath: XFE.File.subjects
      description: Subjects related to the given file
      type: Unknown
    - contextPath: XFE.File.external
      description: Additional information about the given file
      type: Unknown
  - arguments:
    - default: true
      description: The domain to check
      isArray: true
      name: domain
      predefined:
      - ''
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: If the score is above the given threshold, will be considered malicious.
        If threshold is not specified, the default URL threshold, as configured in
        the instance settings, will be used.
      isArray: false
      name: threshold
      predefined:
      - comma seperated optional values
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Should we return full response
      isArray: false
      name: long
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Check domain reputation
    execution: false
    name: domain
    outputs:
    - contextPath: URL.Data
      description: The file's URL
      type: String
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: String
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: String
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: String
    - contextPath: DBotScore.Score
      description: The actual score
      type: Number
  - arguments:
    - auto: PREDEFINED
      default: true
      description: The cve to search for
      isArray: true
      name: cve_id
      predefined:
      - comma seperated optional values
      required: true
      secret: false
    deprecated: false
    description: Search for details about the given CVE
    execution: false
    name: cve-search
    outputs:
    - contextPath: CVE.ID
      description: The ID of the CVE
      type: String
    - contextPath: CVE.CVSS
      description: The CVSS of the CVE
      type: String
    - contextPath: CVE.Published
      description: The date this was published
      type: Date
    - contextPath: CVE.Description
      description: The CVE description
      type: Unknown
    - contextPath: XFE.CVE.Xfdbid
      description: The XFBID of the CVE
      type: String
    - contextPath: XFE.CVE.RiskLevel
      description: The risk level of the CVE
      type: Number
    - contextPath: XFE.CVE.Reported
      description: The reported date of the CVE
      type: Date
    - contextPath: XFE.CVE.Cvss
      description: The CVSS information of the CVE
      type: Unknown
    - contextPath: XFE.CVE.Stdcode
      description: The CVE stdcodes
      type: Unknown
    - contextPath: XFE.CVE.Title
      description: the title of the CVE
      type: String
    - contextPath: XFE.CVE.Description
      description: The description of the CVE
      type: String
    - contextPath: XFE.CVE.PlatformsAffected
      description: The affetcted platforms due to the CVE
      type: Unknown
    - contextPath: XFE.CVE.Exploitability
      description: The exploitability of the CVE.
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: The number of results to return
      isArray: false
      name: limit
      predefined:
      - comma seperated optional values
      required: false
      secret: false
    - default: false
      description: |-
        The start of the date range for searching.
        The format should be YYYY-MM-DDThh:mm:ssZ (e.g. 2016-01-01T00:00:00Z).
      isArray: false
      name: start_date
      required: false
      secret: false
    - default: false
      description: |-
        The end of the date range for searching.
        The format should be YYYY-MM-DDThh:mm:ssZ (e.g. 2016-01-01T00:00:00Z).
      isArray: false
      name: end_date
      required: false
      secret: false
    deprecated: false
    description: Return the latest vulnerabilities found
    execution: false
    name: cve-latest
    outputs:
    - contextPath: CVE.ID
      description: The ID of the CVE
      type: String
    - contextPath: CVE.CVSS
      description: The CVSS of the CVE
      type: String
    - contextPath: CVE.Published
      description: The date this was published
      type: Date
    - contextPath: CVE.Description
      description: The CVE description
      type: Unknown
    - contextPath: XFE.CVE.Xfdbid
      description: The XFBID of the CVE
      type: String
    - contextPath: XFE.CVE.RiskLevel
      description: The risk level of the CVE
      type: Number
    - contextPath: XFE.CVE.Reported
      description: The reported date of the CVE
      type: Date
    - contextPath: XFE.CVE.Cvss
      description: The CVSS information of the CVE
      type: Unknown
    - contextPath: XFE.CVE.Stdcode
      description: The CVE stdcodes
      type: Unknown
    - contextPath: XFE.CVE.Title
      description: the title of the CVE
      type: String
    - contextPath: XFE.CVE.Description
      description: The description of the CVE
      type: String
    - contextPath: XFE.CVE.PlatformsAffected
      description: The affetcted platforms due to the CVE
      type: Unknown
    - contextPath: XFE.CVE.Exploitability
      description: The exploitability of the CVE.
      type: String
  - arguments:
    - default: true
      description: The host or address to search inside X-Force Exchange (e.g. google.com)
      isArray: false
      name: host
      required: true
      secret: false
    deprecated: false
    description: Gets information about the given host address
    execution: false
    name: xfe-whois
    outputs:
    - contextPath: XFE.Whois.Host
      description: The given host from the user.
      type: String
    - contextPath: XFE.Whois.RegistrarName
      description: The domain name registrar of the host.
      type: String
    - contextPath: XFE.Whois.Created
      description: The date the host was created.
      type: Date
    - contextPath: XFE.Whois.Updated
      description: The date the host's information has been updated.
      type: Date
    - contextPath: XFE.Whois.Expires
      description: The date the host will be expired
      type: Date
    - contextPath: XFE.Whois.Email
      description: The contact email of the host owners.
      type: String
    - contextPath: XFE.Whois.Contact
      description: Contact information of the host's organization
      type: Unknown
    - contextPath: Domain.Name
      description: The name of the domain.
      type: String
    - contextPath: Domain.CreationDate
      description: The creation date of the domain.
      type: Date
    - contextPath: Domain.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.UpdatedDate
      description: The date the domain has been updated.
      type: Date
    - contextPath: Domain.Organization
      description: The organizaton which owns the domain.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the domain's registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the domain's registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrar.Name
      description: The name of the domain's registar.
      type: String
    - contextPath: Domain.WHOIS.Registrar.Email
      description: The email of the domain's registar.
      type: String
    - contextPath: Domain.WHOIS.UpdatedDate
      description: The date the domain has been updated.
      type: String
    - contextPath: Domain.WHOIS.ExpirationDate
      description: The date the domain has been updated.
      type: Unknown
    - contextPath: Domain.WHOIS.CreationDate
      description: The creation date of the domain.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Country
      description: The country of the domain's registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Name
      description: The name of the domain's registrant.
      type: String
  - arguments:
    - default: true
      description: |-
        The query for the search.
        (https://exchange.xforce.ibmcloud.com/api/doc/?#Vulnerabilities_get_vulnerabilities_fulltext)
      isArray: false
      name: q
      required: true
      secret: false
    - default: false
      description: |-
        The start of the date range for searching.
        The format should be YYYY-MM-DDThh:mm:ssZ (e.g. 2016-01-01T00:00:00Z).
      isArray: false
      name: start_date
      required: false
      secret: false
    - default: false
      description: |-
        The end of the date range for searching.
        The format should be YYYY-MM-DDThh:mm:ssZ (e.g. 2016-01-01T00:00:00Z).
      isArray: false
      name: end_date
      required: false
      secret: false
    - default: false
      description: |-
        Bookmark used to page through results.
        (https://exchange.xforce.ibmcloud.com/api/doc/?#Vulnerabilities_get_vulnerabilities_fulltext)
      isArray: false
      name: bookmark
      required: false
      secret: false
    deprecated: false
    description: Gets list of all vulnerabilities associated with the search term.
    execution: false
    name: xfe-search-cves
    outputs:
    - contextPath: CVE.ID
      description: The ID of the CVE
      type: String
    - contextPath: CVE.CVSS
      description: The CVSS of the CVE
      type: String
    - contextPath: CVE.Published
      description: The date this was published
      type: Date
    - contextPath: CVE.Description
      description: The CVE description
      type: Unknown
    - contextPath: XFE.CVE.Xfdbid
      description: The XFBID of the CVE
      type: String
    - contextPath: XFE.CVE.RiskLevel
      description: The risk level of the CVE
      type: Number
    - contextPath: XFE.CVE.Reported
      description: The reported date of the CVE
      type: Date
    - contextPath: XFE.CVE.Cvss
      description: The CVSS information of the CVE
      type: Unknown
    - contextPath: XFE.CVE.Stdcode
      description: The CVE stdcodes
      type: Unknown
    - contextPath: XFE.CVE.Title
      description: the title of the CVE
      type: String
    - contextPath: XFE.CVE.Description
      description: The description of the CVE
      type: String
    - contextPath: XFE.CVE.PlatformsAffected
      description: The affetcted platforms due to the CVE
      type: Unknown
    - contextPath: XFE.CVE.Exploitability
      description: The exploitability of the CVE.
      type: String
    - contextPath: XFE.CVESearch.TotalRows
      description: The total rows received after search
      type: String
    - contextPath: XFE.CVESearch.Bookmark
      description: Bookmark used to page through results.
      type: String
  dockerimage: demisto/python3:3.7.4.2245
  feed: false
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: |-
    from typing import Tuple, Dict, Any
    from collections import defaultdict




    XFORCE_URL = 'https://exchange.xforce.ibmcloud.com'
    DEFAULT_THRESHOLD = 7
    DBOT_SCORE_KEY = 'DBotScore(val.Indicator == obj.Indicator && val.Vendor == obj.Vendor)'


    class Client(BaseClient):
        """
        Client for X-Force Exchange RESTful API.

        Args:
              url (str): the URL of X-Force Exchange.
              api_key (str): the API key of X-Force Exchange.
              password (str): password for the API key (required for authentication).
              use_ssl (bool): specifies whether to verify the SSL certificate or not.
              use_proxy (bool): specifies if to use Demisto proxy settings.
        """

        def __init__(self, url: str, api_key: str, password: str, use_ssl: bool, use_proxy: bool):
            super().__init__(url, verify=use_ssl, proxy=use_proxy, headers={'Accept': 'application/json'},
                             auth=(api_key, password))

        def ip_report(self, ip: str) -> dict:
            if not is_ip_valid(ip):
                raise DemistoException('The given IP was invalid')

            return self._http_request('GET', f'/ipr/{ip}')

        def url_report(self, url: str) -> dict:
            return self._http_request('GET', f'/url/{url}').get('result')

        def cve_report(self, code: str) -> dict:
            return self._http_request('GET', f'/vulnerabilities/search/{code}')

        def search_cves(self, q: str, start_date: str, end_date: str, bookmark: str) -> dict:
            params = {'q': q, 'startDate': start_date, 'endDate': end_date, 'bookmark': bookmark}
            params = {key: value for key, value in params.items() if value}
            return self._http_request('GET', '/vulnerabilities/fulltext', params=params)

        def file_report(self, file_hash: str) -> dict:
            return self._http_request('GET', f'/malware/{file_hash}').get('malware')

        def get_recent_vulnerabilities(self, start_date: str, end_date: str, limit: int) -> dict:
            params = {'startDate': start_date, 'endDate': end_date, 'limit': limit}
            params = {key: value for key, value in params.items() if value}
            return self._http_request('GET', '/vulnerabilities', params=params)

        def whois(self, host: str) -> dict:
            return self._http_request('GET', f'/whois/{host}')


    def calculate_score(score: int, threshold: int) -> int:
        """
        Calculates and converts X-Force Exchange score into Demisto score.

        Args:
            score (int): the score from X-Force Exchange for certain indicator (1-10).
            threshold (int): the score threshold configured by the user.

        Returns:
            int - Demisto's score for the indicator
        """

        if score > threshold:
            return 3
        elif score > threshold / 2:
            return 2
        return 1


    def get_cve_results(cve_id: str, report: dict, threshold: int) -> Tuple[str, dict, dict]:
        """
        Formats CVE report from X-Force Exchange into Demisto's outputs.

        Args:
            cve_id (str): the id (code) of the CVE.
            report (dict): the report from X-Force Exchange about the CVE.
            threshold (int): the score threshold configured by the user.

        Returns:
            str: the markdown to display inside Demisto.
            dict: the context to return into Demisto.
            dict: the report from X-Force Exchange (used for debugging).
        """

        outputs = {'ID': cve_id, 'CVSS': report.get('cvss', {}).get('version'),
                   'Published': report.get('reported'),
                   'Description': report.get('description')}
        dbot_score = {'Indicator': cve_id, 'Type': 'cve', 'Vendor': 'XFE',
                      'Score': calculate_score(round(report.get('risk_level', 0)), threshold)}
        additional_headers = ['xfdbid', 'risk_level', 'reported', 'cvss', 'tagname', 'stdcode',
                              'title', 'description', 'platforms_affected', 'exploitability']
        additional_info = {string_to_context_key(field): report.get(field) for field in additional_headers}

        if dbot_score['Score'] == 3:
            outputs['Malicious'] = {'Vendor': 'XFE', 'Description': report.get('description')}

        context = {outputPaths['cve']: outputs,
                   DBOT_SCORE_KEY: dbot_score,
                   f'XFE.{outputPaths["cve"]}': additional_info}

        table_headers = ['title', 'description', 'risk_level', 'reported', 'exploitability']
        table = {'Version': report.get('cvss', {}).get('version'),
                 'Access Vector': report.get('cvss', {}).get('access_vector'),
                 'Complexity': report.get('cvss', {}).get('access_complexity'),
                 'STD Code': '\n'.join(report.get('stdcode', [])),
                 'Affected Platforms': '\n'.join(report.get('platforms_affected', [])),
                 **{string_to_table_header(header): report.get(header) for header in table_headers}
                 }
        markdown = tableToMarkdown(f'X-Force CVE Reputation for {cve_id}\n'
                                   f'{XFORCE_URL}/vulnerability/search/{cve_id}',
                                   table, removeNull=True)

        return markdown, context, report


    def test_module(client: Client) -> str:
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        Args:
            client (Client): X-Force Exchange client.
        Returns:
            str: 'ok' if test passed, anything else will fail the test.
        """

        return 'ok' if client.url_report('google.com') else 'Connection failed.'


    def ip_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        """
        Executes IP enrichment against X-Force Exchange.

        Args:
            client (Client): X-Force client.
            args (Dict[str, str]): the arguments for the command.
        Returns:
            str: human readable presentation of the IP report.
            dict: the results to return into Demisto's context.
            Any: the raw data from X-Force client (used for debugging).
        """

        threshold = int(demisto.params().get('ip_threshold', DEFAULT_THRESHOLD))

        markdown = ''
        context: dict = defaultdict(list)
        reports = []

        for ip in argToList(args.get('ip')):
            report = client.ip_report(ip)
            outputs = {'Address': report['ip'],
                       'Score': report.get('score'),
                       'Geo': {'Country': report.get('geo', {}).get('country', '')}}
            additional_info = {string_to_context_key(field): report[field] for field in
                               ['reason', 'reasonDescription', 'subnets']}
            dbot_score = {'Indicator': report['ip'], 'Type': 'ip', 'Vendor': 'XFE',
                          'Score': calculate_score(report['score'], threshold)}

            if dbot_score['Score'] == 3:
                outputs['Malicious'] = {'Vendor': 'XFE', 'Description': additional_info['Reasondescription']}

            context[outputPaths['ip']].append(outputs)
            context[f'XFE.{outputPaths["ip"]}'].append(additional_info)
            context[DBOT_SCORE_KEY].append(dbot_score)

            table = {'Score': report['score'],
                     'Reason': f'{additional_info["Reason"]}:\n{additional_info["Reasondescription"]}',
                     'Subnets': ', '.join(subnet.get('subnet') for subnet in additional_info['Subnets'])}
            markdown += tableToMarkdown(f'X-Force IP Reputation for: {report["ip"]}\n'
                                        f'{XFORCE_URL}/ip/{report["ip"]}', table, removeNull=True)
            reports.append(report)

        return markdown, context, reports


    def url_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        """
         Executes URL enrichment against X-Force Exchange.

         Args:
             client (Client): X-Force client.
             args (Dict[str, str]): the arguments for the command.
         Returns:
             str: human readable presentation of the URL report.
             dict: the results to return into Demisto's context.
             Any: the raw data from X-Force client (used for debugging).
         """

        urls = argToList(args.get('url', '')) or argToList(args.get('domain', ''))
        threshold = int(demisto.params().get('url_threshold', DEFAULT_THRESHOLD))
        context: Dict[str, Any] = defaultdict(list)
        markdown = ''
        reports = []

        for url in urls:
            report = client.url_report(url)

            outputs = {'Data': report['url']}
            dbot_score = {'Indicator': report['url'], 'Type': 'url', 'Vendor': 'XFE',
                          'Score': calculate_score(report['score'], threshold)}

            if dbot_score['Score'] == 3:
                outputs['Malicious'] = {'Vendor': 'XFE'}

            context[outputPaths['url']].append(outputs)
            context[DBOT_SCORE_KEY].append(dbot_score)

            table = {'Score': report['score'],
                     'Categories': '\n'.join(report['cats'].keys())}
            markdown += tableToMarkdown(f'X-Force URL Reputation for: {report["url"]}\n'
                                        f'{XFORCE_URL}/ip/{report["url"]}', table, removeNull=True)
            reports.append(report)

        return markdown, context, reports


    def cve_search_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        """
         Get details about vulnerabilities (latest / search) from X-Force Exchange.

         Args:
             client (Client): X-Force client.
             args (Dict[str, str]): the arguments for the command.
         Returns:
             str: human readable presentation of the CVEs reports.
             dict: the results to return into Demisto's context.
             Any: the raw data from X-Force Exchange client (used for debugging).
        """

        threshold = int(demisto.params().get('cve_threshold', DEFAULT_THRESHOLD))

        if 'q' in args:
            reports = client.search_cves(args['q'], args.get('start_date', ''), args.get('end_date', ''),
                                         args.get('bookmark', ''))
            reports, total_rows, bookmark = reports['rows'], reports['total_rows'], reports['bookmark']
        else:
            reports = client.get_recent_vulnerabilities(args.get('start_date', ''), args.get('end_date', ''),
                                                        int(args.get('limit', 0)))
            total_rows, bookmark = '', ''

        total_context: Dict[str, Any] = defaultdict(list)
        total_markdown = ''

        for report in reports:
            cve_id = report.get('stdcode', [''])[0]
            markdown, context, _ = get_cve_results(cve_id, report, threshold)

            for key, value in context.items():
                total_context[key].append(value)

            total_markdown += markdown

        if total_rows and bookmark:
            total_context['XFE.CVESearch'] = {'TotalRows': total_rows, 'Bookmark': bookmark}

        return total_markdown, total_context, reports


    def cve_get_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        """
         Executes CVE enrichment against X-Force Exchange.

         Args:
             client (Client): X-Force Exchange client.
             args (Dict[str, str]): the arguments for the command.

         Returns:
             str: human readable presentation of the CVE report.
             dict: the results to return into Demisto's context.
             Any: the raw data from X-Force client (used for debugging).
         """

        threshold = int(demisto.params().get('cve_threshold', DEFAULT_THRESHOLD))
        markdown = ''
        context: Dict[str, Any] = defaultdict(list)
        reports = []

        for cve_id in argToList(args.get('cve_id')):
            report = client.cve_report(cve_id)
            cve_markdown, cve_context, _ = get_cve_results(args['cve_id'], report[0], threshold)

            markdown += cve_markdown
            context[outputPaths['cve']].append(cve_context[outputPaths['cve']])
            context[DBOT_SCORE_KEY].append(cve_context[DBOT_SCORE_KEY])
            context[f'XFE.{outputPaths["cve"]}'].append(cve_context[f'XFE.{outputPaths["cve"]}'])

            reports.append(report)

        return markdown, context, reports


    def file_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        """
        Executes file hash enrichment against X-Force Exchange.

        Args:
            client (Client): X-Force Exchange client.
            args (Dict[str, str]): the arguments for the command.

        Returns:
             str: human readable presentation of the file hash report.
             dict: the results to return into Demisto's context.
             Any: the raw data from X-Force Exchange client (used for debugging).
        """

        context: dict = defaultdict(list)
        markdown = ''
        reports = []

        for file_hash in argToList(args.get('file')):
            report = client.file_report(file_hash)
            hash_type = report['type']

            scores = {'high': 3, 'medium': 2, 'low': 1}

            file_context = build_dbot_entry(args.get('file'), indicator_type=report['type'],
                                            vendor='XFE', score=scores.get(report['risk'], 0))

            if outputPaths['file'] in file_context:
                context[outputPaths['file']].append(file_context[outputPaths['file']])

            if outputPaths['dbotscore'] in file_context:
                context[DBOT_SCORE_KEY].append(file_context[outputPaths['dbotscore']])

            file_key = f'XFE.{outputPaths["file"]}'

            hash_info = {**report['origins'], 'Family': report['family'], 'FamilyMembers': report['familyMembers']}
            context[file_key] = hash_info

            download_servers = ','.join(server['ip'] for server in hash_info.get('downloadServers', {}).get('rows', []))
            cnc_servers = ','.join(server['domain'] for server in hash_info.get('CnCServers', {}).get('rows', []))
            table = {'CnC Servers': cnc_servers, 'Download Servers': download_servers,
                     'Source': hash_info.get('external', {}).get('source'), 'Created Date': report['created'],
                     'Type': hash_info.get('external', {}).get('malwareType')}
            markdown += tableToMarkdown(f'X-Force {hash_type} Reputation for {args.get("file")}\n'
                                        f'{XFORCE_URL}/malware/{args.get("file")}', table, removeNull=True)
            reports.append(report)

        return markdown, context, reports


    def whois_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        """
        Gets information about the given host address.

        Args:
            client (Client): X-Force Exchange client.
            args (Dict[str, str]): the arguments for the command.

        Returns:
             str: human readable presentation of the information about the host.
             dict: the results to return into Demisto's context.
             Any: the raw data from X-Force Exchange client (used for debugging).
        """

        result = client.whois(args['host'])

        contact = [{k.title(): v for k, v in contact.items()} for contact in result.get('contact', [])]
        outputs = {'Host': args['host'], 'RegistrarName': result.get('registrarName'),
                   'Created': result.get('createdDate'), 'Updated': result.get('updatedDate'),
                   'Expires': result.get('expiresDate'), 'Email': result.get('contactEmail'),
                   'Contact': contact}

        domain = {'Name': args['host'], 'CreationDate': outputs['Created'],
                  'ExpirationDate': outputs['Expires'], 'UpdatedDate': outputs['Updated'],
                  'Organization': contact[0]['Organization'] if contact else '',
                  'Registrant': {'Country': contact[0]['Country'] if contact else '',
                                 'Name': contact[0]['Organization'] if contact else ''},
                  'WHOIS': {'Registrar': {'Name': result.get('registrarName'),
                                          'Email': result.get('contactEmail')
                                          },
                            'UpdatedDate': outputs['Updated'], 'ExpirationDate': outputs['Expires'],
                            'CreationDate': outputs['Created']
                            }
                  }

        domain['WHOIS']['Registrant'] = domain['Registrant']  # type: ignore

        context = {outputPaths['domain']: domain, 'XFE.Whois(obj.Host==val.Host)': outputs}
        markdown = tableToMarkdown(f'X-Force Whois result for {args["host"]}', outputs, removeNull=True)

        return markdown, context, result


    def main():
        params = demisto.params()
        credentials = params.get('credentials')

        client = Client(params.get('url'),
                        credentials.get('identifier'), credentials.get('password'),
                        use_ssl=not params.get('insecure', False),
                        use_proxy=params.get('proxy', False))
        commands = {
            'ip': ip_command,
            'url': url_command,
            'domain': url_command,
            'cve-latest': cve_search_command,
            'cve-search': cve_get_command,
            'file': file_command,
            'xfe-whois': whois_command,
            'xfe-search-cves': cve_search_command
        }

        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            if command == 'test-module':
                demisto.results(test_module(client))
            elif command in commands:
                return_outputs(*commands[command](client, demisto.args()))
            else:
                return_error('Command not found.')
        except Exception as e:
            return_error(f'Failed to execute {command} command. Error: {e}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhQAAAKeCAYAAAD9UYJbAAAhHUlEQVR42u3dv05c2ZpAcV7ivsYkt9+hMz+BM2cTOOpgEjJnl8TOnDkhsOTEmQMyS5a6dY2wetoCqyQsEINtoKD4DxMwsw+my9gYqursU2efvX9LWi+AofbyqW9/Z2YGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC0zPrx+eMPB6cXLz/tV872ti/+87/7F88+Hly8WD+6WOyfXiwPzi78pAAAKJwQDG/6R1UwPF3braLh1z83L/5j6X9u9B+/f7mYebN1o7/9tXfxaGVQxcarzWOxAQBAzk8ZHq5s/TQY7vK2oLjNe293quDwdAMAgEyeMtRx0qC4y5uebqwdnj/3rwsAQMRguHrKML8xqP2UIcWgGOXpxpPevqcbAACM+pRhbrXf6FOGrgXFKE83gp5uAAA8ZeiIKQaFpxsAgOyiYWHr8NpThq4FQ25BcZcP3u3+/XQj6OkGAGAqwbC0d3LtKcP995+zi4aSguI2f/lj+9rTjddfTjzdAAB4yiAoPN0AADTwlOHqimVpTxkExfSeblxdhfV0AwA6xtUip6unDCEYPGUQFKk+3bha9BViQ3AAgKcMgoKebgCApwwUFN19uuEqLIDinzJMa100BUVJekkbgCyfMsR6KRUFBeMt+vJ0A4CnDBQU9HQDQPeCIYd10RQUtMYcwBSfMqT8UioKCqb/dMNL2gBPGUhBQU83ANHw47poTxkoKNjFpxvWmAMNB0PpL6WioGDZi768pA2o8ZTBAUZBQXpJG+ApAwUF6ekGMB7WRVNQkF7SBoz9lMFLqSgoSC9pAzxlIAUF6ekG6j1l+H5dtKcMpKAgm3q6YY15x58yeCkVKShIL2nD2E8ZLHIiBQXpJW34IRg8ZSAFBUlPN8Z6ymBdNCkoSHpJ29iEiPDhTAoKktOJDEFBUlCQFBSCghQUJAWFoCApKEhBIShICgpSUAgKkoKCpKAQFKSgICkoBAVJQUEKCkFBUlCQFBQkBQVJQSEoSEFBUlAICpKCghQUgoKkoCApKEgKCpKCQlCQgoKkoBAUJAUFKSgEBUlBQVJQkBQUJAWFoCAFBUlBIShICgpSUAgKkoKCpKAgKShICgpBQQoKkoJCUJAUFKSgEBQkBQVJQUFSUJAUFIKCFBQkBYWgICkoSEEhKEgKCpKCgqSgICkoBAUpKEgKCkFBUlCQgkJQkBQUJAUFSUFBUlAIClJQkBQUgoKkoCAFhaAgKShICgqSgoKkoBAUpKAgKSgEBUlBQQoKQUFSUJAUFCQFBUlBIShIQUFSUAgKkoKCFBSCgqSgICkoSAoKkoJCUJCCgqSgEBQkBQUpKAQFSUFBUlCQFBQkBYWgIAUFSUEhKEgKClJQCAqSgoKkoCApKEgKCkFBCgqSgkJQkBQUpKAQFCQFBUlBQVJQkBQUgoIUFCQFhaAgKShIQSEoSAoKkoKCpKAgKSgEBSkoSAoKQUFSUJCCQlCQFBQkBQVJQUFSUAgKUlCQFBSCgqSgIAWFoCApKEgKCpKCgqSgEBSkoCApKAQFSUFBCgpBQVJQkBQUPpxJQUFSUAgKUlCQFBSCgqSgIAWFoCApKEgKCh/OpKAgKSgEBSkoSAoKQUFSUJCCQlCQFBQkBYWgIAUFSUEhKEhBQVJQCAqSgoIUFIKCpKAgKSgEBSkoSAoKQUEKCpKCQlCQFBSkoBAUJAUFSUEhKEhBQVJQCApSUJAUFIKCpKAgBYWgICkoSAoKQUEKCpKCQlCQgsIHNCkoBAVJQUEKCkFBUlCQFBSCghQUJAWFoCAFhQ9oUlAICpKCghQUgoKkoCApKAQFKShICgpBQQoKQUEKCkFBUlCQgkJQkBQUJAWFoCAFBUlBIShICgpSUAgKXnO2t53vL1gmCIrRXB6c+V1OmBfrRw51QSEoBAUEhaCAoBAUgoKCQlAICggKQSEoKCgEhaAQFIKCgkJQCAoICkEhKASFoBAUeftwZcuHsKDIIigW+6d+lxPmSW/foS4oBEUp3n//uXpiMb8xuHjTP/Lh3CILW4dV7Lk2Op733u5cPPt44He3RULYhacR4fB68G7XQS4oBAWHkfF0bfdiae/Eh/QUCD9reyjifXj6GqR51g7Pn4eIEw+CQlBwrLgI/2Y+Qv0tdGmx1aOVgd/ZBnj95URECAofoqznr39uXoRH8j5S45DyVxu5bMr85Y/ti/A/ab9t9QlPfcJXSw5oQSEo6IaImChy9baoqE81n+JgFhSCgm6JpEUIMu/ymH5U+M2bDLc0BIWgoKhIkHCLxsvB2rE6GCEmBIWgoKjIgTDgKihaFGJCUAgKioqus358/tjry9v11eax31UxISgEBQ1q+rpDUPjao2msyhYUgoKtG5Yz+TjO+/e+60GR9QdrBMKOCQewoPDByiS0AEtQ+GDtJtV2UYevoPDBypT0PhBB4YO1W4Q9HdXVWoevoPDBytQ2aoYBRB/T1wnvRREU7eoFYjdjlbagEBRMOip8TP9I+LkIiva0MfNHqsPGoSsoBAVdJ+0WXXmraI5BUb2HAtewUltQCAq6+dFhBEU7VjcY8DdudAgKQUFDmp5SCApPJwxhUlAIijI1pJnHU4quBoWnE9fxGnJBIShoSNPfgKDwYWoIk/4GBIUhTR/nQ7r4orAuBoWbHYYwBYWgYIbObwxExVc+HJwKioat3kuBisX+qcNVUAgKGtLMlRBYgqIZq2VNMIRJQUGbNH31ISh81REHmzAFhaCgeYoCCHElKOL6avPY79dXqle2O1QFhaCgpVdlsLB1KCgi+WjFnM4VVVg5UAWFoGAJhoPUx/4lc6t9QWGBVdS5CYcpBQUtvTJPISjMTdTC8ioKChZnOER9/A/nKVJ+I2nKQWEb5pDqax8HKQUFS3S2t+0w+Eq4VisoxrMaPERFtXvDIUpBwZINvxeOg0tSfYFYikFh38SQ5cGZA5SCggwu7XlsfUW4Wisobrda1oS/sbyKgoL0ErEbSW2eIrWgqNZJo8LyKgoK0tKrn5La+z5SCgrv6RjipV8UFKSlV536e0klKLySfEh1u8WhSUFBeonYKKSy9CqFoLC8aoiXflFQCAp6idjYpLD0KoWgsLzK3AQFhaCgpVc1SGHpVdtBYXnVEMurKCgEBcc0PO53fFzS9tKrNoPC8qohXvpFQSEo6CVitWlz6VVbQWF51fW5CYckBYWgYA3DFUrHySVtLb1qIygsr7qOIUwKCkFBS6+i0sY8RRtBYXnVkOpgcEBSUAgKWnoVkzaWXk07KKqFTaiwvIqCQlAwsvMbA4dMS39L0wwKy6uGVE9pHIz0tyQo6CViTRJe/Z5bUJibMDdBQSEoaOlVC0xr6dW0gsLyqiGWV1FQCAqap5gaIa5yCYpqxwIqqt0bDkQKCkFBLxGbJtNYetV0UFheNcRLvygoBAUtvWqNppdeNRkUllcNsbyKgkJQsCXNUwxpculVU0ERhg7NTQyp3qjqIKSgEBT0ErG2aWrpVVNBYXnVEC/9oqAQFGzZcH3ScXRJuFbblaCwvGrIi/UjByAFhaBgCobfLcdSc39nsYPC8qohy4Mzhx8FhaCgpVdpEnvpVcygsLzqOpZXUVAICnqJWNLEXHoVMygMYQ6xvIqCQlDQ0qvkibn0KlZQWF41xEu/KCgEBS296gyxll7FCArLq4ZYXkVBISjYEcNB6ti6JMbSq7pBYXnVkPCVj7kJCgpBQS8R6yR1l17VCQrLq8xNUFAIClp6lRF1ll7VCQrLq4ZYXkVBISjYUedW+w6zr9RZejVpUFheNaQaSHXIUVAICnqJWMl/g5MEheVV1+cmHHAUFIKCGfjhwGP3KyZZejVuUFhedR1DmBQUgoKWXmXJuEuvxg0KQ5hDqg91hxsFhaCgpVc5Mu7Sq3GCwvKqIZZXUVAICmbq/MbAYfeVcZZejRoUllcNqW63ONQoKAQFvUSsBEZdejVKUFheZW6CgkJQ0NKrghll6dVdQWF51XUsr6KgEBQ0T1Ekdy29uisoLK8aUn3t4zCjoBAU9BKxErlr6dVtQWF51RAv/aKgEBS09Kp4bvv7/FlQWF41xPIqCgpBwcI1TzHkZ0uvbgoKy6uuc+/tjkOMgkJQ0EvEcMVNS69uCorlwZmf21e89IuCQlCQleF/5o7FS25aevV9UFheNeTF+pHDi4JCUJBDw++n4/GS75defRsU1f/GUVE9pXFwUVAICtLSq5/z7dKrq6CwvOo6lldRUAgK0kvERuBq6VUICsurrmN5FQWFoCAtvRpjniJEVgiKascCKrz0i4JCUJCWXo1J+BroXz37Jq6wvIqCQlCQYxkGEx2f+JbwlY+5CQoKQUF6iRjMTVBQCArS0iu0h+VVFBSCgqzl3GpfVBROtcjLAUVBIShILxFDnbkJhxMFhaAgo/nh4FRUFIghTAoKQUFaeoVaVB/IDiYKCkFBWnqFSbG8ioJCUJCNOr/h5Vi5s9g/dSBRUAgK0kvEYG6CFBSkpVdoEcurKCgEBWmeArV40tt3EFFQCArSS8QwOV76RUEhKEhLr1ALy6soKAQFmYTmKbrNvbc7DiAKCkFBeokYJsdLvygoBAWZlLO9bVHRMV6sHzl4KCgEBZme4XfcMd0NlgdnDh0KCkFBWnqFelheRUEhKEgvEUMtLK+ioBAUpKVXqIWXflFQCArS0ivUwvIqCgpBQXbSN/0jUZEIYXmVuQkKCkFBeokYzE2QgkJQ0NIrtIflVRQUgoLMwrnVvqhoiVebxw4XCgpBQXqJGOrNTThYKCgEBZmdHw5ORcUUMYRJQSEoSEuvUIvqw9ShQkEhKEhLrzApXvpFCgqyCOc3BqKiIRb7pw4TUlCQXiIGcxOkoBAUpKVXLWJ5FSkoSPMUqMWT3r5DhBQUpJeIYXK89IsUFCS9RKwWXvpFCgqS32ieYjLuvd1xeJCCgqSXiE2Ol36RgoLkDc72tkXFiFheRQoKkrcY/k7kwu0sD84cGKSgcGCQXiJWD0OYpKBwWJBeIlYLy6tIQSEoSEuvavHs44GDghQUgoK0m8LOCVJQCArS9swEsBWTFBSCgvRVh68+SEEhKEjDmOlQfVg6NEhBQdL67bpYu00KCpKGMA1pkoJCUJCGMA1pkoJCUJCGMA1pkoJCUJCGMGFIkxQUJA1hGtIkBYWgIA1hGtIkBYWgIFt2fmMgJhpisX/qMCEFBZm/s71tMdEwL9aPHCgUFIKCzNf77z+LiSnxaGXgUKGgEBRknjc6DGFOlwfvdh0sFBSCgjSECUOapKAQFKQhTEOapKAQFKQhTEOapKAQFKQhTBjSpKAQFKQhTBjSJAWFoKAhTEOYhjRJQSEoSEOYhjRJQSEoSEOY+CmvNo8dOBQUgoJM14crW2KiIzzp7Tt0KCgEBWkIE4Y0SUFBZujS3omnEx3EkCYFhaAgkzH8bjuau8ny4MzhQ0EhKMj2nVvtiwlDmqSgEBSkIUwY0qSgEBSkIUwY0iQFBWkIE4Y0SUEhKGgIE4Y0SUEhKEhDmDCkSUEhKEhDmDCkSQoK0hAmDGmSgkJQsCA/HJx6OmFIkxQUgoKc3IWtQzFRKGuH588dThQUgoKs7dO1XTFROK+/nDigKCgEBWkIE4Y0KSgEBdniEKZjdGYmDKL+vmOJlyFNCgpBQRrCrEF4SvPPf29dVLMEMKRJQSEoSEOY4zLb265+Hv/4/cvFvbc7fiaGNCkoBAVpCHM8ws/h6mcSgiJ8QFWP/GFIk4JCUJCGMEfhTf/o2s/lKiiC1XAiDGlSUAgK0hDmbYTZke9/Nt8GRbB61wUMaVJQCArSEOZNhBsdIazuCorgYt/Py5AmBYWgIA1h3kD4yuemn89NQREOUjc/Loc0RQUFhaAgDWF+5epGx6hBYUjTkCYFhaAgDWFe49sbHeMERfYfWmPw7OOBQ4yCQlDQEGa5fH+jY9ygcPNjSPUB7iCjoBAULMswgGgI8/zxKD+ru4IiWD32x0y1AMxhRkEhKFiG4X/ljr6ZmZtudEwaFMHlwVnxP1dDmhQUgoKGMIviZzc66gSFmx+GNCkoBAUNYRbE3Gp/rJ/bqEHh5ochTQoKQUFDmIUwvzEY+2c3TlC4+WFIk4JCUNAQZuaMcqMjRlC4+WFIk4JCUNAQZqaMeqMjVlC4+WFIk4JCUNAQZoaMeqMjZlAEDWka0qSgEBQ0hJkJ49zoiB0U1f/OYUiTgkJQsKvef//ZQTZz91rtpoPCzY8hj1YGDjoKCkHBrt3oMIQZ72+ublAEq8MUM1VcOewoKAQFDWF2hUlvdDQVFMHqsb8hTUOaFBSCgl0w7Fko/dAKT2fqDGE2FRRuflyy2D914FFQCAqm7GzPAGAgZkzEDgo3Py55sX7k0KOgEBQ0hJkudW90TCMo3PwwpElBIShoCDNhYtzomEZQuPlhSJOCQlDQEGaBf19NBIWbH4Y0KSgEBQ1hJkbMGx3TDAo3PwxpUlAIChrCTITYNzqmHRRufhjSpKAQFDSEmQDh59D0z7rpoAiP/N38MKRJQSEoaAizJZq40dFGULj5YUiTgkJQsBWX9jwib+pGR1tB4ebHEEOaFBSCglMw/B6VfuAsbB1O9Wc+raAIPun5910enDkQKSgEBZt0brVf/GETns5M++c+zaAIVgOKhfNq89ihSEEhKNiEYV6g9ENmGjc6UggKNz8uqZ7WOBgpKAQFDWHGZho3OlIJCjc/DGlSUAgKGsJsgGnd6EglKNz8MKRJQSEoaAgzMtO80ZFSULj5YUiTgkJQ0BBmJJpeq516ULj5YUiTgkJQ0BBmTT4cnCbxb9F2ULj5YUiTgkJQ0BDmhLR1oyPVoAhWL9EypOmwpKAQFDSE2Y0hzFSDws0PQ5oUFIKChjDHILxFNaV/k1SCInjv7U7xvx9VVDkwWXJQALibtm90pB4Ubn4AAHAHKdzo6EJQuPkBAMBPSOVGR1eCIlhdpQQAAJekdKOjS0Hh5gcAAN+Q0o2OrgWFmx8AAPw/YRto6jdvUg4KNz8AAMUzvzHoxFXe1IPCzQ8AQLGkeqOjq0Hh5gcAoDjCEGaXlo11JSjc/AAAFEXKNzq6HhTB6nXfAADkTOo3OnIICjc/AABZ04UbHTkEhSFNAEC2dOVGRy5B4eVIAIDs6NKNjpyCws0PAEA2pL5WO/egCL7+ciIqAADdpusxkUNQuPkBAOg0XbzRkWtQuPkBAOgkT9d2s4iJXILCzQ8AQOd4+Wk/m5jIKSjc/AAAdIau3+jIPSiCzz4eiAoAQLrkcKOjhKBw8wMAkDQ5xkSuQRE0pAkASI5cbnSUFBTh5offXABAMuR0o6OkoHDzAwCQDAtbh1nHRO5BEXy0MhAVAID2WNo7yT4mSggKNz8AAK2R642OUoPCzQ8AQCvcf/+5iJgoKSjc/AAATJWcb3SUHhRufgAApkLuNzpKDwo3PwAAjVPCjQ5B4eYHAKBBSrnRISiGvlg/EhUAgHiUdKNDULj5AQBoiJJudAiKH4c03fwAANRmtrdddEyUHhRufgAAalPijQ5B4eYHACAib/pHYkJQXPNJb19UAABG58PBqZAQFG5+AAAmp/QbHYLCzQ8AQARKW6stKNz8AABExo0OQeHmBwCgFm50CAo3PwAAtXCjQ1C4+QEAqEUYwhQNgqKOrzaPRQUAlI4bHYIihov9U1EBAKXiRoegcPMDAFCLudW+WBAUUb33dsdTCgAoifmNgVAQFG5+AAAmx40OQeHmB5DJh3lYHkS2pUAQFNN6UvHbX3tkKz77eJB/1HrpEikoSHqJXW3c+ScFBUm7UaLgA5oUFCSbc3lwVkZQ3H//2Yc0KShINmUpGIwjBQVJQVGbl5/2fUiTgoJkA4ZbHvYAkBQUJO1BcdODFBQk3fBw04OkoCDd8DCYSVJQkAYyC8PLmUhBQdLL6QxmkoKCpIFMg5kkBQVpIDMTfv1z04c1KShIRnLt8Px5kUExt9r3YU0KCpIR/OWP7TKfTtiYSQoKkvF8tDIoNyg+HJz6sCYFBckIvlg/KjcozFGQgoKk+QlzFKSgIGl+Ig0Wtg59YJOCgqT5CfsoSEFB0v6JBLj//rMPbVJQkPT+jno8Xdv1oU0KCpITeO/tjqC4YmnvxIc2KShITuCzjweC4lt8aJOCguT4Lg/OBIXro6SgIOm6qNeZk4KCpNeV+9qDpKAgu+xi/1RQ+NqDFBQkfd3haw9SUJD0dYevPUgKCtLXHb72ICkoSF93wJIrUlCQtMyqYX79c9OHOCkoSP7EtcPz52rBuz1IQUHSuzumgVeak4KCpFeVR+HhypYPclJQkPSq8nosbB36ICcFBclvfLQyEBSGM0lBQdKbRQ1nkoKCpGFMw5kkBQVpGLNgZnvbPtBJQUHajAkvDCMFBUkvAkuA++8/+1AnBQXpqijq8fLTvg91UlCQRfrbX3uCwhVSUlCQdFXUFVKSgoJ0VTQ/fLCTgoIsyddfTgSFpxSkoCDp6YSnFCQFBenphKcUJAUF6ekEPKUgBQXp6QQ8pSAFBUlPJzylICkoSE8nPKUgKShITyfgKQUpKEhPJ+ApBSkoSHo64SkFSUFBejpRFt5ESgoK0htFEQVvIiUFBemNoqjNwtahD31SUJCd9NHKQEykxP33n33wk4KC7J5Ii6W9Ex/8pKAgO+WzjweCIkVme9s+/ElBQXbCX/7YFhOukZKCgqRrolkzvzFwAJCCgkzaB+92xYRrpKSgIOmaaBG86R85BEhBQSbpk96+mDCgSQoKkgYxDWiSFBSkQUyMi/d8kIKC9L4ORMEGTVJQkDZiojYfDk4dCKSgIFv1xfqRoLCbgqSgIO2cgK8+SEFBtuja4flzp7CvPkgKCtJXHfDVBykoSF91wFcfpKAgfdUBX32QgoL0VQd89UFSUJC+6sBtPFzZclCQgoL0rg7UY/34/LHXnJOCgozpq81jQVEiC1uHDgtSUJBRfLQyEBMlM7fad2CQgoKs5b23O2ICMzO++iAFBVnH5cGZoICrpKSgIF0RRSReftp3cJCCghzL3/7aExP4kdnetsODFBSkK6IwT0EKCtLcBMxTkIKCNDeBXLCfghQUpH0TiIL9FKSgIO2bQBS874MUFOS3Q5heSY6J8L4PUlCQV77+cuLpBCZnae/EgUJBIShYuM8+HogJ1MfSKwoKQUHLq4AoPF3bdbBQUJCF+eDdrpiAIU1SUJCGMJEohjQpKMgyXOyfejoBNz9IQUG60YHEedM/cshQUJCZ+qS3Lybg5gcpKEg3OuDmBykoSDc6UCKzvW0HDgUFmcGNDicaWsd1UgoK0vVQIApuflBQkN10eXDm6QTSwXVSCgrS9VBAVJCCgmICSAdvJ6WgIL09FIiCxVcUFKTFVYCoIAUFxQSQDrZpUlCQtmACUbBNk4KCtAUTEBWkoKCYAEQFKSgoJgBRQQoKUkwAooKCghQTgKggBQXFBCAqSEFBMQGIClJQkGICEBUUFKSYAEQFKSgoJgBRQQoKiglAVJCCghQTgKigoCDFBNAi8xsDhxgFBemtoUB93vSPHGQUFOR3PuntiwlAVFBQkGICEBUUFKSYALrL+vH541//3HSwUVCwSF9/ORETgKigoCDFBJAcD1e2HHAUFMzeX/7YvlgenIkJQFRQUJCTx8Ta4flzn/bAFLAAi4KCFlYBEBUUFKSYANLBtVIKCroWCiAKS3snF26AUFCwq75YPxITQCqEa6X33392+FFQsFPDl66FAoniBggFBd3kABAFw5oUFDR8CSAKC1uHDkIKChq+BFCfDwenhjUpKJiMrzaPxQRgroKCwoFIa7QBcxXmKigoaF4CgLkKCgqalwCQDPZVUFDQfgkA0Zhb7TsoKSjYyFcc9ksAvgIhBQV9xQHAVyAUFPQVB4AWmd8YODgpKDi2v/21JyQA/Mhsb9sBSkHBO733dsduCQC3E16H7msQCgr+7OsNrxsHMBYvP+1b3U1BQUOXAOLgiikFhaugvt4AEIXwojFfgwgKlvf1hhd6AWiEsLvC1yCCgvn77OOBkADQPF42JiiY7zVQmy4BTP1rENdMBQXzuQZqORWAVnnTP/I1iKBgh3UNFEBS2LYpKGjLJQBEw9cggoK2XAJAFGzbFBS05RIAomHbpqCgLZcAEA3bNgUFbbkEgCiEa6YPV7Yc0IKCU/p6wzVQAFlj26agoC2XABAN2zYFBW25BIAorB+fP3bNVFCw/jXQxf6ppxIAYNumoKAtlwAQjXDN1AEuKHi3j1YGQgIA7sLXIIKCtlwCQBRs2xQUtOUSAKJ+DWK+QlDYcgkAiIJtm4LClksAQBRs2xQUtlwCAKJh26agsOUSABAN2zYFhS2XAIAo2LYpKGy5BABEw7ZNQWHLJQAgGrZtCgpbLgEA0fA1iKCw5RIAEIVwzdS2TUGRwjXQV5vHQgIAuo5tm4LClksAQDRcMxUU07wG6usNAMgY2zYFhS2XAIBo2LYpKGy5BABEY35jIBoERe2vN/wlAQBs2xQUtlwCAOIRtm26ZiooRpmTsOUSAHAntm0KClsuAQDR8DWIoLDlEgAQBds2yw4KWy4BAFEpedtmqUFhyyUAoDFK3LZZWlDYcgkAmAqlbdssJShsuQQAtEIp2zZLCApbLgEArZP7ts2cg8KWSwBAUuS8bTPHoLDlEgCQNEt7J9ldM80pKGy5BAB0ipy2beYSFLZcAgA6y9xqX1C07IN3u66BAgC6T9e3bXY1KGy5BABkSVe3bXYxKGy5BABkT9e2bXYpKMI10LXD8+d+ywAARdClbZtdCApbLgEARfOmf5T81yCpB4VroAAAfCXlbZupBoUtlwAA3ECq2zZTCwpbLgEAGIHUtm2mEhS2XAIAMAGpbNtMIShsuQQAoCZtb9tsMyhsuQQAICJtbttsIyhsuQQAoEHa2LY57aCw5RIAgCkxzW2b0woKWy4BAGiBaW3bbDoobLkEACABmt622WRQuAYKAEBiNLVts4mgsOUSAIDEib1tM2ZQhC2XroECANARYm7bjBEUtlwCANBhYlwzrRsUroECAJAJdbZtThoUtlwCAJAhk27bHDcobLkEAKAAFrYOx/oaZJygePbxQEgAAFASo27bHCUobLkEAKBgwtcgd10zvS0owjVQWy4BAEDFbds2fxYUroECAIAbuWnb5vdBYcslAAAYiW+/BrkKClsuAQDA2Fxt2/znv329AQAAarJ+/L//5acAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAbvN/UKBFeSsDWs4AAAAASUVORK5CYII=
