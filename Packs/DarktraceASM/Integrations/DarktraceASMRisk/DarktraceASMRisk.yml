commonfields:
  id: Darktrace ASM
  version: -1
name: Darktrace ASM
display: Darktrace ASM
category: Network Security
image: data:image/svg+xml;base64,PHN2ZyBpZD0iYTRkODRkYTQtNTViNC00YWFiLWE2NjctODc4Mjc0NmUzZmMxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB2aWV3Qm94PSIwIDAgOTQuMzUgMTA2LjEzIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImJlMDlkODU5LTQ4OWMtNDY3YS1iYjM1LWFlYjAwNjQ5YmFiYSIgeDE9IjY5Ljk5IiB5MT0iNTQwLjY2IiB4Mj0iOS42MSIgeTI9IjU0MS4yOSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgwIC01MjAuNzYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZTc0ZDIzIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZjA4YTE0Ii8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHBhdGggZD0iTTIxLjM2LDE4LjQ3aDI1YzEuMDcsMCw1LjMxLjMyLDcuNTcuNTZDODEuMiwyMi4xNCw5MC40LDM0LjM4LDk0LjM1LDQwLjI5LDkyLjUsMjcuODksODguMSwxOC40MSw4MS43OSwxMlE3MC4yMS4xMyw0Ni43OCwwSDBWMTguNVoiIGZpbGw9InVybCgjYmUwOWQ4NTktNDg5Yy00NjdhLWJiMzUtYWViMDA2NDliYWJhKSIvPjxwYXRoIGQ9Ik04My4zOCw0MC4wNWE0Ni42Miw0Ni42MiwwLDAsMSw0LjE4LDUuMjIsMzYuNTcsMzYuNTcsMCwwLDEsNi42LDIxLjI0QTM5LjY0LDM5LjY0LDAsMCwxLDU0LjYsMTA2bC03LjE5LjEzSDEwLjQ2QzQuNjksMTA2LjE3LDAsMTAxLDAsOTQuNTR2LTY4aDIxLjVWODcuNjhINDYuNDNjNS4zLS4xLDcuNDYtLjE3LDEwLjQ1LS44MWExNC4zNiwxNC4zNiwwLDAsMCw3LjktNSwyMy45NCwyMy45NCwwLDAsMCw0Ljc3LTkuMzNBNjguMDcsNjguMDcsMCwwLDAsNzEuMzMsNjJhMTIyLjM0LDEyMi4zNCwwLDAsMCwuMTUtMTMuNTQsODEuNDcsODEuNDcsMCwwLDAtMS45Mi0xNSwyMi4zMywyMi4zMywwLDAsMC0xLjEtMy4wNkEzOCwzOCwwLDAsMSw4My4xNywzOS44WiIvPjwvc3ZnPg==
description: 'This pack includes configurations to combine the world-class threat
  detection of Darktrace with the synchrony and automation abilities of XSOAR, allowing
  security teams to monitor their attack surface for risks, high-impact vulnerabilities
  and external threats. '
detaileddescription: "### Community Contributed Integration\n#### Integration Author:
  Darktrace\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- Email: integrationsupport@darktrace.com\n-
  URL: https://customerportal.darktrace.com\n***\n## Darktrace ASM \nTo configure
  the connection to your Darktrace instance, you will provide:\n- Server URL of Darktrace
  ASM instance (ex: example-asm.darktrace.com) and any necessary proxy information\n-
  Darktrace ASM API token\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/darktrace-admin)"
configuration:
- display: Server URL (e.g. https://soar.monstersofhack.com)
  name: url
  defaultvalue: https://soar.monstersofhack.com
  type: 0
  required: true
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Maximum number of incidents per fetch
  name: max_fetch
  defaultvalue: "100"
  type: 0
  required: false
- display: API Key
  name: apikey
  type: 4
  required: true
- display: Fetch alerts with type
  name: alert_type
  defaultvalue: GDPR,Informational,Misconfiguration,Reported,SSL,Vulnerable Software
  type: 16
  required: false
  options:
  - GDPR
  - Informational
  - Misconfiguration
  - Reported
  - SSL
  - Vulnerable Software
  additionalinfo: Comma-separated list of types of alerts to fetch. Types might change
    over time. Some examples are 'Bug' and 'Vulnerability'
- display: Minimum severity of alerts to fetch
  name: min_severity
  defaultvalue: Medium
  type: 15
  required: false
  options:
  - Low
  - Medium
  - High
  - Critical
- display: First fetch time
  name: first_fetch
  defaultvalue: 3 days
  type: 0
  required: false
- display: Incidents Fetch Interval
  name: incidentFetchInterval
  defaultvalue: "1"
  type: 19
  required: false
script:
  script: |
    register_module_line('DarktraceASMRisk', 'start', __line__())
    ### pack version: 3.0.4


    import hashlib
    import hmac
    import json
    import time
    import traceback
    from datetime import datetime, timezone
    from typing import Any, Dict, List, Mapping, Optional, Tuple, cast

    import dateparser
    import urllib3

    """Darktrace Integration for Cortex XSOAR (aka Demisto)"""

    # Disable insecure warnings
    urllib3.disable_warnings()

    """*****CONSTANTS*****"""
    ASM_URI = "/graph/v1.0/api"
    ASM_RISK_QUERY = '''
                        id
                        type
                        startedAt
                        endedAt
                        title
                        description
                        evidence
                        proposedAction
                        securityRating
                        mitigatedAt
                        asset {
                            id
                            state
                            brand
                            createdAt
                            updatedAt
                            securityrating
                            isMalicious
                            tags
                            }
                        comments {
                            edges {
                                node {
                                    id
                                    text
                                }
                            }
                        }
                        '''
    ASM_ASSET_QUERY = '''
                        id
                        state
                        brand
                        createdAt
                        updatedAt
                        securityrating
                        isMalicious
                        tags
                        comments {
                            id
                            text
                        }
                        discoverySources {
                            id
                            description
                        }
                        risks {
                            id
                            title
                        }
                    '''
    ASM_ASSET_QUERY_DICT = {
                'application': ASM_ASSET_QUERY + '''
                protocol
                uri
                fqdns {
                    id
                    name
                }
                ipaddresses {
                    id
                    address
                }
                screenshot
                technologies {
                    id
                    name
                }
                ''', 'fqdn': ASM_ASSET_QUERY + '''
                name
                dnsRecords
                resolvesTo {
                    id
                    address
                }
                whois
                registeredDomain {
                    id
                    name
                }
                ''', 'ipaddress': ASM_ASSET_QUERY + '''
                lat
                lon
                geoCity
                geoCountry
                address
                netblock {
                    id
                    netname
                }
                ''', 'netblock': ASM_ASSET_QUERY + '''
                netname
                ipAddresses {
                    id
                    address
                }
                '''
    }

    SEVERITY_MAP = {"Low": 1,
                    "Medium": 2,
                    "High": 3,
                    "Critical": 4
    }

    MIN_SEVERITY_TO_FETCH = 1
    MAX_INCIDENTS_TO_FETCH = 50
    ALERT_TYPES = ['branding compliance', 'content change', 'gdpr', 'informational', 'informational leak', 'new file', 'misconfiguration', 'outdated software', 'reported', 'social media threat', 'ssl', 'vulnerable software']
    PLEASE_CONTACT = "Please contact your Darktrace representative."

    DARKTRACE_API_ERRORS = {
        'SIGNATURE_ERROR': 'API Signature Error. You have invalid credentials in your config.',
        'DATE_ERROR': 'API Date Error. Check that the time on this machine matches that of the Darktrace instance.',
        'ENDPOINT_ERROR': f'Invalid Endpoint. - {PLEASE_CONTACT}',
        'PRIVILEGE_ERROR': 'User has insufficient permissions to access the API endpoint.',
        'UNDETERMINED_ERROR': f'Darktrace was unable to process your request - {PLEASE_CONTACT}',
        'FAILED_TO_PARSE': 'N/A'
    }

    #CUSTOM EXCEPTIONS
    class InvalidAssetStateError(Exception):
        def __init__(self, state: str):
            super().__init__(f'{state} is not a valid state.  Valid states include "Confirmed" and "Unconfirmed".')

    class InvalidAssetID(Exception):
        def __init__(self, asset_id: str = None):
            super().__init__(f"ASM Asset ID \"{asset_id}\" is not a valid ID.")

    class AssetNotFound(Exception):
        def __init__(self, asset_type:str, id: str = None, message: str = None):
            super().__init__(f"ASM {asset_type} Asset with id \"{id}\" not found. {message}")

    class TagNotFound(Exception):
        def __init__(self, name: str, message: str = None):
            super().__init__(f"ASM Tag with name \"{name}\" not found. {message}")

    class CommentNotFound(Exception):
        def __init__(self, id: str = None, message: str = None):
            if message:
                super().__init__(f"ASM Comment with id \"{id}\" not found. {message}")
            else:
                super().__init__(f"ASM Comment with id \"{id}\" not found.")

    """*****CLIENT CLASS*****
    Wraps all the code that interacts with the Darktrace API."""

    class Client(BaseClient):
        """Client class to interact with the Darktrace API
        This Client implements API calls, and does not contain any Demisto logic.
        Should only do requests and return data.
        It inherits from BaseClient defined in CommonServer Python.
        Most calls use _http_request() that handles proxy, SSL verification, etc.
        """

        def get(self, query_uri: str, params: Dict[str, str] = None):
            """Handles Darktrace GET API calls"""
            return self._darktrace_api_call(query_uri, method='GET', params=params)

        def post(self, query_uri: str, data: dict = None, json: dict = None):
            """Handles Darktrace POST API calls"""
            return self._darktrace_api_call(query_uri, method='POST', data=data, json=json)

        def asm_post(self, query_uri: str, json: dict = None):
            headers = self._headers
            return self._asm_api_call(query_uri, method='POST', json=json, headers=headers)

        def _asm_api_call(
            self,
            query_uri: str,
            method: str,
            params: dict = None,
            data: dict = None,
            json: dict = None,
            headers: Dict[str, str] = None,
        ):
            """Handles Darktrace API calls"""
            """
            headers = {
                **self._create_headers(query_uri, params or data or json or None, is_json=bool(json)),
                **(headers or {}),
            }
            """
            try:
                res = self._http_request(
                    method,
                    url_suffix=query_uri,
                    params=params,
                    data=data,
                    json_data=json,
                    resp_type='response',
                    headers=headers,
                    error_handler=self.error_handler,
                )

                if res.status_code not in [200, 204]:
                    raise Exception('Your request failed with the following error: ' + str(res.content)
                                    + '. Response Status code: ' + str(res.status_code))
            except Exception as e:
                raise Exception(e)
            try:
                return res.json()
            except Exception as e:
                raise ValueError(
                    f'Failed to process the API response - {str(e)}'
                )

        def _darktrace_api_call(
            self,
            query_uri: str,
            method: str,
            params: dict = None,
            data: dict = None,
            json: dict = None,
            headers: Dict[str, str] = None,
        ):
            """Handles Darktrace API calls"""
            headers = {
                **self._create_headers(query_uri, params or data or json or None, is_json=bool(json)),
                **(headers or {}),
            }

            try:
                res = self._http_request(
                    method,
                    url_suffix=query_uri,
                    params=params,
                    data=data,
                    json_data=json,
                    resp_type='response',
                    headers=headers,
                    error_handler=self.error_handler,
                )

                if res.status_code not in [200, 204]:
                    raise Exception('Your request failed with the following error: ' + str(res.content)
                                    + '. Response Status code: ' + str(res.status_code))
            except Exception as e:
                raise Exception(e)
            try:
                return res.json()
            except Exception as e:
                raise ValueError(
                    f'Failed to process the API response - {str(e)}'
                )

        def error_handler(self, res: requests.Response):
            """Handles authentication errors"""
            if res.status_code == 400:
                raise_message = 'Invalid field names in query:\n'
                for error in res.json()['errors']:
                    error_message = error['message']
                    error_location = f"Line {error['locations'][0]['line']}, column {error['locations'][0]['column']}."
                    raise_message += f"{error_message} {error_location}\n"
                raise ValueError(raise_message)
            elif res.status_code == 401:
                raise PermissionError(f"Authentication issue: {res.json()['detail']}")
            elif res.status_code == 404:
                raise ValueError("Error 404. Page not found." + PLEASE_CONTACT)
            elif res.status_code == 500:
                raise ValueError("Error 500. Possibly malformed GraphQL query.")

        def get_asm_risk(self, risk_id: str):
            query = f'''query risk {{
                            risk(id:"{risk_id}") {{
                                id
                                type
                                startedAt
                                endedAt
                                title
                                description
                                evidence
                                proposedAction
                                securityRating
                                mitigatedAt
                                asset {{
                                    id
                                    state
                                    brand
                                    createdAt
                                    updatedAt
                                    securityrating
                                    isMalicious
                                    tags
                                }}
                                comments {{
                                    edges {{
                                        node {{
                                            id
                                            text
                                        }}
                                    }}
                                }}
                            }}
                        }}
                        '''
            payload = {"query": query}
            response = self.asm_post(ASM_URI, payload)
            return response["data"]["risk"]

        def mitigate_asm_risk(self, risk_id: str):
            mutation = f'''mutation MyMutation {{
                        closeRisk(
                        id:"{risk_id}"
                        ) {{
                            success
                            }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            return response["data"]["closeRisk"]

        def get_asm_asset(self, asset_id: str):
            if asset_id[0] == 'Q':
                asset_type = 'application'
            elif asset_id[0] == 'R':
                asset_type = 'fqdn'
            elif asset_id[0] == 'T':
                asset_type = 'netblock'
            elif asset_id[0] == 'S':
                asset_type = 'ipaddress'
            else:
                raise InvalidAssetID(asset_id)
            query_type = ASM_ASSET_QUERY_DICT[asset_type]
            query = f'''query {asset_type} {{ {asset_type}(id:"{asset_id}") {{
                {query_type}
                }}
                }}'''
            payload = {"query": query}
            response = self.asm_post(ASM_URI, payload)
            if not response["data"][asset_type]:
                message = response["errors"][0]["message"]
                raise AssetNotFound(asset_type, asset_id, message)
            asset = response["data"][asset_type]
            asset["type"] = asset_type
            return asset

        def post_asm_comment(self, id: str, comment: str):
            mutation = f'''mutation MyMutation {{
                        placeComment(
                        text:"{comment}",
                        objectId:"{id}"
                        ) {{
                        success
                        comment {{
                            id
                            text
                            }}
                        }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            return response["data"]["placeComment"]

        def edit_asm_comment(self, comment_id: str, comment: str):
            mutation = f'''mutation MyMutation {{
                        editComment(
                        text:"{comment}",
                        id:"{comment_id}"
                        ) {{
                        success
                        comment {{
                            id
                            text
                            }}
                        }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            if not response['data']['editComment']:
                message = response['errors'][0]['message']
                raise CommentNotFound(comment_id, message)
            return response["data"]["editComment"]

        def delete_asm_comment(self, comment_id: str):
            mutation = f'''mutation MyMutation {{
                        deleteComment(
                        id:"{comment_id}"
                        ) {{
                        success
                        }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            return response["data"]["deleteComment"]

        def create_asm_tag(self, tag_name: str):
            mutation = f'''mutation MyMutation {{
                        createTag(
                        name:"{tag_name}"
                        ) {{
                            success
                            tag {{
                                id
                                name
                                }}
                            }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            return response['data']['createTag']

        def assign_asm_tag(self, tag_name: str, asset_id: str):
            mutation = f'''mutation MyMutation {{
                        assignTag(
                        id:"{asset_id}",
                        tagName:"{tag_name}"
                        ) {{
                            success
                            asset {{
                                id
                                tags
                                }}
                            }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            if not response['data']['assignTag']:
                message = response['errors'][0]['message']
                raise TagNotFound(name=tag_name, message=message)
            return response['data']['assignTag']

        def unassign_asm_tag(self, tag_name: str, asset_id: str):
            mutation = f'''mutation MyMutation {{
                        unassignTag(
                        id:"{asset_id}",
                        tagName:"{tag_name}"
                        ) {{
                            success
                            asset {{
                                id
                                tags
                                }}
                            }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            return response['data']['unassignTag']

        def change_asm_asset_state(self, asset_id: str, state: str):
            mutation = f'''mutation MyMutation {{
                        changeState(
                        id:"{asset_id}",
                        state:"{state}"
                        ) {{
                            success
                            asset {{
                                id
                                state
                                }}
                            }}
                        }}
                        '''
            payload = {"query": mutation}
            response = self.asm_post(ASM_URI, payload)
            return response['data']['changeState']

        def get_asm_risks(self, start_time) -> Dict[str, Any]:
            start_string = start_time.strftime("%Y-%m-%dT%H:%M:%S")
            query = f'''query allRisks {{
                            allRisks(startedAt:"{start_string}", orderBy:"startedAt") {{
                                edges {{
                                    node {{
                                        {ASM_RISK_QUERY}
                                        }}
                                    }}
                                }}
                            }}
                        '''
            payload = {"query": query}
            response = self.asm_post(ASM_URI, payload)
            return response["data"]["allRisks"]["edges"]

    """*****HELPER FUNCTIONS****"""

    def arg_to_timestamp(arg: Any, arg_name: str, required: bool = False) -> Optional[int]:
        """Converts an XSOAR argument to a timestamp (seconds from epoch)
        This function is used to quickly validate an argument provided to XSOAR
        via ``demisto.args()`` into an ``int`` containing a timestamp (seconds
        since epoch). It will throw a ValueError if the input is invalid.
        If the input is None, it will throw a ValueError if required is ``True``,
        or ``None`` if required is ``False.
        :type arg: ``Any``
        :param arg: argument to convert
        :type arg_name: ``str``
        :param arg_name: argument name
        :type required: ``bool``
        :param required:
            throws exception if ``True`` and argument provided is None
        :return:
            returns an ``int`` containing a timestamp (seconds from epoch) if conversion works
            returns ``None`` if arg is ``None`` and required is set to ``False``
            otherwise throws an Exception
        :rtype: ``Optional[int]``
        """

        if arg is None:
            if required is True:
                raise ValueError(f'Missing \'{arg_name}\'')
            return None

        if isinstance(arg, str) and arg.isdigit():
            # timestamp is a str containing digits - we just convert it to int
            return int(arg)
        if isinstance(arg, str):
            # we use dateparser to handle strings either in ISO8601 format, or
            # relative time stamps.
            # For example: format 2019-10-23T00:00:00 or "3 days", etc
            date = dateparser.parse(arg, settings={'TIMEZONE': 'UTC'})
            if date is None:
                # if d is None it means dateparser failed to parse it
                raise ValueError(f'Invalid date: {arg_name}')

            return int(date.timestamp())
        if isinstance(arg, (int, float)):
            # Convert to int if the input is a float
            return int(arg)
        raise ValueError(f'Invalid date: \'{arg_name}\'')


    def stringify_data(data: Mapping) -> str:
        """Stringify a params or data dict without encoding"""
        return "&".join([f"{k}={v}" for k, v in data.items()])


    def check_required_fields(args, *fields):
        """Checks that required fields are found, raises a value error otherwise"""
        for field in fields:
            if field not in args:
                raise ValueError(f'Argument error could not find {field} in {args}')


    def format_JSON_for_risk(risk: Dict[str, Any]) -> Dict[str, Any]:
        """Formats JSON for get_risk command, specifically reformat comments from API response
        :type risk: ``Dict[str, Any]``
        :param risk: JSON risk as returned by API for fetch incident
        :return: Reformatted JSON risk
        :rtype: ``Dict[str, Any]``
        """
        new_json ={}
        for key in risk.keys():
            if key == 'comments':
                if risk[key] is None:
                    new_json[key] = {}
                else:
                    comments = {comment['node']['id']:comment['node']['text'] for comment in risk[key]['edges']}
                    new_json[key] = comments
            else:
                new_json[key] = risk[key]
        return new_json

    def format_JSON_for_asset(asset: Dict[str, Any]) -> Dict[str, Any]:
        """Formats JSON for get_asm command, specifically lists of dicts
        :type asset: ``Dict[str, Any]``
        :param asset: JSON asset as returned by API
        :return: Reformatted JSON asset
        :rtype: ``Dict[str, Any]``
        """
        new_json = {}
        for key in asset.keys():
            if key == 'comments':
                if asset[key] is None:
                    new_json[key] = {}
                else:
                    comments = {comment['id']:comment['text'] for comment in asset[key]}
                    new_json[key] = comments
            elif key == 'discoverySources':
                if asset[key] is None:
                    new_json[key] = {}
                else:
                    sources = {source["id"]:source["description"] for source in asset[key]}
                    new_json[key] = sources
            elif key == 'risks':
                if asset[key] is None:
                    new_json[key] = {}
                else:
                    risks = {risk["id"]:risk["title"] for risk in asset[key]}
                    new_json[key] = risks
            elif key in ['fqdns', 'technologies', 'registeredDomain']:
                if asset[key] is None:
                    new_json[key] = {}
                else:
                    values = {value["id"]:value["name"] for value in asset[key]}
                    new_json[key] = values
            elif key in ['ipaddresses', 'ipAddresses', 'resolvesTo']:
                if asset[key] is None:
                    new_json[key] = {}
                else:
                    addresses = {ip["id"]:ip["address"] for ip in asset[key]}
                    new_json[key] = addresses
            else:
                new_json[key] = asset[key]
        return new_json


    def _compute_xsoar_severity(security_rating: str) -> int:
        """Translates Darktrace ASM security rating into XSOAR Severity"""
        if security_rating in ['c', 'd']:
            return 2
        if security_rating in ['e']:
            return 3
        if security_rating in ['f']:
            return 4
        return 1


    """*****COMMAND FUNCTIONS****"""

    def test_module(client: Client, first_fetch_time: Optional[int]) -> str:
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        :type client: ``Client``
        :param client:
            Darktrace Client
        :type first_fetch_time: ``Optional[int]``
        :param first_fetch_time:
            First fetch time
        :return:
            A message to indicate the integration works as it is supposed to
        :rtype: ``str``
        """
        try:
            first_fetch_time = datetime.fromtimestamp(first_fetch_time)
            client.get_asm_risks(start_time=first_fetch_time)

        except DemistoException as e:
            if 'Forbidden' in str(e):
                return 'Authorization Error: make sure API Key is correctly set'
            else:
                raise e
        return 'ok'

    def fetch_incidents(client: Client, last_run, first_fetch_time, max_alerts, min_severity, alert_types) -> Tuple[Dict[str, Any], List[dict]]:
        # Get the last fetch time, if exists
        # last_run is a dict with a single key, called last_fetch
        last_fetch = last_run.get('last_fetch', None)
        first_fetch_time = datetime.fromtimestamp(first_fetch_time)
        # Handle first fetch time
        if last_fetch is None:
            last_fetch = first_fetch_time
        else:
            last_fetch = datetime.strptime(last_fetch, "%Y-%m-%dT%H:%M:%S")

        # for type checking, making sure that latest_created_time is int
        latest_created_time = last_fetch

        # Each incident is a dict with a string as a key
        incidents: List[Dict[str, Any]] = []

        # model_breach_alerts = client.search_model_breaches(
        #     min_score=min_score / 100,    # Scale the min score from [0,100] to [0 to 1] for API calls
        #     start_time=last_fetch       # time of last fetch or initialization time
        # )

        asm_risks = client.get_asm_risks(start_time=last_fetch)

        for alert in asm_risks:
            # Convert startedAt time to datetime object and add to alert
            incident_created_time = datetime.strptime(alert['node']['startedAt'][:19], "%Y-%m-%dT%H:%M:%S")

            # to prevent duplicates, we are only adding incidents with creation_time > last fetched incident
            if last_fetch:
                if incident_created_time <= last_fetch:
                    continue

            brand = alert['node']['asset']['brand']
            title = alert['node']['title']
            incident_name = f'Darktrace ASM | Risk Title: {title} | Brand: {brand}'

            xsoar_severity = _compute_xsoar_severity(alert['node']['securityRating'])

            # Skip incidents with a lower severity score than the desired minimum
            if xsoar_severity < min_severity:
                continue

            incident_type = alert['node']['type'].lower()

            # Skip incidents with a type not included in the chosen alert types to ingest
            if incident_type not in alert_types:
                continue

            incident = {
                'name': incident_name,
                'occurred': alert['node']['startedAt'],
                'rawJSON': json.dumps(alert['node']),
                'severity': xsoar_severity
            }

            incidents.append(incident)

            # Update last run and add incident if the incident is newer than last fetch
            if incident_created_time > latest_created_time:
                latest_created_time = incident_created_time

            if len(incidents) >= max_alerts:
                break

        # Save the next_run as a dict with the last_fetch key to be stored
        next_run = {'last_fetch': latest_created_time.strftime("%Y-%m-%dT%H:%M:%S")}
        return next_run, incidents

    def get_asm_risk_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'risk_id')
        risk_id = str(args.get('risk_id', None))

        response = client.get_asm_risk(risk_id)

        formatted_response = format_JSON_for_risk(response)

        readable_output = tableToMarkdown(f'Darktrace ASM Risk', formatted_response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.risk',
            outputs_key_field='id',
            outputs=response
        )

    def mitigate_asm_risk_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'risk_id')
        risk_id = str(args.get('risk_id', None))

        response = client.mitigate_asm_risk(risk_id)

        readable_output = tableToMarkdown(f'Darktrace ASM Risk Mitigation', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.risk',
            outputs_key_field='success',
            outputs=response
        )

    def get_asm_asset_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'asset_id')
        asset_id = str(args.get('asset_id', None))

        response = client.get_asm_asset(asset_id)

        formatted_response = format_JSON_for_asset(response)

        readable_output = tableToMarkdown(f'Darktrace ASM Asset', formatted_response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.asset',
            outputs_key_field='id',
            outputs=response
        )

    def post_asm_comment_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'id', 'comment')
        id = str(args.get('id', None))
        comment = str(args.get('comment', None))

        response = client.post_asm_comment(id, comment)

        readable_output = tableToMarkdown(f'Darktrace ASM Comment', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.comment',
            outputs_key_field='success',
            outputs=response
        )

    def edit_asm_comment_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'comment_id', 'comment')
        comment_id = str(args.get('comment_id', None))
        comment = str(args.get('comment', None))

        response = client.edit_asm_comment(comment_id, comment)

        readable_output = tableToMarkdown(f'Darktrace ASM Comment Edit', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.comment',
            outputs_key_field='success',
            outputs=response
        )

    def delete_asm_comment_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'comment_id')
        comment_id = str(args.get('comment_id', None))

        response = client.delete_asm_comment(comment_id)

        readable_output = tableToMarkdown(f'Darktrace ASM Comment Deletion', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.comment',
            outputs_key_field='success',
            outputs=response
        )

    def create_asm_tag_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'tag_name')
        tag_name = str(args.get('tag_name', None))

        response = client.create_asm_tag(tag_name)

        readable_output = tableToMarkdown(f'Darktrace ASM Tag Creation', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.tag',
            outputs_key_field='success',
            outputs=response
        )

    def assign_asm_tag_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'tag_name', 'asset_id')
        tag_name = str(args.get('tag_name', None))
        asset_id = str(args.get('asset_id', None))

        response = client.assign_asm_tag(tag_name, asset_id)

        readable_output = tableToMarkdown(f'Darktrace ASM Tag Assignment', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.tag',
            outputs_key_field='success',
            outputs=response
        )

    def unassign_asm_tag_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'tag_name', 'asset_id')
        tag_name = str(args.get('tag_name', None))
        asset_id = str(args.get('asset_id', None))

        response = client.unassign_asm_tag(tag_name, asset_id)

        readable_output = tableToMarkdown(f'Darktrace ASM Tag Unassignment', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.tag',
            outputs_key_field='success',
            outputs=response
        )

    def change_asm_asset_state_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        check_required_fields(args, 'asset_id', 'state')
        asset_id = str(args.get('asset_id', None))
        state = str(args.get('state', None))

        if state not in ['Confirmed', 'Unconfirmed']:
            raise InvalidAssetStateError(state)

        response = client.change_asm_asset_state(asset_id, state)

        readable_output = tableToMarkdown(f'Darktrace ASM Asset State Change', response)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Darktrace.asset',
            outputs_key_field='success',
            outputs=response
        )

    def print_demisto_params(params):
        readable_output = tableToMarkdown('Demisto Params', params)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='Demisto.params',
            outputs_key_field='id',
            outputs=params
        )

    """*****MAIN FUNCTIONS****
    Takes care of reading the integration parameters via
    the ``demisto.params()`` function, initializes the Client class and checks the
    different options provided to ``demisto.commands()``, to invoke the correct
    command function passing to it ``demisto.args()`` and returning the data to
    ``return_results()``. If implemented, ``main()`` also invokes the function
    ``fetch_incidents()``with the right parameters and passes the outputs to the
    ``demisto.incidents()`` function. ``main()`` also catches exceptions and
    returns an error message via ``return_error()``.
    """


    def main() -> None:     # pragma: no cover
        """main function, parses params and runs command functions
        :return:
        :rtype:
        """

        # Collect Darktrace URL
        base_url = demisto.params().get('url')

        #API key
        api_token = (demisto.params().get('apikey', ''))
        headers = {"Authorization": f"Token {api_token}"}

        # Collect API tokens
        # public_api_token = demisto.params().get('publicApiKey', '')
        # private_api_token = demisto.params().get('privateApiKey', '')
        # tokens = (public_api_token, private_api_token)

        # Client class inherits from BaseClient, so SSL verification is
        # handled out of the box by it. Pass ``verify_certificate`` to
        # the Client constructor.
        verify_certificate = not demisto.params().get('insecure', False)

        # How much time before the first fetch to retrieve incidents
        first_fetch_time = arg_to_timestamp(
            arg=demisto.params().get('first_fetch', '1 day'),
            arg_name='First fetch time',
            required=True
        )

        # Client class inherits from BaseClient, so system proxy is handled
        # out of the box by it, just pass ``proxy`` to the Client constructor
        proxy = demisto.params().get('proxy', False)

        # ``demisto.debug()``, ``demisto.info()``, prints information in the XSOAR server log.
        demisto.debug(f'Command being called is {demisto.command()}')

        try:
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                proxy=proxy,
                #auth=api_token
                headers=headers
            )

            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                return_results(test_module(client, first_fetch_time))

            elif demisto.command() == 'fetch-incidents':
                # Set and define the fetch incidents command to run after activated via integration settings.

                # Convert the argument to an int using helper map or set to MIN_SEVERITY_TO_FETCH
                min_severity = SEVERITY_MAP.get(demisto.params().get('min_severity', None), None)
                if not min_severity or min_severity < MIN_SEVERITY_TO_FETCH:
                    min_severity = MIN_SEVERITY_TO_FETCH

                # Get the list of alert types to ingest and make sure each item is all lower case or set to ALERT_TYPES
                alert_types = demisto.params().get('alert_type', None)
                if not alert_types:
                    alert_types = ALERT_TYPES
                else:
                    alert_types = [item.lower() for item in alert_types]


                # Convert the argument to an int using helper function or set to MAX_INCIDENTS_TO_FETCH
                max_alerts = arg_to_number(
                    arg=demisto.params().get('max_fetch', MAX_INCIDENTS_TO_FETCH),
                    arg_name='max_fetch',
                    required=False
                )
                if not max_alerts or max_alerts > MAX_INCIDENTS_TO_FETCH:
                    max_alerts = MAX_INCIDENTS_TO_FETCH

                next_run, incidents = fetch_incidents(
                    client=client,
                    max_alerts=max_alerts,
                    min_severity=min_severity,
                    alert_types=alert_types,
                    last_run=demisto.getLastRun(),  # getLastRun() gets the last run dict
                    first_fetch_time=first_fetch_time
                )

                # Use the variables defined above as the outputs of fetch_incidents to set up the next call and create incidents:
                # saves next_run for the time fetch-incidents is invoked
                demisto.setLastRun(next_run)
                # fetch-incidents calls ``demisto.incidents()`` to provide the list
                # of incidents to create
                demisto.incidents(incidents)

            elif demisto.command() == 'darktrace-asm-get-risk':
                return_results(get_asm_risk_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-mitigate-risk':
                return_results(mitigate_asm_risk_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-post-comment':
                return_results(post_asm_comment_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-edit-comment':
                return_results(edit_asm_comment_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-delete-comment':
                return_results(delete_asm_comment_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-get-asset':
                return_results(get_asm_asset_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-create-tag':
                return_results(create_asm_tag_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-assign-tag':
                return_results(assign_asm_tag_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-unassign-tag':
                return_results(unassign_asm_tag_command(client, demisto.args()))

            elif demisto.command() == 'darktrace-asm-change-asset-state':
                return_results(change_asm_asset_state_command(client, demisto.args()))

        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    """*****ENTRY POINT****"""
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('DarktraceMBs', 'end', __line__())
  type: python
  commands:
  - name: darktrace-asm-get-risk
    arguments:
    - name: risk_id
      required: true
      description: Unique ID of Risk.
    outputs:
    - contextPath: Darktrace.risk.id
      description: Risk ID.
      type: string
    - contextPath: Darktrace.risk.type
      description: Risk type.
      type: string
    - contextPath: Darktrace.risk.startedAt
      description: Risk creation time.
      type: date
    - contextPath: Darktrace.risk.endedAt
      description: Risk end time, no user mitigation.
      type: date
    - contextPath: Darktrace.risk.title
      description: Risk title.
      type: string
    - contextPath: Darktrace.risk.description
      description: Risk description.
      type: string
    - contextPath: Darktrace.risk.evidence
      description: Evidence of risk.
      type: string
    - contextPath: Darktrace.risk.proposedAction
      description: Proposed action to mitigate risk.
      type: string
    - contextPath: Darktrace.risk.securityRating
      description: Security rating of the risk, A to F.
      type: string
    - contextPath: Darktrace.risk.mitigatedAt
      description: Risk user mitigation time.
      type: date
    - contextPath: Darktrace.risk.asset.id
      description: Associated asset ID.
      type: string
    - contextPath: Darktrace.risk.asset.state
      description: State of asset.
      type: string
    - contextPath: Darktrace.risk.asset.brand
      description: Brand asset is associated with.
      type: string
    - contextPath: Darktrace.risk.asset.createdAt
      description: Asset creation time.
      type: date
    - contextPath: Darktrace.risk.asset.updatedAt
      description: Time of asset's last update.
      type: date
    - contextPath: Darktrace.risk.asset.securityrating
      description: Security rating of the asset, A to F.
      type: string
    - contextPath: Darktrace.risk.asset.isMalicious
      description: Whether or note the asset is malicious.
      type: boolean
    - contextPath: Darktrace.risk.asset.tags
      description: Tags applied to the asset.
    - contextPath: Darktrace.risk.comments
      description: Comments posted to the risk.
    - contextPath: Darktrace.risk
      description: Risk object dictionary.
    - contextPath: Darktrace.risk.asset
      description: Asset object dictionary.
    description: Get a specific Darktrace ASM Risk.
  - name: darktrace-asm-get-asset
    arguments:
    - name: asset_id
      required: true
      description: Unique ID of Asset.
    outputs:
    - contextPath: Darktrace.asset
      description: Asset object dictionary.
    - contextPath: Darktrace.asset.id
      description: Asset ID.
      type: string
    - contextPath: Darktrace.asset.state
      description: State of asset.
      type: string
    - contextPath: Darktrace.asset.brand
      description: Brand asset is associated with.
      type: string
    - contextPath: Darktrace.asset.createdAt
      description: Asset creation time.
    - contextPath: Darktrace.asset.updatedAt
      description: Time of asset's last update.
    - contextPath: Darktrace.asset.securityrating
      description: Security rating of the asset, A to F.
    - contextPath: Darktrace.asset.isMalicious
      description: Whether or note the asset is malicious.
    - contextPath: Darktrace.asset.tags
      description: Tags applied to the asset.
    - contextPath: Darktrace.asset.type
      description: Type of Asset.
    - contextPath: Darktrace.asset.comments
      description: Comments posted to the risk.
    - contextPath: Darktrace.asset.discoverySources
      description: Sources used in discovery of asset.
    - contextPath: Darktrace.asset.risks
      description: Risks associated with asset.
    description: Get a specific Darktrace ASM Asset.
  - name: darktrace-asm-post-comment
    arguments:
    - name: id
      required: true
      description: Can be a Risk ID or an Asset ID.
    - name: comment
      description: 'enter your comment '
    outputs:
    - contextPath: Darktrace.comment.success
      description: Whether or not comment was posted.
      type: boolean
    - contextPath: Darktrace.comment.comment.id
      description: Comment ID.
      type: string
    - contextPath: Darktrace.comment.comment.text
      description: Comment text.
      type: string
    description: Post a comment to a Darktrace ASM risk or asset within the Darktrace
      UI.
  - name: darktrace-asm-edit-comment
    arguments:
    - name: comment_id
      required: true
      description: Unique ID of Comment.
    - name: comment
      required: true
      description: Enter comment here.
    outputs:
    - contextPath: Darktrace.comment.success
      description: Whether or not comment was edited.
      type: boolean
    - contextPath: Darktrace.comment.comment.id
      description: Comment ID.
      type: string
    - contextPath: Darktrace.comment.comment.text
      description: Comment text.
      type: string
    description: Edit a comment within the Darktrace UI.
  - name: darktrace-asm-delete-comment
    arguments:
    - name: comment_id
      required: true
      description: Unique ID of Comment.
    outputs:
    - contextPath: Darktrace.comment.success
      description: Whether or not comment was deleted.
    description: Edit a comment within the Darktrace UI.
  - name: darktrace-asm-mitigate-risk
    arguments:
    - name: risk_id
      required: true
      description: Unique ID of Risk.
    outputs:
    - contextPath: Darktrace.risk.success
      description: Whether or not risk was mitigated.
      type: boolean
    description: Mitigate Darktrace ASM Risk within the Darktrace UI.
    execution: true
  - name: darktrace-asm-create-tag
    arguments:
    - name: tag_name
      required: true
      description: Name of Tag being created.
    outputs:
    - contextPath: Darktrace.tag.success
      description: Whether or not the tag was created.
      type: boolean
    - contextPath: Darktrace.tag.tag.id
      description: Tag ID.
      type: string
    - contextPath: Darktrace.tag.tag.name
      description: Tag name.
      type: string
    description: Create a tag to assign to Darktrace ASM Assets within the Darktrace
      UI.
  - name: darktrace-asm-assign-tag
    arguments:
    - name: tag_name
      required: true
      description: Name of tag to be assigned.
    - name: asset_id
      required: true
      description: ID of asset tag should be assigned to.
    outputs:
    - contextPath: Darktrace.tag.success
      description: Whether or not the tag was successfully assigned.
      type: boolean
    - contextPath: Darktrace.tag.asset.id
      description: Asset ID.
      type: string
    - contextPath: Darktrace.tag.asset.tags
      description: All tags assigned to asset.
    description: Assign an existing tag to a Darktrace ASM Asset within the Darktrace
      UI.
  - name: darktrace-asm-unassign-tag
    arguments:
    - name: tag_name
      required: true
      description: Name of Tag to be assigned.
    - name: asset_id
      required: true
      description: ID of asset tag should be assigned to.
    outputs:
    - contextPath: Darktrace.tag.success
      description: Whether or not the tag was successfully unassigned.
      type: boolean
    - contextPath: Darktrace.tag.asset.id
      description: Asset ID.
      type: string
    - contextPath: Darktrace.tag.asset.tags
      description: All tags assigned to asset.
    description: Unassign an existing tag to a Darktrace ASM Asset within the Darktrace
      UI.
  dockerimage: demisto/python3:3.9.8.24399
  isfetch: true
  runonce: false
  subtype: python3