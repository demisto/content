import pytest

from QutteraWebsiteMalwareScanner import scan_start, rescan_status, scan_report, report_malware, status_blacklist

SERVER_URL = "scannerapi.quttera.com"
HTTPS_BASE = f"https://{SERVER_URL}/api/v3"


class ResponseMock:
    start_scan = {'error': 200, 'errorstr': 'success'}
    rescan_status = {
        'error': 200,
        'errorstr': 'success',
        'status': {
            'blacklisted': 'no',
            'files': 12,
            'scanner_result': 'undef',
            'sensitivity': 'HEURISTIC',
            'state': 'SCAN',
            'time': 1653420189,
            'url': 'domain.test'
        }
    }
    scan_report_clean = {
        'error': 200,
        'errorstr': 'success',
        'status': {
            'blacklisted': 'no',
            'files': 16,
            'scanner_result': 'clean',
            'sensitivity': 'HEURISTIC',
            'state': 'DONE',
            'time': 1670147717,
            'url': 'domain.test'
        }
    }
    scan_report_in_progress = {
        'error': 200,
        'errorstr': 'success',
        'status': {
            'blacklisted': 'no',
            'files': 16,
            'scanner_result': 'clean',
            'sensitivity': 'HEURISTIC',
            'state': 'DOWNLOAD',
            'time': 1670147717,
            'url': 'domain.test'
        }
    }
    status_blacklist = {
        'error': 200,
        'errorstr': 'success',
        'status': {
            'blacklisted': 'no',
            'url': 'domain.test'
        }
    }
    report_malware = {
        'error': 200,
        'errorstr': 'success',
        'report': {
            'blacklist_report': {
                'blacklist_status': 'NoThreat',
                'providers': [
                    {
                        'name': 'Google',
                        'status': 'NoThreat',
                        'time': '1511222759'
                    },
                    {
                        'name': 'Google',
                        'status': 'NoThreat',
                        'time': '1511222759'
                    },
                    {
                        'name': 'MalwareDomainList',
                        'status': 'NoThreat',
                        'time': '1511222759'
                    },
                    {
                        'name': 'ZeusTracker',
                        'status': 'NoThreat',
                        'time': '1511222759'
                    }
                ]
            },
            'blacklisted_domains': {},
            'blacklisted_domains_count': 0,
            'blacklisted_iframes': {},
            'blacklisted_iframes_count': 0,
            'blacklisted_links': {},
            'blacklisted_links_count': 0,
            'domains': {
                'adssettings.google.com': 'NoThreat',
                'domain.test': 'NoThreat',
                'youtu.be': 'NoThreat'
            },
            'domains_count': 2,
            'files': [
                {
                    'MD5': '18912736AD1E68285BBD6087610FDBF7',
                    '_severity': 'clean',
                    'details': 'File is clean.',
                    'dumpMD5': '00000000000000000000000000000000',
                    'endtime': 'Sun Dec  4 11:18:29 2022',
                    'filename': 'domain.test/website-anti-malware-monitoring',
                    'filesize': '91356',
                    'filetype': 'HTML',
                    'layer': 'js-emulation-layer',
                    'line': '0',
                    'offset': '0',
                    'pattern_id': 'N/A',
                    'reason': 'No significant issues detected.',
                    'result': '1',
                    'scantime': '5.820000',
                    'threat': 'Clean',
                    'threat_name': 'Undefined'
                },
                {
                    'MD5': '91274D3E5EB68C1BABBD22B55C416698',
                    '_severity': 'clean',
                    'details': 'File is clean.',
                    'dumpMD5': '00000000000000000000000000000000',
                    'endtime': 'Sun Dec  4 11:18:37 2022',
                    'filename': 'domain.test/affiliates',
                    'filesize': '67062',
                    'filetype': 'HTML',
                    'layer': 'js-emulation-layer',
                    'line': '0',
                    'offset': '0',
                    'pattern_id': 'N/A',
                    'reason': 'No significant issues detected.',
                    'result': '1',
                    'scantime': '7.224000',
                    'threat': 'Clean',
                    'threat_name': 'Undefined'
                }
            ],
            'http_timeout': 0.844234,
            'iframes': {
                '<iframe class%3D"embed-responsive-item">': 'NoThreat',
                '<iframe width%3D"420" height%3D"315" >': 'NoThreat'
            },
            'iframes_count': 7,
            'links': {
                'http://docs.fortinet.com/document/fortisoar/1.0.0/quttera/404/quttera-v1-0-0': 'NoThreat',
                'http://domain.test/...': 'NoThreat',
                'https://youtu.be/zphj16hzj8g': 'NoThreat'
            }
        }
    }


class ClientMock:
    def __init__(self, params):
        self.mock_resp = params
        self.apikey = '1234'
        self.base_url = 'api.quttera'

    def _api_request(self, domain: str, method: str, operation: str):
        return self.mock_resp


@pytest.fixture(scope="function")
def client(client_args):
    return ClientMock(client_args)


@pytest.mark.parametrize('client_args', [ResponseMock.start_scan])
def test_start_scan(client):
    """
    Given
            mock BaseClient and domain to scan When
            Calling the start scan
    Then
            Test the scan trigger response
    """
    args = {
        "domain": "domain.test"
    }
    response = scan_start(client, args)
    assert response.outputs == ResponseMock.start_scan


@pytest.mark.parametrize('client_args', [ResponseMock.rescan_status])
def test_rescan_status(client):
    """
    Given
            mock BaseClient and domain to scan
    When
            Rescan the domain
    Then
            Test the scan trigger response
    """
    args = {
        "domain": "domain.test"
    }

    response = rescan_status(client, args)
    assert response.outputs == ResponseMock.rescan_status


@pytest.mark.parametrize('client_args', [ResponseMock.scan_report_clean])
def test_scan_status_clean(client):
    """
    Given
            mock BaseClient and domain to scan
    When
            Retrieve status of scanned domain
    Then
            Test the scan status response
    """
    args = {
        "domain": "domain.test"
    }

    response = scan_report(client, args)
    assert response.readable_output == "Domain domain.test is clean"


@pytest.mark.parametrize('client_args', [ResponseMock.scan_report_in_progress])
def test_scan_status_in_progress(client):
    """
    Given
            mock BaseClient and domain to scan
    When
            Retrieve status of scanned domain
    Then
            Test the scan status response
    """
    args = {
        "domain": "domain.test"
    }

    response = scan_report(client, args)
    assert response.readable_output == "Domain domain.test is being scanned"


@pytest.mark.parametrize('client_args', [ResponseMock.status_blacklist])
def test_blacklist_status(client):
    """
    Given
            mock BaseClient and domain to scan
    When
            Retrieve the info about blacklist status of the domain
    Then
            Test the blacklist status response
    """
    args = {
        "domain": "domain.test"
    }

    response = status_blacklist(client, args)
    assert response.readable_output == "Domain domain.test is NOT blacklisted"


@pytest.mark.parametrize('client_args', [ResponseMock.report_malware])
def test_report_malware(client):
    """
    Given
            mock BaseClient and domain to scan
    When
            Retrieve the malware report for given domain
    Then
            Test the malware status response
    """
    args = {
        "url": "domain.test"
    }

    response = report_malware(client, args)
    assert response.outputs == ResponseMock.report_malware


@pytest.mark.parametrize("client", [client])
@pytest.mark.parametrize("method", ["scan_start", "rescan_status", "scan_report", "status_blacklist"])
def test_valueerror(client, method):
    with pytest.raises(ValueError):
        globals()[method](client, {"domain": ""})


class Failure:
    response = {
        'error': 404,
        'errorstr': 'item not found'
    }


@pytest.mark.parametrize('client_args', [Failure.response])
@pytest.mark.parametrize("method", ["scan_start", "rescan_status"])
def test_failed_response(client, method):
    args = {
        "domain": "domain.test"
    }
    res = globals()[method](client, args)
    assert res.raw_response.get("errorstr") == "item not found"


@pytest.mark.parametrize('client_args', [Failure.response])
@pytest.mark.parametrize("method", ["scan_report"])
def test_failed_scan_report(client, method):
    args = {
        "domain": "domain.test"
    }
    res = globals()[method](client, args)
    assert res.readable_output == "Domain domain.test was not scanned. Scan it with !quttera-scan-start domain=domain.test"


class FailureBlacklist:
    response = {
        'error': 200,
        'errorstr': 'success',
        'status': {'blacklisted': 'no', 'url': 'domain.test'}
    }


@pytest.mark.parametrize('client_args', [FailureBlacklist.response])
@pytest.mark.parametrize("method", ["status_blacklist"])
def test_failed_status_blacklist(client, method):
    args = {
        "domain": "domain.test"
    }
    res = globals()[method](client, args)
    assert res.readable_output == "Domain domain.test is NOT blacklisted"
