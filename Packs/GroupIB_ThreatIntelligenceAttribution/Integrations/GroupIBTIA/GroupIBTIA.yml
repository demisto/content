category: Data Enrichment & Threat Intelligence
commonfields:
  id: Group-IB Threat Intelligence & Attribution
  version: -1
configuration:
- additionalinfo: The FQDN/IP the integration should connect to.
  defaultvalue: https://tap.group-ib.com/api/v2/
  display: GIB TI URL
  name: url
  required: true
  type: 0
- additionalinfo: The API Key and Username required to authenticate to the service.
  display: Username
  name: credentials
  required: true
  type: 9
- additionalinfo: Whether to allow connections without verifying SSL certificates
    validity.
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: Whether to use XSOAR system proxy settings to connect to the API.
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- additionalinfo: Type(s) of incidents to fetch from the third party API.
  display: Colletions to fetch
  hidden: false
  name: incident_collections
  options:
  - compromised/account_group
  - compromised/card
  - compromised/breached
  - bp/phishing
  - bp/phishing_kit
  - osi/git_repository
  - osi/public_leak
  - malware/targeted_malware
  required: false
  type: 16
- additionalinfo: Date to start fetching incidents from.
  defaultvalue: 3 days
  display: Incidents first fetch
  hidden: false
  name: first_fetch
  required: false
  type: 0
- additionalinfo: A number of requests per collection that integration sends in one
    fetch iteration (each request picks up to 200 incidents). If you face some runtime
    errors, lower the value.
  defaultvalue: '3'
  display: Number of requests per collection
  hidden: false
  name: max_fetch
  options:
  - '1'
  - '2'
  - '3'
  - '4'
  - '5'
  required: false
  type: 15
- display: Incident type
  name: incidentType
  required: false
  type: 13
description: "Pack helps to integrate Group-IB Threat Intelligence and get incidents\
  \ directly into Cortex XSOAR. \nThe list of included collections: \nCompromised\
  \ Accounts, Compromised Cards, Brand Protection Phishing, Brand Protection Phishing\
  \ Kit, OSI Git Leak, OSI Public Leak, Targeted Malware."
detaileddescription: "### Group-IB Threat Intelligence\n  \n  \n- This section explains\
  \ how to configure the instance of Threat Intelligence in Cortex XSOAR.  \n  \n\
  1. Open Group-IB TI web interface. (It may be either new interface: [https://tap.group-ib.com](https://tap.group-ib.com))\
  \  \n2. To generate API key(password):  \n2.1. In the new interface: click on your\
  \ name in the right upper corner -> choose **Profile** option -> switch to **Security\
  \ and Access** tab -> click **Personal token** -> follow instructions to generate\
  \ API token.  \n3. Your server URL is the same as your TI web interface URL.  \n\
  4. Your username is the email that you use to enter in the web interface.\n5. Set\
  \ classifier and mapper with Group-IB Threat Intelligence classifier and mapper\
  \ or with our own if you want so.\n6. Go to Settings->Integrations->Pre-Processing\
  \ Rules and set up the pre-processing rule:\n* Set up conditions: \"gibid Is not\
  \ empty (General)\" and \"Type Doesn't equal(String) GIB Data Breach\".\n* Action:\
  \ \"Run a script\".\n* Script: \"GIBIncidentUpdate\" (will recreate closed incidents\
  \ if they get an update, in other cases will update the existing one) or \"GIBIncidentUpdateIncludingClosed\"\
  (will only update incidents). \n7. Don't forget to contact Group-IB to add to allow\
  \ list your Cortex IP or public IP of a proxy that you are using with Cortex."
display: Group-IB Threat Intelligence
name: Group-IB Threat Intelligence & Attribution
script:
  commands:
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 253b9a136f0d574149fc43691eaf7ae27aff141a.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in compromised/account collection
      with provided ID.
    execution: false
    name: gibtia-get-compromised-account-info
    outputs:
    - contextPath: GIBTIA.CompromisedAccount.client.ipv4.asn
      description: Victim IP address.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.client.ipv4.countryName
      description: Country name.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.client.ipv4.ip
      description: Victim IP address.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.client.ipv4.region
      description: Region name.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.cnc.domain
      description: Event CNC domain.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.cnc.url
      description: CNC URL.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.cnc.ipv4.ip
      description: CNC IP address.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.dateCompromised
      description: Date of compromise.
      type: Date
    - contextPath: GIBTIA.CompromisedAccount.dateDetected
      description: Date of detection.
      type: Date
    - contextPath: GIBTIA.CompromisedAccount.dropEmail.email
      description: Email where compromised data were sent to.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.dropEmail.domain
      description: Email domain.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.login
      description: Compromised login.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.password
      description: Compromised password.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.malware.name
      description: Malware name.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.malware.id
      description: Group IB malware ID.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.person.name
      description: Card owner name.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.person.email
      description: Card owner e-mail.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.portalLink
      description: Link to GIB incident.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.threatActor.name
      description: Associated threat actor.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.threatActor.isAPT
      description: Is threat actor APT group.
      type: Boolean
    - contextPath: GIBTIA.CompromisedAccount.threatActor.id
      description: Threat actor GIB ID.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.id
      description: Group IB incident ID.
      type: String
    - contextPath: GIBTIA.CompromisedAccount.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: ecda6f4dc85596f447314ce01e2152db9c9d3cbc.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in compromised/card collection
      with provided ID.
    execution: false
    name: gibtia-get-compromised-card-info
    outputs:
    - contextPath: GIBTIA.CompromisedCard.cardInfo.cvv
      description: Compromised card CVV.
      type: String
    - contextPath: GIBTIA.CompromisedCard.cardInfo.issuer.issuer
      description: Card issuer.
      type: String
    - contextPath: GIBTIA.CompromisedCard.cardInfo.number
      description: Compromised card number.
      type: String
    - contextPath: GIBTIA.CompromisedCard.cardInfo.system
      description: Payment system.
      type: String
    - contextPath: GIBTIA.CompromisedCard.cardInfo.type
      description: Internal issuer card type.
      type: String
    - contextPath: GIBTIA.CompromisedCard.cardInfo.validThru
      description: Card expiration date.
      type: String
    - contextPath: GIBTIA.CompromisedCard.client.ipv4.asn
      description: Compromised client ASN.
      type: String
    - contextPath: GIBTIA.CompromisedCard.client.ipv4.countryName
      description: Country name.
      type: String
    - contextPath: GIBTIA.CompromisedCard.client.ipv4.ip
      description: Victim IP address.
      type: String
    - contextPath: GIBTIA.CompromisedCard.client.ipv4.region
      description: Region name.
      type: String
    - contextPath: GIBTIA.CompromisedCard.dateCompromised
      description: Date of compromise.
      type: Date
    - contextPath: GIBTIA.CompromisedCard.dateDetected
      description: Date detected.
      type: Date
    - contextPath: GIBTIA.CompromisedCard.malware.name
      description: Related malware name.
      type: String
    - contextPath: GIBTIA.CompromisedCard.malware.id
      description: Related GIB malware ID.
      type: String
    - contextPath: GIBTIA.CompromisedCard.portalLink
      description: Link to GIB incident.
      type: String
    - contextPath: GIBTIA.CompromisedCard.threatActor.name
      description: Associated  threat actor.
      type: String
    - contextPath: GIBTIA.CompromisedCard.threatActor.isAPT
      description: Is threat actor APT group.
      type: Boolean
    - contextPath: GIBTIA.CompromisedCard.threatActor.id
      description: Threat actor GIB ID.
      type: String
    - contextPath: GIBTIA.CompromisedCard.id
      description: Group IB incident ID.
      type: String
    - contextPath: GIBTIA.CompromisedCard.sourceType
      description: Information source.
      type: String
    - contextPath: GIBTIA.CompromisedCard.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 50a3b4abbfca5dcbec9c8b3a110598f61ba93r33.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in compromised/mule collection
      with provided ID.
    execution: false
    name: gibtia-get-compromised-mule-info
    outputs:
    - contextPath: GIBTIA.CompromisedMule.account
      description: Account number (card/phone), which was used by threat actor to
        cash out.
      type: String
    - contextPath: GIBTIA.CompromisedMule.cnc.ipv4.asn
      description: CNC ASN.
      type: String
    - contextPath: GIBTIA.CompromisedMule.cnc.ipv4.countryName
      description: Country name.
      type: String
    - contextPath: GIBTIA.CompromisedMule.cnc.ipv4.ip
      description: Victim IP address.
      type: String
    - contextPath: GIBTIA.CompromisedMule.cnc.ipv4.region
      description: Region name.
      type: String
    - contextPath: GIBTIA.CompromisedMule.cnc.url
      description: CNC URL.
      type: String
    - contextPath: GIBTIA.CompromisedMule.cnc.domain
      description: CNC domain.
      type: String
    - contextPath: GIBTIA.CompromisedMule.dateAdd
      description: Date of detection.
      type: Date
    - contextPath: GIBTIA.CompromisedMule.malware.name
      description: Malware name.
      type: String
    - contextPath: GIBTIA.CompromisedMule.portalLink
      description: Link to GIB incident.
      type: String
    - contextPath: GIBTIA.CompromisedMule.threatActor.name
      description: Associated threat actor.
      type: String
    - contextPath: GIBTIA.CompromisedMule.threatActor.id
      description: Threat actor GIB ID.
      type: String
    - contextPath: GIBTIA.CompromisedMule.threatActor.isAPT
      description: Is threat actor APT group.
      type: Boolean
    - contextPath: GIBTIA.CompromisedMule.id
      description: Group IB incident ID.
      type: String
    - contextPath: GIBTIA.CompromisedMule.sourceType
      description: Information source.
      type: String
    - contextPath: GIBTIA.CompromisedMule.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 0c1426048474df19ada9d0089ef8b3efce906556.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in compromised/imei collection
      with provided ID.
    execution: false
    name: gibtia-get-compromised-imei-info
    outputs:
    - contextPath: GIBTIA.CompromisedIMEI.client.ipv4.asn
      description: Compromised client ASN.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.client.ipv4.countryName
      description: Country name.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.client.ipv4.ip
      description: Victim IP address.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.client.ipv4.region
      description: Region name.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.cnc.domain
      description: CNC URL.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.cnc.ipv4.asn
      description: CNC ASN.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.cnc.ipv4.countryName
      description: CNC IP country name.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.cnc.ipv4.ip
      description: CNC IP address.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.cnc.ipv4.region
      description: CNC region name.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.dateCompromised
      description: Date compromised.
      type: Date
    - contextPath: GIBTIA.CompromisedIMEI.dateDetected
      description: Date detected.
      type: Date
    - contextPath: GIBTIA.CompromisedIMEI.device.imei
      description: Compromised IMEI.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.device.model
      description: Compromised device model.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.malware.name
      description: Associated malware.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.threatActor.id
      description: Associated threat actor ID.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.threatActor.name
      description: Associated threat actor.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.threatActor.isAPT
      description: Is threat actor APT group.
      type: Boolean
    - contextPath: GIBTIA.CompromisedIMEI.id
      description: Group IB incident ID.
      type: String
    - contextPath: GIBTIA.CompromisedIMEI.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 6fd344f340f4bdc08548cb36ded62bdf.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in compromised/breached collection
      with provided ID.
    execution: false
    name: gibtia-get-compromised-breached-info
    outputs:
    - contextPath: GIBTIA.DataBreach.email
      description: List of breached emails.
      type: String
    - contextPath: GIBTIA.DataBreach.leakName
      description: Name of the leak.
      type: String
    - contextPath: GIBTIA.DataBreach.password
      description: List of breached passwords.
      type: String
    - contextPath: GIBTIA.DataBreach.uploadTime
      description: Date of breached data upload.
      type: Date
    - contextPath: GIBTIA.DataBreach.id
      description: Group IB incident ID.
      type: String
    - contextPath: GIBTIA.DataBreach.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: f201c253ac71f7d78db39fa111a2af9d7ee7a3f7.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in osi/git_leak collection
      with provided ID.
    execution: false
    name: gibtia-get-osi-git-leak-info
    outputs:
    - contextPath: GIBTIA.GitLeak.dateDetected
      description: Leak detection date.
      type: Date
    - contextPath: GIBTIA.GitLeak.matchesType
      description: List of matches type.
      type: String
    - contextPath: GIBTIA.GitLeak.name
      description: GIT filename.
      type: String
    - contextPath: GIBTIA.GitLeak.repository
      description: GIT repository.
      type: String
    - contextPath: GIBTIA.GitLeak.revisions.file
      description: Leaked file link.
      type: String
    - contextPath: GIBTIA.GitLeak.revisions.fileDiff
      description: Leaked file diff.
      type: String
    - contextPath: GIBTIA.GitLeak.revisions.info.authorName
      description: Revision author.
      type: String
    - contextPath: GIBTIA.GitLeak.revisions.info.authorEmail
      description: Author name.
      type: String
    - contextPath: GIBTIA.GitLeak.revisions.info.dateCreated
      description: Revision creation date.
      type: Date
    - contextPath: GIBTIA.GitLeak.source
      description: Source(github/gitlab/etc.)
      type: String
    - contextPath: GIBTIA.GitLeak.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: a9a5b5cb9b971a2a037e3a0a30654185ea148095.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in osi/public_leak collection
      with provided ID.
    execution: false
    name: gibtia-get-osi-public-leak-info
    outputs:
    - contextPath: GIBTIA.PublicLeak.created
      description: Leak event detection date.
      type: Date
    - contextPath: GIBTIA.PublicLeak.data
      description: Leaked data.
      type: String
    - contextPath: GIBTIA.PublicLeak.hash
      description: Leak data hash.
      type: String
    - contextPath: GIBTIA.PublicLeak.linkList.author
      description: Leak entry author.
      type: String
    - contextPath: GIBTIA.PublicLeak.linkList.dateDetected
      description: Leak detection date.
      type: Date
    - contextPath: GIBTIA.PublicLeak.linkList.datePublished
      description: Leak publish date.
      type: Date
    - contextPath: GIBTIA.PublicLeak.linkList.hash
      description: Leak hash.
      type: String
    - contextPath: GIBTIA.PublicLeak.linkList.link
      description: Leak link.
      type: String
    - contextPath: GIBTIA.PublicLeak.linkList.source
      description: Leak source.
      type: String
    - contextPath: GIBTIA.PublicLeak.matches
      description: Matches.
      type: String
    - contextPath: GIBTIA.PublicLeak.portalLink
      description: Group IB portal link.
      type: String
    - contextPath: GIBTIA.PublicLeak.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.

        e.g.: CVE-2021-27152.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in osi/vulnerability collection
      with provided ID.
    execution: false
    name: gibtia-get-osi-vulnerability-info
    outputs:
    - contextPath: GIBTIA.OSIVulnerability.affectedSoftware.name
      description: Affected software name.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.affectedSoftware.operator
      description: Affected software version operator( ex. le=less or equal).
      type: String
    - contextPath: GIBTIA.OSIVulnerability.affectedSoftware.version
      description: Affected software version.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.bulletinFamily
      description: Bulletin family.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.cvss.score
      description: CVSS score.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.cvss.vector
      description: CVSS vector.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.dateLastSeen
      description: Date last seen.
      type: Date
    - contextPath: GIBTIA.OSIVulnerability.datePublished
      description: Date published.
      type: Date
    - contextPath: GIBTIA.OSIVulnerability.description
      description: Vulnerability description.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.id
      description: Vulnerability ID.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.reporter
      description: Vulnerability reporter.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.title
      description: Vulnerability title.
      type: String
    - contextPath: GIBTIA.OSIVulnerability.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 044f3f2cb599228c1882884eb77eb073f68a25f2.
      isArray: false
      name: id
      required: false
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in bp/phishing_kit and attacks/phishing_kit
      collections with provided ID.
    execution: false
    name: gibtia-get-phishing-kit-info
    outputs:
    - contextPath: GIBTIA.PhishingKit.dateDetected
      description: Phishing kit detection date.
      type: Date
    - contextPath: GIBTIA.PhishingKit.dateFirstSeen
      description: Phishing kit first seen date.
      type: Date
    - contextPath: GIBTIA.PhishingKit.dateLastSeen
      description: Phishing kit last seen date.
      type: Date
    - contextPath: GIBTIA.PhishingKit.downloadedFrom.fileName
      description: Phishing kit filename.
      type: String
    - contextPath: GIBTIA.PhishingKit.downloadedFrom.domain
      description: Phishing kit domain.
      type: String
    - contextPath: GIBTIA.PhishingKit.downloadedFrom.date
      description: Downloading date.
      type: Date
    - contextPath: GIBTIA.PhishingKit.downloadedFrom.url
      description: URL where phishing kit were downloaded from.
      type: String
    - contextPath: GIBTIA.PhishingKit.hash
      description: MD5 phishing kit hash.
      type: String
    - contextPath: GIBTIA.PhishingKit.portalLink
      description: Link to kit on GIB TI&A.
      type: String
    - contextPath: GIBTIA.PhishingKit.targetBrand
      description: Phishing kit target brand.
      type: String
    - contextPath: GIBTIA.PhishingKit.emails
      description: Emails found in phishing kit.
      type: String
    - contextPath: GIBTIA.PhishingKit.id
      description: GIB event ID.
      type: String
    - contextPath: GIBTIA.PhishingKit.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: fce7f92d0b64946cf890842d083953649b259952.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in bp/phishing and attacks/phishing
      collections with provided ID.
    execution: false
    name: gibtia-get-phishing-info
    outputs:
    - contextPath: GIBTIA.Phishing.dateDetected
      description: Date of phishing detection.
      type: Date
    - contextPath: GIBTIA.Phishing.dateBlocked
      description: Phishing resource block date.
      type: Unknown
    - contextPath: GIBTIA.Phishing.id
      description: GIB incident ID.
      type: String
    - contextPath: GIBTIA.Phishing.ipv4.asn
      description: Phishing resource ASN.
      type: String
    - contextPath: GIBTIA.Phishing.ipv4.countryName
      description: Phishing resource country name.
      type: String
    - contextPath: GIBTIA.Phishing.ipv4.ip
      description: Phishing resource IP address.
      type: String
    - contextPath: GIBTIA.Phishing.ipv4.region
      description: Phishing resource region name.
      type: String
    - contextPath: GIBTIA.Phishing.phishingDomain.domain
      description: Phishing domain.
      type: String
    - contextPath: GIBTIA.Phishing.phishingDomain.dateRegistered
      description: Phishing domain creation date.
      type: Date
    - contextPath: GIBTIA.Phishing.phishingDomain.registrar
      description: Phishing domain registrar name.
      type: String
    - contextPath: GIBTIA.Phishing.phishingDomain.title
      description: Phishing domain title.
      type: String
    - contextPath: GIBTIA.Phishing.targetBrand
      description: Phishing target name.
      type: String
    - contextPath: GIBTIA.Phishing.targetCategory
      description: Phishing target category (financial, government, etc.)
      type: String
    - contextPath: GIBTIA.Phishing.targetDomain
      description: Phishing target domain.
      type: String
    - contextPath: GIBTIA.Phishing.status
      description: Current status of phishing incident (blocked, in response, etc.)
      type: String
    - contextPath: GIBTIA.Phishing.url
      description: Phishing URL.
      type: String
    - contextPath: GIBTIA.Phishing.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 26a05baa4025edff367b058b13c6b43e820538a5.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in attacks/ddos collection
      with provided ID.
    execution: false
    name: gibtia-get-attacks-ddos-info
    outputs:
    - contextPath: GIBTIA.AttacksDDoS.cnc.url
      description: CNC URL.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.cnc.domain
      description: CNC domain.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.cnc.ipv4.asn
      description: CNC ASN.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.cnc.ipv4.countryName
      description: CNC IP country name.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.cnc.ipv4.ip
      description: CNC IP address.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.cnc.ipv4.region
      description: CNC region name.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.target.ipv4.asn
      description: DDoS target ASN.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.target.ipv4.countryName
      description: DDoS target country name.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.target.ipv4.ip
      description: DDoS target IP address.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.target.ipv4.region
      description: DDoS target region name.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.target.category
      description: DDoS target category.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.target.domain
      description: DDoS target domain.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.threatActor.id
      description: Associated threat actor ID.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.threatActor.name
      description: Associated threat actor.
      type: String
    - contextPath: GIBTIA.AttacksDdos.threatActor.isAPT
      description: Is threat actor APT.
      type: Boolean
    - contextPath: GIBTIA.AttacksDDoS.id
      description: GIB incident ID.
      type: String
    - contextPath: GIBTIA.AttacksDDoS.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 6009637a1135cd001ef46e21.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in attacks/deface collection
      with provided ID.
    execution: false
    name: gibtia-get-attacks-deface-info
    outputs:
    - contextPath: GIBTIA.AttacksDeface.date
      description: Date of deface.
      type: Date
    - contextPath: GIBTIA.AttacksDeface.id
      description: GIB incident ID.
      type: String
    - contextPath: GIBTIA.AttacksDeface.targetIp.asn
      description: Victim ASN.
      type: String
    - contextPath: GIBTIA.AttacksDeface.targetIp.countryName
      description: Victim country name.
      type: String
    - contextPath: GIBTIA.AttacksDeface.targetIp.region
      description: Victim IP region name.
      type: String
    - contextPath: GIBTIA.AttacksDeface.threatActor.id
      description: Associated threat actor ID.
      type: String
    - contextPath: GIBTIA.AttacksDeface.threatActor.name
      description: Associated threat actor.
      type: String
    - contextPath: GIBTIA.AttacksDeface.threatActor.isAPT
      description: Is threat actor APT.
      type: Boolean
    - contextPath: GIBTIA.AttacksDeface.url
      description: URL of compromised resource.
      type: String
    - contextPath: GIBTIA.AttacksDeface.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 1b09d389d016121afbffe481a14b30ea995876e4.
      isArray: false
      name: id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Is threat APT.
      isArray: false
      name: isAPT
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in hi/threat (or in apt/threat
      if the APT flag is true) collection with provided ID.
    execution: false
    name: gibtia-get-threat-info
    outputs:
    - contextPath: GIBTIA.Threat.contacts.account
      description: Threat accounts found in this threat action.
      type: String
    - contextPath: GIBTIA.Threat.contacts.flag
      description: Is account fake or not.
      type: String
    - contextPath: GIBTIA.Threat.contacts.service
      description: Account service.
      type: String
    - contextPath: GIBTIA.Threat.contacts.type
      description: Type of account(social_network/email/wallet etc.)
      type: String
    - contextPath: GIBTIA.Threat.countries
      description: Affected countries.
      type: String
    - contextPath: GIBTIA.Threat.createdAt
      description: Threat report creation date.
      type: Date
    - contextPath: GIBTIA.Threat.cveList.name
      description: List of abused CVE.
      type: String
    - contextPath: GIBTIA.Threat.dateFirstSeen
      description: Attack first seen date.
      type: Date
    - contextPath: GIBTIA.Threat.dateLastSeen
      description: Attack last seen date.
      type: Date
    - contextPath: GIBTIA.Threat.datePublished
      description: Date published.
      type: Date
    - contextPath: GIBTIA.Threat.description
      description: Threat description.
      type: String
    - contextPath: GIBTIA.Threat.forumsAccounts.url
      description: Related forum URL.
      type: String
    - contextPath: GIBTIA.Threat.forumsAccounts.nickname
      description: Related forums account.
      type: String
    - contextPath: GIBTIA.Threat.forumsAccounts.registeredAt
      description: Related forums account registration date.
      type: Date
    - contextPath: GIBTIA.Threat.forumsAccounts.messageCount
      description: Related forums messages count.
      type: Number
    - contextPath: GIBTIA.Threat.id
      description: GIB internal threat ID.
      type: String
    - contextPath: GIBTIA.Threat.indicators
      description: Can be either network or file indicators.
      type: String
    - contextPath: GIBTIA.Threat.langs
      description: Languages actors related.
      type: String
    - contextPath: GIBTIA.Threat.malwareList.name
      description: Related Malware Name.
      type: String
    - contextPath: GIBTIA.Threat.malwareList.id
      description: Related malware GIB internal ID.
      type: String
    - contextPath: GIBTIA.Threat.mitreMatrix.attackPatternId
      description: MITRE attack pattern ID.
      type: String
    - contextPath: GIBTIA.Threat.mitreMatrix.attackTactic
      description: MITRE attack tactic name.
      type: String
    - contextPath: GIBTIA.Threat.mitreMatrix.attackType
      description: MITRE attack type.
      type: String
    - contextPath: GIBTIA.Threat.mitreMatrix.id
      description: MITRE attack id.
      type: String
    - contextPath: GIBTIA.Threat.regions
      description: Regions affected by attack.
      type: String
    - contextPath: GIBTIA.Threat.reportNumber
      description: GIB report number.
      type: String
    - contextPath: GIBTIA.Threat.sectors
      description: Affected sectors.
      type: String
    - contextPath: GIBTIA.Threat.shortDescription
      description: Short description.
      type: String
    - contextPath: GIBTIA.Threat.title
      description: Threat title.
      type: String
    - contextPath: GIBTIA.Threat.targetedCompany
      description: Targeted company name.
      type: String
    - contextPath: GIBTIA.Threat.ThreatActor.name
      description: Threat actor name.
      type: String
    - contextPath: GIBTIA.Threat.ThreatActor.id
      description: Threat actor ID.
      type: String
    - contextPath: GIBTIA.Threat.ThreatActor.isAPT
      description: Is threat actor APT group.
      type: Boolean
    - contextPath: GIBTIA.Threat.sources
      description: Sources links.
      type: String
    - contextPath: GIBTIA.Threat.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB internal threatActor ID.
        e.g.: 0d4496592ac3a0f5511cd62ef29887f48d9cb545.
      isArray: false
      name: id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Is threat actor APT group.
      isArray: false
      name: isAPT
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in hi/threat_actor (or in
      apt/threat_actor if the APT flag is true) collection with provided ID.
    execution: false
    name: gibtia-get-threat-actor-info
    outputs:
    - contextPath: GIBTIA.ThreatActor.aliases
      description: Threat actor aliases.
      type: String
    - contextPath: GIBTIA.ThreatActor.country
      description: Threat actor country.
      type: String
    - contextPath: GIBTIA.ThreatActor.createdAt
      description: Threat actor record creation time.
      type: Date
    - contextPath: GIBTIA.ThreatActor.description
      description: Threat actor description.
      type: String
    - contextPath: GIBTIA.ThreatActor.goals
      description: Threat actor goals sectors(financial, diplomatic, etc.)
      type: String
    - contextPath: GIBTIA.ThreatActor.id
      description: Threat actor id.
      type: String
    - contextPath: GIBTIA.ThreatActor.isAPT
      description: Threat actor is APT.
      type: Boolean
    - contextPath: GIBTIA.ThreatActor.labels
      description: GIB internal threat actor labels(hacker, nation-state, etc.)
      type: String
    - contextPath: GIBTIA.ThreatActor.langs
      description: Threat actor communication language.
      type: String
    - contextPath: GIBTIA.ThreatActor.name
      description: Threat actor name.
      type: String
    - contextPath: GIBTIA.ThreatActor.roles
      description: Threat actor roles.
      type: String
    - contextPath: GIBTIA.ThreatActor.stat.countries
      description: Threat actor countries activity found in.
      type: String
    - contextPath: GIBTIA.ThreatActor.stat.dateFirstSeen
      description: Date first seen.
      type: Date
    - contextPath: GIBTIA.ThreatActor.stat.dateLastSeen
      description: Date last seen.
      type: Date
    - contextPath: GIBTIA.ThreatActor.stat.regions
      description: Threat actor activity regions.
      type: String
    - contextPath: GIBTIA.ThreatActor.stat.reports.datePublished
      description: Related threat report publishing date.
      type: Date
    - contextPath: GIBTIA.ThreatActor.stat.reports.id
      description: Related threat report id.
      type: String
    - contextPath: GIBTIA.ThreatActor.stat.reports.name.en
      description: Related threat report language.
      type: String
    - contextPath: GIBTIA.ThreatActor.stat.sectors
      description: Sectors attacked by threat actor.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 109.70.100.46.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in suspicious_ip/tor_node
      collection with provided ID.
    execution: false
    name: gibtia-get-suspicious-ip-tor-node-info
    outputs:
    - contextPath: GIBTIA.SuspiciousIPTorNode.ipv4.asn
      description: Tor node ASN.
      type: String
    - contextPath: GIBTIA.SuspiciousIPTorNode.ipv4.countryName
      description: Tor node IP country name.
      type: String
    - contextPath: GIBTIA.SuspiciousIPTorNode.ipv4.ip
      description: Tor node IP address.
      type: String
    - contextPath: GIBTIA.SuspiciousIPTorNode.ipv4.region
      description: Tor node IP region name.
      type: String
    - contextPath: GIBTIA.SuspiciousIPTorNode.id
      description: GIB id.
      type: String
    - contextPath: GIBTIA.SuspiciousIPTorNode.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: cc6a2856da2806b03839f81aa214f22dbcfd7369.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in suspicious_ip/open_proxy
      collection with provided ID.
    execution: false
    name: gibtia-get-suspicious-ip-open-proxy-info
    outputs:
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.asn
      description: Proxy ASN.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.countryName
      description: Proxy IP country name.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.ip
      description: Proxy IP address.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.region
      description: Proxy IP region name.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.port
      description: Proxy port.
      type: Number
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.source
      description: Information source.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.ipv4.anonymous
      description: Proxy anonymous level.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.id
      description: GIB event ID.
      type: String
    - contextPath: GIBTIA.SuspiciousIPOpenProxy.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 02e385600dfc5bf9b3b3656df8e0e20f5fc5c86e.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in suspicious_ip/socks_proxy
      collection with provided ID.
    execution: false
    name: gibtia-get-suspicious-ip-socks-proxy-info
    outputs:
    - contextPath: GIBTIA.SuspiciousIPSocksProxy.ipv4.asn
      description: Proxy IP ASN.
      type: String
    - contextPath: GIBTIA.SuspiciousIPSocksProxy.ipv4.countryName
      description: Proxy IP country name.
      type: String
    - contextPath: GIBTIA.SuspiciousIPSocksProxy.ipv4.ip
      description: Proxy IP address.
      type: String
    - contextPath: GIBTIA.SuspiciousIPSocksProxy.ipv4.region
      description: Proxy IP region name.
      type: String
    - contextPath: GIBTIA.SuspiciousIPSocksProxy.id
      description: GIB ID.
      type: String
    - contextPath: GIBTIA.SuspiciousIPSocksProxy.evaluation.severity
      description: Event severity.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: 5bbd38acf0b9e4f04123af494d485f6c49221e98.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in malware/targeted_malware
      collection with provided ID.
    execution: false
    name: gibtia-get-malware-targeted-malware-info
    outputs:
    - contextPath: GIBTIA.TargetedMalware.date
      description: Date malware detected.
      type: Date
    - contextPath: GIBTIA.TargetedMalware.fileName
      description: Malware file name.
      type: String
    - contextPath: GIBTIA.TargetedMalware.fileType
      description: Malware file type.
      type: String
    - contextPath: GIBTIA.TargetedMalware.id
      description: GIB internal incident ID.
      type: String
    - contextPath: GIBTIA.TargetedMalware.injectDump
      description: Inject dump.
      type: String
    - contextPath: GIBTIA.TargetedMalware.injectMd5
      description: MD5 hash of injection dump.
      type: String
    - contextPath: GIBTIA.TargetedMalware.malware.name
      description: GIB internal malware ID.
      type: String
    - contextPath: GIBTIA.TargetedMalware.md5
      description: MD5 hash of malware file.
      type: String
    - contextPath: GIBTIA.TargetedMalware.sha1
      description: SHA1 hash of malware file.
      type: String
    - contextPath: GIBTIA.TargetedMalware.sha256
      description: SHA256 hash of malware file.
      type: String
    - contextPath: GIBTIA.TargetedMalware.size
      description: Malware size in bytes.
      type: Number
    - contextPath: GIBTIA.TargetedMalware.source
      description: Malware source.
      type: String
    - contextPath: GIBTIA.TargetedMalware.portalLink
      description: GIB portal incident link.
      type: String
    - contextPath: GIBTIA.TargetedMalware.threatActor.name
      description: Related threat actor.
      type: String
    - contextPath: GIBTIA.TargetedMalware.threatActor.id
      description: GIB internal threat actor ID.
      type: String
    - contextPath: GIBTIA.TargetedMalware.threatActor.isAPT
      description: Is threat actor APT.
      type: Boolean
    - contextPath: GIBTIA.TargetedMalware.evaluation.severity
      description: Event severity.
      type: String
  - deprecated: false
    description: Returns list of available collections.
    execution: false
    name: gibtia-get-available-collections
    outputs:
    - contextPath: GIBTIA.OtherInfo.collections
      description: List of availiable collections.
      type: String
  - arguments:
    - default: false
      description: |-
        GIB event id.
        e.g.: aeed277396e27e375d030a91533aa232444d0089.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Command performs Group IB event lookup in malware/cnc collection
      by provided ID.
    execution: false
    name: gibtia-get-malware-cnc-info
    outputs:
    - contextPath: GIBTIA.MalwareCNC.dateDetected
      description: Date CNC detected.
      type: Date
    - contextPath: GIBTIA.MalwareCNC.dateLastSeen
      description: Date CNC last seen.
      type: Date
    - contextPath: GIBTIA.MalwareCNC.url
      description: CNC URL.
      type: String
    - contextPath: GIBTIA.MalwareCNC.domain
      description: CNC domain.
      type: String
    - contextPath: GIBTIA.MalwareCNC.ipv4.asn
      description: CNC ASN.
      type: String
    - contextPath: GIBTIA.MalwareCNC.ipv4.countryName
      description: CNC IP country name.
      type: String
    - contextPath: GIBTIA.MalwareCNC.ipv4.ip
      description: CNC IP address.
      type: String
    - contextPath: GIBTIA.MalwareCNC.ipv4.region
      description: CNC region name.
      type: String
    - contextPath: GIBTIA.MalwareCNC.malwareList.name
      description: Associated malware.
      type: String
    - contextPath: GIBTIA.MalwareCNC.threatActor.id
      description: Associated threat actor ID.
      type: String
    - contextPath: GIBTIA.MalwareCNC.threatActor.name
      description: Associated threat actor.
      type: String
    - contextPath: GIBTIA.MalwareCNC.threatActor.isAPT
      description: Is APT or not.
      type: Boolean
    - contextPath: GIBTIA.MalwareCNC.id
      description: GIB event ID.
      type: String
  - arguments:
    - default: false
      description: |-
        Query you want to search.
        e.g.: 8.8.8.8.
      isArray: false
      name: query
      required: true
      secret: false
    deprecated: false
    description: Command performs global Group IB search.
    execution: false
    name: gibtia-global-search
    outputs:
    - contextPath: apiPath
      description: Name of collection in which found matches.
      type: String
    - contextPath: count
      description: Count of feeds matching this query.
      type: Number
    - contextPath: GIBLink
      description: Link to GIB TI&A interface.
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: Collection you want to search.
      isArray: false
      name: collection_name
      predefined:
      - compromised/account
      - compromised/card
      - compromised/mule
      - compromised/imei
      - attacks/ddos
      - attacks/deface
      - attacks/phishing
      - attacks/phishing_kit
      - bp/phishing
      - bp/phishing_kit
      - hi/threat
      - hi/threat_actor
      - apt/threat
      - apt/threat_actor
      - osi/git_leak
      - osi/vulnerability
      - osi/public_leak
      - suspicious_ip/tor_node
      - suspicious_ip/open_proxy
      - suspicious_ip/socks_proxy
      - malware/cnc
      - malware/targeted_malware
      required: true
      secret: false
    - default: false
      description: |-
        Query you want to search.
        e.g.: 8.8.8.8.
      isArray: false
      name: query
      required: true
      secret: false
    - default: false
      description: Start date of search session.
      isArray: false
      name: date_from
      required: false
      secret: false
    - default: false
      description: End date of search session.
      isArray: false
      name: date_to
      required: false
      secret: false
    deprecated: false
    description: Command performs Group IB search in selected collection.
    execution: false
    name: gibtia-local-search
    outputs:
    - contextPath: id
      description: Id of a feed that matches a query.
      type: String
    - contextPath: additional_info
      description: Additional info about feed.
      type: String
  dockerimage: demisto/python3:3.10.13.78960
  feed: false
  isfetch: true
  longRunning: false
  longRunningPort: false
  runonce: false
  script: |-
    """ IMPORTS """

    import json
    from datetime import datetime, timedelta
    from typing import Dict, Generator, List, Optional, Tuple, Union

    import dateparser
    import urllib3
    import random
    from requests.auth import HTTPBasicAuth

    # Disable insecure warnings
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    """ CONSTANTS """

    DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"
    MAPPING: dict = {
        "compromised/account_group": {
            "date":
                "dateFirstSeen",
            "name":
                "login",
            "prefix":
                "Compromised Account",
            "indicators":
                [
                    {
                        "main_field": "events.cnc.url", "main_field_type": "URL"
                    },
                    {
                        "main_field": "events.cnc.domain", "main_field_type": "Domain"
                    },
                    {
                        "main_field": "events.cnc.ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["events.cnc.ipv4.asn", "events.cnc.ipv4.countryName", "events.cnc.ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    },
                    {
                        "main_field": "events.client.ipv4.ip",
                    }
                ]
        },
        "compromised/card": {
            "date":
                "dateDetected",
            "name":
                "cardInfo.number",
            "prefix":
                "Compromised Card",
            "indicators":
                [
                    {
                        "main_field": "cnc.url", "main_field_type": "URL"
                    },
                    {
                        "main_field": "cnc.domain", "main_field_type": "Domain"
                    },
                    {
                        "main_field": "cnc.ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["cnc.ipv4.asn", "cnc.ipv4.countryName", "cnc.ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "compromised/breached": {
            "date":
                "uploadTime",
            "name":
                "email",
            "prefix":
                "Data Breach",
            "indicators": []
        },
        "bp/phishing": {
            "date":
                "dateDetected",
            "name":
                "phishingDomain.domain",
            "prefix":
                "Phishing",
            "indicators":
                [
                    {
                        "main_field": "url", "main_field_type": "URL"
                    },
                    {
                        "main_field": "phishingDomain.domain", "main_field_type": "Domain",
                        "add_fields": ["phishingDomain.registrar"],
                        "add_fields_types": ["registrarname"]
                    },
                    {
                        "main_field": "ipv4.ip", "main_field_type": "IP"
                    }
                ]
        },
        "bp/phishing_kit": {
            "date":
                "dateDetected",
            "name":
                "hash",
            "prefix":
                "Phishing Kit",
            "indicators":
                [
                    {
                        "main_field": "emails", "main_field_type": "Email"
                    }
                ]
        },
        # "bp/domain": {
        #     "date":
        #         "ts_create",
        #     "name":
        #         "attrs.domain",
        #     "prefix":
        #         "Phishing Domain",
        #     "indicators":
        #         [
        #             {
        #                 "main_field": "attrs.domain", "main_field_type": "Domain",
        #                 "add_fields": ["phishingDomain.registrar"],
        #                 "add_fields_types": ["registrarname"]
        #             },
        #             {
        #                 "main_field": "attrs.server_ip", "main_field_type": "IP",
        #                 "add_fields": ["attrs.server_ip_asn", "attrs.server_ip_country_name", "attrs.server_ip_region"],
        #                 "add_fields_types": ["asn", "geocountry", "geolocation"]
        #             }
        #         ]
        # },
        "osi/git_repository": {
            "date":
                "dateDetected",
            "name":
                "name",
            "prefix":
                "Git Leak",
        },
        "osi/public_leak": {
            "date":
                "created",
            "name":
                "hash",
            "prefix":
                "Public Leak",
        },
        "malware/targeted_malware": {
            "date":
                "date",
            "name":
                "injectMd5",
            "prefix":
                "Targeted Malware",
            "indicators":
                [
                    {
                        "main_field": "md5", "main_field_type": "File",
                        "add_fields": ["fileName", "md5", "sha1", "sha256", "size"],
                        "add_fields_types": ["gibfilename", "md5", "sha1", "sha256", "size"]
                    }
                ]
        },


        "compromised/mule": {
            "name":
                "account",
            "prefix":
                "Compromised Mule",
            "indicators":
                [
                    {
                        "main_field": "cnc.url", "main_field_type": "URL",
                    },
                    {
                        "main_field": "cnc.domain", "main_field_type": "Domain",
                    },
                    {
                        "main_field": "cnc.ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["cnc.ipv4.asn", "cnc.ipv4.countryName", "cnc.ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "compromised/imei": {
            "name":
                "device.imei",
            "prefix":
                "Compromised IMEI",
            "indicators":
                [
                    {
                        "main_field": "cnc.url", "main_field_type": "URL",
                    },
                    {
                        "main_field": "cnc.domain", "main_field_type": "Domain",
                    },
                    {
                        "main_field": "cnc.ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["cnc.ipv4.asn", "cnc.ipv4.countryName", "cnc.ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "attacks/ddos": {
            "name":
                "target.ipv4.ip",
            "prefix":
                "Attacks DDoS",
            "indicators":
                [
                    {
                        "main_field": "cnc.url", "main_field_type": "URL",
                    },
                    {
                        "main_field": "cnc.domain", "main_field_type": "Domain",
                    },
                    {
                        "main_field": "cnc.ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["cnc.ipv4.asn", "cnc.ipv4.countryName", "cnc.ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    },
                ]
        },
        "attacks/deface": {
            "name":
                "url",
            "prefix":
                "Attacks Deface",
            "indicators":
                [
                    {
                        "main_field": "url", "main_field_type": "URL",
                    },
                    {
                        "main_field": "targetDomain", "main_field_type": "Domain",
                    },
                    {
                        "main_field": "targetIp.ip", "main_field_type": "IP",
                        "add_fields": ["targetIp.asn", "targetIp.countryName", "targetIp.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "attacks/phishing": {
            "name":
                "phishingDomain.domain",
            "prefix":
                "Phishing",
            "indicators":
                [
                    {
                        "main_field": "url", "main_field_type": "URL",
                    },
                    {
                        "main_field": "phishingDomain.domain", "main_field_type": "Domain",
                        "add_fields": ["phishingDomain.registrar"],
                        "add_fields_types": ["registrarname"]
                    },
                    {
                        "main_field": "ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["ipv4.asn", "ipv4.countryName", "ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "attacks/phishing_kit": {
            "name":
                "emails",
            "prefix":
                "Phishing Kit",
            "indicators":
                [
                    {
                        "main_field": "emails", "main_field_type": "Email",
                    }
                ]
        },
        "apt/threat": {
            "prefix":
                "Threat",
            "indicators":
                [
                    {
                        "main_field": "indicators.params.ipv4", "main_field_type": "IP",
                    },
                    {
                        "main_field": "indicators.params.domain", "main_field_type": "Domain",
                    },
                    {
                        "main_field": "indicators.params.url", "main_field_type": "URL",
                    },
                    {
                        "main_field": "indicators.params.hashes.md5", "main_field_type": "File",
                        "add_fields":
                        [
                            "indicators.params.name", "indicators.params.hashes.md5",
                            "indicators.params.hashes.sha1",
                            "indicators.params.hashes.sha256", "indicators.params.size"
                        ],
                        "add_fields_types": ["gibfilename", "md5", "sha1", "sha256", "size"]
                    }
                ]
        },
        "hi/threat": {
            "prefix":
                "Threat",
            "indicators":
                [
                     {
                         "main_field": "indicators.params.ipv4", "main_field_type": "IP",
                     },
                    {
                         "main_field": "indicators.params.domain", "main_field_type": "Domain",
                     },
                    {
                         "main_field": "indicators.params.url", "main_field_type": "URL",
                     },
                    {
                         "main_field": "indicators.params.hashes.md5", "main_field_type": "File",
                         "add_fields":
                             [
                                 "indicators.params.name", "indicators.params.hashes.md5",
                                 "indicators.params.hashes.sha1",
                                 "indicators.params.hashes.sha256", "indicators.params.size"
                             ],
                         "add_fields_types": ["gibfilename", "md5", "sha1", "sha256", "size"]
                     }
                ]
        },
        "suspicious_ip/tor_node": {
            "name":
                "ipv4.ip",
            "prefix":
                "Suspicious IP Tor Node",
            "indicators":
                [
                    {
                        "main_field": "ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["ipv4.asn", "ipv4.countryName", "ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "suspicious_ip/open_proxy": {
            "name":
                "ipv4.ip",
            "prefix":
                "Suspicious IP Open Proxy",
            "indicators":
                [
                    {
                        "main_field": "ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["ipv4.asn", "ipv4.countryName", "ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "suspicious_ip/socks_proxy": {
            "name":
                "ipv4.ip",
            "prefix":
                "Suspicious IP Socks Proxy",
            "indicators":
                [
                    {
                        "main_field": "ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["ipv4.asn", "ipv4.countryName", "ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "malware/cnc": {
            "name":
                "ipv4.ip",
            "prefix":
                "Malware CNC",
            "indicators":
                [
                    {
                        "main_field": "url", "main_field_type": "URL"
                    },
                    {
                        "main_field": "domain", "main_field_type": "Domain"
                    },
                    {
                        "main_field": "ipv4.ip", "main_field_type": "IP",
                        "add_fields": ["ipv4.asn", "ipv4.countryName", "ipv4.region"],
                        "add_fields_types": ["asn", "geocountry", "geolocation"]
                    }
                ]
        },
        "osi/vulnerability": {
            "name":
                "id",
            "prefix":
                "OSI Vulnerability",
            "indicators":
                [
                    {
                        "main_field": "id", "main_field_type": "CVE",
                        "add_fields": ["cvss.score", "description", "dateLastSeen", "datePublished"],
                        "add_fields_types": ["cvss", "cvedescription", "cvemodified", "published"]
                    }
                ]
        },
        "hi/threat_actor": {"prefix": "Threat Actor"},
        "apt/threat_actor": {"prefix": "Threat Actor"}
    }

    STATUS_CODE_MSGS = {
        401: "Bad Credentials",
        403: "Something is wrong with your account, please, contact GIB.",
        404: "Not found. There is no such data on server.",
        500: "There are some troubles on server with your request.",
        301: "Verify that your public IP is whitelisted by Group IB.",
        302: "Verify that your public IP is whitelisted by Group IB."
    }

    # LEGACY_HEADERS = {
    #     "Accept": "application/json",
    #     'Connection': 'Keep-Alive',
    #     'Keep-Alive': "30"
    # }

    TIMEOUT = 60.
    RETRIES = 4
    STATUS_LIST_TO_RETRY = [429, 500]


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def _create_update_generator(self, collection_name: str, max_requests: int,
                                     date_from: Optional[str] = None, seq_update: Union[int, str] = None,
                                     limit: int = 200) -> Generator:
            """
            Creates generator of lists with feeds class objects for an update session
            (feeds are sorted in ascending order) `collection_name` with set parameters.

            `seq_update` allows you to receive all relevant feeds. Such a request uses the seq_update parameter,
            you will receive a portion of feeds that starts with the next `seq_update` parameter for the current collection.
            For all feeds in the Group IB Intelligence continuous numbering is carried out.
            For example, the `seq_update` equal to 1999998 can be in the `compromised/accounts` collection,
            and a feed with seq_update equal to 1999999 can be in the `attacks/ddos` collection.
            If item updates (for example, if new attacks were associated with existing APT by our specialists
            or tor node has been detected as active again), the item gets a new parameter and it automatically rises
            in the database and "becomes relevant" again.

            :param collection_name: collection to update.
            :param max_requests: a maximum number of requests to API.
            :param date_from: start date of update session.
            :param seq_update: identification number from which to start the session.
            """
            requests_count = 0
            while True:
                if requests_count >= max_requests:
                    break
                session = requests.Session()
                session.auth = HTTPBasicAuth(self._auth[0], self._auth[1])

                session.headers["Accept"] = "*/*"
                session.headers["User-Agent"] = f'SOAR/CortexSOAR/{self._auth[0]}/unknown'

                params = {'df': date_from, 'limit': limit, 'seqUpdate': seq_update}
                params = {key: value for key, value in params.items() if value}
                portion = session.get(url=f'{self._base_url}{collection_name}/updated', params=params, timeout=60).json()

                # params = {"df": date_from, "seqUpdate": seq_update}
                # params = assign_params(**params)
                # portion = self._http_request(method="GET", url_suffix=collection_name + "/updated",
                #                              params=params, timeout=TIMEOUT, retries=RETRIES,
                #                              status_list_to_retry=STATUS_LIST_TO_RETRY)
                if portion.get("count") == 0:
                    break
                seq_update = portion.get("seqUpdate")
                date_from = None
                requests_count += 1

                yield portion.get("items"), seq_update

        def _create_search_generator(self, collection_name: str, max_requests: int, date_to: str = None,
                                     page: int = 0, starting_date_from: str = None,
                                     starting_date_to: str = None, limit: int = 200) -> Generator:
            """
            Creates generator of lists with feeds for the search session for ingestion purpose
            (feeds are sorted in descending order) for `collection_name` with set parameters. This version solves problem
            with a large number of feeds with the same date.

            :param collection_name: collection to search.
            :param max_requests: a maximum number of requests to API.
            :param date_to: current search location.
            :param page: number of pages from start.
            :param starting_date_from: global down border for a session.
            :param starting_date_to: global upper border for a session.
            """

            requests_count = 0
            result_id = None
            no_data_flag = 0
            while True:
                if requests_count >= max_requests or no_data_flag:
                    break

                if page and not result_id:
                    k = 0
                    while k != page:
                        if result_id:
                            params = {'resultId': result_id}
                        else:
                            params = {'df': starting_date_from, 'dt': date_to}
                        params = assign_params(**params)
                        portion = self._http_request(method="GET", url_suffix=collection_name,
                                                     params=params, timeout=TIMEOUT, retries=RETRIES,
                                                     status_list_to_retry=STATUS_LIST_TO_RETRY)
                        result_id = portion.get("resultId")
                        k += 1

                if result_id:
                    params = {'resultId': result_id}
                else:
                    params = {'df': starting_date_from, 'dt': date_to}
                params = assign_params(**params)
                portion = self._http_request(method="GET", url_suffix=collection_name,
                                             params=params, timeout=TIMEOUT, retries=RETRIES,
                                             status_list_to_retry=STATUS_LIST_TO_RETRY)

                requests_count += 1
                data = portion.get('items')
                if len(data) < 100:
                    no_data_flag = 1
                    page = 0
                    starting_date_from = (dateparser.parse(starting_date_to)   # type: ignore
                                          + timedelta(seconds=1)).strftime(DATE_FORMAT)
                    starting_date_to = datetime.now().strftime(DATE_FORMAT)
                    date_to = starting_date_to
                else:
                    if data[0].get("uploadTime") == data[-1].get("uploadTime"):
                        page += 1
                    else:
                        result_id = None
                        page = 0
                        for i in range(len(data) - 1, -1, -1):
                            if data[i].get("uploadTime") != data[-1].get("uploadTime"):
                                upload_time_parsed = dateparser.parse(data[i].get("uploadTime"))
                                assert upload_time_parsed is not None, f'could not parse {data[i].get("uploadTime")}'
                                date_to = (upload_time_parsed - timedelta(seconds=1)).strftime(DATE_FORMAT)
                                data = data[:i + 1:]
                                break

                last_fetch = {"starting_date_from": starting_date_from, "page": page,
                              "starting_date_to": starting_date_to, "current_date_to": date_to}
                yield data, last_fetch

        # def _create_legacy_generator(self, action: str, max_requests: int, last: Optional[str] = None) -> Generator:
        #     """
        #     Legacy generator is similar to update generator.
        #
        #     :param action: collection to search.
        #     :param max_requests: a maximum number of requests to API.
        #     :param last: identification number from which to start the session.
        #     """
        #     requests_count = 0
        #     while True:
        #         if requests_count >= max_requests:
        #             break
        #
        #         params = {"action": action, "last": last, "module": "get", "lang": 3}
        #         params = assign_params(**params)
        #         portion = self._http_request(method="GET", full_url="https://bt.group-ib.com",
        #                                      headers=LEGACY_HEADERS, params=params, timeout=TIMEOUT, retries=RETRIES,
        #                                      status_list_to_retry=STATUS_LIST_TO_RETRY)
        #         if portion.get("status") != 200:
        #             if portion.get("status") in STATUS_CODE_MSGS:
        #                 raise DemistoException(STATUS_CODE_MSGS[portion.get("status")])
        #             else:
        #                 raise DemistoException(
        #                     "Something is wrong, status code {0} for request to APIv1".format(portion.get("status"))
        #                 )
        #         portion = portion.get("data")
        #
        #         if portion.get("count") == 0:
        #             break
        #         last = portion.get("last")
        #         requests_count += 1
        #
        #         yield portion.get("new"), last
        #
        # def _legacy_get_last(self, date_from, action):
        #     """
        #     Get last for a certain date.
        #
        #     :param action: collection to search.
        #     :param date_from: date to get the "last" identifier.
        #     """
        #     params = {"action": "get_last", "date": date_from, "module": "get", "type": action}
        #     params = assign_params(**params)
        #     resp = self._http_request(method="GET", full_url="https://bt.group-ib.com",
        #                               headers=LEGACY_HEADERS, params=params, timeout=TIMEOUT, retries=RETRIES,
        #                               status_list_to_retry=STATUS_LIST_TO_RETRY)
        #     if resp.get("status") != 200:
        #         if resp.get("status") in STATUS_CODE_MSGS:
        #             raise DemistoException(STATUS_CODE_MSGS[resp.get("status")])
        #         else:
        #             raise DemistoException(
        #                 "Something is wrong, status code {0} for request to APIv1".format(resp.get("status"))
        #             )
        #     last = resp.get("data")
        #     return last

        def create_poll_generator(self, collection_name: str, max_requests: int, **kwargs):
            """
            Interface to work with different types of indicators.
            """

            # Handle first time fetch
            date_from = None
            last_fetch = kwargs.get("last_fetch")
            if not last_fetch:
                date_from = dateparser.parse(kwargs.get("first_fetch_time"))  # type: ignore
                if date_from is None:
                    raise DemistoException('Inappropriate first_fetch format, '
                                           'please use something like this: 2020-01-01 or January 1 2020 or 3 days')
                date_from = date_from.strftime('%Y-%m-%d')  # type: ignore

            if collection_name == "compromised/breached":
                # we need the isinstance check for BC because it used to be a string
                if last_fetch and isinstance(last_fetch, dict):
                    starting_date_from = last_fetch.get("starting_date_from")
                    starting_date_to = last_fetch.get("starting_date_to")
                    date_to = last_fetch.get("current_date_to")
                    page = last_fetch.get("page", 0)
                else:
                    starting_date_from = date_from
                    starting_date_to = datetime.now().strftime(DATE_FORMAT)
                    date_to = starting_date_to
                    page = 0
                return self._create_search_generator(collection_name=collection_name, max_requests=max_requests,
                                                     date_to=date_to, page=page, starting_date_from=starting_date_from,
                                                     starting_date_to=starting_date_to)
            # elif collection_name == "bp/domain":
            #     if not last_fetch:
            #         last_fetch = self._legacy_get_last(date_from=date_from, action="domain")
            #     return self._create_legacy_generator(action="domain", max_requests=max_requests, last=last_fetch)
            else:
                return self._create_update_generator(collection_name=collection_name, max_requests=max_requests,
                                                     date_from=date_from, seq_update=last_fetch)  # type: ignore

        def create_manual_generator(self, collection_name: str, date_from: str = None,
                                    date_to: str = None, query: str = None) -> Generator:
            """
            Creates generator of lists with feeds for the search session
            (feeds are sorted in descending order) for `collection_name` with set parameters.

            :param collection_name: collection to search.
            :param date_from: start date of search session.
            :param date_to: end date of search session.
            :param query: query to search.
            """

            result_id = None
            while True:
                params = {'df': date_from, 'dt': date_to, 'resultId': result_id, 'q': query}
                params = assign_params(**params)
                portion = self._http_request(method="GET", url_suffix=collection_name,
                                             params=params, timeout=TIMEOUT, retries=RETRIES,
                                             status_list_to_retry=STATUS_LIST_TO_RETRY)
                if portion.get('count') > 2000:
                    raise DemistoException('Portion is too large (count > 2000), this can cause timeout in Demisto.'
                                           'Please, change or set date_from/date_to arguments or change query.')
                if len(portion.get('items')) == 0:
                    break
                result_id = portion.get("resultId")
                date_from, date_to, query = None, None, None
                yield portion.get('items')

        def search_feed_by_id(self, collection_name: str, feed_id: str) -> Dict:
            """
            Searches for feed with `feed_id` in collection with `collection_name`.

            :param collection_name: in what collection to search.
            :param feed_id: id of feed to search.
            """
            portion = self._http_request(method="GET", url_suffix=collection_name + "/" + feed_id, timeout=TIMEOUT,
                                         retries=RETRIES, status_list_to_retry=STATUS_LIST_TO_RETRY,
                                         backoff_factor=random.random() * 10 + 1)

            return portion

        def get_available_collections(self):
            """
            Gets list of available collections from GIB TI&A API.
            """

            response = self._http_request(method="GET", url_suffix="user/granted_collections",
                                          timeout=TIMEOUT, retries=RETRIES,
                                          status_list_to_retry=STATUS_LIST_TO_RETRY)
            buffer_list = find_element_by_key(response, 'collection')

            # buffer_list = list(response.get("list").keys())
            #
            # try:
            #     self._http_request(method="GET", url_suffix="compromised/breached", params={"limit": 1},
            #                        timeout=TIMEOUT, retries=RETRIES, status_list_to_retry=STATUS_LIST_TO_RETRY)
            #     buffer_list.append("compromised/breached")
            # except Exception:
            #     pass
            #
            # # legacy collection
            # try:
            #     params = {"action": "get_last", "date": datetime.now().strftime("%Y-%m-%d"),
            #               "module": "get", "type": "domain"}
            #     response = self._http_request(method="GET", full_url="https://bt.group-ib.com",
            #                                   headers=LEGACY_HEADERS, params=params, timeout=TIMEOUT, retries=RETRIES,
            #                                   status_list_to_retry=STATUS_LIST_TO_RETRY)
            #     last = response.get("data")
            #     params = {"action": "domain", "last": last, "module": "get"}
            #     portion = self._http_request(method="GET", full_url="https://bt.group-ib.com",
            #                                  headers=LEGACY_HEADERS, params=params, timeout=TIMEOUT, retries=RETRIES,
            #                                  status_list_to_retry=STATUS_LIST_TO_RETRY)
            #     if portion.get("status") == 200:
            #         buffer_list.append("bp/domain")
            # except Exception:
            #     pass

            collections_list = []
            for key in MAPPING.keys():
                if key in buffer_list:
                    collections_list.append(key)
            return {"collections": collections_list}, buffer_list

        def search_by_query(self, q):
            results = self._http_request(method="GET", url_suffix="search", params={'q': q},
                                         timeout=TIMEOUT, retries=RETRIES,
                                         status_list_to_retry=STATUS_LIST_TO_RETRY)
            return results


    def test_module(client: Client) -> str:
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        :param client: GIB_TI&A client
        :return: 'ok' if test passed, anything else will fail the test.
        """

        collections_list, _ = client.get_available_collections()
        for collection in collections_list.get("collections"):
            if collection not in MAPPING.keys():
                return "Test failed, some problems with getting available collections."
        return "ok"


    """ Support functions """


    def find_element_by_key(obj, key):
        """
        Recursively finds element or elements in dict.
        """

        path = key.split(".", 1)
        if len(path) == 1:
            if isinstance(obj, list):
                return [i.get(path[0]) for i in obj if i not in ["255.255.255.255", "0.0.0.0", ""]]
            elif isinstance(obj, dict):
                if obj.get(path[0]) in ["255.255.255.255", "0.0.0.0", ""]:
                    return None
                else:
                    return obj.get(path[0])
            else:
                if obj in ["255.255.255.255", "0.0.0.0", ""]:
                    return None
                else:
                    return obj
        else:
            if isinstance(obj, list):
                return [find_element_by_key(i.get(path[0]), path[1]) for i in obj]
            elif isinstance(obj, dict):
                return find_element_by_key(obj.get(path[0]), path[1])
            else:
                if obj in ["255.255.255.255", "0.0.0.0", ""]:
                    return None
                else:
                    return obj


    def transform_to_command_results(iocs, ioc_type, fields, fields_names, collection_name):
        """
        Recursively ties together and transforms indicator data.
        """

        parsed_info = []
        if isinstance(iocs, list):
            for i, ioc in enumerate(iocs):
                buf_fields = []
                for field in fields:
                    if isinstance(field, list):
                        buf_fields.append(field[i])
                    else:
                        buf_fields.append(field)
                parsed_info.extend(transform_to_command_results(ioc, ioc_type, buf_fields, fields_names, collection_name))
            return parsed_info
        else:
            if iocs is None:
                return []

            fields = {fields_names[i]: fields[i] for i in range(len(fields_names)) if fields[i] is not None}

            output = parse_to_outputs(iocs, ioc_type, fields)
            if output:
                results = [CommandResults(
                    readable_output=tableToMarkdown("{0} indicator".format(ioc_type), {"value": iocs, **fields}),
                    indicator=output,
                    ignore_auto_extract=True
                )]
                return results
            else:
                return []


    def parse_to_outputs(value, indicator_type, fields):
        def calculate_dbot_score(type_):
            severity = fields.get("severity")
            if severity == "green":
                score = Common.DBotScore.GOOD
            elif severity == "orange":
                score = Common.DBotScore.SUSPICIOUS
            elif severity == "red":
                score = Common.DBotScore.BAD
            else:
                score = Common.DBotScore.NONE

            return Common.DBotScore(
                indicator=value,
                indicator_type=type_,
                integration_name="GIB TI&A",
                score=score
            )

        if indicator_type == "IP":
            return Common.IP(ip=value, asn=fields.get("asn"), geo_country=fields.get("geocountry"),
                             geo_description=fields.get("geolocation"),
                             dbot_score=calculate_dbot_score(DBotScoreType.IP))
        elif indicator_type == "Domain":
            return Common.Domain(domain=value, registrar_name=fields.get("registrarname"),
                                 dbot_score=calculate_dbot_score(DBotScoreType.DOMAIN))
        elif indicator_type == "File":
            return Common.File(md5=value, sha1=fields.get("sha1"), sha256=fields.get("sha256"),
                               name=fields.get("gibfilename"), size=fields.get("size"),
                               dbot_score=calculate_dbot_score(DBotScoreType.FILE))
        elif indicator_type == "URL":
            return Common.URL(url=value, dbot_score=calculate_dbot_score(DBotScoreType.URL))
        elif indicator_type == "CVE":
            return Common.CVE(id=value, cvss=fields.get("cvss"), published=fields.get("published"),
                              modified=fields.get("cvemodified"), description=fields.get("cvedescription"))
        return None


    def find_iocs_in_feed(feed: Dict, collection_name: str) -> List:
        """
        Finds IOCs in the feed and transform them to the appropriate format to ingest them into Demisto.

        :param feed: feed from GIB TI&A.
        :param collection_name: which collection this feed belongs to.
        """

        indicators = []
        indicators_info = MAPPING.get(collection_name, {}).get("indicators", [])
        for i in indicators_info:
            main_field = find_element_by_key(feed, i["main_field"])
            main_field_type = i["main_field_type"]
            add_fields = []
            add_fields_list = i.get("add_fields", []) + ["evaluation.severity"]
            add_fields_types = i.get("add_fields_types", []) + ["severity"]
            for j in add_fields_list:
                add_fields.append(find_element_by_key(feed, j))
            parsed_info = transform_to_command_results(main_field, main_field_type,
                                                       add_fields, add_fields_types, collection_name)
            indicators.extend(parsed_info)

        return indicators


    def transform_some_fields_into_markdown(collection_name, feed: Dict) -> Dict:
        """
        Some fields can have complex nesting, so this function transforms them into an appropriate state.

        :param collection_name: which collection this feed belongs to.
        :param feed: feed from GIB TI&A that needs transformation.
        :return: given feed with transformed fields.
        """

        if collection_name == "osi/git_repository":
            buffer = ""
            files = feed.get("files", [])
            for i in files:
                url = i.get("url")
                date = i.get("dateCreated")
                # file_diff = "[https://bt.group-ib.com/api/v2/osi/git_leak]({0})".format(i.get("fileDiff"))
                # info = find_element_by_key(i,'revisions.info')
                author_email = ''.join(find_element_by_key(i, 'revisions.info.authorEmail'))
                author_name = ''.join(find_element_by_key(i, 'revisions.info.authorName'))
                timestamp = ''.join(str(find_element_by_key(i, 'revisions.info.timestamp')))
                # author_email, author_name, date = info.get("authorEmail"), info.get("authorName"), info.get("dateCreated")
                buffer += "| {0} | {1} | {2} | {3} | {4} |\n".format(url, author_email, author_name, date, timestamp)
            if buffer:
                buffer = "| URL  |   Author Email  | Author Name  | Date Created| TimeStamp    |\n" \
                         "| ---- | --------------- | ------------ | ----------- | ------------ |\n" + buffer
                feed["files"] = buffer
            else:
                del feed["files"]

        elif collection_name == "osi/public_leak":
            buffer = ""
            link_list = feed.get("linkList", [])
            for i in link_list:
                author = i.get("author")
                detected = i.get("dateDetected")
                published = i.get("datePublished")
                hash_ = i.get("hash")
                link = "[{0}]({0})".format(i.get("link"))
                source = i.get("source")
                buffer += "| {0} | {1} | {2} | {3} | {4} | {5} |\n".format(author, detected, published, hash_, link, source)
            if buffer:
                buffer = "| Author | Date Detected | Date Published | Hash | Link | Source |\n" \
                         "| ------ | ------------- | -------------- | ---- |----- | ------ |\n" + buffer
                feed["linkList"] = buffer
            else:
                del feed["linkList"]

            buffer = ""
            matches = feed.get("matches", {})
            if isinstance(matches, list):
                matches = {}
            for type_, sub_dict in matches.items():
                for sub_type, sub_list in sub_dict.items():
                    for value in sub_list:
                        buffer += "| {0} | {1} | {2} |\n".format(type_, sub_type, value)
            if buffer:
                buffer = "| Type | Sub Type | Value |\n" \
                         "| ---- | -------- | ----- |\n" + buffer
                feed["matches"] = buffer
            else:
                del feed["matches"]

        elif collection_name == "bp/phishing_kit":
            buffer = ""
            downloaded_from = feed.get("downloadedFrom", [])
            for i in downloaded_from:
                date, url, domain, filename = i.get("date"), i.get("url"), i.get("domain"), i.get("fileName")
                buffer += "| {0} | {1} | {2} | {3} |\n".format(url, filename, domain, date)
            if buffer:
                buffer = "| URL | File Name | Domain | Date |\n| --- | --------- | ------ | ---- |\n" + buffer
                feed["downloadedFrom"] = buffer
            else:
                del feed["downloadedFrom"]

        return feed


    def get_human_readable_feed(collection_name, feed):
        return tableToMarkdown(name="Feed from {0} with ID {1}".format(collection_name, feed.get("id")),
                               t=feed, removeNull=True)


    def transform_function(result, previous_keys="", is_inside_list=False):
        result_dict = {}
        additional_tables: List[Any] = []

        if isinstance(result, dict):
            if is_inside_list:
                additional_tables.append(result)
            else:
                for key, value in result.items():
                    sub_key = previous_keys + " " + key if previous_keys else key
                    transformed_part, additional_info = transform_function(value, previous_keys=sub_key,
                                                                           is_inside_list=is_inside_list)
                    result_dict.update(transformed_part)
                    additional_tables.extend(additional_info)

            return result_dict, additional_tables

        elif isinstance(result, list):
            is_inside_list = True
            for value in result:
                transformed_part, additional_info = transform_function(value, previous_keys=previous_keys,
                                                                       is_inside_list=is_inside_list)
                additional_tables.extend(additional_info)
                if result_dict.get(previous_keys) is None:
                    result_dict.update(transformed_part)
                else:
                    result_dict[previous_keys].extend(transformed_part[previous_keys])

            if additional_tables:
                additional_tables = [CommandResults(
                    readable_output=tableToMarkdown("{0} table".format(previous_keys), additional_tables, removeNull=True),
                    ignore_auto_extract=True
                )]

            return result_dict, additional_tables

        elif isinstance(result, (str, int, float)) or result is None:
            if not is_inside_list:
                result_dict.update({previous_keys: result})
            else:
                result_dict.update({previous_keys: [result]})

            return result_dict, additional_tables


    """ Commands """


    def fetch_incidents_command(client: Client, last_run: Dict, first_fetch_time: str,
                                incident_collections: List, requests_count: int) -> Tuple[Dict, List]:
        """
        This function will execute each interval (default is 1 minute).

        :param client: GIB_TI&A_Feed client.
        :param last_run: the greatest sequpdate we fetched from last fetch.
        :param first_fetch_time: if last_run is None then fetch all incidents since first_fetch_time.
        :param incident_collections: list of collections enabled by client.
        :param requests_count: count of requests to API per collection.

        :return: next_run will be last_run in the next fetch-incidents; incidents and indicators will be created in Demisto.
        """
        incidents = []
        next_run: Dict[str, Dict[str, Union[int, Any]]] = {"last_fetch": {}}
        for collection_name in incident_collections:
            last_fetch = last_run.get("last_fetch", {}).get(collection_name)

            portions = client.create_poll_generator(collection_name=collection_name, max_requests=requests_count,
                                                    last_fetch=last_fetch, first_fetch_time=first_fetch_time)
            for portion, last_fetch in portions:
                for feed in portion:
                    mapping = MAPPING.get(collection_name, {})
                    if collection_name == "compromised/breached":
                        feed.update({"name": mapping.get("prefix", "") + ": " + ', '.join(
                            find_element_by_key(feed, mapping.get("name")))})
                    else:
                        feed.update({"name": mapping.get("prefix", "") + ": " + str(
                            find_element_by_key(feed, mapping.get("name")))})

                    feed.update({"gibType": collection_name})

                    severity = feed.get("evaluation", {}).get("severity")
                    system_severity = 0
                    if severity == "green":
                        system_severity = 1
                    elif severity == "orange":
                        system_severity = 2
                    elif severity == "red":
                        system_severity = 3

                    related_indicators_data = []
                    indicators_info = MAPPING.get(collection_name, {}).get("indicators", [])
                    for i in indicators_info:
                        if find_element_by_key(feed, i["main_field"]) is not None:
                            related_indicators_data.append(find_element_by_key(feed, i["main_field"]))

                    incident_created_time = dateparser.parse(feed.get(mapping.get("date")))
                    assert incident_created_time is not None
                    feed.update({"relatedIndicatorsData": related_indicators_data})
                    feed.update({"systemSeverity": system_severity})
                    if collection_name in ["osi/git_repository", "osi/public_leak", "bp/phishing_kit"]:
                        feed = transform_some_fields_into_markdown(collection_name, feed)
                    incident = {
                        "name": feed["name"],
                        "occurred": incident_created_time.strftime(DATE_FORMAT),
                        "rawJSON": json.dumps(feed)
                    }
                    incidents.append(incident)

            next_run["last_fetch"][collection_name] = last_fetch

        return next_run, incidents


    def get_available_collections_command(client: Client, args):
        """
        Returns list of available collections to context and War Room.

        :param client: GIB_TI&A_Feed client.
        """

        result, buffer_list = client.get_available_collections()
        readable_output = tableToMarkdown(name="Available collections", t=result, headers="collections")
        return CommandResults(
            outputs_prefix="GIBTIA.OtherInfo",
            outputs_key_field="collections",
            outputs=result,
            readable_output=readable_output,
            ignore_auto_extract=True,
            raw_response=buffer_list
        )


    def get_info_by_id_command(collection_name: str):
        """
        Decorator around actual commands, that returns command depends on `collection_name`.
        """

        def get_info_by_id_for_collection(client: Client, args: Dict) -> List[CommandResults]:
            """
            This function returns additional information to context and War Room.

            :param client: GIB_TI&A_Feed client.
            :param args: arguments, provided by client.
            """
            results = []
            coll_name = collection_name
            id_ = str(args.get("id"))

            if coll_name in ["threat", "threat_actor"]:
                flag = args.get("isAPT")
                if flag:
                    coll_name = "apt/" + coll_name
                else:
                    coll_name = "hi/" + coll_name
                result = client.search_feed_by_id(coll_name, id_)
                if "displayOptions" in result:
                    del result["displayOptions"]

            else:
                result = client.search_feed_by_id(coll_name, id_)
                if "isFavourite" in result:
                    del result["isFavourite"]
                if "isHidden" in result:
                    del result["isHidden"]

            if "seqUpdate" in result:
                del result["seqUpdate"]

            indicators: List[CommandResults] = []
            if coll_name not in ["apt/threat_actor", "hi/threat_actor"]:
                indicators = find_iocs_in_feed(result, coll_name)

            if coll_name in ["apt/threat", "hi/threat"]:
                del result["indicatorMalwareRelationships"], result["indicatorRelationships"], \
                    result["indicatorToolRelationships"], result["indicatorsIds"], \
                    result["indicators"]

            if coll_name == "compromised/breached":
                if "updateTime" in result:
                    del result["updateTime"]
                main_table_data, additional_tables = result, []
            else:
                main_table_data, additional_tables = transform_function(result)
            results.append(CommandResults(
                outputs_prefix="GIBTIA.{0}".format(MAPPING.get(coll_name, {}).get("prefix", "").replace(" ", "")),
                outputs_key_field="id",
                outputs=result,
                readable_output=get_human_readable_feed(collection_name, main_table_data),
                raw_response=result,
                ignore_auto_extract=True
            ))
            results.extend(additional_tables)
            results.extend(indicators)
            return results

        return get_info_by_id_for_collection


    def global_search_command(client: Client, args: Dict):
        query = str(args.get('query'))
        raw_response = client.search_by_query(query)
        handled_list = []
        for result in raw_response:
            if result.get('apiPath') in MAPPING.keys():
                handled_list.append({'apiPath': result.get('apiPath'), 'count': result.get('count'),
                                     'GIBLink': result.get('link'),
                                     'query': result.get('apiPath') + '?q=' + query})
        if len(handled_list) != 0:
            results = CommandResults(
                outputs_prefix="GIBTIA.search.global",
                outputs_key_field="query",
                outputs=handled_list,
                readable_output=tableToMarkdown('Search results', t=handled_list,
                                                headers=['apiPath', 'count', 'GIBLink'],
                                                url_keys=['GIBLink']),
                raw_response=raw_response,
                ignore_auto_extract=True
            )
        else:
            results = CommandResults(
                raw_response=raw_response,
                ignore_auto_extract=True,
                outputs=[],
                readable_output="Did not find anything for your query :("
            )
        return results


    def local_search_command(client: Client, args: Dict):
        query, date_from, date_to = args.get('query'), args.get('date_from', None), args.get('date_to', None)
        collection_name = str(args.get('collection_name'))

        if date_from is not None:
            date_from_parsed = dateparser.parse(date_from)
            if date_from_parsed is None:
                raise DemistoException('Inappropriate date_from format, '
                                       'please use something like this: 2020-01-01 or January 1 2020')
            date_from_parsed = date_from_parsed.strftime('%Y-%m-%dT%H:%M:%SZ')
        else:
            date_from_parsed = date_from  # type: ignore
        if date_to is not None:
            date_to_parsed = dateparser.parse(date_to)
            if date_to_parsed is None:
                raise DemistoException('Inappropriate date_to format, '
                                       'please use something like this: 2020-01-01 or January 1 2020')
            date_to_parsed = date_to_parsed.strftime('%Y-%m-%dT%H:%M:%SZ')
        else:
            date_to_parsed = date_to  # type: ignore

        portions = client.create_manual_generator(collection_name=collection_name, query=query,
                                                  date_from=date_from_parsed, date_to=date_to_parsed)
        result_list = []
        name = MAPPING.get(collection_name, {}).get('name')
        for portion in portions:
            for feed in portion:
                add_info = None
                if name is not None:
                    add_info = name + ": " + str(find_element_by_key(feed, name))
                result_list.append({'id': feed.get('id'), 'additional_info': add_info})

        results = CommandResults(
            outputs_prefix="GIBTIA.search.local",
            outputs_key_field="id",
            outputs=result_list,
            readable_output=tableToMarkdown('Search results', t=result_list,
                                            headers=['id', 'additional_info']),
            ignore_auto_extract=True
        )
        return results


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        username = params.get("credentials").get("identifier")
        password = params.get("credentials").get("password")
        base_url = str(params.get("url"))
        proxy = params.get("proxy", False)
        verify_certificate = not params.get("insecure", False)

        incident_collections = params.get("incident_collections", [])
        incidents_first_fetch = params.get("first_fetch", "3 days").strip()
        requests_count = int(params.get("max_fetch", 3))

        args = demisto.args()
        command = demisto.command()
        LOG(f"Command being called is {command}")
        try:
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                auth=(username, password),
                proxy=proxy,
                headers={"Accept": "*/*"}
            )

            commands = {
                "gibtia-get-compromised-account-info": get_info_by_id_command("compromised/account_group"),
                "gibtia-get-compromised-card-info": get_info_by_id_command("compromised/card"),
                "gibtia-get-compromised-mule-info": get_info_by_id_command("compromised/mule"),
                "gibtia-get-compromised-imei-info": get_info_by_id_command("compromised/imei"),
                "gibtia-get-compromised-breached-info": get_info_by_id_command("compromised/breached"),
                "gibtia-get-phishing-kit-info": get_info_by_id_command("attacks/phishing_kit"),
                "gibtia-get-phishing-info": get_info_by_id_command("attacks/phishing"),
                "gibtia-get-osi-git-leak-info": get_info_by_id_command("osi/git_repository"),
                "gibtia-get-osi-public-leak-info": get_info_by_id_command("osi/public_leak"),
                "gibtia-get-osi-vulnerability-info": get_info_by_id_command("osi/vulnerability"),
                "gibtia-get-attacks-ddos-info": get_info_by_id_command("attacks/ddos"),
                "gibtia-get-attacks-deface-info": get_info_by_id_command("attacks/deface"),
                "gibtia-get-threat-info": get_info_by_id_command("threat"),
                "gibtia-get-threat-actor-info": get_info_by_id_command("threat_actor"),
                "gibtia-get-suspicious-ip-tor-node-info": get_info_by_id_command("suspicious_ip/tor_node"),
                "gibtia-get-suspicious-ip-open-proxy-info": get_info_by_id_command("suspicious_ip/open_proxy"),
                "gibtia-get-suspicious-ip-socks-proxy-info": get_info_by_id_command("suspicious_ip/socks_proxy"),
                "gibtia-get-malware-targeted-malware-info": get_info_by_id_command("malware/targeted_malware"),
                "gibtia-get-malware-cnc-info": get_info_by_id_command("malware/cnc"),
                "gibtia-get-available-collections": get_available_collections_command,
                "gibtia-global-search": global_search_command,
                "gibtia-local-search": local_search_command
            }

            if command == "test-module":
                # This is the call made when pressing the integration Test button.
                result = test_module(client)
                demisto.results(result)

            elif command == "fetch-incidents":
                # Set and define the fetch incidents command to run after activated via integration settings.
                next_run, incidents = fetch_incidents_command(client=client, last_run=demisto.getLastRun(),
                                                              first_fetch_time=incidents_first_fetch,
                                                              incident_collections=incident_collections,
                                                              requests_count=requests_count)
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
            else:
                return_results(commands[command](client, args))

        # Log exceptions
        except Exception as e:
            return_error(f"Failed to execute {demisto.command()} command. Error: {str(e)}")


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()
  subtype: python3
  type: python
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAvwAAAB6CAYAAADDLodjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAB31SURBVHgB7d3tmRy3lQXgQz76LzmBFeQALHoDMGHvf4tyAGZLAZiSAjBLCkCiNgBNUQGQVACrLm0AFpmABwxgTToBzfYxGp5mc3qmP3BRQNV5nwemSI6s+kLVxcUt1C20ya3anVV7f9U+WLV313/m1n//3rptCxu/vl61l6t2vv6Vf/YcIrLN4fT+Ri8Q+91zqL+JiIgUcwv1c6vmEQOOu+vfvwcbKRhhYDKs22uIzIdDuf5Gz9dtQOx3GgSIiIhkVmvA71ft3qp9hMss4liGVXu2aj/gMlPZEh7HO5iHgDhAS03B43486ulvAbHPsb89Q9ss+h6v60eYpg75Det2LLdqC8xLwOW9VPfQNi2Q/17OaojHOJ1ftzkJUGzyBo/4IHu1aheVtp9X7T7GD4oO0aPe41nqnD1FDCY8bLPVLfGov79x287Q7sOhR/5jco7psriGOpzGG21XSy3dQ+9jPsmj1i2R/zr4EXl0yL9trfarJWYUm3AHHyDueCsnKbUztBH492jruJZoS7Q3cMuh5f52Dg2203GYKovrpsNpvNF2tdzOEZ9/Cv7rtUT+866A374tMcHYhIHHQ9SdXTzkBHnUq0dbx3OsDjZlU+pvbGeY72D7HNNlca10OI032q6ptDTrLXVZIv+5VsBftnFWzSOj2ygrBR7niCd9ClMYHrFznWF+GeMp8IiBGa/J+5iWKfY3WuAyy+ggImNhlr/HNO+fImPiO2CMLf+OTH2rZMDPUoKpBR6bFoj79w0UhLTIYVoPrqn3N1og3hAfQkTG5HB5//QQkVy4FHa/ak9wYmxZIuBnBoAPZb4gOIcXJj/DPMpEpsohdq5Ws8dz628OcVBzDg20RcbmEO8/THxpgQSRfD5GzPYfneCyDvjTC4Ie8+IQg0bd9Nq1QHxwtfRi2lz7GznEoF/ZfpHxMfHFe5GDiOTCpfS7VfsOR8SWVgG/w2WWcc5002ubQzx/n6FuDupvSQdl+0Vq4BDvn/cgIjl9smp/w4HPOYuA36P+lWtKctBNr3Wcqak1c+yh/rbNQX1OpAbMQqY1/EUkH9b2c+Ukt++/kDvgZ0nBEsqubUs3PZUbtKtDfedP/W039TmRevRQ0C+SWwr69yrvyRnw88GqkoLrdVAA0rIO9ZT3qL/tp0OcoRGRcfXQTKRIbgz6n+zzg7kCfgYfHWQfHRT0t4zBo8e4uA0dZF8cpJ1BRMbGWTcHEcnp96v29U0/lCPgV7B/uA4K+ls25kOLgWvtLxHXaAEF/SJjY+nBElq9TiQ3xgX+uh84NeBXsH+8DgrcWsWH1RjBI/vbAnKsBRT0i4zNQQkvkdy4ZOe1Wf5TAn4F+6eroTxEjuNRdsCm/pbHAqrpFxnbjdlIETkYvxu0My45NuDncncdJAfVNLaLQXiJqWmuxtNBcvkMml0TGZsG3iJ5Mcv/V+yIS44J+B00LZ5TWj5Q2sNzZx04csSu1Xjy0+yayLh4b9NSnSJ5MS5ZXPUX7+Dw/6NaX7gJq/Z81V6v2ssdP/M+4oCF238H9eC2MAD5HNIaZt8ZkL9Gfg51DwZfr1vY+D29t/GrQ70v6PHY/haX2y8iZfHe+Rgikguz/H/EFYnCQwN+/h84jI+BxTPEAP+n9a/H8Kv2IWKJkse4mCn+YdUGSEtSlr9Dfh3qKfcKiNdm6m/8/b6DnDTAdrjsczUMuNPL17+HiIyBfZBZfgX9Ivn4dRtwpMWqXYzYXiEOODxsuPU+LgFcjNTOkV8PFNn2ObdXyO8BUGz7d7Xlejsc8nMYv7+lZlWW1SP/tp5juizObYfTeKPtUrtsS0huPKa5z9OPyKND/m1Te7t12LJvht9hvGW0mEX8FnZlE0lAfECzecRg5D7KcognqUPdmOGtpfyIGaL3Eb82x8yxR3nv4cTR9BaH8a4B9jFm2ziDNsBOwGV/c4j7W7q/JSynG3D8TKHIofhMs3ye7Yv3rncR++AdjFN+55H3/inzw3v3t6hDQOxHqaQ1zWg7lPVnHBlH9Cg/Onm13tgx6389Ykat9H7n3Oce+bdxibqxRKtH2fN2hnyeAkW2ebtxUD1mf3MYb0Zqifx65N/Oc0yXxXntcBpvtF0OdXIYZ+ZNCxPkZXH+as7w59o2Swz6e5SLKX/BEc/zO4U2brM9RV0v+nUou/85lyvrkX/7lmiDQ7kAMldZzwIw39arzqdDPRzGKfXJXdrTI/82nmO6LM5ph9N4o+1yqJ9DueSDRVnknC2R/xwp4M/DoUxcwoB/sfkf3mdZzpKrhHCK85NV+xh1THcmHWLJSEAZDDwc5FQB8YLnNWV9PaWynlM9RDk8JizN4kurAfUIiNvEbSt5H+Cxr3VFIZHSAuKzuEQ/zHX/FKldQIxLvoAtrtbz4eYf3BTwL1Au8AyIS+T1qFNADEJK1flavUg4Rz3KLL946sozDDgdygiI13PNU+nctpLLZpb4roJIa9gPea+wDvpPvX+KtISVHNZBv9v8zU0Bf6lsI4PoFtbDDigX9N+Hso05BdjPHHkcz2HHxzIM8PotOXg9RUDZbeWqROp3Im9K9wxLHiLzwsH0ADt7Z/gXKJNtTDeSmkp4rsPtLBGAKNuYH8/Zl7BzF8fjAM/BXupvAe0IKBf0q9+JXM16dbZT7p8iLWKt/aew4zZ/c13AXyK731qwn3B7mS0OsPUAkhtH1AE20lJch3Iok91vtb9RqYE2KcsvcjXr+6eDyLwE2Gb5XfqHXQH/Pdh3vID6Xs49RID99utFJhuW6/U6HM6jTH9rNdhPUtAfYEtZfpHdLGdJP4TIvDDL/z0K2BXwl8gst1ZWcBXrEhG6D8mth13geweHs55NC2g/2E9S0G+9L8ryi1ztGez63wcQmZ8Bdv79HLsq4HewzyqzDjBgGqxfuuBsiwKPvPiwGmDD4TAlZtM6TKe/UUCcXbPEPqeaYpG38f75A2w4iMxPgN0g+tqA33oqu8f0vqpnmeXnyTomayzX+wk2Dh2cWc/g9Kv2GNMzwP5T6irrEbma1bs070Jknsxn4K8K+D+CLesSmDEMsA2q7kFyC7BxyAPLwfbcBkyzvyUdbGcuPDS7JnKVATYcRMTEdsDvYdvhGHwETFMHO6rjz6/Eai838bDVYbr9jdKXgi0pyy/ytim8DyRSE6s+FdI/bAf8C9gJmF4pz6YAu6yHlivLz6pz/eqAn7UcyAVMs5RnG18gHGBHdfwibwuwoRk1mSura//fsc52wG/5cOsw/ayAZfmEh+RkdS3uW9LjYHtOO8yHdb9TECJShvqazFXRgJ8vhjrYCLB7q78mA+wCSWUa87LqXGHPn/OwEzCP7H4ywDbLv4CIiIiNYz/aeZM3Spc3A34POwPmU/NnFWhppZ68xs4kedjpMD+aXRNpX4DI/FjFdy83f/POxj9bZpCnvFLINtYUW3wtUC9J5eVg4597/pxVfwuYV3Y/GRD7iMVATrNrIm9yEJEcbsFudcwXm7/ZDPg9bAyY16h9gG15geRhNaLeZ2BmWT43YL64Lr/FV4vTtzBqWNlJpAYONvZNmIhMiUXAf4GteCCV9PBhZlXi0EOkPlYB/897/IxledYcs/vJADseIpJY3cNeQWReFrAbQF9Zw28ZgFh90VTkFFZlGvtkqDxsBMw7wz/AbjbRokxPpFVWJQgvITIfLOf5K2wM2Ko4sA74OboIEKnLAoVG1DtYBY8DxGo1MA8RIQe7/rDPDKnIFDDY/xo2sQjLed6a7U8Bv1UAouy+1MiizpsY7O9bw2/hGcTqGDhojXAR8rCjGn6ZC8Yhn8HOW/G3dYZfAYjUZgG77P4+09Eqn7Nl+WKtg8i8OdglTEgvxsvUMXH0DWz7EWe6w/Yf3obdgv+kzis1cYgdzcrTPX7Gwca+swtTx2Ngdd/RtzBk7jroHiZyDMbZD1btHLaZfZbzfHvVX3BZTsv6fXVeqYVbtSVsyzL2ybBb9jeJeB4sjrMCfpkzBiv3YUf3MJmSlEz3iIuE3EOZstCAHe/zvWO4AXrbXmrhEbPvlp1t3xfUHWy8gCRWgcO7EJknBvuPYOuQEuAOtiURtfg9tBjDPniczlEPy8qZ6zC7v/NDt9YZfpExscPxIWWZlUr2fRi+Dxvqb5dU0iOSB++h1i8XJkpayCkchIPmnd/isczwa3ktGUP6KiozUh7lRtn7vjBrtT0BkgTYGCNjIzKGVG/8Gcpc9wN0DxM5BbP7X1z3Awz4rTKONS6vlYLB1o39fkSqS6tBmjrjef0Qtl+N3qXH/g8rBxsBkrxet9zXgYPIdDmUrzdOeojIKb7CDXGAZYY/oC7cT846OLRv7Lo+BtVLSPL4gJ+16G8Bss0i4Mf6/3PMwbZMwxnq4TBezXGiJYVFjsd4rLvph+YU8LMO0UEkrwH7D74cbATItgCb462AX3LwkKSH7mEix+LLyp/u84NpHf6pK/XSkczPJ5AaWa0Spjp+kby+hIgcg8H+H7DngNkq4A+oB1886iCSX4/DrnW9sNs+Bfwi+fTQ/UvkGK9W7U84oP9MPcPvoGBfbAQcnplSsFhOgIjUTtl9kcOlzP5BS1DfxnQ52H9ZVearQz1BZY0rYomIXKeHBuYix3iGI743YxXwB4yPX1Z1EMnvWxy2Mo81vUQqIi0JUHZf5Fifr9rfcWCMaxXwj51V/wb6KqbY4KhaL4CLiByvg7L7Iqf4YNV+xAErfk0x4NeKPGKFdXMfoz5WH88TEcmtthlSkValoH+vmHdqNfwMxjqI5HfQ8lciIvKWACXkRHK6tWpfY49+xYB/KvW/HOl8B5H8cgX7qrUvx0FEahIQvxIvInmloP/+dT9kFfCXLulJ0xpakUdy+xn5MvtWAf+vICJSLyZNGOwHiIgFBv3Xvr86hRp+7uQTzCujp0yxvYtVe4Q2ynhUw/82q2MSICKHUDmkSBlM/j3BjiQgA/4AGw5lcBpjbivyKOC3xS/YfYG49FXOYx1gQzNbb7M6Jup7IvvLOUMqIjdjxcuTq/7Csoa/RBDSYZ4vACnosMGsPj/W9p+I2X0LFufOQbY52FDfE7lZSzOkIlNzF1fU8zPgt/pKp3XWnSvyPMQ8KejIiw+nNO1s/YCyOncOkrwHm4RDgIjchDOknyL/DKmI7CfV87/xHHwHbZb0zHlFngDJhYH+gLgmdKl1ofnhLof8PoSujcTBRoCI7ML7aY9YDqlAX0ri9fYKhwuw5/DmM+kWymAdPytguvQHlgG/1Utzc1+RJ0BOxRsDA++vEAP+kqxm1D6AJA42rM6dSMtS4mSM+6kIpXdFanZn3T5aN7IO/v+CWFr3rwG45Uu7HjbmtiLPNgUdp2ONPm8OA8oLsPEhJPGw8RxiRS+et4VBPhMnqU5/rPupSCv4/OgRy9F/jVj2dg5bvK8u0m+sS3r4H8s5tcfpiXdhf5BysMq4Bozv2OmzffCasV5XfoHxvsgcYGNuK1Vdx2rwEyBWFPDX7WL9K+/9DFy+X7VnUOmOyDECYvA/IMYi92GDMwicTfjXIiQp4GentbjhMggZkM8j2K2ekhunmCyCsIDx8YZv9cVEB/sB3QPEmv0xBo4DbPBayz3AbpXV4CdAJI8LtCEg3u9/WrUX63+u5R7TyjEU2SUgJiD5q9UiNFyxx6/a8M7Gf9TiIXkP853mswo6pl5WEFbtS9iuwMTAmC99j/GZ9wA7uQfYLfKwyxbX0PccpskhvwvUGxRyBZtayzMDLhOBtSYQmPjrMX1K4MwDYx4+tx4gP2b5PTYCfo7cLQLUudYVW5ZXTD3gJ97M+bKJZWmPRwz4lyiP51ADbBuWA+1aHr6aydlfrcfpB2jG6BQ1D0bGVmoVGMmHiQkmARgze+T3O/7P7fVvrIJIj3nWZloFHXO5yXEfv4I9ZvnHuD5fwMZHEKtj8BL1cJie38KGFjkQkRYw6P8SNvyqvZcC/gF2FpgfDxtzyO4nzPIPsOUwzpeaB9hwsLv2WuBgt/8D6mG15PFYmJF0EBGZN74rM8DGnc0Mv1XmeI5Zx7uwYZUZrpXVaHcTa+ZKr2E/wI7HfHnYGXC4ABtT/ObCb2DDajUxEZHcmOX/CTb+HfCTynryYDmPg40x6s3HNKzaU9jitfk1ygqwG2BbvPTTCqsXvdNShMf8exam+G6Ugw2V9IhISywCfs6i/mYz4P8BdsYomxiLhx2rkV/NSnymnS+7ll6xx6q/cQDjMT8edkHjsf3O6rr1mBYHu3MXICLSDqvku9sM+AfYYdZxLll+qw8o1LRKSElh1b6FvdJZ/gF2LJc0rdUCdo6dZQqw4TCtmncPOwEiIu2wivPcdkmP1X+Iwf4csvx3YLdCzxyz+wlf4A2wxfNW8hp9Bjse88ryO9gNtOnYvhdg5x6mIa0RbUHLNopIiwIM3N76/WPYmUOW3zJgtAwQa8cHd4kXeJkZt1z7fxP3aYCdOWX5O9gZcPzNN0CLIezjd7Axp1XNRESu47YDfsugcupZfge7LKN1cNiCHvbHoPQLvJbvzfhV+xjTxxVrLLP7PU4TYMNjGgkUzlQ42JjbqmYiIjttB/wDbKdBx1gCsZQF7Mw5u7+pRJZ/gXLlMD1s+xsHL1OfVfsRtk4tpbMMOltPoLCcx2qwxuXtAkRE2uNg4PYVf2b5giSDj+8wPQ62JRQK+KMBp2dc91GqHObY5R735TDt0p4Oti+vDjg9aLQ8v60vwepgW5qkkh4RaY1Zku6qgH+ALY/plfZ0sBNgW/rRms9h/zKeR7lr1HrWgvtResnREjhTaD2Y6XE6y6CTDwbLciZLzO53sDXnhQ5EpE1WC7+EXQH/AFt8UP8W08BgyvKhO0A2MdgvsUwnr9ES5TAD7EsPnmBapXTcF+tSnnPkWcRggO0AtUObZVs8h3+GnQEiIu2xCvhf397xF9ZZRz6gphCEcPutS5RK1K235hFiQGaJ12ipchjL1bEo9bdSKxBZYmaY7yY42MrZ71S29Saew/+BHcvP04uIWOG98Y+wsTPgH2CfdXRoPwixDjwG6MWzqzBj+inssRzGwx4HMNZlSswaMCt+C21jn7sHWwF5A0brkryWyrZ4/XGA4mBrgIhIWxzsYo5w+5q/tM46UgpCWgz6O9gHHj1kl2HVlrBXIntaqkyJ/Y0zUi32t1TzXeLdCt77AvLpYY/ntYUZUw/7PhWgDL+ItMXyvSbOel67YhzLAP6x/kHr9jPaKu/pYH9M/o48euTftiXqwAC2xPW5gD32t1cASuxPa/2NA5QzlDk257DJPi8B823nea15MPdrlLnGc5ZZethso4OIDQaOS+S/ZnO9N9Wh3m0bE2dpre6Jv6yavy7Dz6zjVygjZfprD0LSCOwh7Kl2/2asjX4Ee9/A/sXIUll+aqW/UXpBd4Eycmf3kxIrbdV8XrlIA+v2rfsRH27/DRGRdpR4H3Svd8mYab4o1Jj9WaDOOuOSWcZc2X3qkX/7lqhHqZmoDva4L6X7G5c5rbG/cZuY8Sg165G7320rOYNzjnqCfp5HfvG51L7nPoceNtvpIGJDGf52pOfcOezuiWx/w5688YZc1c5QV5aK2alzlNv/+8inR/7tW6IurOsucV5KXJMewEXh9hRx32oJ/Dm47lH+ONyHrUcASu1LDckTnseS+8xp69xLfXrYbKuDiA0F/PXjOeL9sYPd/XCzfYMD/Fhoozbb+fpgjP3A6lB2v3NfuD3yb+MS9eEI1vrclNrvMfob2xnGDfxTfyuZ1U/tCex5ABeF2xnKn9NSWavtZjFD42GzrQ4iNhTw1+fWRuO9keW7pZ5zTITc5Ua8g/1wCUQGVCVfCHOItfL3EevZuepCQNwBSzwhnH5/sG6lP2pTYrnJKfoC9gG5RyxPeApbY/Q3Wqxbj/j+TsD0+xvxxvsF7A3r5lHOApfnlLXtrOO0Oqc8l37V/oqy+0jcp8cQkTnis7LGpYndqr2LmHT5DeJ7VqWfcQFHrFpWqmziunaGeFLTSCmXzZEXp6DHyDCydcivR/7tXKJOJTLj5yjTYWvob0vEYDFliHP0ufT/86v1Pi6Bovt0VSux1GfiMe6+ciUfDqxynNPN+2aH8e6bbMzuO+TnYbO9DiI25pjhV9vdjn4ZeKxSg+3GBwuzrOmDM7e22i7bP8eH3icYN8hPzeqFwR75t3WJOjmUOY8dyngC4KKSxkDxDHEAwD7HgP3Wno0/y/dgUl/7uaL9KlHKs+0Mdez7OeJ9lAMAzlzxHF13Xvl3H6x/lvfeZxj/vslmUbufeMBkmx1EbCjgV0uN90aXDvy+JT3JnxBLDcZ+oZYZ1nt488NXnKrm0oZh1V7u+PfeX//KaRWHccoHdvkD5FQBsTbuIWwxQHqMGDBZYmkPr9Wx+xvdWbfFxp+l/rbrK8EOsY/V1M828fyVKOXZxpWRPsL4a+a7ddv1AcGw8XM143n8HiIisqnHictM86HPUUOtI5oWWwc7PZB9e5eoV6llOksdgzso9wG8ObVf1sd2LDWUbE3lPDrY8YDJdjuI2FCGX43trXvjdR/e2oWZ9DGyYlPFKfUOkkupD8Z5lHlJSP3NBo/pXh8iMcLSpiXkFHyofQmbD6WJiLSK98YeW/fGYwJ+4sPqS8ipzqFVeSzw+hxgjy/DlChX6aH+lhOPZYkvNN+Eff8V5Fi8f6pfiIi8KeCKxOexAT91iIGIHIcPK9btv4ZYKBEIOJRb4aWDgpsceAw71CEgvhclh+NA6b8gIiKbmN3vcMXM5ykBP3HVjR5yKD6s+KAPECsD7NfLp7TEYQkdFPSfokd95XMDdE4PxQcanz0BIiKSpFKeKxcxODXgJwX9h2Gwz8z+mPXDc8E6besZFJb0fI1yOihAPAZLeD5BnTrUUWLUglS3/wNERGQTK0d2vvOXI+AnPkgVhNxMwX5ZAXGZTmtc1rDEC7xJh9jfLiA3SQHi56gbb9KPIddJ51LPGhGRNzHYZ5ljsTLxDlqyc1fjh7XGWAawR/59WaIdzMDz2Fuf33OUx/cH1N92t19Q9iu6p+Jyej3aOsYlz+VDlOdhsz8OIja0LOf82l5fGs+V4U86xNp0rTzxpnMosz8WjnZLLGvpUD64ZBnIf2KcwUbt0mxaS6UyvHEvoAz2Nh4XztDouIiIvCnFl+GmH8wd8NMzKAhJ+KDii6M8HgEyFl6TA+w9RPmvp3IQyc6+hBD7HI8F+9yANnVQyVbCgdvHKFOaJyLSCj4ffsaewT5ZBPxY/8d/jXk/tLjfzCxzxkNLb46vRHaw9Au8SUDs9HMPElOf2/sGWLEO806cpGlqHgO9oCsicon3RyZBqnvWOZSpoa6p/Q3j1OtfpUf+/VuiTd+gzPn3GI9D7G9zqu3nvrK+tJY+l5ND7MNzO5/sqyU+ancTD5t9dBCxoRr+ad8b/2/VPkLlOkw/8P8H6lvnu0f+/VyiTQwgWCJgfR3UcHwWmMdAm32upRdzj7XA9M/nL+t9vIt6eNjsq4OIDQX8070/1pII2YtbtTNML1vF/fkOdd7Ee+Tf3yXa1aHMNVFDEOoQ95dB8cXEWhpcN3Pzy8BhmiuhcX94Ph+iPh42++wgYkMB/7TujTXHl3txuAz8W354pVICj3r1yL/fS7StRKaUMwm1BKMOMTMwhVKfOQb62xymUeazGejXej49bPbdQcSGAv72Wwv3xoM5XE5Vt/LwSieCAZRH/XrkPwZLtM2jzLXyDerCG8cC7QX+3Fa+F9Nh3oH+NofYv1s8n608zDxsjoGDiA0F/O21lPxOseVdTJxHzPpzh2t8eKVs/gO0FXT0yH8slmgfz2WJ68ajTh6xv9UaLLY2sB7bAvGarnXWNJ1PbuNdtMPD5ng4iNiwCPhT/JNDh7zb1kL75YrG+yETWSzX+QsK3BNuoU73EN9CvovLg1B6Wy/Wvw6r9r+IgXNAe3gsc69ecr5qj9E2hxgkWeM6+c9QN79q91FHfwuIyzCy8dhpSdvDOMTz+cf1ryk5Mdb55Pnj9f8T4jlt7Xw62Nwn+EE4XdtiZYG8AST7M5/73+N0HvNL4vD4vV63l4jPuYDCag34NznEi4PById4O3g9dR8uNv6ZJ4NBxgvEB9QA3ZRlXhzK9Td6vm4cVA/QB+py84jnMQ3mNs9njvv/9vkMiOcxnVN9XVxEpAItBPxX4UPLrdr7G7++h8sRrdvx74X1r6/X/8xfGdxzxPUcCjZErpK7v/0TCu7HwvN2Z+PX/8Db59Ht+HfD+tfN85myVS82/kxERCrz/yWA75WCYL0wAAAAAElFTkSuQmCC
tests:
- Group-IB Threat Intelligence -Test
fromversion: 6.0.0
