commonfields:
  id: ProtectWise
  version: -1
name: ProtectWise
display: ProtectWise
category: Network Security
image: data:image/png;base64,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
description: Cloud based Security Network DVR
detaileddescription: |-
  To configure this integration you can either use Email and Password, or the API token.
  To obtain the API token navigate to the `Settings` page in the Visualizer UI, and under `Your Settings`
  select `GENERATE TOKEN`.
configuration:
- display: Url
  name: url
  defaultvalue: https://api.protectwise.com/api/v1/
  type: 0
  required: true
- display: Email
  name: email
  defaultvalue: ""
  type: 0
  required: false
- display: Password
  name: password
  defaultvalue: ""
  type: 4
  required: false
- display: API Token
  name: token
  type: 4
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Only fetch events with this text in the name
  name: messageFilter
  defaultvalue: ""
  type: 0
  required: false
- display: Filter by threat category
  name: threatCategory
  defaultvalue: ""
  type: 0
  required: false
- display: Filter by killchain stage
  name: killChainStage
  defaultvalue: ""
  type: 0
  required: false
- display: Filter by  threat level (LOW, MEDIUM, or HIGH)
  name: threatLevel
  defaultvalue: ""
  type: 0
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- display: "Maximum events to fetch per fetch"
  name: maxFetch
  defaultvalue: "50"
  type: 0
  required: false
script:
  script: >-
    var DEFAULT_EVENT_HEADERS = ['message','id','type','sensorId','threatScore','killChainStage','confidence','startedAt','observedAt','endedAt','observationCount','netflowCount','observedStage'];

    var DEFAULT_NETFLOW_HEADERS = ['key', 'id.srcIp', 'id.dstIp', 'id.srcPort', 'id.dstPort', 'id.layer4Proto'];

    var DEFAULT_OBSERVATION_HEADERS = ['id','killChainStage','source','sensorId','threatScore','severity','confidence','occurredAt','observedAt','endedAt','netflowId','observedStage'];

    var DEFAULT_SENSOR_HEADERS = ['id', 'friendly_name', 'ip_address', 'last_seen', 'customer_id', 'enabled'];

    var TIME_FIELDS = ['startedAt', 'occurredAt', 'endedAt', 'observedAt'];


    var serverUrl = params.url.replace(/[\/]+$/, '') + '/';


    var getToken = function() {
        var token = '';
        if ((params.token) && (params.token.length > 0)) {
            token = params.token;
        }
        if (token.length === 0) {
            if (params.email.length === 0 || params.password.length === 0){
                throw 'If token configuration is empty , you must provide email+password configuration params for auth';
            }
            var tokResult = http(
                serverUrl + 'token',
                {
                    Headers: {'Content-Type': ['application/json']},
                    Method: 'POST',
                    Body: JSON.stringify({'email': params.email, 'password': params.password}),
                },
                params.insecure,
                params.proxy
            );
            var body;
            if (tokResult.StatusCode !== 200 && tokResult.StatusCode !== 201) {
                throw 'Failed to create token, request status code: ' + tokResult.StatusCode + ', body: ' + tokResult.Body;
            }
            try {
                body = JSON.parse(tokResult.Body);
            } catch (ex) {
                throw 'Error parsing token - ' + tokResult.Body + ' - ' + ex;
            }

            return body.token;
        }
        return token;
    };


    // If value for any argument is empty remove it

    var cleanArgs = function(args) {
        return Object.keys(args).filter(function(k) {return args[k];}).reduce(function(clean, k) {clean[k] = args[k]; return clean;}, {});
    };


    var doReq = function(url, token, raw, args, saveToFile) {
        if (args) {
            url += encodeToURLQuery(cleanArgs(args));
        }
        var res = http(
            url,
            {
                Headers: {'X-Access-Token': [ token ]},
                Method: 'GET',
                SaveToFile: saveToFile ? true : false
            },
            params.insecure,
            params.proxy
            );
        if (res.StatusCode !== 200) {
            throw 'Failed to execute ' + url + ' : ' + res.StatusCode + ', body: ' + res.Body;
        }
        try {
            return (raw ? (saveToFile ? res.Path : res.Body) : JSON.parse(res.Body));
        } catch (ex) {
            throw 'Error parsing response - ' + res.Body + ' - ' + ex;
        }
    };


    var filterClone = function(src, filter) {
        if (src && Array.isArray(src) && filter && Array.isArray(filter)) {
            var items = [];
            src.forEach(function(s) {
                var item = {};
                filter.forEach(function( col ) {
                   item[col] =  dq(s, col);
                });
                items.push(item);
            });
            return items;
        } else return undefined;
    };


    var parseTime = function(time) {
        if ((typeof time === 'string' || time instanceof String) && (time.indexOf("-") >= 0 || time.indexOf("/") >= 0 )){
            var d = new Date(time);
            return d.getTime();
        }
        return time;
    };


    var eventsSearch = function(start, end, eventType, killChainStage, threatLevel, threatCategory, observationStage, ip, expandDetails, minLimit, maxLimit, reverseOrder, nextPage, token) {
        return doReq(serverUrl + 'events', token, true, {start: parseTime(start), end: parseTime(end),
            eventType: eventType, killChainStage: killChainStage, threatLevel: threatLevel, threatCategory: threatCategory, observationStage: observationStage,
            ip: ip, expandDetails: expandDetails, minLimit: minLimit, maxLimit: maxLimit, reverseOrder: reverseOrder, nextPage: nextPage});
    };


    var observationSearch = function(sensorId,start,end,type,killChainStage,threatLevel,threatCategory,hasKillChain,ip,expandDetails,minLimit,maxLimit,reverseOrder,nextPage,signatureId,token) {
        return doReq(serverUrl + 'observations', token, true, {sensorId: sensorId, start: parseTime(start), end: parseTime(end), type: type, killChainStage: killChainStage,
            threatLevel: threatLevel, threatCategory: threatCategory, hasKillChain: hasKillChain, ip: ip, expandDetails: expandDetails, minLimit: minLimit, maxLimit: maxLimit,
            reverseOrder: reverseOrder, nextPage: nextPage, signatureId: signatureId});
    };


    var createIncidentFromEvent = function(event) {
        var keys = Object.keys(event);
        var labels = [];
        for (var i = 0; i<keys.length; i++) {
            val = event[keys[i]];
            if (TIME_FIELDS.indexOf(keys[i]) > -1) {
                val = convertTimestampToString(val);
            }
            labels.push({'type': keys[i], 'value': String(val)});
        }
        return {
            "name": event.message,
            "labels": labels,
            "rawJSON": JSON.stringify(event),
            "occurred": convertTimestampToString(event.observedAt)
        };
    };


    var token = getToken();

    switch (command) {
        case 'test-module':
            if (token && token.length > 0) {
                return true;
            }
            return false;
        case 'fetch-incidents':
            var lastRun = getLastRun();
            var now = (new Date()).getTime();
            if (!lastRun || !lastRun.time) {
                // First time, retrieve events from the last 10 min
                lastRun = {time: now - 10 * 60 * 1000};
            }
            var data = eventsSearch(lastRun.time , now , params.eventType, params.killChainStage, params.threatLevel,
                params.threatCategory, null, null, null, null, null, null, null, token);
            try {
                var res = JSON.parse(data).events;
                res.reverse();  // events are fetched in descending order so reversing to process older first
            } catch (ex) {
                throw 'Error parsing event fetch - ' + data + ' - ' + ex;
            }
            var incidents = [];
            for (var i = 0; i < res.length; i++) {
                if (incidents.length >= Math.min(parseInt(params.maxFetch), 50)) {
                    break;
                }
                var skip = true;
                if (params.messageFilter && res[i].message) {
                    filters = params.messageFilter.split(',');
                    for (var j = 0; j < filters.length; j++) {
                        if (filters[j] && filters[j].length > 0 && res[i].message.toLowerCase().indexOf(filters[j].toLowerCase()) > -1) {
                            skip = false;
                            break;
                        }
                    }
                } else {
                    skip = false;
                }
                if(!skip) {
                    incidents.push(createIncidentFromEvent(res[i]));
                    lastRun.time = Math.max(lastRun.time, res[i].startedAt)+1;
                }
            }
            setLastRun(lastRun);
            return JSON.stringify(incidents);
        case 'sensors':
        case 'protectwise-show-sensors':
            var url = serverUrl + 'sensors';
            if (args.sensorId && args.sensorId.length > 0 ) {
                url = url + '/' + args.sensorId;
            }
            var headers = args.headers ? args.headers : DEFAULT_SENSOR_HEADERS;

            var res = doReq(url, token);
            var items = [];

            if (!Array.isArray(res)) {
                res = [res];
            }
            items = filterClone(res, headers);

            return {
                Type: entryTypes.note,
                Contents: res,
                ContentsFormat: formats.json,
                HumanReadable: tableToMarkdown('Protectwise sensors', items, headers),
                EntryContext: {'Protectwise.Sensor(val.id == obj.id)': items}
            };
        case 'search':
        case 'protectwise-search-events':
            var res;
            var raw = eventsSearch(args.start, args.end, args.eventType, args.killChainStage, args.threatLevel,
                args.threatCategory, args.observationStage, args.ip, args.expandDetails, args.minLimit, args.maxLimit, args.reverseOrder, args.nextPage, token);
            try {
                res = JSON.parse(raw).events;
            } catch (ex) {
                throw 'Error parsing event search - ' + raw + ' - ' + ex;
            }
            var eventHeaders = args.headers ? args.headers : DEFAULT_EVENT_HEADERS;
            var items = [];
            if (!Array.isArray(res)) {
                res = [res];
            }
            items = filterClone(res, eventHeaders);
            items.forEach(function(item) {
               TIME_FIELDS.forEach(function (timeKey) {
                   if (item[timeKey]) {
                       item[timeKey] = convertTimestampToString(item[timeKey]);
                   }
               });
            });

            return {
                Type: entryTypes.note,
                Contents: raw,
                ContentsFormat: formats.json,
                HumanReadable: tableToMarkdown('Protectwise Event Search', items, eventHeaders),
                EntryContext: {'Protectwise.Event(val.id == obj.id)': items}
            };
        case 'pw-event-get':
        case 'protectwise-event-info':
            var url = serverUrl + 'events/' + args.id;
            var eventHeaders = args.headers ? args.headers : DEFAULT_EVENT_HEADERS;
            var res = doReq(url, token);
            var event = {};
            eventHeaders.forEach(function( col ) {
               event[col] = res[col];
            });

            TIME_FIELDS.forEach(function (timeKey) {
               if (event[timeKey]) {
                   event[timeKey] = convertTimestampToString(event[timeKey]);
               }
            });

            var md = tableToMarkdown('Protectwise Event ' + res.id, [event], eventHeaders);

            if (res.netflows && res.netflows.length > 0) {
                var nf = filterClone(res.netflows, DEFAULT_NETFLOW_HEADERS);
                for(var i = 0; i < nf.length; i++) {
                    nf[i].srcIp = nf[i]['id.srcIp'];
                    nf[i].dstIp = nf[i]['id.dstIp'];
                    nf[i].srcPort  = nf[i]['id.srcPort'];
                    nf[i].dstPort = nf[i]['id.dstPort'];
                    nf[i].layer4Proto = nf[i]['id.layer4Proto'];
                    }
                event.Netflows = nf;
                md += '\n' + tableToMarkdown('Related Netflows', nf, DEFAULT_NETFLOW_HEADERS);
            }

            if (res.observations && res.observations.length > 0) {
                var obs = filterClone(res.observations, DEFAULT_OBSERVATION_HEADERS);
                obs.forEach(function(item) {
                    TIME_FIELDS.forEach(function (timeKey) {
                       if (item[timeKey]) {
                           item[timeKey] = convertTimestampToString(item[timeKey]);
                       }
                   });
                });
                event.Observations = obs;
                md += '\n' + tableToMarkdown('Related Observations', obs, DEFAULT_OBSERVATION_HEADERS);
            }

            return {
                Type: entryTypes.note,
                Contents: res,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: {'Protectwise.Event(val.id == obj.id)': event}
            };
        case 'observation-search':
        case 'protectwise-search-observations':
            var res;
            var raw = observationSearch(args.sensorId, args.start, args.end, args.type, args.killChainStage, args.threatLevel,
                args.threatCategory, args.hasKillChain, args.ip, args.expandDetails, args.minLimit, args.maxLimit, args.reverseOrder, args.nextPage, args.signatureId, token);
            try {
                res = JSON.parse(raw).observations;
            } catch (ex) {
                throw 'Error parsing observation search - ' + raw + ' - ' + ex;
            }
            var headers = args.headers ? args.headers : DEFAULT_OBSERVATION_HEADERS;
            var items = [];
            if (!Array.isArray(res)) {
                res = [res];
            }
            items = filterClone(res, headers);
            items.forEach(function(item) {
                TIME_FIELDS.forEach(function (timeKey) {
                   if (item[timeKey]) {
                       item[timeKey] = convertTimestampToString(item[timeKey]);
                   }
               });
            });

            return {
                Type: entryTypes.note,
                Contents: raw,
                ContentsFormat: formats.json,
                HumanReadable: tableToMarkdown('Protectwise Observation Search', items, headers),
                EntryContext: {'Protectwise.Observation(val.id == obj.id)': items}
            };
        case 'pw-observation-get':
        case 'protectwise-observation-info':
            var url = serverUrl + 'observations/' + args.id;
            var headers = args.headers ? args.headers : DEFAULT_OBSERVATION_HEADERS;
            var res = doReq(url, token, false, {'sensorId': args.sensorId});
            var obj = {};
            headers.forEach(function( col ) {
               obj[col] = res[col];
            });
            TIME_FIELDS.forEach(function (timeKey) {
               if (obj[timeKey]) {
                   obj[timeKey] = convertTimestampToString(obj[timeKey]);
               }
            });

            var md = tableToMarkdown('Protectwise Observation ' + res.id, [obj], headers);
            return {
                Type: entryTypes.note,
                Contents: res,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: {'Protectwise.Observation(val.id == obj.id)': obj}
            };
        case 'event-pcap-download':
        case 'protectwise-event-pcap-download':
            var filename = (args.filename && args.filename.length > 0) ? args.filename : (args.eventId + '.pcap');

            var url = serverUrl + 'pcaps/events/' + args.eventId;
            res = doReq(url, token, true, {filename: filename}, true);
            return {Type: 3, FileID: res, File: filename, Contents: 'we must have contents for an entry'};
        case 'event-pcap-info':
        case 'protectwise-event-pcap-info':
            var url = serverUrl + 'pcaps/events/'+ args.eventId + '/info';
            var res = doReq(url, token);
            var md = '### Protectwise PCAP for Event ' + res.id + '\n - Estimated size: ' + res.estimatedSize + ' bytes';
            if (res.netflows && res.netflows.length > 0) {
                var nf = filterClone(res.netflows, DEFAULT_NETFLOW_HEADERS);
                    for(var i = 0; i < nf.length; i++) {
                        nf[i].srcIp = nf[i]['id.srcIp'];
                        nf[i].dstIp = nf[i]['id.dstIp'];
                        nf[i].srcPort  = nf[i]['id.srcPort'];
                        nf[i].dstPort = nf[i]['id.dstPort'];
                        nf[i].layer4Proto = nf[i]['id.layer4Proto'];
                    }
                event.Netflows = nf;
                md += '\n' + tableToMarkdown('Included Netflows', res.netflows);
            }

            return {
                Type: entryTypes.note,
                Contents: res,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: {'Protectwise.Event(val.id == obj.id)': {'id': res.id, 'PCAPSize': res.estimatedSize}}
            };
        case 'observation-pcap-download':
        case 'protectwise-observation-pcap-download':
            var filename = (args.filename && args.filename.length > 0) ? args.filename : ( args.sensorId+'-'+args.id + '.pcap');
            var url = serverUrl + 'pcaps/observations/' + args.sensorId + '/' + args.id;
            res = doReq(url, token, true, {filename: filename}, true);
            return {Type: 3, FileID: res, File: filename, Contents: 'we must have contents for an entry'};
        case 'observation-pcap-info':
        case 'protectwise-observation-pcap-info':
            var url = serverUrl + 'pcaps/observations/' + args.sensorId + '/' + args.id + '/info';
            var res = doReq(url, token);
            var md = '### Protectwise PCAP for Observation ' + res.id + '\n - Estimated size: ' + res.estimatedSize + ' bytes';
            if (res.netflows && res.netflows.length > 0) {
                var nf = filterClone(res.netflows, DEFAULT_NETFLOW_HEADERS);
                    for(var i = 0; i < nf.length; i++) {
                        nf[i].srcIp = nf[i]['id.srcIp'];
                        nf[i].dstIp = nf[i]['id.dstIp'];
                        nf[i].srcPort  = nf[i]['id.srcPort'];
                        nf[i].dstPort = nf[i]['id.dstPort'];
                        nf[i].layer4Proto = nf[i]['id.layer4Proto'];
                    }
                event.Netflows = nf;
                md += '\n' + tableToMarkdown('Included Netflows', res.netflows);
            }

            return {
                Type: entryTypes.note,
                Contents: res,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: {'Protectwise.Observation(val.id == obj.id && val.sensorId == obj.sensorId)': {'id': args.id, 'sensorId': args.sensorId, 'PCAPSize': res.estimatedSize}}
            };
        case 'get-token':
            return token;
        default:
            return 'The Protectwise integration has no command "' + command + '"';
    }
  type: javascript
  commands:
  - name: sensors
    deprecated: true
    arguments:
    - name: sensorId
      default: true
      description: The ID of the individual sensor. If empty, will query all available sensors.
    description: Returns the specified, or all available sensors.
  - name: protectwise-show-sensors
    arguments:
    - name: sensorId
      default: true
      description: The ID of the individual sensor. If empty, will query all available sensors.
    outputs:
    - contextPath: Protectwise.Sensor.id
      description: The ID of the sensor.
    - contextPath: Protectwise.Sensor.friendly_name
      description: The name of the sensor.
    - contextPath: Protectwise.Sensor.ip_address
      description: The IP address of the sensor.
    - contextPath: Protectwise.Sensor.last_seen
      description: The time when the sensor was last seen.
    - contextPath: Protectwise.Sensor.customer_id
      description: The customer ID of the sensor.
    - contextPath: Protectwise.Sensor.enabled
      description: Whether the sensor is enabled.
    description: Returns all available sensors.
  - name: search
    deprecated: true
    arguments:
    - name: start
      required: true
      description: 'The timestamp of the start time of the event. For example, 1401451200000, or 2015-03-25T12:00:00.'
    - name: end
      required: true
      description: 'The timestamp of the end of the event. For example, 1401451500000, or 2015-03-25T12:00:00.'
    - name: eventType
      description: 'Filter by one or more event types. Can be: "MaliciousFlow", "KillChainEscalation", or "MaliciousConversation".'
    - name: killChainStage
      description: 'Filter by killchain stage. Can be: "Methodology", "Recon", "Delivery", "Exploit", "Beacon", "CnC", "Fortification", or Data_Theft".'
    - name: threatLevel
      description: 'Filter by the threat level. Can be: "NONE", "LOW", "MEDIUM", or "HIGH".'
    - name: threatCategory
      description: 'Filter by the threat category. Can be: "ExploitsAndAttacks", "DenialOfService", "Malware", "Scanning", "Botnets", "Phishing", "Suspicious", "MaliciousHost", "APT", "Misc", or "Unknown".'
    - name: observationStage
      description: 'Filter by the observation stage. Can be: "Realtime" or "Retrospective".'
    - name: ip
      description: Filter by events that are affected by a specific IP address.
    - name: minLimit
      description: The minimum number of results to return per page.
    - name: maxLimit
      description: The maximum number of results to return per page.
    - name: reverseOrder
      description: Whether to sort results by descending timestamp. If "true", results are returned in descending timestamp order. If "false", results are returned in ascending timestamp order. Default is "true".
    - name: nextPage
      description: An identifier to fetch the next page in the result set.
    description: Searches for events. Events are resources that describe a threat and contain a collection of observations.
  - name: protectwise-search-events
    arguments:
    - name: start
      required: true
      description: 'Timestamp of the start time of the event. For example, 1401451200000, or 2015-03-25T12:00:00.'
    - name: end
      required: true
      description: Timestamp of the end of the event. For example, 1401451500000, or 2015-03-25T12:00:00.
    - name: eventType
      description: 'Filters by one or more event types. Can be: "MaliciousFlow:, "KillChainEscalation", or "MaliciousConversation".'
    - name: killChainStage
      description: 'Filters by the killchain stage. Can be: "Methodology", "Recon", "Delivery", "Exploit", "Beacon", "CnC", "Fortification", or "Data_Theft".'
    - name: threatLevel
      description: 'Filters by Low, Medium, or High threats. Can be: "NONE", "LOW", "MEDIUM", or "HIGH".'
    - name: threatCategory
      description: 'Filters by threat category. Can be: "ExploitsAndAttacks", "DenialOfService", "Malware", "Scanning", "Botnets", "Phishing", "Suspicious", "MaliciousHost", "APT", "Misc", or "Unknown".'
    - name: observationStage
      description: Filters by Realtime or Retrospective.
    - name: ip
      description: Filters by events that are affected by a specific IP address.
    - name: minLimit
      description: Minimum number of results to return per page.
    - name: maxLimit
      description: Maximum number of results to return per page.
    - name: reverseOrder
      description: Return results sorted by descending timestamp (default = true).
    - name: nextPage
      description: An identifier which fetches the next page in the result set.
    outputs:
    - contextPath: Protectwise.Event.message
      description: Name of the event.
    - contextPath: Protectwise.Event.id
      description: Protectwise event ID.
    - contextPath: Protectwise.Event.type
      description: The type of the event.
    - contextPath: Protectwise.Event.sensorId
      description: The sensor ID of the event.
    - contextPath: Protectwise.Event.threatScore
      description: The threat score (0-100).
    - contextPath: Protectwise.Event.killChainStage
      description: The Kill Chain Stage of the event.
    - contextPath: Protectwise.Event.confidence
      description: The confidence level (0-100)
    - contextPath: Protectwise.Event.startedAt
      description: The time that Event started.
    - contextPath: Protectwise.Event.observedAt
      description: The time the event was observed.
    - contextPath: Protectwise.Event.endedAt
      description: The time the event ended.
    - contextPath: Protectwise.Event.observationCount
      description: The number of observations related to this event.
    - contextPath: Protectwise.Event.netflowCount
      description: The number of netflows related to this event.
    - contextPath: Protectwise.Event.observedStage
      description: The observed stage (Realtime or Retrospective).
    description: Searches for events. Events are resources that describe a threat and contains a collection of observations. Deprecated - use the protectwise-search-events command.
  - name: pw-event-get
    deprecated: true
    arguments:
    - name: id
      required: true
      default: true
      description: The ID of the event to return.
    description: Returns information about a single event and its associated observations.
  - name: protectwise-event-info
    arguments:
    - name: id
      required: true
      default: true
      description: The ID of the event.
    outputs:
    - contextPath: Protectwise.Event.message
      description: Name of the event.
    - contextPath: Protectwise.Event.id
      description: The ID of the event.
    - contextPath: Protectwise.Event.type
      description: The type of the event.
    - contextPath: Protectwise.Event.sensorId
      description: The sensor ID of the event.
    - contextPath: Protectwise.Event.threatScore
      description: The Threat score. From 0-100.
    - contextPath: Protectwise.Event.killChainStage
      description: Kill Chain Stage of the event.
    - contextPath: Protectwise.Event.confidence
      description: The Confidence level. From 0-100.
    - contextPath: Protectwise.Event.startedAt
      description: The time the event started.
    - contextPath: Protectwise.Event.observedAt
      description: The time the event was observed.
    - contextPath: Protectwise.Event.endedAt
      description: The time the event ended.
    - contextPath: Protectwise.Event.observationCount
      description: The number of observations related to this event.
    - contextPath: Protectwise.Event.netflowCount
      description: The number of netflows related to this event.
    - contextPath: Protectwise.Event.observedStage
      description: The observed stage (Realtime or Retrospective).
    - contextPath: Protectwise.Event.Netflows.key
      description: The Netflow key.
    - contextPath: Protectwise.Event.Netflows.srcIp
      description: The Netflow Source IP.
    - contextPath: Protectwise.Event.Netflows.dstIp
      description: The Netflow Dst IP.
    - contextPath: Protectwise.Event.Netflows.srcPort
      description: The Netflow source port.
    - contextPath: Protectwise.Event.Netflows.dstPort
      description: The Netflow DST Port.
    - contextPath: Protectwise.Event.Netflows.layer4Proto
      description: The Netflow Layer 4 Protocol.
    - contextPath: Protectwise.Event.Observations.id
      description: The observation ID.
    - contextPath: Protectwise.Event.Observations.killChainStage
      description: The Observation Killchain Stage.
    - contextPath: Protectwise.Event.Observations.source
      description: The Observation Source.
    - contextPath: Protectwise.Event.Observations.sensorId
      description: The Observation's Sensor ID.
    - contextPath: Protectwise.Event.Observations.threatScore
      description: The Observation threat score.
    - contextPath: Protectwise.Event.Observations.severity
      description: The Observation Severity.
    - contextPath: Protectwise.Event.Observations.confidence
      description: The observation confidence level (0-100).
    - contextPath: Protectwise.Event.Observations.occurredAt
      description: The time the observation occurred.
    - contextPath: Protectwise.Event.Observations.observedAt
      description: The time the observation observed.
    - contextPath: Protectwise.Event.Observations.endedAt
      description: The time the observation ended.
    - contextPath: Protectwise.Event.Observations.netflowId
      description: The ID of the related Netflow for this observation.
    - contextPath: Protectwise.Event.Observations.observedStage
      description: The observed stage of the observation.
    description: Searches for a single event in ProtectWise. Deprecated - use the protectwise-event-info command.
  - name: observation-search
    deprecated: true
    arguments:
    - name: sensorId
      required: true
      description: The sensor ID or a comma-separated list of sensor IDs.
    - name: start
      required: true
      description: 'The timestamp of the start time of the event. For example, 1401451200000, or 2015-03-25T12:00:00'
    - name: end
      required: true
      description: 'The timestamp of the end of the event. For example, 1401451500000, or 2015-03-25T12:00:00'
    - name: type
      description: 'Filter by observation type. Can be: "ids", "http", "iprep", "urlrep", "protocol" or "file".'
    - name: hasKillChain
      description: Search for observations in every kill chain stage (true false)
    - name: killChainStage
      description: Filter by kill chain stage (Methodology  Recon  Delivery  Exploit  Beacon  CnC  Fortification  Data_Theft)
    - name: ip
      description: Filter observations by IP address in the src/dst fields
    - name: threatLevel
      description: Filter by Low, Medium, or High threats (NONE  LOW  MEDIUM  HIGH)
    - name: threatCategory
      description: Filter by threat category (ExploitsAndAttacks  DenialOfService  Malware  Scanning  Botnets  Phishing  Suspicious  MaliciousHost  APT  Misc  Unknown)
    - name: signatureId
      description: 'Filter by threat signature (find observations of the same type of threat) -  Example: 69020504'
    - name: minLimit
      description: Try to return at least this many results per page
    - name: maxLimit
      description: Do not return more than this many results
    - name: reverseOrder
      description: Return results sorted by descending timestamp (default = true)
    - name: nextPage
      description: An identifier to fetch the next page in the result set
    description: Searches for observations in ProtectWise.
  - name: protectwise-search-observations
    arguments:
    - name: sensorId
      required: true
      description: The ID of the individual sensor or a comma-separated list of Sensor IDs.
    - name: start
      required: true
      description: 'Timestamp of the start time of the event. For example, 1401451200000, or 2015-03-25T12:00:00.'
    - name: end
      required: true
      description: 'Timestamp of the end of the event. For example, 1401451500000, or 2015-03-25T12:00:00'
    - name: type
      description: 'Filter by observation type. Can be: "ids", "http", "iprep", "urlrep", "protocol", or "file".'
    - name: hasKillChain
      description: 'Searches for observations in every kill chain stage. Can be: "true" or "false".'
    - name: killChainStage
      description: 'Filter by killchain stage. Can be: "Methodology", "Recon", "Delivery", "Exploit", "Beacon", "CnC", "Fortification", or "Data_Theft".'
    - name: ip
      description: Filter observations by IP address in the src/dst fields.
    - name: threatLevel
      description: 'Filter by Low, Medium, or High threats. Can be: "NONE", "LOW", "MEDIUM", or "HIGH".'
    - name: threatCategory
      description: 'Filter by threat category. Can be: "ExploitsAndAttacks", "DenialOfService", "Malware", "Scanning", "Botnets", "Phishing", "Suspicious", "MaliciousHost", "APT", "Misc", or "Unknown".'
    - name: signatureId
      description: 'Filter by threat signature. Finds observations of the same type of threat). For example, 69020504.'
    - name: minLimit
      description: Minimum number of results per page.
    - name: maxLimit
      description: Maximum number of results per page.
    - name: reverseOrder
      description: Returns results sorted by descending timestamp. Default is true.
    - name: nextPage
      description: An identifier to fetch the next page in the result set.
    outputs:
    - contextPath: Protectwise.Observation.id
      description: The ID of the observation.
    - contextPath: Protectwise.Observation.killChainStage
      description: The Killchain Stage of the observation.
    - contextPath: Protectwise.Observation.source
      description: The source of the observation.
    - contextPath: Protectwise.Observation.sensorId
      description: The ID of the protectwise sensor that generated the observation.
    - contextPath: Protectwise.Observation.threatScore
      description: The threat score of the observation.
    - contextPath: Protectwise.Observation.severity
      description: The severity of the observation.
    - contextPath: Protectwise.Observation.confidence
      description: The confidence level of the observation.
    - contextPath: Protectwise.Observation.occurredAt
      description: The time the observation occurred.
    - contextPath: Protectwise.Observation.observedAt
      description: The time the observation was observed.
    - contextPath: Protectwise.Observation.endedAt
      description: The time the observation ended.
    - contextPath: Protectwise.Observation.netflowId
      description: The ID of the Netflow attached to this observation.
    - contextPath: Protectwise.Observation.observedStage
      description: The attack stage reflected by the observation.
    description: Searches for observations in ProtectWise. Deprecated - use the protectwise-search-observations command.
  - name: pw-observation-get
    deprecated: true
    arguments:
    - name: id
      required: true
      description: The ID of the observation.
    - name: sensorId
      required: true
      description: The ID of an individual sensor or a comma-separated list of sensor IDs.
    description: Searches for a single observation in ProtectWise.
  - name: protectwise-observation-info
    arguments:
    - name: id
      required: true
      description: The ID of the observation.
    - name: sensorId
      required: true
      description: The Sensor ID or a comma-separated list of Sensor IDs.
    outputs:
    - contextPath: Protectwise.Observation.id
      description: The ID of the observation.
    - contextPath: Protectwise.Observation.killChainStage
      description: The Killchain Stage of the observation.
    - contextPath: Protectwise.Observation.source
      description: Observation Source
    - contextPath: Protectwise.Observation.sensorId
      description: ID of the Protectwise sensor that generated the observation.
    - contextPath: Protectwise.Observation.threatScore
      description: The threat Score of the observation.
    - contextPath: Protectwise.Observation.severity
      description: The severity of the observation.
    - contextPath: Protectwise.Observation.confidence
      description: The confidence level of the observation.
    - contextPath: Protectwise.Observation.occurredAt
      description: The time the observation occurred.
    - contextPath: Protectwise.Observation.observedAt
      description: The time the observation was Observed.
    - contextPath: Protectwise.Observation.endedAt
      description: The time the observation ended.
    - contextPath: Protectwise.Observation.netflowId
      description: The ID of the Netflow tied to this observation.
    - contextPath: Protectwise.Observation.observedStage
      description: The attack stage reflected by the observation.
    description: Lookup a single observation for ProtectWise. Deprecated - use the protectwise-event-pcap-download command.
  - name: event-pcap-download
    deprecated: true
    arguments:
    - name: eventId
      required: true
      default: true
      description: The event ID.
    - name: filename
      description: The filename for download.
    description: The Event PCAP file to download.
  - name: protectwise-event-pcap-download
    arguments:
    - name: eventId
      required: true
      default: true
      description: The ID of the event.
    - name: filename
      description: The filename for the download.
    description: Event Pcap Download. Deprecated - use the protectwise-event-pcap-info command.
  - name: event-pcap-info
    deprecated: true
    arguments:
    - name: eventId
      required: true
      default: true
      description: The ID of the event.
    description: Returns details of the ProtectWise Event PCAP files.
  - name: protectwise-event-pcap-info
    arguments:
    - name: eventId
      required: true
      default: true
      description: The event ID.
    outputs:
    - contextPath: Protectwise.Event.id
      description: The ID of the Event.
    - contextPath: Protectwise.Event.PCAPSize
      description: Estimated PCAP size in bytes.
    description: Get ProtectWise Event Pcap info. Deprecated - use the protectwise-observation-pcap-download command.
  - name: observation-pcap-download
    deprecated: true
    arguments:
    - name: id
      required: true
      default: true
      description: The ID of the observation.
    - name: sensorId
      required: true
      description: The ID of the sensor.
    - name: filename
      description: The filename for the download.
    description: Downloads the observation PCAP file.
  - name: protectwise-observation-pcap-download
    arguments:
    - name: id
      required: true
      default: true
      description: The ID of the observation.
    - name: sensorId
      required: true
      description: The ID of the sensor.
    - name: filename
      description: The filename for the download.
    description: Downloads the Observation PCAP file. Deprecated - use the protectwise-observation-pcap-info command.
  - name: observation-pcap-info
    deprecated: true
    arguments:
    - name: id
      required: true
      description: The ID of the observation.
    - name: sensorId
      required: true
      description: The ID of the sensor.
    description: Returns PCAP details of observations in Protectwise.
  - name: protectwise-observation-pcap-info
    arguments:
    - name: id
      required: true
      description: The ID of the observation.
    - name: sensorId
      required: true
      description: The ID of the Sensor.
    outputs:
    - contextPath: Protectwise.Observation.id
      description: The ID of the observation.
    - contextPath: Protectwise.Observation.sensorId
      description: The Sensor ID of the observation.
    - contextPath: Protectwise.Observation.PCAPSize
      description: Estimated PCAP size in bytes
    description: Returns ProtectWise Observation PCAP file information.
  - name: get-token
    deprecated: true
    arguments: []
    description: Returns the API token, which is used in the integration configuration.
  isfetch: true
fromversion: 5.0.0
tests:
- Protectwise-Test
