commonfields:
  id: VMware
  version: -1
name: VMware
display: VMware
category: IT Services
image: data:image/png;base64,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
description: VMware vCenter server is a centralized management application that lets you manage virtual machines and ESXi hosts centrally.
configuration:
- display: Server URL (i.e. 192.168.0.1:443)
  name: url
  defaultvalue: ""
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |-
    from pyVim.connect import SmartConnect, Disconnect
    from pyVim.task import WaitForTask
    from pyVmomi import vim
    from pyVmomi import vmodl
    import ssl
    import os
    import sys
    from datetime import datetime

    FULL_URL=demisto.params()['url'].split(':')
    URL=FULL_URL[0]
    USERNAME=demisto.params()['credentials']['identifier']
    PASSWORD=demisto.params()['credentials']['password']
    PORT=str(FULL_URL[1])

    def login():
        s = ssl.SSLContext(ssl.PROTOCOL_TLS)
        s.verify_mode = ssl.CERT_NONE
        try:
            si = SmartConnect(host=URL,
                              user=USERNAME,
                              pwd=PASSWORD,
                              port=PORT)
        except:
            si = SmartConnect(host=URL,
                              user=USERNAME,
                              pwd=PASSWORD,
                              port=PORT,
                              sslContext=s)
        return si

    def logout(si):
        Disconnect(si)

    def get_vm(uuid):
        vm = si.content.searchIndex.FindByUuid(None, uuid, True, True)
        if vm is None:
            raise SystemExit('Unable to locate Virtual Machine.')
        return vm

    def get_vms():
        data = []
        content = si.RetrieveContent()
        container = content.rootFolder
        viewType = [vim.VirtualMachine]
        recursive = True
        containerView = content.viewManager.CreateContainerView(container, viewType, recursive)
        children = containerView.view
        for child in children:
            summary = child.summary
            for dev in child.config.hardware.device:
                if isinstance(dev, vim.vm.device.VirtualEthernetCard):
                    macAddress = dev.macAddress
                    break
            data.append ({
                'Name': summary.config.name,
                'Template': summary.config.template,
                'Path': summary.config.vmPathName,
                'Guest': summary.config.guestFullName,
                'UUID': summary.config.instanceUuid,
                'IP': summary.guest.ipAddress if summary.guest.ipAddress else ' ',
                'State': summary.runtime.powerState,
                'HostName': summary.guest.hostName if summary.guest.hostName else ' ',
                'MACAddress': macAddress if macAddress else ' '
            })
        ec = {
            'VMWare(val.UUID && val.UUID === obj.UUID)': data
        }
        return create_entry(data, ec)

    def create_entry(data, ec):
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': data,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Virtual Machines', data) if data else 'No result were found',
            'EntryContext': ec
        }

    def power_on(uuid):
        vm = get_vm(uuid)

        if vm.runtime.powerState == 'poweredOn':
            raise SystemExit('Virtual Machine is already powered on.')
        task = vm.PowerOn()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            time.sleep(1)
        if task.info.state == 'success':
            ec = {
                'VMWare(val.UUID && val.UUID === obj.UUID)': {
                    'UUID': uuid,
                    'State': 'poweredOn'
                }
            }
            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': ec,
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Virtual Machine was powered on successfully.',
                'EntryContext': ec
            }
        elif task.info.state == 'error':
            raise SystemExit('Error occured while trying to power on Virtual Machine.')

    def power_off(uuid):
        vm = get_vm(uuid)
        if vm.runtime.powerState == 'poweredOff':
            raise SystemExit('Virtual Machine is already powered off.')
        task = vm.PowerOff()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            time.sleep(1)
        if task.info.state == 'success':
            ec = {
                'VMWare(val.UUID && val.UUID === obj.UUID)': {
                    'UUID': uuid,
                    'State': 'poweredOff'
                }
            }
            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': ec,
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Virtual Machine was powered off successfully.',
                'EntryContext': ec
            }
        elif task.info.state == 'error':
            raise SystemExit('Error occured while trying to power off Virtual Machine.')

    def suspend(uuid):
        vm = get_vm(uuid)
        if vm.runtime.powerState == 'suspended':
             raise SystemExit('Virtual Machine is already suspended.')
        task = vm.Suspend()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            time.sleep(1)
        if task.info.state == 'success':
            ec = {
                'VMWare(val.UUID && val.UUID === obj.UUID)': {
                    'UUID': uuid,
                    'State': 'suspended'
                }
            }
            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': ec,
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Virtual Machine was suspended successfully.',
                'EntryContext': ec
            }
        elif task.info.state == 'error':
            raise SystemExit('Error occured while trying to power on Virtual Machine.')

    def hard_reboot(uuid):
        vm = get_vm(uuid)
        task = vm.ResetVM_Task()
        wait_for_tasks(si, [task])
        if task.info.state == 'success':
            ec = {
                'VMWare(val.UUID && val.UUID === obj.UUID)': {
                    'UUID': uuid,
                    'State': 'HardRebooted'
                }
            }
            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': ec,
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Virtual Machine was rebooted successfully.',
                'EntryContext': ec
            }
        elif task.info.state == 'error':
            raise SystemExit('Error occured while trying to reboot Virtual Machine.')

    def wait_for_tasks(si, tasks):
        propertyCollector = si.content.propertyCollector
        taskList = [str(task) for task in tasks]
        objSpecs = [vmodl.query.PropertyCollector.ObjectSpec(obj=task) for task in tasks]
        propertySpec = vmodl.query.PropertyCollector.PropertySpec(type=vim.Task, pathSet=[], all=True)
        filterSpec = vmodl.query.PropertyCollector.FilterSpec()
        filterSpec.objectSet = objSpecs
        filterSpec.propSet = [propertySpec]
        pcfilter = propertyCollector.CreateFilter(filterSpec, True)
        try:
            version, state = None, None
            while len(taskList):
                update = propertyCollector.WaitForUpdates(version)
                for filter_set in update.filterSet:
                    for obj_set in filter_set.objectSet:
                        task = obj_set.obj
                        for change in obj_set.changeSet:
                            if change.name == 'info':
                                state = change.val.state
                            elif change.name == 'info.state':
                                state = change.val
                            else:
                                continue
                            if not str(task) in taskList:
                                continue
                            if state == vim.TaskInfo.State.success:
                                taskList.remove(str(task))
                            elif state == vim.TaskInfo.State.error:
                                raise task.info.error
                version = update.version
        finally:
            if pcfilter:
                pcfilter.Destroy()

    def soft_reboot(uuid):
        vm = get_vm(uuid)
        vm.RebootGuest()
        return 'A request to reboot the guest has been sent.'

    def create_snapshot(args):
        uuid = args['vm-uuid']
        vm = get_vm(uuid)
        d = str(datetime.now())
        if args['memory'] == 'True':
            mem = True
        else:
            mem = False
        if args['quiesce'] == 'True':
            qui = True
        else:
            qui = False
        name = args.get('name', uuid + ' snapshot ' + d)
        desc = args.get('description', 'Snapshot of VM UUID ' + uuid + ' taken on ' + d)
        WaitForTask(vm.CreateSnapshot(name=name, description=desc, memory=mem, quiesce=qui))
        return 'Snapshot ' + name + ' completed.'

    def revert_snapshot(name, uuid):
        vm = get_vm(uuid)
        snapObj = get_snapshots(vm.snapshot.rootSnapshotList, name)
        if len(snapObj) == 1:
            snapObj = snapObj[0].snapshot
            WaitForTask(snapObj.RevertToSnapshot_Task())
            ec = {
                'VMWare(val.UUID && val.UUID === obj.UUID)': {
                    'UUID': uuid,
                    'Snapshot': 'Reverted to ' + name
                }
            }
            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': ec,
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Reverted to snapshot ' + name + ' successfully.',
                'EntryContext': ec
            }
        else:
            return 'No snapshots found with name: ' + name + ' on VM: ' + uuid

    def get_snapshots(snapshots, snapname):
        snapObj = []
        for snapshot in snapshots:
            if snapshot.name == snapname:
                snapObj.append(snapshot)
            else:
                snapObj = snapObj + get_snapshots(snapshot.childSnapshotList, snapname)
        return snapObj

    def get_events(uuid, event_type):
        vm = get_vm(uuid)
        hr = []
        content = si.RetrieveServiceContent()
        eventManager = content.eventManager
        filter = vim.event.EventFilterSpec.ByEntity(entity=vm, recursion="self")
        filterSpec = vim.event.EventFilterSpec()
        ids = event_type.split(',')
        filterSpec.eventTypeId = ids
        filterSpec.entity = filter
        eventRes = eventManager.QueryEvents(filterSpec)
        for e in eventRes:
            hr.append({
                'Event': e.fullFormattedMessage,
                'Created Time': e.createdTime.strftime("%Y-%m-%d %H:%M:%S")
            })
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': hr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('VM ' + vm.summary.config.name + ' Events', hr) if hr else 'No result were found'
        }

    from cStringIO import StringIO
    sout = sys.stdout
    sys.stdout = StringIO()
    res = []
    si = None
    try:
        si = login()

        if demisto.command() == 'test-module':
            result = 'ok'
        if demisto.command() == 'vmware-get-vms':
            result = get_vms()
        if demisto.command() == 'vmware-poweron':
            result = power_on(demisto.args()['vm-uuid'])
        if demisto.command() == 'vmware-poweroff':
            result = power_off(demisto.args()['vm-uuid'])
        if demisto.command() == 'vmware-hard-reboot':
            result = hard_reboot(demisto.args()['vm-uuid'])
        if demisto.command() == 'vmware-suspend':
            result = suspend(demisto.args()['vm-uuid'])
        if demisto.command() == 'vmware-soft-reboot':
            result = soft_reboot(demisto.args()['vm-uuid'])
        if demisto.command() == 'vmware-create-snapshot':
            result = create_snapshot(demisto.args())
        if demisto.command() == 'vmware-revert-snapshot':
            result = revert_snapshot(demisto.args()['snapshot-name'], demisto.args()['vm-uuid'])
        if demisto.command() == 'vmware-get-events':
            result = get_events(demisto.args()['vm-uuid'], demisto.args()['event-type'])
        res.append(result)
    except Exception as ex:
        res.append({ "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : str(ex)})

    try:
        logout(si)
    except Exception as ex:
        res.append({ "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : "Logout failed. " + str(ex)})

    sys.stdout = sout
    demisto.results(res)
    sys.exit(0)
  type: python
  subtype: python2
  commands:
  - name: vmware-get-vms
    arguments: []
    outputs:
    - contextPath: VMWare.Name
      description: VM name
    - contextPath: VMWare.Template
      description: true if template, else false
    - contextPath: VMWare.Path
      description: Path to VM
    - contextPath: VMWare.Guest
      description: Guest full name
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.IP
      description: VM IP address
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
    - contextPath: VMWare.HostName
      description: Host name of VM
    - contextPath: VMWare.MACAddress
      description: MAC Address of VM
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ""
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ""
    description: Returns all virtual machines on a system.
  - name: vmware-poweron
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to be powered on.
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ""
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ""
    description: Powers on a powered-off or suspended virtual machine.
    execution: true
  - name: vmware-poweroff
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to be powered on.
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ""
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ""
    description: Powers off a powered-on or suspended virtual machine.
    execution: true
  - name: vmware-hard-reboot
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to reboot.
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ""
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ""
    description: Reboots a powered-on virtual machine.
    execution: true
  - name: vmware-suspend
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to be suspended.
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ""
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ""
    description: Suspends a powered-on virtual machine.
    execution: true
  - name: vmware-soft-reboot
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to reboot.
    description: Issues a command to the guest operating system asking it to perform
      a reboot.
  - name: vmware-create-snapshot
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to take snapshot of.
    - name: name
      description: Snapshot name
    - name: description
      description: Snapshot description
    - name: memory
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Snapshot the virtual machine's memory
      defaultValue: "True"
    - name: quiesce
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Quiesce guest file system (needs VMWare Tools installed).
      defaultValue: "False"
    description: Creates VM snapshot
  - name: vmware-revert-snapshot
    arguments:
    - name: snapshot-name
      required: true
      description: Snapshot name to revert to
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to revert snapshot.
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.Snapshot
      description: Name of the snapshot reverted to.
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ""
    - contextPath: VMWare.Snapshot
      description: Name of the snapshot reverted to.
      related: ""
    description: Reverts VM to snapshot
    execution: true
  - name: vmware-get-events
    arguments:
    - name: vm-uuid
      required: true
      description: VM UUID of virtual machine to get events of.
    - name: event-type
      description: Type of events to get, given in CSV (i.e.  VmGuestRebootEvent,VmGuestShutdownEvent).
      defaultValue: VmGuestRebootEvent,VmGuestShutdownEvent,VmPoweredOnEvent,VmPoweredOffEvent,VmSuspendedEvent
    description: Gets events of VM
  dockerimage: demisto/vmware:1.0-alpine
