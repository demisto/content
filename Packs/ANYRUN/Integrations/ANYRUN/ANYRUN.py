from requests import Response
import demistomock as demisto
from CommonServerPython import *
from CommonServerUserPython import *

''' IMPORTS '''

import re
import json
from base64 import b64encode

''' GLOBAL VARS / INSTANCE CONFIGURATION '''

# Context fields that should always be uppercase
ALWAYS_UPPER_CASE = {
    'md5', 'sha1', 'sha256', 'sha512', 'pcap', 'ip',
    'url', 'id', 'pid', 'ppid', 'uuid', 'asn', 'mime'
}
THREAT_TEXT_TO_DBOTSCORE = {
    'no threats detected': Common.DBotScore.GOOD,
    'suspicious activity': Common.DBotScore.SUSPICIOUS,
    'malicious activity': Common.DBotScore.BAD
}

''' SETUP '''

# Disable insecure warnings


class Client(BaseClient):

    def handle_error(self, response: Response):
        """Handles any non 200 or 201 response
            codes generated by the file or URL
            submission to ANYRUN

        Parameters
        ----------
        response : dict
            Response received by the ANYRUN command

        Returns
        -------
        None
        """
        message = response.json().get('message')
        return F"API rate limit: {message}"

    def handle_metrics(self, response: Response):
        """Handles any 429 errors associated with API limitations
            Will handle integrations metrics dependant on the response
            status code in the response

        Parameters
        ----------
        response : dict
            Response received from the file or URL submission to ANYRUN

        Returns
        -------
        dict
            If the response is 200 or 201 the JSON of the response is
            returned. If the response is 429 (API rate limit hit)
            not response is returned

        """

        if not response:
            return response
        execution_metrics = ExecutionMetrics()
        if response.status_code == 429:
            execution_metrics.quota_error += 1
            return_results(execution_metrics.metrics)
            return_error(self.handle_error(response))
        else:
            execution_metrics.success += 1
            return_results(execution_metrics.metrics)
        return response.json()

    def get_history(self, args: Dict) -> Dict:
        """Make API call to ANYRUN to get analysis history

        Parameters
        ----------
        args : dict
            URL parameters that determine which, and how many results are
            returned in the response.

        Returns
        -------
        dict
            Response JSON from ANYRUN API call.
        """
        response = self._http_request(
            'GET',
            url_suffix='analysis/',
            params=args
        )
        return response

    def get_report(self, task_id: str) -> Dict:
        """Make API call to ANYRUN to get task report

        Parameters
        ----------
        task_id : str
            The unique task ID of the analysis whose report to fetch.

        Returns
        -------
        dict
            Response JSON from ANYRUN API call.
        """

        try:
            # according to the any-run documentation, this request should work:
            # https://any.run/api-documentation/#api-Analysis-GetReport
            url_suffix = f'analysis/{task_id}'
            response = self._http_request(
                'GET',
                url_suffix=url_suffix
            )
        except DemistoException as exc:
            if exc.res and exc.res.status_code != 403:
                raise

            # in case of 403, try a work-around suggested by customer
            url_suffix = 'analysis/'
            params = {
                'task': task_id,
            }
            response = self._http_request(
                'GET',
                url_suffix=url_suffix,
                params=params
            )

        return response

    def run_analysis(self, args: Dict) -> Dict:
        """Make API call to ANYRUN to submit file or url for analysis

        Parameters
        ----------
        args : dict
            The analysis specifications and data.

        Returns
        -------
        dict
            Response JSON from ANYRUN API call.
        """

        response = None
        try:
            entry_id = args.pop('file', None)
            obj_url = args.get('obj_url')
            obj_type = args.get('obj_type')
            if obj_type == 'remote file':
                obj_type = 'download'
                args['obj_type'] = 'download'
            # In the case only a url was entered but the object type arg wasn't changed
            if not entry_id and obj_url and obj_type == 'file':
                args['obj_type'] = obj_type = 'url'
            files = None
            if obj_type == 'file':
                cmd_res = demisto.getFilePath(entry_id)
                file_path = cmd_res.get('path')
                name = cmd_res.get('name')
                files = {
                    'file': (name, open(file_path, 'rb'))
                }

            # Format command arguments to API's parameter expectations
            env_bitness = int(args.get('env_bitness', 32))
            args['env_bitness'] = env_bitness
            env_version = str(args.get('env_version')).lower()
            if env_version == 'windows vista':
                args['env_version'] = 'vista'
            elif env_version == 'windows 8.1':
                args['env_version'] = '8.1'
            elif env_version == 'windows 10':
                args['env_version'] = '10'
            else:
                args['env_version'] = '7'
            url_suffix = 'analysis'
            response = self._http_request(
                'POST',
                url_suffix=url_suffix,
                json_data=args,
                files=files,
                resp_type='response',
                ok_codes=[200, 201, 429]
            )
        except ValueError:
            err_msg = 'Invalid entryID - File not found for the given entryID'
            return_error(err_msg)
        return self.handle_metrics(response)

    def get_images_from_report(self, response: Dict) -> List:
        """Retrieve images from an ANYRUN report

        Parameters
        ----------
        response : dict
            Object returned by ANYRUN API call in 'get_report' function.

        Returns
        -------
        list
            List of images from ANYRUN report.
        """

        data = response.get('data', {})
        analysis = data.get('analysis', {})
        content = analysis.get('content', {})
        screenshots = content.get('screenshots', [])

        screen_captures = []
        for idx, shot in enumerate(screenshots):
            screen_cap_url = shot.get('permanentUrl')
            img_response = self._http_request(
                'GET',
                full_url=screen_cap_url,
                resp_type='response'
            )
            if img_response.content:
                stored_img = fileResult('screenshot{}.png'.format(idx), img_response.content)
                img_entry = {
                    'Type': entryTypes['image'],
                    'ContentsFormat': formats['text'],
                    'File': stored_img['File'],
                    'FileID': stored_img['FileID'],
                    'Contents': ''
                }
                screen_captures.append(img_entry)
        return screen_captures


''' HELPER FUNCTIONS '''


def underscore_to_camel_case(s: str):
    """
    Convert an underscore separated string to camel case, leaving one-word strings untouched

    Parameters
    ----------
    s : str
        The string to convert (e.g. heLLo_world) (required).

    Returns
    -------
    str
        The converted string (e.g. heLLoWorld).
    """

    if not isinstance(s, str):
        return s
    components = s.split('_')
    return ''.join(x.title() if i != 0 else x for i, x in enumerate(components))


def make_upper(string: str):
    """
    Make argument uppercase if it is a member of 'ALWAYS_UPPER_CASE' global variable

    Parameters
    ----------
    string : str
        The string to check and potentially make uppercase.

    Returns
    -------
    str
        Uppercased string (or original string if it didn't match the criteria).
    """

    if isinstance(string, str):
        if string.casefold() in ALWAYS_UPPER_CASE:
            return string.upper()
        elif string.casefold() == 'ssdeep':  # special case
            return 'SSDeep'
        else:
            return string
    else:
        return string


def make_capital(string: str):
    """Capitalize first letter of a string, leaving the rest of the string as is

    Parameters
    ----------
    string : str
        The string to capitalize (e.g. 'foRUm').

    Returns
    -------
    str
        The capitalized string (e.g. 'FoRUm').
    """

    if isinstance(string, str) and string:
        return string[:1].upper() + string[1:]
    else:
        return string


def make_singular(word: str):
    """Relatively naive/imperfect function to make a word singular

    Parameters
    ----------
    word : str
        The string to make singular (e.g. 'zebras').

    Returns
    -------
    str
        The string in singular form (e.e. 'zebra').
    """

    if not isinstance(word, str) or not word:
        return word

    word_as_lower = word.casefold()
    # Not a plural
    if not word_as_lower.endswith('s'):
        return word
    # Word ends in 's' and is therefore possibly plural
    else:
        es_endings = ('sses', 'shes', 'ches', 'xes', 'zes')
        if word_as_lower.endswith(es_endings):
            # Then the word was pluralized by adding 'es'
            return word[:-2]
        elif word_as_lower.endswith('ss'):
            # Then it's probably not a plural, e.g. 'assess' or 'process'
            return word
        elif len(word) <= 2:
            # Then it's probably not a plural, e.g. 'OS'
            return word
        elif word_as_lower.endswith('sis') or word_as_lower.endswith('us'):
            # Then it's probably singular like 'analysis' and 'cactus' and 'focus'
            return word
        else:
            # Assume regular noun pluralization of adding an 's'
            return word[:-1]


def travel_object(obj,
                  key_functions=[underscoreToCamelCase, make_capital, make_singular, make_upper],
                  val_functions=[]):
    """Recursively apply functions to the keys and values of a dictionary

    Parameters
    ----------
    obj : dict/list
        List or dict to recurse through.
    key_functions : list
        Functions to apply to the keys in 'obj'.
    val_functions : list
        Functions to apply to the values in 'obj'

    Returns
    -------
    list/dict
        A list or dict in which all nested keys and values have been
        altered by the key_functions and val_functions respectively.
    """

    def operate_on_dict(the_dict: Dict):
        new_dict = {}
        for key, val in the_dict.items():
            new_key = key
            for key_func in key_functions:
                new_key = key_func(new_key)
            if isinstance(val, dict) or isinstance(val, list):
                new_val = travel_object(val)
            else:
                new_val = val
                for val_func in val_functions:
                    new_val = val_func(val)
            new_dict[new_key] = new_val
        return new_dict

    if isinstance(obj, list):
        new_list = []
        for item in obj:
            new_item = operate_on_dict(item) if isinstance(item, dict) else item
            new_list.append(new_item)
        return new_list
    elif isinstance(obj, dict):
        altered_dict = operate_on_dict(obj)
        return altered_dict
    else:
        err_msg = 'Invalid type: the passed "obj" argument was not of type "dict" or "list".'
        raise TypeError(err_msg)


def generate_dbotscore(response: Dict) -> List[CommandResults]:
    """Creates CommandResult object based on the contents of 'response' argument
        and provides DBotScore objects.

    Parameters
    ----------
    response : Dict
        Object returned by ANYRUN API call in 'get_report' function.

    Returns
    -------
    List
        A list of CommandResults objects.
    """
    params = demisto.params()
    create_relationships = argToBoolean(params.get('createRelationships', 'true'))
    source_reliability = params.get('integrationReliability')
    data = response.get('data', {})
    analysis = data.get('analysis', {})
    main_object = analysis.get('content', {}).get('mainObject', {})
    submission_type = main_object.get('type')
    submission_type = 'hash' if submission_type in {'file', 'download'} else submission_type
    threat_text = analysis.get('scores', {}).get('verdict', {}).get('threatLevelText', '').casefold()
    reputation_map = {
        "shared": Common.DBotScore.NONE,
        "unknown": Common.DBotScore.NONE,
        "whitelisted": Common.DBotScore.GOOD,
        "malicious": Common.DBotScore.BAD,
        "suspicious": Common.DBotScore.SUSPICIOUS
    }
    returned_data = []
    main_entity = None
    main_entity_type = None

    # Add the hash or URL first
    if submission_type == 'hash':
        hashes = main_object.get('hashes', {})
        info = main_object.get('info', {})
        file_type = info.get('file')
        exif = info.get('exif', {})
        main_entity = hashes.get('sha256') or hashes.get('sha1') or hashes.get('md5')
        main_entity_type = FeedIndicatorType.File
        dbot_score = Common.DBotScore(
            indicator=main_entity,
            indicator_type=DBotScoreType.FILE,
            integration_name='ANYRUN',
            score=THREAT_TEXT_TO_DBOTSCORE.get(threat_text) or Common.DBotScore.NONE,
            reliability=source_reliability
        )
        returned_data.append(CommandResults(
            indicator=Common.File(
                dbot_score=dbot_score,
                md5=hashes.get('md5'),
                sha1=hashes.get('sha1'),
                sha256=hashes.get('sha256'),
                file_type=file_type,
                associated_file_names=exif.get('OriginalFileName')
            )
        ))

    else:
        main_entity = main_object.get('url')
        main_entity_type = FeedIndicatorType.URL
        url_outputs = {
            'Data': main_entity
        }
        dbot_score = Common.DBotScore(
            indicator=main_entity,
            indicator_type=DBotScoreType.URL,
            integration_name='ANYRUN',
            score=THREAT_TEXT_TO_DBOTSCORE.get(threat_text) or Common.DBotScore.NONE,
            reliability=source_reliability
        )
        if dbot_score.score >= Common.DBotScore.SUSPICIOUS:
            url_outputs['Malicious'] = {
                'Vendor': 'ANYRUN',
                'Description': threat_text
            }
        returned_data.append(CommandResults(
            outputs_prefix='URL',
            outputs_key_field=['Data'],
            outputs=url_outputs,
            indicator=Common.URL(
                url=main_entity,
                dbot_score=dbot_score
            )
        ))

    # Check if network information is available in the report
    if 'network' in data:
        network_data = data.get('network', {})

        # Then add all the network-related indicators - 'connections'
        if 'connections' in network_data:
            connections = network_data.get('connections')
            for current_connection in connections:
                reputation = current_connection.get('Reputation')
                if score:= reputation_map.get(reputation):
                    current_dbot_score = Common.DBotScore(
                        indicator=current_connection.get('IP'),
                        indicator_type=DBotScoreType.IP,
                        integration_name='ANYRUN',
                        score=score,
                        reliability=source_reliability
                    )
                    ip_indicator = Common.IP(
                        ip=current_connection.get('IP'),
                        asn=current_connection.get('ASN'),
                        port=current_connection.get('Port'),
                        geo_country=current_connection.get('Country'),
                        dbot_score=current_dbot_score
                    )
                    ip_connection_command_results = CommandResults(
                        readable_output=tableToMarkdown(
                            f"{current_connection.get('IP')}",
                            [{
                                "Description": f"This IP was observed after detonation of {main_entity} in ANYRUN"
                            }]
                        ),
                        indicator=ip_indicator
                    )
                    if create_relationships:
                        ip_indicator_relationships = [EntityRelationship(
                            name=EntityRelationship.Relationships.COMMUNICATED_WITH,
                            entity_a=main_entity,
                            entity_a_type=main_entity_type,
                            entity_b=current_connection.get('IP'),
                            entity_b_type=FeedIndicatorType.IP,
                            brand="ANYRUN",
                            source_reliability=source_reliability
                        )]
                        ip_indicator.relationships = ip_indicator_relationships
                        ip_connection_command_results.relationships=ip_indicator_relationships

                    returned_data.append(ip_connection_command_results)

        # Then add all the network-related indicators - 'dnsRequests'
        if 'dnsRequests' in network_data:
            for current_dnsRequests in network_data.get('dnsRequests'):
                reputation = current_dnsRequests.get('Reputation')
                if score:= reputation_map.get(reputation):
                    current_dbot_score = Common.DBotScore(
                        indicator=current_dnsRequests.get('Domain'),
                        indicator_type=DBotScoreType.DOMAIN,
                        integration_name='ANYRUN',
                        score=score,
                        reliability=source_reliability
                    )
                    domain_indicator = Common.Domain(
                        domain=current_dnsRequests.get('Domain'),
                        dbot_score=current_dbot_score
                    )
                    domain_command_results = CommandResults(
                        readable_output=tableToMarkdown(
                            f"{current_dnsRequests.get('Domain')}",
                            [{
                                "Description": f"This domain was observed after detonation of {main_entity} in ANYRUN"
                            }]
                        ),
                        indicator=domain_indicator
                    )

                    if create_relationships:
                        domain_relationships = [EntityRelationship(
                            name=EntityRelationship.Relationships.COMMUNICATED_WITH,
                            entity_a=main_entity,
                            entity_a_type=main_entity_type,
                            entity_b=current_dnsRequests.get('Domain'),
                            entity_b_type=FeedIndicatorType.Domain,
                            brand="ANYRUN",
                            source_reliability=source_reliability
                        )]
                        domain_command_results.relationships=domain_relationships
                    returned_data.append(domain_command_results)

                    if "IP" in current_dnsRequests:
                        for ip in current_dnsRequests.get('IP', []):
                            domain_ip_dbot_score = Common.DBotScore(
                                indicator=ip,
                                indicator_type=DBotScoreType.IP,
                                integration_name="ANYRUN",
                                score=Common.DBotScore.NONE,
                                reliability=source_reliability
                            )
                            domain_ip_indicator = Common.IP(
                                ip=ip,
                                dbot_score=domain_ip_dbot_score
                            )
                            domain_ip_command_results = CommandResults(
                                indicator=domain_ip_indicator,
                                readable_output=tableToMarkdown(
                                    f"{ip}",
                                    [{
                                        "Description": f"This IP was resovled from {current_dnsRequests.get('Domain')}"
                                    }]
                                )
                            )
                            if create_relationships:
                                domain_ip_relationships = [EntityRelationship(
                                    name=EntityRelationship.Relationships.RESOLVES_TO,
                                    entity_a=current_dnsRequests.get('Domain'),
                                    entity_a_type=FeedIndicatorType.Domain,
                                    entity_b=ip,
                                    entity_b_type=FeedIndicatorType.IP,
                                    source_reliability=source_reliability
                                )]
                                domain_ip_indicator.relationships = domain_ip_relationships
                                domain_ip_command_results.relationships = domain_ip_relationships
                            returned_data.append(domain_ip_command_results)

        # Then add all the network-related indicators - 'httpRequests'
        if 'httpRequests' in network_data:
            for current_httpRequests in network_data.get('httpRequests'):
                reputation = current_httpRequests['Reputation']
                if score:= reputation_map.get(reputation):
                    current_dbot_score = Common.DBotScore(
                        indicator=current_httpRequests.get('URL'),
                        indicator_type=DBotScoreType.URL,
                        integration_name='ANYRUN',
                        score=score,
                        reliability=source_reliability
                    )
                    url_indicator = Common.URL(
                        url=current_httpRequests.get('URL'),
                        geo_country=current_httpRequests.get('Country'),
                        port=current_httpRequests.get('Port'),
                        dbot_score=current_dbot_score
                    )
                    url_command_results = CommandResults(
                        readable_output=tableToMarkdown(
                            f"{current_httpRequests.get('URL')}",
                            [{
                                "Description": f"This URL was observed after detonation of {main_entity} in ANYRUN"
                            }]
                        ),
                        indicator=url_indicator
                    )
                    if create_relationships:
                        url_relationships = [EntityRelationship(
                            name=EntityRelationship.Relationships.COMMUNICATED_WITH,
                            entity_a=main_entity,
                            entity_a_type=main_entity_type,
                            entity_b=current_httpRequests.get('URL'),
                            entity_b_type=FeedIndicatorType.URL,
                            brand="ANYRUN",
                            source_reliability=source_reliability
                        )]
                        url_indicator.relationships=url_relationships
                        url_command_results.relationships=url_relationships
                    
                    returned_data.append(url_indicator)

    if 'mitre' in data:
        mitre_data = data.get('mitre')
        for item in mitre_data:
            attack_indicator = Common.AttackPattern(
                stix_id=None,
                value=item.get('name'),
                mitre_id=item.get('id')
            )
            attack_command_results = CommandResults(
                readable_output=tableToMarkdown(
                    f"{item.get('name')}",
                    [{
                        "Description": f"This Attack Pattern was observed after detonation of {main_entity} in ANYRUN"
                    }]
                ),
                indicator=attack_indicator
            )
            if create_relationships:
                attack_relationships = [EntityRelationship(
                    name=EntityRelationship.Relationships.RELATED_TO,
                    entity_a=main_entity,
                    entity_a_type=main_entity_type,
                    entity_b=item.get('name'),
                    entity_b_type='Attack Pattern',
                    source_reliability=source_reliability
                )]
                attack_command_results.relationships=attack_relationships
            
            returned_data.append(attack_command_results)

    return returned_data


def add_malicious_key(entity: Dict, verdict: Dict):
    """Return the entity with the additional 'Malicious' key if determined as such by ANYRUN

    Parameters
    ----------
    entity : dict
        File or URL object.
    verdict : dict
        Task analysis verdict for a detonated file or url.

    Returns
    -------
    dict
        The modified entity if it was malicious, otherwise the original entity.
    """

    threat_level_text = verdict.get('threatLevelText', '')

    if threat_level_text.casefold() == 'malicious activity':
        entity['Malicious'] = {
            'Vendor': 'ANYRUN',
            'Description': threat_level_text
        }
    return entity


def ec_file(main_object: Dict):
    """Return File entity in Demisto format for use in entry context

    Parameters
    ----------
    main_object : dict
        The main object from a report's contents.

    Returns
    -------
    dict
        File object populated by report contents.
    """

    name = main_object.get('filename')
    hashes = main_object.get('hashes', {})
    md5 = hashes.get('md5')
    sha1 = hashes.get('sha1')
    sha256 = hashes.get('sha256')
    ssdeep = hashes.get('ssdeep')
    ext = main_object.get('info', {}).get('ext')

    file_ec = {
        'File': {
            'Name': name,
            'MD5': md5,
            'SHA1': sha1,
            'SHA256': sha256,
            'SSDeep': ssdeep,
            'Extension': ext
        }
    }
    return file_ec


def ec_url(main_object: Dict):
    """Return URL entity in Demisto format for use in entry context

    Parameters
    ----------
    main_object : dict
        The main object from a report's contents.

    Returns
    -------
    dict
        URL object populated by report contents.
    """

    url = main_object.get('url')

    url_ec = {
        'URL': {
            'Data': url
        }
    }
    return url_ec


def ec_entity(response: Dict):
    """
    Return URL or File entity in Demisto format for use in entry
    context depending on data in 'response' (the report)

    Parameters
    ----------
    response : dict
        Object returned by ANYRUN API call in 'get_report' function.

    Returns
    -------
    dict
        File or URL object populated by report contents.
    """

    analysis = response.get('data', {}).get('analysis', {})
    verdict = analysis.get('scores', {}).get('verdict', {})
    main_object = analysis.get('content', {}).get('mainObject', {})
    submission_type = main_object.get('type')
    entity = None
    if submission_type == 'url':
        entity = ec_url(main_object)
        entity['URL'] = add_malicious_key(entity.get('URL', {}), verdict)
    else:
        entity = ec_file(main_object)
        entity['File'] = add_malicious_key(entity.get('File', {}), verdict)
    return entity


def taskid_from_url(anyrun_url: str):
    """Extract task ID from ANYRUN url inside a 'task' result returned by the get_history command

    Parameters
    ----------
    anyrun_url : str
        URL that contains an ANYRUN task ID.

    Returns
    -------
    str
        An ANYRUN task ID.
    """

    pattern = r'tasks/(.*?)/'
    match = re.search(pattern, anyrun_url)
    if match:
        task_id = match.groups()[0]
    else:
        task_id = None
    return task_id


def contents_from_report(response: Dict):
    """Selectively retrieve content from an ANYRUN report

    Parameters
    ----------
    response : dict
        Object returned by ANYRUN API call in 'get_report' function.

    Returns
    -------
    dict
        Selected content from ANYRUN report.
    """

    data = response.get('data', {})
    environment = data.get('environments', {})
    analysis = data.get('analysis', {})
    processes = data.get('processes', [])
    incidents = data.get('incidents', [])
    status = data.get('status')

    # Retrieve environment info from response
    os = environment.get('os', {}).get('title')

    # Retrieve threat score + info from response
    score = analysis.get('scores', {})
    verdict = score.get('verdict', {})
    threat_level_text = verdict.get('threatLevelText')

    # Retrieve analysis time stuff
    start_text = analysis.get('creationText')

    # Retrieve submitted file info from response
    content = analysis.get('content', {})
    main_object = content.get('mainObject', {})
    info = main_object.get('info', {})
    mime = info.get('mime')
    file_info = info.get('file')
    hashes = main_object.get('hashes')

    # Retrieve network details
    network = data.get('network', {})
    threats = network.get('threats', [])
    connections = network.get('connections', [])
    http_reqs = network.get('httpRequests', [])
    dns_requests = network.get('dnsRequests', [])

    reformatted_threats = []
    for threat in threats:
        reformatted_threat = {
            'ProcessUUID': threat.get('process'),
            'Message': threat.get('msg'),
            'Class': threat.get('class'),
            'SrcPort': threat.get('srcport'),
            'DstPort': threat.get('dstport'),
            'SrcIP': threat.get('srcip'),
            'DstIP': threat.get('dstip')
        }
        reformatted_threats.append(reformatted_threat)
    network['threats'] = reformatted_threats

    reformatted_connections = []
    for connection in connections:
        reformatted_connection = {
            'Reputation': connection.get('reputation'),
            'ProcessUUID': connection.get('process'),
            'ASN': connection.get('asn'),
            'Country': connection.get('country'),
            'Protocol': connection.get('protocol'),
            'Port': connection.get('port'),
            'IP': connection.get('ip')
        }
        reformatted_connections.append(reformatted_connection)
    network['connections'] = reformatted_connections

    reformatted_http_reqs = []
    for http_req in http_reqs:
        reformatted_http_req = {
            'Reputation': http_req.get('reputation'),
            'Country': http_req.get('country'),
            'ProcessUUID': http_req.get('process'),
            'Body': http_req.get('body'),
            'HttpCode': http_req.get('httpCode'),
            'Status': http_req.get('status'),
            'ProxyDetected': http_req.get('proxyDetected'),
            'Port': http_req.get('port'),
            'IP': http_req.get('ip'),
            'URL': http_req.get('url'),
            'Host': http_req.get('host'),
            'Method': http_req.get('method')
        }
        reformatted_http_reqs.append(reformatted_http_req)
    network['httpRequests'] = reformatted_http_reqs

    reformatted_dns_requests = []
    for dns_request in dns_requests:
        reformatted_dns_request = {
            'Reputation': dns_request.get('reputation'),
            'IP': dns_request.get('ips'),
            'Domain': dns_request.get('domain')
        }
        reformatted_dns_requests.append(reformatted_dns_request)
    network['dnsRequests'] = reformatted_dns_requests

    # Retrieve process details
    reformatted_processes = []
    for process in processes:
        context = process.get('context', {})
        reformatted_process = {
            'FileName': process.get('fileName'),
            'PID': process.get('pid'),
            'PPID': process.get('ppid'),
            'ProcessUUID': process.get('uuid'),
            'CMD': process.get('commandLine'),
            'Path': process.get('image'),
            'User': context.get('userName'),
            'IntegrityLevel': context.get('integrityLevel'),
            'ExitCode': process.get('exitCode'),
            'MainProcess': process.get('mainProcess'),
            'Version': process.get('versionInfo', {})
        }
        reformatted_processes.append(reformatted_process)

    # Retrieve incident details
    reformatted_incidents = []
    for incident in incidents:
        reformatted_incident = {
            'ProcessUUID': incident.get('process'),
            'Category': incident.get('desc'),
            'Action': incident.get('title'),
            'ThreatLevel': incident.get('threatLevel')
        }
        reformatted_incidents.append(reformatted_incident)

    # BRE - Network entry added
    contents = {
        'OS': os,
        'AnalysisDate': start_text,
        'Verdict': threat_level_text,
        'MIME': mime,
        'FileInfo': file_info,
        'Process': reformatted_processes,
        'Behavior': reformatted_incidents,
        'Network': network,
        'Status': status
    }

    if hashes:
        for key, val in hashes.items():
            contents[key] = val
    if network:
        for key, val in network.items():
            contents[key] = val

    return contents


def humanreadable_from_report_contents(contents: Dict):
    """Make the selected contents pulled from a report suitable for war room output

    Parameters
    ----------
    contents : dict
        Contents selected from an ANYRUN report for Demisto output.

    Returns
    -------
    dict
        Contents formatted so that nested dicts/lists appear nicely in a war room
        entry.
    """

    def dict_to_string(nested_dict: Dict):
        return json.dumps(nested_dict).lstrip('{').rstrip('}').replace('\'', '').replace('\"', '')

    humanreadable_contents = {}
    for key, val in contents.items():
        if isinstance(val, dict):
            humanreadable_contents[key] = dict_to_string(val)
        elif isinstance(val, list):
            humanreadable_vals = []
            for item in val:
                if isinstance(item, dict):
                    humanreadable_vals.append(dict_to_string(item))
                else:
                    humanreadable_vals.append(item)
            humanreadable_contents[key] = humanreadable_vals
        else:
            humanreadable_contents[key] = val
    return humanreadable_contents


def contents_from_history(filter: str, response: Dict):
    """Return desired fields from filtered response

    Parameters
    ----------
    filter : str
        File name (for a file analysis), URL (for a URL analysis),
        Task ID, or hash by which to filter task history.
    response : dict
        Object returned by ANYRUN API call in 'get_history' function.

    Returns
    -------
    list
        List of Task summaries matching the filter.
    """

    # Filter response
    tasks = response.get('data', {}).get('tasks', {})
    desired_fields = {'related', 'verdict', 'date'}
    filtered_tasks = []
    for task in tasks:
        # First fetch fields that we can filter on
        name = task.get('name')
        hashes = task.get('hashes')
        file_url = task.get('file')
        task_id = taskid_from_url(file_url)

        if filter and filter not in {name, task_id, *hashes.values()}:
            continue

        # Reconstruct task dict with desired output fields if filter satisfied
        filtered_task = {'name': name, 'id': task_id, 'file': file_url, 'hashes': hashes}
        for field in task:
            if field in desired_fields:
                filtered_task[field] = task.get(field)
        filtered_tasks.append(filtered_task)

    return filtered_tasks


''' COMMANDS + REQUESTS FUNCTIONS '''


def test_module(args: Dict, client: Client, ):
    """Performs get_history API call to verify integration is operational

    Returns
    -------
    str
        'ok' message.
    """
    client.get_history({"limit": 1})
    return 'ok'


def get_history_command(args: Dict, client: Client, ):
    """Return ANYRUN task analysis history to XSOAR"""

    filter = args.get('filter')
    response = client.get_history(args)
    contents = contents_from_history(str(filter), response)
    formatted_contents = travel_object(contents)
    if contents:
        reformatted_contents = []
        for task in formatted_contents:
            new_task = {k: v for k, v in task.items()}
            related = task.get('Related', '')
            new_task['Related'] = f'[{related}]({related})'
            reformatted_contents.append(new_task)
        command_results = CommandResults(
            outputs_prefix='ANYRUN.Task',
            outputs_key_field='ID',
            outputs=formatted_contents,
            readable_output=tableToMarkdown(
                f'Task History - Filtered By "{filter}"' if filter else 'Task History',
                reformatted_contents
            )
        )
    else:
        command_results = CommandResults(
            outputs=None,
            readable_output='No results found'
        )

    return command_results


def get_report_command(args: Dict, client: Client):
    """Return ANYRUN analysis report to XSOAR"""
    task_id = args.get('task')
    response = client.get_report(str(task_id))

    images = client.get_images_from_report(response)
    contents = contents_from_report(response)
    reports = response.get('data', {}).get('analysis', {}).get('reports')
    contents['ID'] = task_id
    formatted_contents = travel_object(contents)
    formatted_contents['Reports'] = reports

    dbot_scores: List = generate_dbotscore(response)
    returned_results = []
    returned_results.append(CommandResults(     # noqa: E9007
        outputs_prefix='ANYRUN.Task',
        outputs_key_field='ID',
        outputs=formatted_contents,
        readable_output=tableToMarkdown(
            f'Report for Task {task_id}',
            humanreadable_from_report_contents(formatted_contents),
            removeNull=True
        ),
        raw_response=response
    ))
    for indicator in dbot_scores:
        returned_results.append(indicator)
    for image in images:
        returned_results.append(image)
    return returned_results


@polling_function(
    name=demisto.command(),
    interval=arg_to_number(demisto.args().get('interval_in_seconds', 30)),
    timeout=arg_to_number(demisto.args().get('timeout', 1300))
)
def run_analysis_command(args: Dict, client: Client):
    """Submit file or URL to ANYRUN for analysis and return task ID to XSOAR"""

    task_id = args.get('task_id')
    polling = argToBoolean(args.get('polling', 'false'))
    command_args = {
        k: v for k, v in args.items() if k not in [
            'polling',
            'task_id',
            'interval_in_seconds',
            'timeout',
            'hide_polling_output'
        ]
    }

    # Create a new file / URL submission
    if not task_id:
        response = client.run_analysis(command_args)
        task_id = response.get('data', {}).get('taskid')
        status = response.get('data', {}).get('status') or 'in progress'
        outputs = {
            'ID': task_id
        }
        continue_to_poll = polling
        poll_result = PollResult(
            response=CommandResults(
                outputs_prefix='ANYRUN.Task',
                outputs_key_field='ID',
                outputs=outputs,
                readable_output=tableToMarkdown('Task:', outputs),
                raw_response=response
            ),
            continue_to_poll=continue_to_poll,
            args_for_next_run={
                'task_id': task_id,
                'polling': True
            },
            partial_result=CommandResults(
                readable_output=f"Waiting for submission {task_id} to complete..."
            )
        )

    else:
        response = client.get_report(task_id)
        status = response.get('data', {}).get('status')
        continue_to_poll = True if status != 'done' else False
        contents = contents_from_report(response)
        formatted_contents = travel_object(contents)
        reports = response.get('data', {}).get('analysis', {}).get('reports')

        submit_output = []
        submit_output.append(
            CommandResults(
                outputs_prefix='ANYRUN.Task',
                outputs_key_field='ID',
                outputs={
                    'ID': task_id,
                    'Reports': reports,
                    **formatted_contents
                },
                readable_output=tableToMarkdown(
                    f"Report for Task {task_id}:",
                    humanreadable_from_report_contents(formatted_contents)
                )
            )
        )
        indicators = generate_dbotscore(response)
        for indicator in indicators:
            submit_output.append(indicator)
        images = client.get_images_from_report(response)
        for image in images:
            submit_output.append(image)

        poll_result = PollResult(
            response=submit_output,
            continue_to_poll=continue_to_poll,
            args_for_next_run={
                'task_id': task_id,
                'polling': True,
                'hide_polling_output': True
            }
        )

    return poll_result

''' Main Entry Point '''


def main():
    params = demisto.params()
    args = demisto.args()
    username = params.get('credentials', {}).get('identifier', '')
    password = params.get('credentials', {}).get('password', '')

    # Remove trailing slash to prevent wrong URL path to service
    server = params.get('url', '')
    server = server[:-1] if (server and server.endswith('/')) else server
    base_url = server + '/v1/'
    use_ssl = not params.get('insecure', False)
    proxy = params.get('proxy', False)
    auth = (username + ':' + password).encode('utf-8')
    basic_auth = 'Basic ' + b64encode(auth).decode()
    headers = {
        'Authorization': basic_auth
    }
    commands = {
        'test-module': test_module,
        'anyrun-get-history': get_history_command,
        'anyrun-get-report': get_report_command,
        'anyrun-run-analysis': run_analysis_command,
    }

    #try:
    command = demisto.command()
    demisto.info(f'Command being called is {command}')
    client = Client(
        base_url=base_url,
        verify=use_ssl,
        proxy=proxy,
        headers=headers
    )

    if command in commands:
        return_results(commands[command](args, client))
    else:
        raise NotImplementedError(f'{command} command is not implemented.')

    #except Exception as e:
    #    demisto.error(traceback.format_exc())  # print the traceback
    #    return_error(f'Failed to execute {command} command.\nError:\n{str(e)}')


if __name__ in ('__builtin__', 'builtins'):
    main()
