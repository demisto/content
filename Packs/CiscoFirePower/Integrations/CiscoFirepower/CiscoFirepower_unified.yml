category: Network Security
commonfields:
  id: Cisco Firepower
  version: -1
configuration:
- display: Server URL (e.g. https://example.com)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Cisco Firepower provides complete and unified management of firewalls,
  application control, intrusion prevention, URL filtering, and advanced malware protection
detaileddescription: |-
  Authentication from a REST API Client
  Cisco recommends that you use different accounts for interfacing with the API and the Firepower User Interface. Credentials cannot be used for both interfaces simultaneously, and will be logged out without warning if used for both.

  The first time you connect to the REST API you may receive an error that the connection is not secure due to an invalid certificate. Add an exception in your browser to use the certificate and accept the connection.

  With Token Based Authentication you obtain a token by providing your username and password. You use this token to access an HTTP service for a limited time period without the need for the username and password with every request. In other words, to eliminate the need for authenticating with your username and password with each request.
display: Cisco Firepower
name: Cisco Firepower
script:
  commands:
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all security zone objects.
    execution: false
    name: ciscofp-list-zones
    outputs:
    - contextPath: CiscoFP.Zone.ID
      description: Zone ID
      type: String
    - contextPath: CiscoFP.Zone.Name
      description: Zone Name
      type: String
    - contextPath: CiscoFP.Zone.InterfaceMode
      description: Zone Interface mode
      type: String
    - contextPath: CiscoFP.Zone.Interfaces.Name
      description: Name of interfaces belonging to security zone.
      type: String
    - contextPath: CiscoFP.Zone.Interfaces.ID
      description: ID of interfaces belonging to security zone.
      type: String
  - arguments:
    - default: true
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all port objects.
    execution: false
    name: ciscofp-list-ports
    outputs:
    - contextPath: CiscoFP.Port.ID
      description: ID of port
      type: String
    - contextPath: CiscoFP.Port.Name
      description: Name of port
      type: String
    - contextPath: CiscoFP.Port.Protocol
      description: protocol of port
      type: String
    - contextPath: CiscoFP.Port.Port
      description: port number
      type: String
  - arguments:
    - default: true
      defaultValue: '50'
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all url category objects.
    execution: false
    name: ciscofp-list-url-categories
    outputs:
    - contextPath: CiscoFP.Category.ID
      description: ID of category
      type: String
    - contextPath: CiscoFP.Category.Name
      description: Name of category
      type: String
  - arguments:
    - default: false
      description: Object ID
      isArray: false
      name: object_id
      required: false
      secret: false
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves the network objects associated with the specified ID. If
      not input ID retrieves list of all network objects.
    execution: false
    name: ciscofp-get-network-object
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of network object
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of network object
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CIDR
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of network object
      type: String
  - arguments:
    - default: false
      description: Set the name of the new object.
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: CIDR
      isArray: false
      name: value
      required: true
      secret: false
    - default: false
      description: object description.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Boolean indicating whether object can be overridden.
      isArray: false
      name: overridable
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
    deprecated: false
    description: Creats network object
    execution: false
    name: ciscofp-create-network-object
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of network object
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of network object
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CIDR
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of network object
      type: String
  - arguments:
    - default: false
      description: ID of the object to update.
      isArray: false
      name: id
      required: true
      secret: false
    - default: false
      description: Name of the object.
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: CIDR
      isArray: false
      name: value
      required: true
      secret: false
    - default: false
      description: Description of the object.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Boolean indicating whether object can be overridden.
      isArray: false
      name: overridable
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
    deprecated: false
    description: Update network object
    execution: false
    name: ciscofp-update-network-object
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of network object
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of network object
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CIDR
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of network object
      type: String
  - arguments:
    - default: false
      description: ID of the object group you are interested
      isArray: false
      name: id
      required: false
      secret: false
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves the groups of network objects and addresses associated
      with the specified ID. If not input ID retrieves list of all network objects.
    execution: false
    name: ciscofp-get-network-groups-object
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: id of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: Name of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: Description of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address / CIDR range
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: Address type
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: Object name
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: Object id
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: Object type
      type: String
  - arguments:
    - default: false
      description: The name of the group
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: A comma-separated list of object id to add to the group
      isArray: false
      name: network_objects_id_list
      required: false
      secret: false
    - default: false
      description: A comma-separated list of ip addresses or CIDR ranges to add the
        group
      isArray: false
      name: network_address_list
      required: false
      secret: false
    - default: false
      description: object description.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Boolean indicating whether object values can be overridden.
      isArray: false
      name: overridable
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
    deprecated: false
    description: Create group of network objects
    execution: false
    name: ciscofp-create-network-groups-objects
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: ID of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: Name of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: Description of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address / CIDR range
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: Address type
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: Object name
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: Object id
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: Object type
      type: String
  - arguments:
    - default: false
      description: The id of the group you want to update
      isArray: false
      name: id
      required: true
      secret: false
    - default: false
      description: A comma-separated list of object id to add the group
      isArray: false
      name: network_objects_id_list
      required: false
      secret: false
    - default: false
      description: A comma-separated list of ip addresses or CIDR ranges to add the
        group
      isArray: false
      name: network_address_list
      required: false
      secret: false
    - default: false
      description: New object description.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: Boolean indicating whether object values can be overridden.
      description: Boolean indicating whether object values can be overridden.
      isArray: false
      name: overridable
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - default: false
      description: The name of the group
      isArray: false
      name: name
      required: true
      secret: false
    deprecated: false
    description: Update group of network objects
    execution: false
    name: ciscofp-update-network-groups-objects
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: ID of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: Name of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: Description of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address / CIDR range
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: Address type
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: Object name
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: Object id
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: Object type
      type: String
  - arguments:
    - default: false
      description: ID of the object to delete.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Delete group of network objects
    execution: false
    name: ciscofp-delete-network-groups-objects
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: Id of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: Iame of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: Description of the group
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address CIDR range
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: Address type
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: Object name
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: Object id
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: Object type
      type: String
  - arguments:
    - default: false
      description: ID of the object you are interested
      isArray: false
      name: object_id
      required: false
      secret: false
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves the groups of host objects associated with the specified
      ID. If not input ID retrieves list of all network objects.
    execution: false
    name: ciscofp-get-host-object
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of host object
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of host object
      type: String
    - contextPath: CiscoFP.Host.Value
      description: IP address
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of host object
      type: String
  - arguments:
    - default: false
      description: Set the name of the new object
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: IP address.
      isArray: false
      name: value
      required: true
      secret: false
    - default: false
      description: New object description.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Boolean indicating whether object can be overridden.
      isArray: false
      name: overridable
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
    deprecated: false
    description: Create host object
    execution: false
    name: ciscofp-create-host-object
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of host object
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of host object
      type: String
    - contextPath: CiscoFP.Host.Value
      description: IP address
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of host object
      type: String
  - arguments:
    - default: false
      description: ID of the object to update.
      isArray: false
      name: id
      required: true
      secret: false
    - default: false
      description: Name of the object.
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: ip address.
      isArray: false
      name: value
      required: true
      secret: false
    - default: false
      description: Description of the object.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Boolean indicating whether object can be overridden.
      isArray: false
      name: overridable
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
    deprecated: false
    description: Update host object
    execution: false
    name: ciscofp-update-host-object
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of host object
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of host object
      type: String
    - contextPath: CiscoFP.Host.Value
      description: IP address
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of host object
      type: String
  - arguments:
    - default: false
      description: ID of the object to delete.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: delete network object
    execution: false
    name: ciscofp-delete-network-object
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of network object
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of network object
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CISR range
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of network object
      type: String
  - arguments:
    - default: false
      description: ID of the object to delete.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Delete host object
    execution: false
    name: ciscofp-delete-host-object
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of host object
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of host object
      type: String
    - contextPath: CiscoFP.Host.Value
      description: cidr range
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: ‘true’ if the object can be overridden, ‘false’ otherwise.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of host object
      type: String
  - arguments:
    - default: false
      description: ID of the access policy
      isArray: false
      name: id
      required: false
      secret: false
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves the access control policy associated with the specified
      ID. Also, retrieves list of all access control policies
    execution: false
    name: ciscofp-get-access-policy
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The id of policy
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: the name of the policy
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: Default action id of policy
      type: String
  - arguments:
    - default: false
      description: Set the name of the new access policy.
      isArray: false
      name: name
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: rule action
      isArray: false
      name: action
      predefined:
      - BLOCK
      - TRUST
      - PERMIT
      - NETWORK_DISCOVERY
      required: true
      secret: false
    deprecated: false
    description: Create access control policy
    execution: false
    name: ciscofp-create-access-policy
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The id of policy
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: Default action id of policy
      type: String
  - arguments:
    - default: false
      description: Access policy name
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: ID of access policy
      isArray: false
      name: id
      required: true
      secret: false
    - default: false
      description: ID of default action
      isArray: false
      name: default_action_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Action to take
      isArray: false
      name: action
      predefined:
      - BLOCK
      - TRUST
      - PERMIT
      - NETWORK_DISCOVERY
      required: true
      secret: false
    deprecated: false
    description: Update access control policy
    execution: false
    name: ciscofp-update-access-policy
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The id of policy
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: Default action id of policy
      type: String
  - arguments:
    - default: false
      description: ID of access policy
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Delete access control policy
    execution: false
    name: ciscofp-delete-access-policy
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The id of policy
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: Default action id of policy
      type: String
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all custom security group tag objects.
    execution: false
    name: ciscofp-list-security-group-tags
    outputs:
    - contextPath: CiscoFP.SecurityGroupTags.ID
      description: ID of security group tag
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Name
      description: Name of security group tag
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Tag
      description: Tag number
      type: Number
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all ISE security group tag objects.
    execution: false
    name: ciscofp-list-ise-security-group-tag
    outputs:
    - contextPath: CiscoFP.SecurityGroupTags.ID
      description: ID of security group tag
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Name
      description: Name of security group tag
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Tag
      description: Tag namber
      type: Number
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all vlantag objects.
    execution: false
    name: ciscofp-list-vlan-tags
    outputs:
    - contextPath: CiscoFP.VlanTags.ID
      description: ID of vlan tag
      type: String
    - contextPath: CiscoFP.VlanTags.Name
      description: Name of vlan tag
      type: Unknown
    - contextPath: CiscoFP.VlanTags.Overridable
      description: Boolean indicating whether object values can be overridden
      type: Unknown
    - contextPath: CiscoFP.VlanTags.Description
      description: Description of vlan tag
      type: Unknown
    - contextPath: CiscoFP.VlanTags.StartTag
      description: Start tag number
      type: Number
    - contextPath: CiscoFP.VlanTags.EndTag
      description: End tag number
      type: Number
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all vlan group tag objects.
    execution: false
    name: ciscofp-list-vlan-tags-group
    outputs:
    - contextPath: CiscoFP.VlanTagsGroup.Name
      description: Name of group
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.ID
      description: ID of group
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Description
      description: Description of object
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Overridable
      description: Boolean indicating whether object values can be overridden
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Objects.Name
      description: Name of object
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.Objects.ID
      description: ID of object
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Objects.Description
      description: Description of vlan tag
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Objects.Overridable
      description: Boolean indicating whether object values can be overridden
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Objects.StartTag
      description: Start tag number
      type: Unknown
    - contextPath: CiscoFP.VlanTagsGroup.Objects.EndTag
      description: End tag number
      type: Unknown
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all application objects.
    execution: false
    name: ciscofp-list-applications
    outputs:
    - contextPath: CiscoFP.Applications.Name
      description: Name of Application
      type: String
    - contextPath: CiscoFP.Applications.ID
      description: ID of Application
      type: String
    - contextPath: CiscoFP.Applications.Risk
      description: Risk of Application
      type: String
    - contextPath: CiscoFP.Applications.AppProductivity
      description: AppProductivity of Application
      type: Unknown
    - contextPath: CiscoFP.Applications.ApplicationTypes
      description: Application Type
      type: String
    - contextPath: CiscoFP.Applications.AppCategories.ID
      description: AppCategory id
      type: String
    - contextPath: CiscoFP.Applications.AppCategories.Name
      description: AppCategory name
      type: String
    - contextPath: CiscoFP.Applications.AppCategories.Count
      description: AppCategory count
      type: String
  - arguments:
    - default: false
      description: Policy id
      isArray: false
      name: policy_id
      required: true
      secret: false
    - default: false
      description: Rule ID
      isArray: false
      name: rule_id
      required: false
      secret: false
    deprecated: false
    description: Retrieves the access control rule associated with the specified policy
      ID and rule ID. If no rule ID is specified, retrieves list of all access rules
      associated with the specified policy ID.
    execution: false
    name: ciscofp-get-access-rules
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: Rule Action
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: Application object id
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: Application object name
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: Category of rule
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: Address type
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: ip Address / CIDR range
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: Object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: Object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: Object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: port number
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: port Protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: port object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: port object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: port object protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: port object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: zone id
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: zone name
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: zone type
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: is rule enable or not
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: rule id
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: rule name
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: the index of the rule
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: the section of the rule
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to the Firepower
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: address ip / CIDR range
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: port number
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: port protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: object protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.Uels.Addresses.URL
      description: url address
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.ID
      description: url object id
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.Name
      description: url object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: vlan tag number end tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: vlan tag number start tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: object type
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: rule's traffic
      isArray: false
      name: action
      predefined:
      - ALLOW
      - TRUST
      - BLOCK
      - MONITOR
      - BLOCK_RESET
      - BLOCK_INTERACTIVE
      - BLOCK_RESET_INTERACTIVE
      required: true
      secret: false
    - default: false
      description: the role name
      isArray: false
      name: rule_name
      required: true
      secret: false
    - auto: PREDEFINED
      default: true
      description: Boolean indicating to enable or not.
      isArray: false
      name: enabled
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - default: false
      description: list of source Zones object id - use ciscofp-list-zones command
      isArray: true
      name: source_zone_object_ids
      required: false
      secret: false
    - default: false
      description: policy id to create there the new role
      isArray: false
      name: policy_id
      required: true
      secret: false
    - default: false
      description: list of destination Zones object id - use ciscofp-list-zones
      isArray: true
      name: destination_zone_object_ids
      required: false
      secret: false
    - default: false
      description: list of vlan Tags object id - use ciscofp-list-vlan-tags
      isArray: true
      name: vlan_tag_object_ids
      required: false
      secret: false
    - default: false
      description: list of network object id  - use ciscofp-get-network-groups-object
      isArray: true
      name: source_network_object_ids
      required: false
      secret: false
    - default: false
      description: list of IP addresses / CIDR ranges - use ciscofp-get-network-object
        / ciscofp-get-host-object
      isArray: true
      name: source_network_addresses
      required: false
      secret: false
    - default: false
      description: source_network_object_ids  - use ciscofp-get-network-object / ciscofp-get-host-object
      isArray: true
      name: destination_network_object_ids
      required: false
      secret: false
    - default: false
      description: list of addresses
      isArray: true
      name: destination_network_addresses
      required: false
      secret: false
    - default: false
      description: list of port object id - use ciscofp-get-network-object / ciscofp-get-host-object
      isArray: false
      name: source_port_object_ids
      required: false
      secret: false
    - default: false
      description: list of port object id - use ciscofp-list-ports
      isArray: false
      name: destination_port_object_ids
      required: false
      secret: false
    - default: false
      description: list of security group tag object id - use ciscofp-list-security-group-tags
      isArray: false
      name: source_security_group_tag_object_ids
      required: false
      secret: false
    - default: false
      description: list of application object id - use ciscofp-list-applications
      isArray: true
      name: application_object_ids
      required: false
      secret: false
    - default: false
      description: list of url object id - use ciscofp-list-url-categories
      isArray: true
      name: url_object_ids
      required: false
      secret: false
    - default: false
      description: list of url addresses
      isArray: true
      name: url_addresses
      required: false
      secret: false
    deprecated: false
    description: create access control rule
    execution: false
    name: ciscofp-create-access-rules
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: action determines how the system handles matching traffic
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: application object id
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: application object name
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: category of rule
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: address value
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: the port
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: port object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: port object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: port object protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: port object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: zone id
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: zone name
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: zone type
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Boolean indicating to enable or not
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: rule id
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: rule name
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: the index of the rule
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: the section of the rule
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to the Firepower
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: address value
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: address port
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: address protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: object protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.Uels.Addresses.URL
      description: url
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.ID
      description: url object id
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.Name
      description: url object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: vlan tag number end tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: vlan tag number start tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: object type
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: |-
        merge will add the changes requested to the existing rule
        override will override the fields with the inputs provided, and will delete any fields that were not provided
      isArray: false
      name: update_strategy
      predefined:
      - merge
      - override
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Action—A rule's action determines how the system handles matching
        traffic
      isArray: false
      name: action
      predefined:
      - ALLOW
      - TRUST
      - BLOCK
      - MONITOR
      - BLOCK_RESET
      - BLOCK_INTERACTIVE
      - BLOCK_RESET_INTERACTIVE
      required: false
      secret: false
    - default: false
      description: the role name
      isArray: false
      name: rule_name
      required: false
      secret: false
    - auto: PREDEFINED
      default: true
      description: Boolean indicating to enable or not.
      isArray: false
      name: enabled
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - default: false
      description: list of source Zones object id
      isArray: true
      name: source_zone_object_ids
      required: false
      secret: false
    - default: false
      description: policy id to create there the new role
      isArray: false
      name: policy_id
      required: true
      secret: false
    - default: false
      description: list of destination Zones object id
      isArray: true
      name: destination_zone_object_ids
      required: false
      secret: false
    - default: false
      description: list of vlan Tags object id
      isArray: true
      name: vlan_tag_object_ids
      required: false
      secret: false
    - default: false
      description: list of network object id
      isArray: true
      name: source_network_object_ids
      required: false
      secret: false
    - default: false
      description: list of addresses
      isArray: true
      name: source_network_addresses
      required: false
      secret: false
    - default: false
      description: source_network_object_ids
      isArray: true
      name: destination_network_object_ids
      required: false
      secret: false
    - default: false
      description: list of addresses
      isArray: true
      name: destination_network_addresses
      required: false
      secret: false
    - default: false
      description: list of port object id
      isArray: false
      name: source_port_object_ids
      required: false
      secret: false
    - default: false
      description: list of port object id
      isArray: false
      name: destination_port_object_ids
      required: false
      secret: false
    - default: false
      description: list of security group tag object id
      isArray: false
      name: source_security_group_tag_object_ids
      required: false
      secret: false
    - default: false
      description: list of application object id
      isArray: true
      name: application_object_ids
      required: false
      secret: false
    - default: false
      description: list of url object id
      isArray: true
      name: url_object_ids
      required: false
      secret: false
    - default: false
      description: list of url_addresses
      isArray: true
      name: url_addresses
      required: false
      secret: false
    - default: false
      description: the id of the rule to update
      isArray: false
      name: rule_id
      required: true
      secret: false
    deprecated: false
    description: update access control rule
    execution: false
    name: ciscofp-update-access-rules
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: action determines how the system handles matching traffic
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: application object id
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: application object name
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: category of rule
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: address value
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: the port
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: port object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: port object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: port object protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: port object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: zones id
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: zones name
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: zones type
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Boolean indicating to enable or not
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: rule id
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: rule name
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: the index of the rule
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: the section of the rule
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to the Firepower
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: address value
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: address port
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: address protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: object protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.Uels.Addresses.URL
      description: url
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.ID
      description: url object id
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.Name
      description: url object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: vlan tag number end tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: vlan tag number start tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: object type
      type: String
  - arguments:
    - default: false
      description: the policy id
      isArray: false
      name: policy_id
      required: true
      secret: false
    - default: false
      description: the role id to delete
      isArray: false
      name: rule_id
      required: true
      secret: false
    deprecated: false
    description: delete access control rule
    execution: false
    name: ciscofp-delete-access-rules
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: action determines how the system handles matching traffic
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: application object id
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: application object name
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: category of rule
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: address value
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: the port
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: port object id
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: port object name
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: port object protocol
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: port object type
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: zones id
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: zones name
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: zones type
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Boolean indicating to enable or not
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: rule id
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: rule name
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: the index of the rule
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: the section of the rule
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to the Firepower
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: address type
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: address value
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: address port
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: address protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: object protocol
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: object type
      type: String
    - contextPath: CiscoFP.Rule.Uels.Addresses.URL
      description: url
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.ID
      description: url object id
      type: String
    - contextPath: CiscoFP.Rule.Uels.Objects.Name
      description: url object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: vlan tag number end tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: vlan tag number start tag
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: object id
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: object name
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: object type
      type: String
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: retrieves list of all policy assignments to target devices.
    execution: false
    name: ciscofp-list-policy-assignments
    outputs:
    - contextPath: CiscoFP.PolicyAssignments.ID
      description: policy assignments id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Name
      description: policy assignments name
      type: Unknown
    - contextPath: CiscoFP.PolicyAssignments.PolicyDescription
      description: policy description
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyID
      description: policy id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyName
      description: policy name
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.ID
      description: targets id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Name
      description: targets name
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Type
      description: targets type
      type: String
  - arguments:
    - default: false
      description: policy id
      isArray: false
      name: policy_id
      required: true
      secret: false
    - default: false
      description: list of device id
      isArray: true
      name: device_ids
      required: false
      secret: false
    - default: false
      description: list of device group id
      isArray: true
      name: device_group_ids
      required: false
      secret: false
    deprecated: false
    description: create policy assignments to target devices.
    execution: false
    name: ciscofp-create-policy-assignments
    outputs:
    - contextPath: CiscoFP.PolicyAssignments.ID
      description: policy assignments id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Name
      description: policy assignments name
      type: Unknown
    - contextPath: CiscoFP.PolicyAssignments.PolicyDescription
      description: policy description
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyID
      description: policy id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyName
      description: policy name
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.ID
      description: targets id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Name
      description: targets name
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Type
      description: targets type
      type: String
  - arguments:
    - default: false
      description: polisy id
      isArray: false
      name: policy_id
      required: false
      secret: false
    - default: false
      description: list of device id
      isArray: false
      name: device_ids
      required: false
      secret: false
    - default: false
      description: list of device group id
      isArray: false
      name: device_group_ids
      required: false
      secret: false
    deprecated: false
    description: Update policy assignments to target devices.
    execution: false
    name: ciscofp-update-policy-assignments
    outputs:
    - contextPath: CiscoFP.PolicyAssignments.ID
      description: policy assignments id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Name
      description: policy assignments name
      type: Unknown
    - contextPath: CiscoFP.PolicyAssignments.PolicyDescription
      description: policy description
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyID
      description: policy id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyName
      description: policy name
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.ID
      description: targets id
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Name
      description: targets name
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Type
      description: targets type
      type: String
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: Retrieves list of all devices with configuration changes, ready to
      be deployed.
    execution: false
    name: ciscofp-get-deployable-devices
    outputs:
    - contextPath: CiscoFP.DeployableDevices.CanBeDeployed
      description: can be deployed
      type: String
    - contextPath: CiscoFP.DeployableDevices.UpToDate
      description: up to date
      type: String
    - contextPath: CiscoFP.DeployableDevices.DeviceID
      description: device Id
      type: String
    - contextPath: CiscoFP.DeployableDevices.DeviceName
      description: device name
      type: String
    - contextPath: CiscoFP.DeployableDevices.DeviceType
      description: device type
      type: String
    - contextPath: CiscoFP.DeployableDevices.Version
      description: version
      type: String
  - arguments:
    - default: false
      description: |-
        Number of items to return.
        by default is 50
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: |-
        Index of first item to return.
        by default is 0
      isArray: false
      name: offset
      required: false
      secret: false
    deprecated: false
    description: retrieves list of all device records.
    execution: false
    name: ciscofp-get-device-records
    outputs:
    - contextPath: CiscoFP.DeviceRecords.DeviceGroupID
      description: device group id
      type: String
    - contextPath: CiscoFP.DeviceRecords.HostName
      description: device host
      type: String
    - contextPath: CiscoFP.DeviceRecords.ID
      description: device id
      type: String
    - contextPath: CiscoFP.DeviceRecords.Name
      description: device name
      type: String
    - contextPath: CiscoFP.DeviceRecords.Type
      description: device type
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: Boolean of force deploy
      isArray: false
      name: force_deploy
      predefined:
      - 'true'
      - 'false'
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Boolean of ignore warning
      isArray: false
      name: ignore_warning
      predefined:
      - 'true'
      - 'false'
      required: true
      secret: false
    - default: false
      description: list of device id
      isArray: true
      name: device_ids
      required: true
      secret: false
    - default: false
      description: the version to deploy - use ciscofp-get-deployable-devices
      isArray: false
      name: version
      required: true
      secret: false
    deprecated: false
    description: Creates a request for deploying configuration changes to devices.
    execution: false
    name: ciscofp-deploy-to-devices
    outputs:
    - contextPath: CiscoFP.Deploy.TaskID
      description: task id
      type: String
    - contextPath: CiscoFP.Deploy.ForceDeploy
      description: force deploy
      type: String
    - contextPath: CiscoFP.Deploy.IgnoreWarning
      description: ignore warning
      type: String
    - contextPath: CiscoFP.Deploy.Version
      description: The version of the policy
      type: String
    - contextPath: CiscoFP.Deploy.DeviceList
      description: device list
      type: String
  - arguments:
    - default: false
      description: the id of the task to check the status
      isArray: false
      name: task_id
      required: true
      secret: false
    deprecated: false
    description: Retrieves information about a previously submitted pending job/task
      with the specified ID. Used for deploying
    execution: false
    name: ciscofp-get-task-status
    outputs:
    - contextPath: CiscoFP.TaskStatus.Status
      description: task status
      type: Unknown
  dockerimage: demisto/python3:3.8.1.5734
  feed: false
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: |-
    ''' IMPORTS '''
    from typing import Dict, Tuple, List, Union
    import urllib3

    """Example for Analytics and SIEM integration
    """
    # Disable insecure warnings
    urllib3.disable_warnings()

    '''GLOBALS/PARAMS'''

    INTEGRATION_NAME = 'Cisco Fire Power'
    # lowercase with `-` dividers
    INTEGRATION_COMMAND_NAME = 'ciscofp'
    # No dividers
    INTEGRATION_CONTEXT_NAME = 'CiscoFP'

    OUTPUT_KEYS_DICTIONARY = {
        'id': 'ID'
    }


    class Client(BaseClient):
        def login(self):
            """update the X-auth-access-token in the client.
            """
            new_headers = self._http_request(
                'POST',
                url_suffix='/api/fmc_platform/v1/auth/generatetoken',
                resp_type='response'
            ).headers
            self._headers = {'X-auth-access-token': new_headers.get('X-auth-access-token')}
            self._base_url += f'/api/fmc_config/v1/domain/{new_headers.get("DOMAIN_UUID")}/'
            if self._headers['X-auth-access-token'] == '':
                return_error('No valid access token')
            return

        def get_list(self, limit, offset, object_path) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = f'object/{object_path}'
            return self._http_request('GET', suffix, params=params)

        def list_policy_assignments(self, limit, offset) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = 'assignment/policyassignments'
            return self._http_request('GET', suffix, params=params)

        def get_deployable_devices(self, limit, offset) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = 'deployment/deployabledevices'
            return self._http_request('GET', suffix, params=params)

        def get_device_records(self, limit, offset) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = 'devices/devicerecords'
            return self._http_request('GET', suffix, params=params)

        def get_network_objects(self, limit, offset, object_id) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/networks{end_suffix}'
            return self._http_request('GET', suffix)

        def get_hosts_objects(self, limit, offset, object_id) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/hosts{end_suffix}'
            return self._http_request('GET', suffix)

        def create_network_objects(self, name, value, description, overridable) -> Dict:
            data = {'name': name, 'value': value, 'description': description, 'overridable': overridable}
            suffix = 'object/networks'
            return self._http_request('POST', suffix, json_data=data)

        def create_host_objects(self, name, value, description, overridable) -> Dict:
            data = {'name': name, 'value': value, 'description': description, 'overridable': overridable}
            suffix = 'object/hosts'
            return self._http_request('POST', suffix, json_data=data)

        def update_network_objects(self, name, value, description, overridable, object_id) -> Dict:
            data = assign_params(id=object_id, name=name, value=value, description=description, overridable=overridable)
            suffix = f'object/networks/{object_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def update_host_objects(self, name, value, description, overridable, object_id) -> Dict:
            data = assign_params(id=object_id, name=name, value=value, description=description, overridable=overridable)
            suffix = f'object/hosts/{object_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def delete_network_objects(self, object_id) -> Dict:
            suffix = f'object/networks/{object_id}'
            return self._http_request('DELETE', suffix)

        def delete_host_objects(self, object_id) -> Dict:
            suffix = f'object/hosts/{object_id}'
            return self._http_request('DELETE', suffix)

        def get_network_groups_objects(self, limit, offset, object_id) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/networkgroups{end_suffix}'
            return self._http_request('GET', suffix)

        def create_network_groups_objects(self, name, ids, values, description, overridable) -> Dict:
            objects = [{'id': curr_id} for curr_id in argToList(ids)]
            values = [{'value': curr_value} for curr_value in argToList(values)]
            data = assign_params(
                name=name, objects=objects, literals=values, description=description, overridable=overridable)
            suffix = 'object/networkgroups'
            return self._http_request('POST', suffix, json_data=data)

        def update_network_groups_objects(self, name, ids, values, group_id, description, overridable) -> Dict:
            objects = [{'id': curr_id} for curr_id in argToList(ids)]
            values = [{'value': curr_value} for curr_value in argToList(values)]
            data = assign_params(name=name, id=group_id, objects=objects, literals=values,
                                 description=description, overridable=overridable)
            suffix = f'object/networkgroups/{group_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def delete_network_groups_objects(self, object_id) -> Dict:
            suffix = f'object/networkgroups/{object_id}'
            return self._http_request('DELETE', suffix)

        def get_access_policy(self, limit, offset, policy_id) -> Dict:
            end_suffix = f'/{policy_id}' if policy_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'policy/accesspolicies{end_suffix}'
            return self._http_request('GET', suffix)

        def create_access_policy(self, name, action) -> Dict:
            data = {'name': name, 'defaultAction': {'action': action}}
            suffix = 'policy/accesspolicies'
            return self._http_request('POST', suffix, json_data=data)

        def update_access_policy(self, name, policy_id, action, action_id) -> Dict:
            data = {
                'name': name,
                'id': policy_id,
                'defaultAction': {
                    'action': action,
                    'id': action_id
                }}
            suffix = f'policy/accesspolicies/{policy_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def delete_access_policy(self, policy_id) -> Dict:
            suffix = f'policy/accesspolicies/{policy_id}'
            return self._http_request('DELETE', suffix)

        def get_task_status(self, task_id) -> Dict:
            suffix = f'job/taskstatuses/{task_id}'
            return self._http_request('GET', suffix)

        def create_policy_assignments(self, policy_id, device_ids, device_group_ids) -> Dict:
            targets = [{'id': curr_id, 'type': 'Device'} for curr_id in argToList(device_ids)]
            targets.extend([{'id': curr_id, 'type': 'DeviceGroup'} for curr_id in argToList(device_group_ids)])
            data_to_post = assign_params(policy={'id': policy_id}, type='PolicyAssignment', targets=targets)
            suffix = 'assignment/policyassignments'
            return self._http_request('POST', suffix, json_data=data_to_post)

        def update_policy_assignments(self, policy_id, device_ids, device_group_ids) -> Dict:
            targets = [{'id': curr_id, 'type': 'Device'} for curr_id in argToList(device_ids)]
            targets.extend([{'id': curr_id, 'type': 'DeviceGroup'} for curr_id in argToList(device_group_ids)])
            data_to_post = assign_params(policy={'id': policy_id}, type='PolicyAssignment', targets=targets)
            suffix = f'assignment/policyassignments/{policy_id}'
            return self._http_request('POST', suffix, json_data=data_to_post)

        def get_access_rules(self, limit, offset, policy_id, rule_id) -> Dict:
            end_suffix = f'?expanded=true&limit={limit}&offset={offset}' if rule_id == '' else '/' + rule_id
            suffix = f'policy/accesspolicies/{policy_id}/accessrules{end_suffix}'
            return self._http_request('GET', suffix)

        def create_access_rules(
            self,
            source_zone_object_ids,
            destination_zone_object_ids,
            vlan_tag_object_ids,
            source_network_object_ids,
            source_network_addresses,
            destination_network_object_ids,
            destination_network_addresses,
            source_port_object_ids,
            destination_port_object_ids,
            source_security_group_tag_object_ids,
            application_object_ids,
            url_object_ids,
            url_addresses,
            enabled,
            name,
            policy_id,
            action
        ) -> Dict:
            sourceZones = {'objects': [{'id': curr_id, 'type': 'SecurityZone'
                                                            } for curr_id in argToList(source_zone_object_ids)]}
            destinationZones = {'objects': [{'id': curr_id, 'type': 'SecurityZone'
                                                                 } for curr_id in argToList(destination_zone_object_ids)]}
            vlanTags = {'objects': [{'id': curr_id, 'type': 'vlanTags'} for curr_id in argToList(vlan_tag_object_ids)]}
            sourceNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(source_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(source_network_addresses)])
            destinationNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(destination_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(destination_network_addresses)])
            sourcePorts = {'objects': [{'id': curr_id, 'type': 'ProtocolPortObject'
                                                            } for curr_id in argToList(source_port_object_ids)]}
            destinationPorts = {'objects': [{'id': curr_id, 'type': 'ProtocolPortObject'
                                                                 } for curr_id in argToList(destination_port_object_ids)]}
            sourceSecurityGroupTags = {'objects': [{'id': curr_id, 'type': 'SecurityGroupTag'
                                                    } for curr_id in argToList(source_security_group_tag_object_ids)]}
            applications = {'applications': [{'id': curr_id, 'type': 'Application'
                                                                  } for curr_id in argToList(application_object_ids)]}
            urls = assign_params(
                objects=[{'id': curr_id, 'type': 'Url'} for curr_id in argToList(url_object_ids)],
                literals=[{'url': curr_id, 'type': 'Url'} for curr_id in argToList(url_addresses)])
            data = assign_params(name=name, action=action, enabled=enabled, sourceZones=sourceZones,
                                 destinationZones=destinationZones, vlanTags=vlanTags, sourceNetworks=sourceNetworks,
                                 destinationNetworks=destinationNetworks, sourcePorts=sourcePorts,
                                 destinationPorts=destinationPorts, sourceSecurityGroupTags=sourceSecurityGroupTags,
                                 applications=applications, urls=urls)
            suffix = f'policy/accesspolicies/{policy_id}/accessrules'
            return self._http_request('POST', suffix, json_data=data)

        def update_access_rules(
                self,
                update_strategy,
                source_zone_object_ids,
                destination_zone_object_ids,
                vlan_tag_object_ids,
                source_network_object_ids,
                source_network_addresses,
                destination_network_object_ids,
                destination_network_addresses,
                source_port_object_ids,
                destination_port_object_ids,
                source_security_group_tag_object_ids,
                application_object_ids,
                url_object_ids,
                url_addresses,
                enabled,
                name,
                policy_id,
                action,
                rule_id
            ) -> Dict:

            suffix = f'policy/accesspolicies/{policy_id}/accessrules/{rule_id}'

            sourceZones = assign_params(objects=[{'id': curr_id, 'type': 'SecurityZone'
                                        } for curr_id in argToList(source_zone_object_ids)])
            destinationZones = assign_params(objects=[{'id': curr_id, 'type': 'SecurityZone'
                                             } for curr_id in argToList(destination_zone_object_ids)])
            vlanTags = assign_params(objects=[{'id': curr_id, 'type': 'vlanTags'
                                     } for curr_id in argToList(vlan_tag_object_ids)])
            sourceNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(source_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(source_network_addresses)])
            destinationNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(destination_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(destination_network_addresses)])
            sourcePorts = assign_params(objects=[{'id': curr_id, 'type': 'ProtocolPortObject'
                                                            } for curr_id in argToList(source_port_object_ids)])
            destinationPorts = assign_params(objects=[{'id': curr_id, 'type': 'ProtocolPortObject'
                                                                 } for curr_id in argToList(destination_port_object_ids)])
            sourceSecurityGroupTags = assign_params(objects=[{'id': curr_id, 'type': 'SecurityGroupTag'
                                                    } for curr_id in argToList(source_security_group_tag_object_ids)])
            applications = assign_params(applications=[{'id': curr_id, 'type': 'Application'
                                                                  } for curr_id in argToList(application_object_ids)])
            urls = assign_params(
                objects=[{'id': curr_id, 'type': 'Url'} for curr_id in argToList(url_object_ids)],
                literals=[{'url': curr_id, 'type': 'Url'} for curr_id in argToList(url_addresses)])

            data = assign_params(name=name, action=action, id=rule_id, enabled=enabled, sourceZones=sourceZones,
                                 destinationZones=destinationZones, vlanTags=vlanTags, sourceNetworks=sourceNetworks,
                                 destinationNetworks=destinationNetworks, sourcePorts=sourcePorts,
                                 destinationPorts=destinationPorts, sourceSecurityGroupTags=sourceSecurityGroupTags,
                                 applications=applications, urls=urls)

            data_from_get = self.get_access_rules(0, 0, rule_id=rule_id, policy_id=policy_id)
            if update_strategy == 'override':
                if 'name' not in data:
                    data['name'] = data_from_get.get('name')
                if 'action' not in data:
                    data['action'] = data_from_get.get('action')
                return self._http_request('PUT', suffix, json_data=data)
            else:
                for key, value in data.items():
                    if type(value) == dict:
                        for in_key in value:
                            if in_key in data_from_get[key]:
                                data_from_get[key][in_key].extend(value[in_key])
                            else:
                                data_from_get[key][in_key] = value[in_key]
                    else:
                        data_from_get[key] = value
                del data_from_get['metadata']
                del data_from_get['links']
                return self._http_request('PUT', suffix, json_data=data_from_get)

        def delete_access_rules(self, policy_id, rule_id) -> Dict:
            suffix = f'policy/accesspolicies/{policy_id}/accessrules{rule_id}'
            return self._http_request('DELETE', suffix)

        def deploy_to_devices(self, force_deploy, ignore_warning, version, device_ids) -> Dict:
            data_to_post = assign_params(forceDeploy=force_deploy, ignoreWarning=ignore_warning, version=version,
                                                deviceList=argToList(device_ids))
            suffix = 'deployment/deploymentrequests'
            return self._http_request('POST', suffix, json_data=data_to_post)


    ''' HELPER FUNCTIONS '''


    def switch_list_to_list_counter(data: Union[Dict, List]) -> Union[Dict, List]:
        """Receives a list of dictionaries or a dictionary,
        and if one of the keys contains a list or dictionary with lists,
        returns the size of the lists
            Examples:
            >>> switch_list_to_list_counter({'name': 'n', 'type': 't', 'devices': [1, 2, 3]})
            {'name': 'name', 'type': 'type', 'devices': 3}

            >>> switch_list_to_list_counter({'name': 'n', 'type': 't', 'devices': {'new': [1, 2, 3], 'old': [1, 2, 3]}}
            {'name': 'name', 'type': 'type', 'devices': 6}

            >>> switch_list_to_list_counter({'name': 'n', 'type': 't', 'devices': {'new': 'my new'}
            {'name': 'name', 'type': 'type', 'devices': 1}

        :type data: ``list`` or ``dict``
        :param data:  context entry

        :return: ``list`` or ``dict``
        :rtype: context entry for human readable`
        """
        if isinstance(data, list):
            return [switch_list_to_list_counter(dat) for dat in data]
        new_data = {}
        for item in data:
            if type(data[item]) == list:
                new_data[item] = len(data[item])
            elif data[item] and type(data[item]) == dict:
                counter = 0
                for in_item in data[item]:
                    if type(data[item][in_item]) == list:
                        counter += len(data[item][in_item])
                    elif data[item][in_item]:
                        counter = 1 if counter == 0 else counter
                new_data[item] = counter
            else:
                new_data[item] = data[item]
        return new_data


    def raw_response_to_context_list(list_key, items):
        """Receives a dictionary or list of dictionaries and returns only the keys that exist in the list_key
        and changes the keys by Context Standards

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :type list_key: ``list``
        :keyword list_key: Selected keys to copy on context_entry
        """
        if isinstance(items, list):
            return [raw_response_to_context_list(list_key, item) for item in items]

        list_to_output = {OUTPUT_KEYS_DICTIONARY.get(key, key.capitalize()): items.get(key, '') for key in list_key}
        return list_to_output


    def raw_response_to_context_network_groups(items):
        if isinstance(items, list):
            return [raw_response_to_context_network_groups(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'Overridable': items.get('overridable'),
            'Description': items.get('description'),
            'Objects': [
                {
                    'Name': obj.get('name'),
                    'ID': obj.get('id'),
                    'Type': obj.get('type')
                } for obj in items.get('objects', [])
            ],
            'Addresses': [
                {
                    'value': obj.get('value'),
                    'Type': obj.get('type')
                } for obj in items.get('literals', [])
            ]
        }


    def raw_response_to_context_policy_assignment(items):
        if isinstance(items, list):
            return [raw_response_to_context_policy_assignment(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'PolicyName':  items.get('policy', {}).get('name', ''),
            'PolicyID':  items.get('policy', {}).get('id', ''),
            'PolicyDescription': items.get('policy', {}).get('description', ''),
            'Targets': [
                {
                    'Name': obj.get('name'),
                    'ID': obj.get('id'),
                    'Type': obj.get('type')
                } for obj in items.get('targets', [])
            ]
        }


    def raw_response_to_context_access_policy(items):
        if isinstance(items, list):
            return [raw_response_to_context_access_policy(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'DefaultActionID': items.get('defaultAction', {}).get('id', '')
        }


    def raw_response_to_context_ruls(items):
        if isinstance(items, list):
            return [raw_response_to_context_ruls(item) for item in items]
        return {
            'ID': items.get('id'),
            'Name': items.get('name'),
            'Action': items.get('action'),
            'Enabled': items.get('enabled'),
            'SendEventsToFMC': items.get('sendEventsToFMC'),
            'RuleIndex': items.get('metadata', {}).get('ruleIndex', ''),
            'Section': items.get('metadata', {}).get('section', ''),
            'Category': items.get('metadata', {}).get('category', ''),
            'Urls': {
                'Addresses': [{
                        'URL': obj.get('url', '')
                    }for obj in items.get('urls', {}).get('literals', [])
                ],
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', '')
                    } for obj in items.get('urls', {}).get('objects', [])
                ]
            },
            'VlanTags': {
                'Numbers': [{
                        'EndTag': obj.get('endTag', ''),
                        'StartTag': obj.get('startTag', '')
                    } for obj in items.get('vlanTags', {}).get('literals', [])
                ],
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', '')
                    } for obj in items.get('vlanTags', {}).get('objects', [])
                ]
            },
            'SourceZones': {
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', '')
                    } for obj in items.get('sourceZones', {}).get('objects', [])
                ]
            },
            'Applications': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', '')
                } for obj in items.get('applications', {}).get('applications', [])
            ],
            'DestinationZones': {
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', '')
                    } for obj in items.get('destinationZones', {}).get('objects', [])
                ]
            },
            'SourceNetworks': {
                'Addresses': [{
                        'Type': obj.get('type', ''),
                        'Value': obj.get('value', '')
                    }for obj in items.get('sourceNetworks', {}).get('literals', [])
                ],
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', '')
                    } for obj in items.get('sourceNetworks', {}).get('objects', [])
                ]
            },
            'DestinationNetworks': {
                'Addresses': [{
                        'Type': obj.get('type', ''),
                        'Value': obj.get('value', '')
                    } for obj in items.get('destinationNetworks', {}).get('literals', [])
                ],
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', '')
                    } for obj in items.get('destinationNetworks', {}).get('objects', [])
                ]
            },
            'SourcePorts': {
                'Addresses': [{
                        'Port': obj.get('port', ''),
                        'Protocol': obj.get('protocol', '')
                    } for obj in items.get('sourcePorts', {}).get('literals', [])
                ],
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', ''),
                        'Protocol': obj.get('protocol', '')
                    } for obj in items.get('sourcePorts', {}).get('objects', [])
                ]
            },
            'DestinationPorts': {
                'Addresses': [{
                        'Port': obj.get('port', ''),
                        'Protocol': obj.get('protocol', '')
                    } for obj in items.get('destinationPorts', {}).get('literals', [])
                ],
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', ''),
                        'Protocol': obj.get('protocol', '')
                    } for obj in items.get('destinationPorts', {}).get('objects', [])
                ]
            },
            'SourceSecurityGroupTags': {
                'Objects': [{
                        'Name': obj.get('name', ''),
                        'ID': obj.get('id', ''),
                        'Type': obj.get('type', '')
                    } for obj in items.get('sourceSecurityGroupTags', {}).get('objects', [])
                ]
            }
        }


    ''' COMMANDS '''


    @logger
    def list_zones_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'securityzones')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List zones:'
            context_entry = [{
                    'ID': item.get('id', ''),
                    'Name': item.get('name', ''),
                    'InterfaceMode': item.get('interfaceMode', ''),
                    'Interfaces': [{
                            'Name': obj.get('name', ''),
                            'ID': obj.get('id' '')
                        }for obj in item.get('interfaces', {})
                    ]
                }for item in items
            ]
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Zone(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'InterfaceMode', 'Interfaces']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any zone.', {}, {}


    def list_ports_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'ports')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List ports:'
            list_to_output = ['id', 'name', 'protocol', 'port']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Port(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Protocol', 'Port']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any port.', {}, {}


    def list_url_categories_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'urlcategories')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List url categories:'
            list_to_output = ['id', 'name']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Category(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any category.', {}, {}


    def get_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        object_id = args.get('object_id', '')

        raw_response = client.get_network_objects(limit, offset, object_id)
        items = raw_response.get('items')
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List network objects:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - get network object {object_id}'
                items = raw_response
            list_to_output = ['id', 'name', 'value', 'overridable', 'description']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any network object.', {}, {}


    def get_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        object_id = args.get('object_id', '')

        raw_response = client.get_hosts_objects(limit, offset, object_id)
        items = raw_response.get('items')
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List host objects:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - get host object {object_id}'
                items = raw_response
            list_to_output = ['id', 'name', 'value', 'overridable', 'description']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any host object.', {}, {}


    def create_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name = args.get('name')
        value = args.get('value')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        raw_response = client.create_network_objects(name, value, description, overridable)
        title = f'{INTEGRATION_NAME} - network object has been created.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def create_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name = args.get('name')
        value = args.get('value')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        raw_response = client.create_host_objects(name, value, description, overridable)
        title = f'{INTEGRATION_NAME} - host object has been created.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def update_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id')
        name = args.get('name')
        value = args.get('value')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        raw_response = client.update_network_objects(name, value, description, overridable, object_id)
        title = f'{INTEGRATION_NAME} - network object has been updated.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']

        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def update_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id')
        name = args.get('name')
        value = args.get('value')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        raw_response = client.update_host_objects(name, value, description, overridable, object_id)
        title = f'{INTEGRATION_NAME} - host object has been updated.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']

        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def delete_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id')
        raw_response = client.delete_network_objects(object_id)
        title = f'{INTEGRATION_NAME} - network object has been deleted.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def delete_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id')
        raw_response = client.delete_host_objects(object_id)
        title = f'{INTEGRATION_NAME} - host object has been deleted.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def get_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id', '')
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        raw_response = client.get_network_groups_objects(limit, offset, object_id)
        items = raw_response.get('items')
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List of network groups object:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - network group object:'
                items = raw_response
            context_entry = raw_response_to_context_network_groups(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not delete the object.')


    def create_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        if 'id_list' or 'value_list' in args:
            name = args.get('name')
            ids = args.get('network_objects_id_list', '')
            values = args.get('network_address_list', '')
            description = args.get('description', '')
            overridable = args.get('overridable', '')
            raw_response = client.create_network_groups_objects(name, ids, values, description, overridable)
            title = f'{INTEGRATION_NAME} - network group has been created.'
            context_entry = raw_response_to_context_network_groups(raw_response)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
            }

            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not create new group, Missing value or ID.')


    def update_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        if 'id_list' or 'value_list' in args:
            group_id = args.get('id')
            name = args.get('name')
            ids = args.get('network_objects_id_list', '')
            values = args.get('network_address_list', '')
            description = args.get('description', '')
            overridable = args.get('overridable', '')
            raw_response = client.update_network_groups_objects(name, ids, values, group_id, description, overridable)
            title = f'{INTEGRATION_NAME} - network group has been updated.'
            context_entry = raw_response_to_context_network_groups(raw_response)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
            }

            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not update the group, Missing value or ID.')


    def delete_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args['id']
        raw_response = client.delete_network_groups_objects(object_id)
        title = f'{INTEGRATION_NAME} - network group - {object_id} - has been delete.'
        context_entry = raw_response_to_context_network_groups(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def get_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        policy_id = args.get('id', '')
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        raw_response = client.get_access_policy(limit, offset, policy_id)
        items = raw_response.get('items')
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List access policy:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - get access policy'
                items = raw_response
            context_entry = raw_response_to_context_access_policy(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'DefaultActionID']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any access policy.', {}, {}


    def create_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name = args.get('name')
        action = args.get('action')
        raw_response = client.create_access_policy(name, action)
        title = f'{INTEGRATION_NAME} - access policy has been created.'
        context_entry = raw_response_to_context_access_policy(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'DefaultActionID']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def update_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name = args.get('name')
        policy_id = args.get('id')
        action = args.get('action')
        action_id = args.get('default_action_id')

        raw_response = client.update_access_policy(name, policy_id, action, action_id)
        title = f'{INTEGRATION_NAME} - access policy has been updated.'
        context_entry = raw_response_to_context_access_policy(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'DefaultActionID']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def delete_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        policy_id = args.get('id')
        raw_response = client.delete_access_policy(policy_id)
        title = f'{INTEGRATION_NAME} - access policy deleted.'
        context_entry = raw_response_to_context_access_policy(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'DefaultActionID']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def list_security_group_tags_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'securitygrouptags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List security group tags:'
            list_to_output = ['id', 'name', 'tag']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.SecurityGroupTags(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Tag']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any security group tags.', {}, {}


    def list_ise_security_group_tags_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'isesecuritygrouptags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List ise security group tags:'
            list_to_output = ['id', 'name', 'tag']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.IseSecurityGroupTags(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Tag']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any ise security group tags.', {}, {}


    def list_vlan_tags_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'vlantags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List vlan tags:'
            context_entry = [
                {
                    'Name': item.get('name'),
                    'ID': item.get('id'),
                    'Overridable': item.get('overridable'),
                    'Description': item.get('description'),
                    'StartTag': item.get('data', {}).get('startTag'),
                    'EndTag': item.get('data', {}).get('endTag')
                } for item in items
            ]
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.VlanTags(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'StartTag', 'EndTag']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any vlan tags.', {}, {}


    def list_vlan_tags_group_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'vlangrouptags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List of vlan tags groups objects:'
            context_entry = [
                {
                    'Name': item.get('name'),
                    'ID': item.get('id'),
                    'Overridable': item.get('overridable'),
                    'Description': item.get('description'),
                    'Objects': [
                        {
                            'Name': obj.get('name'),
                            'ID': obj.get('id'),
                            'Overridable': obj.get('overridable'),
                            'Description': obj.get('description'),
                            'StartTag': obj.get('data', {}).get('startTag'),
                            'EndTag': obj.get('data', {}).get('endTag')
                        } for obj in item.get('object', [])
                    ]
                } for item in items
            ]
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.VlanTagsGroup(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Objects']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any vlan tags group.', {}, {}


    def list_applications_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'applications')
        items = raw_response.get('items')
        if items:
            context_entry = [
                {
                    'Name': item.get('name'),
                    'ID': item.get('id'),
                    'Risk': item.get('risk', {}).get('name', ''),
                    'AppProductivity': item.get('appProductivity', {}).get('name', ''),
                    'ApplicationTypes': [
                        {
                            'Name': obj.get('name')
                        } for obj in item.get('applicationTypes', [])
                    ],
                    'AppCategories': [
                        {
                            'Name': obj.get('name'),
                            'ID': obj.get('id'),
                            'Count': obj.get('metadata', {}).get('count', '')
                        } for obj in item.get('appCategories', [])
                    ]
                } for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of applications objects:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Applications(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'Risk', 'AppProductivity', 'ApplicationTypes', 'AppCategories']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any applications.', {}, {}


    def get_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        policy_id = args.get('policy_id')
        rule_id = args.get('rule_id', '')
        raw_response = client.get_access_rules(limit, offset, policy_id, rule_id)
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List of access rules:'
        elif 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - access rule:'
            items = raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any access rule.', {}, {}
        context_entry = raw_response_to_context_ruls(items)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def create_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        source_zone_object_ids = args.get('source_zone_object_ids', '')
        destination_zone_object_ids = args.get('destination_zone_object_ids', '')
        vlan_tag_object_ids = args.get('vlan_tag_object_ids', '')
        source_network_object_ids = args.get('source_network_object_ids', '')
        source_network_addresses = args.get('source_network_addresses', '')
        destination_network_object_ids = args.get('destination_network_object_ids', '')
        destination_network_addresses = args.get('destination_network_addresses', '')
        source_port_object_ids = args.get('source_port_object_ids', '')
        destination_port_object_ids = args.get('destination_port_object_ids', '')
        source_security_group_tag_object_ids = args.get('source_security_group_tag_object_ids', '')
        application_object_ids = args.get('application_object_ids', '')
        url_object_ids = args.get('url_object_ids', '')
        url_addresses = args.get('url_addresses', '')
        enabled = args.get('enabled', '')
        name = args.get('rule_name', '')
        policy_id = args.get('policy_id', '')
        action = args.get('action', '')

        raw_response = client.create_access_rules(source_zone_object_ids,
                                                    destination_zone_object_ids,
                                                    vlan_tag_object_ids,
                                                    source_network_object_ids,
                                                    source_network_addresses,
                                                    destination_network_object_ids,
                                                    destination_network_addresses,
                                                    source_port_object_ids,
                                                    destination_port_object_ids,
                                                    source_security_group_tag_object_ids,
                                                    application_object_ids,
                                                    url_object_ids,
                                                    url_addresses,
                                                    enabled,
                                                    name,
                                                    policy_id,
                                                    action)
        title = f'{INTEGRATION_NAME} - the new access rule:'
        context_entry = raw_response_to_context_ruls(raw_response)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def update_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        update_strategy = args.get('update_strategy')
        source_zone_object_ids = args.get('source_zone_object_ids', '')
        destination_zone_object_ids = args.get('destination_zone_object_ids', '')
        vlan_tag_object_ids = args.get('vlan_tag_object_ids', '')
        source_network_object_ids = args.get('source_network_object_ids', '')
        source_network_addresses = args.get('source_network_addresses', '')
        destination_network_object_ids = args.get('destination_network_object_ids', '')
        destination_network_addresses = args.get('destination_network_addresses', '')
        source_port_object_ids = args.get('source_port_object_ids', '')
        destination_port_object_ids = args.get('destination_port_object_ids', '')
        source_security_group_tag_object_ids = args.get('source_security_group_tag_object_ids', '')
        application_object_ids = args.get('application_object_ids', '')
        url_object_ids = args.get('url_object_ids', '')
        url_addresses = args.get('url_addresses', '')
        enabled = args.get('enabled', '')
        name = args.get('rule_name', '')
        policy_id = args.get('policy_id', '')
        action = args.get('action', '')
        rule_id = args.get('rule_id')

        raw_response = client.update_access_rules(update_strategy,
                                                  source_zone_object_ids,
                                                  destination_zone_object_ids,
                                                  vlan_tag_object_ids,
                                                  source_network_object_ids,
                                                  source_network_addresses,
                                                  destination_network_object_ids,
                                                  destination_network_addresses,
                                                  source_port_object_ids,
                                                  destination_port_object_ids,
                                                  source_security_group_tag_object_ids,
                                                  application_object_ids,
                                                  url_object_ids,
                                                  url_addresses,
                                                  enabled,
                                                  name,
                                                  policy_id,
                                                  action,
                                                  rule_id)
        title = f'{INTEGRATION_NAME} - access rule:'
        context_entry = raw_response_to_context_ruls(raw_response)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def delete_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        policy_id = args.get('policy_id')
        rule_id = args.get('rule_id')
        raw_response = client.delete_access_rules(policy_id, rule_id)
        title = f'{INTEGRATION_NAME} - deleted access rule:'
        context_entry = raw_response_to_context_ruls(raw_response)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def list_policy_assignments_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.list_policy_assignments(limit, offset)
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List of policy assignments:'
            context_entry = raw_response_to_context_policy_assignment(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.PolicyAssignments(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'PolicyName', 'PolicyID', 'PolicyDescription', 'Targets']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any policy assignments.', {}, {}


    def create_policy_assignments_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        device_ids = args.get('device_ids')
        device_group_ids = args.get('device_group_ids')
        policy_id = args.get('policy_id')
        raw_response = client.create_policy_assignments(policy_id, device_ids, device_group_ids)
        title = f'{INTEGRATION_NAME} - Policy assignments has been done.'
        context_entry = raw_response_to_context_policy_assignment(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.PolicyAssignments(val.ID && val.ID === obj.ID)': context_entry
        }
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        presented_output = ['ID', 'Name', 'PolicyName', 'PolicyID', 'PolicyDescription', 'Targets']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def update_policy_assignments_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        device_ids = args.get('device_ids')
        device_group_ids = args.get('device_group_ids')
        policy_id = args.get('policy_id')
        raw_response = client.update_policy_assignments(policy_id, device_ids, device_group_ids)
        title = f'{INTEGRATION_NAME} - policy update has been done.'
        context_entry = raw_response_to_context_policy_assignment(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.PolicyAssignments(val.ID && val.ID === obj.ID)': context_entry
        }
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        presented_output = ['ID', 'Name', 'PolicyName', 'PolicyID', 'PolicyDescription', 'Targets']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def get_deployable_devices_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_deployable_devices(limit, offset)
        items = raw_response.get('items')
        if items:
            context_entry = [{
                    'CanBeDeployed': item.get('canBeDeployed', ''),
                    'UpToDate': item.get('upToDate', ''),
                    'DeviceID': item.get('device', {}).get('id', ''),
                    'DeviceName': item.get('device', {}).get('name', ''),
                    'DeviceType': item.get('device', {}).get('type', ''),
                    'Version': item.get('version', '')
                }for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of deployable devices:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.DeployableDevices(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any deployable devices.', {}, {}


    def get_device_records_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_device_records(limit, offset)
        items = raw_response.get('items')
        if items:
            context_entry = [{
                    'ID': item.get('id', ''),
                    'Name': item.get('name', ''),
                    'HostName': item.get('hostName', ''),
                    'Type': item.get('type', ''),
                    'DeviceGroupID': item.get('deviceGroup', {}).get('id', '')
                } for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of device records:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.DeviceRecords(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'HostName', 'Type', 'DeviceGroupID']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any device records.', {}, {}


    def deploy_to_devices_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        force_deploy = args.get('force_deploy', '')
        ignore_warning = args.get('ignore_warning', '')
        version = args.get('version', '')
        device_list = args.get('device_ids', '')

        raw_response = client.deploy_to_devices(force_deploy, ignore_warning, version, device_list)
        title = f'{INTEGRATION_NAME} - devices requests to deploy.'
        context_entry = {
            'TaskID': raw_response.get('metadata', {}).get('task', {}).get('id', ''),
            'ForceDeploy': raw_response.get('forceDeploy'),
            'IgnoreWarning': raw_response.get('ignoreWarning'),
            'Version': raw_response.get('version'),
            'DeviceList': raw_response.get('deviceList')
        }
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Deploy(val.ID && val.ID === obj.ID)': context_entry
        }
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        human_readable = tableToMarkdown(title, entry_white_list_count)
        return human_readable, context, raw_response


    def get_task_status_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        task_id = args.get('task_id')
        raw_response = client.get_task_status(task_id)
        if 'status' in raw_response:
            context_entry = {
                'Status': raw_response.get('status')
            }
            title = f'{INTEGRATION_NAME} - {task_id} status:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.TaskStatus(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any status.', {}, {}


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def main():  # pragma: no cover
        params = demisto.params()
        base_url = params.get('url')
        username = params.get('credentials').get('identifier')
        password = params.get('credentials').get('password')

        verify_ssl = not params.get('insecure', False)
        proxy = params.get('proxy')
        client = Client(base_url=base_url, verify=verify_ssl, proxy=proxy, auth=(username, password))

        client.login()

        LOG('command is %s' % (demisto.command(),))
        try:
            if demisto.command() == 'test-module':
                return_outputs('ok')
                # Login is performed at the beginning of each flow if the login fails we return an error.
            elif demisto.command() == 'ciscofp-list-zones':
                return_outputs(*list_zones_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-ports':
                return_outputs(*list_ports_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-url-categories':
                return_outputs(*list_url_categories_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-network-object':
                return_outputs(*get_network_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-network-object':
                return_outputs(*create_network_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-network-object':
                return_outputs(*update_network_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-network-object':
                return_outputs(*delete_network_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-host-object':
                return_outputs(*get_host_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-host-object':
                return_outputs(*create_host_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-host-object':
                return_outputs(*update_host_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-host-object':
                return_outputs(*delete_host_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-network-groups-object':
                return_outputs(*get_network_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-network-groups-objects':
                return_outputs(*create_network_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-network-groups-objects':
                return_outputs(*update_network_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-network-groups-objects':
                return_outputs(*delete_network_groups_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-access-policy':
                return_outputs(*get_access_policy_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-access-policy':
                return_outputs(*create_access_policy_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-access-policy':
                return_outputs(*update_access_policy_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-access-policy':
                return_outputs(*delete_access_policy_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-list-security-group-tags':
                return_outputs(*list_security_group_tags_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-ise-security-group-tags':
                return_outputs(*list_ise_security_group_tags_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-vlan-tags':
                return_outputs(*list_vlan_tags_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-vlan-tags-group':
                return_outputs(*list_vlan_tags_group_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-applications':
                return_outputs(*list_applications_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-access-rules':
                return_outputs(*get_access_rules_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-access-rules':
                return_outputs(*create_access_rules_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-access-rules':
                return_outputs(*update_access_rules_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-access-rules':
                return_outputs(*delete_access_rules_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-list-policy-assignments':
                return_outputs(*list_policy_assignments_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-policy-assignments':
                return_outputs(*create_policy_assignments_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-policy-assignments':
                return_outputs(*update_policy_assignments_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-deployable-devices':
                return_outputs(*get_deployable_devices_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-get-device-records':
                return_outputs(*get_device_records_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-deploy-to-devices':
                return_outputs(*deploy_to_devices_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-get-task-status':
                return_outputs(*get_task_status_command(client, demisto.args()))

        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} Integration [{e}]'
            return_error(err_msg, error=e)


    if __name__ == 'builtins':  # pragma: no cover
        main()
  subtype: python3
  type: python
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEkAAAAyCAYAAAAQlvbeAAAGx0lEQVR42u1Za2xURRTeOzPbYikPeWgRWx7y8JXwQ/3HDw2JxldMBDXGBIhiFF+AihDFhJDwA8KjElhLd/c+lkIRQhtRjPKIKIokCshD9s7c3S0FSgVFnilQlPW77ez2lr3VLs0uNt6TnGxzz8ycc78558w3tz5PPPHEE0888cQTTzz5T4lini5jYb6IBPaPy4c/svz4WKYfWqys/mNYtwGJ1tRNZypPUt38nFRxJdf+WDCxnmlmkhqHZ3cbkFgoGmEaT0KPMNUsyKkvwyRMN0WrP3N99wFJM8MSpDhTo7kFSecEfn6R/tZ4IHU3kJSTF4uZJl6hmrgvG5AUPT6QRaJTybLfR2bVnCPx4SitqUr5uZJsQKJqbAyLiFd9FaJP/pvzuvgc9Bs7sDqqix6dBQnAaraNquL7rPxFxJbWwyBe3VmQaFXMz3TBW2xBMT//JRU2y2VgJxB8n86DxDdK28Gs/Kn8R9mcv+o0SCrviWdHbZtf4ytzWPOiyL3v8MUysEa8QO8sQKqVtn3u68aKO/C3S877otMgabwIz+olSAF3+mAWdY2kaYeegoMGqlobSDDuzzVIROfT7MwkRnRmzkHad4rSDXVrWMg8Tqri47uSRZp0ftFviJJcg0Q1sd22Uc36IdcgsUqzH1rGOTlP78JRzivlImcKInkASRWbZVPfnnOQNN4P+pucF+wC3Td1uUhTgSEGXWNbJm2nsCPZgLRJNuBoZibx1kwK8Z0uIO2xbSiPrVk0bhukxhaQVB5yAemsbUPFXH8m0W3HJiNLLlJd7FAisUKnjXzZ+BzAuUxXWZuU2nraWZBomM9kutlMVyYqM/yFjsxj4egVUlu/IMMWjn4Ef1fop/UfdhYkpcok1OA1eN5MDGtyO9ta4YdtK2yX6MfRKV3jQ4Y1mEbMm9zvaKKUVNcVuJDJVC9L4KUz7dW8jCw9QdyzN1rmSl6D+xVaaWbYALgN0iHpb23GYbDGAhhWqTtB5YXYtNt9+RbZgCta05gnsFsst5fpuMJUgUwy0csso/t8Tyo/PZyFogHyTeOj+fBHIsfHoa8ElKW7R/k88cST/7XQtYlCNOk7QBVGM8O6uf2lNKrYXAXaE3a/+5dFPhDz74IOw0lT9M+XXDGAaeJOrDWE6ryg43Exmx+NxPgRYO89bhg4RKvrhWa5iBnCZrR/Qq9CT0Ofd1CBUnkLP+nX+evtj/QDJZi/ATZ5NcB8jFUCP5W5nJYPws82x9hmALXbt1IUt4uppqE/C/EVsDdA/5JxHcXYxcRI9M7v6bWsaQBTrT0AwQ74Wp3hAGmYDDQJkGal56+wCA2LzY45l6EXoEkltHd0uxff1jCJhfnVDD8gub6KeN/0mocvDGZVsShT3WICPdCtvT7twoD8lZgki5LSJ1hEvI/fl1AKS/FsggOkoTajlSDNbCsxMVTudJIaYiPIXn/7mgBONUZZuCOdHUq4bjiuP02Ol11HVfNlAPQmSrgSmZQGiYVFbRogne/F70yMm50mmlDMieSnzEL8Njhskrt5hKjWIPeRHYMEBl8GptySYQDsAPrGw3RVLIPV09XxeekX1OILOy59MSoFOjZrD10dK3LY+lKNR+U6l4gaL805SHD0UDrwsFjig2QFkhQarF/NdEdp6LyRRsSsa75+bkyVI0Ac2pEfZNf4tmwTUzLt/N10zFXWI7kHaV18XNqhYS24XpCUJacLmWHOha3e0WeSxDj8hmNDPktlAPpShxlAdfOZdEy6mOTydWF62l6dyP0tgFYfHtLSaFUbpFiMVB/rkz1IzheI+QH2E/JkRPnxXY4MWJgCj0ZiczqMqfLg3ehHV5GNSYD5HQ1y0lZuvDD1mQXaTLTYsPw07gCvcZweaJJiMvQx/D0Lp8jj/wYSCe4rpmHzAezwLZhXzHTrXvSSRll236bHreT3sJB5JU0RjNhyNPonMW8C+th8X6h1g8iGOoWtsbY4Trav4fsFgD8R6+1s62uiJn8UYMeZUpxocTh2pwDtQWqWIL2Xeu7XrFFy7AXoqfRcvCSJ1L/Yrilv+nUGelPShQI0+SqsNgpQe34EaMkxaXfTuBL4uTS/TLs6VoLgNTg/4wjkCnSyA6Qh0n4RIM1oA0nY/On8NS/RQMOJd9x7jvU01tqbOsGkWuBJvdoBqteVoT99kuJcUs9CI0S3Snw3QgDSrfZ/cZnewnIrqc4/AIca4biW9EZfmQZ9G/b7HeD1sjMOWg4NQZeghJ4l4Xp/x9wsOhbj5kKDyKJyGrEm+gIxlkEHDA6gxFsYVwENUFW8hrgG+TzxxBNPPPHEE0888eRGyN8R98jGg6pa+wAAAABJRU5ErkJggg==
