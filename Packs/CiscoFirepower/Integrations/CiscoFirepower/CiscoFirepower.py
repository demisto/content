commonfields:
  id: Cisco Firepower_morita
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: Cisco Firepower_morita
display: Cisco Firepower_morita
category: Network Security
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEkAAAAyCAYAAAAQlvbeAAAGx0lEQVR42u1Za2xURRTeOzPbYikPeWgRWx7y8JXwQ/3HDw2JxldMBDXGBIhiFF+AihDFhJDwA8KjElhLd/c+lkIRQhtRjPKIKIokCshD9s7c3S0FSgVFnilQlPW77ez2lr3VLs0uNt6TnGxzz8ycc78558w3tz5PPPHEE0888cQTTzz5T4lini5jYb6IBPaPy4c/svz4WKYfWqys/mNYtwGJ1tRNZypPUt38nFRxJdf+WDCxnmlmkhqHZ3cbkFgoGmEaT0KPMNUsyKkvwyRMN0WrP3N99wFJM8MSpDhTo7kFSecEfn6R/tZ4IHU3kJSTF4uZJl6hmrgvG5AUPT6QRaJTybLfR2bVnCPx4SitqUr5uZJsQKJqbAyLiFd9FaJP/pvzuvgc9Bs7sDqqix6dBQnAaraNquL7rPxFxJbWwyBe3VmQaFXMz3TBW2xBMT//JRU2y2VgJxB8n86DxDdK28Gs/Kn8R9mcv+o0SCrviWdHbZtf4ytzWPOiyL3v8MUysEa8QO8sQKqVtn3u68aKO/C3S877otMgabwIz+olSAF3+mAWdY2kaYeegoMGqlobSDDuzzVIROfT7MwkRnRmzkHad4rSDXVrWMg8Tqri47uSRZp0ftFviJJcg0Q1sd22Uc36IdcgsUqzH1rGOTlP78JRzivlImcKInkASRWbZVPfnnOQNN4P+pucF+wC3Td1uUhTgSEGXWNbJm2nsCPZgLRJNuBoZibx1kwK8Z0uIO2xbSiPrVk0bhukxhaQVB5yAemsbUPFXH8m0W3HJiNLLlJd7FAisUKnjXzZ+BzAuUxXWZuU2nraWZBomM9kutlMVyYqM/yFjsxj4egVUlu/IMMWjn4Ef1fop/UfdhYkpcok1OA1eN5MDGtyO9ta4YdtK2yX6MfRKV3jQ4Y1mEbMm9zvaKKUVNcVuJDJVC9L4KUz7dW8jCw9QdyzN1rmSl6D+xVaaWbYALgN0iHpb23GYbDGAhhWqTtB5YXYtNt9+RbZgCta05gnsFsst5fpuMJUgUwy0csso/t8Tyo/PZyFogHyTeOj+fBHIsfHoa8ElKW7R/k88cST/7XQtYlCNOk7QBVGM8O6uf2lNKrYXAXaE3a/+5dFPhDz74IOw0lT9M+XXDGAaeJOrDWE6ryg43Exmx+NxPgRYO89bhg4RKvrhWa5iBnCZrR/Qq9CT0Ofd1CBUnkLP+nX+evtj/QDJZi/ATZ5NcB8jFUCP5W5nJYPws82x9hmALXbt1IUt4uppqE/C/EVsDdA/5JxHcXYxcRI9M7v6bWsaQBTrT0AwQ74Wp3hAGmYDDQJkGal56+wCA2LzY45l6EXoEkltHd0uxff1jCJhfnVDD8gub6KeN/0mocvDGZVsShT3WICPdCtvT7twoD8lZgki5LSJ1hEvI/fl1AKS/FsggOkoTajlSDNbCsxMVTudJIaYiPIXn/7mgBONUZZuCOdHUq4bjiuP02Ol11HVfNlAPQmSrgSmZQGiYVFbRogne/F70yMm50mmlDMieSnzEL8Njhskrt5hKjWIPeRHYMEBl8GptySYQDsAPrGw3RVLIPV09XxeekX1OILOy59MSoFOjZrD10dK3LY+lKNR+U6l4gaL805SHD0UDrwsFjig2QFkhQarF/NdEdp6LyRRsSsa75+bkyVI0Ac2pEfZNf4tmwTUzLt/N10zFXWI7kHaV18XNqhYS24XpCUJacLmWHOha3e0WeSxDj8hmNDPktlAPpShxlAdfOZdEy6mOTydWF62l6dyP0tgFYfHtLSaFUbpFiMVB/rkz1IzheI+QH2E/JkRPnxXY4MWJgCj0ZiczqMqfLg3ehHV5GNSYD5HQ1y0lZuvDD1mQXaTLTYsPw07gCvcZweaJJiMvQx/D0Lp8jj/wYSCe4rpmHzAezwLZhXzHTrXvSSRll236bHreT3sJB5JU0RjNhyNPonMW8C+th8X6h1g8iGOoWtsbY4Trav4fsFgD8R6+1s62uiJn8UYMeZUpxocTh2pwDtQWqWIL2Xeu7XrFFy7AXoqfRcvCSJ1L/Yrilv+nUGelPShQI0+SqsNgpQe34EaMkxaXfTuBL4uTS/TLs6VoLgNTg/4wjkCnSyA6Qh0n4RIM1oA0nY/On8NS/RQMOJd9x7jvU01tqbOsGkWuBJvdoBqteVoT99kuJcUs9CI0S3Snw3QgDSrfZ/cZnewnIrqc4/AIca4biW9EZfmQZ9G/b7HeD1sjMOWg4NQZeghJ4l4Xp/x9wsOhbj5kKDyKJyGrEm+gIxlkEHDA6gxFsYVwENUFW8hrgG+TzxxBNPPPHEE0888eRGyN8R98jGg6pa+wAAAABJRU5ErkJggg==
description: Use the Cisco Firepower integration for unified management of firewalls,
  application control, intrusion prevention, URL filtering, and advanced malware protection.
detaileddescription: |-
  Supports FMC 6.2.3 and above

  Authentication from a REST API Client
  Cisco recommends that you use different accounts for interfacing with the API and the Firepower User Interface. Credentials cannot be used for both interfaces simultaneously, and will be logged out without warning if used for both.

  The first time you connect to the REST API you may receive an error that the connection is not secure due to an invalid certificate. Add an exception in your browser to use the certificate and accept the connection.

  With Token Based Authentication you obtain a token by providing your username and password. You use this token to access an HTTP service for a limited time period without the need for the username and password with every request. In other words, to eliminate the need for authenticating with your username and password with each request.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/cisco-firepower)
configuration:
- display: Server URL (e.g., https://192.168.0.1)
  name: url
  type: 0
  required: true
- display: Username
  name: credentials
  type: 9
  required: true
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
script:
  script: |2


    ''' IMPORTS '''
    from typing import Dict, Tuple, List, Union
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    '''GLOBALS/PARAMS'''

    INTEGRATION_NAME = 'Cisco Firepower'

    INTEGRATION_CONTEXT_NAME = 'CiscoFP'

    OUTPUT_KEYS_DICTIONARY = {
        'id': 'ID'
    }


    class Client(BaseClient):
        def login(self):
            """update the X-auth-access-token in the client.
            """
            new_headers = self._http_request(
                'POST',
                url_suffix='/api/fmc_platform/v1/auth/generatetoken',
                resp_type='response'
            ).headers
            self._headers = {'X-auth-access-token': new_headers.get('X-auth-access-token')}
            self._base_url += f'/api/fmc_config/v1/domain/{new_headers.get("DOMAIN_UUID")}/'
            if self._headers['X-auth-access-token'] == '':
                return_error('No valid access token')

        def get_list(self, limit: int, offset: int, object_path: str) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = f'object/{object_path}'
            return self._http_request('GET', suffix, params=params)

        def list_policy_assignments(self, limit: int, offset: int) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = 'assignment/policyassignments'
            return self._http_request('GET', suffix, params=params)

        def get_deployable_devices(self, limit: int, offset: int, container_uuid: str) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            end_suffix = '/' + container_uuid + '/deployments' if container_uuid else ''
            suffix = f'deployment/deployabledevices{end_suffix}'
            return self._http_request('GET', suffix, params=params)

        def get_device_records(self, limit: int, offset: int) -> Dict:
            params = {'expanded': 'true', 'limit': limit, 'offset': offset}
            suffix = 'devices/devicerecords'
            return self._http_request('GET', suffix, params=params)

        def get_network_objects(self, limit: int, offset: int, object_id: str) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/networks{end_suffix}'
            return self._http_request('GET', suffix)

        def get_hosts_objects(self, limit: int, offset: int, object_id: str) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/hosts{end_suffix}'
            return self._http_request('GET', suffix)

        def create_network_objects(self, name: str, value: str, description: str, overridable: bool) -> Dict:
            data = {'name': name, 'value': value, 'description': description, 'overridable': overridable}
            suffix = 'object/networks'
            return self._http_request('POST', suffix, json_data=data)

        def create_host_objects(self, name: str, value: str, description: str, overridable: bool) -> Dict:
            data = {'name': name, 'value': value, 'description': description, 'overridable': overridable}
            suffix = 'object/hosts'
            return self._http_request('POST', suffix, json_data=data)

        def update_network_objects(
                self, name: str, value: str, description: str, overridable: bool, object_id: str) -> Dict:
            data = assign_params(id=object_id, name=name, value=value, description=description, overridable=overridable)
            suffix = f'object/networks/{object_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def update_host_objects(self, name: str, value: str, description: str, overridable: bool, object_id: str) -> Dict:
            data = assign_params(id=object_id, name=name, value=value, description=description, overridable=overridable)
            suffix = f'object/hosts/{object_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def delete_network_objects(self, object_id: str) -> Dict:
            suffix = f'object/networks/{object_id}'
            return self._http_request('DELETE', suffix)

        def delete_host_objects(self, object_id: str) -> Dict:
            suffix = f'object/hosts/{object_id}'
            return self._http_request('DELETE', suffix)

        def get_network_groups_objects(self, limit: int, offset: int, object_id: str) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/networkgroups{end_suffix}'
            return self._http_request('GET', suffix)

        def get_url_groups_objects(self, limit: int, offset: int, object_id: str) -> Dict:
            end_suffix = f'/{object_id}' if object_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'object/urlgroups{end_suffix}'
            return self._http_request('GET', suffix)

        def create_network_groups_objects(
                self, name: str, ids: str, values: str, description: str, overridable: bool) -> Dict:
            objects = [{'id': curr_id} for curr_id in argToList(ids)]
            values = [{'value': curr_value} for curr_value in argToList(values)]
            data = assign_params(
                name=name, objects=objects, literals=values, description=description, overridable=overridable)
            suffix = 'object/networkgroups'
            return self._http_request('POST', suffix, json_data=data)

        def update_network_groups_objects(
                self, name: str, ids: str, values: str, group_id: str, description: str, overridable: bool) -> Dict:
            objects = [{'id': curr_id} for curr_id in argToList(ids)]
            values = [{'value': curr_value} for curr_value in argToList(values)]
            data = assign_params(name=name, id=group_id, objects=objects, literals=values,
                                 description=description, overridable=overridable)
            suffix = f'object/networkgroups/{group_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def update_url_groups_objects(
                self, name: str, ids: str, values: str, group_id: str, description: str, overridable: bool) -> Dict:
            objects = [{'id': curr_id} for curr_id in argToList(ids)]
            values = [{'url': curr_value} for curr_value in argToList(values)]
            data = assign_params(name=name, id=group_id, objects=objects, literals=values,
                                 description=description, overridable=overridable)
            suffix = f'object/urlgroups/{group_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def delete_network_groups_objects(self, object_id: str) -> Dict:
            suffix = f'object/networkgroups/{object_id}'
            return self._http_request('DELETE', suffix)

        def get_access_policy(self, limit: int, offset: int, policy_id: str) -> Dict:
            end_suffix = f'/{policy_id}' if policy_id else f'?expanded=true&limit={limit}&offset={offset}'
            suffix = f'policy/accesspolicies{end_suffix}'
            return self._http_request('GET', suffix)

        def create_access_policy(self, name: str, action: str) -> Dict:
            data = {'name': name, 'defaultAction': {'action': action}}
            suffix = 'policy/accesspolicies'
            return self._http_request('POST', suffix, json_data=data)

        def update_access_policy(self, name: str, policy_id: str, action: str, action_id: str) -> Dict:
            data = {
                'name': name,
                'id': policy_id,
                'defaultAction': {
                    'action': action,
                    'id': action_id
                }}
            suffix = f'policy/accesspolicies/{policy_id}'
            return self._http_request('PUT', suffix, json_data=data)

        def delete_access_policy(self, policy_id: str) -> Dict:
            suffix = f'policy/accesspolicies/{policy_id}'
            return self._http_request('DELETE', suffix)

        def get_task_status(self, task_id: str) -> Dict:
            suffix = f'job/taskstatuses/{task_id}'
            return self._http_request('GET', suffix)

        def create_policy_assignments(self, policy_id: str, device_ids: str, device_group_ids: str) -> Dict:
            targets = [{'id': curr_id, 'type': 'Device'} for curr_id in argToList(device_ids)]
            targets.extend([{'id': curr_id, 'type': 'DeviceGroup'} for curr_id in argToList(device_group_ids)])
            data_to_post = assign_params(policy={'id': policy_id}, type='PolicyAssignment', targets=targets)
            suffix = 'assignment/policyassignments'
            return self._http_request('POST', suffix, json_data=data_to_post)

        def update_policy_assignments(self, policy_id: str, device_ids: str, device_group_ids: str) -> Dict:
            targets = [{'id': curr_id, 'type': 'Device'} for curr_id in argToList(device_ids)]
            targets.extend([{'id': curr_id, 'type': 'DeviceGroup'} for curr_id in argToList(device_group_ids)])
            data_to_post = assign_params(policy={'id': policy_id}, type='PolicyAssignment', targets=targets)
            suffix = f'assignment/policyassignments/{policy_id}'
            return self._http_request('POST', suffix, json_data=data_to_post)

        def get_access_rules(self, limit: int, offset: int, policy_id: str, rule_id: str) -> Dict:
            end_suffix = f'?expanded=true&limit={limit}&offset={offset}' if rule_id == '' else '/' + rule_id
            suffix = f'policy/accesspolicies/{policy_id}/accessrules{end_suffix}'
            return self._http_request('GET', suffix)

        def create_access_rules(
                self,
                source_zone_object_ids: str,
                destination_zone_object_ids: str,
                vlan_tag_object_ids: str,
                source_network_object_ids: str,
                source_network_addresses: str,
                destination_network_object_ids: str,
                destination_network_addresses: str,
                source_port_object_ids: str,
                destination_port_object_ids: str,
                source_security_group_tag_object_ids: str,
                application_object_ids: str,
                url_object_ids: str,
                url_addresses: str,
                enabled: bool,
                name: str,
                policy_id: str,
                action: str
        ) -> Dict:
            sourceZones = {'objects': [{'id': curr_id, 'type': 'SecurityZone'
                                        } for curr_id in argToList(source_zone_object_ids)]}
            destinationZones = {'objects': [{'id': curr_id, 'type': 'SecurityZone'
                                             } for curr_id in argToList(destination_zone_object_ids)]}
            vlanTags = {'objects': [{'id': curr_id, 'type': 'vlanTags'} for curr_id in argToList(vlan_tag_object_ids)]}
            sourceNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(source_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(source_network_addresses)])
            destinationNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(destination_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(destination_network_addresses)])
            sourcePorts = {'objects': [{'id': curr_id, 'type': 'ProtocolPortObject'
                                        } for curr_id in argToList(source_port_object_ids)]}
            destinationPorts = {'objects': [{'id': curr_id, 'type': 'ProtocolPortObject'
                                             } for curr_id in argToList(destination_port_object_ids)]}
            sourceSecurityGroupTags = {'objects': [{'id': curr_id, 'type': 'SecurityGroupTag'
                                                    } for curr_id in argToList(source_security_group_tag_object_ids)]}
            applications = {'applications': [{'id': curr_id, 'type': 'Application'
                                              } for curr_id in argToList(application_object_ids)]}
            urls = assign_params(
                objects=[{'id': curr_id, 'type': 'Url'} for curr_id in argToList(url_object_ids)],
                literals=[{'url': curr_id, 'type': 'Url'} for curr_id in argToList(url_addresses)])
            data = assign_params(name=name, action=action, enabled=enabled, sourceZones=sourceZones,
                                 destinationZones=destinationZones, vlanTags=vlanTags, sourceNetworks=sourceNetworks,
                                 destinationNetworks=destinationNetworks, sourcePorts=sourcePorts,
                                 destinationPorts=destinationPorts, sourceSecurityGroupTags=sourceSecurityGroupTags,
                                 applications=applications, urls=urls)
            suffix = f'policy/accesspolicies/{policy_id}/accessrules'
            return self._http_request('POST', suffix, json_data=data)

        def update_access_rules(
                self,
                update_strategy: str,
                source_zone_object_ids: str,
                destination_zone_object_ids: str,
                vlan_tag_object_ids: str,
                source_network_object_ids: str,
                source_network_addresses: str,
                destination_network_object_ids: str,
                destination_network_addresses: str,
                source_port_object_ids: str,
                destination_port_object_ids: str,
                source_security_group_tag_object_ids: str,
                application_object_ids: str,
                url_object_ids: str,
                url_addresses: str,
                enabled: bool,
                name: str,
                policy_id: str,
                action: str,
                rule_id: str
        ) -> Dict:

            suffix = f'policy/accesspolicies/{policy_id}/accessrules/{rule_id}'

            sourceZones = assign_params(
                objects=[{'id': curr_id, 'type': 'SecurityZone'} for curr_id in argToList(source_zone_object_ids)])
            destinationZones = assign_params(
                objects=[{'id': curr_id, 'type': 'SecurityZone'} for curr_id in argToList(destination_zone_object_ids)])
            vlanTags = assign_params(
                objects=[{'id': curr_id, 'type': 'vlanTags'} for curr_id in argToList(vlan_tag_object_ids)])
            sourceNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(source_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(source_network_addresses)])
            destinationNetworks = assign_params(
                objects=[{'id': curr_id, 'type': 'NetworkGroup'} for curr_id in argToList(destination_network_object_ids)],
                literals=[{'value': curr_id, 'type': 'Host'} for curr_id in argToList(destination_network_addresses)])
            sourcePorts = assign_params(
                objects=[{'id': curr_id, 'type': 'ProtocolPortObject'} for curr_id in argToList(source_port_object_ids)])
            destinationPorts = assign_params(
                objects=[{'id': curr_id, 'type': 'ProtocolPortObject'} for curr_id in
                         argToList(destination_port_object_ids)])
            sourceSecurityGroupTags = assign_params(objects=[{'id': curr_id, 'type': 'SecurityGroupTag'} for curr_id in
                                                             argToList(source_security_group_tag_object_ids)])
            applications = assign_params(
                applications=[{'id': curr_id, 'type': 'Application'} for curr_id in argToList(application_object_ids)])
            urls = assign_params(
                objects=[{'id': curr_id, 'type': 'Url'} for curr_id in argToList(url_object_ids)],
                literals=[{'url': curr_id, 'type': 'Url'} for curr_id in argToList(url_addresses)])
            data = assign_params(name=name, action=action, id=rule_id, enabled=enabled, sourceZones=sourceZones,
                                 destinationZones=destinationZones, vlanTags=vlanTags, sourceNetworks=sourceNetworks,
                                 destinationNetworks=destinationNetworks, sourcePorts=sourcePorts,
                                 destinationPorts=destinationPorts, sourceSecurityGroupTags=sourceSecurityGroupTags,
                                 applications=applications, urls=urls)

            data_from_get = self.get_access_rules(0, 0, rule_id=rule_id, policy_id=policy_id)
            if update_strategy == 'override':
                if 'name' not in data:
                    data['name'] = data_from_get.get('name')
                if 'action' not in data:
                    data['action'] = data_from_get.get('action')
                return self._http_request('PUT', suffix, json_data=data)
            else:
                for key, value in data.items():
                    if type(value) == dict:
                        for in_key in value:
                            if in_key in data_from_get[key]:
                                data_from_get[key][in_key].extend(value[in_key])
                            else:
                                data_from_get[key][in_key] = value[in_key]
                    else:
                        data_from_get[key] = value
                del data_from_get['metadata']
                del data_from_get['links']
                return self._http_request('PUT', suffix, json_data=data_from_get)

        def delete_access_rules(self, policy_id, rule_id) -> Dict:
            suffix = f'policy/accesspolicies/{policy_id}/accessrules/{rule_id}'
            return self._http_request('DELETE', suffix)

        def deploy_to_devices(self, force_deploy, ignore_warning, version, device_ids) -> Dict:
            data_to_post = assign_params(forceDeploy=force_deploy, ignoreWarning=ignore_warning, version=version,
                                         deviceList=argToList(device_ids), type="DeploymentRequest")
            suffix = 'deployment/deploymentrequests'
            return self._http_request('POST', suffix, json_data=data_to_post)


    ''' HELPER FUNCTIONS '''


    def switch_list_to_list_counter(data: Union[Dict, List]) -> Union[Dict, List]:
        """Receives a list of dictionaries or a dictionary,
        and if one of the keys contains a list or dictionary with lists,
        returns the size of the lists
            Examples:
            >>> switch_list_to_list_counter({'name': 'n', 'type': 't', 'devices': [1, 2, 3]})
            {'name': 'name', 'type': 'type', 'devices': 3}

            >>> switch_list_to_list_counter({'name': 'n', 'type': 't', 'devices': {'new': [1, 2, 3], 'old': [1, 2, 3]}}
            {'name': 'name', 'type': 'type', 'devices': 6}

            >>> switch_list_to_list_counter({'name': 'n', 'type': 't', 'devices': {'new': 'my new'}
            {'name': 'name', 'type': 'type', 'devices': 1}

        :type data: ``list`` or ``dict``
        :param data:  context entry

        :return: ``list`` or ``dict``
        :rtype: context entry for human readable`
        """
        if isinstance(data, list):
            return [switch_list_to_list_counter(dat) for dat in data]
        new_data = {}
        for item in data:
            if type(data[item]) == list:
                new_data[item] = len(data[item])
            elif data[item] and type(data[item]) == dict:
                counter = 0
                for in_item in data[item]:
                    if type(data[item][in_item]) == list:
                        counter += len(data[item][in_item])
                    elif data[item][in_item]:
                        counter = 1 if counter == 0 else counter
                new_data[item] = counter
            else:
                new_data[item] = data[item]
        return new_data


    def raw_response_to_context_list(list_key: List, items: Union[Dict, List]) -> Union[Dict, List]:
        """Receives a dictionary or list of dictionaries and returns only the keys that exist in the list_key
        and changes the keys by Context Standards

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :type list_key: ``list``
        :keyword list_key: Selected keys to copy on context_entry
        """
        if isinstance(items, list):
            return [raw_response_to_context_list(list_key, item) for item in items]

        list_to_output = {OUTPUT_KEYS_DICTIONARY.get(key, key.capitalize()): items.get(key, '') for key in list_key}
        return list_to_output


    def raw_response_to_context_network_groups(items: Union[Dict, List]) -> Union[Dict, List]:
        """Receives raw response and returns Context entry to network groups command

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :return: ``list`` or ``dict``
        :rtype: context entry`
        """
        if isinstance(items, list):
            return [raw_response_to_context_network_groups(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'Overridable': items.get('overridable'),
            'Description': items.get('description'),
            'Objects': [
                {
                    'Name': obj.get('name'),
                    'ID': obj.get('id'),
                    'Type': obj.get('type')
                } for obj in items.get('objects', [])
            ],
            'Addresses': [
                {
                    'Value': obj.get('value'),
                    'Type': obj.get('type')
                } for obj in items.get('literals', [])
            ]
        }

    def raw_response_to_context_url_groups(items: Union[Dict, List]) -> Union[Dict, List]:
        """Receives raw response and returns Context entry to url groups command

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :return: ``list`` or ``dict``
        :rtype: context entry`
        """
        if isinstance(items, list):
            return [raw_response_to_context_url_groups(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'Overridable': items.get('overridable'),
            'Description': items.get('description'),
            'Objects': [
                {
                    'Name': obj.get('name'),
                    'ID': obj.get('id'),
                    'Type': obj.get('type')
                } for obj in items.get('objects', [])
            ],
            'Addresses': [
                {
                    'Url': obj.get('url'),
                    'Type': obj.get('type')
                } for obj in items.get('literals', [])
            ]
        }

    def raw_response_to_context_policy_assignment(items: Union[Dict, List]) -> Union[Dict, List]:
        """Receives raw response and returns Context entry to policy assignment command

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :return: ``list`` or ``dict``
        :rtype: context entry`
        """
        if isinstance(items, list):
            return [raw_response_to_context_policy_assignment(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'PolicyName': items.get('policy', {}).get('name', ''),
            'PolicyID': items.get('policy', {}).get('id', ''),
            'PolicyDescription': items.get('policy', {}).get('description', ''),
            'Targets': [
                {
                    'Name': obj.get('name'),
                    'ID': obj.get('id'),
                    'Type': obj.get('type')
                } for obj in items.get('targets', [])
            ]
        }


    def raw_response_to_context_access_policy(items: Union[Dict, List]) -> Union[Dict, List]:
        """Receives raw response and returns Context entry to access policy command

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :return: ``list`` or ``dict``
        :rtype: context entry`
        """
        if isinstance(items, list):
            return [raw_response_to_context_access_policy(item) for item in items]
        return {
            'Name': items.get('name'),
            'ID': items.get('id'),
            'DefaultActionID': items.get('defaultAction', {}).get('id', '')
        }


    def raw_response_to_context_rules(items: Union[Dict, List]) -> Union[Dict, List]:
        """Receives raw response and returns Context entry to rules command

        :type items: ``list`` or ``dict``
        :param items:  list of dict or dict of data from http request

        :return: ``list`` or ``dict``
        :rtype: context entry`
        """
        if isinstance(items, list):
            return [raw_response_to_context_rules(item) for item in items]
        return {
            'ID': items.get('id'),
            'Name': items.get('name'),
            'Action': items.get('action'),
            'Enabled': items.get('enabled'),
            'SendEventsToFMC': items.get('sendEventsToFMC'),
            'RuleIndex': items.get('metadata', {}).get('ruleIndex', ''),
            'Section': items.get('metadata', {}).get('section', ''),
            'Category': items.get('metadata', {}).get('category', ''),
            'Urls': {
                'Addresses': [{
                    'URL': obj.get('url', '')
                } for obj in items.get('urls', {}).get('literals', [])
                ],
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', '')
                } for obj in items.get('urls', {}).get('objects', [])
                ]
            },
            'VlanTags': {
                'Numbers': [{
                    'EndTag': obj.get('endTag', ''),
                    'StartTag': obj.get('startTag', '')
                } for obj in items.get('vlanTags', {}).get('literals', [])
                ],
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', '')
                } for obj in items.get('vlanTags', {}).get('objects', [])
                ]
            },
            'SourceZones': {
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', '')
                } for obj in items.get('sourceZones', {}).get('objects', [])
                ]
            },
            'Applications': [{
                'Name': obj.get('name', ''),
                'ID': obj.get('id', '')
            } for obj in items.get('applications', {}).get('applications', [])
            ],
            'DestinationZones': {
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', '')
                } for obj in items.get('destinationZones', {}).get('objects', [])
                ]
            },
            'SourceNetworks': {
                'Addresses': [{
                    'Type': obj.get('type', ''),
                    'Value': obj.get('value', '')
                } for obj in items.get('sourceNetworks', {}).get('literals', [])
                ],
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', '')
                } for obj in items.get('sourceNetworks', {}).get('objects', [])
                ]
            },
            'DestinationNetworks': {
                'Addresses': [{
                    'Type': obj.get('type', ''),
                    'Value': obj.get('value', '')
                } for obj in items.get('destinationNetworks', {}).get('literals', [])
                ],
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', '')
                } for obj in items.get('destinationNetworks', {}).get('objects', [])
                ]
            },
            'SourcePorts': {
                'Addresses': [{
                    'Port': obj.get('port', ''),
                    'Protocol': obj.get('protocol', '')
                } for obj in items.get('sourcePorts', {}).get('literals', [])
                ],
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', ''),
                    'Protocol': obj.get('protocol', '')
                } for obj in items.get('sourcePorts', {}).get('objects', [])
                ]
            },
            'DestinationPorts': {
                'Addresses': [{
                    'Port': obj.get('port', ''),
                    'Protocol': obj.get('protocol', '')
                } for obj in items.get('destinationPorts', {}).get('literals', [])
                ],
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', ''),
                    'Protocol': obj.get('protocol', '')
                } for obj in items.get('destinationPorts', {}).get('objects', [])
                ]
            },
            'SourceSecurityGroupTags': {
                'Objects': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id', ''),
                    'Type': obj.get('type', '')
                } for obj in items.get('sourceSecurityGroupTags', {}).get('objects', [])
                ]
            }
        }


    ''' COMMANDS '''


    def list_zones_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'securityzones')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List zones:'
            context_entry = [{
                'ID': item.get('id', ''),
                'Name': item.get('name', ''),
                'InterfaceMode': item.get('interfaceMode', ''),
                'Interfaces': [{
                    'Name': obj.get('name', ''),
                    'ID': obj.get('id' '')
                } for obj in item.get('interfaces', {})
                ]
            } for item in items
            ]
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Zone(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'InterfaceMode', 'Interfaces']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any zone.', {}, {}


    def list_ports_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'ports')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List ports:'
            list_to_output = ['id', 'name', 'protocol', 'port']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Port(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Protocol', 'Port']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any port.', {}, {}


    def list_url_categories_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'urlcategories')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List url categories:'
            list_to_output = ['id', 'name']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Category(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any category.', {}, {}


    def get_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        object_id = args.get('object_id', '')

        raw_response = client.get_network_objects(limit, offset, object_id)
        items: Union[List, Dict] = raw_response.get('items')    # type:ignore
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List network objects:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - get network object {object_id}'
                items = raw_response
            list_to_output = ['id', 'name', 'value', 'overridable', 'description']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any network object.', {}, {}


    def get_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        object_id = args.get('object_id', '')

        raw_response = client.get_hosts_objects(limit, offset, object_id)
        items: Union[List, Dict] = raw_response.get('items')    # type:ignore
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List host objects:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - get host object {object_id}'
                items = raw_response
            list_to_output = ['id', 'name', 'value', 'overridable', 'description']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any host object.', {}, {}


    def create_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name: str = args.get('name')    # type:ignore
        value: str = args.get('value')    # type:ignore
        description: str = args.get('description', '')    # type:ignore
        overridable = args.get('overridable', '')
        raw_response = client.create_network_objects(name, value, description, overridable)
        title = f'{INTEGRATION_NAME} - network object has been created.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def create_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name: str = args.get('name')    # type:ignore
        value: str = args.get('value')    # type:ignore
        description: str = args.get('description', '')    # type:ignore
        overridable = args.get('overridable', '')
        raw_response = client.create_host_objects(name, value, description, overridable)
        title = f'{INTEGRATION_NAME} - host object has been created.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def update_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id: str = args.get('id')    # type:ignore
        name: str = args.get('name')    # type:ignore
        value: str = args.get('value')    # type:ignore
        description: str = args.get('description', '')    # type:ignore
        overridable = args.get('overridable', '')
        raw_response = client.update_network_objects(name, value, description, overridable, object_id)
        title = f'{INTEGRATION_NAME} - network object has been updated.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']

        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def update_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id: str = args.get('id')    # type:ignore
        name: str = args.get('name')    # type:ignore
        value: str = args.get('value')    # type:ignore
        description: str = args.get('description', '')    # type:ignore
        overridable = args.get('overridable', '')
        raw_response = client.update_host_objects(name, value, description, overridable, object_id)
        title = f'{INTEGRATION_NAME} - host object has been updated.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']

        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def delete_network_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id: str = args.get('id')    # type:ignore
        raw_response = client.delete_network_objects(object_id)
        title = f'{INTEGRATION_NAME} - network object has been deleted.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Network(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def delete_host_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id: str = args.get('id')    # type:ignore
        raw_response = client.delete_host_objects(object_id)
        title = f'{INTEGRATION_NAME} - host object has been deleted.'
        list_to_output = ['id', 'name', 'value', 'overridable', 'description']
        context_entry = raw_response_to_context_list(list_to_output, raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Host(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Value', 'Overridable', 'Description']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def get_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id', '')
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        raw_response = client.get_network_groups_objects(limit, offset, object_id)
        items: Union[List, Dict] = raw_response.get('items')    # type:ignore
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List of network groups object:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - network group object:'
                items = raw_response
            context_entry = raw_response_to_context_network_groups(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not delete the object.')

    def get_url_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args.get('id', '')
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        raw_response = client.get_url_groups_objects(limit, offset, object_id)
        items: Union[List, Dict] = raw_response.get('items')    # type:ignore
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List of url groups object:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - url group object:'
                items = raw_response
            context_entry = raw_response_to_context_url_groups(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.URLGroups(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not delete the object.')


    def create_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name: str = args.get('name')    # type:ignore
        ids = args.get('network_objects_id_list', '')
        values = args.get('network_address_list', '')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        if ids or values:
            raw_response = client.create_network_groups_objects(name, ids, values, description, overridable)
            title = f'{INTEGRATION_NAME} - network group has been created.'
            context_entry = raw_response_to_context_network_groups(raw_response)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
            }

            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not create new group, Missing value or ID.')


    def update_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        group_id: str = args.get('id')   # type:ignore
        name: str = args.get('name')    # type:ignore
        ids = args.get('network_objects_id_list', '')
        values = args.get('network_address_list', '')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        if ids or values:
            raw_response = client.update_network_groups_objects(name, ids, values, group_id, description, overridable)
            title = f'{INTEGRATION_NAME} - network group has been updated.'
            context_entry = raw_response_to_context_network_groups(raw_response)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
            }

            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not update the group, Missing value or ID.')

    def update_url_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        group_id: str = args.get('id')   # type:ignore
        name: str = args.get('name')    # type:ignore
        ids = args.get('url_objects_id_list', '')
        values = args.get('url_list', '')
        description = args.get('description', '')
        overridable = args.get('overridable', '')
        if ids or values:
            raw_response = client.update_url_groups_objects(name, ids, values, group_id, description, overridable)
            title = f'{INTEGRATION_NAME} - url group has been updated.'
            context_entry = raw_response_to_context_url_groups(raw_response)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.UrlGroups(val.ID && val.ID === obj.ID)': context_entry
            }

            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            raise DemistoException(f'{INTEGRATION_NAME} - Could not update the group, Missing value or ID.')

    def delete_network_groups_objects_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        object_id = args['id']
        raw_response = client.delete_network_groups_objects(object_id)
        title = f'{INTEGRATION_NAME} - network group - {object_id} - has been delete.'
        context_entry = raw_response_to_context_network_groups(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.NetworkGroups(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Addresses', 'Objects']
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def get_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        policy_id = args.get('id', '')
        limit = args.get('limit', '50')
        offset = args.get('offset', '0')
        raw_response = client.get_access_policy(limit, offset, policy_id)
        items: Union[List, Dict] = raw_response.get('items')    # type:ignore
        if items or 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - List access policy:'
            if 'id' in raw_response:
                title = f'{INTEGRATION_NAME} - get access policy'
                items = raw_response
            context_entry = raw_response_to_context_access_policy(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'DefaultActionID']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any access policy.', {}, {}


    def create_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name: str = args.get('name')    # type:ignore
        action: str = args.get('action')    # type:ignore
        raw_response = client.create_access_policy(name, action)
        title = f'{INTEGRATION_NAME} - access policy has been created.'
        context_entry = raw_response_to_context_access_policy(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'DefaultActionID']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def update_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        name: str = args.get('name')    # type:ignore
        policy_id: str = args.get('id')    # type:ignore
        action: str = args.get('action')    # type:ignore
        action_id: str = args.get('default_action_id')    # type:ignore

        raw_response = client.update_access_policy(name, policy_id, action, action_id)
        title = f'{INTEGRATION_NAME} - access policy has been updated.'
        context_entry = raw_response_to_context_access_policy(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'DefaultActionID']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def delete_access_policy_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        policy_id: str = args.get('id')    # type:ignore
        raw_response = client.delete_access_policy(policy_id)
        title = f'{INTEGRATION_NAME} - access policy deleted.'
        context_entry = raw_response_to_context_access_policy(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Policy(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'DefaultActionID']
        human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
        return human_readable, context, raw_response


    def list_security_group_tags_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'securitygrouptags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List security group tags:'
            list_to_output = ['id', 'name', 'tag']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.SecurityGroupTags(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Tag']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any security group tags.', {}, {}


    def list_ise_security_group_tags_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'isesecuritygrouptags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List ise security group tags:'
            list_to_output = ['id', 'name', 'tag']
            context_entry = raw_response_to_context_list(list_to_output, items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.IseSecurityGroupTags(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Tag']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any ise security group tags.', {}, {}


    def list_vlan_tags_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'vlantags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List vlan tags:'
            context_entry = [
                {
                    'Name': item.get('name'),
                    'ID': item.get('id'),
                    'Overridable': item.get('overridable'),
                    'Description': item.get('description'),
                    'StartTag': item.get('data', {}).get('startTag'),
                    'EndTag': item.get('data', {}).get('endTag')
                } for item in items
            ]
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.VlanTags(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'StartTag', 'EndTag']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any vlan tags.', {}, {}


    def list_vlan_tags_group_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'vlangrouptags')
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List of vlan tags groups objects:'
            context_entry = [
                {
                    'Name': item.get('name'),
                    'ID': item.get('id'),
                    'Overridable': item.get('overridable'),
                    'Description': item.get('description'),
                    'Objects': [
                        {
                            'Name': obj.get('name'),
                            'ID': obj.get('id'),
                            'Overridable': obj.get('overridable'),
                            'Description': obj.get('description'),
                            'StartTag': obj.get('data', {}).get('startTag'),
                            'EndTag': obj.get('data', {}).get('endTag')
                        } for obj in item.get('object', [])
                    ]
                } for item in items
            ]
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.VlanTagsGroup(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'Overridable', 'Description', 'Objects']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any vlan tags group.', {}, {}


    def list_applications_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_list(limit, offset, 'applications')
        items = raw_response.get('items')
        if items:
            context_entry = [
                {
                    'Name': item.get('name'),
                    'ID': item.get('id'),
                    'Risk': item.get('risk', {}).get('name', ''),
                    'AppProductivity': item.get('appProductivity', {}).get('name', ''),
                    'ApplicationTypes': [
                        {
                            'Name': obj.get('name')
                        } for obj in item.get('applicationTypes', [])
                    ],
                    'AppCategories': [
                        {
                            'Name': obj.get('name'),
                            'ID': obj.get('id'),
                            'Count': obj.get('metadata', {}).get('count', '')
                        } for obj in item.get('appCategories', [])
                    ]
                } for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of applications objects:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Applications(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'Risk', 'AppProductivity', 'ApplicationTypes', 'AppCategories']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any applications.', {}, {}


    def get_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        policy_id: str = args.get('policy_id')    # type:ignore
        rule_id = args.get('rule_id', '')
        raw_response = client.get_access_rules(limit, offset, policy_id, rule_id)
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List of access rules:'
        elif 'id' in raw_response:
            title = f'{INTEGRATION_NAME} - access rule:'
            items = raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any access rule.', {}, {}
        context_entry = raw_response_to_context_rules(items)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def create_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        source_zone_object_ids = args.get('source_zone_object_ids', '')
        destination_zone_object_ids = args.get('destination_zone_object_ids', '')
        vlan_tag_object_ids = args.get('vlan_tag_object_ids', '')
        source_network_object_ids = args.get('source_network_object_ids', '')
        source_network_addresses = args.get('source_network_addresses', '')
        destination_network_object_ids = args.get('destination_network_object_ids', '')
        destination_network_addresses = args.get('destination_network_addresses', '')
        source_port_object_ids = args.get('source_port_object_ids', '')
        destination_port_object_ids = args.get('destination_port_object_ids', '')
        source_security_group_tag_object_ids = args.get('source_security_group_tag_object_ids', '')
        application_object_ids = args.get('application_object_ids', '')
        url_object_ids = args.get('url_object_ids', '')
        url_addresses = args.get('url_addresses', '')
        enabled = args.get('enabled', '')
        name = args.get('rule_name', '')
        policy_id = args.get('policy_id', '')
        action = args.get('action', '')

        raw_response = client.create_access_rules(source_zone_object_ids,
                                                  destination_zone_object_ids,
                                                  vlan_tag_object_ids,
                                                  source_network_object_ids,
                                                  source_network_addresses,
                                                  destination_network_object_ids,
                                                  destination_network_addresses,
                                                  source_port_object_ids,
                                                  destination_port_object_ids,
                                                  source_security_group_tag_object_ids,
                                                  application_object_ids,
                                                  url_object_ids,
                                                  url_addresses,
                                                  enabled,
                                                  name,
                                                  policy_id,
                                                  action)
        title = f'{INTEGRATION_NAME} - the new access rule:'
        context_entry = raw_response_to_context_rules(raw_response)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def update_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        update_strategy: str = args.get('update_strategy')     # type:ignore
        source_zone_object_ids = args.get('source_zone_object_ids', '')
        destination_zone_object_ids = args.get('destination_zone_object_ids', '')
        vlan_tag_object_ids = args.get('vlan_tag_object_ids', '')
        source_network_object_ids = args.get('source_network_object_ids', '')
        source_network_addresses = args.get('source_network_addresses', '')
        destination_network_object_ids = args.get('destination_network_object_ids', '')
        destination_network_addresses = args.get('destination_network_addresses', '')
        source_port_object_ids = args.get('source_port_object_ids', '')
        destination_port_object_ids = args.get('destination_port_object_ids', '')
        source_security_group_tag_object_ids = args.get('source_security_group_tag_object_ids', '')
        application_object_ids = args.get('application_object_ids', '')
        url_object_ids = args.get('url_object_ids', '')
        url_addresses = args.get('url_addresses', '')
        enabled = args.get('enabled', '')
        name = args.get('rule_name', '')
        policy_id = args.get('policy_id', '')
        action = args.get('action', '')
        rule_id: str = args.get('rule_id')    # type:ignore

        raw_response = client.update_access_rules(update_strategy,
                                                  source_zone_object_ids,
                                                  destination_zone_object_ids,
                                                  vlan_tag_object_ids,
                                                  source_network_object_ids,
                                                  source_network_addresses,
                                                  destination_network_object_ids,
                                                  destination_network_addresses,
                                                  source_port_object_ids,
                                                  destination_port_object_ids,
                                                  source_security_group_tag_object_ids,
                                                  application_object_ids,
                                                  url_object_ids,
                                                  url_addresses,
                                                  enabled,
                                                  name,
                                                  policy_id,
                                                  action,
                                                  rule_id)
        title = f'{INTEGRATION_NAME} - access rule:'
        context_entry = raw_response_to_context_rules(raw_response)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def delete_access_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        policy_id = args.get('policy_id')
        rule_id = args.get('rule_id')
        raw_response = client.delete_access_rules(policy_id, rule_id)
        title = f'{INTEGRATION_NAME} - deleted access rule:'
        context_entry = raw_response_to_context_rules(raw_response)
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
        }
        presented_output = ['ID', 'Name', 'Action', 'Enabled', 'SendEventsToFMC', 'RuleIndex', 'Section', 'Category',
                            'Urls', 'VlanTags', 'SourceZones', 'Applications', 'DestinationZones', 'SourceNetworks',
                            'DestinationNetworks', 'SourcePorts', 'DestinationPorts', 'SourceSecurityGroupTags']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def list_policy_assignments_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.list_policy_assignments(limit, offset)
        items = raw_response.get('items')
        if items:
            title = f'{INTEGRATION_NAME} - List of policy assignments:'
            context_entry = raw_response_to_context_policy_assignment(items)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.PolicyAssignments(val.ID && val.ID === obj.ID)': context_entry
            }
            entry_white_list_count = switch_list_to_list_counter(context_entry)
            presented_output = ['ID', 'Name', 'PolicyName', 'PolicyID', 'PolicyDescription', 'Targets']
            human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any policy assignments.', {}, {}


    def create_policy_assignments_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        device_ids: str = args.get('device_ids')    # type:ignore
        device_group_ids: str = args.get('device_group_ids')    # type:ignore
        policy_id: str = args.get('policy_id')    # type:ignore
        raw_response = client.create_policy_assignments(policy_id, device_ids, device_group_ids)
        title = f'{INTEGRATION_NAME} - Policy assignments has been done.'
        context_entry = raw_response_to_context_policy_assignment(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.PolicyAssignments(val.ID && val.ID === obj.ID)': context_entry
        }
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        presented_output = ['ID', 'Name', 'PolicyName', 'PolicyID', 'PolicyDescription', 'Targets']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def update_policy_assignments_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        device_ids: str = args.get('device_ids')    # type:ignore
        device_group_ids: str = args.get('device_group_ids')    # type:ignore
        policy_id: str = args.get('policy_id')    # type:ignore
        raw_response = client.update_policy_assignments(policy_id, device_ids, device_group_ids)
        title = f'{INTEGRATION_NAME} - policy update has been done.'
        context_entry = raw_response_to_context_policy_assignment(raw_response)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.PolicyAssignments(val.ID && val.ID === obj.ID)': context_entry
        }
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        presented_output = ['ID', 'Name', 'PolicyName', 'PolicyID', 'PolicyDescription', 'Targets']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response

    
    def get_deployable_devices_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        container_uuid = args.get('container_uuid','')
        raw_response = client.get_deployable_devices(limit, offset,container_uuid)
        items = raw_response.get('items')
        if container_uuid:
            if items:
                context_entry = [{
                'EndTime': item.get('endTime', ''),
                'ID': item.get('id', ''),
                'Name': item.get('name', ''),
                'StartTime': item.get('startTime', ''),
                'Status': item.get('status', ''),
                'Type': item.get('type', '')
            } for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of devices status pending deployment:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.PendingDeployment(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['EndTime', 'ID', 'Name', 'StartTime', 'Status', 'Type']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        if items:
            context_entry = [{
                'CanBeDeployed': item.get('canBeDeployed', ''),
                'UpToDate': item.get('upToDate', ''),
                'DeviceID': item.get('device', {}).get('id', ''),
                'DeviceName': item.get('device', {}).get('name', ''),
                'DeviceType': item.get('device', {}).get('type', ''),
                'Version': item.get('version', '')
            } for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of deployable devices:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.DeployableDevices(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['CanBeDeployed', 'UpToDate', 'DeviceID', 'DeviceName', 'DeviceType', 'Version']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any deployable devices.', {}, {}


    def get_device_records_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        limit = args.get('limit', 50)
        offset = args.get('offset', 0)
        raw_response = client.get_device_records(limit, offset)
        items = raw_response.get('items')
        if items:
            context_entry = [{
                'ID': item.get('id', ''),
                'Name': item.get('name', ''),
                'HostName': item.get('hostName', ''),
                'Type': item.get('type', ''),
                'DeviceGroupID': item.get('deviceGroup', {}).get('id', '')
            } for item in items
            ]
            title = f'{INTEGRATION_NAME} - List of device records:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.DeviceRecords(val.ID && val.ID === obj.ID)': context_entry
            }
            presented_output = ['ID', 'Name', 'HostName', 'Type', 'DeviceGroupID']
            human_readable = tableToMarkdown(title, context_entry, headers=presented_output)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any device records.', {}, {}


    def deploy_to_devices_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        force_deploy = args.get('force_deploy', '')
        ignore_warning = args.get('ignore_warning', '')
        version = args.get('version', '')
        device_list = args.get('device_ids', '')

        raw_response = client.deploy_to_devices(force_deploy, ignore_warning, version, device_list)
        title = f'{INTEGRATION_NAME} - devices requests to deploy.'
        context_entry = {
            'TaskID': raw_response.get('metadata', {}).get('task', {}).get('id', ''),
            'ForceDeploy': raw_response.get('forceDeploy'),
            'IgnoreWarning': raw_response.get('ignoreWarning'),
            'Version': raw_response.get('version'),
            'DeviceList': raw_response.get('deviceList')
        }
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.Deploy(val.ID && val.ID === obj.ID)': context_entry
        }
        entry_white_list_count = switch_list_to_list_counter(context_entry)
        presented_output = ['TaskID', 'ForceDeploy', 'IgnoreWarning', 'Version', 'DeviceList']
        human_readable = tableToMarkdown(title, entry_white_list_count, headers=presented_output)
        return human_readable, context, raw_response


    def get_task_status_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        task_id: str = args.get('task_id')    # type:ignore
        raw_response = client.get_task_status(task_id)
        if 'status' in raw_response:
            context_entry = {
                'Status': raw_response.get('status')
            }
            title = f'{INTEGRATION_NAME} - {task_id} status:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.TaskStatus(val.ID && val.ID === obj.ID)': context_entry
            }
            human_readable = tableToMarkdown(title, context_entry, headers=['Status'])
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any status.', {}, {}


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def main():  # pragma: no cover
        params = demisto.params()
        base_url = params.get('url')
        username = params.get('credentials').get('identifier')
        password = params.get('credentials').get('password')

        verify_ssl = not params.get('insecure', False)
        proxy = params.get('proxy')
        client = Client(base_url=base_url, verify=verify_ssl, proxy=proxy, auth=(username, password))
        command = demisto.command()
        client.login()

        LOG(f'Command being called is {command}')

        try:
            if demisto.command() == 'test-module':
                return_outputs('ok')
                # Login is performed at the beginning of each flow if the login fails we return an error.
            elif demisto.command() == 'ciscofp-list-zones':
                return_outputs(*list_zones_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-ports':
                return_outputs(*list_ports_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-url-categories':
                return_outputs(*list_url_categories_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-network-object':
                return_outputs(*get_network_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-network-object':
                return_outputs(*create_network_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-network-object':
                return_outputs(*update_network_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-network-object':
                return_outputs(*delete_network_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-host-object':
                return_outputs(*get_host_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-host-object':
                return_outputs(*create_host_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-host-object':
                return_outputs(*update_host_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-host-object':
                return_outputs(*delete_host_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-network-groups-object':
                return_outputs(*get_network_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-network-groups-objects':
                return_outputs(*create_network_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-network-groups-objects':
                return_outputs(*update_network_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-network-groups-objects':
                return_outputs(*delete_network_groups_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-url-groups-object':
                return_outputs(*get_url_groups_objects_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-url-groups-objects':
                return_outputs(*update_url_groups_objects_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-access-policy':
                return_outputs(*get_access_policy_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-access-policy':
                return_outputs(*create_access_policy_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-access-policy':
                return_outputs(*update_access_policy_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-access-policy':
                return_outputs(*delete_access_policy_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-list-security-group-tags':
                return_outputs(*list_security_group_tags_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-ise-security-group-tag':
                return_outputs(*list_ise_security_group_tags_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-vlan-tags':
                return_outputs(*list_vlan_tags_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-vlan-tags-group':
                return_outputs(*list_vlan_tags_group_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-list-applications':
                return_outputs(*list_applications_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-access-rules':
                return_outputs(*get_access_rules_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-access-rules':
                return_outputs(*create_access_rules_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-access-rules':
                return_outputs(*update_access_rules_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-delete-access-rules':
                return_outputs(*delete_access_rules_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-list-policy-assignments':
                return_outputs(*list_policy_assignments_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-create-policy-assignments':
                return_outputs(*create_policy_assignments_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-update-policy-assignments':
                return_outputs(*update_policy_assignments_command(client, demisto.args()))

            elif demisto.command() == 'ciscofp-get-deployable-devices':
                return_outputs(*get_deployable_devices_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-get-device-records':
                return_outputs(*get_device_records_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-deploy-to-devices':
                return_outputs(*deploy_to_devices_command(client, demisto.args()))
            elif demisto.command() == 'ciscofp-get-task-status':
                return_outputs(*get_task_status_command(client, demisto.args()))

        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} Integration [{e}]'
            return_error(err_msg, error=e)


    if __name__ == 'builtins':  # pragma: no cover
        main()
  type: python
  commands:
  - name: ciscofp-list-zones
    arguments:
    - name: limit
      description: |-
        The number of items to return.
        The default is 50
    - name: offset
      description: |-
        Index of the first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.Zone.ID
      description: Zone ID.
      type: String
    - contextPath: CiscoFP.Zone.Name
      description: Zone name.
      type: String
    - contextPath: CiscoFP.Zone.InterfaceMode
      description: Zone interface mode.
      type: String
    - contextPath: CiscoFP.Zone.Interfaces.Name
      description: Name of interfaces belonging to the security zone.
      type: String
    - contextPath: CiscoFP.Zone.Interfaces.ID
      description: ID of interfaces belonging to the security zone.
      type: String
    description: Retrieves a list of all security zone objects.
  - name: ciscofp-list-ports
    arguments:
    - name: limit
      default: true
      description: |-
        The number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        by default is 0
    outputs:
    - contextPath: CiscoFP.Port.ID
      description: Port ID.
      type: String
    - contextPath: CiscoFP.Port.Name
      description: Port name.
      type: String
    - contextPath: CiscoFP.Port.Protocol
      description: Port protocol.
      type: String
    - contextPath: CiscoFP.Port.Port
      description: Port number.
      type: String
    description: Retrieves list of all port objects.
  - name: ciscofp-list-url-categories
    arguments:
    - name: limit
      default: true
      description: |-
        The number of items to return.
        The default is 50.
      defaultValue: "50"
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.Category.ID
      description: ID of the category.
      type: String
    - contextPath: CiscoFP.Category.Name
      description: Name of the category.
      type: String
    description: Retrieves a list of all URL category objects.
  - name: ciscofp-get-network-object
    arguments:
    - name: object_id
      description: Object ID.
    - name: limit
      description: |-
        The number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of network object
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of network object
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CIDR
      type: String
    - contextPath: CiscoFP.Network.Overrideable
      description: Boolean indicating whether object can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of the network object.
      type: String
    description: Retrieves the network objects associated with the specified ID. If
      not supplied, retrieves a list of all network objects.
  - name: ciscofp-create-network-object
    arguments:
    - name: name
      required: true
      description: The name of the new object.
    - name: value
      required: true
      description: CIDR
    - name: description
      description: The object description.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "false"
      - "true"
      description: Boolean indicating whether objects can be overridden. Can be "true"
        or "false". The default is "false".
      defaultValue: "false"
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of network object.
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of network object.
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CIDR.
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether the object can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of the network object.
      type: String
    description: Creates a network object.
  - name: ciscofp-update-network-object
    arguments:
    - name: id
      required: true
      description: ID of the object to update.
    - name: name
      required: true
      description: The object name.
    - name: value
      required: true
      description: CIDR
    - name: description
      description: The object description.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "false"
      - "true"
      description: Boolean indicating whether the object can be overridden.
      defaultValue: "false"
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of the network object.
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of the network object.
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CIDR.
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether the object can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of the network object.
      type: String
    description: Updates the specified network object.
  - name: ciscofp-get-network-groups-object
    arguments:
    - name: id
      description: ID of the object group for which to return groups and addresses.
    - name: limit
      description: |-
        The number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of the first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: The group ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: The group name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether the object can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: The group description.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address / CIDR range.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: The object type.
      type: String
    description: Retrieves the groups of network objects and addresses associated
      with the specified ID. If not supplied, retrieves a list of all network objects.
  - name: ciscofp-create-network-groups-objects
    arguments:
    - name: name
      required: true
      description: The group name.
    - name: network_objects_id_list
      description: A comma-separated list of object IDs to add to the group.
    - name: network_address_list
      description: A comma-separated list of IP addresses or CIDR ranges to add the
        group.
    - name: description
      description: The object description.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "false"
      - "true"
      description: Boolean indicating whether object values can be overridden. Can
        be "true" or "false". The default is "false".
      defaultValue: "false"
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: The group ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: The group name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether the object can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: The group description.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address or CIDR range.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: The object type.
      type: String
    description: Creates a group of network objects.
  - name: ciscofp-update-network-groups-objects
    arguments:
    - name: id
      required: true
      description: The ID of the group to update.
    - name: network_objects_id_list
      description: A comma-separated list of object IDs to add the group.
    - name: network_address_list
      description: A comma-separated list of IP addresses or CIDR ranges to add the
        group.
    - name: description
      description: The new description for the object.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Boolean indicating whether object values can be overridden. Can
        be "true" or "false". The default is "false".
      defaultValue: "false"
    - name: name
      required: true
      description: The group name.
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: The group ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: The group name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether objects can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: The group description.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address or CIDR range.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: The object type.
      type: String
    description: Updates a group of network objects.
  - name: ciscofp-delete-network-groups-objects
    arguments:
    - name: id
      required: true
      description: ID of the object to delete.
    outputs:
    - contextPath: CiscoFP.NetworkGroups.ID
      description: The group ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Name
      description: The group name.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Description
      description: The group description.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Value
      description: IP address or CIDR range.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Name
      description: The object name
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.NetworkGroups.Objects.Type
      description: The object type.
      type: String
    description: Deletes a group of network objects.
  - name: ciscofp-get-host-object
    arguments:
    - name: object_id
      description: ID of the object for which to retrieve host objects.
    - name: limit
      description: |-
        Number of items to return.
        The default is 50
    - name: offset
      description: |-
        Index of the first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of the host object.
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of host object.
      type: String
    - contextPath: CiscoFP.Host.Value
      description: The IP address.
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: A description of the host object.
      type: String
    description: Retrieves the groups of host objects associated with the specified
      ID. If no ID is passed, the input ID retrieves a list of all network objects.
  - name: ciscofp-create-host-object
    arguments:
    - name: name
      required: true
      description: The name of the new object.
    - name: value
      required: true
      description: The IP address.
    - name: description
      description: A description of the new object.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "false"
      - "true"
      description: Boolean indicating whether object values can be overridden. Can
        be "true" or "false". The default is "false".
      defaultValue: "false"
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of the host object.
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of the host object.
      type: String
    - contextPath: CiscoFP.Host.Value
      description: The IP address.
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of the host object.
      type: String
    description: Creates a host object.
  - name: ciscofp-update-host-object
    arguments:
    - name: id
      required: true
      description: ID of the object to update.
    - name: name
      required: true
      description: Name of the object.
    - name: value
      required: true
      description: The IP address.
    - name: description
      description: Description of the object.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "false"
      - "true"
      description: Boolean indicating whether object values can be overridden. Can
        be "true" or "false". The default is "false".
      defaultValue: "false"
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of the host object.
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of the host object.
      type: String
    - contextPath: CiscoFP.Host.Value
      description: The IP address.
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of the host object.
      type: String
    description: Updates the specified host object.
  - name: ciscofp-delete-network-object
    arguments:
    - name: id
      required: true
      description: ID of the object to delete.
    outputs:
    - contextPath: CiscoFP.Network.ID
      description: ID of the network object.
      type: String
    - contextPath: CiscoFP.Network.Name
      description: Name of the network object.
      type: String
    - contextPath: CiscoFP.Network.Value
      description: CISR range.
      type: String
    - contextPath: CiscoFP.Network.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: String
    - contextPath: CiscoFP.Network.Description
      description: Description of the network object.
      type: String
    description: Deletes the specified network object.
  - name: ciscofp-delete-host-object
    arguments:
    - name: id
      required: true
      description: ID of the host object to delete.
    outputs:
    - contextPath: CiscoFP.Host.ID
      description: ID of the host object.
      type: String
    - contextPath: CiscoFP.Host.Name
      description: Name of the host object.
      type: String
    - contextPath: CiscoFP.Host.Value
      description: CIDR range.
      type: String
    - contextPath: CiscoFP.Host.Overridable
      description: Whether the  object can be overridden.
      type: String
    - contextPath: CiscoFP.Host.Description
      description: Description of the host object.
      type: String
    description: Deletes the specified host object.
  - name: ciscofp-get-access-policy
    arguments:
    - name: id
      description: ID of the access policy.
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy.
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: The default action ID of the policy.
      type: String
    description: Retrieves the access control policy associated with the specified
      ID. If no access policy ID is passed, all access control policies are returned.
  - name: ciscofp-create-access-policy
    arguments:
    - name: name
      required: true
      description: The name of the new access policy.
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - BLOCK
      - TRUST
      - PERMIT
      - NETWORK_DISCOVERY
      description: The action to take. Can be "BLOCK", "TRUST", "PERMIT", or "NETWORK_DISCOVERY".
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy.
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: The default action ID of the policy.
      type: String
    description: Creates an access control policy.
  - name: ciscofp-update-access-policy
    arguments:
    - name: name
      required: true
      description: The access policy name.
    - name: id
      required: true
      description: ID of the access policy.
    - name: default_action_id
      required: true
      description: ID of the default action.
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - BLOCK
      - TRUST
      - PERMIT
      - NETWORK_DISCOVERY
      description: The action to take. Can be "BLOCK", "TRUST", "PERMIT", or "NETWORK_DISCOVERY".
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy.
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: The default action ID of the policy.
      type: String
    description: Updates the specified access control policy.
  - name: ciscofp-delete-access-policy
    arguments:
    - name: id
      required: true
      description: ID of the access policy.
    outputs:
    - contextPath: CiscoFP.Policy.ID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.Policy.Name
      description: The name of the policy.
      type: String
    - contextPath: CiscoFP.Policy.DefaultActionID
      description: The default action ID of the policy.
      type: String
    description: Deletes the specified access control policy.
  - name: ciscofp-list-security-group-tags
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.SecurityGroupTags.ID
      description: ID of security group tag.
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Name
      description: Name of security group tag.
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Tag
      description: The tag number.
      type: Number
    description: Retrieves a list of all custom security group tag objects.
  - name: ciscofp-list-ise-security-group-tag
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.SecurityGroupTags.ID
      description: ID of security group tag.
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Name
      description: Name of security group tag.
      type: String
    - contextPath: CiscoFP.SecurityGroupTags.Tag
      description: The tag number.
      type: Number
    description: Retrieves a list of all ISE security group tag objects.
  - name: ciscofp-list-vlan-tags
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.VlanTags.ID
      description: ID of the vlan tag.
      type: String
    - contextPath: CiscoFP.VlanTags.Name
      description: Name of the vlan tag.
      type: String
    - contextPath: CiscoFP.VlanTags.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: Boolean
    - contextPath: CiscoFP.VlanTags.Description
      description: Description of the vlan tag.
      type: String
    - contextPath: CiscoFP.VlanTags.StartTag
      description: Start tag number.
      type: Number
    - contextPath: CiscoFP.VlanTags.EndTag
      description: End tag number.
      type: Number
    description: Retrieves a list of all vlantag objects.
  - name: ciscofp-list-vlan-tags-group
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.VlanTagsGroup.Name
      description: Name of the group.
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.ID
      description: ID of the group.
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.Description
      description: Description of the object.
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: Boolean
    - contextPath: CiscoFP.VlanTagsGroup.Objects.Name
      description: Name of the object.
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.Objects.ID
      description: ID of the object.
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.Objects.Description
      description: Description of the vlan tag.
      type: String
    - contextPath: CiscoFP.VlanTagsGroup.Objects.Overridable
      description: Boolean indicating whether object values can be overridden.
      type: Boolean
    - contextPath: CiscoFP.VlanTagsGroup.Objects.StartTag
      description: Start tag number.
      type: Number
    - contextPath: CiscoFP.VlanTagsGroup.Objects.EndTag
      description: End tag number.
      type: Number
    description: Retrieves a list of all vlan group tag objects.
  - name: ciscofp-list-applications
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0
    outputs:
    - contextPath: CiscoFP.Applications.Name
      description: Name of the application.
      type: String
    - contextPath: CiscoFP.Applications.ID
      description: ID of the application.
      type: String
    - contextPath: CiscoFP.Applications.Risk
      description: Risk of the application.
      type: String
    - contextPath: CiscoFP.Applications.AppProductivity
      description: AppProductivity of the application.
      type: String
    - contextPath: CiscoFP.Applications.ApplicationTypes
      description: The application type.
      type: String
    - contextPath: CiscoFP.Applications.AppCategories.ID
      description: AppCategory ID.
      type: String
    - contextPath: CiscoFP.Applications.AppCategories.Name
      description: AppCategory name.
      type: String
    - contextPath: CiscoFP.Applications.AppCategories.Count
      description: AppCategory count.
      type: String
    description: Retrieves a list of all application objects.
  - name: ciscofp-get-access-rules
    arguments:
    - name: policy_id
      required: true
      description: Policy ID.
    - name: rule_id
      description: Rule ID.
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: Rule action.
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: Application object ID.
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: Application object name.
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: Category of rule.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: Address type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: IP address or CIDR range.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: Object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: Object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: Object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: Port number.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: Port protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: Port object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: Port object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: Port object protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: Port object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: Zone ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: Zone name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: Zone type.
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Whether the rule is enabled.
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: Rule ID.
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: Rule name.
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: The index of the rule.
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: The section of the rule.
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to Cisco
        Firepower.
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: IP address or CIDR range.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: Object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: Object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: Object type.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: Port number.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: Port protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: Object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: Object name.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: Object protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: Object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: Object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: Object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: Object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: Object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: Object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: Object type.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Addresses.URL
      description: URL address.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.ID
      description: URL object ID.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.Name
      description: URL object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: The vlan tag number end tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: The vlan tag number start tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: Object ID.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: Object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: Object type.
      type: String
    description: Retrieves the access control rule associated with the specified policy
      ID and rule ID. If no rule ID is specified, retrieves a list of all access rules
      associated with the specified policy ID.
  - name: ciscofp-create-access-rules
    arguments:
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - ALLOW
      - TRUST
      - BLOCK
      - MONITOR
      - BLOCK_RESET
      - BLOCK_INTERACTIVE
      - BLOCK_RESET_INTERACTIVE
      description: The rule's traffic. Can be "ALLOW", "TRUST", "BLOCK", "MONITOR",
        "BLOCK_RESET", "BLOCK_INTERACTIVE", or "BLOCK_RESET_INTERACTIVE".
    - name: rule_name
      required: true
      description: The rule name.
    - name: enabled
      default: true
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Boolean indicating whether to enable the access control rule.
    - name: source_zone_object_ids
      description: A list of source zone object IDs. To get IDs use the ciscofp-list-zones
        command.
      isArray: true
    - name: policy_id
      required: true
      description: The policy ID in which to create the new rule.
    - name: destination_zone_object_ids
      description: A list of destination zone object IDs. To get IDs, use the ciscofp-list-zones
        command.
      isArray: true
    - name: vlan_tag_object_ids
      description: A list of vlan tag object IDs. To get IDs, use the ciscofp-list-vlan-tags
        command.
      isArray: true
    - name: source_network_object_ids
      description: A list of network object IDs. To get IDs, use the ciscofp-get-network-groups-object
        command.
      isArray: true
    - name: source_network_addresses
      description: A list of source IP addresses or CIDR ranges. To get the addresses
        or ranges, use the ciscofp-get-network-object or ciscofp-get-host-object command,
        respectively.
      isArray: true
    - name: destination_network_object_ids
      description: A list of destination IP addresses or CIDR ranges. To get the addresses
        or ranges, use the ciscofp-get-network-object or ciscofp-get-host-object command,
        respectively.
      isArray: true
    - name: destination_network_addresses
      description: A list of destination addresses.
      isArray: true
    - name: source_port_object_ids
      description: A list of port object IDs. To get IDs,  use the ciscofp-get-network-object
        or ciscofp-get-host-object commands.
    - name: destination_port_object_ids
      description: A list of port object IDs. To get IDs, use the ciscofp-list-ports
        command.
    - name: source_security_group_tag_object_ids
      description: A list of security group tag object IDs. To get IDs, use the ciscofp-list-security-group-tags
        command.
    - name: application_object_ids
      description: A list of application object IDs. To get IDs, use the ciscofp-list-applications
        command.
      isArray: true
    - name: url_object_ids
      description: A list of URL object IDs. To get IDs, use the ciscofp-list-url-categories
        command.
      isArray: true
    - name: url_addresses
      description: A list of URL addresses.
      isArray: true
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: The action that determines how the system handles matching traffic.
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: The application object ID.
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: The application object name.
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: The category of rule.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: The address value.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: The port number.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: The port protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: The port object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: The port object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: The port object protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: The port object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: The zone ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: The zone name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: The zone type.
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Boolean indicating whether to enable the rule.
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: The rule name.
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: The index of the rule.
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: The section of the rule.
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to Cisco
        Firepower.
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: The address value.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: The address port.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: The address protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: The object protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Addresses.URL
      description: The URL address.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.ID
      description: The URL object ID.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.Name
      description: The URL object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: The vlan tag number end tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: The vlan tag number start tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: The object type.
      type: String
    description: Creates an access control rule.
  - name: ciscofp-update-access-rules
    arguments:
    - name: update_strategy
      required: true
      auto: PREDEFINED
      predefined:
      - merge
      - override
      description: |-
        The method by which to update the rule. Can be "merge" or "override".
        If merge, will add the changes requested to the existing rule.
        If override, will override the fields with the inputs provided and will delete any fields that were not provided.
    - name: action
      auto: PREDEFINED
      predefined:
      - ALLOW
      - TRUST
      - BLOCK
      - MONITOR
      - BLOCK_RESET
      - BLOCK_INTERACTIVE
      - BLOCK_RESET_INTERACTIVE
      description: The rule action that determines how the system handles matching
        traffic. Can be "ALLOW", "TRUST", "BLOCK", "MONITOR", "BLOCK_RESET", "BLOCK_INTERACTIVE",
        or "BLOCK_RESET_INTERACTIVE".
    - name: rule_name
      description: The rule name.
    - name: enabled
      default: true
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Boolean indicating whether to enable the rule. The default is "true".
    - name: source_zone_object_ids
      description: A list of source zones object IDs.
      isArray: true
    - name: policy_id
      required: true
      description: The policy ID for which to create the new rule.
    - name: destination_zone_object_ids
      description: A list of destination zones object IDs.
      isArray: true
    - name: vlan_tag_object_ids
      description: A list of vlan tag object IDs.
      isArray: true
    - name: source_network_object_ids
      description: A list of source network object IDs.
      isArray: true
    - name: source_network_addresses
      description: A list of addresses.
      isArray: true
    - name: destination_network_object_ids
      description: A list of destination network object IDs.
      isArray: true
    - name: destination_network_addresses
      description: A list of addresses.
      isArray: true
    - name: source_port_object_ids
      description: A list of port object IDs.
    - name: destination_port_object_ids
      description: A list of port object IDs.
    - name: source_security_group_tag_object_ids
      description: A list of security group tag object IDs.
    - name: application_object_ids
      description: A list of application object IDs.
      isArray: true
    - name: url_object_ids
      description: A list of URL object IDs.
      isArray: true
    - name: url_addresses
      description: A list of URL addresses.
      isArray: true
    - name: rule_id
      required: true
      description: The ID of the rule to update.
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: The action that determines how the system handles matching traffic.
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: The application object ID.
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: The application object name.
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: The category of the rule.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: The address value.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: The port number.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: The port protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: The port object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: The port object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: The port object protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: The port object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: The destination zone object IDs.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: The destination zone object names.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: The destination zone object types.
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Boolean indicating whether the rule is enabled.
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: The rule name.
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: The index of the rule.
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: The section of the rule.
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to Cisco
        Firepower.
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: The address value.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: The address port.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: The address protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: The object protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Addresses.URL
      description: The URL address.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.ID
      description: The URL object ID.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.Name
      description: The URL object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: The vlan tag number end tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: The vlan tag number start tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: The object type.
      type: String
    description: Updates the specified access control rule.
  - name: ciscofp-delete-access-rules
    arguments:
    - name: policy_id
      required: true
      description: The policy ID.
    - name: rule_id
      required: true
      description: The ID of the rule to delete.
    outputs:
    - contextPath: CiscoFP.Rule.Action
      description: The action that determines how the system handles matching traffic.
      type: String
    - contextPath: CiscoFP.Rule.Applications.ID
      description: The application object ID.
      type: String
    - contextPath: CiscoFP.Rule.Applications.Name
      description: The application object name.
      type: String
    - contextPath: CiscoFP.Rule.Category
      description: The category of the rule.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Addresses.Value
      description: The address value.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationNetworks.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Port
      description: The port number.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Addresses.Protocol
      description: The port protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.ID
      description: The port object ID.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Name
      description: The port object name.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Protocol
      description: The port object protocol.
      type: String
    - contextPath: CiscoFP.Rule.DestinationPorts.Objects.Type
      description: The port object type.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.ID
      description: The zone IDs.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Name
      description: The zone names.
      type: String
    - contextPath: CiscoFP.Rule.DestinationZones.Objects.Type
      description: The zone types.
      type: String
    - contextPath: CiscoFP.Rule.Enabled
      description: Boolean indicating whether the rule is enabled.
      type: Number
    - contextPath: CiscoFP.Rule.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoFP.Rule.Name
      description: The rule name.
      type: String
    - contextPath: CiscoFP.Rule.RuleIndex
      description: The index of the rule.
      type: Number
    - contextPath: CiscoFP.Rule.Section
      description: The section of the rule.
      type: String
    - contextPath: CiscoFP.Rule.SendEventsToFMC
      description: Boolean indicating whether the device will send events to Cisco
        Firepower.
      type: Number
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Type
      description: The address type.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Addresses.Value
      description: The address value.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceNetworks.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Port
      description: The address port.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Addresses.Protocol
      description: The address protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Protocol
      description: The object protocol.
      type: String
    - contextPath: CiscoFP.Rule.SourcePorts.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceSecurityGroupTags.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.SourceZones.Objects.Type
      description: The object type.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Addresses.URL
      description: The URL address.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.ID
      description: The URL object ID.
      type: String
    - contextPath: CiscoFP.Rule.Urls.Objects.Name
      description: The URL object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.EndTag
      description: The vlan tag number end tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Numbers.StartTag
      description: The vlan tag number start tag.
      type: Number
    - contextPath: CiscoFP.Rule.VlanTags.Objects.ID
      description: The object ID.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Name
      description: The object name.
      type: String
    - contextPath: CiscoFP.Rule.VlanTags.Objects.Type
      description: The object type.
      type: String
    description: Deletes the specified access control rule.
  - name: ciscofp-list-policy-assignments
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0
    outputs:
    - contextPath: CiscoFP.PolicyAssignments.ID
      description: The policy assignments ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Name
      description: The policy assignments name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyDescription
      description: The policy description.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyName
      description: The policy name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.ID
      description: The targets ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Name
      description: The targets name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Type
      description: The targets type.
      type: String
    description: Retrieves a list of all policy assignments to target devices.
  - name: ciscofp-create-policy-assignments
    arguments:
    - name: policy_id
      required: true
      description: The policy ID.
    - name: device_ids
      description: A list of device IDs.
      isArray: true
    - name: device_group_ids
      description: A list of device group IDs.
      isArray: true
    outputs:
    - contextPath: CiscoFP.PolicyAssignments.ID
      description: The policy assignments ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Name
      description: The policy assignments name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyDescription
      description: The policy description.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyName
      description: The policy name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.ID
      description: The targets ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Name
      description: The targets name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Type
      description: The targets type.
      type: String
    description: Creates policy assignments to target devices.
  - name: ciscofp-update-policy-assignments
    arguments:
    - name: policy_id
      description: The policy ID.
    - name: device_ids
      description: A list of device IDs.
    - name: device_group_ids
      description: A list of device group IDs.
    outputs:
    - contextPath: CiscoFP.PolicyAssignments.ID
      description: The policy assignments ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Name
      description: The policy assignments name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyDescription
      description: The policy description.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyID
      description: The policy ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.PolicyName
      description: The policy name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.ID
      description: The targets ID.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Name
      description: The targets name.
      type: String
    - contextPath: CiscoFP.PolicyAssignments.Targets.Type
      description: The targets type.
      type: String
    description: Updates the specified policy assignments to target devices.
  - name: ciscofp-get-deployable-devices
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    - name: container_uuid
      description: container UUID(Firewall ID)
    outputs:
    - contextPath: CiscoFP.DeployableDevices.CanBeDeployed
      description: Can be deployed.
      type: String
    - contextPath: CiscoFP.DeployableDevices.UpToDate
      description: Up to date.
      type: String
    - contextPath: CiscoFP.DeployableDevices.DeviceID
      description: Device ID.
      type: String
    - contextPath: CiscoFP.DeployableDevices.DeviceName
      description: Device name.
      type: String
    - contextPath: CiscoFP.DeployableDevices.DeviceType
      description: Device type.
      type: String
    - contextPath: CiscoFP.DeployableDevices.Version
      description: Device version.
      type: String
    - contextPath: CiscoFP.PendingDeployment.EndTime
      description: EndTime.
      type: string
    - contextPath: CiscoFP.PendingDeployment.ID
      description: ID.
      type: string
    - contextPath: CiscoFP.PendingDeployment.Name
      description: Name.
      type: string
    - contextPath: CiscoFP.PendingDeployment.StartTime
      description: StartTime.
      type: string
    - contextPath: CiscoFP.PendingDeployment.Status
      description: Status.
      type: string
    - contextPath: CiscoFP.PendingDeployment.Type
      description: Type.
      type: string
    description: Retrieves a list of all devices with configuration changes that are
      ready to deploy.
  - name: ciscofp-get-device-records
    arguments:
    - name: limit
      description: |-
        The maximum number of items to return.
        The default is 50.
    - name: offset
      description: |-
        Index of first item to return.
        The default is 0.
    outputs:
    - contextPath: CiscoFP.DeviceRecords.DeviceGroupID
      description: The device group ID.
      type: String
    - contextPath: CiscoFP.DeviceRecords.HostName
      description: The device host.
      type: String
    - contextPath: CiscoFP.DeviceRecords.ID
      description: The device ID.
      type: String
    - contextPath: CiscoFP.DeviceRecords.Name
      description: The device name.
      type: String
    - contextPath: CiscoFP.DeviceRecords.Type
      description: The device type.
      type: String
    description: Retrieves list of all device records.
  - name: ciscofp-deploy-to-devices
    arguments:
    - name: force_deploy
      required: true
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Boolean indicating whether to force deployment. Can be "true" or
        "false".
    - name: ignore_warning
      required: true
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Boolean indicating whether to ignore warning. Can be "true" or
        "false".
    - name: device_ids
      required: true
      description: A list of device IDs.
      isArray: true
    - name: version
      required: true
      description: The version to deploy. To get versions, use the ciscofp-get-deployable-devices
        command.
    outputs:
    - contextPath: CiscoFP.Deploy.TaskID
      description: The task ID.
      type: String
    - contextPath: CiscoFP.Deploy.ForceDeploy
      description: Whether to force deploy.
      type: String
    - contextPath: CiscoFP.Deploy.IgnoreWarning
      description: Whether to ignore warning.
      type: String
    - contextPath: CiscoFP.Deploy.Version
      description: The version of the policy.
      type: String
    - contextPath: CiscoFP.Deploy.DeviceList
      description: The list of devices.
      type: String
    description: Creates a request for deploying configuration changes to devices.
  - name: ciscofp-get-task-status
    arguments:
    - name: task_id
      required: true
      description: The ID of the task for which to check the status.
    outputs:
    - contextPath: CiscoFP.TaskStatus.Status
      description: task status
      type: String
    description: Retrieves information about a previously submitted pending job or
      task with the specified ID. Used for deploying.
  - name: ciscofp-get-url-groups-object
    arguments:
    - name: id
      required: true
    outputs:
    - contextPath: CiscoFP.URLGroups.ID
      description: The group ID.
      type: string
    - contextPath: CiscoFP.URLGroups.Name
      description: The group Name.
      type: string
    - contextPath: CiscoFP.URLGroups.Overridable
      description: Boolean indicating whether objects can be overridden.
      type: string
    - contextPath: CiscoFP.URLGroups.Description
      description: The group description.
      type: string
    - contextPath: CiscoFP.URLGroups.Addresses.Value
      description: The group addresses.
      type: string
    - contextPath: CiscoFP.URLGroups.Objects.Name
      description: The group object name.
      type: string
    - contextPath: CiscoFP.URLGroups.Objects.ID
      description: The object ID.
      type: string
    - contextPath: CiscoFP.URLGroups.Objects.Type
      description: The object type.
      type: string
    description: Retrieves the groups of url objects and addresses associated with
      the specified ID. If not supplied, retrieves a list of all url objects.
  - name: ciscofp-update-url-groups-objects
    arguments:
    - name: id
      required: true
      description: The ID of the group to update.
    - name: url_objects_id_list
      description: A comma-separated list of object IDs to add the url.
    - name: url_list
      description: A comma-separated list of url to add the group.
    - name: description
      description: The new description for the object.
    - name: overridable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Boolean indicating whether object values can be overridden. Can
        be "true" or "false". The default is "false".
      defaultValue: "false"
    - name: name
      required: true
      description: The group name.
    description: UpdateThe ID of the group to update.s a group of url objects.
  dockerimage: demisto/python3:3.8.6.14516
  runonce: false
  subtype: python3
sourcemoduleid: Cisco Firepower
