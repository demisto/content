category: Email
sectionorder:
- Connect
- Collect
commonfields:
  id: EWSO365 - Custom
  version: -1
configuration:
- additionalinfo: ID can be received from the admin consent procedure - see Detailed Instructions.
  display: ID / Application ID
  name: _client_id
  type: 0
  section: Connect
  required: false
- additionalinfo: Token can be received from the admin consent procedure - see Detailed Instructions.
  display: Token / Tenant ID
  name: _tenant_id
  type: 0
  section: Connect
  required: false
- additionalinfo: Key can be received from the admin consent procedure - see Detailed Instructions.
  displaypassword: Key / Application Secret
  name: credentials
  type: 9
  hiddenusername: true
  section: Connect
  display: ''
  required: false
- additionalinfo: Mailbox to run commands on and to fetch incidents from. To use this functionality, your account must have impersonation rights or delegation for the account specified. For more information, see https://xsoar.pan.dev/docs/reference/integrations/ewso365#additional-information
  display: Email Address
  name: default_target_mailbox
  required: true
  type: 0
  section: Connect
- additionalinfo: If this parameter is given, the commands will run with the UPN mailbox instead of the default target mailbox.
  display: UPN Address
  name: upn_mailbox
  type: 0
  section: Connect
  advanced: true
  required: false
- defaultvalue: Inbox
  display: Name of the folder from which to fetch incidents
  name: folder
  required: true
  type: 0
  additionalinfo: Supports Exchange Folder ID and sub-folders e.g. Inbox/Phishing.
  section: Collect
- defaultvalue: Impersonation
  display: Access Type
  name: access_type
  type: 15
  options:
  - Impersonation
  - Delegate
  section: Connect
  advanced: true
  required: false
- display: Public Folder
  name: is_public_folder
  type: 8
  section: Connect
  advanced: true
  defaultvalue: 'false'
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  section: Collect
  required: false
- display: Incident type
  name: incidentType
  type: 13
  section: Connect
  required: false
- defaultvalue: 10 minutes
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  type: 0
  section: Collect
  required: false
- display: Maximum number of incidents per fetch (up to 200). Performance might be affected by a value higher than 50.
  name: max_fetch
  type: 0
  defaultvalue: '50'
  section: Collect
  required: false
- display: Mark fetched emails as read
  name: mark_as_read
  type: 8
  section: Collect
  advanced: true
  required: false
- display: Timeout (in seconds) for HTTP requests to Exchange Server
  name: request_timeout
  type: 0
  defaultvalue: '120'
  section: Connect
  advanced: true
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  section: Connect
  advanced: true
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  defaultvalue: 'false'
  section: Connect
  advanced: true
  required: false
- display: Run as a separate process (protects against memory depletion)
  name: separate_process
  type: 8
  defaultvalue: 'false'
  section: Connect
  advanced: true
  required: false
- additionalinfo: Select this checkbox if you are using a self-deployed Azure application.
  display: Use a self deployed Azure Application
  name: self_deployed
  type: 8
  section: Connect
  advanced: false
  required: false
- additionalinfo: Use the "ID" parameter instead.
  display: ID / Application ID (Deprecated)
  name: client_id
  type: 4
  hidden: true
  section: Connect
  advanced: true
  required: false
- additionalinfo: Use the "Token" parameter instead.
  display: Token / Tenant ID (Deprecated)
  name: tenant_id
  type: 4
  hidden: true
  section: Connect
  advanced: true
  required: false
- additionalinfo: Use the "Key" parameter instead.
  display: Key / Application Secret (Deprecated)
  name: client_secret
  type: 4
  hidden: true
  section: Connect
  advanced: true
  required: false
- defaultvalue: '1'
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  type: 19
  section: Collect
  required: false
- additionalinfo: Default is to filter by received-time, which works well if the folder is an "Inbox". But for a folder emails are dragged into for attention, if we filter by received-time, out-of-order processing of emails means some are ignored. Filtering by modified-time works better for such a scenario. This works best if any modifications (such as tagging) happens before moving the email into the folder, such that the move into the folder is the last modification, and triggers Cortex XSOAR to fetch it as an incident.
  display: What time field should we filter incidents by?
  name: incidentFilter
  options:
  - received-time
  - modified-time
  type: 15
  section: Collect
  advanced: true
  required: false
description: The new EWS O365 integration uses OAuth 2.0 protocol and can be used with Exchange Online and Office 365 (mail).
display: EWS O365 - Custom
name: EWSO365 - Custom
script:
  commands:
  - arguments:
    - description: The ID of the email message for which to get the attachments.
      name: item-id
      required: true
    - description: The mailbox in which this attachment was found. If empty, the default mailbox is used. Otherwise the user might require impersonation rights to this mailbox.
      name: target-mailbox
    - description: The attachments ids to get. If none - all attachments will be retrieve from the message. Support multiple attachments with comma-separated value or array.
      isArray: true
      name: attachment-ids
    description: Retrieves the actual attachments from an item (email message). To get all attachments for a message, only specify the item-id argument.
    name: ews-get-attachment
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The attachment ID. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: The attachment name. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentSHA256
      description: The SHA256 hash of the attached file.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentLastModifiedTime
      description: The attachment last modified time. Used for file attachments only.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeCreated
      description: The created time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeReceived
      description: The received time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeSent
      description: The sent time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.receivedBy
      description: The received by address of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.subject
      description: The subject of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.textBody
      description: The body of the attached email (as text).
      type: string
    - contextPath: EWS.Items.ItemAttachments.headers
      description: The headers of the attached email.
      type: Unknown
    - contextPath: EWS.Items.ItemAttachments.hasAttachments
      description: Whether the attached email has attachments.
      type: boolean
    - contextPath: EWS.Items.ItemAttachments.itemId
      description: The attached email item ID.
      type: string
    - contextPath: EWS.Items.ItemAttachments.toRecipients
      description: A list of recipient email addresses for the attached email.
      type: Unknown
    - contextPath: EWS.Items.ItemAttachments.body
      description: The body of the attached email (as HTML).
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentSHA256
      description: The SHA256 hash of the attached email (as EML file).
      type: string
    - contextPath: EWS.Items.ItemAttachments.FileAttachments.attachmentSHA256
      description: SHA256 hash of the attached files inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.ItemAttachments.attachmentSHA256
      description: SHA256 hash of the attached emails inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.isRead
      description: The read status of the attachment.
      type: String
  - arguments:
    - description: The ID of the email message for which to delete attachments.
      name: item-id
      required: true
    - description: The mailbox in which this attachment was found. If empty, the default mailbox is used. Otherwise the user might require impersonation rights to this mailbox.
      name: target-mailbox
    - description: A comma-separated list (or array) of attachment IDs to delete. If empty, all attachments will be deleted from the message.
      isArray: true
      name: attachment-ids
    description: Deletes the attachments of an item (email message).
    name: ews-delete-attachment
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The ID of the deleted attachment, in case of file attachment.
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: The ID of the deleted attachment, in case of other attachment (for example, "email").
      type: string
    - contextPath: EWS.Items.FileAttachments.action
      description: "The deletion action in case of file attachment. This is a constant value: 'deleted'."
      type: string
    - contextPath: EWS.Items.ItemAttachments.action
      description: "The deletion action in case of other attachment (for example, \"email\"). This is a constant value: 'deleted'."
      type: string
  - description: Returns a list of searchable mailboxes. This command requires eDiscovery permissions to the Exchange Server. For more information, see the EWSv2 integration documentation.
    name: ews-get-searchable-mailboxes
    outputs:
    - contextPath: EWS.Mailboxes.mailbox
      description: Addresses of the searchable mailboxes.
      type: string
    - contextPath: EWS.Mailboxes.mailboxId
      description: IDs of the searchable mailboxes.
      type: string
    - contextPath: EWS.Mailboxes.displayName
      description: The email display name.
      type: string
    - contextPath: EWS.Mailboxes.isExternal
      description: Whether the mailbox is external.
      type: boolean
    - contextPath: EWS.Mailboxes.externalEmailAddress
      description: The external email address.
      type: string
    arguments: []
  - arguments:
    - description: The ID of the item to move.
      name: item-id
      required: true
    - description: The path to the folder to which to move the item. Complex paths are supported, for example, "Inbox\Phishing".
      name: target-folder-path
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the target folder is a public folder. Can be "True" or "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Move an item to different folder in the mailbox.
    name: ews-move-item
    outputs:
    - contextPath: EWS.Items.newItemID
      description: The item ID after move.
      type: string
    - contextPath: EWS.Items.messageID
      description: The item message ID.
      type: string
    - contextPath: EWS.Items.itemId
      description: The original item ID.
      type: string
    - contextPath: EWS.Items.action
      description: The action taken. The value will be "moved".
      type: string
  - arguments:
    - description: The item IDs to delete.
      name: item-ids
      required: true
    - defaultValue: soft
      description: Deletion type. Can be "trash", "soft", or "hard".
      name: delete-type
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    description: Delete items from mailbox.
    name: ews-delete-items
    outputs:
    - contextPath: EWS.Items.itemId
      description: The deleted item ID.
      type: string
    - contextPath: EWS.Items.messageId
      description: The deleted message ID.
      type: string
    - contextPath: EWS.Items.action
      description: The deletion action. Can be 'trash-deleted', 'soft-deleted', or 'hard-deleted'.
      type: string
  - arguments:
    - description: 'The search query string. For more information about the query syntax, see the Microsoft documentation: https://msdn.microsoft.com/en-us/library/ee693615.aspx'
      name: query
    - description: The folder path in which to search. If empty, searches all folders in the mailbox.
      name: folder-path
    - defaultValue: '50'
      description: Maximum number of results to return. The default is 50.
      name: limit
    - description: The mailbox on which to apply the search.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the folder is a public folder. Can be "True" or "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    - description: The message ID of the email. This will be ignored if a query argument is provided.
      name: message-id
    - defaultValue: all
      description: A comma-separated list of fields to retrieve.
      isArray: true
      name: selected-fields
      predefined:
      - ''
      auto: PREDEFINED
    description: Searches for items in the specified mailbox. Specific permissions are needed for this operation to search in a target mailbox other than the default.
    name: ews-search-mailbox
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item ID.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender email address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: List of email recipients addresses.
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
  - arguments:
    - description: The mailbox for which to retrieve the contacts.
      name: target-mailbox
    - defaultValue: '50'
      description: Maximum number of results to return. The default is 50.
      name: limit
    description: Retrieves contacts for a specified mailbox.
    name: ews-get-contacts
    outputs:
    - contextPath: Account.Email.EwsContacts.displayName
      description: The contact name.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.lastModifiedTime
      description: The time that the contact was last modified.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.emailAddresses
      description: Phone numbers of the contact.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.physicalAddresses
      description: Physical addresses of the contact.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.phoneNumbers.phoneNumber
      description: Email addresses of the contact.
      type: Unknown
  - arguments:
    - description: The mailbox for which to get the out-of-office status.
      name: target-mailbox
      required: true
    description: Retrieves the out-of-office status for a specified mailbox.
    name: ews-get-out-of-office
    outputs:
    - contextPath: Account.Email.OutOfOffice.state
      description: 'Out-of-office state. Result can be: Enabled, Scheduled, Disabled.'
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.externalAudience
      description: Out-of-office external audience. Can be "None", "Known", or "All".
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.start
      description: Out-of-office start date.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.end
      description: Out-of-office end date.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.internalReply
      description: Out-of-office internal reply.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.externalReply
      description: Out-of-office external reply.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.mailbox
      description: Out-of-office mailbox.
      type: Unknown
  - arguments:
    - description: A comma-separated list of message IDs. Run the py-ews-delete-items command to retrieve the message IDs.
      name: message-ids
      required: true
    - defaultValue: Inbox
      description: The folder path to recover the messages to.
      name: target-folder-path
      required: true
    - description: The mailbox in which the messages found. If empty, will use the default mailbox. If you specify a different mailbox, you might need impersonation rights to the mailbox.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the target folder is a Public Folder. Can be "True" or "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Recovers messages that were soft-deleted.
    name: ews-recover-messages
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID of the recovered item.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: The message ID of the recovered item.
      type: Unknown
    - contextPath: EWS.Items.action
      description: The action taken on the item. The value will be 'recovered'.
      type: Unknown
  - arguments:
    - description: The name of the new folder.
      name: new-folder-name
      required: true
    - defaultValue: Inbox
      description: Path to locate the new folder. Exchange folder ID is also supported.
      name: folder-path
      required: true
    - description: The mailbox in which to create the folder.
      name: target-mailbox
    description: Creates a new folder in a specified mailbox.
    name: ews-create-folder
  - arguments:
    - description: The item ID to mark as junk.
      name: item-id
      required: true
    - auto: PREDEFINED
      defaultValue: yes
      description: Whether to move the item from the original folder to the junk folder. Can be "yes" or "no". The default is "yes".
      name: move-items
      predefined:
      - yes
      - no
    - description: If empty, will use the default mailbox. If you specify a different mailbox, you might need impersonation rights to the mailbox.
      name: target-mailbox
    description: 'Marks an item as junk. This is commonly used to block an email address. For more information, see the Microsoft documentation: https://msdn.microsoft.com/en-us/library/office/dn481311(v=exchg.150).aspx.'
    name: ews-mark-item-as-junk
  - arguments:
    - description: The mailbox on which to apply the command.
      name: target-mailbox
    description: Retrieves information for folders for a specified mailbox. Only folders with read permissions will be returned. Your visual folders on the mailbox, such as "Inbox", are under the folder "Top of Information Store".
    name: ews-find-folders
    outputs:
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.id
      description: Folder ID.
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Number of items in the folder.
      type: Unknown
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread items in the folder.
      type: number
    - contextPath: EWS.Folders.changeKey
      description: Folder change key.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
  - arguments:
    - description: The folder path from which to get the items.
      name: folder-path
      required: true
    - defaultValue: '50'
      description: Maximum number of items to return. The default is 50.
      name: limit
    - description: The mailbox on which to apply the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the folder is a public folder. Can be "True" or "False". The default is "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    - auto: PREDEFINED
      defaultValue: no
      description: If the email item contains another email as an attachment (EML or MSG file), whether to retrieve the EML/MSG file attachment. Can be "yes" or "no". The default is "no".
      name: get-internal-item
      predefined:
      - yes
      - no
    description: Retrieves items from a specified folder in a mailbox. The items are order by the item created time, most recent is first.
    name: ews-get-items-from-folder
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID of the email.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender mail address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
    - contextPath: EWS.Items.categories
      description: The categories of the email.
      type: unknown
  - arguments:
    - description: A comma-separated list of item IDs.
      isArray: true
      name: item-ids
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    description: Retrieves items by item ID.
    name: ews-get-items
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item ID.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender mail address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
    - contextPath: Email.CC
      description: Email addresses CC'ed to the email.
      type: String
    - contextPath: Email.BCC
      description: Email addresses BCC'ed to the email.
      type: String
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.HeadersMap
      description: The headers of the email.
      type: String
    - contextPath: EWS.Items.categories
      description: The categories of the email.
      type: unknown
  - arguments:
    - description: The item ID to move.
      name: item-id
      required: true
    - description: The folder in the destination mailbox to which to move the item. You can specify a complex path, for example, "Inbox\Phishing".
      name: destination-folder-path
      required: true
    - description: The mailbox to which to move the item.
      name: destination-mailbox
      required: true
    - description: The mailbox from which to move the item (conventionally called the "target-mailbox", the target mailbox on which to run the command).
      name: source-mailbox
    - auto: PREDEFINED
      description: Whether the destination folder is a Public Folder. Can be "True" or "False". Default is "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Moves an item from one mailbox to different mailbox.
    name: ews-move-item-between-mailboxes
    outputs:
    - contextPath: EWS.Items.movedToMailbox
      description: The mailbox wo which the item was moved.
      type: string
    - contextPath: EWS.Items.movedToFolder
      description: The folder to which the item was moved.
      type: string
    - contextPath: EWS.Items.action
      description: The action taken on the item. The value will be "moved".
      type: string
  - arguments:
    - description: The mailbox on which to run the search.
      name: target-mailbox
    - default: true
      defaultValue: AllItems
      description: The path of the folder to retrieve. If empty, will retrieve the folder "AllItems".
      name: folder-path
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder. Default is "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Retrieves a single folder.
    name: ews-get-folder
    outputs:
    - contextPath: EWS.Folders.id
      description: Folder ID.
      type: string
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.changeKey
      description: Folder change key.
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Total number of emails in the folder.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread emails in the folder.
      type: number
  - arguments:
    - description: Email address of the group to expand.
      name: email-address
      required: true
    - auto: PREDEFINED
      defaultValue: 'False'
      description: Whether to enable recursive expansion. Can be "True" or "False". Default is "False".
      name: recursive-expansion
      predefined:
      - 'True'
      - 'False'
    description: Expands a distribution list to display all members. By default, expands only first layer of the distribution list. If recursive-expansion is "True", the command expands nested distribution lists and returns all members.
    name: ews-expand-group
  - arguments:
    - description: A comma-separated list of item IDs.
      isArray: true
      name: item-ids
      required: true
    - auto: PREDEFINED
      defaultValue: read
      description: How to mark the item. Can be "read" or "unread". Default is "read".
      name: operation
      predefined:
      - read
      - unread
    - description: The mailbox on which to run the command. If empty, the command will be applied on the default mailbox.
      name: target-mailbox
    description: Marks items as read or unread.
    name: ews-mark-items-as-read
    outputs:
    - contextPath: EWS.Items.action
      description: The action that was performed on item.
      type: String
    - contextPath: EWS.Items.itemId
      description: The ID of the item.
      type: String
    - contextPath: EWS.Items.messageId
      description: The message ID of the item.
      type: String
  - arguments:
    - description: The item ID of the item to upload as an EML file.
      name: item-id
      required: true
    - description: The mailbox in which this email was found. If empty, the default mailbox is used. Otherwise the user might require impersonation rights to this mailbox.
      name: target-mailbox
    description: Retrieves items by item ID and uploads its content as an EML file.
    name: ews-get-items-as-eml
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: EntryID of the file.
      type: String
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
  - arguments:
    - default: true
      description: Email addresses for the 'To' field. Supports comma-separated values.
      isArray: true
      name: to
    - description: Email addresses for the 'Cc' field. Supports comma-separated values.
      isArray: true
      name: cc
    - description: Email addresses for the 'Bcc' field. Supports comma-separated values.
      isArray: true
      name: bcc
    - description: The email subject.
      name: subject
    - description: The content (body) of the email (in plain text).
      name: body
    - description: The content (body) of the email (in HTML format).
      name: htmlBody
    - description: A comma-separated list of War Room entry IDs that contain the files to attach to the email.
      isArray: true
      name: attachIDs
    - description: A comma-separated list to rename file names of corresponding attachment IDs. For example, rename the first two files - attachNames=file_name1,file_name2. rename first and third file - attachNames=file_name1,,file_name3).
      isArray: true
      name: attachNames
    - description: A comma-separated list of CIDs to embed attachments inside the email itself.
      isArray: true
      name: attachCIDs
    - description: A name for the attached file. You can pass multiple files in a comma-separated list, e.g., transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test 2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz".
      isArray: true
      name: transientFile
    - description: Content for the attached file. You can pass multiple files in a comma-separated list, e.g., transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test 2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz".
      isArray: true
      name: transientFileContent
    - description: CID for the attached file if it's inline. You can pass multiple files in a comma-separated list, e.g., transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test 2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz".
      isArray: true
      name: transientFileCID
    - description: 'Replace {varname} variables with values from this argument. Expected values are in the form of a JSON document, such ase {"varname": {"value": "some value", "key": "context key"}}. Each var name can either be provided with the value or a context key from which to retrieve the value. Note that only context data is accessible for this argument, while incident fields are not.'
      name: templateParams
    - description: 'A comma-separated list of additional headers in the format: headerName=headerValue. For example: "headerName1=headerValue1,headerName2=headerValue2".'
      isArray: true
      name: additionalHeader
    - description: Raw email message. If provided, all other arguments will be ignored except "to", "cc", and "bcc".
      name: raw_message
    - description: The email address from which to reply.
      name: from
    - description: Email addresses that need to be used to reply to the message. Supports comma-separated values.
      isArray: true
      name: replyTo
    - auto: PREDEFINED
      defaultValue: Normal
      description: Sets the importance/Priority of the email. Default value is Normal.
      name: importance
      predefined:
      - High
      - Normal
      - Low
    description: Sends an email.
    name: send-mail
  - name: reply-mail
    arguments:
    - name: inReplyTo
      required: true
      description: ID of the item to reply to.
    - name: to
      required: true
      description: A comma-separated list of email addresses for the 'to' field.
    - name: cc
      description: A comma-separated list of email addresses for the 'cc' field.
    - name: bcc
      description: A comma-separated list of email addresses for the 'bcc' field.
    - name: subject
      description: Subject for the email to be sent.
    - name: body
      description: The contents (body) of the email to be sent.
    - name: htmlBody
      description: HTML formatted content (body) of the email to be sent. This argument overrides the "body" argument.
    - name: renderBody
      description: Indicates whether to render the email body.
      auto: PREDEFINED
      predefined:
      - 'true'
      - 'false'
    - name: attachIDs
      description: 'A comma-separated list of War Room entry IDs that contain files, and are used to attach files to the outgoing email. For example: attachIDs=15@8,19@8.'
      isArray: true
    - name: attachNames
      description: A comma-separated list of names of attachments to send. Should be the same number of elements as attachIDs.
      isArray: true
    - name: attachCIDs
      description: A comma-separated list of CIDs to embed attachments within the email itself.
      isArray: true
    description: Replies to an email using EWS.
  - description: Run this command if for some reason you need to rerun the authentication process.
    name: ews-auth-reset
    arguments: []
  dockerimage: demisto/py3ews:1.0.0.86480
  isfetch: true
  script: >
    register_module_line('EWSO365', 'start', __line__())

    ### pack version: 1.2.39

    import email

    import hashlib

    import json

    import logging

    import os

    import random

    import string

    import subprocess

    import sys

    import traceback

    import warnings

    from email.policy import SMTP, SMTPUTF8

    from io import StringIO

    from multiprocessing import Process

    from xml.sax import SAXParseException


    import chardet

    import dateparser

    import exchangelib

    from exchangelib import (
        IMPERSONATION,
        OAUTH2,
        Account,
        Body,
        Configuration,
        EWSDateTime,
        EWSTimeZone,
        ExtendedProperty,
        FileAttachment,
        Folder,
        HTMLBody,
        Identity,
        ItemAttachment,
        OAuth2AuthorizationCodeCredentials,
        Version,
    )

    from exchangelib.errors import (
        ErrorFolderNotFound,
        ErrorInvalidIdMalformed,
        ErrorItemNotFound,
        ErrorMailboxMoveInProgress,
        ErrorMailboxStoreUnavailable,
        ErrorNameResolutionNoResults,
        MalformedResponseError,
        RateLimitError,
        ResponseMessageError,
    )

    from exchangelib.items import Contact, Item, Message

    from exchangelib.protocol import BaseProtocol, NoVerifyHTTPAdapter

    from exchangelib.services.common import EWSAccountService, EWSService

    from exchangelib.util import MNS, TNS, add_xml_child, create_element

    from exchangelib.version import EXCHANGE_O365

    from oauthlib.oauth2 import OAuth2Token

    from requests.exceptions import ConnectionError





    ### GENERATED CODE ###: from MicrosoftApiModule import *

    # This code was inserted in place of an API module.

    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)



    # pylint: disable=E9010, E9011

    import traceback



    import requests

    import re

    import base64

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM



    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'  # resource_manager


    class Resources:
        graph = 'https://graph.microsoft.com/'
        security_center = 'https://api.securitycenter.microsoft.com/'
        management_azure = 'https://management.azure.com/'  # resource_manager
        manage_office = 'https://manage.office.com/'


    # authorization types

    OPROXY_AUTH_TYPE = 'oproxy'

    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = 'client_credentials'

    AUTHORIZATION_CODE = 'authorization_code'

    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line

    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'

    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'

    REGEX_SEARCH_ERROR_DESC = r"^.*?:\s(?P<desc>.*?\.)"

    SESSION_STATE = 'session_state'


    # Deprecated, prefer using AZURE_CLOUDS

    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }


    # Deprecated, prefer using AZURE_CLOUDS

    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.us',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }


    # Deprecated, prefer using AZURE_CLOUDS

    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }


    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }


    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"

    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"



    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris

    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api

    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }


    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'geo-us': 'https://login.microsoftonline.com',
        'geo-eu': 'https://login.microsoftonline.com',
        'geo-uk': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
    }


    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints

    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'geo-us': 'https://graph.microsoft.com',
        'geo-eu': 'https://graph.microsoft.com',
        'geo-uk': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
    }


    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        'com': 'https://securitycenter.onmicrosoft.com',
        'geo-us': 'https://securitycenter.onmicrosoft.com',
        'geo-eu': 'https://securitycenter.onmicrosoft.com',
        'geo-uk': 'https://securitycenter.onmicrosoft.com',
        'gcc': 'https://securitycenter.onmicrosoft.us',
        'gcc-high': 'https://securitycenter.onmicrosoft.us',
        'dod': 'https://securitycenter.onmicrosoft.us',
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }



    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
    }


    # Azure Managed Identities

    MANAGED_IDENTITIES_TOKEN_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01'

    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = 'SYSTEM_ASSIGNED'

    TOKEN_EXPIRED_ERROR_CODES = {50173, 700082, 70008, 54005, 7000222,
                                 }  # See: https://login.microsoftonline.com/error?code=

    # Moderate Retry Mechanism

    MAX_DELAY_REQUEST_COUNTER = 6



    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     management=None,
                     resource_manager=None,
                     sql_management=None,
                     batch_resource_id=None,
                     gallery=None,
                     active_directory=None,
                     active_directory_resource_id=None,
                     active_directory_graph_resource_id=None,
                     microsoft_graph_resource_id=None,
                     active_directory_data_lake_resource_id=None,
                     vm_image_alias_doc=None,
                     media_resource_id=None,
                     ossrdbms_resource_id=None,
                     log_analytics_resource_id=None,
                     app_insights_resource_id=None,
                     app_insights_telemetry_channel_resource_id=None,
                     synapse_analytics_resource_id=None,
                     attestation_resource_id=None,
                     portal=None,
                     keyvault=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     storage_endpoint=None,
                     storage_sync_endpoint=None,
                     keyvault_dns=None,
                     mhsm_dns=None,
                     sql_server_hostname=None,
                     azure_datalake_store_file_system_endpoint=None,
                     azure_datalake_analytics_catalog_and_job_endpoint=None,
                     acr_login_server_endpoint=None,
                     mysql_server_endpoint=None,
                     postgresql_server_endpoint=None,
                     mariadb_server_endpoint=None,
                     synapse_analytics_endpoint=None,
                     attestation_endpoint=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """ Represents an Azure Cloud instance """

        def __init__(self,
                     origin,
                     name,
                     abbreviation,
                     endpoints=None,
                     suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        'Embedded',
        'AzureCloud',
        'com',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.windows.net/',
            resource_manager='https://management.azure.com/',
            sql_management='https://management.core.windows.net:8443/',
            batch_resource_id='https://batch.core.windows.net/',
            gallery='https://gallery.azure.com/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.windows.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.com/',
            active_directory_data_lake_resource_id='https://datalake.azure.net/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.azure.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.windows.net',
            app_insights_resource_id='https://api.applicationinsights.io',
            log_analytics_resource_id='https://api.loganalytics.io',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.com/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.net',
            attestation_resource_id='https://attest.azure.net',
            portal='https://portal.azure.com',
            keyvault='https://vault.azure.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.windows.net',
            storage_sync_endpoint='afs.azure.net',
            keyvault_dns='.vault.azure.net',
            mhsm_dns='.managedhsm.azure.net',
            sql_server_hostname='.database.windows.net',
            mysql_server_endpoint='.mysql.database.azure.com',
            postgresql_server_endpoint='.postgres.database.azure.com',
            mariadb_server_endpoint='.mariadb.database.azure.com',
            azure_datalake_store_file_system_endpoint='azuredatalakestore.net',
            azure_datalake_analytics_catalog_and_job_endpoint='azuredatalakeanalytics.net',
            acr_login_server_endpoint='.azurecr.io',
            synapse_analytics_endpoint='.dev.azuresynapse.net',
            attestation_endpoint='.attest.azure.net'))

    AZURE_US_GCC_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc-high',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_DOD_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'dod',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://dod-graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))


    AZURE_GERMAN_CLOUD = AzureCloud(
        'Embedded',
        'AzureGermanCloud',
        'de',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.cloudapi.de/',
            resource_manager='https://management.microsoftazure.de',
            sql_management='https://management.core.cloudapi.de:8443/',
            batch_resource_id='https://batch.cloudapi.de/',
            gallery='https://gallery.cloudapi.de/',
            active_directory='https://login.microsoftonline.de',
            active_directory_resource_id='https://management.core.cloudapi.de/',
            active_directory_graph_resource_id='https://graph.cloudapi.de/',
            microsoft_graph_resource_id='https://graph.microsoft.de',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.cloudapi.de',
            ossrdbms_resource_id='https://ossrdbms-aad.database.cloudapi.de',
            portal='https://portal.microsoftazure.de',
            keyvault='https://vault.microsoftazure.de'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.cloudapi.de',
            keyvault_dns='.vault.microsoftazure.de',
            mhsm_dns='.managedhsm.microsoftazure.de',
            sql_server_hostname='.database.cloudapi.de',
            mysql_server_endpoint='.mysql.database.cloudapi.de',
            postgresql_server_endpoint='.postgres.database.cloudapi.de',
            mariadb_server_endpoint='.mariadb.database.cloudapi.de'))

    AZURE_CHINA_CLOUD = AzureCloud(
        'Embedded',
        'AzureChinaCloud',
        'cn',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.chinacloudapi.cn/',
            resource_manager='https://management.chinacloudapi.cn',
            sql_management='https://management.core.chinacloudapi.cn:8443/',
            batch_resource_id='https://batch.chinacloudapi.cn/',
            gallery='https://gallery.chinacloudapi.cn/',
            active_directory='https://login.chinacloudapi.cn',
            active_directory_resource_id='https://management.core.chinacloudapi.cn/',
            active_directory_graph_resource_id='https://graph.chinacloudapi.cn/',
            microsoft_graph_resource_id='https://microsoftgraph.chinacloudapi.cn',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.chinacloudapi.cn',
            ossrdbms_resource_id='https://ossrdbms-aad.database.chinacloudapi.cn',
            app_insights_resource_id='https://api.applicationinsights.azure.cn',
            log_analytics_resource_id='https://api.loganalytics.azure.cn',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.cn/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.azure.cn',
            portal='https://portal.azure.cn',
            keyvault='https://vault.azure.cn',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.chinacloudapi.cn',
            keyvault_dns='.vault.azure.cn',
            mhsm_dns='.managedhsm.azure.cn',
            sql_server_hostname='.database.chinacloudapi.cn',
            mysql_server_endpoint='.mysql.database.chinacloudapi.cn',
            postgresql_server_endpoint='.postgres.database.chinacloudapi.cn',
            mariadb_server_endpoint='.mariadb.database.chinacloudapi.cn',
            acr_login_server_endpoint='.azurecr.cn',
            synapse_analytics_endpoint='.dev.azuresynapse.azure.cn'))


    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }


    AZURE_CLOUD_NAME_CUSTOM = "Custom"


    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }



    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(origin: str,
                                  name: str | None = None,
                                  abbreviation: str | None = None,
                                  defaults: AzureCloud | None = None,
                                  endpoints: dict | None = None,
                                  suffixes: dict | None = None):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get('management', defaults.endpoints.management),
                resource_manager=endpoints.get('resource_manager', defaults.endpoints.resource_manager),
                sql_management=endpoints.get('sql_management', defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get('batch_resource_id', defaults.endpoints.batch_resource_id),
                gallery=endpoints.get('gallery', defaults.endpoints.gallery),
                active_directory=endpoints.get('active_directory', defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get('active_directory_resource_id',
                                                           defaults.endpoints.active_directory_resource_id),
                active_directory_graph_resource_id=endpoints.get(
                    'active_directory_graph_resource_id', defaults.endpoints.active_directory_graph_resource_id),
                microsoft_graph_resource_id=endpoints.get('microsoft_graph_resource_id',
                                                          defaults.endpoints.microsoft_graph_resource_id),
                active_directory_data_lake_resource_id=endpoints.get(
                    'active_directory_data_lake_resource_id', defaults.endpoints.active_directory_data_lake_resource_id),
                vm_image_alias_doc=endpoints.get('vm_image_alias_doc', defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get('media_resource_id', defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get('ossrdbms_resource_id', defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get('app_insights_resource_id', defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get('log_analytics_resource_id', defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    'app_insights_telemetry_channel_resource_id', defaults.endpoints.app_insights_telemetry_channel_resource_id),
                synapse_analytics_resource_id=endpoints.get(
                    'synapse_analytics_resource_id', defaults.endpoints.synapse_analytics_resource_id),
                attestation_resource_id=endpoints.get('attestation_resource_id', defaults.endpoints.attestation_resource_id),
                portal=endpoints.get('portal', defaults.endpoints.portal),
                keyvault=endpoints.get('keyvault', defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get('storage_endpoint', defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get('storage_sync_endpoint', defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get('keyvault_dns', defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get('mhsm_dns', defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get('sql_server_hostname', defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get('mysql_server_endpoint', defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get('postgresql_server_endpoint', defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get('mariadb_server_endpoint', defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    'azure_datalake_store_file_system_endpoint', defaults.suffixes.azure_datalake_store_file_system_endpoint),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    'azure_datalake_analytics_catalog_and_job_endpoint',
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint),
                acr_login_server_endpoint=suffixes.get('acr_login_server_endpoint', defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get('synapse_analytics_endpoint', defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get('attestation_endpoint', defaults.suffixes.attestation_endpoint),
            ))


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, 'com')
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get('azure_cloud')
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if 'server_url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'resource_manager': params.get('server_url')
                                                            or 'https://management.azure.com'})
            if 'azure_ad_endpoint' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={
                                                     'active_directory': params.get('azure_ad_endpoint')
                                                     or 'https://login.microsoftonline.com'
                                                 })
            # in multiple Graph integrations, the url is called 'url' instead of 'server_url' and the default url is different.
            if 'url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'microsoft_graph_resource_id': params.get('url')
                                                            or 'https://graph.microsoft.com'})

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str | None = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str | None = '',
                     multi_resource: bool = False,
                     resources: list[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: int | None = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
                     endpoint: str = "__NA__",  # Deprecated
                     certificate_thumbprint: str | None = None,
                     retry_on_rate_limit: bool = False,
                     private_key: str | None = None,
                     managed_identities_client_id: str | None = None,
                     managed_identities_resource_uri: str | None = None,
                     base_url: str | None = None,
                     command_prefix: str | None = "command_prefix",
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=self.azure_cloud.endpoints.active_directory
                                                                      .rstrip("/"))
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(
                endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: str | None = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    try:
                        import defusedxml.ElementTree as defused_ET
                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug('defused_ET is not supported, using ET instead.')
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f'Failed to parse json object from response: {response.content}', exception)

        def get_access_token(self, resource: str = '', scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else \
                            min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug('Set integration context successfully.')

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = 'Error in Microsoft authorization.'
            try:
                demisto.info(
                    f'Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} '
                    f'{oproxy_response.text}'
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r'{.*}', oproxy_response.text)
                microsoft_response = self.extract_microsoft_error(json.loads(search_microsoft_response.group())) \
                    if search_microsoft_response else ""
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f' body: {err_str}'
                err_response = oproxy_response.json()
                server_msg = err_response.get('message', '') or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f' Server message: {server_msg}'
            except Exception as ex:
                demisto.error(f'Failed parsing error response - Exception: {ex}')
            raise Exception(msg)

        def _oproxy_authorize_build_request(self, headers: dict[str, str], content: str,
                                            scope: str | None = None, resource: str = ''
                                            ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

        def _oproxy_authorize(self, resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get('delay_request_counter', 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(next_request_time=next_request_time, delay_request_counter=delay_request_counter,
                                              context=context)
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: str | None = None,
                                     integration_context: dict | None = None
                                     ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:

                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return '', expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                      resource)
                    self.resource_to_access_token[resource] = access_token

                return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: str | None = None,
                                                        resource: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope or self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = (self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED)
                resource = resource or self.managed_identities_resource_uri

                demisto.debug('try to get Managed Identities token')

                params = {'resource': resource}
                if not use_system_assigned:
                    params['client_id'] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={'Metadata': 'True'}).json()
                access_token = response_json.get('access_token')
                expires_in = int(response_json.get('expires_in', 3595))
                if access_token:
                    return access_token, expires_in, ''

                err = response_json.get('error_description')
            except Exception as e:
                err = f'{str(e)}'

            return_error(f'Error in Microsoft authorization with Azure Managed Identities: {err}')
            return None

        def _get_token_device_code(
            self, refresh_token: str = '', scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run))

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get('error', {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get('error_description', '')

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += f"\nYou can run the ***{self.command_prefix}-auth-reset*** command " \
                               f"to reset the authentication process."
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f'Failed getting integration info: {str(e)}')

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search['url'] if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
            Calculates the next request time based on the delay_request_counter.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2 ** delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
            Sets the next_request_time in the integration context.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context['next_request_time'] = next_request_time
        context['delay_request_counter'] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context['delay_request_counter'] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
            Checks if the request should be delayed based on context variables.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get('auth_type') or params.get('authentication_type')
        if params and (argToBoolean(params.get('use_managed_identities') or auth_type == 'Azure Managed Identities')):
            client_id = params.get('managed_identities_client_id', {}).get('password')
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient,
                           login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException("Please make sure you entered the Authorization configuration correctly. "
                                   f"Missing:{','.join(missing)}")

        login_url = urljoin(login_url, f'{client.tenant_id}/oauth2/v2.0/authorize?'
                                       f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
                                       f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}')

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.

    You will be automatically redirected to a link with the following structure:

    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```

    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)

    and paste it in your instance configuration under the **Authorization code** parameter.
        """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f'No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.')



    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(readable_output='Authorization was reset successfully. Please regenerate the credentials, '
                                              'and then click **Test** to validate the credentials and connection.')

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###


    # Ignore warnings print to stdout

    warnings.filterwarnings("ignore")


    """ Constants """


    APP_NAME = "ms-ews-o365"

    FOLDER_ID_LEN = 120

    MAX_INCIDENTS_PER_FETCH = 200

    FETCH_TIME = demisto.params().get('fetch_time') or '10 minutes'


    # move results

    MOVED_TO_MAILBOX = "movedToMailbox"

    MOVED_TO_FOLDER = "movedToFolder"


    # item types

    FILE_ATTACHMENT_TYPE = "FileAttachment"

    ITEM_ATTACHMENT_TYPE = "ItemAttachment"

    ATTACHMENT_TYPE = "attachmentType"


    TOIS_PATH = "/root/Top of Information Store/"


    # context keys

    ATTACHMENT_ID = "attachmentId"

    ATTACHMENT_ORIGINAL_ITEM_ID = "originalItemId"

    NEW_ITEM_ID = "newItemId"

    MESSAGE_ID = "messageId"

    ITEM_ID = "itemId"

    ACTION = "action"

    MAILBOX = "mailbox"

    MAILBOX_ID = "mailboxId"

    FOLDER_ID = "id"

    TARGET_MAILBOX = 'receivedBy'


    # context paths

    CONTEXT_UPDATE_EWS_ITEM = f"EWS.Items((val.{ITEM_ID} === obj.{ITEM_ID} || " \
                              f"(val.{MESSAGE_ID} && obj.{MESSAGE_ID} && val.{MESSAGE_ID} === obj.{MESSAGE_ID}))" \
                              f" && val.{TARGET_MAILBOX} === obj.{TARGET_MAILBOX})"

    CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT = f"EWS.Items(val.{ITEM_ID} == obj.{ATTACHMENT_ORIGINAL_ITEM_ID})"

    CONTEXT_UPDATE_ITEM_ATTACHMENT = f".ItemAttachments(val.{ATTACHMENT_ID} == obj.{ATTACHMENT_ID})"

    CONTEXT_UPDATE_FILE_ATTACHMENT = f".FileAttachments(val.{ATTACHMENT_ID} == obj.{ATTACHMENT_ID})"

    CONTEXT_UPDATE_FOLDER = f"EWS.Folders(val.{FOLDER_ID} == obj.{FOLDER_ID})"


    # fetch params

    LAST_RUN_TIME = "lastRunTime"

    LAST_RUN_IDS = "ids"

    LAST_RUN_FOLDER = "folderName"

    ERROR_COUNTER = "errorCounter"


    # Types of filter

    MODIFIED_FILTER = "modified-time"

    RECEIVED_FILTER = "received-time"


    # headers

    ITEMS_RESULTS_HEADERS = [
        "sender",
        "subject",
        "hasAttachments",
        "datetimeReceived",
        "receivedBy",
        "author",
        "toRecipients",
        "textBody",
    ]


    UTF_8 = 'utf-8'


    """ Classes """



    class ProxyAdapter(requests.adapters.HTTPAdapter):
        """
        Proxy Adapter used to add PROXY to requests
        """

        def send(self, *args, **kwargs):
            kwargs['proxies'] = handle_proxy()
            return super().send(*args, **kwargs)


    class InsecureProxyAdapter(NoVerifyHTTPAdapter):
        """
        Insecure Proxy Adapter used to add PROXY and INSECURE to requests
        NoVerifyHTTPAdapter is a built-in insecure HTTPAdapter class
        """

        def send(self, *args, **kwargs):
            kwargs['proxies'] = handle_proxy()
            return super().send(*args, **kwargs)


    class EWSClient:
        def __init__(
                self,
                default_target_mailbox,
                folder="Inbox",
                is_public_folder=False,
                request_timeout="120",
                max_fetch=MAX_INCIDENTS_PER_FETCH,
                self_deployed=True,
                insecure=True,
                proxy=False,
                **kwargs,
        ):
            """
            Client used to communicate with EWS
            :param default_target_mailbox: Email address from which to fetch incidents
            :param client_id: Application client ID
            :param client_secret: Application client secret
            :param folder: Name of the folder from which to fetch incidents
            :param is_public_folder: Public Folder flag
            :param request_timeout: Timeout (in seconds) for HTTP requests to Exchange Server
            :param max_fetch: Max incidents per fetch
            :param insecure: Trust any certificate (not secure)
            """

            client_id = kwargs.get('_client_id') or kwargs.get('client_id')
            tenant_id = kwargs.get('_tenant_id') or kwargs.get('tenant_id')
            client_secret = (kwargs.get('credentials') or {}).get('password') or kwargs.get('client_secret')
            access_type = kwargs.get('access_type', IMPERSONATION) or IMPERSONATION

            if not client_secret:
                raise Exception('Key / Application Secret must be provided.')
            elif not client_id:
                raise Exception('ID / Application ID must be provided.')
            elif not tenant_id:
                raise Exception('Token / Tenant ID must be provided.')

            BaseProtocol.TIMEOUT = int(request_timeout)
            self.ews_server = "https://outlook.office365.com/EWS/Exchange.asmx/"
            self.ms_client = MicrosoftClient(
                tenant_id=tenant_id,
                auth_id=client_id,
                enc_key=client_secret,
                app_name=APP_NAME,
                base_url=self.ews_server,
                verify=not insecure,
                proxy=proxy,
                self_deployed=self_deployed,
                scope="https://outlook.office.com/.default",
                command_prefix="ews",
            )
            self.folder_name = folder
            self.is_public_folder = is_public_folder
            self.access_type = (access_type[0] if isinstance(access_type, list) else access_type).lower()
            self.max_fetch = min(MAX_INCIDENTS_PER_FETCH, int(max_fetch))
            self.last_run_ids_queue_size = 500
            self.client_id = client_id
            self.client_secret = client_secret
            self.account_email = default_target_mailbox
            self.config = self.__prepare(insecure)
            self.protocol = BaseProtocol(self.config)
            self.mark_as_read = kwargs.get('mark_as_read', False)

        def __prepare(self, insecure):      # pragma: no cover
            """
            Prepares the client PROTOCOL, CREDENTIALS and CONFIGURATION
            :param insecure: Trust any certificate (not secure)
            :return: OAuth 2 Configuration
            """
            BaseProtocol.HTTP_ADAPTER_CLS = InsecureProxyAdapter if insecure else ProxyAdapter
            access_token = self.ms_client.get_access_token()
            oauth2_token = OAuth2Token({"access_token": access_token})
            self.credentials = credentials = OAuth2AuthorizationCodeCredentials(
                client_id=self.client_id,
                client_secret=self.client_secret,
                access_token=oauth2_token,
            )
            # need to add identity for protocol OAuth header
            self.credentials.identity = Identity(upn=self.account_email)
            config_args = {
                "credentials": credentials,
                "auth_type": OAUTH2,
                "version": Version(EXCHANGE_O365),
                "service_endpoint": "https://outlook.office365.com/EWS/Exchange.asmx",
            }

            return Configuration(**config_args)

        def get_account(self, target_mailbox=None):
            """
            Request an account from EWS
            :param (Optional) target_mailbox: Mailbox associated with the requested account
            :return: exchangelib Account
            """
            if not target_mailbox:
                target_mailbox = self.account_email
            return Account(
                primary_smtp_address=target_mailbox,
                autodiscover=False,
                config=self.config,
                access_type=self.access_type,
            )

        def get_items_from_mailbox(self, account, item_ids):     # pragma: no cover
            """
            Request specific items from a mailbox associated with an account
            :param account: EWS account or target_mailbox associated with that account
            :param item_ids: item_ids of the requested items
            :return: list of exchangelib Items
            """
            # allow user to pass target_mailbox as account
            account = self.get_account(account) if isinstance(account, str) else self.get_account(self.account_email)
            if type(item_ids) is not list:
                item_ids = [item_ids]
            items = [Item(id=x) for x in item_ids]
            result = list(account.fetch(ids=items))
            result = [x for x in result if not (isinstance(x, ErrorItemNotFound | ErrorInvalidIdMalformed))]
            if len(result) != len(item_ids):
                raise Exception("One or more items were not found/malformed. Check the input item ids")
            return result

        def get_item_from_mailbox(self, account, item_id):
            """
            Request a single item from a mailbox associated with an account
            :param account: EWS account or target_mailbox associated with that account
            :param item_id: item_id of the requested item
            :return: exchangelib Item
            """
            result = self.get_items_from_mailbox(account, [item_id])
            if len(result) == 0:
                raise Exception(f"ItemId {str(item_id)} not found")
            return result[0]

        def get_attachments_for_item(self, item_id, account, attachment_ids=None):     # pragma: no cover
            """
            Request attachments for an item
            :param item_id: item_id of the item to retrieve attachments from
            :param account: EWS account or target_mailbox associated with that account
            :param (Optional) attachment_ids: attachment_ids: attachment_ids to retrieve
            :return: list of exchangelib Item.attachments
            """
            item = self.get_item_from_mailbox(account, item_id)
            attachments = []
            attachment_ids = argToList(attachment_ids)
            if item:
                if item.attachments:
                    for attachment in item.attachments:
                        if (
                                attachment_ids
                                and attachment.attachment_id.id not in attachment_ids
                        ):
                            continue
                        attachments.append(attachment)

            else:
                raise Exception("Message item not found: " + item_id)

            if attachment_ids and len(attachments) < len(attachment_ids):
                raise Exception(
                    "Some attachment id did not found for message:" + str(attachment_ids)
                )

            return attachments

        def is_default_folder(self, folder_path, is_public=None):
            """
            Is the given folder_path public
            :param folder_path: folder path to check if is public
            :param is_public: (Optional) if provided, will return this value
            :return: Boolean
            """
            if is_public is not None:
                return is_public

            if folder_path == self.folder_name:
                return self.is_public_folder

            return False

        def get_folder_by_path(self, path, account=None, is_public=False):     # pragma: no cover
            """
            Retrieve folder by path
            :param path: path of the folder
            :param account: account associated with the requested path
            :param is_public: is the requested folder public
            :return: exchangelib Folder
            """
            if account is None:
                account = self.get_account()
            # handle exchange folder id
            if len(path) == FOLDER_ID_LEN:
                folders_map = account.root._folders_map
                if path in folders_map:
                    return account.root._folders_map[path]
            if is_public:
                folder_result = account.public_folders_root
            elif path == "AllItems":
                folder_result = account.root
            else:
                folder_result = account.inbox.parent  # Top of Information Store
            path = path.replace("/", "\\")
            path = path.split("\\")
            for sub_folder_name in path:
                folder_filter_by_name = [
                    x
                    for x in folder_result.children
                    if x.name.lower() == sub_folder_name.lower()
                ]
                if len(folder_filter_by_name) == 0:
                    raise Exception(f"No such folder {path}")
                folder_result = folder_filter_by_name[0]

            return folder_result

        def send_email(self, message: Message):
            account = self.get_account()
            message.account = account
            message.send_and_save()

        def reply_mail(self, inReplyTo, to, body, subject, bcc, cc, htmlBody, attachments):     # pragma: no cover
            account = self.get_account()
            item_to_reply_to = account.inbox.get(id=inReplyTo)  # pylint: disable=E1101
            if isinstance(item_to_reply_to, ErrorItemNotFound):
                raise Exception(item_to_reply_to)

            subject = subject or item_to_reply_to.subject
            message_body = HTMLBody(htmlBody) if htmlBody else body
            reply = item_to_reply_to.create_reply(subject='Re: ' + subject, body=message_body, to_recipients=to,
                                                  cc_recipients=cc,
                                                  bcc_recipients=bcc)
            reply = reply.save(account.drafts)
            m = account.inbox.get(id=reply.id)  # pylint: disable=E1101

            for attachment in attachments:
                if not attachment.get('cid'):
                    new_attachment = FileAttachment(name=attachment.get('name'), content=attachment.get('data'))
                else:
                    new_attachment = FileAttachment(name=attachment.get('name'), content=attachment.get('data'),
                                                    is_inline=True, content_id=attachment.get('cid'))
                m.attach(new_attachment)
            m.send()

            return m


    class MarkAsJunk(EWSAccountService):
        """
        EWSAccountService class used for marking items as junk
        """
        SERVICE_NAME = "MarkAsJunk"

        def call(self, item_id, move_item):
            elements = list(
                self._get_elements(
                    payload=self.get_payload(item_id=item_id, move_item=move_item)
                )
            )
            for element in elements:
                if isinstance(element, ResponseMessageError):
                    return str(element)
            return "Success"

        def get_payload(self, item_id, move_item):     # pragma: no cover
            junk = create_element(
                f"m:{self.SERVICE_NAME}",
                {"IsJunk": "true", "MoveItem": "true" if move_item else "false"},
            )

            items_list = create_element("m:ItemIds")
            item_element = create_element("t:ItemId", {"Id": item_id})
            items_list.append(item_element)
            junk.append(items_list)

            return junk


    class GetSearchableMailboxes(EWSService):
        """
        EWSAccountService class used for getting Searchable Mailboxes
        """
        SERVICE_NAME = "GetSearchableMailboxes"
        element_container_name = f"{{{MNS}}}SearchableMailboxes"

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find(f"{{{TNS}}}PrimarySmtpAddress").text
                if element.find(f"{{{TNS}}}PrimarySmtpAddress") is not None
                else None,
                MAILBOX_ID: element.find(f"{{{TNS}}}ReferenceId").text
                if element.find(f"{{{TNS}}}ReferenceId") is not None
                else None,
                "displayName": element.find(f"{{{TNS}}}DisplayName").text
                if element.find(f"{{{TNS}}}DisplayName") is not None
                else None,
                "isExternal": element.find(f"{{{TNS}}}IsExternalMailbox").text
                if element.find(f"{{{TNS}}}IsExternalMailbox") is not None
                else None,
                "externalEmailAddress": element.find(f"{{{TNS}}}ExternalEmailAddress").text
                if element.find(f"{{{TNS}}}ExternalEmailAddress") is not None
                else None,
            }

        def call(self):
            elements = self._get_elements(payload=self.get_payload())
            return [
                self.parse_element(x)
                for x in elements
                if x.find(f"{{{TNS}}}ReferenceId").text
            ]

        def get_payload(self):
            element = create_element(f"m:{self.SERVICE_NAME}")
            return element


    class ExpandGroup(EWSService):
        """
        EWSAccountService class used for expanding groups
        """
        SERVICE_NAME = "ExpandDL"
        element_container_name = f"{{{MNS}}}DLExpansion"

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find(f"{{{TNS}}}EmailAddress").text
                if element.find(f"{{{TNS}}}EmailAddress") is not None
                else None,
                "displayName": element.find(f"{{{TNS}}}Name").text
                if element.find(f"{{{TNS}}}Name") is not None
                else None,
                "mailboxType": element.find(f"{{{TNS}}}MailboxType").text
                if element.find(f"{{{TNS}}}MailboxType") is not None
                else None,
            }

        def call(self, email_address, recursive_expansion=False):      # pragma: no cover
            demisto.info('Started call function')
            try:
                if recursive_expansion == "True":
                    group_members: dict = {}
                    self.expand_group_recursive(email_address, group_members)
                    return list(group_members.values())
                else:
                    return self.expand_group(email_address)
            except ErrorNameResolutionNoResults as e:
                demisto.results(f"No results were found. error message: {e}")
                sys.exit()

        def get_payload(self, email_address):
            element = create_element(f"m:{self.SERVICE_NAME}")
            mailbox_element = create_element("m:Mailbox")
            add_xml_child(mailbox_element, "t:EmailAddress", email_address)
            element.append(mailbox_element)
            return element

        def expand_group(self, email_address):
            """
            Expand given group
            :param email_address: email address of the group to expand
            :return: list dict with parsed expanded group data
            """
            demisto.info(f'Started expand_group with email_address: {email_address}')
            elements = self._get_elements(payload=self.get_payload(email_address))
            return [self.parse_element(x) for x in elements]

        def expand_group_recursive(self, email_address, non_dl_emails, dl_emails=None):     # pragma: no cover
            """
            Expand group recursively
            :param email_address: email address of the group to expand
            :param non_dl_emails: non distribution only emails
            :param dl_emails: (Optional) distribution only emails
            :return: Set of dl emails and non dl emails (returned via reference)
            """
            demisto.info(f'Started expand_group_recursive with email_address: {email_address}')
            if dl_emails is None:
                dl_emails = set()
            if email_address in non_dl_emails or email_address in dl_emails:
                return
            dl_emails.add(email_address)

            for member in self.expand_group(email_address):
                if (
                        member["mailboxType"] == "PublicDL"
                        or member["mailboxType"] == "PrivateDL"
                ):
                    self.expand_group_recursive(member.get("mailbox"), non_dl_emails, dl_emails)
                else:
                    if member["mailbox"] not in non_dl_emails:
                        non_dl_emails[member["mailbox"]] = member


    # If you are modifying this probably also need to modify in other files

    def exchangelib_cleanup():     # pragma: no cover
        key_protocols = list(exchangelib.protocol.CachingProtocol._protocol_cache.items())
        try:
            exchangelib.close_connections()
        except Exception as ex:
            demisto.error(f"Error was found in exchangelib cleanup, ignoring: {ex}")
        for key, (protocol, _) in key_protocols:
            try:
                if "thread_pool" in protocol.__dict__:
                    demisto.debug(
                        "terminating thread pool key{} id: {}".format(
                            key, id(protocol.thread_pool)
                        )
                    )
                    protocol.thread_pool.terminate()
                    del protocol.__dict__["thread_pool"]
                else:
                    demisto.info(
                        "Thread pool not found (ignoring terminate) in protcol dict: {}".format(
                            dir(protocol.__dict__)
                        )
                    )
            except Exception as ex:
                demisto.error(f"Error with thread_pool.terminate, ignoring: {ex}")


    """ LOGGING """


    log_stream = None

    log_handler = None



    def start_logging():
        global log_stream
        global log_handler
        logging.raiseExceptions = False
        if log_stream is None:
            log_stream = StringIO()
            log_handler = logging.StreamHandler(stream=log_stream)
            log_handler.setFormatter(logging.Formatter(logging.BASIC_FORMAT))
            logger = logging.getLogger()
            logger.addHandler(log_handler)
            logger.setLevel(logging.DEBUG)


    """ Helper Functions """



    def get_attachment_name(attachment_name, eml_extension=False):
        """
        Retrieve attachment name or error string if none is provided
        :param attachment_name: attachment name to retrieve
        :param eml_extension: Indicates whether the eml extension should be added
        :return: string
        """
        if attachment_name is None or attachment_name == "":
            return "demisto_untitled_attachment.eml" if eml_extension else "demisto_untitled_attachment"
        elif eml_extension and not attachment_name.endswith(".eml"):
            return f'{attachment_name}.eml'
        return attachment_name


    def get_entry_for_object(title, context_key, obj, headers=None):
        """
        Create an entry for a given object
        :param title: Title of the human readable
        :param context_key: Context key used for entry context
        :param obj: Object to create entry for
        :param headers: (Optional) headers used in the tableToMarkDown
        :return: Entry object to be used with demisto.results()
        """
        if len(obj) == 0:
            return "There is no output results"
        if headers and isinstance(obj, dict):
            headers = list(set(headers).intersection(set(obj.keys())))

        return {
            "Type": entryTypes["note"],
            "Contents": obj,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown(title, obj, headers),
            "EntryContext": {context_key: obj},
        }


    def prepare_args(args):
        """
        Prepare arguments to be used as the API expects it
        :param args: demisto args
        :return: transformed args
        """
        args = {k.replace("-", "_"): v for k, v in list(args.items())}
        if "is_public" in args:
            args["is_public"] = args["is_public"] == "True"
        if "from" in args:
            args['from_address'] = args.pop('from')
        return args


    def get_limited_number_of_messages_from_qs(qs, limit):      # pragma: no cover
        """
        Retrieve a limited number of messages from query search
        :param qs: query search to execute
        :param limit: limit on number of items to retrieve from search
        :return: list of exchangelib.Message
        """
        count = 0
        results = []
        for item in qs:
            if count == limit:
                break
            if isinstance(item, Message):
                count += 1
                results.append(item)
        return results


    def keys_to_camel_case(value):     # pragma: no cover
        """
        Transform keys from snake to camel case (does nothing if no snakes are found)
        :param value: value to transform
        :return: transformed value
        """

        def str_to_camel_case(snake_str):
            components = snake_str.split("_")
            return components[0] + "".join(x.title() for x in components[1:])

        if value is None:
            return None
        if isinstance(value, list | set):
            return list(map(keys_to_camel_case, value))
        if isinstance(value, dict):
            return {
                keys_to_camel_case(k): keys_to_camel_case(v) if isinstance(v, list | dict) else v
                for (k, v) in list(value.items())
            }

        return str_to_camel_case(value)


    def get_last_run(client: EWSClient, last_run=None):
        """
        Retrieve the last run time
        :param client: EWS Client
        :param last_run: (Optional) last run object
        :return: last run dict
        """
        if not last_run or last_run.get(LAST_RUN_FOLDER) != client.folder_name:
            last_run = {
                LAST_RUN_TIME: None,
                LAST_RUN_FOLDER: client.folder_name,
                LAST_RUN_IDS: [],
            }
        if LAST_RUN_TIME in last_run and last_run[LAST_RUN_TIME] is not None:
            last_run[LAST_RUN_TIME] = EWSDateTime.from_string(last_run[LAST_RUN_TIME])

        # In case we have existing last_run data
        if last_run.get(LAST_RUN_IDS) is None:
            last_run[LAST_RUN_IDS] = []

        return last_run


    def email_ec(item):
        """
        Create entry context for an email
        :param item: exchangelib.Item
        :return: entry context dict
        """
        return {
            "CC": None
            if not item.cc_recipients
            else [mailbox.email_address for mailbox in item.cc_recipients],
            "BCC": None
            if not item.bcc_recipients
            else [mailbox.email_address for mailbox in item.bcc_recipients],
            "To": None
            if not item.to_recipients
            else [mailbox.email_address for mailbox in item.to_recipients],
            "From": item.author.email_address,
            "Subject": item.subject,
            "Text": item.text_body,
            "HTML": item.body,
            "HeadersMap": {header.name: header.value for header in item.headers},
        }


    def parse_item_as_dict(item, email_address=None, camel_case=False, compact_fields=False):     # pragma: no cover
        """
        Parses an exchangelib item as a dict
        :param item: exchangelib.Item to parse
        :param (Optional) email_address: string mailbox
        :param (Optional) camel_case: Is camel case
        :param (Optional) compact_fields: Is compact fields
        :return: Item as a dict
        """

        def parse_object_as_dict(obj):
            raw_dict = {}
            if obj is not None:
                for field in obj.FIELDS:
                    raw_dict[field.name] = getattr(obj, field.name, None)
            return raw_dict

        def parse_folder_as_json(folder):     # pragma: no cover
            raw_dict = parse_object_as_dict(folder)
            if "parent_folder_id" in raw_dict:
                raw_dict["parent_folder_id"] = parse_folder_as_json(
                    raw_dict["parent_folder_id"]
                )
            if "effective_rights" in raw_dict:
                raw_dict["effective_rights"] = parse_object_as_dict(
                    raw_dict["effective_rights"]
                )
            return raw_dict

        raw_dict = {}
        for field, value in item._field_vals():
            if type(value) in [str, str, int, float, bool, Body, HTMLBody, None]:
                raw_dict[field] = value
        raw_dict["id"] = item.id
        demisto.debug(f"checking for attachments in email with id {item.id}")
        log_memory()
        if getattr(item, "attachments", None):
            raw_dict["attachments"] = [
                parse_attachment_as_dict(item.id, x) for x in item.attachments
            ]

        for time_field in [
            "datetime_sent",
            "datetime_created",
            "datetime_received",
            "last_modified_time",
            "reminder_due_by",
        ]:
            value = getattr(item, time_field, None)
            if value:
                raw_dict[time_field] = value.ewsformat()

        for dict_field in [
            "effective_rights",
            "parent_folder_id",
            "conversation_id",
            "author",
            "extern_id",
            "received_by",
            "received_representing",
            "reply_to",
            "sender",
            "folder",
        ]:
            value = getattr(item, dict_field, None)
            if value:
                if isinstance(value, list):
                    raw_dict[dict_field] = []
                    for single_val in value:
                        raw_dict[dict_field].append(parse_object_as_dict(single_val))
                else:
                    raw_dict[dict_field] = parse_object_as_dict(value)

        for list_dict_field in ["headers", "cc_recipients", "to_recipients"]:
            value = getattr(item, list_dict_field, None)
            if value:
                raw_dict[list_dict_field] = [parse_object_as_dict(x) for x in value]

        for list_str_field in ["categories"]:
            value = getattr(item, list_str_field, None)
            if value:
                raw_dict[list_str_field] = value

        if getattr(item, "folder", None):
            raw_dict["folder"] = parse_folder_as_json(item.folder)
            folder_path = (
                item.folder.absolute[len(TOIS_PATH):]
                if item.folder.absolute.startswith(TOIS_PATH)
                else item.folder.absolute
            )
            raw_dict["folder_path"] = folder_path

        if compact_fields:
            new_dict = {}
            # noinspection PyListCreation
            fields_list = [
                "datetime_created",
                "datetime_received",
                "datetime_sent",
                "sender",
                "has_attachments",
                "importance",
                "message_id",
                "last_modified_time",
                "size",
                "subject",
                "text_body",
                "headers",
                "body",
                "folder_path",
                "is_read",
                "categories"
            ]

            if "id" in raw_dict:
                new_dict["itemId"] = raw_dict["id"]
                fields_list.append("itemId")

            for field in fields_list:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field)
            for field in ["received_by", "author", "sender"]:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field, {}).get("email_address")
            for field in ["to_recipients"]:
                if field in raw_dict:
                    new_dict[field] = [x.get("email_address") for x in raw_dict[field]]
            attachments = raw_dict.get("attachments")
            if attachments and len(attachments) > 0:
                file_attachments = [
                    x for x in attachments if x[ATTACHMENT_TYPE] == FILE_ATTACHMENT_TYPE
                ]
                if len(file_attachments) > 0:
                    new_dict["FileAttachments"] = file_attachments
                item_attachments = [
                    x for x in attachments if x[ATTACHMENT_TYPE] == ITEM_ATTACHMENT_TYPE
                ]
                if len(item_attachments) > 0:
                    new_dict["ItemAttachments"] = item_attachments

            raw_dict = new_dict

        if camel_case:
            raw_dict = keys_to_camel_case(raw_dict)

        if email_address:
            raw_dict[MAILBOX] = email_address
        return raw_dict


    def get_entry_for_file_attachment(item_id, attachment):
        """
        Creates a file entry for an attachment
        :param item_id: item_id of the attachment
        :param attachment: attachment dict
        :return: file entry dict for attachment
        """
        entry = fileResult(get_attachment_name(attachment.name), attachment.content)
        entry["EntryContext"] = {
            CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT
            + CONTEXT_UPDATE_FILE_ATTACHMENT: parse_attachment_as_dict(item_id, attachment)
        }
        return entry


    def parse_attachment_as_dict(item_id, attachment):
        """
        Creates a note entry for an attachment
        :param item_id: item_id of the attachment
        :param attachment: attachment dict
        :return: note entry dict for attachment
        """
        try:
            attachment_content = (
                attachment.content
                if isinstance(attachment, FileAttachment)
                else attachment.item.mime_content
            )
            if isinstance(attachment_content, str):  # Strings must be encoded before hashing
                attachment_content = attachment_content.encode()
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                "attachmentName": get_attachment_name(attachment.name),
                "attachmentSHA256": hashlib.sha256(attachment_content).hexdigest()
                if attachment_content
                else None,
                "attachmentContentType": attachment.content_type,
                "attachmentContentId": attachment.content_id,
                "attachmentContentLocation": attachment.content_location,
                "attachmentSize": attachment.size,
                "attachmentLastModifiedTime": attachment.last_modified_time.ewsformat(),
                "attachmentIsInline": attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE
                if isinstance(attachment, FileAttachment)
                else ITEM_ATTACHMENT_TYPE,
            }
        except TypeError as e:
            if str(e) != "must be string or buffer, not None":
                raise
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                "attachmentName": get_attachment_name(attachment.name),
                "attachmentSHA256": None,
                "attachmentContentType": attachment.content_type,
                "attachmentContentId": attachment.content_id,
                "attachmentContentLocation": attachment.content_location,
                "attachmentSize": attachment.size,
                "attachmentLastModifiedTime": attachment.last_modified_time.ewsformat(),
                "attachmentIsInline": attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE
                if isinstance(attachment, FileAttachment)
                else ITEM_ATTACHMENT_TYPE,
            }


    def get_entry_for_item_attachment(item_id, attachment, target_email):      # pragma: no cover
        """
        Creates a note entry for an item attachment
        :param item_id: Item id
        :param attachment: exchangelib attachment
        :param target_email: target email
        :return: note entry dict for item attachment
        """
        item = attachment.item
        dict_result = parse_attachment_as_dict(item_id, attachment)
        dict_result.update(
            parse_item_as_dict(item, target_email, camel_case=True, compact_fields=True)
        )
        title = f'EWS get attachment got item for "{target_email}", "{get_attachment_name(attachment.name)}"'

        return get_entry_for_object(
            title,
            CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_ITEM_ATTACHMENT,
            dict_result,
        )


    """ Command Functions """



    def get_expanded_group(client: EWSClient, email_address, recursive_expansion=False):
        """
        Retrieve expanded group command
        :param client: EWS Client
        :param email_address: Email address of the group to expand
        :param (Optional) recursive_expansion: Whether to enable recursive expansion. Default is "False".
        :return: Expanded groups output tuple
        """
        demisto.info('Starting get_expanded_group command')
        group_members = ExpandGroup(protocol=client.protocol).call(
            email_address, recursive_expansion
        )
        group_details = {"name": email_address, "members": group_members}
        output = {"EWS.ExpandGroup": group_details}
        readable_output = tableToMarkdown("Group Members", group_members)
        return readable_output, output, group_details


    def get_searchable_mailboxes(client: EWSClient):
        """
        Retrieve searchable mailboxes command
        :param client: EWS Client
        :return: Searchable mailboxes output tuple
        """
        searchable_mailboxes = GetSearchableMailboxes(protocol=client.protocol).call()
        readable_output = tableToMarkdown(
            "Searchable mailboxes", searchable_mailboxes, headers=["displayName", "mailbox"]
        )
        output = {"EWS.Mailboxes": searchable_mailboxes}
        return readable_output, output, searchable_mailboxes


    def delete_attachments_for_message(
            client: EWSClient, item_id, target_mailbox=None, attachment_ids=None
    ):     # pragma: no cover
        """
        Deletes attachments for a given message
        :param client: EWS Client
        :param item_id: item id
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) attachment_ids: attachment ids to delete
        :return: entries that were delted
        """
        attachments = client.get_attachments_for_item(
            item_id, target_mailbox, attachment_ids
        )
        deleted_file_attachments = []
        deleted_item_attachments = []  # type: ignore
        for attachment in attachments:
            attachment_deleted_action = {
                ATTACHMENT_ID: attachment.attachment_id.id,
                ACTION: "deleted",
            }
            if isinstance(attachment, FileAttachment):
                deleted_file_attachments.append(attachment_deleted_action)
            else:
                deleted_item_attachments.append(attachment_deleted_action)
            attachment.detach()

        entries = []
        if len(deleted_file_attachments) > 0:
            entry = get_entry_for_object(
                "Deleted file attachments",
                "EWS.Items" + CONTEXT_UPDATE_FILE_ATTACHMENT,
                deleted_file_attachments,
            )
            entries.append(entry)
        if len(deleted_item_attachments) > 0:
            entry = get_entry_for_object(
                "Deleted item attachments",
                "EWS.Items" + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                deleted_item_attachments,
            )
            entries.append(entry)

        return entries


    def fetch_attachments_for_message(
            client: EWSClient, item_id, target_mailbox=None, attachment_ids=None
    ):     # pragma: no cover
        """
        Fetches attachments for a message
        :param client: EWS Client
        :param item_id: item id
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) attachment_ids: attachment ids
        :return: list of parsed entries
        """
        account = client.get_account(target_mailbox)
        attachments = client.get_attachments_for_item(item_id, account, attachment_ids)
        entries = []
        for attachment in attachments:
            if isinstance(attachment, FileAttachment):
                try:
                    if attachment.content:
                        entries.append(get_entry_for_file_attachment(item_id, attachment))
                except TypeError as e:
                    if str(e) != "must be string or buffer, not None":
                        raise
            else:
                entries.append(
                    get_entry_for_item_attachment(
                        item_id, attachment, account.primary_smtp_address
                    )
                )
                if attachment.item.mime_content:
                    entries.append(
                        fileResult(
                            get_attachment_name(attachment.name, eml_extension=True),
                            attachment.item.mime_content,
                        )
                    )

        return entries


    def move_item_between_mailboxes(
            client: EWSClient,
            item_id,
            destination_mailbox,
            destination_folder_path,
            source_mailbox=None,
            is_public=None,
    ):     # pragma: no cover
        """
        Moves item between mailboxes
        :param client: EWS Client
        :param item_id: item id
        :param destination_mailbox: destination mailbox
        :param destination_folder_path: destination folder path
        :param (Optional) source_mailbox: source mailbox
        :param (Optional) is_public: is the destination folder public
        :return: Output tuple
        """
        source_account = client.get_account(source_mailbox)
        destination_account = client.get_account(destination_mailbox)
        is_public = client.is_default_folder(destination_folder_path, is_public)
        destination_folder = client.get_folder_by_path(
            destination_folder_path, destination_account, is_public
        )
        item = client.get_item_from_mailbox(source_account, item_id)
        exported_items = source_account.export([item])
        destination_account.upload([(destination_folder, exported_items[0])])
        source_account.bulk_delete([item])
        move_result = {
            MOVED_TO_MAILBOX: destination_mailbox,
            MOVED_TO_FOLDER: destination_folder_path,
        }
        readable_output = "Item was moved successfully."
        output = {f"EWS.Items(val.itemId === '{item_id}')": move_result}
        return readable_output, output, move_result


    def move_item(
            client: EWSClient, item_id, target_folder_path, target_mailbox=None, is_public=None
    ):     # pragma: no cover
        """
        Moves an item within the same mailbox
        :param client: EWS Client
        :param item_id: item id
        :param target_folder_path: target folder path
        :param (Optional) target_mailbox: mailbox containing the item
        :param (Optional) is_public: is the destination folder public
        :return: Output tuple
        """
        account = client.get_account(target_mailbox)
        is_public = client.is_default_folder(target_folder_path, is_public)
        target_folder = client.get_folder_by_path(target_folder_path, is_public=is_public)
        item = client.get_item_from_mailbox(account, item_id)
        if isinstance(item, ErrorInvalidIdMalformed):
            raise Exception("Item not found")
        item.move(target_folder)
        move_result = {
            NEW_ITEM_ID: item.id,
            ITEM_ID: item_id,
            MESSAGE_ID: item.message_id,
            ACTION: "moved",
        }
        readable_output = tableToMarkdown("Moved items", move_result)
        output = {CONTEXT_UPDATE_EWS_ITEM: move_result}
        return readable_output, output, move_result


    def delete_items(client: EWSClient, item_ids, delete_type, target_mailbox=None):     # pragma: no cover
        """
        Delete items in a mailbox
        :param client: EWS Client
        :param item_ids: items ids to delete
        :param delete_type: delte type soft/hard
        :param (Optional) target_mailbox: mailbox containinf the items
        :return: Output tuple
        """
        deleted_items = []
        item_ids = argToList(item_ids)
        items = client.get_items_from_mailbox(target_mailbox, item_ids)
        delete_type = delete_type.lower()

        for item in items:
            item_id = item.id
            if delete_type == "trash":
                item.move_to_trash()
            elif delete_type == "soft":
                item.soft_delete()
            elif delete_type == "hard":
                item.delete()
            else:
                raise Exception(
                    f'invalid delete type: {delete_type}. Use "trash" \\ "soft" \\ "hard"'
                )
            deleted_items.append(
                {
                    ITEM_ID: item_id,
                    MESSAGE_ID: item.message_id,
                    ACTION: f"{delete_type}-deleted",
                }
            )

        readable_output = tableToMarkdown(
            f"Deleted items ({delete_type} delete type)", deleted_items
        )
        output = {CONTEXT_UPDATE_EWS_ITEM: deleted_items}
        return readable_output, output, deleted_items


    def search_items_in_mailbox(
            client: EWSClient,
            query=None,
            message_id=None,
            folder_path="",
            limit=100,
            target_mailbox=None,
            is_public=None,
            selected_fields="all",
    ):     # pragma: no cover
        """
        Search items in mailbox
        :param client: EWS Client
        :param (Optional) query: query to execute
        :param (Optional) message_id: message ids to search
        :param (Optional) folder_path: folder path to search
        :param (Optional) limit: max amount of items to fetch
        :param (Optional) target_mailbox: mailbox containing the items
        :param (Optional) is_public: is the targeted folder public
        :param (Optional) selected_fields: Selected fields
        :return: Output tuple
        """
        if not query and not message_id:
            return_error("Missing required argument. Provide query or message-id")

        if message_id and message_id[0] != "<" and message_id[-1] != ">":
            message_id = f"<{message_id}>"

        account = client.get_account(target_mailbox)
        limit = int(limit)
        if folder_path.lower() == "inbox":
            folders = [account.inbox]
        elif folder_path:
            is_public = client.is_default_folder(folder_path, is_public)
            folders = [client.get_folder_by_path(folder_path, account, is_public)]
        else:
            folders = account.inbox.parent.walk()  # pylint: disable=E1101

        items = []  # type: ignore
        selected_all_fields = selected_fields == "all"

        if selected_all_fields:
            restricted_fields = [x.name for x in Message.FIELDS]
        else:
            restricted_fields = set(argToList(selected_fields))  # type: ignore
            restricted_fields.update(["id", "message_id"])  # type: ignore

        for folder in folders:
            if Message not in folder.supported_item_models:
                continue
            if query:
                items_qs = folder.filter(query).only(*restricted_fields)
            else:
                items_qs = folder.filter(message_id=message_id).only(*restricted_fields)
            items += get_limited_number_of_messages_from_qs(items_qs, limit)
            if len(items) >= limit:
                break

        items = items[:limit]
        searched_items_result = [
            parse_item_as_dict(
                item,
                account.primary_smtp_address,
                camel_case=True,
                compact_fields=selected_all_fields,
            )
            for item in items
        ]

        if not selected_all_fields:
            searched_items_result = [
                {k: v for (k, v) in i.items() if k in keys_to_camel_case(restricted_fields)}
                for i in searched_items_result
            ]

            for item in searched_items_result:
                item["itemId"] = item.pop("id", "")

        readable_output = tableToMarkdown(
            "Searched items",
            searched_items_result,
            headers=ITEMS_RESULTS_HEADERS if selected_all_fields else None,
        )
        output = {CONTEXT_UPDATE_EWS_ITEM: searched_items_result}
        return readable_output, output, searched_items_result


    def get_out_of_office_state(client: EWSClient, target_mailbox=None):      # pragma: no cover
        """
        Retrieve get out of office state of the targeted mailbox
        :param client: EWS Client
        :param (Optional) target_mailbox: target mailbox
        :return: Output tuple
        """
        account = client.get_account(target_mailbox)
        oof = account.oof_settings
        oof_dict = {
            "state": oof.state,  # pylint: disable=E1101
            "externalAudience": getattr(oof, "external_audience", None),
            "start": oof.start.ewsformat() if oof.start else None,  # pylint: disable=E1101
            "end": oof.end.ewsformat() if oof.end else None,  # pylint: disable=E1101
            "internalReply": getattr(oof, "internal_replay", None),
            "externalReply": getattr(oof, "external_replay", None),
            MAILBOX: account.primary_smtp_address,
        }
        readable_output = tableToMarkdown(
            f"Out of office state for {account.primary_smtp_address}", oof_dict
        )
        output = {f"Account.Email(val.Address == obj.{MAILBOX}).OutOfOffice": oof_dict}
        return readable_output, output, oof_dict


    def recover_soft_delete_item(
            client: EWSClient,
            message_ids,
            target_folder_path="Inbox",
            target_mailbox=None,
            is_public=None,
    ):     # pragma: no cover
        """
        Recovers soft deleted items
        :param client: EWS Client
        :param message_ids: Message ids to recover
        :param (Optional) target_folder_path: target folder path
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) is_public: is the target folder public
        :return:
        """
        account = client.get_account(target_mailbox)
        is_public = client.is_default_folder(target_folder_path, is_public)
        target_folder = client.get_folder_by_path(target_folder_path, account, is_public)
        recovered_messages = []
        message_ids = argToList(message_ids)

        items_to_recover = account.recoverable_items_deletions.filter(  # pylint: disable=E1101
            message_id__in=message_ids
        ).all()  # pylint: disable=E1101

        recovered_items = set()
        for item in items_to_recover:
            recovered_items.add(item)
        if len(recovered_items) != len(message_ids):
            missing_items = set(message_ids).difference(recovered_items)
            raise Exception(
                f"Some message ids are missing in recoverable items directory: {missing_items}"
            )

        for item in recovered_items:
            item.move(target_folder)
            recovered_messages.append(
                {ITEM_ID: item.id, MESSAGE_ID: item.message_id, ACTION: "recovered"}
            )

        readable_output = tableToMarkdown("Recovered messages", recovered_messages)
        output = {CONTEXT_UPDATE_EWS_ITEM: recovered_messages}
        return readable_output, output, recovered_messages


    def get_contacts(client: EWSClient, limit, target_mailbox=None):     # pragma: no cover
        """
        Retrieve contacts of the target mailbox or client mailbox
        :param client: EWS Client
        :param limit: max amount of contacts to retrieve
        :param (Optional) target_mailbox: Target mailbox
        :return:
        """

        def parse_physical_address(address):
            result = {}
            for attr in ["city", "country", "label", "state", "street", "zipcode"]:
                result[attr] = getattr(address, attr, None)
            return result

        def parse_phone_number(phone_number):
            result = {}
            for attr in ["label", "phone_number"]:
                result[attr] = getattr(phone_number, attr, None)
            return result

        def parse_contact(contact):
            contact_dict = {
                k: v if not isinstance(v, EWSDateTime) else v.ewsformat()
                for k, v in list(contact._field_vals())
                if isinstance(v, str | EWSDateTime)
            }
            if isinstance(contact, Contact) and contact.physical_addresses:
                contact_dict["physical_addresses"] = list(
                    map(parse_physical_address, contact.physical_addresses)
                )
            if isinstance(contact, Contact) and contact.phone_numbers:
                contact_dict["phone_numbers"] = list(
                    map(parse_phone_number, contact.phone_numbers)
                )
            if (
                    isinstance(contact, Contact)
                    and contact.email_addresses
                    and len(contact.email_addresses) > 0
            ):
                contact_dict["emailAddresses"] = [x.email for x in contact.email_addresses]
            contact_dict = keys_to_camel_case(contact_dict)
            contact_dict = {k: v for k, v in list(contact_dict.items()) if v}
            contact_dict.pop("mimeContent", None)
            contact_dict["originMailbox"] = target_mailbox
            return contact_dict

        account = client.get_account(target_mailbox)
        contacts = []

        for contact in account.contacts.all()[: int(limit)]:  # pylint: disable=E1101
            contacts.append(parse_contact(contact))
        readable_output = tableToMarkdown(f"Email contacts for {target_mailbox}", contacts)
        output = {"Account.Email(val.Address == obj.originMailbox).EwsContacts": contacts}
        return readable_output, output, contacts


    def create_folder(client: EWSClient, new_folder_name, folder_path, target_mailbox=None):     # pragma: no cover
        """
        Creates a folder in the target mailbox or the client mailbox
        :param client: EWS Client
        :param new_folder_name: new folder name
        :param folder_path: path of the new folder
        :param (Optional) target_mailbox: target mailbox
        :return: Output tuple
        """
        account = client.get_account(target_mailbox)
        full_path = os.path.join(folder_path, new_folder_name)
        try:
            if client.get_folder_by_path(full_path, account):
                return f"Folder {full_path} already exists",
        except Exception:
            pass
        parent_folder = client.get_folder_by_path(folder_path, account)
        f = Folder(parent=parent_folder, name=new_folder_name)
        f.save()
        client.get_folder_by_path(full_path, account)
        return f"Folder {full_path} created successfully",


    def find_folders(client: EWSClient, target_mailbox=None):
        """
        Finds folders in the mailbox
        :param client: EWS Client
        :param (Optional) target_mailbox: target mailbox
        :return: Output tuple
        """
        account = client.get_account(target_mailbox)
        root = account.root
        if client.is_public_folder:
            root = account.public_folders_root
        folders = []
        for f in root.walk():  # pylint: disable=E1101
            folder = folder_to_context_entry(f)
            folders.append(folder)
        folders_tree = root.tree()  # pylint: disable=E1101
        readable_output = folders_tree
        output = {"EWS.Folders(val.id == obj.id)": folders}
        return readable_output, output, folders


    def mark_item_as_junk(client: EWSClient, item_id, move_items, target_mailbox=None):     # pragma: no cover
        """
        Marks item as junk in the target mailbox or client mailbox
        :param client: EWS Client
        :param item_id: item ids to mark as junk
        :param move_items: "yes" or "no" - to move or not to move to trash
        :param (Optional) target_mailbox: target mailbox
        :return:
        """
        account = client.get_account(target_mailbox)
        move_items = move_items.lower() == "yes"
        ews_result = MarkAsJunk(account=account).call(item_id=item_id, move_item=move_items)
        mark_as_junk_result = {
            ITEM_ID: item_id,
        }
        if ews_result == "Success":
            mark_as_junk_result[ACTION] = "marked-as-junk"
        else:
            raise Exception("Failed mark-item-as-junk with error: " + ews_result)

        readable_output = tableToMarkdown("Mark item as junk", mark_as_junk_result)
        output = {CONTEXT_UPDATE_EWS_ITEM: mark_as_junk_result}
        return readable_output, output, mark_as_junk_result


    def get_items_from_folder(
            client: EWSClient,
            folder_path,
            limit=100,
            target_mailbox=None,
            is_public=None,
            get_internal_item="no",
    ):     # pragma: no cover
        """
        Retrieve items from folder path
        :param client: EWS Client
        :param folder_path: folder path
        :param (Optional) limit: max amount of items to retrieve
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) is_public: is the folder public
        :param (Optional) get_internal_item: should also retrieve internal items ("no" by default)
        :return: Output tuple
        """
        account = client.get_account(target_mailbox)
        limit = int(limit)
        get_internal_item = get_internal_item == "yes"
        is_public = client.is_default_folder(folder_path, is_public)
        folder = client.get_folder_by_path(folder_path, account, is_public)
        qs = folder.filter().order_by("-datetime_created")[:limit]
        items = get_limited_number_of_messages_from_qs(qs, limit)
        items_result = []

        for item in items:
            item_attachment = parse_item_as_dict(
                item, account.primary_smtp_address, camel_case=True, compact_fields=True
            )
            for attachment in item.attachments:
                if (
                        get_internal_item
                        and isinstance(attachment, ItemAttachment)
                        and isinstance(attachment.item, Message)
                ):
                    # if found item attachment - switch item to the attchment
                    item_attachment = parse_item_as_dict(
                        attachment.item,
                        account.primary_smtp_address,
                        camel_case=True,
                        compact_fields=True,
                    )
                    break
            items_result.append(item_attachment)

        hm_headers = [
            "sender",
            "subject",
            "hasAttachments",
            "datetimeReceived",
            "receivedBy",
            "author",
            "toRecipients",
            "itemId",
        ]
        readable_output = tableToMarkdown(
            "Items in folder " + folder_path, items_result, headers=hm_headers
        )
        output = {CONTEXT_UPDATE_EWS_ITEM: items_result}
        return readable_output, output, items_result


    def get_items(client: EWSClient, item_ids, target_mailbox=None):     # pragma: no cover
        """
        Get items from target mailbox or client mailbox
        :param client: EWS Client
        :param item_ids: item ids to retrieve
        :param (Optional) target_mailbox: target mailbox to retrieve items from
        :return:
        """
        item_ids = argToList(item_ids)
        account = client.get_account(target_mailbox)
        items = client.get_items_from_mailbox(account, item_ids)
        items = [x for x in items if isinstance(x, Message)]
        items_as_incidents = [parse_incident_from_item(x) for x in items]
        items_to_context = [
            parse_item_as_dict(x, account.primary_smtp_address, True, True) for x in items
        ]
        readable_output = tableToMarkdown(
            "Get items", items_to_context, ITEMS_RESULTS_HEADERS
        )
        output = {
            CONTEXT_UPDATE_EWS_ITEM: items_to_context,
            "Email": [email_ec(item) for item in items],
        }
        return readable_output, output, items_as_incidents


    def get_folder(client: EWSClient, folder_path, target_mailbox=None, is_public=None):      # pragma: no cover
        """
        Retrieve a folder from the target mailbox or client mailbox
        :param client: EWS Client
        :param folder_path: folder path to retrieve
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) is_public: is the folder public
        :return:
        """
        account = client.get_account(target_mailbox)
        is_public = client.is_default_folder(folder_path, is_public)
        folder = folder_to_context_entry(
            client.get_folder_by_path(folder_path, account=account, is_public=is_public)
        )
        readable_output = tableToMarkdown(f"Folder {folder_path}", folder)
        output = {CONTEXT_UPDATE_FOLDER: folder}
        return readable_output, output, folder


    def folder_to_context_entry(f):
        """
        Create a context entry from a folder response
        :param f: folder response
        :return: dict context entry
        """
        try:
            f_entry = {
                "name": f.name,
                "totalCount": f.total_count,
                "id": f.id,
                "childrenFolderCount": f.child_folder_count,
                "changeKey": f.changekey,
            }

            if "unread_count" in [x.name for x in Folder.FIELDS]:
                f_entry["unreadCount"] = f.unread_count
            return f_entry
        except AttributeError:
            if isinstance(f, dict):
                return {
                    "name": f.get("name"),
                    "totalCount": f.get("total_count"),
                    "id": f.get("id"),
                    "childrenFolderCount": f.get("child_folder_count"),
                    "changeKey": f.get("changekey"),
                    "unreadCount": f.get("unread_count"),
                }


    def mark_item_as_read(
            client: EWSClient, item_ids, operation="read", target_mailbox=None
    ):     # pragma: no cover
        """
        Marks item as read
        :param client: EWS Client
        :param item_ids: items ids to mark as read
        :param (Optional) operation: operation to execute
        :param (Optional) target_mailbox: target mailbox
        :return: Output tuple
        """
        marked_items = []
        item_ids = argToList(item_ids)
        items = client.get_items_from_mailbox(target_mailbox, item_ids)
        items = [x for x in items if isinstance(x, Message)]

        for item in items:
            item.is_read = operation == "read"
            item.save()

            marked_items.append(
                {
                    ITEM_ID: item.id,
                    MESSAGE_ID: item.message_id,
                    ACTION: f"marked-as-{operation}",
                }
            )

        readable_output = tableToMarkdown(
            f"Marked items ({operation} marked operation)", marked_items
        )
        output = {CONTEXT_UPDATE_EWS_ITEM: marked_items}
        return readable_output, output, marked_items


    def random_word_generator(length):
        """Generate a random string of given length
        """
        letters = string.ascii_lowercase
        return ''.join(random.choice(letters) for i in range(length))


    def handle_html(html_body):
        """
        Extract all data-url content from within the html and return as separate attachments.
        Due to security implications, we support only images here
        We might not have Beautiful Soup so just do regex search
        """
        attachments = []
        clean_body = ''
        last_index = 0
        for i, m in enumerate(
                re.finditer(r'<img.+?src=\"(data:(image\/.+?);base64,([a-zA-Z0-9+/=\r\n]+?))\"', html_body, re.I)):
            attachment = {
                'data': base64.b64decode(m.group(3)),
                'name': f'image{i}'
            }
            attachment['cid'] = f'{attachment["name"]}@{random_word_generator(8)}.{random_word_generator(8)}'

            attachments.append(attachment)
            clean_body += html_body[last_index:m.start(1)] + 'cid:' + attachment['cid']
            last_index = m.end() - 1

        clean_body += html_body[last_index:]
        return clean_body, attachments


    def collect_manual_attachments(manualAttachObj):      # pragma: no cover
        """Collect all manual attachments' data

        Args:
            manualAttachObj (str): String representation of the manually attached files list.

        Returns:
            List[Dict]. List of the files data.
        """
        manually_attached_objects = argToList(manualAttachObj)

        attachments = []
        for attachment in manually_attached_objects:
            file_res = demisto.getFilePath(os.path.basename(attachment['RealFileName']))

            path = file_res['path']

            with open(path, 'rb') as fp:
                data = fp.read()

            attachments.append({
                'name': attachment['FileName'],
                'data': data,
                'cid': ''
            })

        return attachments


    def collect_attachments(attachments_ids, attachments_cids, attachments_names):     # pragma: no cover
        """Collect all attachments' data

        Args:
            attachments_ids (str): String representation of the files ids list.
            attachments_cids (str): String representation of the files content ids list.
            attachments_names (str): String representation of the files names list.

        Returns:
            List[Dict]. List of the files data.
        """
        attachments = []

        files_ids = argToList(attachments_ids)
        files_cids = argToList(attachments_cids)
        files_names = argToList(attachments_names)

        for index, file_id in enumerate(files_ids):
            try:
                file_res = demisto.getFilePath(file_id)
                path = file_res['path']

                filename = files_names[index] if len(files_names) > index and files_names[index] else file_res["name"]

                cid = files_cids[index] if len(files_cids) > index and files_cids[index] else ""

                with open(path, 'rb') as fp:
                    data = fp.read()

                attachments.append({
                    'name': filename,
                    'data': data,
                    'cid': cid
                })

            except Exception as e:
                demisto.error(f'Invalid entry {file_id} with exception: {e}')
                return_error(f'Entry {file_id} is not valid or is not a file entry')

        return attachments


    def handle_transient_files(transient_files, transient_files_contents, transient_files_cids):
        """Creates the transient attachments data

        Args:
            transient_files (str): String representation of the transient files names list.
            transient_files_contents (str): String representation of the transient files content list.
            transient_files_cids (str): String representation of the transient files content ids list.

        Returns:
            List[Dict]. List of the transient files data.
        """
        transient_attachments = []

        files_names = argToList(transient_files)
        files_contents = argToList(transient_files_contents)
        files_cids = argToList(transient_files_cids)

        for index in range(len(files_names)):
            file_name = files_names[index]

            if index >= len(files_contents):
                break

            file_content = bytes(files_contents[index], UTF_8)

            file_cid = "" if index >= len(files_cids) else files_cids[index]

            transient_attachments.append({
                'name': file_name,
                'data': file_content,
                'cid': file_cid
            })

        return transient_attachments


    def handle_template_params(template_params):      # pragma: no cover
        """Translates the template params if they exist from the context

        Args:
            template_params (str): JSON string that represent the variables names to be replaced and the desired value.
                                    Value can be either real value or context key to fetch the value from.

        Returns:
            Dict. `variable_name: value_to_use` of the templated parameters.
        """
        actual_params = {}

        if template_params:
            try:
                params = json.loads(template_params)

                for p in params:
                    if params[p].get('value'):
                        actual_params[p] = params[p]['value']
                    elif params[p].get('key'):
                        actual_params[p] = demisto.dt(demisto.context(), params[p]['key'])
            except ValueError as e:
                return_error('Unable to parse template_params: %s' % (str(e)))

        return actual_params


    def create_message_object(to, cc, bcc, subject, body, additional_headers, from_address, reply_to, importance):
        """Creates the message object according to the existence of additional custom headers.
        """
        if additional_headers:
            return Message(
                to_recipients=to,
                author=from_address,
                cc_recipients=cc,
                bcc_recipients=bcc,
                subject=subject,
                reply_to=reply_to,
                body=body,
                importance=importance,
                **additional_headers
            )

        return Message(
            to_recipients=to,
            author=from_address,
            cc_recipients=cc,
            bcc_recipients=bcc,
            subject=subject,
            reply_to=reply_to,
            body=body,
            importance=importance
        )


    def create_message(to, subject='', body='', bcc=None, cc=None, html_body=None, attachments=None,
                       additional_headers=None, from_address=None, reply_to=None, importance=None):     # pragma: no cover
        """Creates the Message object that will be sent.

        Args:
            to (list): Main recipients.
            cc (list): CC recipients.
            bcc (list): BCC recipients.
            subject (str): Email's subject.
            body (str): Email's simple text body.
            html_body (str): Email's html body.
            attachments (list): Files to be attached to the mail, both inline and as files.
            additional_headers (Dict): Custom headers to be added to the message.
            from_address (str): The email address from which to reply.
            reply_to (list): Email addresses that need to be used to reply to the message.

        Returns:
            Message. Message object ready to be sent.
        """
        if not html_body:
            # This is a simple text message - we cannot have CIDs here
            message = create_message_object(to, cc, bcc, subject, body, additional_headers, from_address, reply_to, importance)

            for attachment in attachments:
                if not attachment.get('cid'):
                    new_attachment = FileAttachment(name=attachment.get('name'), content=attachment.get('data'))
                    message.attach(new_attachment)

        else:
            html_body, html_attachments = handle_html(html_body)
            attachments += html_attachments

            message = create_message_object(to, cc, bcc, subject, HTMLBody(html_body), additional_headers, from_address,
                                            reply_to, importance)

            for attachment in attachments:
                if not attachment.get('cid'):
                    new_attachment = FileAttachment(name=attachment.get('name'), content=attachment.get('data'))
                else:
                    new_attachment = FileAttachment(name=attachment.get('name'), content=attachment.get('data'),
                                                    is_inline=True, content_id=attachment.get('cid'))

                message.attach(new_attachment)

        return message


    def add_additional_headers(additional_headers):
        """Adds custom headers to the Message object

        Args:
            additional_headers (str): Headers list as string. Example: headerName1=headerValue1,headerName2=headerValue2

        Returns:
            Dict. Headers dictionary in the form of: `header_name: header value`
        """
        headers = {}

        for header in argToList(additional_headers):
            header_name, header_value = header.split('=', 1)

            class TempClass(ExtendedProperty):
                distinguished_property_set_id = 'InternetHeaders'
                property_name = header_name
                property_type = 'String'

            try:
                Message.register(header_name, TempClass)
                headers[header_name] = header_value
            except ValueError as e:
                demisto.debug('EWSO365 - Header ' + header_name + ' could not be registered. ' + str(e))

        return headers


    def send_email(client: EWSClient, to, subject='', body="", bcc=None, cc=None, htmlBody=None,
                   attachIDs="", attachCIDs="", attachNames="", manualAttachObj=None,
                   transientFile=None, transientFileContent=None, transientFileCID=None, templateParams=None,
                   additionalHeader=None, raw_message=None, from_address=None, replyTo=None, importance=None,
                   renderBody=False):     # pragma: no cover
        to = argToList(to)
        cc = argToList(cc)
        bcc = argToList(bcc)
        reply_to = argToList(replyTo)
        render_body = argToBoolean(renderBody)

        # Basic validation - we allow pretty much everything but you have to have at least a recipient
        # We allow messages without subject and also without body
        if not to and not cc and not bcc:
            return_error('You must have at least one recipient')

        if raw_message:
            message = Message(
                to_recipients=to,
                cc_recipients=cc,
                bcc_recipients=bcc,
                body=raw_message,
                author=from_address,
                reply_to=reply_to,
                importance=importance
            )

        else:
            if additionalHeader:
                additionalHeader = add_additional_headers(additionalHeader)

            # collect all types of attachments
            attachments = collect_attachments(attachIDs, attachCIDs, attachNames)
            attachments.extend(collect_manual_attachments(manualAttachObj))
            attachments.extend(handle_transient_files(transientFile, transientFileContent, transientFileCID))

            # update body and html_body with the templated params, if exists
            template_params = handle_template_params(templateParams)
            if template_params:
                body = body.format(**template_params)
                if htmlBody:
                    htmlBody = htmlBody.format(**template_params)

            message = create_message(to, subject, body, bcc, cc, htmlBody, attachments, additionalHeader, from_address,
                                     reply_to, importance)

        client.send_email(message)

        results = [CommandResults(entry_type=EntryType.NOTE, raw_response='Mail sent successfully')]
        if render_body:
            results.append(CommandResults(
                entry_type=EntryType.NOTE,
                content_format=EntryFormat.HTML,
                raw_response=htmlBody,
            ))

        return results


    def reply_mail(client: EWSClient, to, inReplyTo, subject='', body="", bcc=None, cc=None, htmlBody=None,
                   attachIDs="", attachCIDs="", attachNames="", manualAttachObj=None):     # pragma: no cover
        to = argToList(to)
        cc = argToList(cc)
        bcc = argToList(bcc)

        # collect all types of attachments
        attachments = collect_attachments(attachIDs, attachCIDs, attachNames)
        attachments.extend(collect_manual_attachments(manualAttachObj))
        client.reply_mail(inReplyTo, to, body, subject, bcc, cc, htmlBody, attachments)


    def get_item_as_eml(client: EWSClient, item_id, target_mailbox=None):      # pragma: no cover
        """
        Retrieve item as an eml
        :param client: EWS Client
        :param item_id: Item id to retrieve
        :param (Optional) target_mailbox: target mailbox
        :return: Output tuple
        """
        account = client.get_account(target_mailbox)
        item = client.get_item_from_mailbox(account, item_id)

        if item.mime_content:
            mime_content = item.mime_content
            email_policy = SMTP if mime_content.isascii() else SMTPUTF8
            if isinstance(mime_content, bytes):
                email_content = email.message_from_bytes(mime_content, policy=email_policy)
            else:
                email_content = email.message_from_string(mime_content, policy=email_policy)
            if item.headers:
                # compare header keys case-insensitive
                attached_email_headers = [
                    (h.lower(), " ".join(map(str.strip, v.split("\r\n"))))
                    for (h, v) in list(email_content.items())
                ]
                for header in item.headers:
                    if (
                            header.name.lower(),
                            header.value,
                    ) not in attached_email_headers and header.name.lower() != "content-type":
                        try:
                            email_content.add_header(header.name, header.value)
                        except ValueError as err:
                            if "There may be at most" not in str(err):
                                raise err

            eml_name = item.subject if item.subject else "demisto_untitled_eml"
            file_result = fileResult(eml_name + ".eml", email_content.as_string())
            file_result = (
                file_result if file_result else "Failed uploading eml file to war room"
            )

            return file_result
        return None


    def handle_attached_email_with_incorrect_id(attached_email: Message):
        """This function handles a malformed Message-ID value which can be returned in the header of certain email objects.
        This issue happens due to a current bug in "email" library and further explained in XSUP-32074.
        Public issue link: https://github.com/python/cpython/issues/105802

        The function will run on every attached email if exists, check its Message-ID header value and fix it if possible.
        Args:
            attached_email (Message): attached email object.

        Returns:
            Message: attached email object.
        """
        message_id_value = ""
        for i in range(len(attached_email._headers)):
            if attached_email._headers[i][0] == "Message-ID":
                message_id = attached_email._headers[i][1]
                try:
                    if message_id.endswith("]>") and message_id.startswith("<["):
                        demisto.debug(f"Fixing invalid {message_id=} attachment header by removing its square bracket \
                            wrapper (see XSUP-32074 for further information)")
                        attached_email._headers.pop(i)
                        message_id_value = f"<{message_id[2:-2]}>"

                except Exception as e:
                    # The function is designed to handle a specific format error for the Message-ID header
                    # as explained in the docstring.
                    # That being said, we do expect the header to be in a known format.
                    # If this function encounters a header format which is not in the known format and can't be fixed,
                    # the header will be ignored completely to prevent crashing the fetch command.
                    demisto.debug(f"Invalid {message_id=}, Error: {e}")
                    break
                break
        if message_id_value:
            # If the Message-ID header was fixed in the context of this function, it will be inserted again to the _headers list
            attached_email._headers.append(("Message-ID", message_id_value))
        return attached_email


    def parse_incident_from_item(item):     # pragma: no cover
        """
        Parses an incident from an item
        :param item: item to parse
        :return: Parsed item
        """
        incident = {}
        labels = []
        demisto.debug(f"starting to parse the email with id {item.id} into an incident")
        log_memory()
        try:
            incident["details"] = item.text_body or item.body
        except AttributeError:
            incident["details"] = item.body
        incident["name"] = item.subject
        labels.append({"type": "Email/subject", "value": item.subject})
        incident["occurred"] = item.datetime_received.ewsformat()

        # handle recipients
        if item.to_recipients:
            for recipient in item.to_recipients:
                labels.append({"type": "Email", "value": recipient.email_address})

        # handle cc
        if item.cc_recipients:
            for recipient in item.cc_recipients:
                labels.append({"type": "Email/cc", "value": recipient.email_address})
        # handle email from
        if item.sender:
            labels.append({"type": "Email/from", "value": item.sender.email_address})
            labels.append({"type": "Email/from/name", "value": item.sender.name})

        # email format
        email_format = ""
        try:
            if item.text_body:
                labels.append({"type": "Email/text", "value": item.text_body})
                email_format = "text"
        except AttributeError:
            pass
        if item.body:
            labels.append({"type": "Email/html", "value": item.body})
            email_format = "HTML"
        labels.append({"type": "Email/format", "value": email_format})

        # handle attachments
        if item.attachments:
            incident["attachment"] = []
            demisto.debug(f"parsing {len(item.attachments)} attachments for item with id {item.id}")
            attachment_counter = 0
            for attachment in item.attachments:
                attachment_counter += 1
                demisto.debug(f'retrieving attachment number {attachment_counter} of email with id {item.id}')
                file_result = None
                label_attachment_type = None
                label_attachment_id_type = None
                if isinstance(attachment, FileAttachment):
                    try:
                        if attachment.content:
                            # file attachment
                            label_attachment_type = "attachments"
                            label_attachment_id_type = "attachmentId"

                            # save the attachment
                            file_name = get_attachment_name(attachment.name)
                            demisto.debug(f"saving content number {attachment_counter}, "
                                          f"of size {sys.getsizeof(attachment.content)}, of email with id {item.id}")
                            file_result = fileResult(file_name, attachment.content)

                            # check for error
                            if file_result["Type"] == entryTypes["error"]:
                                demisto.error(file_result["Contents"])
                                raise Exception(file_result["Contents"])

                            # save attachment to incident
                            incident["attachment"].append(
                                {
                                    "path": file_result["FileID"],
                                    "name": get_attachment_name(attachment.name),
                                }
                            )
                    except TypeError as e:
                        if str(e) != "must be string or buffer, not None":
                            raise
                        continue
                    except SAXParseException as e:
                        # TODO: When a fix is released, we will need to bump the library version.
                        #  https://github.com/ecederstrand/exchangelib/issues/1200
                        demisto.debug(f'An XML error occurred while loading an attachments content.'
                                      f'\nMessage ID is {item.id}'
                                      f'\nError: {e.getMessage()}')
                        continue
                else:
                    # other item attachment
                    label_attachment_type = "attachmentItems"
                    label_attachment_id_type = "attachmentItemsId"

                    # save the attachment
                    if attachment.item.mime_content:
                        mime_content = attachment.item.mime_content
                        email_policy = SMTP if mime_content.isascii() else SMTPUTF8
                        if isinstance(mime_content, str) and not mime_content.isascii():
                            mime_content = mime_content.encode()
                        attached_email = email.message_from_bytes(mime_content, policy=email_policy) \
                            if isinstance(mime_content, bytes) \
                            else email.message_from_string(mime_content, policy=email_policy)
                        if attachment.item.headers:
                            # compare header keys case-insensitive
                            attached_email_headers = []
                            attached_email = handle_attached_email_with_incorrect_id(attached_email)
                            for h, v in attached_email.items():
                                if not isinstance(v, str):
                                    try:
                                        v = str(v)
                                    except:  # noqa: E722
                                        demisto.debug(f'cannot parse the header "{h}"')
                                        continue

                                v = ' '.join(map(str.strip, v.split('\r\n')))
                                attached_email_headers.append((h.lower(), v))
                            demisto.debug(f'{attached_email_headers=}')
                            for header in attachment.item.headers:
                                if (
                                        (header.name.lower(), header.value)
                                        not in attached_email_headers
                                        and header.name.lower() != "content-type"
                                ):
                                    try:
                                        attached_email.add_header(header.name, header.value)
                                    except ValueError as err:
                                        if "There may be at most" not in str(err):
                                            raise err

                        attached_email_bytes = attached_email.as_bytes()
                        chardet_detection = chardet.detect(attached_email_bytes)
                        encoding = chardet_detection.get('encoding', 'utf-8') or 'utf-8'
                        try:
                            # Trying to decode using the detected encoding
                            data = attached_email_bytes.decode(encoding)
                        except UnicodeDecodeError:
                            # In case the detected encoding fails apply the default encoding
                            demisto.info(f'Could not decode attached email using detected encoding:{encoding}, retrying '
                                         f'using utf-8.\nAttached email:\n{attached_email}')
                            try:
                                data = attached_email_bytes.decode('utf-8')
                            except UnicodeDecodeError:
                                demisto.info('Could not decode attached email using utf-8. returned the content without decoding')
                                data = attached_email_bytes  # type: ignore

                        file_result = fileResult(get_attachment_name(attachment.name, eml_extension=True), data)

                    if file_result:
                        # check for error
                        if file_result["Type"] == entryTypes["error"]:
                            demisto.error(file_result["Contents"])
                            raise Exception(file_result["Contents"])

                        # save attachment to incident
                        incident["attachment"].append(
                            {
                                "path": file_result["FileID"],
                                "name": get_attachment_name(attachment.name, eml_extension=True),
                            }
                        )

                labels.append(
                    {
                        "type": label_attachment_type,
                        "value": get_attachment_name(attachment.name),
                    }
                )
                labels.append(
                    {"type": label_attachment_id_type, "value": attachment.attachment_id.id}
                )
            demisto.debug(f'finished parsing attachment {attachment_counter} of email with id {item.id}')

        # handle headers
        if item.headers:
            headers = []
            for header in item.headers:
                labels.append(
                    {
                        "type": f"Email/Header/{header.name}",
                        "value": str(header.value),
                    }
                )
                headers.append(f"{header.name}: {header.value}")
            labels.append({"type": "Email/headers", "value": "\r\n".join(headers)})

        # handle item id
        if item.message_id:
            labels.append({"type": "Email/MessageId", "value": str(item.message_id)})

        if item.id:
            labels.append({"type": "Email/ID", "value": item.id})
            labels.append({"type": "Email/itemId", "value": item.id})

        # handle conversion id
        if item.conversation_id:
            labels.append({"type": "Email/ConversionID", "value": item.conversation_id.id})

        incident["labels"] = labels
        demisto.debug(f"Starting to generate rawJSON for incident, from email with id {item.id}")
        log_memory()
        incident["rawJSON"] = json.dumps(parse_item_as_dict(item, None), ensure_ascii=False)
        log_memory()
        demisto.debug(f"Finished generating rawJSON from email with id {item.id}")

        return incident


    def fetch_emails_as_incidents(client: EWSClient, last_run, incident_filter):
        """
        Fetch incidents
        :param client: EWS Client
        :param last_run: last run dict
        :return:
        """
        log_memory()
        last_run = get_last_run(client, last_run)
        demisto.debug(f"get_last_run: {last_run=}")
        excluded_ids = set(last_run.get(LAST_RUN_IDS, []))
        try:
            last_emails = fetch_last_emails(
                client,
                client.folder_name,
                last_run.get(LAST_RUN_TIME),
                excluded_ids,
                incident_filter,
            )

            incidents = []
            incident: dict[str, str] = {}
            emails_ids = []  # Used for mark emails as read
            demisto.debug(f'{APP_NAME} - Started fetch with {len(last_emails)} at {last_run.get(LAST_RUN_TIME)}')
            current_fetch_ids = set()

            last_fetch_time = last_run.get(LAST_RUN_TIME)

            last_modification_time = last_fetch_time
            if isinstance(last_modification_time, EWSDateTime):
                last_modification_time = last_modification_time.ewsformat()

            for item in last_emails:
                if item.message_id:
                    current_fetch_ids.add(item.message_id)
                    incident = parse_incident_from_item(item)
                    incidents.append(incident)

                    if incident_filter == MODIFIED_FILTER:
                        item_modified_time = item.last_modified_time.ewsformat()
                        if last_modification_time is None or last_modification_time < item_modified_time:
                            last_modification_time = item_modified_time

                    if item.id:
                        emails_ids.append(item.id)

                    if len(incidents) >= client.max_fetch:
                        break

            demisto.debug(f'{APP_NAME} - ending fetch - got {len(incidents)} incidents.')

            if incident_filter == MODIFIED_FILTER:
                last_incident_run_time = last_modification_time
            else:  # default case - using 'received' time
                last_incident_run_time = incident.get("occurred", last_fetch_time)

            # making sure both last fetch time and the time of most recent incident are the same type for comparing.
            if isinstance(last_incident_run_time, EWSDateTime):
                last_incident_run_time = last_incident_run_time.ewsformat()

            if isinstance(last_fetch_time, EWSDateTime):
                last_fetch_time = last_fetch_time.ewsformat()

            demisto.debug(
                f'#### last_incident_time: {last_incident_run_time}({type(last_incident_run_time)}).'
                f'last_fetch_time: {last_fetch_time}({type(last_fetch_time)}) ####')

            # If the fetch query is not fully fetched (we didn't have any time progress) - then we keep the
            # id's from current fetch until progress is made. This is for when max_fetch < incidents_from_query.
            if not last_incident_run_time or not last_fetch_time or last_incident_run_time > last_fetch_time:
                ids = current_fetch_ids
            else:
                ids = current_fetch_ids | excluded_ids

            new_last_run = {
                LAST_RUN_TIME: last_incident_run_time,
                LAST_RUN_FOLDER: client.folder_name,
                LAST_RUN_IDS: list(ids),
                ERROR_COUNTER: 0,
            }

            demisto.debug(f'Set last run to: {new_last_run=}')
            demisto.setLastRun(new_last_run)

            if client.mark_as_read:
                mark_item_as_read(client, emails_ids)

            return incidents

        except RateLimitError:
            if LAST_RUN_TIME in last_run:
                last_run[LAST_RUN_TIME] = last_run[LAST_RUN_TIME].ewsformat()
            if ERROR_COUNTER not in last_run:
                last_run[ERROR_COUNTER] = 0
            last_run[ERROR_COUNTER] += 1
            demisto.setLastRun(last_run)
            if last_run[ERROR_COUNTER] > 2:
                raise
            return []


    def fetch_last_emails(
            client: EWSClient, folder_name="Inbox", since_datetime=None, exclude_ids=None, incident_filter=RECEIVED_FILTER
    ):
        """
        Fetches last emails
        :param client: EWS client
        :param (Optional) folder_name: folder name to pull from
        :param (Optional) since_datetime: items will be searched after this datetime
        :param (Optional) exclude_ids: exclude ids from fetch
        :return: list of exchangelib.Items
        """
        qs = client.get_folder_by_path(folder_name, is_public=client.is_public_folder)
        demisto.debug(f"Finished getting the folder named {folder_name} by path")
        log_memory()
        if since_datetime:
            if incident_filter == MODIFIED_FILTER:
                qs = qs.filter(last_modified_time__gte=since_datetime)
            else:  # default to "received" time
                qs = qs.filter(datetime_received__gte=since_datetime)
        else:
            tz = EWSTimeZone('UTC')
            first_fetch_datetime = dateparser.parse(FETCH_TIME)
            assert first_fetch_datetime is not None
            first_fetch_ews_datetime = EWSDateTime.from_datetime(first_fetch_datetime.replace(tzinfo=tz))
            qs = qs.filter(last_modified_time__gte=first_fetch_ews_datetime)
            demisto.debug(f"{first_fetch_ews_datetime=}")
        qs = qs.filter().only(*[x.name for x in Message.FIELDS if x.name.lower() != 'mime_content'])
        qs = qs.filter().order_by("datetime_received")
        result = []
        exclude_ids = exclude_ids if exclude_ids else set()
        demisto.debug(f'{APP_NAME} - Exclude ID list: {exclude_ids}')
        qs.chunk_size = min(client.max_fetch, 100)
        qs.page_size = min(client.max_fetch, 100)
        demisto.debug("Before iterating on queryset")
        demisto.debug(f'Size of the queryset object in fetch-incidents:{sys.getsizeof(qs)}')
        for item in qs:
            demisto.debug("next iteration of the queryset in fetch-incidents")
            if isinstance(item, Message) and item.message_id not in exclude_ids:
                result.append(item)
                if len(result) >= client.max_fetch:
                    break
            else:
                demisto.debug(f'message_id {item.message_id} was excluded. IsMessage: {isinstance(item, Message)}')
        demisto.debug(f'{APP_NAME} - Got total of {len(result)} from ews query.')
        log_memory()
        return result


    def test_module(client: EWSClient, max_fetch):     # pragma: no cover
        """
        test-module
        * Max incidents per fetch <= MAX_INCIDENTS_PER_FETCH
        * Account can be retrieved
        * Account has read rights
        * Test access to fetch folder
        :param client: EWS Client
        :param max_fetch: Max fetches per incident
        :return: "ok"
        """
        try:
            if int(max_fetch) > MAX_INCIDENTS_PER_FETCH:
                return_error(f'Error - Max incidents per fetch cannot be greater than {MAX_INCIDENTS_PER_FETCH}. '
                             f'You provided: {max_fetch}')
            account = client.get_account()
            if not account.root.effective_rights.read:  # pylint: disable=E1101
                raise Exception(
                    "Success to authenticate, but user has no permissions to read from the mailbox. "
                    "Need to delegate the user permissions to the mailbox - "
                    "please read integration documentation and follow the instructions"
                )
            client.get_folder_by_path(
                client.folder_name, account, client.is_public_folder
            ).test_access()
        except ErrorFolderNotFound as e:
            if "Top of Information Store" in str(e):
                raise Exception(
                    "Success to authenticate, but user probably has no permissions to read from the specific folder."
                    "Check user permissions. You can try !ews-find-folders command to "
                    "get all the folders structure that the user has permissions to"
                )

        return "ok"


    def sub_main():     # pragma: no cover
        is_test_module = False
        params = demisto.params()
        args = prepare_args(demisto.args())
        # client's default_target_mailbox is the authorization source for the instance
        params['default_target_mailbox'] = args.get('target_mailbox', args.get('source_mailbox', params['default_target_mailbox']))
        if params.get('upn_mailbox') and not (args.get('target_mailbox')):
            params['default_target_mailbox'] = params.get('upn_mailbox')
        try:
            client = EWSClient(**params)
            start_logging()
            # replace sensitive access_token value in logs
            add_sensitive_log_strs(client.credentials.access_token.get('access_token', ''))
            command = demisto.command()
            # commands that return a single note result
            normal_commands = {
                "ews-get-searchable-mailboxes": get_searchable_mailboxes,
                "ews-move-item-between-mailboxes": move_item_between_mailboxes,
                "ews-move-item": move_item,
                "ews-delete-items": delete_items,
                "ews-search-mailbox": search_items_in_mailbox,
                "ews-get-contacts": get_contacts,
                "ews-get-out-of-office": get_out_of_office_state,
                "ews-recover-messages": recover_soft_delete_item,
                "ews-create-folder": create_folder,
                "ews-mark-item-as-junk": mark_item_as_junk,
                "ews-find-folders": find_folders,
                "ews-get-items-from-folder": get_items_from_folder,
                "ews-get-items": get_items,
                "ews-get-folder": get_folder,
                "ews-expand-group": get_expanded_group,
                "ews-mark-items-as-read": mark_item_as_read,
            }

            # commands that may return multiple results or non-note result
            special_output_commands = {
                "ews-get-attachment": fetch_attachments_for_message,
                "ews-delete-attachment": delete_attachments_for_message,
                "ews-get-items-as-eml": get_item_as_eml,
                "reply-mail": reply_mail,
            }
            # system commands:
            if command == "test-module":
                is_test_module = True
                demisto.results(test_module(client, params.get('max_fetch')))
            elif command == "fetch-incidents":
                last_run = demisto.getLastRun()
                incident_filter = params.get('incidentFilter', RECEIVED_FILTER)
                if incident_filter not in [RECEIVED_FILTER, MODIFIED_FILTER]:  # Ensure it's one of the allowed filter values
                    incident_filter = RECEIVED_FILTER  # or if not, force it to the default, RECEIVED_FILTER
                demisto.debug(f"{incident_filter=}")
                incidents = fetch_emails_as_incidents(client, last_run, incident_filter)
                demisto.debug(f"Saving incidents with size {sys.getsizeof(incidents)}")

                demisto.incidents(incidents)
            elif command == "send-mail":
                commands_res = send_email(client, **args)
                return_results(commands_res)

            # special outputs commands
            elif command in special_output_commands:
                demisto.results(special_output_commands[command](client, **args))  # type: ignore[operator]

            elif command == "ews-auth-reset":
                return_results(reset_auth())

            # normal commands
            else:
                output = normal_commands[command](client, **args)  # type: ignore[operator]
                return_outputs(*output)

        except Exception as e:
            demisto.error(f'got exception {e}')
            start_logging()
            debug_log = log_stream.getvalue()  # type: ignore[union-attr]
            error_message_simple = ""

            # Office365 regular maintenance case
            if isinstance(e, ErrorMailboxStoreUnavailable | ErrorMailboxMoveInProgress):
                log_message = (
                    "Office365 is undergoing load balancing operations. "
                    "As a result, the service is temporarily unavailable."
                )
                if demisto.command() == "fetch-incidents":
                    demisto.info(log_message)
                    demisto.incidents([])
                    sys.exit(0)
                if is_test_module:
                    demisto.results(
                        log_message + " Please retry the instance configuration test."
                    )
                    sys.exit(0)
                error_message_simple = log_message + " Please retry your request."

            if isinstance(e, ConnectionError):
                error_message_simple = (
                    "Could not connect to the server.\n"
                    f"Additional information: {str(e)}"
                )
            else:
                if is_test_module and isinstance(e, MalformedResponseError):
                    error_message_simple = (
                        "Got invalid response from the server.\n"
                    )

            # Legacy error handling
            if "Status code: 401" in debug_log:
                error_message_simple = (
                    "Got unauthorized from the server. "
                )

            if "Status code: 503" in debug_log:
                error_message_simple = (
                    "Got timeout from the server. "
                    "Probably the server is not reachable with the current settings. "
                )

            if not error_message_simple:
                error_message = error_message_simple = str(e)
            else:
                error_message = error_message_simple + "\n" + str(e)

            stacktrace = traceback.format_exc()
            if stacktrace:
                error_message += "\nFull stacktrace:\n" + stacktrace

            if debug_log:
                error_message += "\nFull debug log:\n" + debug_log

            if demisto.command() == "fetch-incidents":
                raise
            if demisto.command() == "ews-search-mailbox" and isinstance(e, ValueError):
                return_error(
                    message="Selected invalid field, please specify valid field name.",
                    error=e,
                )
            if is_test_module:
                demisto.results(error_message_simple)
            else:
                demisto.results(
                    {
                        "Type": entryTypes["error"],
                        "ContentsFormat": formats["text"],
                        "Contents": error_message_simple,
                    }
                )
            demisto.error(f"{e.__class__.__name__}: {error_message}")
        finally:
            exchangelib_cleanup()
            if log_stream:
                try:
                    logging.getLogger().removeHandler(log_handler)  # type: ignore
                    log_stream.close()
                except Exception as ex:
                    demisto.error(
                        "EWS: unexpected exception when trying to remove log handler: {}".format(
                            ex
                        )
                    )


    def process_main():
        """setup stdin to fd=0 so we can read from the server"""
        sys.stdin = os.fdopen(0, "r")
        sub_main()


    def main():     # pragma: no cover
        # When running big queries, like 'ews-search-mailbox' the memory might not freed by the garbage
        # collector. `separate_process` flag will run the integration on a separate process that will prevent
        # memory leakage.
        separate_process = demisto.params().get("separate_process", False)
        demisto.debug(f"Running as separate_process: {separate_process}")
        if separate_process:
            try:
                p = Process(target=process_main)
                p.start()
                p.join()
                demisto.debug("subprocess finished")
            except Exception as ex:
                demisto.error(f"Failed starting Process: {ex}")
        else:
            sub_main()


    def log_memory():
        if is_debug_mode():
            demisto.debug(f'memstat\n{str(subprocess.check_output(["ps", "-opid,comm,rss,vsz"]))}')


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('EWSO365', 'end', __line__())
  subtype: python3
  type: python
  nativeimage:
  - '8.3'
  - '8.4'
tests:
- EWS search-mailbox test
fromversion: 5.0.0
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADIVJREFUeAHtXHt0FNUZv/fOYzebJ3k1CQ8THiaBBLAEiuIRAu2hoqinSrR6xIqeoq1gRast2rr8UThYPT5QKigeDvScUkCl1lePWiggL4MYFWMMLxMgaTYk2WR3Z+dx7+13JxGBJmQ3BJgN+U4mMztzHzPf737f/b7vfjMYXQLEEcJos1ea21SWUdUSzg1o+PKcZNeiIQr62Uu3jfy0L7NA7ksPZwM5BUmPPeSLqzrRMPh4IDysNmiMzOB0tL6djKC8ZRjjPJViBVWeCKH7ipNpX3r+zp4lZgEGMAniXJr28s7MFtM1tMGkBUMYv0K3+KhARVUuZySLEqJSJEExghADLDmDDWoiHbkUAj/6PjkeYFsqvUiae3lVylet5sCmkJ7fRq3R2RYr1hbvHGoYbBDF4RQmKYhxDEACbgz2Akza5wW02xHqKICFVK6tqI/72z5fVnMofHlDiBRkWdaoMLVGWQdP5FFK0ylRJQpTajuIUEMIpACV6t0+7KVYwDEAZyz5+Pl0JuVbbx8YYZhYqFdPu3oVYIKKtdUrHFPjUsSpx8/sGIBPGMp8G0RbvYJYUgseSmz9dC4ccAzAyOpXsecCZFd1Qff1U1/mgHMk+CJyGSYEmNzB7eoFElZCLzTTa030AwysnLyi/OffhMhcFu65AUdgjGAiaWNUa/1n/vdXY6/XEX52HwIYZEfIYfu/dqs7Qjlo0HFug4avQYbwuXpKoi5HfpNMn5o1swUh7xs9bak368UQwICerNr4EQzH4DYRsQNrW+wwYjpIURh+BCBaxUyGIbAVIWAYGrN96W6sdtyFFrf7ae8rbCKUlpSyGkDqBzjykYqRR0XNOfFog85oYxxRmjjiTUR1t0im0ZzgSWpNdfMADVttlw0YEPq2pWn81nrrA93sBrCOG4jjKKQS1GxJ0gDWWfQLgJUFtpw3wQA6Y9TACYaSKIcAt7gEYDMuJ0b+bOe3ZGxIMCEoXiGHqhZMeACkFWTk7PST5XtMGABnL3TK1fEu9Gp6Bt54pF564ts26X7LFF101AdwVRlrYzKUB5BO35FMelrDASiZlOC6fo/PXGWZHfaVCMo4hGIDYGAWhdUDWPLjqNTbLessiiMT3Y6WVs4tCcFhiM9C8/LG7/LVIemPZof0KyC6eUl83u77x7/WVcelK8r3d6G8u6pywc7HDMBncsTr9ZKjRTcXyUx1n3mtJqgV86ZuBf1ktVXbfYl+PZyEpg0+fnjDxEVjn9+buL8FP4RBegtT2Cv75l+5GjQHWry1OkOicS5RkWqavnDGCJ/dCOhke+/Af469se54lTrhjoSVn/ve9VtkIFhapxSHORHmQdOKXE2+9kXNvZUh6cmnl2xf+eLU3KUN/67N58SFBrv0TxYWJy2Axjm4UvOf2dn0OKXMDf4QSnPxCl6+YhoumRv5SDrlLi/UYcwCHAoQ3GoyosFsa8ewz4FjPoO7WkJWssyk387/T81Mn44KXFhvGJul3jWrdFSwdOW++Xsa9Gd1g4rRY4dEMOcp59DlBavq1KkjIgaAW3SawRNRpU4KSQAb/CHLstDxAC8gkoRyEvnCN2ePq5wM4O4W4OoWFBFaQXTJERauVQxQzEpwWGkVmLgRLPTDemI7q2kHAOfAe0xklC7TD6sXXLVmwrJdd++pDz1jmCKT4IyxxL+fd1VFMTF3pqaOWYCTTE0fkqxuqg/hzKBuIsqYlJWgZPtNKzWg4yFiHo6eMHJJNDxjROLDE5fvufWLRrbCsCDnxw6sfN8egUGV5eZfo7fr7Mm/uiU01U5CiL7D814jZgFeUHaVBiy/FzgkDNx27r87T82vuqMsRPEaakYeV6aMSzanJRllx7F/VjUG8z73sVcNisBL4m2AsGZgNZNbIKXgkw+KY7tfmzl8Dhrh5WNe2DXnqya+CLJNzjtYPekgpudgoTdhs1ME7OMZy3S/haPmdKab1Kki7gkg1Qf5tPJ66+865eAOcZQaLx+bOyZj+tB4ssyjyiYCFd4YZtnz3jv446v/su/2b/x8BWgPiKF+L+E9AeJ81YlpgDtjCqMsqiCHaGNb6sE1RSn4adWlIM3iqTpFLtuggrm8McgLNh3wP7t8Suofpg2Mn5Kqsu0aUoZ82Wy9vrc+tAYsa/lcrfjOnqO3zsWsivau369WmujGD462tRimruclxKHBKW50rNUobhER/yjocVdh+p4hrz9ZYFznO8KUpeYp6p2BZV0bIlNmf/Tfd2bnqdf9YbQ89fZtaFFNK3/U4BhUu7ON6ZgFGCmG56MD2gpYnhuAwaCt8luoujUImpKBpo2O6Zvr9DlDtRsmX53tfkTmAfJ1q7SYU/B5Yb71SJyGTZM06OqkVdXGO1/V6DdVPVL6+I9e3Lujus1c4ddJDqLRDagoxt45F41ZFe02k7hBuQZAQE47Ax+WIgPix0YUEazvuNdiIFajSdPXVzXt+DZoXI+gLQxLkyky33/zsJQ5qkJMbupiuWnSNt21acYLW9P3PDDu7Ruz5GlZHrxTlHUqxSzAvc5QSMeFxaDEkEUmcVnBCTKtunek/NNtxwMFBpJsBLlloDYAeWeb/OaUlzZnrb675Os7c6VrM1T6vvCfnUgxC7AIdBDMPUgBY1dIkAh4EJgSIU58MqsjWo4L3xl83niJVhV76Iwqf2JSncYeZPbyYXtjNshUmXSo1f0KX79eWlpW4i9KUv+ktDta0fZ43ss7c9hF8NgjTTU0PJktqWzS0xNceHDAYImShDMYJymMsR+AnZUctesCUpiisNpJGcrNb6X8+ejwmoe36EzynGlIcZhzgwrPQ0ObxWiiTBHpIM50k2IW4LKyUSKS8ZQYC7DoDk4sbLNm4S1PrVdu+evOe3RZflFIW0Qk4BHgqqz2mgz3DZt+ecX+0c+VP1ar8StVrGscQt7gAMed6g5BcOSkv82pCHU5k2JLRfu8nYqJHeQQAY8NG2hpHg6fCJhtsBwQMcddYIZnqbz+6kzP9QDuZzNe/fSaA23WkyLhqyQr7jeFae5b4t2K3wV6WIUEAFWWkCdG3k6MIQnG0sejfR7unaUh7xYRverSF5JkFtUy08RsZXVynLJ26cxRNfetqcjceDS4SqdSnEeix2/KSXjjkZn5jbPXVU5o0klKyIQwh6IgjxFuQyVzow6qRDzqeqlgbAAM7/b6NVJ47YbqClVZ7CNL0LFsjGrcRD6a4SE+i9PaAYpSn+NJavzduGEtEzZuJ1oUDHq5bOwxURwWKNx5T+9e3WxKw8VLbmEk5yz5vHHdnWsqbl9zW+E3Zzb5nY4gWMzBzqTYABh4BzlZStAkeUGM89qtZUg0h/NHdYYwDAAMKwES0VrfONLQoBCcEDaMiM0eYQ2vHDAuYeyyT547HibX8o73pBik5LZgddpH9eF/3bq6/JZ1d42r6QzG6as+TT+LQumsygU7FzMA2xwR67xiFhZv6wOJw5OWDsIK5EKnAeppYBXBLnKhmuwf/ouKw/4nQpqVe+aqkDDU6oPy2LeOmDtSF+9s/H8gCSRbsgwT8gFOku2qnfx1UQ9iC+CzsgrgFn6sQB2oY9f+o5v/9SGW2WaS3C6/CADrFzommbrOM9v97FMbFH0CuN8lGQiDmrK2U0tczOM+BHDP2QivNUBlcCgikbyuEglEXdhUt4p8geCven43vVuzH2Dg52XxUpOGpIMUXn7pKREYIEGLN+bFm//Yer+2DjsE4n6AAdEP7/nhqjpUtzYbZUej2U8bC3V1CGevLDXwwi0WfvC0Sxf1Rz/AwH6M7TchHO/T9mSk9Fwn9aS3/joXnAOOkWAMq0K2/XLaB8t6rDEvOCOd2qFjAIZVnF+7JFwEHzMrChg8lzL4lBKWFWp/0A6APg14p7LTefflGIBP/H7icoARI/jW5KJHqz2fHDeHHNNCw5tCKD9IaTFHpChM8SDOWJoFr+LaAQ57lQ6OmJD0fmnvbHg5BmBxcyJcgLbAx7G2jGiFn192bAI6jMrL5bsPpaXVBAJDj7Vp+ZCdM7rVRPmagYZZBA2E96/jYRBASBNqnZT2yKNZUKtPkqMA7orDNvAlJSKzrb5j2yHKApZk0ebD6vbDjTmBsJTfEDALwpwXBy1WCEDnQfgwnRFZYvYHSQFskVF7iUl7TAAswOyMAHiGSvPCcO1Qx/aeLe3w8dKFoyuTdzXQQbUBbYRu0TGgEgogEaOQUTzYQiRJUmBB11Khib5NMQ1wZ9DY0u4V30AsPAHXxVYB20Yh7WCmS2Vr92YfaFVzMzx8wqB4ubmzNvrSuf8BON13AZrf558AAAAASUVORK5CYII=
detaileddescription: "To allow access to EWS O365, an administrator has to approve the Demisto app using an admin consent flow, by clicking on the following [link](https://oproxy.demisto.ninja/ms-ews-o365).\nAfter authorizing the Demisto app, you will get an ID, Token, and Key, which needs to be added to the integration instance configuration's corresponding fields.\n\n### Required Permissions for self deployed Azure Applications\n#### Office 365 Exchange Online\n**full_access_as_app** - To set this permission follow [the Microsoft documentation](https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/how-to-authenticate-an-ews-application-by-using-oauth#configure-for-app-only-authentication).\nYou can't manage the **Office 365 Exchange Online** app permissions via the Azure portal.\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/ewso365)"
