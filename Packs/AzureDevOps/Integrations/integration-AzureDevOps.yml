category: Utilities
commonfields:
  id: AzureDevOps
  version: -1
configuration:
- additionalinfo: App Registration Client ID
  display: Client ID
  name: client_id
  required: true
  type: 4
- additionalinfo: Organizaion name
  display: Organization
  name: organization
  required: true
  type: 0
- additionalinfo: Default is 50. Maximum is 200.
  defaultvalue: '50'
  display: Maximum incidents for one fetch.
  hidden: false
  name: max_fetch
  required: false
  type: 0
- additionalinfo: The name of the project which the pull requests belongs to. This argument is mandatory for Fetch functionality.
  display: Pull-request project name
  hidden: false
  name: project
  required: false
  type: 0
- additionalinfo: The name of the repository pull request's target branch. This argument is mandatory for Fetch functionality.
  display: Pull-request repository name
  hidden: false
  name: repository
  required: false
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  hidden: false
  name: first_fetch
  required: false
  type: 0
- display: Outgoing mirroring
  name: is_mirroring
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
description: |-
  Manage Git repositories in Azure DevOps Services. Integration capabilities include retrieving, creating, and updating pull requests. Run pipelines and retrieve git information.
  ** Note: This is a beta Integration, which lets you implement and test pre-release software. Since the integration is beta, it might contain bugs. Updates to the integration during the beta phase might include non-backward compatible features. We appreciate your feedback on the quality and usability of the integration to help us identify issues, fix them, and continually improve.
display: AzureDevOps (Beta)
name: AzureDevOps
script:
  commands:
  - deprecated: false
    description: Tests the connectivity to Azure.
    execution: false
    name: azure-devops-auth-test
  - deprecated: false
    description: Run this command to start the authorization process and follow the instructions in the command results.
    execution: false
    name: azure-devops-auth-start
  - deprecated: false
    description: Run this command to complete the authorization process. Should be used after running the azure-devops-auth-start command.
    execution: false
    name: azure-devops-auth-complete
  - deprecated: false
    description: Run this command if for some reason you need to rerun the authentication process.
    execution: false
    name: azure-devops-auth-reset
  - deprecated: false
    description: Get mapping fields from remote incident. Please note that this method will not update the current incident, it's here for debugging purposes.
    execution: false
    name: get-mapping-fields
  - arguments:
    - default: false
      description: The name of the project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The ID of the pipeline.
      isArray: false
      name: pipeline_id
      required: true
      secret: false
    - default: false
      description: The name of the repository branch which runs the pipeline.
      isArray: false
      name: branch_name
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'False'
      description: Use XSOAR built-in polling to retrieve the result when it's ready.
      isArray: false
      name: polling
      predefined:
      - 'True'
      - 'False'
      required: false
      secret: false
    - default: false
      defaultValue: '30'
      description: Indicates how long to wait between commands execution (in seconds) when 'polling' argument is true. Minimum value is 10 seconds.
      isArray: false
      name: interval
      required: false
      secret: false
    - default: false
      defaultValue: '60'
      description: Indicates the time in seconds until the polling sequence timeouts.
      isArray: false
      name: timeout
      required: false
      secret: false
    - default: false
      description: The ID of the pipeline run to retrieve when polling argument is 'True'. Intended for use by the Polling process and does not need to be provided by the user.
      isArray: false
      name: run_id
      required: false
      secret: false
    deprecated: false
    description: Run a pipeline. A DevOps pipeline is a set of automated processes and tools that allows both developers and operations professionals to work cohesively to build and deploy code to a production environment.
    execution: false
    polling: true
    name: azure-devops-pipeline-run
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.id
      description: The ID of the pipeline.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.revision
      description: Pipeline revision number
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.name
      description: Pipeline repository name
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.folder
      description: Pipeline folder
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.state
      description: The run state.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.createdDate
      description: Run-pipeline creation date.
      type: Date
    - contextPath: AzureDevOps.Project.Pipeline.Run.url
      description: The URL of the run.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.run_id
      description: The ID of the run.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.Run.name
      description: The name of the run.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.name
      description: The result of the pipeline running. If the run is in progress, the default value is 'unknown'.
      type: String
  - arguments:
    - default: false
      description: The Email of the user to add to the organization.
      isArray: false
      name: user_email
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'The type of account license (e.g. Express, Stakeholder etc.). More information can be found here: https://docs.microsoft.com/en-us/rest/api/azure/devops/memberentitlementmanagement/user-entitlements/add?view=azure-devops-rest-6.1#accountlicensetype .'
      isArray: false
      name: account_license_type
      predefined:
      - express
      - stakeholder
      - advanced
      - earlyAdopter
      - professional
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'Project Group type (e.g. Contributor, Reader etc.). More information can be found here: https://docs.microsoft.com/en-us/rest/api/azure/devops/memberentitlementmanagement/user-entitlements/add?view=azure-devops-rest-6.1#grouptype .'
      isArray: false
      name: group_type
      predefined:
      - projectReader
      - projectContributor
      - projectAdministrator
      - projectStakeholder
      required: true
      secret: false
    - default: false
      description: The ID of the project.
      isArray: false
      name: project_id
      required: true
      secret: false
    deprecated: false
    description: Add a user, assign license and extensions and make them a member of a project group in an account.
    execution: false
    name: azure-devops-user-add
    outputs:
    - contextPath: AzureDevOps.User.id
      description: The ID of the user.
      type: String
    - contextPath: AzureDevOps.User.accountLicenseType
      description: The type of account license.
      type: String
    - contextPath: AzureDevOps.User.lastAccessedDate
      description: Date the user last accessed the collection.
      type: Date
  - arguments:
    - default: false
      description: The ID of the user to remove from the organization. A user ID can be obtained by running the 'azure-devops-user-list' command.
      isArray: false
      name: user_id
      required: true
      secret: false
    deprecated: false
    description: Remove the user from all project memberships.
    execution: false
    name: azure-devops-user-remove
  - arguments:
    - default: false
      description: The name or ID of the project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The repository ID of the pull request's target branch. A repository ID can be obtained by running the 'azure-devops-repository-list'.
      isArray: false
      name: repository_id
      required: true
      secret: false
    - default: false
      description: The name of the source branch of the pull request.
      isArray: false
      name: source_branch
      required: true
      secret: false
    - default: false
      description: The name of the target branch of the pull request.
      isArray: false
      name: target_branch
      required: true
      secret: false
    - default: false
      description: The title of the pull request.
      isArray: false
      name: title
      required: true
      secret: false
    - default: false
      description: The description of the pull request.
      isArray: false
      name: description
      required: true
      secret: false
    - default: false
      description: Comma-separated list of the pull request reviewers IDs. A reviewer ID can be obtained by running the 'azure-devops-user-list' command.
      isArray: true
      name: reviewers_ids
      required: true
      secret: false
    deprecated: false
    description: Create a new pull request.
    execution: false
    name: azure-devops-pull-request-create
    outputs:
    - contextPath: AzureDevOps.PullRequest.repository.project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.id
      description: The ID of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.name
      description: The name of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.url
      description: The URL of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.size
      description: The size of the repository.
      type: Number
    - contextPath: AzureDevOps.PullRequest.pullRequestId
      description: The ID of the pull request.
      type: Number
    - contextPath: AzureDevOps.PullRequest.status
      description: The status of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.displayName
      description: The display name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.id
      description: The ID of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.uniqueName
      description: The unique name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.creationDate
      description: The creation date of the pull request.
      type: Date
    - contextPath: AzureDevOps.PullRequest.title
      description: The title of the pull request
      type: String
    - contextPath: AzureDevOps.PullRequest.description
      description: The description of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.sourceRefName
      description: The source branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.targetRefName
      description: The target branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.mergeStatus
      description: The current status of the pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.isDraft
      description: Draft / WIP pull request.
      type: Boolean
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.commitId
      description: The ID of the commit at the head of the source branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.url
      description: The REST URL for this resource.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.commitId
      description: The ID of the commit at the head of the target branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.url
      description: The REST URL for this resource.
      type: String
  - arguments:
    - default: false
      description: The name or ID of the project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The repository ID of the pull request's target branch. A repository ID can be obtained by running the 'azure-devops-repository-list' command.
      isArray: false
      name: repository_id
      required: true
      secret: false
    - default: false
      description: The ID of the pull request to update.
      isArray: false
      name: pull_request_id
      required: true
      secret: false
    - default: false
      description: The updated pull-request title.
      isArray: false
      name: title
      required: false
      secret: false
    - default: false
      description: The updated pull-request description.
      isArray: false
      name: description
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The updated pull-request status.
      isArray: false
      name: status
      predefined:
      - abandoned
      - completed
      - active
      required: false
      secret: false
    deprecated: false
    description: 'Update a pull request. At least one of the arguments: title, description, or status must be provided.'
    execution: false
    name: azure-devops-pull-request-update
    outputs:
    - contextPath: AzureDevOps.PullRequest.repository.project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.id
      description: The ID of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.name
      description: The name of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.url
      description: The URL of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.size
      description: The size of the repository.
      type: Number
    - contextPath: AzureDevOps.PullRequest.pullRequestId
      description: The ID of the pull request.
      type: Number
    - contextPath: AzureDevOps.PullRequest.status
      description: The status of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.displayName
      description: The display name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.id
      description: The ID of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.uniqueName
      description: The unique name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.creationDate
      description: The creation date of the pull request.
      type: Date
    - contextPath: AzureDevOps.PullRequest.title
      description: The title of the pull request
      type: String
    - contextPath: AzureDevOps.PullRequest.description
      description: The description of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.sourceRefName
      description: The source branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.targetRefName
      description: The target branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.mergeStatus
      description: The current status of the pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.isDraft
      description: Draft / WIP pull request.
      type: Boolean
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.commitId
      description: The ID of the commit at the head of the source branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.url
      description: The REST URL for this resource.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.commitId
      description: The ID of the commit at the head of the target branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.url
      description: The REST URL for this resource.
      type: String
  - arguments:
    - default: false
      description: The name or ID of the project which the pull requests belongs to.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The name of the repository pull request's target branch.
      isArray: false
      name: repository
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum  value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    deprecated: false
    description: Retrieve pull requests in repository.
    execution: false
    name: azure-devops-pull-request-list
    outputs:
    - contextPath: AzureDevOps.PullRequest.repository.project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.id
      description: The ID of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.name
      description: The name of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.url
      description: The URL of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.pullRequestId
      description: The ID of the pull request.
      type: Number
    - contextPath: AzureDevOps.PullRequest.status
      description: The status of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.displayName
      description: The display name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.id
      description: The ID of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.uniqueName
      description: The unique name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.creationDate
      description: The creation date of the pull request.
      type: Date
    - contextPath: AzureDevOps.PullRequest.title
      description: The title of the pull request
      type: String
    - contextPath: AzureDevOps.PullRequest.description
      description: The description of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.sourceRefName
      description: The source branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.targetRefName
      description: The target branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.mergeStatus
      description: The current status of the pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.isDraft
      description: Draft / WIP pull request.
      type: Boolean
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.commitId
      description: The ID of the commit at the head of the source branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.url
      description: The REST URL for this resource.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.commitId
      description: The ID of the commit at the head of the target branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.url
      description: The REST URL for this resource.
      type: String
  - arguments:
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    deprecated: false
    description: Retrieve all projects in the organization that the authenticated user has access to.
    execution: false
    name: azure-devops-project-list
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.state
      description: The state of the project.
      type: String
    - contextPath: AzureDevOps.Project.revision
      description: The revision number of the project.
      type: Number
    - contextPath: AzureDevOps.Project.visibility
      description: Indicates whom the project is visible to.
      type: String
    - contextPath: AzureDevOps.Project.lastUpdateTime
      description: Project last update time.
      type: Date
    - contextPath: AzureDevOps.Project.id
      description: The ID of the Project
      type: String
  - arguments:
    - default: false
      description: The name or ID of the project to which the repositories belong to.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      required: false
      secret: false
    deprecated: false
    description: Retrieve git repositories in the organization project.
    execution: false
    name: azure-devops-repository-list
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.Repository.id
      description: The ID of the repository.
      type: String
    - contextPath: AzureDevOps.Project.Repository.name
      description: The name of the repository.
      type: String
    - contextPath: AzureDevOps.Project.Repository.url
      description: The URL of the repository.
      type: String
    - contextPath: AzureDevOps.Project.Repository.size
      description: The size of the repository.
      type: Number
  - arguments:
    - default: false
      description: Users or organization query prefix. For example, If we want to retrieve information about the user 'Tom' we can enter the value of this argument as 'Tom' .
      isArray: false
      name: query
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      predefined:
      - ''
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    deprecated: false
    description: Query users that were added to organization projects.
    execution: false
    name: azure-devops-user-list
    outputs:
    - contextPath: AzureDevOps.User.entityType
      description: The type of the entity.
      type: String
    - contextPath: AzureDevOps.User.id
      description: The ID of the identity.
      type: String
    - contextPath: AzureDevOps.User.email
      description: The email address of the user.
      type: String
  - arguments:
    - default: false
      description: The name or ID of the project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The repository ID of the pull request's target branch. A repository ID can be obtained by running the 'azure-devops-repository-list'.
      isArray: false
      name: repository_id
      required: true
      secret: false
    - default: false
      description: The ID of the pull request to retrieve.
      isArray: false
      name: pull_request_id
      required: true
      secret: false
    deprecated: false
    description: Retrieve pull-request.
    execution: false
    name: azure-devops-pull-request-get
    outputs:
    - contextPath: AzureDevOps.PullRequest.repository.project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.id
      description: The ID of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.name
      description: The name of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.url
      description: The URL of the repository.
      type: String
    - contextPath: AzureDevOps.PullRequest.repository.size
      description: The size of the repository.
      type: Number
    - contextPath: AzureDevOps.PullRequest.pullRequestId
      description: The ID of the pull request.
      type: Number
    - contextPath: AzureDevOps.PullRequest.status
      description: The status of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.displayName
      description: The display name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.id
      description: The ID of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.createdBy.uniqueName
      description: The unique name of the pull request creator.
      type: String
    - contextPath: AzureDevOps.PullRequest.creationDate
      description: The creation date of the pull request.
      type: Date
    - contextPath: AzureDevOps.PullRequest.title
      description: The title of the pull request
      type: String
    - contextPath: AzureDevOps.PullRequest.description
      description: The description of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.sourceRefName
      description: The source branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.targetRefName
      description: The target branch of the pull request.
      type: String
    - contextPath: AzureDevOps.PullRequest.mergeStatus
      description: The current status of the pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.isDraft
      description: Draft / WIP pull request.
      type: Boolean
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.commitId
      description: The ID of the commit at the head of the source branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeSourceCommit.url
      description: The REST URL for this resource.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.commitId
      description: The ID of the commit at the head of the target branch at the time of the last pull request merge.
      type: String
    - contextPath: AzureDevOps.PullRequest.lastMergeTargetCommit.url
      description: The REST URL for this resource.
      type: String
  - arguments:
    - default: false
      description: The name of the project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The ID of the pipeline to retrieve.
      isArray: false
      name: pipeline_id
      required: true
      secret: false
    - default: false
      description: The ID of the pipeline run to retrieve.
      isArray: false
      name: run_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'False'
      description: Indicates if the command was scheduled.
      isArray: false
      name: scheduled
      predefined:
      - 'True'
      - 'False'
      required: false
      secret: false
    - default: false
      defaultValue: '30'
      description: Indicates how long to wait between commands execution (in seconds) when 'polling' argument is true. Minimum value is 10 seconds.
      isArray: false
      name: interval
      required: false
      secret: false
    - default: false
      defaultValue: '60'
      description: Indicates the time in seconds until the polling sequence timeouts.
      isArray: false
      name: timeout
      required: false
      secret: false
    deprecated: false
    description: Retrieve a pipeline run information.
    execution: false
    polling: true
    name: azure-devops-pipeline-run-get
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.id
      description: The ID of the pipeline.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.revision
      description: Pipeline revision number
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.name
      description: Pipeline repository name
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.folder
      description: Pipeline folder
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.state
      description: The run state.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.createdDate
      description: Run-pipeline creation date.
      type: Date
    - contextPath: AzureDevOps.Project.Pipeline.Run.url
      description: The URL of the run.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.run_id
      description: The ID of the run.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.Run.name
      description: The name of the run.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.name
      description: The result of the pipeline running. If the run is in progress, the default value is 'unknown'.
      type: String
  - arguments:
    - default: false
      description: The name of the organizaion project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: The ID of the pipeline which the runs belongs to.
      isArray: false
      name: pipeline_id
      required: true
      secret: false
    deprecated: false
    description: Retrieve pipeline runs list. The command retrieves up to the top 10000 runs for a particular pipeline.
    execution: false
    name: azure-devops-pipeline-run-list
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.id
      description: The ID of the pipeline.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.revision
      description: Pipeline revision number
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.name
      description: Pipeline repository name
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.folder
      description: Pipeline folder
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.state
      description: The run state.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.createdDate
      description: Run-pipeline creation date.
      type: Date
    - contextPath: AzureDevOps.Project.Pipeline.Run.url
      description: The URL of the run.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.run_id
      description: The ID of the run.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.Run.name
      description: The name of the run.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.Run.name
      description: The result of the pipeline running. If the run is in progress, the default value is 'unknown'.
      type: String
  - arguments:
    - default: false
      description: The name of the organizaion project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    deprecated: false
    description: Retrieve project pipelines list.
    execution: false
    name: azure-devops-pipeline-list
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.id
      description: The ID of the pipeline.
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.revision
      description: Pipeline revision number
      type: Number
    - contextPath: AzureDevOps.Project.Pipeline.name
      description: Pipeline repository name
      type: String
    - contextPath: AzureDevOps.Project.Pipeline.folder
      description: Pipeline folder
      type: String
  - arguments:
    - default: false
      description: The name of the organizaion project.
      isArray: false
      name: project
      required: true
      secret: false
    - default: false
      description: The name of the project repository.
      isArray: false
      name: repository
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: The page number of the results to retrieve. Minimum value is 1.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The number of results to retrieve. Minimum value is 1.
      isArray: false
      name: limit
      required: false
      secret: false
    deprecated: false
    description: Retrieve repository branches list.
    execution: false
    name: azure-devops-branch-list
    outputs:
    - contextPath: AzureDevOps.Project.name
      description: The name of the project.
      type: String
    - contextPath: AzureDevOps.Project.Repository.name
      description: The name of the repository.
      type: String
    - contextPath: AzureDevOps.Project.Repository.Branch.name
      description: The name of the branch
      type: String
    - contextPath: AzureDevOps.Project.Repository.Branch.creator
      description: Thr creator of the branch.
      type: String
  dockerimage: demisto/crypto:1.0.0.24380
  isremotesyncin: true
  isremotesyncout: true
  ismappable: true
  feed: false
  isfetch: true
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >
    # type: ignore




    import copy

    from requests import Response

    from typing import Callable


    INCIDENT_TYPE_NAME = "Azure DevOps"

    OUTGOING_MIRRORED_FIELDS = {'status': 'The status of the pull request.',
                                'title': 'The title of the pull request.',
                                'description': 'The description of the pull request.',
                                'project': 'The name of the project.',
                                'repository_id': 'The repository ID of the pull request target branch.',
                                'pull_request_id': 'the ID of the pull request'}


    class Client:
        """
        API Client to communicate with AzureDevOps.
        """

        def __init__(self, client_id: str, organization: str, verify: bool, proxy: bool):
            self.ms_client = MicrosoftClient(
                self_deployed=True,
                auth_id=client_id,
                token_retrieval_url='https://login.microsoftonline.com/organizations/oauth2/v2.0/token',
                grant_type=DEVICE_CODE,
                base_url=f'https://dev.azure.com/{organization}',
                verify=verify,
                proxy=proxy,
                scope='499b84ac-1321-427f-aa17-267ca6975798/user_impersonation offline_access')
            self.organization = organization

        def pipeline_run_request(self, project: str, pipeline_id: str, branch_name: str) -> dict:
            """
            Run a pipeline.
            Args:
                project (str): The name or the ID of the project.
                pipeline_id (str): The ID of the pipeline.
                branch_name (str): The name of the repository branch which run the pipeline.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}

            data = {"resources": {"repositories": {"self": {"refName": f'refs/heads/{branch_name}'}}}}

            url_suffix = f"{project}/_apis/pipelines/{pipeline_id}/runs"

            response = self.ms_client.http_request(method='POST',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   json_data=data,
                                                   resp_type='json')

            return response

        def user_add_request(self, user_email: str, account_license_type: str, group_type: str, project_id: str) -> dict:
            """
            Add a user, assign license and extensions and make them a member of a project group in an account.
            Args:
                user_email (str): The Email of the user to add to the organization.
                account_license_type (str): The type of account license (e.g. Express, Stakeholder etc.).
                group_type (str): Project Group (e.g. Contributor, Reader etc.).
                project_id (str): The ID of the project.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.3'}
            data = {
                "accessLevel": {
                    "accountLicenseType": account_license_type
                },
                "projectEntitlements": [
                    {
                        "group": {
                            "groupType": group_type
                        },
                        "projectRef": {
                            "id": project_id}
                    }
                ],
                "user": {
                    "principalName": user_email,
                    "subjectKind": "user"
                }
            }

            full_url = f"https://vsaex.dev.azure.com/{self.organization}/_apis/UserEntitlements"

            response = self.ms_client.http_request(method='POST',
                                                   full_url=full_url,
                                                   params=params,
                                                   json_data=data,
                                                   resp_type='json')

            return response

        def user_remove_request(self, user_id: str) -> Response:
            """
            Delete a user from the account.
            Args:
                user_id (str): The ID of the user to remove from the account.

            Returns:
                Response: API response from Azure.

            """
            params = {'api-version': '6.1-preview.3'}

            full_url = f'https://vsaex.dev.azure.com/{self.organization}/_apis/userentitlements/{user_id}'

            response = self.ms_client.http_request(method='DELETE',
                                                   full_url=full_url,
                                                   params=params,
                                                   resp_type='response')

            return response

        def pull_request_create_request(self, project: str, repository_id: str, source_branch: str,
                                        target_branch: str, title: str, description: str, reviewers: list) -> dict:
            """
            Create a new pull request in Azure DevOps.

            Args:
                project (str): The name or the ID of the project.
                repository_id (str): The repository ID of the pull request's target branch.
                source_branch (str): The name of the source branch of the pull request.
                target_branch (str): The name of the target branch of the pull request.
                title (str): The title of the pull request.
                description (str): The description of the pull request.
                reviewers (list): Pull-request reviewers IDs.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}
            data = {
                "sourceRefName": f'refs/heads/{source_branch}',
                "targetRefName": f'refs/heads/{target_branch}',
                "description": description,
                "reviewers": reviewers,
                "title": title
            }

            url_suffix = f'{project}/_apis/git/repositories/{repository_id}/pullrequests'

            response = self.ms_client.http_request(method='POST',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   json_data=data,
                                                   resp_type='json')

            return response

        def pull_request_update_request(self, project: str, repository_id: str, pull_request_id: str,
                                        title: str = None, description: str = None, status: str = None,
                                        last_merge_source_commit: dict = None) -> dict:
            """
            Update a pull request.
            Args:
                project (str): The name or the ID of the project.
                repository_id (str): The repository ID of the pull request's target branch.
                pull_request_id (str): The ID of the pull-request.
                title (str): The updated pull-request title.
                description (str): The updated pull-request description.
                status (str): The updated pull-request status.
                last_merge_source_commit (dict): Commit object at the head of the source branch
                                                 at the time of the last pull request merge.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}
            data = remove_empty_elements({"description": description, "status": status,
                                          "title": title, "LastMergeSourceCommit": last_merge_source_commit})

            url_suffix = f'{project}/_apis/git/repositories/{repository_id}/pullrequests/{pull_request_id}'

            response = self.ms_client.http_request(method='PATCH',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   json_data=data,
                                                   resp_type='json')

            return response

        def pull_requests_get_request(self, project: str, repository_id: str, pull_request_id: str) -> dict:
            """
            Retrieve pull request information request.
            Args:
                project (str): The name or the ID of the project.
                repository_id (str): The repository ID of the pull request's target branch.
                pull_request_id (str): The ID of the pull-request.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}

            url_suffix = f'{project}/_apis/git/repositories/{repository_id}/pullrequests/{pull_request_id}'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='json')

            return response

        def pull_requests_list_request(self, project: str, repository: str, skip: int = None, limit: int = None) -> dict:
            """
            Retrieve pull requests in repository.
            Args:
                project (str): The name or the ID of the project.
                repository (str): The repository name of the pull request's target branch.
                skip (int): The number of results to skip.
                limit (int): The number of results to retrieve.

            Returns:
                dict: API response from Azure.

            """
            params = remove_empty_elements({'api-version': '6.1-preview.1', "$skip": skip, "$top": limit})

            url_suffix = f'{project}/_apis/git/repositories/{repository}/pullrequests/'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='json')

            return response

        def project_list_request(self, skip: int = None, limit: int = None) -> dict:
            """
            Retrieve all projects in the organization that the authenticated user has access to.
            Args:
                skip (int): The number of results to skip.
                limit (int): The number of results to retrieve.

            Returns:
                dict: API response from Azure.

            """

            params = remove_empty_elements({'api-version': '6.1-preview.4', "$skip": skip, "$top": limit})

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix='_apis/projects',
                                                   params=params,
                                                   resp_type='json')

            return response

        def repository_list_request(self, project: str) -> dict:
            """
            Retrieve git repositories in the organization project.
            Args:
                project (str): The name of the project to which the repositories belong to.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}

            url_suffix = f'{project}/_apis/git/repositories'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='json')

            return response

        def users_query_request(self, query: str) -> dict:
            """
            Query users  in the organization.
            Args:
                query (str): Users or organization query prefix.
                             For example, If we want to retrieve information about the user 'Tom'
                             we can enter the value of this argument as 'Tom'.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}

            url_suffix = '_apis/IdentityPicker/Identities'

            data = {"query": query, "identityTypes": ["user", "group"], "operationScopes": ["ims", "source"],
                    "properties": ["DisplayName", "IsMru", "ScopeName", "SamAccountName", "Active", "SubjectDescriptor",
                                   "Department", "JobTitle", "Mail", "MailNickname", "PhysicalDeliveryOfficeName",
                                   "SignInAddress", "Surname", "Guest", "TelephoneNumber", "Manager", "Description"]}

            response = self.ms_client.http_request(method='POST',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   json_data=data,
                                                   resp_type='json')

            return response

        def get_pipeline_run_request(self, project: str, pipeline_id: str, run_id: str) -> dict:
            """
            Retrieve pipeline run information.
            Args:
                project (str): The name of the project.
                pipeline_id (str): The ID of the pipeline to retrieve.
                run_id (str): The ID of the pipeline run to retrieve.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}

            url_suffix = f'{project}/_apis/pipelines/{pipeline_id}/runs/{run_id}'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='json')

            return response

        def pipeline_run_list_request(self, project: str, pipeline_id: str) -> dict:
            """
            Retrieve project pipeline runs list.
            Args:
                project (str): The name of the project.
                pipeline_id (str): The ID of the pipeline to retrieve.

            Returns:
                dict: API response from Azure.

            """
            params = {'api-version': '6.1-preview.1'}

            url_suffix = f'{project}/_apis/pipelines/{pipeline_id}/runs'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='json')

            return response

        def pipeline_list_request(self, project: str, limit: int = None,
                                  continuation_token: str = None) -> Response:
            """
            Retrieve project pipelines list.
            Args:
                project (str): The name of the project.
                limit (int): The number of results to retrieve.
                continuation_token (str): A continuation token from a previous request, to retrieve the next page of results.

            Returns:
                Response: API response from Azure.

            """
            params = remove_empty_elements({'api-version': '6.1-preview.1',
                                            '$top': limit,
                                            'continuationToken': continuation_token})

            url_suffix = f'{project}/_apis/pipelines'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='response')

            return response

        def branch_list_request(self, project: str, repository: str, limit: int = None,
                                continuation_token: str = None) -> Response:
            """
            Retrieve repository branches list.
            Args:
                project (str): The name of the project.
                repository (str): The name of the project repository.
                limit (int): The number of results to retrieve.
                continuation_token (str): A continuation token from a previous request, to retrieve the next page of results.

            Returns:
                Response: API response from Azure.

            """
            params = remove_empty_elements({'api-version': '6.1-preview.1',
                                            '$top': limit,
                                            'continuationToken': continuation_token,
                                            'filter': 'heads'})

            url_suffix = f'{project}/_apis/git/repositories/{repository}/refs'

            response = self.ms_client.http_request(method='GET',
                                                   url_suffix=url_suffix,
                                                   params=params,
                                                   resp_type='response')

            return response


    def generate_pipeline_run_output(response: dict, project: str) -> dict:
        """
        Create XSOAR context output for retrieving pipeline run information.
        Args:
            response (dict): API response from Azure.
            project (str): The name of the pipeline project.

        Returns:
            dict: XSOAR command outputs.

        """
        creation_date = FormatIso8601(arg_to_datetime(response.get('createdDate')))

        run_data = {"state": response.get('state'),
                    "createdDate": creation_date,
                    "url": response.get('url'),
                    "run_id": response.get('id'),
                    "name": response.get('name'),
                    "result": response.get('result', 'unknown')
                    }

        pipeline_data = {"id": dict_safe_get(response, ['pipeline', 'id']),
                         "name": dict_safe_get(response, ['pipeline', 'name']),
                         "revision": dict_safe_get(response, ['pipeline', 'revision']),
                         "folder": dict_safe_get(response, ['pipeline', 'folder']),
                         "Run": run_data
                         }

        outputs = {"name": project, "Pipeline": pipeline_data}

        return outputs


    def filter_pipeline_run_table(run: dict) -> dict:
        """
        Filter pipeline-run required information for representing to the user.
        Args:
            run (dict): Pipeline-run information.

        Returns:
            dict: Filtered pipeline-run information.

        """
        creation_date = FormatIso8601(arg_to_datetime(run.get('createdDate')))

        return {
            "pipeline_id": dict_safe_get(run, ['pipeline', 'id']),
            "run_state": run.get('state'),
            "creation_date": creation_date,
            "run_id": run.get('id'),
            "result": run.get('result', 'unknown')
        }


    def generate_pipeline_run_readable_information(response: Union[dict, list],
                                                   message: str = "Pipeline Run Information:") -> str:
        """
        Create XSOAR readable output for retrieving pipe-line information.
        Args:
            response (dict/list): API response from Azure.
            message (str): XSOAR readable outputs table message.

        Returns:
            str: XSOAR readable outputs.

        """

        if not isinstance(response, list):
            response = [response]

        readable_table = []
        for run in response:
            readable_table.append(filter_pipeline_run_table(run))

        readable_output = tableToMarkdown(
            message,
            readable_table,
            headers=['pipeline_id', 'run_state', 'creation_date', 'run_id', 'result'],
            headerTransform=string_to_table_header
        )

        return readable_output


    def pipeline_run_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Run a pipeline.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        pipeline_id = args['pipeline_id']
        branch_name = args['branch_name']
        should_poll = argToBoolean(args.get('polling', False))

        # create new pipeline-run.
        response = client.pipeline_run_request(project, pipeline_id, branch_name)
        state = response.get('state')

        # Running polling flow
        if should_poll and state != 'completed':
            interval = arg_to_number(args.get('interval', 30))
            timeout = arg_to_number(args.get('timeout', 60))
            run_id = response.get('id')
            polling_args = {
                'run_id': run_id,
                'interval': interval,
                'scheduled': True,
                'timeout': timeout,
                **args
            }
            # Schedule poll for the piplenine status
            scheduled_command = ScheduledCommand(
                command='azure-devops-pipeline-run-get',
                next_run_in_seconds=interval,
                timeout_in_seconds=timeout,
                args=polling_args)

            # Result with scheduled_command only - no update to the war room
            command_results = CommandResults(scheduled_command=scheduled_command)

        # Polling flow is done or user did not trigger the polling flow (should_poll = False)
        else:

            outputs = generate_pipeline_run_output(response, project)
            readable_output = generate_pipeline_run_readable_information(response)
            command_results = CommandResults(
                readable_output=readable_output,
                outputs_prefix='AzureDevOps.Project',
                outputs_key_field='name',
                outputs=outputs,
                raw_response=response
            )

        return command_results


    def user_add_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Add a user, assign license and extensions and make them a member of a project group in an account.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        user_email = args['user_email']
        account_license_type = args['account_license_type']
        group_type = args['group_type']
        project_id = args['project_id']

        response = client.user_add_request(user_email, account_license_type, group_type, project_id)

        if not dict_safe_get(response, ['operationResult', 'isSuccess']):
            error = dict_safe_get(response, ['operationResult', 'errors'])
            if not isinstance(error, list) or not error:
                raise ValueError('Error occurred. API response is not in the appropriate format.')

            error_message = error[0].get('value')
            raise ValueError(error_message)

        outputs = {
            "id": dict_safe_get(response, ['operationResult', 'userId']),
            "accountLicenseType": dict_safe_get(response,
                                                ['operationResult', 'result', 'accessLevel', 'accountLicenseType']),
            "lastAccessedDate": dict_safe_get(response, ['operationResult', 'result', 'lastAccessedDate']),
        }

        readable_output = tableToMarkdown(
            "User Information:",
            outputs,
            headers=['id', 'accountLicenseType', 'lastAccessedDate'],
            headerTransform=pascalToSpace
        )

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.User',
            outputs_key_field='id',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def user_remove_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Remove the user from all project memberships.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        user_id = args['user_id']

        client.user_remove_request(user_id)

        readable_output = f'User {user_id} was successfully removed from the organization.'
        command_results = CommandResults(
            readable_output=readable_output
        )

        return command_results


    def generate_pull_request_output(raw_response: Union[dict, list]) -> dict:
        """
        Create XSOAR context output for retrieving pull-request information.
        Args:
            raw_response (dict/list): API response from Azure.

        Returns:
            dict: XSOAR command outputs.

        """

        if not isinstance(raw_response, list):
            raw_response = [raw_response]

        if not raw_response:
            return []

        project = {"name": dict_safe_get(raw_response[0], ['repository', 'project', 'name'])}

        repository_id = dict_safe_get(raw_response[0], ['repository', 'id'])
        name = dict_safe_get(raw_response[0], ['repository', 'name'])
        url = dict_safe_get(raw_response[0], ['repository', 'url'])
        size = dict_safe_get(raw_response[0], ['repository', 'size'])

        repository_data = {"id": repository_id, "name": name, "url": url, "size": size, "PullRequest": []}

        for response in raw_response:
            pr_id = response.get('pullRequestId')
            status = response.get('status')

            creation_date = FormatIso8601(arg_to_datetime(response.get('creationDate')))
            title = response.get('title')
            description = response.get('description')
            source = response.get('sourceRefName')
            target = response.get('targetRefName')
            merge_status = response.get('mergeStatus')
            is_draft = response.get('isDraft')

            pr_data = {"Id": pr_id, "status": status, "creationDate": creation_date, "title": title,
                       "description": description, "sourceRefName": source, "targetRefName": target,
                       "mergeStatus": merge_status, "isDraft": is_draft}

            creator_display = dict_safe_get(response, ['createdBy', 'displayName'])
            creator_id = dict_safe_get(response, ['createdBy', 'id'])
            creator_unique_name = dict_safe_get(response, ['createdBy', 'uniqueName'])

            created_by = {"displayName": creator_display, "id": creator_id, "uniqueName": creator_unique_name}
            pr_data["CreatedBy"] = created_by

            source_commit_id = dict_safe_get(response, ['lastMergeSourceCommit', 'commitId'])
            source_commit_url = dict_safe_get(response, ['lastMergeSourceCommit', 'url'])
            source_data = {"commitId": source_commit_id, "url": source_commit_url}
            pr_data["LastMergeSourceCommit"] = source_data

            target_commit_id = dict_safe_get(response, ['lastMergeTargetCommit', 'commitId'])
            target_commit_url = dict_safe_get(response, ['lastMergeTargetCommit', 'url'])
            target_data = {"commitId": target_commit_id, "url": target_commit_url}
            pr_data["LastMergeTargetCommit"] = target_data

            reviewers = []

            for reviewer in response.get("reviewers", []):
                data = {"reviewerUrl": reviewer.get('reviewerUrl'), "vote": reviewer.get('vote'),
                        "hasDeclined": reviewer.get('hasDeclined'), "isFlagged": reviewer.get('isFlagged'),
                        "displayName": reviewer.get('displayName'), "id": reviewer.get('id'),
                        "uniqueName": reviewer.get('uniqueName')}

                reviewers.append(data)

            pr_data["Reviewers"] = reviewers

            repository_data["PullRequest"].append(pr_data)

        project["Repository"] = repository_data

        return project


    def filter_pull_request_table(pull_request: dict) -> dict:
        """
        Filter pull-request required information for representing to the user.
        Args:
            pull_request (dict): Pull-request information.

        Returns:
            dict: Filtered pull-request information.

        """

        creation_date = FormatIso8601(arg_to_datetime(pull_request.get('creationDate')))

        return {
            "repository_id": dict_safe_get(pull_request, ['repository', 'id']),
            "repository_name": dict_safe_get(pull_request, ['repository', 'name']),
            "project_id": dict_safe_get(pull_request, ['repository', 'project', 'id']),
            "project_name": dict_safe_get(pull_request, ['repository', 'project', 'name']),
            "pull_request_id": pull_request.get('pullRequestId'),
            "status": pull_request.get('status'),
            "title": pull_request.get('title'),
            "description": pull_request.get('description'),
            "created_by": dict_safe_get(pull_request, ['createdBy', 'displayName']),
            "creation_date": creation_date
        }


    def generate_pull_request_readable_information(response: Union[dict, list],
                                                   message: str = "Pull Request Information:") -> str:
        """
        Create XSOAR readable output for retrieving pull-request information.
        Args:
            response (dict/list): API response from Azure.
            message (str): XSOAR readable outputs table message.

        Returns:
            str: XSOAR readable outputs.

        """

        if not isinstance(response, list):
            response = [response]

        readable_table = []
        for pr in response:
            readable_table.append(filter_pull_request_table(pr))

        readable_output = tableToMarkdown(
            message,
            readable_table,
            headers=['title', 'description', 'created_by', 'pull_request_id',
                     'repository_name', 'repository_id', 'project_name', 'project_id', 'creation_date'],
            headerTransform=string_to_table_header
        )

        return readable_output


    def pull_request_create_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Create a new pull-request.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        repository_id = args['repository_id']
        source_branch = args['source_branch']
        target_branch = args['target_branch']
        title = args['title']
        description = args['description']

        reviewers_ids = argToList(args['reviewers_ids'])

        reviewers = [{"id": reviewer} for reviewer in reviewers_ids]

        response = client.pull_request_create_request(
            project, repository_id, source_branch, target_branch, title, description, reviewers)

        outputs = copy.deepcopy(response)
        outputs['creationDate'] = arg_to_datetime(response.get('creationDate')).isoformat()

        readable_output = generate_pull_request_readable_information(response)

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.PullRequest',
            outputs_key_field='pullRequestId',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def pull_request_update_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Update a pull request.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        repository_id = args['repository_id']
        pull_request_id = args['pull_request_id']
        title = args.get('title')
        description = args.get('description')
        status = args.get('status')

        if not (title or description or status):
            raise Exception('At least one of the arguments: title, description, or status must be provided.')

        last_merge_source_commit = None
        if status == "completed":
            pr_data = client.pull_requests_get_request(project, repository_id, pull_request_id)
            last_merge_source_commit = pr_data.get("lastMergeSourceCommit")

        response = client.pull_request_update_request(
            project, repository_id, pull_request_id, title, description, status, last_merge_source_commit)

        outputs = copy.deepcopy(response)
        outputs['creationDate'] = arg_to_datetime(response.get('creationDate')).isoformat()

        readable_output = generate_pull_request_readable_information(response)

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.PullRequest',
            outputs_key_field='pullRequestId',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def pull_request_get_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve pull-request information.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        repository_id = args['repository_id']
        pull_request_id = args['pull_request_id']

        response = client.pull_requests_get_request(project, repository_id, pull_request_id)

        outputs = copy.deepcopy(response)
        outputs['creationDate'] = arg_to_datetime(response.get('creationDate')).isoformat()

        readable_output = generate_pull_request_readable_information(response)

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.PullRequest',
            outputs_key_field='pullRequestId',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def pull_requests_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve pull requests in repository.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        repository = args['repository']
        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        offset = (page - 1) * limit

        response = client.pull_requests_list_request(project, repository, offset, limit)

        readable_message = f'Pull Request List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'

        outputs = copy.deepcopy(response.get('value'))
        for pr in outputs:
            pr['creationDate'] = arg_to_datetime(pr.get('creationDate')).isoformat()

        readable_output = generate_pull_request_readable_information(response.get('value'), message=readable_message)

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.PullRequest',
            outputs_key_field='pullRequestId',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def project_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve all projects in the organization that the authenticated user has access to.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        offset = (page - 1) * limit
        response = client.project_list_request(offset, limit)
        readable_message = f'Project List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'
        print(response)

        outputs = copy.deepcopy(response.get('value', []))
        output_headers = ['name', 'id', 'state', 'revision', 'visibility', 'lastUpdateTime']

        for project in outputs:
            project['lastUpdateTime'] = arg_to_datetime(project.get('lastUpdateTime')).isoformat()

        print("1")
        readable_output = tableToMarkdown(
            readable_message,
            outputs,
            headers=output_headers,
            headerTransform=pascalToSpace
        )

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.Project',
            outputs_key_field='id',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def repository_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve git repositories in the organization project.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']

        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        start = (page - 1) * limit
        end = start + limit

        readable_message = f'Repositories List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'

        response = client.repository_list_request(project)

        repository_data = []

        outputs = {}

        if response.get('count') and response.get('count') >= start:
            min_index = min(response.get('count'), end)
            for repo in response.get('value')[start:min_index]:
                data = {"id": repo.get('id'), "name": repo.get("name"), "url": repo.get("url"), "size": repo.get("size")}
                repository_data.append(data)

            outputs = {"name": dict_safe_get(response.get('value')[start], ['project', 'name']),
                       "Repository": repository_data}

        readable_data = copy.deepcopy(repository_data)
        for repo in readable_data:
            repo["size (Bytes)"] = repo.pop("size")

        readable_output = tableToMarkdown(
            readable_message,
            readable_data,
            headers=['id', 'name', 'size (Bytes)'],
            headerTransform=pascalToSpace
        )

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.Project',
            outputs_key_field='name',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def users_query_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Query users in the organization.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        query = args['query']
        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        start = (page - 1) * limit
        end = start + limit

        readable_message = f'Users List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'

        response = client.users_query_request(query)

        outputs = []
        results = response.get('results')
        if results and len(results) > 0:
            identities = results[0].get('identities')
            if len(identities) >= start:
                min_index = min(len(identities), end)
                for identity in identities[start:min_index]:
                    if identity.get("localDirectory") == "vsd":
                        outputs.append({"entityType": identity.get("entityType"), "id": identity.get("localId"),
                                        "email": identity.get("signInAddress")})

        readable_output = tableToMarkdown(
            readable_message,
            outputs,
            headers=['email', 'entityType', 'id'],
            headerTransform=pascalToSpace
        )

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.User',
            outputs_key_field='id',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def pipeline_run_get_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve pipeline run information.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """

        project = args['project']
        pipeline_id = args['pipeline_id']
        run_id = args['run_id']
        scheduled = argToBoolean(args.get('scheduled', False))
        response = client.get_pipeline_run_request(project, pipeline_id, run_id)

        # This is part of a scheduled command run
        state = response.get("state")

        if scheduled and state != 'completed':
            # schedule next poll
            scheduled_command = ScheduledCommand(
                command='azure-devops-pipeline-run-get',
                next_run_in_seconds=arg_to_number(args.get('interval', 30)),
                timeout_in_seconds=arg_to_number(args.get('timeout', 60)),
                args=args,
            )

            # result with scheduled_command only - no update to the war room
            command_results = CommandResults(scheduled_command=scheduled_command)

        else:
            outputs = generate_pipeline_run_output(response, project)
            readable_output = generate_pipeline_run_readable_information(response)
            command_results = CommandResults(
                readable_output=readable_output,
                outputs_prefix='AzureDevOps.Project',
                outputs_key_field='name',
                outputs=outputs,
                raw_response=response
            )

        return command_results


    def pipeline_run_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve project pipeline runs list. The command retrieves up to the top 10000 runs for a particular pipeline.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        pipeline_id = args['pipeline_id']

        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        start = (page - 1) * limit
        end = start + limit

        readable_message = f'Pipeline runs List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'
        readable_output = readable_message
        response = client.pipeline_run_list_request(project, pipeline_id)

        outputs = {"name": project, "Pipeline": []}
        if response.get('count') and response.get('count') >= start:
            min_index = min(response.get('count'), end)
            for run in response.get('value')[start:min_index]:
                data = generate_pipeline_run_output(run, project)
                outputs["Pipeline"].append(data.get("Pipeline"))

            readable_output = generate_pipeline_run_readable_information(response.get('value')[start:min_index],
                                                                         message=readable_message)

        command_results = CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.Project',
            outputs_key_field='name',
            outputs=outputs,
            raw_response=response
        )

        return command_results


    def get_pagination_continuation_token(limit: int, page: int, client_request: Callable, args: dict) -> str:
        """
        Get next continuation token for request pagination.
        Args:
            limit (): Number of elements to retrieve.
            page (): Page number.
            client_request (Callable): Client request function.
            args (dict): Request function arguments.

        Returns:
            str: Continuation token

        """
        offset = limit * (page - 1)
        response = client_request(limit=offset, **args)
        return response.headers.get('x-ms-continuationtoken')


    def pipeline_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve project pipelines list.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """

        project = args['project']

        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')
        readable_message = f'Pipelines List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        continuation_token = None
        outputs = {"name": project, "Pipeline": []}
        if page > 1:
            continuation_token = get_pagination_continuation_token(limit=limit, page=page,
                                                                   client_request=client.pipeline_list_request,
                                                                   args={"project": project})

            if not continuation_token:
                return CommandResults(
                    readable_output=readable_message,
                    outputs_prefix='AzureDevOps.Project',
                    outputs=outputs,
                    raw_response=[]
                )

        response = client.pipeline_list_request(project, limit, continuation_token).json()

        for pipeline in response.get("value"):
            pipeline_data = {"id": pipeline.get("id"),
                             "name": pipeline.get("name"),
                             "revision": pipeline.get("revision"),
                             "folder": pipeline.get("folder"),
                             }

            outputs["Pipeline"].append(pipeline_data)

        readable_output = tableToMarkdown(
            readable_message,
            outputs.get("Pipeline"),
            headers=['id', 'name', 'revision', 'folder'],
            headerTransform=string_to_table_header
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.Project',
            outputs_key_field='name',
            outputs=outputs,
            raw_response=response
        )


    def branch_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve repository branches list.
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.

        """
        project = args['project']
        repository = args['repository']

        page = arg_to_number(args.get('page') or '1')
        limit = arg_to_number(args.get('limit') or '50')
        readable_message = f'Branches List:\n Current page size: {limit}\n Showing page {page} out others that may exist.'

        if page < 1 or limit < 1:
            raise Exception('Page and limit arguments must be greater than 1.')

        outputs = {"name": project, "Repository": {"name": repository, "Branch": []}}
        continuation_token = None
        if page > 1:
            continuation_token = get_pagination_continuation_token(limit=limit, page=page,
                                                                   client_request=client.branch_list_request,
                                                                   args={"project": project, "repository": repository})

            if not continuation_token:
                return CommandResults(
                    readable_output=readable_message,
                    outputs_prefix='AzureDevOps.Project',
                    outputs_key_field='name',
                    outputs=outputs,
                    raw_response=[]
                )

        response = client.branch_list_request(project, repository, limit, continuation_token).json()

        for branch in response.get("value"):
            branch_data = {"name": branch.get("name").replace("refs/heads/", ""),
                           "creator": dict_safe_get(branch, ['creator', 'displayName'])}

            outputs["Repository"]["Branch"].append(branch_data)

        readable_output = tableToMarkdown(
            readable_message,
            dict_safe_get(outputs, ["Repository", "Branch"]),
            headers=['name', 'creator'],
            headerTransform=string_to_table_header
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureDevOps.Project',
            outputs_key_field='name',
            outputs=outputs,
            raw_response=response
        )


    # --Mirroring Commands--

    def get_update_args(delta: dict, data: dict) -> dict:
        """
        Change the updated field names to fit the pull-request update command.
        Args:
            delta (dict): Updated fields from XSOAR incident mirroring.
            data (dict): Incident source fields from XSOAR incident mirroring.

        Returns:
            dict: Updated argument information.

        """
        arguments = {'project': data.get('project'), 'repository_id': data.get('repository_id'),
                     'pull_request_id': data.get('pull_request_id'), 'title': delta.get('title'),
                     'description': delta.get('description'), 'status': delta.get('status')}

        return arguments


    def update_remote_system_command(client: Client, args: Dict[str, Any]) -> str:
        """
        Pushes local changes to the remote system
        Args:
            client (Client): Azure DevOps API client.
            args (dict): Command arguments from XSOAR.
                            args['data']: the data to send to the remote system
                            args['entries']: the entries to send to the remote system
                            args['incident_changed']: boolean telling us if the local incident indeed changed or not
                            args['remote_incident_id']: the remote incident id

        Returns:
            str: The new ID of the updated incident.

        """

        remote_args = UpdateRemoteSystemArgs(args)

        if remote_args.delta:
            demisto.debug(f'Got the following delta keys {str(list(remote_args.delta.keys()))} to update Azure DevOps '
                          f'incident {remote_args.remote_incident_id}')
        else:
            demisto.debug('There is no delta fields in Azure DevOps\n')
        try:
            if remote_args.incident_changed:
                update_args = get_update_args(remote_args.delta, remote_args.data)
                demisto.debug(f'Sending incident with remote ID [{remote_args.remote_incident_id}] to Azure DevOps\n')
                pull_request_update_command(client, update_args)

            else:
                demisto.debug(f'Skipping updating remote incident fields [{remote_args.remote_incident_id}] '
                              f'as it is not new nor changed')

        except Exception as e:
            demisto.info(f"Error in Azure DevOps outgoing mirror for incident {remote_args.remote_incident_id} \n"
                         f"Error message: {str(e)}")

        finally:
            return remote_args.remote_incident_id


    def get_mapping_fields_command() -> GetMappingFieldsResponse:
        """
        Returns the list of fields for an incident type.
        """

        incident_type_scheme = SchemeTypeMapping(type_name=INCIDENT_TYPE_NAME)

        demisto.debug(f'Collecting incident mapping for incident type - "{INCIDENT_TYPE_NAME}"')

        for argument, description in OUTGOING_MIRRORED_FIELDS.items():
            incident_type_scheme.add_field(name=argument, description=description)

        mapping_response = GetMappingFieldsResponse()

        mapping_response.add_scheme_type(incident_type_scheme)

        return mapping_response


    # --Authorization Commands--


    def start_auth(client) -> CommandResults:
        result = client.ms_client.start_auth('!azure-devops-auth-complete')
        return CommandResults(readable_output=result)


    def complete_auth(client) -> str:
        client.ms_client.get_access_token()
        return 'Authorization completed successfully.'


    def test_connection(client) -> str:
        try:
            client.ms_client.get_access_token()
        except Exception as err:
            return f'Authorization Error: \n{err}'
        return 'Success!'


    def reset_auth() -> str:
        set_integration_context({})
        return 'Authorization was reset successfully. Run **!azure-devops-auth-start** to start' \
               ' the authentication process.'


    def parse_incident(pull_request: dict, integration_instance: str) -> dict:
        """
        Parse pull request to XSOAR Incident.
        Args:
            pull_request (dict): Pull-request information.
            integration_instance (str): The name of the integration instance.

        Returns:
            dict: XSOAR Incident.

        """
        incident_data = filter_pull_request_table(pull_request)

        incident_data['mirror_direction'] = 'Out'
        incident_data['mirror_instance'] = integration_instance

        incident = {'name': "Azure DevOps - Pull request ID: " + str(incident_data.get('pull_request_id')),
                    'rawJSON': json.dumps(incident_data)}

        return incident


    def count_active_pull_requests(project: str, repository: str, client: Client, first_fetch: datetime = None) -> int:
        """
        Count the number of active pull-requests in the repository.
        Args:
            project (str): The name of the project which the pull requests belongs to.
            repository (str): The repository name of the pull request's target branch.
            client (Client): Azure DevOps API client.
            first_fetch (datetime): Indicated the oldest pull-request time.

        Returns:
            int: Pull-requests number.

        """
        count = 0
        limit = 100
        max_iterations = 100

        while max_iterations > 0:
            max_iterations -= 1
            response = client.pull_requests_list_request(project, repository, skip=count, limit=limit)
            if response.get("count") == 0:
                break
            if first_fetch:
                last_pr_date = arg_to_datetime(
                    response.get("value")[response.get("count") - 1].get('creationDate').replace('Z', ''))
                if last_pr_date < first_fetch:  # If the oldest pr in the result is older than 'first_fetch' argument.
                    for pr in response.get("value"):
                        if arg_to_datetime(pr.get('creationDate').replace('Z', '')) > first_fetch:
                            count += 1
                        else:  # Stop counting
                            max_iterations = -1
                            break
                else:
                    count += response.get("count")
            else:
                count += response.get("count")

        return count


    def get_last_fetch_incident_index(project: str, repository: str, client: Client, last_id: int):
        """
        Retrieve the index of the last fetched pull-request.
        index if the pull request is no active anymore - return -1.
        Args:
            project (str): The name of the project which the pull requests belongs to.
            repository (str): The repository name of the pull request's target branch.
            client (Client): Azure DevOps API client.
            last_id (int): Last fetch pull-request ID.

        Returns:
            int: Last fetched pull-request.

        """
        count = 0
        limit = 100
        max_iterations = 100

        while max_iterations > 0:
            response = client.pull_requests_list_request(project, repository, skip=count, limit=limit)
            if response.get("count") == 0:
                break

            pr_ids = [pr.get('pullRequestId') for pr in response.get('value')]
            if last_id in pr_ids:
                return pr_ids.index(last_id) + count
            else:
                if max(pr_ids) < last_id:
                    break
                count += response.get("count")
                max_iterations -= 1

        return -1


    def get_closest_index(project: str, repository: str, client: Client, last_id: int) -> int:
        """
        This method used for find the closest index to the last fetched pull-request ID.
        This method is used to find the ID of the next pull-request after the last_id.
        The correctness of the method stems from the fact that the pull-request ID is an incremental number,
        and from the way the pull-requests are retrieved from the API.
        Args:
            project (str): The name of the project which the pull requests belongs to.
            repository (str): The repository name of the pull request's target branch.
            client (Client): Azure DevOps API client.
            last_id (int): Last fetch pull-request ID.

        Returns:
            int: Closest index to the last fetched pull-request ID.
        """
        count = 0
        limit = 100
        max_iterations = 100

        while max_iterations > 0:
            response = client.pull_requests_list_request(project, repository, skip=count, limit=limit)

            if response.get("count") == 0:
                break

            pr_ids = [pr.get('pullRequestId') for pr in response.get('value')]
            min_id = min(pr_ids)
            max_id = max(pr_ids)

            if min_id < last_id < max_id:  # The closest index is in this page.
                closest_id = -1
                for pr_id in pr_ids:
                    if pr_id < last_id:
                        break
                    closest_id = pr_id

                return pr_ids.index(closest_id) + count

            elif max_id < last_id:  # The closest index is in the previous page.
                return count - 1
            else:
                count += response.get("count")
                max_iterations -= 1

            if response.get("count") == 0:
                break

        return -1


    def is_new_pr(project: str, repository: str, client: Client, last_id: int) -> bool:
        """
        Validate if there is new pull-request in the repository.
        Args:
            project (str): The name of the project which the pull requests belongs to.
            repository (str): The repository name of the pull request's target branch.
            client (Client): Azure DevOps API client.
            last_id (int): Last fetch pull-request ID.

        Returns:
            bool: True if there is new pull-request in the repository, otherwise False.

        """
        response = client.pull_requests_list_request(project, repository, skip=0, limit=1)
        num_prs = response.get("count", 0)
        last_pr_id = response.get('value')[0].get('pullRequestId', 0) if len(response.get('value')) > 0 else None
        if num_prs == 0 or last_pr_id <= last_id:
            demisto.debug(f'Number of PRs is: {num_prs}. Last fetched PR id: {last_pr_id}')
            return False

        return True


    def fetch_incidents(client, project: str, repository: str, integration_instance: str, max_fetch: int = 50,
                        first_fetch: str = None) -> None:
        """
        Fetch new active pull-requests from repository.
        Args:
            client (Client): Azure DevOps API client.
            project (str): The name of the project which the pull requests belongs to.
            repository (str): The repository name of the pull request's target branch.
            integration_instance (str): The name of the integration instance.
            max_fetch (int): Maximum incidents for one fetch.
            first_fetch (str): Indicated the date from which to start fetching pull-requests.

        """
        last_run = demisto.getLastRun()

        last_id = last_run.get("last_id", None)

        if last_id:
            if not is_new_pr(project, repository, client, last_id):  # There is no new pr
                demisto.incidents([])
                return

            last_id_index = get_last_fetch_incident_index(project, repository, client, last_id)

            if last_id_index == -1:  # Last pull-request state is no-active
                last_id_index = get_closest_index(project, repository, client, last_id) + 1

        else:  # In the first iteration of fetch-incident ,
            # we have to find the oldest active pull-request index.
            if first_fetch:
                first_fetch = arg_to_datetime(first_fetch)
            last_id_index = count_active_pull_requests(project, repository, client, first_fetch)

        skip = last_id_index - max_fetch
        if skip <= 0:
            skip = 0
            max_fetch = last_id_index

        response = client.pull_requests_list_request(project, repository, skip=skip, limit=max_fetch)

        pr_data = reversed(response.get("value"))

        if pr_data:
            incidents = []
            for pr in pr_data:
                incidents.append(parse_incident(pr, integration_instance))
                last = pr.get('pullRequestId')

            demisto.setLastRun({
                'last_id': last
            })

            demisto.incidents(incidents)


    def main() -> None:
        params: Dict[str, Any] = demisto.params()
        args: Dict[str, Any] = demisto.args()
        client_id = params['client_id']
        organization = params['organization']
        verify_certificate: bool = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        is_mirroring = params.get('is_mirroring', False)

        command = demisto.command()
        demisto.debug(f'Command being called is {command}')

        try:
            requests.packages.urllib3.disable_warnings()
            client: Client = Client(
                client_id=client_id,
                organization=organization,
                verify=verify_certificate,
                proxy=proxy)

            if command == 'azure-devops-auth-start':
                return_results(start_auth(client))

            elif command == 'azure-devops-auth-complete':
                return_results(complete_auth(client))

            elif command == 'azure-devops-auth-test':
                return_results(test_connection(client))

            elif command == 'azure-devops-user-add':
                return_results(user_add_command(client, args))

            elif command == 'azure-devops-user-remove':
                return_results(user_remove_command(client, args))

            elif command == 'azure-devops-pull-request-create':
                return_results(pull_request_create_command(client, args))

            elif command == 'azure-devops-pull-request-get':
                return_results(pull_request_get_command(client, args))

            elif command == 'azure-devops-pull-request-update':
                return_results(pull_request_update_command(client, args))

            elif command == 'azure-devops-pull-request-list':
                return_results(pull_requests_list_command(client, args))

            elif command == 'azure-devops-project-list':
                return_results(project_list_command(client, args))

            elif command == 'azure-devops-repository-list':
                return_results(repository_list_command(client, args))

            elif command == 'azure-devops-user-list':
                return_results(users_query_command(client, args))

            elif command == 'azure-devops-pipeline-run-get':
                return_results(pipeline_run_get_command(client, args))

            elif command == 'azure-devops-pipeline-run-list':
                return_results(pipeline_run_list_command(client, args))

            elif command == 'azure-devops-pipeline-list':
                return_results(pipeline_list_command(client, args))

            elif command == 'azure-devops-branch-list':
                return_results(branch_list_command(client, args))

            elif command == 'test-module':
                return_results(
                    'The test module is not functional, '
                    'run the azure-devops-auth-start command instead.')

            elif command == 'fetch-incidents':
                integration_instance = demisto.integrationInstance()
                fetch_incidents(client, params.get('project'), params.get('repository'), integration_instance,
                                arg_to_number(params.get('max_fetch', 50)), params.get('first_fetch'))

            elif command == 'azure-devops-auth-reset':
                return_results(reset_auth())

            elif command == 'azure-devops-pipeline-run':
                pipeline_result = pipeline_run_command(client, args)
                if pipeline_result is not None:
                    return_results(pipeline_result)

            elif command == 'get-mapping-fields':
                return_results(get_mapping_fields_command())

            elif command == 'update-remote-system':
                if is_mirroring:
                    return_results(update_remote_system_command(client, args))

            else:
                raise NotImplementedError(f'{command} command is not implemented.')

        except Exception as e:
            return_error(str(e))



    ### GENERATED CODE ###

    # This code was inserted in place of an API module.import traceback





    import requests

    import re

    import base64

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    from typing import Dict, Tuple, List, Optional



    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'


    # authorization types

    OPROXY_AUTH_TYPE = 'oproxy'

    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = 'client_credentials'

    AUTHORIZATION_CODE = 'authorization_code'

    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line

    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'

    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'

    SESSION_STATE = 'session_state'



    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: Optional[str] = '',
                     multi_resource: bool = False,
                     resources: List[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     azure_ad_endpoint: str = 'https://login.microsoftonline.com',
                     timeout: Optional[int] = None,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint
            self.timeout = timeout

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: Dict[str, str] = {}

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: Optional[str] = None,
                resource: str = '', **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers.update(headers)

            if self.timeout:
                kwargs['timeout'] = self.timeout

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self, resource: str = '', scope: Optional[str] = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource (str): The resource identifier for which the generated token will have access to.
                scope (str): A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            if self.multi_resource:
                access_token = integration_context.get(resource)
            else:
                access_token = integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    for resource_str in self.resources:
                        access_token, expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _oproxy_authorize(self, resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: Optional[str] = None,
                                     integration_context: Optional[dict] = None
                                     ) -> Tuple[str, int, str]:
            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                else:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                          resource)
                        self.resource_to_access_token[resource] = access_token

                    return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope; A scope to add to the headers. Else will get self.scope.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope if scope else self.scope

            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=self.resource if not resource else resource,
                redirect_uri=self.redirect_uri
            )

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_token_device_code(
                self, refresh_token: str = '', scope: Optional[str] = None, integration_context: Optional[dict] = None
        ) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search.group('url') if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message



    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
fromversion: 6.0.0
beta: true
tests:
- playbook-AzureDevOps-Test
image: data:image/png;base64,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
detaileddescription: "### Authenticationg\r\nIn order to connect to the Azure DevOps, please follow  these steps:\r\n\r\n1. Add a new Azure App Registration in the Azure Portal. To add the registration, refer to the following [Microsoft article](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\r\n2. Add the following permissions to your registered app:\r\n   - `Azure DevOps/user_impersonation`\r\n   - `Microsoft Graph/User.Read`\r\n3. In your registered app - Get the Application (client) ID. \r\n   1. Navigate in the Azure Portal to **App registrations** > your registered application > **Overview**.\r\n   2. Copy and save the Application (client) ID.\r\n4. In the ***Client ID*** parameter, enter your registered app Application (client) ID.\r\n5. In the ***Organization*** parameter, enter the Azure DevOps organization name.\r\n   More information about creating an organization or project can be found here:\r\n   \r\n   [Create an organization](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/create-organization?view=azure-devops)\r\n\r\n    [Create a project](https://docs.microsoft.com/en-us/azure/devops/organizations/projects/create-project?view=azure-devops&tabs=preview-page)\r\n6. In order to connect to the Azure DevOps Account , we will use the [device authorization grant flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code).\r\n   1. Fill in the required parameters.\r\n   2. Run the ***!azure-devops-auth-start*** command. .\r\n   3. Follow the instructions that appear.\r\n   4. Run the ***!azure-devops-auth-complete*** command.\r\n    \r\n### Testing authentication and connectivity\r\nTo test your authentication and connectivity to the Azure DevOps service run the ***!azure-devops-auth-test***\r\n\r\nNote: This is a beta Integration, which lets you implement and test pre-release software. Since the integration is beta, it might contain bugs. Updates to the integration during the beta phase might include non-backward compatible features. We appreciate your feedback on the quality and usability of the integration to help us identify issues, fix them, and continually improve.\r\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/azure-dev-ops)"
