category: Authentication & Identity Management
commonfields:
  id: AwsSecretsManager - Candidate
  version: -1
configuration:
- display: AWS Default Region
  name: defaultRegion
  options:
  - us-east-1
  - us-east-2
  - us-west-1
  - us-west-2
  - ca-central-1
  - eu-west-1
  - eu-central-1
  - eu-west-2
  - ap-northeast-1
  - ap-northeast-2
  - ap-southeast-1
  - ap-southeast-2
  - ap-south-1
  - sa-east-1
  - eu-north-1
  - eu-west-3
  - us-gov-east-1
  - us-gov-west-1
  required: true
  type: 15
- display: Role Arn
  name: roleArn
  type: 0
  required: false
- display: Role Session Name
  name: roleSessionName
  type: 0
  required: false
- display: Role Session Duration
  name: sessionDuration
  type: 0
  required: false
- displaypassword: Secret Key
  name: credentials
  display: Access Key
  type: 9
  required: false
- display: STS External ID
  name: externalId
  type: 0
  required: false
- display: Timeout
  name: timeout
  additionalinfo: The time in seconds until a timeout exception is reached. You can specify just the read timeout (for example 60) or also the connect timeout separated from the read timeout with a comma (for example 60,10). If a connect timeout is not specified, a default of 10 second will be used.
  defaultvalue: 60,10
  type: 0
  required: false
- display: Retries
  name: retries
  defaultvalue: 5
  additionalinfo: 'The maximum number of retry attempts when connection or throttling errors are encountered. Set to 0 to disable retries. The default value is 5 and the limit is 10. Note: Increasing the number of retries will increase the execution time.'
  type: 0
  required: false
- display: Fetches credentials
  name: isFetchCredentials
  defaultvalue: 'true'
  type: 8
  required: false
- display: AWS STS Regional Endpoints
  additionalinfo: Sets the AWS_STS_REGIONAL_ENDPOINTS environment variable to specify the AWS STS endpoint resolution logic. By default, this option is set to “legacy” in AWS. Leave empty if the environment variable is already set using server configuration.
  name: sts_regional_endpoint
  options:
  - legacy
  - regional
  type: 15
  section: Connect
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Disable sensitive commands
  name: disable_sensitive_commands
  type: 8
  required: false
  defaultvalue: 'false'
description: AWS Secrets Manager helps you to securely encrypt, store, and retrieve credentials for your databases and other services.
display: Aws Secrets Manager - Candidate
name: AwsSecretsManager - Candidate
script:
  commands:
  - arguments:
    - description: Description field to filter by.
      name: description
    - description: Secret name.
      name: name
    - description: Tag key to filter by.
      name: tag_key
    - description: Tag value to filter by.
      name: tag_value
    - description: Search in all possible fields.
      name: general_search
    - description: Direction by which to display the results.
      name: sort
      auto: PREDEFINED
      predefined:
      - Asc
      - Desc
    - description: Number of total results to query.
      name: limit
    - description: Specific page to query.
      name: page
    - description: Number of total results in each page.
      name: page_size
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) up to the maximum session duration setting for the role.
      name: roleSessionDuration
    description: Retrieve all secrets.
    name: aws-secrets-manager-secret-list
    outputs:
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.HTTPHeaders.content-length
      description: The length of the HTTP header response content.
      type: String
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.HTTPHeaders.content-type
      description: The type of the HTTP header response content.
      type: String
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.HTTPHeaders.date
      description: The date of the HTTP header response.
      type: Date
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.HTTPHeaders.x-amzn-requestid
      description: The ID of the HTTP header Amazon request.
      type: String
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.HTTPStatusCode
      description: The status code in the HTTP header.
      type: Number
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.RequestId
      description: The ID of the HTTP header response request.
      type: String
    - contextPath: AWS.SecretsManager.Secret.ResponseMetadata.RetryAttempts
      description: The number of HTTP header response retry attempts.
      type: Number
    - contextPath: AWS.SecretsManager.Secret.SecretList.ARN
      description: The secret ARN.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.CreatedDate
      description: The date and time this version of the secret was created.
      type: Date
    - contextPath: AWS.SecretsManager.Secret.SecretList.LastAccessedDate
      description: The date the secret was last accessed.
      type: Date
    - contextPath: AWS.SecretsManager.Secret.SecretList.LastChangedDate
      description: The date the secret was last changed.
      type: Date
    - contextPath: AWS.SecretsManager.Secret.SecretList.Name
      description: The secret name.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.SecretVersionsToStages.c88e2176-aca4-4776-a422-c3a0616079bc
      description: The SecretVersionStage staging labels for the provided hash.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.SecretVersionsToStages.5889c662-13a6-4318-bec3-b234fcae3826
      description: The SecretVersionStage staging labels for the provided hash.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.SecretVersionsToStages.f2a389e8-3860-47a0-b4a0-16424ad63a24
      description: The SecretVersionStage staging labels for the provided hash.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.Description
      description: The secret description.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.SecretVersionsToStages.01cba660-28be-45d7-8597-d1ab295b0f35
      description: The SecretVersionStage staging labels for the provided hash.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretList.SecretVersionsToStages.ac32e535-79e7-4188-a732-7f02dbe399f0
      description: The SecretVersionStage staging labels for the provided hash.
      type: String
  - arguments:
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) up to the maximum session duration setting for the role.
      name: roleSessionDuration
    - description: The ID of the secret or ARN.
      name: secret_id
      required: true
    - description: The version ID of the secret.
      name: version_id
    - description: The version stage of the secret.
      name: version_stage
    description: Retrieve a secret value by key.
    name: aws-secrets-manager-secret–value-get
    outputs:
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ARN
      description: The secret ARN.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.Name
      description: The secret name.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.VersionId
      description: The secret version ID.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.SecretString
      description: The secret value.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.VersionStages
      description: A list of all of the staging labels currently attached to this version of the secret.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.CreatedDate
      description: The date and time this version of the secret was created.
      type: Date
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.RequestId
      description: The ID of the HTTP header response request.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.HTTPStatusCode
      description: The status code in the HTTP header.
      type: Number
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.HTTPHeaders.x-amzn-requestid
      description: The ID of the HTTP header Amazon request.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.HTTPHeaders.content-type
      description: The type of the HTTP header response content.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.HTTPHeaders.content-length
      description: The length of the HTTP header response content.
      type: String
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.HTTPHeaders.date
      description: The date of the HTTP header response.
      type: Date
    - contextPath: AWS.SecretsManager.Secret.SecretValue.ResponseMetadata.RetryAttempts
      description: The number of HTTP header response retry attempts.
      type: Number
  - arguments:
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) up to the maximum session duration setting for the role.
      name: roleSessionDuration
    - description: The ID of the secret or ARN.
      name: secret_id
      required: true
    - description: Delete with grace period.
      name: delete_immediately
    - description: The number of days allowed to restore the secret (default in AWS - 30 days).
      name: days_of_recovery
    description: Delete a specific secret.
    name: aws-secrets-manager-secret–delete
  - arguments:
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) up to the maximum session duration setting for the role.
      name: roleSessionDuration
    - description: The ID of the secret or ARN.
      name: secret_id
      required: true
    description: Restore a specific secret after deletion.
    name: aws-secrets-manager-secret–restore
  - arguments:
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) up to the maximum session duration setting for the role.
      name: roleSessionDuration
    - description: The ID of the secret or ARN.
      name: secret_id
      required: true
    description: Get the Secret Manager policy for a specific secret.
    name: aws-secrets-manager-secret–policy-get
    outputs:
    - contextPath: AWS.SecretsManager.Policy.ARN
      description: The policy ARN.
      type: String
    - contextPath: AWS.SecretsManager.Policy.Name
      description: The policy name.
      type: String
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.RequestId
      description: The ID of the HTTP header response request.
      type: String
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.HTTPStatusCode
      description: The status code in the HTTP header.
      type: Number
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.HTTPHeaders.x-amzn-requestid
      description: The ID of the HTTP header Amazon request.
      type: String
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.HTTPHeaders.content-type
      description: The type of the HTTP header response content.
      type: String
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.HTTPHeaders.content-length
      description: The length of the HTTP header response content.
      type: String
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.HTTPHeaders.date
      description: The date of the HTTP header response.
      type: Date
    - contextPath: AWS.SecretsManager.Policy.ResponseMetadata.RetryAttempts
      description: The number of HTTP header response retry attempts.
      type: Number
  script: >
    register_module_line('AwsSecretsManager', 'start', __line__())

    demisto.debug('pack name = AWS Secrets Manager, pack version = 1.0.44')




    import json

    from datetime import datetime, date


    import urllib3

    from typing import Dict, Any



    ### GENERATED CODE ###: from AWSApiModule import *  # noqa: E402

    # This code was inserted in place of an API module.

    register_module_line('AWSApiModule', 'start', __line__(), wrapper=-3)



    import boto3

    from botocore.config import Config


    STS_ENDPOINTS = {
        "us-gov-west-1": "https://sts.us-gov-west-1.amazonaws.com",
        "us-gov-east-1": "https://sts.us-gov-east-1.amazonaws.com",
    }  # See: https://docs.aws.amazon.com/general/latest/gr/sts.html



    def validate_params(aws_default_region, aws_role_arn, aws_role_session_name, aws_access_key_id, aws_secret_access_key):
        """
        Validates that the provided parameters are compatible with the appropriate authentication method.
        """
        if not aws_default_region:
            raise DemistoException('You must specify AWS default region.')

        if bool(aws_access_key_id) != bool(aws_secret_access_key):
            raise DemistoException('You must provide Access Key id and Secret key id to configure the instance with '
                                   'credentials.')
        if bool(aws_role_arn) != bool(aws_role_session_name):
            raise DemistoException('Role session name is required when using role ARN.')


    def extract_session_from_secret(secret_key, session_token):
        """
        Extract the session token from the secret_key field.
        """
        if secret_key and '@@@' in secret_key and not session_token:
            return secret_key.split('@@@')[0], secret_key.split('@@@')[1]
        else:
            return secret_key, session_token


    class AWSClient:

        def __init__(self, aws_default_region, aws_role_arn, aws_role_session_name, aws_role_session_duration,
                     aws_role_policy, aws_access_key_id, aws_secret_access_key, verify_certificate, timeout,
                     retries, aws_external_id=None, aws_session_token=None, sts_endpoint_url=None, endpoint_url=None):

            self.sts_endpoint_url = sts_endpoint_url
            self.endpoint_url = endpoint_url
            self.aws_default_region = aws_default_region
            self.aws_role_arn = aws_role_arn
            self.aws_role_session_name = aws_role_session_name
            # handle cases where aws_role_session_duration can be also empty string
            self.aws_role_session_duration = aws_role_session_duration if aws_role_session_duration else None
            self.aws_role_policy = aws_role_policy
            self.aws_access_key_id = aws_access_key_id
            self.aws_secret_access_key, self.aws_session_token = extract_session_from_secret(aws_secret_access_key, aws_session_token)
            self.aws_external_id = aws_external_id
            self.verify_certificate = verify_certificate

            sts_regional_endpoint = demisto.params().get("sts_regional_endpoint") or None
            if sts_regional_endpoint:
                demisto.debug(f"Sets the environment variable AWS_STS_REGIONAL_ENDPOINTS={sts_regional_endpoint}")
                os.environ["AWS_STS_REGIONAL_ENDPOINTS"] = sts_regional_endpoint.lower()

            proxies = handle_proxy(proxy_param_name='proxy', checkbox_default_value=False)
            (read_timeout, connect_timeout) = AWSClient.get_timeout(timeout)
            if int(retries) > 10:
                retries = 10
            self.config = Config(
                connect_timeout=connect_timeout,
                read_timeout=read_timeout,
                retries=dict(
                    max_attempts=int(retries)
                ),
                proxies=proxies
            )

        def update_config(self):
            command_config = {}
            retries = demisto.getArg('retries')  # Supports retries and timeout parameters on the command execution level
            if retries is not None:
                command_config['retries'] = dict(max_attempts=int(retries))
            timeout = demisto.getArg('timeout')
            if timeout is not None:
                (read_timeout, connect_timeout) = AWSClient.get_timeout(timeout)
                command_config['read_timeout'] = read_timeout
                command_config['connect_timeout'] = connect_timeout
            if retries or timeout:
                demisto.debug('Merging client config settings: {}'.format(command_config))
                self.config = self.config.merge(Config(**command_config))  # type: ignore[arg-type]

        def aws_session(self, service, region=None, role_arn=None, role_session_name=None, role_session_duration=None,
                        role_policy=None):
            kwargs = {}

            self.update_config()

            if role_arn and role_session_name is not None:
                kwargs.update({
                    'RoleArn': role_arn,
                    'RoleSessionName': role_session_name,
                })
            elif self.aws_role_arn and self.aws_role_session_name is not None:
                kwargs.update({
                    'RoleArn': self.aws_role_arn,
                    'RoleSessionName': self.aws_role_session_name,
                })

            if role_session_duration is not None:
                kwargs.update({'DurationSeconds': int(role_session_duration)})
            elif self.aws_role_session_duration is not None:
                kwargs.update({'DurationSeconds': int(self.aws_role_session_duration)})

            if role_policy is not None:
                kwargs.update({'Policy': role_policy})
            elif self.aws_role_policy is not None:
                kwargs.update({'Policy': self.aws_role_policy})
            
            if self.aws_external_id:
                kwargs['ExternalId'] = self.aws_external_id

            demisto.debug(f'{kwargs=}')
            self.sts_endpoint_url = self.sts_endpoint_url or STS_ENDPOINTS.get(region) or STS_ENDPOINTS.get(self.aws_default_region)

            sts_client = boto3.client(
                service_name='sts',
                region_name=region or self.aws_default_region,
                aws_access_key_id=self.aws_access_key_id,
                aws_secret_access_key=self.aws_secret_access_key,
                verify=self.verify_certificate,
                config=self.config,
                endpoint_url=self.sts_endpoint_url
            )
            kwargs.update({
                'RoleArn': role_arn or self.aws_role_arn,
                'RoleSessionName': role_session_name or self.aws_role_session_name,
            })
            sts_response = sts_client.assume_role(**kwargs)
            client = boto3.client(
                service_name=service,
                region_name=region or self.aws_default_region,
                aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                aws_session_token=sts_response['Credentials']['SessionToken'],
                verify=self.verify_certificate,
                config=self.config,
                endpoint_url=self.endpoint_url
            )
            return client

            if kwargs and not self.aws_access_key_id:  # login with Role ARN
                sts_client = boto3.client(
                    service_name='sts',
                    config=self.config,
                    verify=self.verify_certificate,
                    region_name=region or self.aws_default_region,
                    endpoint_url=self.sts_endpoint_url
                )
                sts_response = sts_client.assume_role(**kwargs)
                client = boto3.client(
                    service_name=service,
                    region_name=region or self.aws_default_region,
                    aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                    aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                    aws_session_token=sts_response['Credentials']['SessionToken'],
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_access_key_id and (role_arn or self.aws_role_arn):  # login with Access Key ID and Role ARN
                sts_client = boto3.client(
                    service_name='sts',
                    region_name=region or self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.sts_endpoint_url
                )
                kwargs.update({
                    'RoleArn': role_arn or self.aws_role_arn,
                    'RoleSessionName': role_session_name or self.aws_role_session_name,
                })
                sts_response = sts_client.assume_role(**kwargs)
                client = boto3.client(
                    service_name=service,
                    region_name=region or self.aws_default_region,
                    aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                    aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                    aws_session_token=sts_response['Credentials']['SessionToken'],
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_session_token and not self.aws_role_arn:  # login with session token
                client = boto3.client(
                    service_name=service,
                    region_name=region or self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    aws_session_token=self.aws_session_token,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_access_key_id and not self.aws_role_arn:  # login with access key id
                client = boto3.client(
                    service_name=service,
                    region_name=region or self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            else:  # login with default permissions, permissions pulled from the ec2 metadata
                client = boto3.client(service_name=service,
                                      region_name=region or self.aws_default_region,
                                      endpoint_url=self.endpoint_url)

            return client

        @staticmethod
        def get_timeout(timeout):
            if not timeout:
                timeout = "60,10"  # default values
            try:

                if isinstance(timeout, int):
                    read_timeout = timeout
                    connect_timeout = 10

                else:
                    timeout_vals = timeout.split(',')
                    read_timeout = int(timeout_vals[0])
                    # the default connect timeout is 10
                    connect_timeout = 10 if len(timeout_vals) == 1 else int(timeout_vals[1])

            except ValueError:
                raise DemistoException("You can specify just the read timeout (for example 60) or also the connect "
                                       "timeout followed after a comma (for example 60,10). If a connect timeout is not "
                                       "specified, a default of 10 second will be used.")
            return read_timeout, connect_timeout

    register_module_line('AWSApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###


    SERVICE = 'secretsmanager'


    # Disable insecure warnings

    urllib3.disable_warnings()  # pylint: disable=no-member


    ''' CONSTANTS '''


    ''' HELPER FUNCTIONS '''



    class DatetimeEncoder(json.JSONEncoder):
        # pylint: disable=method-hidden
        def default(self, obj):
            if isinstance(obj, datetime):
                return obj.strftime('%Y-%m-%dT%H:%M:%S')
            elif isinstance(obj, date):
                return obj.strftime('%Y-%m-%d')
            # Let the base class default method raise the TypeError
            return json.JSONEncoder.default(self, obj)


    ''' COMMAND FUNCTIONS '''



    def test_module(client: AWSClient):
        aws_client = client.aws_session(
            service=SERVICE
        )

        response = aws_client.list_secrets(MaxResults=1)

        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results('ok')


    def aws_secrets_manager_secret_list_command(client: AWSClient, args: Dict[str, Any]):
        aws_client = client.aws_session(
            service=SERVICE,
            role_arn=args.get('roleArn'),
            role_session_name=args.get('roleSessionName'),
            role_session_duration=args.get('roleSessionDuration'),
        )

        description = args.get('description')
        name = args.get('name')
        tag_key = args.get('tag_key')
        tag_value = args.get('tag_value')
        general_search = args.get('general_search')
        sort = args.get('sort', 'desc')
        limit = int(args.get('limit', 50))
        page = int(args.get('page', 1)) - 1
        page_size = int(args.get('page_size', 50))

        offset = page_size * page
        end = page_size * page + page_size

        filters = []
        if description:
            filters.append({'Key': 'description', 'Values': description})
        if name:
            filters.append({'Key': 'name', 'Values': name})
        if tag_key:
            filters.append({'Key': 'tag_key', 'Values': tag_key})
        if tag_value:
            filters.append({'Key': 'tag_value', 'Values': tag_value})
        if general_search:
            filters.append({'Key': 'all', 'Values': general_search})

        response = aws_client.list_secrets(Filters=filters, SortOrder=sort, MaxResults=limit)

        output = json.dumps(response, cls=DatetimeEncoder)
        response = json.loads(output)

        readable_output = [{'Name': secret.get('Name', ''),
                            'ARN': secret.get('ARN', ''),
                            'Description': secret.get('Description', ''),
                            'LastAccessedDate': secret.get('LastChangedDate', '')}
                           for secret in response['SecretList'][offset:end]]

        human_readable = tableToMarkdown('AWS Secrets List', readable_output)

        return_results(CommandResults(
            outputs_prefix='AWS.SecretsManager.Secret',
            outputs=response,
            outputs_key_field='Name',
            readable_output=human_readable
        ))


    def aws_secrets_manager_secret_value_get_command(client: AWSClient, args: Dict[str, Any]):
        client = client.aws_session(
            service=SERVICE,
            role_arn=args.get('roleArn'),
            role_session_name=args.get('roleSessionName'),
            role_session_duration=args.get('roleSessionDuration'),
        )

        kwargs = dict()

        if args.get('secret_id'):
            kwargs['SecretId'] = args.get('secret_id')
        else:
            return_error('Get command cannot be executed without "secret_id" param')

        if args.get('version_id'):
            kwargs['VersionId'] = args.get('version_id')
        if args.get('version_stage'):
            kwargs['VersionStage'] = args.get('version_stage')

        response = client.get_secret_value(**kwargs)

        output = json.dumps(response, cls=DatetimeEncoder)
        response = json.loads(output)

        if not response['ResponseMetadata']['HTTPStatusCode'] == 200:
            return_error(f'Get command encountered an issue, got unexpected result! {response["ResponseMetadata"]}')

        readable_output = {'Name': response.get('Name', ''),
                           'ARN': response.get('ARN', ''),
                           'SecretBinary': response.get('SecretBinary', ''),
                           'SecretString': response.get('SecretString', ''),
                           'CreatedDate': response.get('CreatedDate', '')}

        human_readable = tableToMarkdown('AWS Get Secret', readable_output)

        return_results(CommandResults(
            outputs_prefix='AWS.SecretsManager.Secret.SecretValue',
            outputs=response,
            outputs_key_field='Name',
            readable_output=human_readable
        ))


    def aws_secrets_manager_secret_delete_command(client: AWSClient, args):
        client = client.aws_session(
            service=SERVICE,
            role_arn=args.get('roleArn'),
            role_session_name=args.get('roleSessionName'),
            role_session_duration=args.get('roleSessionDuration'),
        )

        kwargs = dict()

        if args.get('secret_id'):
            kwargs['SecretId'] = args.get('secret_id')
        if args.get('days_of_recovery'):
            kwargs['RecoveryWindowInDays'] = int(args.get('days_of_recovery'))
        if args.get('delete_immediately') is not None:
            if args.get('days_of_recovery'):
                raise Exception('Delete command cannot be executed with both args: delete_immediately and days_of_recovery')
            kwargs['ForceDeleteWithoutRecovery'] = argToBoolean(args.get('delete_immediately'))

        response = client.delete_secret(**kwargs)

        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Secret was Deleted")


    def aws_secrets_manager_secret_restore_command(client: AWSClient, args: Dict[str, Any]):
        client = client.aws_session(
            service=SERVICE,
            role_arn=args.get('roleArn'),
            role_session_name=args.get('roleSessionName'),
            role_session_duration=args.get('roleSessionDuration'),
        )

        if not args.get('secret_id'):
            raise Exception('secret_id is mandatory inorder to run this command!')

        response = client.restore_secret(SecretId=args.get('secret_id'))

        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("the secret was restored successfully")


    def aws_secrets_manager_secret_policy_get_command(client: AWSClient, args: Dict[str, Any]):
        client = client.aws_session(
            service=SERVICE,
            role_arn=args.get('roleArn'),
            role_session_name=args.get('roleSessionName'),
            role_session_duration=args.get('roleSessionDuration'),
        )

        if not args.get('secret_id'):
            return_error('secret_id is mandatory inorder to run this command!')

        response = client.get_resource_policy(
            SecretId=args.get('secret_id')
        )

        readable_output = {'Name': response.get('Name', ''),
                           'ARN': response.get('ARN', ''),
                           'Policy': response.get('ResourcePolicy', '')}

        human_readable = tableToMarkdown('AWS Secret Policy', readable_output)

        return_results(CommandResults(
            outputs_prefix='AWS.SecretsManager.Policy',
            outputs=response,
            outputs_key_field='Name',
            readable_output=human_readable
        ))


    def fetch_credentials(client: AWSClient, args: Dict[str, Any]):  # pragma: no cover
        client = client.aws_session(
            service=SERVICE,
            role_arn=args.get('roleArn'),
            role_session_name=args.get('roleSessionName'),
            role_session_duration=args.get('roleSessionDuration'),
        )

        creds_dict = dict()
        if args.get('secret_id'):
            try:
                creds_dict[args.get('secret_id')] = client.get_secret_value(SecretId=args.get('secret_id'))
            except Exception as e:
                demisto.debug(f"Could not fetch credentials: {args.get('secret_id')}. Error: {e}")
        else:
            for secret in client.list_secrets()['SecretList']:
                creds_dict[secret.get('Name')] = client.get_secret_value(SecretId=secret.get('Name'))

        credentials = []
        for cred_key in creds_dict.keys():
            try:
                secret_as_dict = json.loads(creds_dict[cred_key].get("SecretString"))

                if any(key in ["username", "password", "workgroup", "certificate"] for key in secret_as_dict.keys()):
                    credentials.append({
                        "user": secret_as_dict.get("username", ""),
                        "password": secret_as_dict.get("password", ""),
                        "workgroup": secret_as_dict.get("workgroup", ""),
                        "certificate": secret_as_dict.get("certificate", ""),
                        "name": f'{creds_dict[cred_key].get("Name")}',
                    })
                else:
                    demisto.debug(f'({creds_dict[cred_key]}) has no keys supporting the format')
            except Exception as e:
                demisto.debug(f'exception occured during parsing {e}')
                return_error(f'theres is a problem parsing ({creds_dict[cred_key]}) secret value, {e}')
        demisto.credentials(credentials)


    def main():  # pragma: no cover:
        try:
            params = demisto.params()
            aws_default_region = params.get('defaultRegion')
            aws_role_arn = params.get('roleArn')
            aws_role_session_name = params.get('roleSessionName')
            aws_role_session_duration = params.get('sessionDuration')
            aws_role_policy = None
            aws_access_key_id = params.get('credentials', {}).get('identifier')
            aws_secret_access_key = params.get('credentials', {}).get('password')
            aws_external_id = params.get('externalId')
            verify_certificate = not argToBoolean(params.get('insecure'))
            disable_sensitive_commands = argToBoolean(params.get('disable_sensitive_commands'))
            timeout = params.get('timeout')
            retries = int(params.get('retries')) if params.get('retries') else 5

            validate_params(aws_default_region, aws_role_arn, aws_role_session_name, aws_access_key_id,
                            aws_secret_access_key)

            aws_client = AWSClient(aws_default_region, aws_role_arn, aws_role_session_name, aws_role_session_duration,
                                   aws_role_policy, aws_access_key_id, aws_secret_access_key, verify_certificate, timeout,
                                   retries, aws_external_id=aws_external_id)

            args = demisto.args()

            if demisto.command() == 'test-module':
                test_module(aws_client)
            elif demisto.command() == 'aws-secrets-manager-secret-list':
                aws_secrets_manager_secret_list_command(aws_client, args)
            elif demisto.command() == 'aws-secrets-manager-secret–value-get':
                if disable_sensitive_commands:
                    raise ValueError('Sensitive commands are disabled. You can reenable them in the integration settings.')
                aws_secrets_manager_secret_value_get_command(aws_client, args)
            elif demisto.command() == 'aws-secrets-manager-secret–delete':
                aws_secrets_manager_secret_delete_command(aws_client, args)
            elif demisto.command() == 'aws-secrets-manager-secret–restore':
                aws_secrets_manager_secret_restore_command(aws_client, args)
            elif demisto.command() == 'aws-secrets-manager-secret–policy-get':
                aws_secrets_manager_secret_policy_get_command(aws_client, args)
            elif demisto.command() == 'fetch-credentials':
                fetch_credentials(aws_client, args)

        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('AwsSecretsManager', 'end', __line__())
  type: python
  subtype: python3
  dockerimage: demisto/boto3py3:1.0.0.98661
  nativeimage:
  - '8.7'
  - '8.6'
fromversion: 6.5.0
tests:
- No tests (auto formatted)
image: data:image/png;base64,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
detaileddescription: "Before you can use AWS Secrets Manager you need to perform several configuration steps in your AWS environment.\n\n### Prerequisites\n- Attach an instance profile with the required permissions to the Cortex XSOAR server or engine that is running \non your AWS environment.\n- The instance profile requires the following minimum permission: sts:AssumeRole.\n- The instance profile requires permission to assume the roles needed by the AWS integrations.\n\n### Configure AWS Settings\n- Create an IAM role for the instance profile.\n- Attach a role to the instance profile.\n- Configure the necessary IAM roles that the AWS integration can assume.\n\nFor detailed instructions, see the [AWS Integrations - Authentication](https://xsoar.pan.dev/docs/reference/articles/aws-integrations---authentication).\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/aws-secrets-manager)"
