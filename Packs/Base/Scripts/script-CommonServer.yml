comment: Common code that will be merged into each server script when it runs
commonfields:
  id: CommonServer
  version: -1
dependson: {}
name: CommonServer
script: "// Common functions script\n// =======================\n// This script will\
  \ be appended to each server script before being executed.\n// Place here all common\
  \ functions you'd like to share between server scripts.\n\n\n// ============= Fix\
  \ vault credentials =============\n// =================================================\n\
  try {\n    if(params && typeof params === 'object'){\n        for(var key in params){\n\
  \            param = params[key];\n            if(typeof param === 'object' && 'credentials'\
  \ in param  && param.credentials.vaultInstanceId){\n                param.identifier\
  \ = param.credentials.user;\n            }\n        }\n    }\n}\ncatch (e) {}\n\
  // =================================================\n\n/**\n * Returns true if\
  \ string starts with search string\n * @param {String} search - The string to be\
  \ searched\n * @param {Integer} pos - The position in this string at which to begin\
  \ searching for search string; defaults to 0.\n * @return {Boolean} true if string\
  \ starts with <search> string\n */\nif (!String.prototype.startsWith) {\n    String.prototype.startsWith\
  \ = function(search, pos) {\n        return this.substr(!pos || pos < 0 ? 0 : +pos,\
  \ search.length) === search;\n    };\n}\n\n/**\n * Returns true if string ends with\
  \ search string\n * @param {String} search - The string to be searched\n * @param\
  \ {Integer} this_len - Optional. If provided it is used as the length of search\
  \ string. If omitted, the default value is the length of the string.\n * @return\
  \ {Boolean} true if string ends with <search> string\n */\nif (!String.prototype.endsWith)\
  \ {\n    String.prototype.endsWith = function(search, this_len) {\n        if (this_len\
  \ === undefined || this_len > this.length) {\n            this_len = this.length;\n\
  \        }\n        return this.substring(this_len - search.length, this_len) ===\
  \ search;\n    };\n}\n\n/**\n * Removes the final slash / from the given url. This\
  \ function should be used to prevent double slash situations such as https://192.12.12.3:8443//api/\n\
  \ *\n * @param {String} url - e.g https://some_url.com:8080/ or https://some_url.com:8080\n\
  \ * @return {String} url without slash in the end - e.g https://some_url.com:8080\n\
  \ */\nfunction fixUrl(url) {\n    if (url.endsWith('/')) {\n        return url.slice(0,\
  \ -1);\n    }\n\n    return url;\n}\n/**\n * Removes the final slash / from the\
  \ given url. This function should be used to prevent double slash situations such\
  \ as https://192.12.12.3:8443//api/\n *\n * @param {String} url - e.g https://some_url.com:8080/\
  \ or https://some_url.com:8080\n * @return {String} url without slash in the end\
  \ - e.g https://some_url.com:8080\n */\nvar removeLastSlash = fixUrl;\n\n/**\n *\
  \ Formats a string in place\n * @return {String} The formatted string\n */\nString.prototype.format\
  \ = function() {\n   var content = this;\n   for (var i=0; i < arguments.length;\
  \ i++)\n   {\n        var replacement = '{' + i + '}';\n        content = content.replace(replacement,\
  \ arguments[i]);\n   }\n   return content;\n}\n\ncleanSingleObject = function(contents)\
  \ {\n    var cleanContents = {};\n    var keys = Object.keys(contents);\n    for\
  \ (var i = 0; i < keys.length; i++) {\n        if (contents[keys[i]] || contents[keys[i]]\
  \ === false) {\n            cleanContents[keys[i]] = contents[keys[i]];\n      \
  \  }\n    }\n    return cleanContents;\n}\n\n/**\n * Clean an object from empty\
  \ fields\n * @param {Object} obj - The object to be cleaned\n * @return {Object}\
  \ The cleaned object\n */\nvar cleanObject = function(obj) {\n    if (obj instanceof\
  \ Array) {\n        var res = [];\n        for (var j in obj) {\n            res.push(cleanObject(obj[j]));\n\
  \        }\n        return res;\n    }\n    return cleanSingleObject(obj);\n}\n\n\
  /**\n  * Merge a list of objects into a single object.\n  * Note: to avoid loss\
  \ of data, use only on objects with foreign properties.\n  * @param {Array} objs\
  \ - An array of arrays to be merged\n  * @return {Object} the merged array\n  */\n\
  function mergeForeignObjects(objs) {\n    var merged = {};\n    for (var i in objs)\
  \ {\n        for (var j in objs[i]) {\n            merged[j] = objs[i][j];\n   \
  \     }\n    }\n    return merged;\n}\n\n/**\n * Creates a string from an object\n\
  \ * @param {JSON | String} o - The object to create the string from\n * @param {String}\
  \ [delimiter] - The delimiter of the string representation of arrays\n * @return\
  \ {String} A string which represents the object\n */\nfunction objToStr(o, delimiter)\
  \ {\n    if(!delimiter || typeof(delimiter) !== 'string') {\n              delimiter\
  \ = ',';\n          }\n    if (Array.isArray(o)) {\n        return o.map(function(v)\
  \ {\n            return objToStr(v);\n        }).join(delimiter);\n    } else if\
  \ (typeof(o) === 'string') {\n        return o;\n    } else if (typeof(o) === 'number')\
  \ {\n        return '' + o;\n    } else {\n        return JSON.stringify(o);\n \
  \   }\n}\n\nMARKDOWN_CHARS = \"\\\\`*_{}[]()#+-!|\"\n\n/**\n * Escapes markdown\
  \ characters in a string\n * @param {String} st - The string to fix\n * @param {Boolean}\
  \ [replaceNewlines] - Should newlines be replaced with '<br>'\n * @return {String}\
  \ A string with the markdown characters escaped\n */\nvar stringEscapeMD = function(st,\
  \ replaceNewlines, minimal_escaping) {\n    if (typeof(st) != 'string') {\n    \
  \    return st;\n    }\n\n    if (replaceNewlines) {\n      st = st.replace(/\\\
  r\\n/g, '<br>');\n      st = st.replace(/\\n/g, '<br>');\n      st = st.replace(/\\\
  r/g, '<br>');\n    }\n\n    var escapedSt = '';\n    if (minimal_escaping) {\n \
  \       escapedSt = st.replace(/\\|/g, '\\\\|');\n    } else {\n        for (var\
  \ i = 0; i < st.length; i++) {\n            if (MARKDOWN_CHARS.indexOf(st[i]) >\
  \ -1) {\n                escapedSt += '\\\\';\n            }\n            escapedSt\
  \ += st[i];\n        }\n    }\n\n    return escapedSt;\n};\n\nvar HTML_ENTITY_MAP\
  \ = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"\
  '\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\n/**\n\
  \ * Escapes html characters in a string\n * @param {String} st - The string to fix\n\
  \ * @return {String} A string with the html characters escaped\n */\nvar stringEscapeHTML\
  \ = function(st) {\n    return String(st).replace(/[&<>\"'`=\\/]/g, function (s)\
  \ {\n        return HTML_ENTITY_MAP[s];\n    });\n}\n\n/**\n * Converts textual\
  \ keys to pascal format (e.g. \"Threat Score\" -> \"ThreatScore\")\n * @param {Object}\
  \ dict - The object to be converted\n * @return {Object} The converted object\n\
  \ */\nvar convertKeysToPascalCase = function(dict) {\n    var pascalDict = {};\n\
  \    for (var key in dict) {\n        var pascalCaseKey = key.replace(/\\w+/g, function(w)\
  \ { return w[0].toUpperCase() + w.slice(1).toLowerCase(); }).replace(/ /g, '');\n\
  \        pascalDict[pascalCaseKey] = dict[key];\n    }\n\n    return pascalDict;\n\
  }\n\n/**\n * Gets a parameter that can be either an array, a JSON array or a string\
  \ list separated by ',' and returns an array\n * @param {Object} [arg] - The object\
  \ to be converted\n * @return {Array} An array representing the given object\n */\n\
  function argToList(arg) {\n    if (!arg) {\n        return [];\n    }\n    if (Array.isArray(arg))\
  \ {\n        return arg;\n    }\n    if (typeof(arg) === 'string') {\n        if\
  \ (arg[0] === '[' && arg[arg.length - 1] === ']') {\n            return JSON.parse(arg);\n\
  \        }\n        return arg.split(',');\n    }\n    return arg;\n}\n\n/**\n *\
  \ Converts a JSON demisto table to a Markdown table\n * @param {String} name - The\
  \ name of the table\n * @param {Object} t - the JSON table - Array of objects with\
  \ the same keys\n * @param {Array|String} [headers] - The output markdown table\
  \ will show only these headers (by order). Use a single string in case of a value\
  \ type array (Optional).\n * @param {String} [cellDelimiter] - The delimiter of\
  \ the string representation of arrays (Optional).\n * @param {Function} [headerTransform]\
  \ - A transformation function for the header keys in the markdown table (Optional).\n\
  \ * @return {String} A string representing the markdown table\n */\nfunction tableToMarkdown(name,\
  \ t, headers, cellDelimiter, headerTransform) {\n    if (t && !(t instanceof Array)){\n\
  \        t = [t];\n    }\n\n    if(headers && !(headers instanceof Array) && typeof(headers)\
  \ !== 'object'){\n        headers = [headers];\n    }\n\n    //in case of headers\
  \ was not provided (backward compatibility)\n    if ((!(headers) || !(headers instanceof\
  \ Array) || headers.length === 0) && t && t.length > 0 && typeof(t[0]) === 'object')\
  \ {\n        headers = GetAllObjectsProperties(t);\n    }\n\n    if(!headers ||\
  \ !(headers instanceof Array) || headers.length === 0) {\n        return 'No data\
  \ returned\\n';\n    }\n\n    var mdResults = '';\n    if (name) {\n        mdResults\
  \ = '### ' + name + '\\n';\n    }\n    if (t && t.length) {\n        var newHeaders\
  \ = [];\n        if(!headerTransform){\n          headerTransform = function(string){return\
  \ string;};\n        }\n        for(var i=0; i<headers.length; i++){\n         \
  \   newHeaders.push(headerTransform(headers[i]));\n        }\n        if (newHeaders.length\
  \ > 1) {\n            mdResults += newHeaders.join('|') + '\\n';\n        } else\
  \ {\n            mdResults += newHeaders[0] + '|' + '\\n';\n        }\n        var\
  \ sep = [];\n        headers.forEach(function(h){\n            sep.push('---');\n\
  \        });\n        if (sep.length === 1) {\n            sep[0] = sep[0]+'|';\n\
  \        }\n        mdResults += sep.join('|') + '\\n';\n        t.forEach(function(entry){\n\
  \            var vals = [];\n            if(typeof(entry) !== 'object' && !(entry\
  \ instanceof Array)){\n              var obj = {};\n              obj[headers[0]]\
  \ = entry;\n              entry = obj;\n            }\n            headers.forEach(function(h){\n\
  \                if(entry[h] === null || entry[h] === undefined) {\n           \
  \         vals.push(' ');\n                } else {\n                    vals.push(stringEscapeMD(formatCell(entry[h],\
  \ cellDelimiter), true, true) || ' ');\n                }\n            });\n   \
  \         if (vals.length === 1) {\n                vals[0] = vals[0]+'|';\n   \
  \         }\n            mdResults += vals.join(' | ') + '\\n';\n        });\n \
  \   } else{\n        mdResults += 'No data returned\\n';\n    }\n    return mdResults;\n\
  }\n\nvar tblToMd = tableToMarkdown;\n\n\n/**\n * Converts an array of stings to\
  \ markdown table\n * @param {Array} arr - from strings\n * @param {String} [header]\
  \ - The output markdown table will show only these headers (by order) (Optional).\n\
  \ * @return {String} A markdown string of tables. If input array was empty, will\
  \ return \"No results\" instead.\n */\nfunction arrayToMarkdownTable(arr, header)\
  \ {\n  if (!arr) {\n      return 'No results';\n  }\n  if (!Array.isArray(arr))\
  \ {\n      throw arr + ' is not an array';\n  }\n  if (arr.length === 0) {\n   \
  \   return 'No results';\n  }\n\n  if (typeof arr[0] === 'object') {\n      throw\
  \ 'arrayToMarkdownTable should receive arr which contain objects but simple types\
  \ like string, int, bool'\n  }\n  if (!header) {\n      throw 'header is required\
  \ for arrayToMarkdownTable';\n  }\n\n  var md = '|' + header + '|\\n-';\n  arr.forEach(function(item)\
  \ {\n      md += '\\n|' + item + '|';\n  });\n\n  return md;\n}\n\n/**\n * Converts\
  \ underscore case strings to camel case\n * @param {String} string - The string\
  \ to be converted - i.e. hello_world\n * @return {String} - The converted string\
  \ - i.e. HelloWorld\n*/\nvar underscoreToCamelCase = function(string) {\n    var\
  \ ret_string = '_'+string;\n    return ret_string.replace(/_([a-z])/g, function\
  \ (g) { return g[1].toUpperCase(); });\n};\n\n/**\n * Converts dots into spaces\
  \ and capitalizes\n * @param {String} string - The string to be converted - i.e.\
  \ hello.world\n * @return {String} - The converted string - i.e. Hello World\n*/\n\
  var dotToSpace = function(string) {\n    var ret_string = '.'+string;\n    return\
  \ ret_string.replace(/\\.([a-z,A-Z])/g, function (g) { return ' '+g[1].toUpperCase();\
  \ });\n};\n\n/**\n * Converts pascal strings to human readable (e.g. \"ThreatScore\"\
  \ -> \"Threat Score\")\n * @param {String} string - The string to be converted\n\
  \ * @return {String} - The converted string\n*/\nvar pascalToSpace = function(string)\
  \ {\n    return string.replace(/([a-z][A-Z])/g, function (g) { return g[0] + ' '\
  \ + g.slice(1); });\n};\n\nfunction mapObjFunction(mapFields, filter) {\n    var\
  \ transformSingleObj= function(obj) {\n        var res = {};\n        mapFields.forEach(function(f)\
  \ {\n            if(!filter || filter(f)){\n                res[f.to] = dq(obj,\
  \ f.from);\n            }\n        });\n        return res;\n    };\n    return\
  \ function(obj) {\n        if (obj instanceof Array) {\n            var res = [];\n\
  \            for (var j=0; j < obj.length; j++) {\n                var current =\
  \ transformSingleObj(obj[j]);\n                if (current) {\n                \
  \    res.push(current);\n                }\n            }\n            return res;\n\
  \        }\n        return transformSingleObj(obj);\n    };\n}\n\nfunction createContext(data,\
  \ id) {\n    var createContextSingle = function(obj) {\n        var res = {};\n\
  \        var keys = Object.keys(obj);\n        keys.forEach(function(k) {\n    \
  \        var values = k.split('.');\n            var current = res;\n          \
  \  for (var j = 0; j<values.length - 1; j++) {\n                if (!current[values[j]])\
  \ {\n                    current[values[j]] = {};\n                }\n         \
  \       current = current[values[j]];\n            }\n            current[values[j]]\
  \ = obj[k];\n        });\n        if (!res.ID && id) {\n            res.ID = id;\n\
  \        }\n        return res;\n    };\n    if (data instanceof Array) {\n    \
  \    var res = [];\n        for (var j=0; j < data.length; j++) {\n            res.push(createContextSingle(data[j]));\n\
  \        }\n        return res;\n    }\n    return createContextSingle(data);\n\
  }\n\nvar isFunction = function(functionToCheck) {\n    return functionToCheck &&\
  \ typeof functionToCheck === 'function';\n}\n\n/**\n * Creates a dq query string.\
  \ Used by easyDQ.\n * @param {string} path - the path to be parsed\n * @param {function\
  \ | string} filter - filter string (e.g. 'val.id===<some id>'') or filter function\
  \ (e.g. function(obj){return obj.name === 'name';} )\n * @param {function | string}\
  \ returnValue - string or function that defines returned data format (e.g. '{Name\
  \ : val.name}' or function(val){return {Name:val.name};} )\n * @return {string}\
  \ - the query string to pass to dq function\n*/\nvar dqQueryBuilder = function(path,\
  \ filter, returnValue){\n    var query = path;\n    if(!filter){\n        filter\
  \ = 'true';\n    }\n    if(isFunction(filter)){\n        filter = filter.toString()\
  \ + '(val)';\n    }\n    if(typeof filter !== 'string'){\n        throw 'dqQueryBuilder:\
  \ Filter type is neither a function nor a string';\n    }\n    query += '('+filter+')';\n\
  \    if(returnValue){\n        if(isFunction(returnValue)){\n            returnValue\
  \ = returnValue.toString() + '(val)';\n        }\n        if(typeof returnValue\
  \ !== 'string'){\n            throw 'dqQueryBuilder: return value for DQ is neither\
  \ a function nor a string';\n        }\n        query += '='+returnValue;\n    }\n\
  \    return query;\n};\n\n/**\n * Creates a dq query from arguments and calls dq\n\
  \ * @param {Object} data - The raw data object\n * @param {String} path - The path\
  \ to be parsed\n * @param {Function | String} filter - A filter string (e.g. 'val.id===<some\
  \ id>'') or a filter function (e.g. function(obj){return obj.name === 'name';} )\n\
  \ * @param {Function | String} returnValue - string or function that defines the\
  \ returned data format (e.g. '{Name : val.name}' or function(val){return {Name:val.name};}\
  \ )\n * @return {Object} - The value returned from the dq function\n*/\neasyDQ =\
  \ function(data, path, filter, returnValue){\n    return dq(data, dqQueryBuilder(path,\
  \ filter, returnValue));\n};\n\n/* creates array from obj, if obj is not already\
  \ an array */\nvar toArray = function(obj){\n    if(obj && !Array.isArray(obj))\n\
  \        return [obj];\n    return obj;\n};\n\n/**\n * Creates a war room entry\n\
  \ * @param {Object} result - The raw result to be parsed\n * @param {Object} translator\
  \ - Maps raw data to the war room output. Should be of the following format:\n *\
  \ ```\n * {\n *   contextPath: <context-path>,\n *   title: <war-room-title>,\n\
  \ *   data: [\n *     {to: <dest-key>, from: <orig-key>, (optional) humanReadable:\
  \ <true/false>},\n *     {to: <dest-key>, from: <orig-key>, (optional) humanReadable:\
  \ <true/false>},\n *     ...\n *   ]\n * }\n * ```\n * - dest-key/orig-key should\
  \ be sparated with '.' (e.g. 'File.Malicious')\n * - dest-key is also used for war\
  \ room table headers\n * - humanReadable states whether field should appear in war\
  \ room table. Default is true.\n * @param {function} [MDfilter] - (optional) filters\
  \ out fields that shouldn't be displayed in warroom (returns true/false). Default\
  \ uses humanReadable field.\n * @param {function} [headerTransform] - transform\
  \ mark down headers to readable format.\n * @return {Object} - the war room entry\n\
  */\nvar createEntry = function(result, translator, MDfilter, headerTransform) {\n\
  \    /* filters out all fields where humanReadable is false */\n    var filter =\
  \ function(obj) {\n        if(obj.humanReadable !== false) {\n            return\
  \ true;\n        }\n        return false;\n    };\n    if (MDfilter) {\n       \
  \ filter = MDfilter;\n    }\n\n    var entry = {\n        Type: entryTypes.note,\n\
  \        Contents: result,\n        ContentsFormat: formats.json,\n        ReadableContentsFormat:\
  \ formats.markdown\n    };\n\n    var content = translator.innerPath ? dq(result,\
  \ translator.innerPath) : result;\n    var translatedContext = mapObjFunction(translator.data)\
  \ (content);\n    var translatedMD = mapObjFunction(translator.data, filter) (content);\n\
  \    entry.HumanReadable = tableToMarkdown(translator.title, translatedMD, undefined,\
  \ undefined, headerTransform || dotToSpace);\n    entry.EntryContext = {};\n   \
  \ var context = createContext(translatedContext);\n    entry.EntryContext[translator.contextPath]\
  \ = context;\n    return entry;\n};\n\n/**\n * Converts a demisto table in JSON\
  \ form to a HTML table\n * @param {String} name - the name of the table\n * @param\
  \ {Object} t - the JSON table - Array of objects with the same keys\n * @param {Array}\
  \ [headers] - optional, the output markdown table will show only these headers (by\
  \ order)\n * @param {String} [cellDelimiter] - The delimiter of the string representation\
  \ of arrays (Optional).\n * @return {String} A string representation of the html\
  \ result\n */\nfunction tableToHTML(name, t, headers, cellDelimiter) {\n    if (t\
  \ && !(t instanceof Array)){\n        t = [t];\n    }\n\n    //in case of headers\
  \ was not provided (backward compatibility)\n    if ((!headers || !headers instanceof\
  \ Array || headers.length === 0) && t && t.length > 0){\n        headers = GetAllObjectsProperties(t);\n\
  \    }\n\n    if(!headers || !headers instanceof Array || headers.length === 0)\
  \ {\n        return 'No data returned<br/>';\n    }\n\n    var htmlResults = '';\n\
  \    if (name) {\n        htmlResults = '<h3>' + name + '</h3><br/>';\n    }\n \
  \   if (t && t.length) {\n        htmlResults += '<table><tr>' + headers.reduce(function(acc,\
  \ v) {return acc + '<th>' + v + '</th>';}, '') + '</tr>';\n        t.forEach(function(entry){\n\
  \            var vals = [];\n            headers.forEach(function(h){\n        \
  \        vals.push((!!entry[h] || entry[h]==0) ? stringEscapeHTML(formatCell(entry[h],\
  \ cellDelimiter)) : ' ');\n            });\n            htmlResults += '<tr>' +\
  \ vals.reduce(function(acc, v) {return acc + '<td>' + v + '</td>';}, '') + '</tr>';\n\
  \        });\n        htmlResults += '</table>';\n    } else{\n        htmlResults\
  \ += 'No data returned<br/>';\n    }\n    return htmlResults;\n}\n\n/**\n\n* Verifies\
  \ that the given fields exists in the content and verifies its value\n* @param {String}\
  \ fieldName - the name of the field (dq format)\n* @param {Object} expectedValue\
  \ - the value to verify\n* @param {String} [comparisonType] - 'stringContains' or\
  \ 'stringEquals'. Default is 'stringEquals'\n* @return {Object} Returns the value\
  \ if value at the field matches, throws an error an exeption otherwise\n*/\nfunction\
  \ verifyContextField(fieldName, expectedValue, comparisonType) {\n    value = dq(invContext,\
  \ fieldName);\n\n    if (value === undefined) {\n        throw 'Field does not exist:\
  \ {0}.'.format(fieldName);\n    }\n\n    if (expectedValue !== undefined) {\n  \
  \      if (comparisonType == 'stringContains') {\n            if (value.indexOf(expectedValue)\
  \ == -1) {\n                throw 'Field {0} does not contain the expected string.\
  \ Value: {1}, expected: {2}.'.format(fieldName, value, expectedValue);\n       \
  \     }\n        } else {\n            if (value != expectedValue) {\n         \
  \       throw 'Field {0} does not match. Value: {1}, expected: {2}.'.format(fieldName,\
  \ value, expectedValue);\n            }\n        }\n    }\n\n    return value;\n\
  }\n\n/**\n * Get all properties of objects in an array.\n * @param {Array} t - Array\
  \ of elements\n * @return {Array} - Array of object properties\n*/\nfunction GetAllObjectsProperties(t)\
  \ {\n    var properties = {};\n    t.forEach(function (element) {\n        for(var\
  \ prop in element) {\n            properties[prop] ='';\n        }\n    });\n  \
  \  return Object.keys(properties).sort();\n}\n\n/**\n * Checks if the given string\
  \ represents a valid IPv4 address\n * @deprecated please use isValidIP which really\
  \ checks IP for validity\n * @param {String} ip - the string to check\n * @return\
  \ {Boolean} true if valid IPv4 address\n */\nfunction isIp(ip) {\n  var d = ip.split('.'),\
  \ i = d.length;\n  if (i !== 4) {\n    return false;\n  }\n  var ok = true;\n  while\
  \ (i-- && ok) {\n    ok = d[i].length !== 0 && !isNaN(parseInt(d[i])) && d[i] >\
  \ -1 && d[i] < 256;\n  }\n  return ok;\n}\n\nvar entryTypes = {note: 1, downloadAgent:\
  \ 2, file: 3, error: 4, pinned: 5, userManagement: 6, image: 7, plagroundError:\
  \ 8, playgroundError: 8, entryInfoFile: 9, map: 15, widget: 17};\nvar formats =\
  \ {html: 'html', table: 'table', json: 'json', text: 'text', dbotResponse: 'dbotCommandResponse',\
  \ markdown: 'markdown'};\n// The object below does not represent DBot Scores correctly,\
  \ and should not be used\nvar dbotscores = {critical : 4, high: 3, medium: 2, low:\
  \ 1, informational: 0.5, unknown: 0};\n\n/**\n * Returns the name of the file as\
  \ stored in our investigation artifacts on disk.\n * This should be used when sending\
  \ files to d2 scripts as you can see in StaticAnalyze.\n * @param {String} entryId\
  \ - The entry ID containing the file\n * @return {String} The name of the file in\
  \ our artifact repository\n */\nfunction fileNameFromEntry(entryId) {\n  var parts\
  \ = entryId.split('@');\n  if (parts.length !== 2) {\n    return null;\n  }\n  var\
  \ res = executeCommand('getEntry', {id: entryId});\n  if (res && Array.isArray(res)\
  \ && res.length === 1) {\n    return parts[1] + '_' + res[0].FileID;\n  }\n  return\
  \ null;\n}\n\n/**\n * Closes the current investigation\n * @param {Object} args\
  \ - Closing details (what happened, damage, etc.)\n * @return {Array} An array with\
  \ an error entry if an error occurred, an empty array otherwise\n */\nfunction closeInvestigation(args)\
  \ {\n  return executeCommand('closeInvestigation', args);\n}\n\n/**\n * Sets severity\
  \ an incident. The incident must be related to current investigation.\n * @param\
  \ {Object} arg - Has 2 keys, 'id' - the incident id, 'severity' - the new severity\
  \ value (Critical, High, Medium etc.).\n * @return {Array} An array with an error\
  \ entry if an error occurred, an empty array otherwise\n */\nfunction setSeverity(arg)\
  \ {\n  return executeCommand('setSeverity', arg);\n}\n\n/**\n * Sets fields of the\
  \ incident. The incident must be related to current investigation and be the only\
  \ incident in it.\n * @param {Object} args - Has 5 optional keys: type, severity,\
  \ details, name and systems of the incident.\n *                        systems\
  \ should follow this string template: '1.1.1.1,10.10.10.10'\n * @return {Array}\
  \ An array with an error entry if an error occurred, an empty array otherwise\n\
  \ */\nfunction setIncident(args) {\n  return executeCommand('setIncident', args);\n\
  }\n\n/**\n * Create a new incident with the fields specified, only if an incident\
  \ with the same name does not exist as an active incident.\n * If an active incident\
  \ with the same name exists, ignore the request.\n * @param {Object} args - Has\
  \ 5 optional keys: type, severity, details, name and system of the incident.\n *\
  \ @return {Array} An array with an error entry if an error occurred, an empty array\
  \ otherwise\n */\nfunction createNewIncident(args) {\n  return executeCommand('createNewIncident',\
  \ args);\n}\n\n/**\n * Sets playbook according to type.\n * @param {String} type\
  \ - The incident type, according to which the playbook is chosen\n * @return {Array}\
  \ An array with an error entry if an error occurred, an empty array otherwise\n\
  \ */\nfunction setPlaybookAccordingToType(type) {\n  return executeCommand('setPlaybookAccordingToType',\
  \ {type: type});\n}\n\n/**\n * Sets Owner to an incident. The incident must be related\
  \ to current investigation.\n * @param {Object} name - The user name of the owner\n\
  \ * @return {Array} An array with an error entry if an error occurred, an empty\
  \ array otherwise\n */\nfunction setOwner(name) {\n  return executeCommand('setOwner',\
  \ { owner: name });\n}\n\n/**\n * Assigns a playbook task to a user.\n * @param\
  \ {Object} arg - Has 2 keys, 'id' - the task id, 'assignee' - the user name of the\
  \ assignee.\n * @return {Array} An array with an error entry if an error occurred,\
  \ an empty array otherwise\n */\nfunction taskAssign(arg) {\n  return executeCommand('taskAssign',\
  \ arg);\n}\n\n/**\n * Sets task due date.\n * @param {Object} arg - Has 2 keys,\
  \ 'id' - the task id, 'dueDate' - time string in UTC format (To get current time\
  \ use: 'new Date().toUTCString()').\n * @return {Array} An array with an error entry\
  \ if an error occurred, an empty array otherwise\n */\nfunction setTaskDueDate(arg)\
  \ {\n  return executeCommand('setTaskDueDate', arg);\n}\n\n/**\n * Sets investigation\
  \ playbook\n * @param {String} name - The playbook name.\n * @return {Array} An\
  \ array with an error entry if an error occurred, an empty array otherwise\n */\n\
  function setPlaybook(name) {\n  return executeCommand('setPlaybook', { name: name\
  \ });\n}\n\n/**\n * Adds task to Workplan\n * @param {Object} arg - has 5 keys:\n\
  \ * - 'name' - (mandatory) The new task's name.\n * - 'description' - (optional)\
  \ The new task's description.\n * - 'script' - (optional) Name of script to be run\
  \ by task.\n * - 'addBefore' - (optional, refers to task id) Insert new task before\
  \ specified task (when using this argument do not use afterTask)\n * - 'addAfter'\
  \ - (optional, refers to task id) Insert new task after specified task (when using\
  \ this argument do not use beforeTask)\n * @return {Array} An array with an error\
  \ entry if an error occurred, an empty array otherwise\n */\nfunction addTask(arg)\
  \ {\n  return executeCommand('addTask', arg);\n}\n\n/**\n * Encode json object to\
  \ URL. Supports multiple arguments of the same value if input is an array.\n * @param\
  \ {Object} args - The object to encode.\n * @return {String} in case of error will\
  \ be empty. In Case of success will return the URL string.\n */\nfunction encodeToURLQuery(args)\
  \ {\n      var query = '';\n      if (args) {\n          var keys = Object.keys(args);\n\
  \          if (keys.length > 0) {\n              query = '?';\n              for\
  \ (var i = 0; i<keys.length; i++) {\n                  if (i !== 0) {\n        \
  \              query += '&';\n                  }\n                  if (Array.isArray(args[keys[i]]))\
  \ {\n                      for (var j=0; j<args[keys[i]].length; j++) {\n      \
  \                    if (j !== 0) {\n                              query += '&';\n\
  \                          }\n                          query += encodeURIComponent(keys[i])\
  \ + '=' + encodeURIComponent(args[keys[i]][j]);\n                      }\n     \
  \             } else {\n                      query += encodeURIComponent(keys[i])\
  \ + '=' + encodeURIComponent(args[keys[i]]);\n                  }\n            \
  \  }\n          }\n      }\n      return query;\n}\n\n/**\n * Translate ThreatConnect\
  \ rating to score\n * @param {rating} TC rating as int\n * @return {score} Int (between\
  \ 0 and 3)\n */\nfunction threatConnectRatingToScore(rating) {\n    var tcScore\
  \ = 0;\n    if (rating == 2 || rating == 1) {\n        tcScore = 2;\n    }\n   \
  \ if (rating > 2) {\n        tcScore = 3;\n    }\n    return tcScore;\n}\n\n/**\n\
  * Check the list of available modules to see whether a command is currently available\
  \ to be run.\n* @param {Object} cmd - The command to check.\n* @return {bool} True\
  \ if command is available, false otherwise\n*/\nfunction isCommandAvailable(cmd)\
  \ {\n    var all = getAllSupportedCommands();\n    var modules = Object.keys(all);\n\
  \    for(var i = 0; i < modules.length ; i++) {\n        var modCmds = all[modules[i]];\n\
  \        if (modCmds) {\n            for(var j = 0; j < modCmds.length ; j++) {\n\
  \                if (modCmds[j].name === cmd) {\n                    return true;\n\
  \                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n\
  \ * Check if the given entry is an error entry\n * @param {Object} entry - The entry\
  \ to check\n * @return {Boolean} True if this is an error entry, false otherwise\n\
  \ */\nfunction isError(entry) {\n  return entry && typeof entry === 'object' &&\
  \ entry.Type === entryTypes.error;\n}\n\n/**\n * Check if the given result entry\
  \ is an array and is not an error\n * @param {Array} res - The result from the execute\
  \ to check\n * @return {Boolean} True if this is a valid result\n */\nfunction isValidRes(res)\
  \ {\n  return res && Array.isArray(res) && res.length && !isError(res[0]);\n}\n\n\
  /**\n * If the given value exists, return it. Otherwise, return default and if not\
  \ provided 'Unknown'\n * @param {Object} v - Value that can be anything\n * @param\
  \ {Object} [def] - Default value. If not provided will be 'Unknown'\n * @return\
  \ {Object} Value if exists, default otherwise\n */\nfunction nvl(v, def) {\n  return\
  \ v ? v : def ? def : 'Unknown';\n}\n\n/**\n * Flatten the fields into a map of\
  \ dot notation key and value\n * @param {Object} obj - The object to iterate on\n\
  \ * @param {String} [path] - (optional) The path so far in dot notation\n * @param\
  \ {Object} flat - The collected object result\n * @return {Object} An object with\
  \ keys that are dot notation and values\n */\nfunction flattenFields(obj, path,\
  \ flat) {\n  if (obj) {\n      if (typeof obj === 'object') {\n          var keys\
  \ = Object.keys(obj);\n          for (var f=0; f<keys.length; f++) {\n         \
  \     flattenFields(obj[keys[f]], !!path ? path + '.' + keys[f] : keys[f], flat);\n\
  \          }\n      } else if (Array.isArray(obj)) {\n          for (var i=0; i<obj.length;\
  \ i++) {\n              flattenFields(obj[i], !!path ? path + '.' + i : '' + i,\
  \ flat);\n          }\n      } else {\n          flat[path] = obj.toString();\n\
  \      }\n  }\n}\n\nvar formatCell = objToStr;\n\n/**\n * Convert a given object\
  \ to md while descending multiple levels\n * @param {Object} o - The object to convert\
  \ - can be an array as well\n * @return {String} - The converted markdown string\n\
  \ */\nfunction objToMd(o) {\n    var flat = {};\n    flattenFields(o, '', flat);\n\
  \    var keys = Object.keys(flat);\n    keys.sort();\n    var md = 'Key | Value\\\
  n- | -\\n';\n    for (var i=0; i<keys.length; i++) {\n        md += keys[i] + '\
  \ | ' + flat[keys[i]] + '\\n';\n    }\n    return md;\n}\n\n/**\n * Convert a given\
  \ object to md list (-) while each value is converted to a simple string\n * @param\
  \ {Object} o - The object to convert\n * @param {String} t - The title of the list\n\
  \ * @return {String} The markdown string\n */\nfunction objToList(o, t) {\n  var\
  \ md = '';\n  if (o) {\n      md += '### ' + t + '\\n';\n      var keys = Object.keys(o);\n\
  \      for (var i=0; i<keys.length; i++) {\n          md += '- ' + keys[i] + ':\
  \ ' + objToStr(o[keys[i]]) + '\\n';\n      }\n  }\n  return md;\n}\n\n/**\n* Converts\
  \ the given timestamp to a string\n* @param {int} timestamp - The timestamp in UNIX\
  \ format\n* @return {String} A string representing the time - e.g. 'Thu, 11 May\
  \ 2017 11:18:56 UTC'\n*/\nfunction convertTimestampToString(timestamp) {\n  return\
  \ (new Date(parseInt(timestamp))).toISOString();\n}\n\n/**\n* Converts the given\
  \ number (uint32) to an IP address string\n* @param {int} num -  The number to convert\n\
  * @return {String} A string representing the IP address - e.g. '192.168.2.1'\n*/\n\
  var numToIp = function(num) {\n  var ip = num % 256;\n\n  for (var i = 3; i > 0;\
  \ i--) {\n      num = Math.floor(num / 256);\n      ip = num % 256 + '.' + ip;\n\
  \  }\n\n  return ip;\n}\n\n/**\n * Convert a given array to a markdown table\n *\
  \ @param {Array} arr - The array to convert\n * @return {String} - The converted\
  \ markdown string\n */\nfunction arrToMd(arr) {\n    if (!arr || arr.length ===\
  \ 0) {\n        return '';\n    }\n    return tableToMarkdown('', arr);\n}\n\n/**\n\
  \ * Query the given object with the given path and retrive it\n * @deprecated please\
  \ use dq which has the full functionality\n * @param {Object} obj - The object to\
  \ query\n * @param {String} path - The path to retrieve from the object\n * @return\
  \ {Object} The value of the path if the path exists, null otherwise\n */\nfunction\
  \ jq(obj, path) {\n  if (!obj || !path || (typeof obj !== 'object' && !Array.isArray(obj)))\
  \ {\n    return null;\n  }\n  var parts = path.split('.');\n  for (var i=0; i<parts.length;\
  \ i++) {\n    // First, handle array option\n    var part = parts[i].match(/([a-zA-Z0-9_]*)(\\\
  [([0-9]+)\\])?/);\n    if (part[3]) {\n      // If array of property and not top\
  \ array\n      if (part[1]) {\n        if (obj.hasOwnProperty(part[1]) && Array.isArray(obj[part[1]]))\
  \ {\n          obj = obj[part[1]][parseInt(part[3])];\n        } else {\n      \
  \    return null;\n        }\n      } else {\n        if (Array.isArray(obj)) {\n\
  \          obj = obj[parseInt(part[3])];\n        } else {\n          return null;\n\
  \        }\n      }\n    } else {\n      // Not an array\n      if (obj.hasOwnProperty(part[1]))\
  \ {\n        obj = obj[part[1]];\n      } else {\n        return null;\n      }\n\
  \    }\n  }\n  return obj;\n}\n\n/**\n * Replace the given args with the actual\
  \ values in the input template\n * @param {String} input - The template to replace\
  \ values in\n * @param {Object} args - The map of values to use\n * @return {String}\
  \ The template with the values filled in\n */\nfunction replaceInTemplates(input,\
  \ args) {\n  var res = input;\n  var keys = Object.keys(args);\n  for (var i = 0;\
  \ i < keys.length; i++) {\n    res = res.split('%' + keys[i] + '%').join(args[keys[i]]);\n\
  \  }\n  return res;\n}\n\n/**\n * Replace the given args with the actual values\
  \ in the input template and remove from args\n * @param {String} input - The template\
  \ to replace values in\n * @param {Object} args - The map of values to use\n * @return\
  \ {String} the template with the values filled in\n */\nfunction replaceInTemplatesAndRemove(input,\
  \ args) {\n    var res = input;\n    var keys = Object.keys(args);\n    for (var\
  \ i = 0; i < keys.length; i++) {\n      if (res.indexOf('%' +  keys[i] + '%') !==\
  \ -1) {\n        res = res.split('%' + keys[i] + '%').join(args[keys[i]]);\n   \
  \     delete(args[keys[i]]);\n      }\n    }\n    return res;\n}\n\nvar xmlReservedChars\
  \ = {\n  '&': '&amp;',\n  '\\\"': '&quot;',\n  '\\'': '&apos;',\n  '<': '&lt;',\n\
  \  '>': '&gt;'\n};\n\n/**\n * Escape reserved XML chars in the input\n * @param\
  \ {String} input - The input to escape\n * @return {String} The escaped input\n\
  \ */\nfunction escapeXMLChars(input) {\n    var res = input;\n    var keys = Object.keys(xmlReservedChars);\n\
  \    for (var i = 0; i < keys.length; i++) {\n        res = res.split(keys[i]).join(xmlReservedChars[keys[i]]);\n\
  \    }\n    return res;\n}\n\n/**\n * Convert a string representing a comma separated\
  \ list into an array\n * @param {String} listName - The name of the list\n * @return\
  \ {Array} The list as an array\n */\nfunction getCSVListAsArray(listName) {\n  \
  \  var res = executeCommand('getList', {listName: listName});\n    if (isValidRes(res))\
  \ {\n        var data = res[0].Contents.split(',');\n        return data.filter(function(v)\
  \ {return v;}).map(function(v) {return v.trim();});\n    }\n    return [];\n}\n\n\
  /**\n * Convert a JSON list/array into an object\n * @param {String} listName -\
  \ The name of the list\n * @return {Object} The JSON as an object\n */\nfunction\
  \ getJSONListAsObject(listName) {\n    var res = executeCommand('getList', {listName:\
  \ listName});\n    if (isValidRes(res)) {\n        try {\n            return JSON.parse(res[0].Contents);\n\
  \        } catch (ex) {\n            throw 'Error parsing list - ' + res[0].Contents\
  \ + ' - ' + ex;\n        }\n    }\n    return null;\n}\n\nvar brands = {xfe: 'xfe',\
  \ vt: 'VirusTotal', cy: 'cylance', wf: 'WildFire', cs: 'crowdstrike-intel', threatconnect:\
  \ 'ThreatConnect'};\nvar providers = {xfe: 'IBM X-Force Exchange', vt: 'VirusTotal',\
  \ cy: 'Cylance', wf: 'WildFire', cs: 'CrowdStrike'};\n// Thresholds for the various\
  \ reputation services to mark something as positive\nvar thresholds = {xfeScore:\
  \ 3, vtPositives: 10, vtPositiveUrlsForIP: 10};\n\n/**\n * Checks if the given entry\
  \ from a URL reputation query is positive (known bad)\n * @deprecated\n * @param\
  \ {Object} entry - reputation entry\n * @return {Boolean} true if positive, false\
  \ otherwise\n */\nfunction positiveUrl(entry) {\n  if (entry.Type !== entryTypes.error\
  \ && entry.ContentsFormat === formats.json) {\n    var c = entry.Contents;\n   \
  \ if (entry.Brand === brands.xfe && c && c.url.result.score && c.url.result.score\
  \ > thresholds.xfeScore) {\n      return true;\n    } else if (entry.Brand === brands.vt\
  \ && c && c.positives && c.positives > thresholds.vtPositives) {\n      return true;\n\
  \    } else if (entry.Brand === brands.cs && c && c.length && c[0].indicator &&\
  \ (c[0].malicious_confidence === 'high' || c[0].malicious_confidence === 'medium'))\
  \ {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks if the\
  \ given entry from a file reputation query is positive (known bad)\n * @deprecated\n\
  \ * @param {Object} entry - reputation entry\n * @return {Boolean} true if positive,\
  \ false otherwise\n */\nfunction positiveFile(entry) {\n  if (entry.Type !== entryTypes.error\
  \ && entry.ContentsFormat === formats.json) {\n    var c = entry.Contents;\n   \
  \ if (entry.Brand === brands.xfe && c && c.malware.family) {\n      return true;\n\
  \    } else if (entry.Brand === brands.vt && c && c.positives && c.positives > thresholds.vtPositives)\
  \ {\n      return true;\n    } else if (entry.Brand === brands.wf && c && c.wildfire\
  \ && c.wildfire.file_info) {\n      return c.wildfire.file_info.malware === 'yes';\n\
  \    } else if (entry.Brand === brands.cy && c) {\n      var k = Object.keys(c);\n\
  \      if (k && k.length > 0) {\n        var v = c[k[0]];\n        if (v && v.generalscore)\
  \ {\n          return v.generalscore < -0.5;\n        }\n      }\n    } else if\
  \ (entry.Brand === brands.cs && c && c.length && c[0].indicator && (c[0].malicious_confidence\
  \ === 'high' || c[0].malicious_confidence === 'medium')) {\n      return true;\n\
  \    }\n  }\n  return false;\n}\n\n/**\n * Checks if the given entry from an IP\
  \ reputation query is positive (known bad)\n * @deprecated\n * @param {Object} entry\
  \ - reputation entry\n * @return {Boolean} true if positive, false otherwise\n */\n\
  function positiveIP(entry) {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat\
  \ === formats.json) {\n    var c = entry.Contents;\n    if (entry.Brand === brands.xfe\
  \ && c && c.reputation.score && c.reputation.score > thresholds.xfeScore) {\n  \
  \    return true;\n    } else if (entry.Brand === brands.vt && c && c.detected_urls)\
  \ {\n      var positives = 0;\n      for (var i = 0; i < c.detected_urls.length;\
  \ i++) {\n        if (c.detected_urls[i].positives > thresholds.vtPositives) {\n\
  \          positives++;\n        }\n      }\n      return positives > thresholds.vtPositiveUrlsForIP;\n\
  \    } else if (entry.Brand === brands.cs && c && c.length && c[0].indicator &&\
  \ (c[0].malicious_confidence === 'high' || c[0].malicious_confidence === 'medium'))\
  \ {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Display CrowdStrike\
  \ Intel results in Markdown\n * @deprecated\n * @param {Object} entry - reputation\
  \ entry\n * @return {Object} the markdown entry\n */\nfunction shortCrowdStrike(entry)\
  \ {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat === formats.json)\
  \ {\n    var c = entry.Contents;\n    if (entry.Brand === brands.cs && c && c.length\
  \ && c[0].indicator) {\n      var csRes = '## CrowdStrike Falcon Intelligence';\n\
  \      csRes += '\\n\\n### Indicator - ' + c[0].indicator;\n      if (c[0].labels\
  \ && c[0].labels.length) {\n        csRes += '\\n### Labels';\n        csRes +=\
  \ '\\nName|Created|Last Valid';\n        csRes += '\\n----|-------|----------';\n\
  \        for (var l = 0; l < c[0].labels.length; l++) {\n          csRes += '\\\
  n' + c[0].labels[l].name + '|' + new Date(c[0].labels[l].created_on * 1000) + '|'\
  \ + new Date(c[0].labels[l].last_valid_on * 1000);\n        }\n      }\n      if\
  \ (c[0].relations && c[0].relations.length) {\n        csRes += '\\n### Relations';\n\
  \        csRes += '\\nIndicator|Type|Created|Last Valid';\n        csRes += '\\\
  n---------|----|-------|----------';\n        for (var r = 0; r < c[0].relations.length;\
  \ r++) {\n          csRes += '\\n' + c[0].relations[r].indicator + '|' + c[0].relations[r].type\
  \ + '|' + new Date(c[0].relations[r].created_date * 1000) + '|' + new Date(c[0].relations[r].last_valid_date\
  \ * 1000);\n        }\n      }\n      return {ContentsFormat: formats.markdown,\
  \ Type: entryTypes.note, Contents: csRes};\n    }\n  }\n  return entry;\n}\n\n/**\n\
  \ * Formats a URL reputation entry into a short table\n * @deprecated\n * @param\
  \ {Object} entry - reputation entry\n * @return {Object} the table entry\n */\n\
  function shortUrl(entry) {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat\
  \ === formats.json) {\n    var c = entry.Contents;\n    if (entry.Brand === brands.xfe\
  \ && c) {\n      return {ContentsFormat: formats.table, Type: entryTypes.note, Contents:\
  \ {\n        Country: c.country, MalwareCount: c.malware.count, A: c.resolution.A\
  \ ? c.resolution.A.join(',') : '',\n        AAAA: c.resolution.AAAA ? c.resolution.AAAA.join(',')\
  \ : '', Score: c.url.result.score,\n        Categories: c.url.result.cats ? Object.keys(c.url.result.cats).join(',')\
  \ : '',\n        URL: c.url.result.url, Provider: providers.xfe, ProviderLink: 'https://exchange.xforce.ibmcloud.com/url/'\
  \ + c.url.result.url\n      }};\n    } else if (entry.Brand === brands.vt && c)\
  \ {\n      return {ContentsFormat: formats.table, Type: entryTypes.note, Contents:\
  \ {\n        ScanDate: c.scan_date, Positives: c.positives, Total: c.total, URL:\
  \ c.url, Provider: providers.vt, ProviderLink: c.permalink\n      }};\n    } else\
  \ if (entry.Brand === brands.cs && c && c.length && c[0].indicator) {\n      return\
  \ shortCrowdStrike(entry);\n    } else if (entry.Brand === brands.threatconnect\
  \ && c && c.data && c.data.url) {\n      var url = c.data.url;\n      return {ContentsFormat:\
  \ formats.table, Type: entryTypes.note, Contents: {\n        Url: url.text, Rating:\
  \ url.rating, Confidence: url.confidence,\n        DateAdded: url.dateAdded, ID:\
  \ url.id, webLink: url.webLink, Provider: entry.Brand\n      }};\n    }\n  }\n \
  \ return entry;\n}\n\n/**\n * Formats a file reputation entry into a short table\n\
  \ * @deprecated\n * @param {Object} entry - reputation entry\n * @return {Object}\
  \ the table entry\n */\nfunction shortFile(entry) {\n  if (entry.Type !== entryTypes.error\
  \ && entry.ContentsFormat === formats.json) {\n    var c = entry.Contents;\n   \
  \ if (entry.Brand === brands.xfe && entry.Contents) {\n      var cm = c.malware;\n\
  \      return {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n\
  \        Family: cm.family, MIMEType: cm.mimetype, MD5: cm.md5 ? cm.md5.substring(2)\
  \ : '',\n        CnCServers: cm.origins.CnCServers.count, DownloadServers: cm.origins.downloadServers.count,\n\
  \        Emails: cm.origins.emails.count, ExternalFamily: cm.origins.external &&\
  \ cm.origins.external.family ? cm.origins.external.family.join(',') : '',\n    \
  \    ExternalCoverage: cm.origins.external.detectionCoverage, Provider: providers.xfe,\n\
  \        ProviderLink: 'https://exchange.xforce.ibmcloud.com/malware/' + cm.md5.replace(/^(0x)/,\"\
  \")\n      }};\n    } else if (entry.Brand === brands.vt && entry.Contents) {\n\
  \      return {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n\
  \        Resource: c.resource, ScanDate: c.scan_date, Positives: c.positives, Total:\
  \ c.total, SHA1: c.sha1, SHA256: c.sha256, Provider: providers.vt, ProviderLink:\
  \ c.permalink\n      }};\n    } else if (entry.Brand === brands.cy && entry.Contents)\
  \ {\n      var k = Object.keys(entry.Contents);\n      if (k && k.length > 0) {\n\
  \        var v = entry.Contents[k[0]];\n        if (v) {\n          return {ContentsFormat:\
  \ formats.table, Type: entryTypes.note, Contents: {\n            Status: v.status,\
  \ Code: v.statuscode, Score: v.generalscore, Classifiers: JSON.stringify(v.classifiers),\
  \ ConfirmCode: v.confirmcode, Error: v.error, Provider: providers.cy\n         \
  \ }};\n        }\n      }\n    } else if (entry.Brand === brands.wf && entry.Contents\
  \ && entry.Contents.wildfire && entry.Contents.wildfire.file_info) {\n      var\
  \ c = entry.Contents.wildfire.file_info;\n      return {ContentsFormat: formats.table,\
  \ Type: entryTypes.note, Contents: {\n        Type: c.filetype, Malware: c.malware,\
  \ MD5: c.md5, SHA256: c.sha256, Size: c.size, Provider: providers.wf\n      }};\n\
  \    } else if (entry.Brand === brands.cs && c && c.length && c[0].indicator) {\n\
  \      return shortCrowdStrike(entry);\n    } else if (entry.Brand === brands.threatconnect\
  \ && c && c.data && c.data.file) {\n      var file = c.data.file;\n      return\
  \ {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n        File:\
  \ file.file, Rating: file.rating, Confidence: file.confidence, Sha256: file.sha256,\
  \ Sha1: file.sha1, MD5: file.md5,\n        DateAdded: file.dateAdded, ID: file.id,\
  \ webLink: file.webLink, Provider: entry.Brand\n      }};\n    }\n  }\n  return\
  \ entry;\n}\n\n/**\n * Formats an ip reputation entry into a short table\n * @deprecated\n\
  \ * @param {Object} entry - reputation entry\n * @return {Object} the table entry\n\
  \ */\nfunction shortIP(entry) {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat\
  \ === formats.json) {\n    var c = entry.Contents;\n    if (entry.Brand === brands.xfe\
  \ && entry.Contents) {\n      var cr = c.reputation;\n      return {ContentsFormat:\
  \ formats.table, Type: entryTypes.note, Contents: {\n        IP: cr.ip, Score: cr.score,\
  \ Geo: cr.geo && cr.geo['country'] ? cr.geo['country'] : '',\n        Categories:\
  \ cr.cats ? JSON.stringify(cr.cats) : '', Provider: providers.xfe\n      }};\n \
  \   } else if (entry.Brand === brands.vt && entry.Contents) {\n      var positives\
  \ = 0;\n      for (var i = 0; i < entry.Contents.detected_urls.length; i++) {\n\
  \        if (entry.Contents.detected_urls[i].positives > thresholds.vtPositives)\
  \ {\n          positives++;\n        }\n      }\n      return {ContentsFormat: formats.table,\
  \ Type: entryTypes.note, Contents: {\n        DetectedURLs: positives, Provider:\
  \ providers.vt\n      }};\n    } else if (entry.Brand === brands.cs && c && c.length\
  \ && c[0].indicator) {\n      return shortCrowdStrike(entry);\n    } else if (entry.Brand\
  \ === brands.threatconnect && c && c.data && c.data.address) {\n      var addr =\
  \ c.data.address;\n      return {ContentsFormat: formats.table, Type: entryTypes.note,\
  \ Contents: {\n        IP: addr.ip, Rating: addr.rating, Confidence: addr.confidence,\n\
  \        DateAdded: addr.dateAdded, ID: addr.id, webLink: addr.webLink, Provider:\
  \ entry.Brand\n      }};\n    }\n  }\n  return entry;\n}\n\n/**\n * Formats a domain\
  \ reputation entry into a short table\n * @deprecated\n * @param {Object} entry\
  \ - reputation entry\n * @return {Object} the table entry\n */\nfunction shortDomain(entry)\
  \ {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat === formats.json)\
  \ {\n    if (entry.Brand === brands.vt && entry.Contents) {\n      var c = entry.Contents;\n\
  \      var positives = 0;\n      for (var i = 0; i < entry.Contents.detected_urls.length;\
  \ i++) {\n        if (entry.Contents.detected_urls[i].positives > 20) {\n      \
  \    positives++;\n        }\n      }\n      return {ContentsFormat: formats.table,\
  \ Type: entryTypes.note, Contents: {\n        DetectedURLs: positives, Provider:\
  \ providers.vt\n      }};\n    }\n  }\n  return entry;\n}\n\n/**\n * Flatten a JSON\
  \ tree object to key-value format\n * @param {Object} object - The object to be\
  \ flattened\n * @return {Object} the formatted object (key-value format)\n */\n\
  var treeToFlattenObject = function(object) {\n    if(typeof object !== 'object'\
  \ && !(Array.isArray(object))){\n        return object;\n    }\n    var retVal =\
  \ {};\n\n    for (var i in object) {\n        if (!object.hasOwnProperty(i)) continue;\n\
  \        if ((typeof object[i]) == 'object' && (!Array.isArray(object[i]) || !(object[i].length\
  \ == 0 || (typeof object[i][0] != 'object')))) {\n            var flatObject = treeToFlattenObject(object[i]);\n\
  \            for (var x in flatObject) {\n                if (!flatObject.hasOwnProperty(x))\
  \ continue;\n                retVal[i + '.' + x] = flatObject[x];\n            }\n\
  \        } else {\n            retVal[i] = object[i];\n        }\n    }\n    return\
  \ retVal;\n};\n\n\n/**\n * Base64 encode utiliy. Use Base64.encode(<value>) to encode\
  \ a string into base64\n * @return A base64 encoded string\n */\nvar Base64 = {\n\
  \      _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\
  ,\n      encode: function(input) {\n        var output = \"\";\n        var chr1,\
  \ chr2, chr3, enc1, enc2, enc3, enc4;\n        var i = 0;\n        while (i < input.length)\
  \ {\n          chr1 = input.charCodeAt(i++);\n          chr2 = input.charCodeAt(i++);\n\
  \          chr3 = input.charCodeAt(i++);\n          enc1 = chr1 >> 2;\n        \
  \  enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n          enc3 = ((chr2 & 15) << 2)\
  \ | (chr3 >> 6);\n          enc4 = chr3 & 63;\n          if (isNaN(chr2)) {\n  \
  \          enc3 = enc4 = 64;\n          } else if (isNaN(chr3)) {\n            enc4\
  \ = 64;\n          }\n          output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2)\
  \ + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n        }\n\n      \
  \  return output;\n      }\n};\n\n/**\n * Add the given obj to the path while making\
  \ sure to append Malicious property\n * @param {Object} context - The current war\
  \ room context, to which the value should be added\n * @param {String} path - The\
  \ context path in which the object shoud be added\n * @param {Object} obj - The\
  \ object to be flattened\n * @return {Undefined} The function does not return a\
  \ value\n */\nfunction addMalicious(context, path, obj) {\n    obj['properties_to_append']\
  \ = ['Malicious'];\n    context[path] = obj;\n}\n\n// Constants for common merge\
  \ paths\nvar outputPaths = {\n    file: 'File(val.MD5 && val.MD5 === obj.MD5 ||\
  \ val.SHA1 && val.SHA1 === obj.SHA1 || val.SHA256 && val.SHA256 === obj.SHA256)',\n\
  \    ip: 'IP(val.Address && val.Address === obj.Address)',\n    url: 'URL(val.Data\
  \ && val.Data === obj.Data)',\n    domain: 'Domain(val.Name && val.Name === obj.Name)',\n\
  \    cve: 'CVE(val.ID && val.ID === obj.ID)',\n    email: 'Account.Email(val.Address\
  \ && val.Address === obj.Address)'\n};\n\n\n/**\n * Converts score (in number format)\
  \ to human readable reputation format\n * @param {Int} score - The score to be formatted\n\
  \ * @return {String} The formatted score\n */\nfunction scoreToReputation(score)\
  \ {\n    if (score === 3){\n        return 'Bad';\n    }\n    if (score === 2){\n\
  \        return 'Suspicious';\n    }\n    if (score === 1){\n        return 'Good';\n\
  \    }\n    return 'None';\n};\n\n/**\n * Check if the given IP address is in the\
  \ given subnet\n * @param {String} ip - The IP address\n * @param {String} subnet\
  \ - The subnet\n * @return {String} True if IP is in the subnet, false otherwise\n\
  \ */\nfunction isIPInSubnet(ip, subnet) {\n    function IPnumber(IPaddress) {\n\
  \        var parsedIp = IPaddress.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n\
  \        if(parsedIp) {\n            return (+parsedIp[1]<<24) + (+parsedIp[2]<<16)\
  \ + (+parsedIp[3]<<8) + (+parsedIp[4]);\n        }\n        return null;\n    }\n\
  \n    function IPmask(maskSize) {\n        return -1<<(32-maskSize);\n    }\n\n\
  \    var parts = subnet.split('/');\n    if (parts.length == 1) {\n        return\
  \ ip == parts[0];\n    }\n    if (IPnumber(parts[0]) && parts[1].match(/^(\\d+)/))\
  \ {\n        return (IPnumber(ip) & IPmask(parts[1])) == IPnumber(parts[0]);\n \
  \   }\n    return false;\n}\n\n/**\n * Converts all cells in a JSON form Demisto\
  \ table to human-readable strings\n * @param {Object} obj - The Demisto table\n\
  \ * @return {Object} - A new Demisto table containing the same fields as formatted\
  \ strings\n */\nfunction formatTableValues(obj) {\n\n  /* Helper function to reduces\
  \ multiples newlines in a string */\n  var reduceNewlines = function(str) {\n  \
  \    var res = str;\n      while (res.indexOf('\\n\\n\\n') != -1) {\n          res\
  \ = res.replace('\\n\\n\\n', '\\n\\n');\n      }\n      return res;\n  }\n\n  /*\
  \ Helper function that handles the padding of new lines by depth */\n  var indent\
  \ = function(depth) {\n      var res = ''\n      for (var i = 0; i < (depth || 0);\
  \ i++) {\n          res += '  ';\n      }\n      return res;\n  }\n\n  /* Helper\
  \ function that rucurses an object, formatting it's values as strings */\n  var\
  \ formatTableValuesRecursive = function(obj, depth) {\n      var res = '';\n\n \
  \     /* Return non objects (or dates) as strings */\n      if (!obj || typeof obj\
  \ !== 'object' || !Object.keys(obj).length) {\n            return indent(depth ||\
  \ 0) + obj + '\\n';  // this will always convert to string type\n      }\n\n   \
  \   /* Recurse all object keys, formatting values as independent lines, increasing\
  \ depth with each call */\n      Object.keys(obj).forEach(function(key) {\n    \
  \      var value = obj[key];\n          var isArrayElement = obj instanceof Array;\n\
  \n          /* Handle object values in a new call */\n          if (typeof value\
  \ === 'object') {\n              if (isArrayElement) {\n                  res +=\
  \ formatTableValuesRecursive(value, (depth || 0)) + '\\n';\n              } else\
  \ {\n                  res += indent(depth) + key + '\\n';\n                  res\
  \ += formatTableValuesRecursive(value, (depth || 0) + 1) + '\\n';\n            \
  \  }\n          } else {\n              /* Format primitives as a string */\n  \
  \            var keyStr = (isArrayElement) ? (parseInt(key) + 1) : key;    // 1-based\
  \ indexing for arrays for better readability\n              res += indent(depth)\
  \ + keyStr + ': ' + value + '\\n';\n          }\n      });\n\n      res = reduceNewlines(res);\n\
  \      return res;\n  }\n\n  /* Run all object keys and invoke the recursive helper\
  \ function */\n  if (!obj || typeof obj !== 'object' || !Object.keys(obj).length)\
  \ {\n      return obj;\n  }\n  var res = {};\n  Object.keys(obj).forEach(function(key)\
  \ {\n      var str = formatTableValuesRecursive(obj[key]);\n      str = str.trim('\\\
  n');   //There's no need for a newline at the end of the entire stirng\n      res[key]\
  \ = str;\n  });\n\n  return res;\n}\n\n/********************************** Date\
  \ Formatting **************************************/\n/* Date formats\n  %d - day\
  \ 01, 02 ... 31\n  %m - month 01, 02 .. 12\n  %y - 95, 17\n  %Y - year 1995, 2017\n\
  \  %H - hour 01, 02 .. 24\n  %M - minute 01, 02 .. 60\n  %S - seconds 01, 02 ..\
  \ 60\n  %f - millisecond 001, 002, 003 ... 999\n  %z - timezone (empty), +0000,\
  \ -0400, +1030\n  %Z - timezone (empty), UTC, EST, CST\n*/\nvar month_names_short\
  \ = {\n    'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun':6, 'Jul':7, 'Aug':8,\
  \ 'Sep':9, 'Oct':20, 'Nov':11, 'Dec':0\n};\n\n/**\n * Formats a date object to a\
  \ string according to the given format.\n * @deprecated\n * @param {Date} date -\
  \ The date object to be formatted\n * @param {Date} format - The format string.\
  \ Should be a legal python datetime format (e.g. \"%d %Y %H:%M:%S\")\n * @return\
  \ {string} A string representation of date object according to format\n */\nfunction\
  \ dateToString(date, format) {\n    if (!date || !(date instanceof Date) || typeof\
  \ date.getMonth !== 'function' || String(date.getDate()) === 'NaN') {\n        throw\
  \ date + ' must be of type Date';\n    }\n\n    var dateString = format;\n    if\
  \ (format.indexOf('%d') > -1) {\n        if (Number(date.getDate()) < 10) {\n  \
  \          dateString = dateString.replace('%d', '0' + date.getDate());\n      \
  \  } else {\n            dateString = dateString.replace('%d', date.getDate());\n\
  \        }\n    }\n    if (format.indexOf('%m') > -1) {\n        if (Number(date.getMonth())\
  \ + 1 < 10) {\n            dateString = dateString.replace('%m', '0' + (date.getMonth()\
  \ + 1));\n        } else {\n            dateString = dateString.replace('%m', date.getMonth()\
  \ + 1);\n        }\n    }\n    if (format.indexOf('%y') > -1) {\n        if (Number(date.getYear())\
  \ < 10) {\n            dateString = dateString.replace('%y', '0' + date.getYear());\n\
  \        } else {\n            dateString = dateString.replace('%y', date.getYear());\n\
  \        }\n    }\n    if (format.indexOf('%Y') > -1) {\n        dateString = dateString.replace('%Y',\
  \ date.getFullYear());\n    }\n    if (format.indexOf('%H') > -1) {\n        if\
  \ (date.getHours() < 10) {\n            dateString = dateString.replace('%H', '0'\
  \ + date.getHours());\n        } else {\n            dateString = dateString.replace('%H',\
  \ date.getHours());\n        }\n    }\n    if (format.indexOf('%M') > -1) {\n  \
  \      if (date.getMinutes() < 10) {\n            dateString = dateString.replace('%M',\
  \ '0' + date.getMinutes());\n        } else {\n            dateString = dateString.replace('%M',\
  \ date.getMinutes());\n        }\n    }\n    if (format.indexOf('%S') > -1) {\n\
  \        if (date.getSeconds() < 10) {\n            dateString = dateString.replace('%S',\
  \ '0' + date.getSeconds());\n        } else {\n            dateString = dateString.replace('%S',\
  \ date.getSeconds());\n        }\n    }\n    if (format.indexOf('%f') > -1) {\n\
  \        if (date.getMilliseconds() < 10) {\n            dateString = dateString.replace('%f',\
  \ '00' + date.getMilliseconds());\n        } else if (date.getMilliseconds() < 100)\
  \ {\n            dateString = dateString.replace('%f', '0' + date.getMilliseconds());\n\
  \        } else {\n            dateString = dateString.replace('%f', date.getMilliseconds());\n\
  \        }\n    }\n\n    return dateString;\n}\n\n/**\n * Parses date string to\
  \ date object.\n * @deprecated\n * @param {string} dateString - date as string\n\
  \ * @param {string} format - the dateString must fit the format.\n * format is according\
  \ to date format of python datetime library\n * @return {Date} parsed date object\n\
  \ */\nfunction stringToDate(dateString, format) {\n    if (typeof dateString !==\
  \ 'string') {\n        throw dateString  + ' must be string';\n    } else if (typeof\
  \ format !== 'string') {\n        throw format + ' must be string';\n    }\n\n \
  \   var newDate = new Date(1970, 0, 1, 0, 0, 0, 0);\n    var newString = dateString;\n\
  \    var delta = 0;\n    for(var i = 0; i < format.length - 1; i++) {\n        switch\
  \ (format.charAt(i) + format.charAt(i + 1)) {\n            case '%d':\n        \
  \        var d = newString.substring(delta + i, delta + i + 2);\n              \
  \  newDate.setDate(Number(d));\n                break;\n            case '%m':\n\
  \                var m = newString.substring(delta + i, delta + i + 2);\n      \
  \          newDate.setMonth(Number(m) - 1);\n                break;\n          \
  \  case '%b':\n                var b = newString.substring(delta + i, delta + i\
  \ + 3);\n                var month = month_names_short[b];\n                newDate.setMonth(month\
  \ - 1);\n                delta += 1;\n                break;\n            case '%y':\n\
  \                var y = newString.substring(delta + i, delta + i + 2);\n      \
  \          newDate.setYear('20' + y);\n                break;\n            case\
  \ '%Y':\n                var Y = newString.substring(delta + i, delta + i + 4);\n\
  \                newDate.setFullYear(Y);\n                delta += 2;\n        \
  \        break;\n            case '%H':\n                var H = newString.substring(delta\
  \ + i, delta + i + 2);\n                newDate.setHours(H);\n                break;\n\
  \            case '%M':\n                var M = newString.substring(delta + i,\
  \ delta + i + 2);\n                newDate.setMinutes(M);\n                break;\n\
  \            case '%S':\n                var S = newString.substring(delta + i,\
  \ delta + i + 2);\n                newDate.setSeconds(S);\n                break;\n\
  \            case '%f':\n                var f = newString.substring(delta + i,\
  \ delta + i + 3);\n                newDate.setMilliseconds(f);\n               \
  \ delta += 1;\n                break;\n        }\n    }\n\n    return newDate;\n\
  }\n\n/********************************** Date Formatting end **************************************/\n\
  \n/********************************** HMAC_SHA256 **************************************/\n\
  \n    /* string_to_array: convert a string to a character (byte) array */\n    function\
  \ string_to_array(str) {\n      var len = str.length;\n      var res = new Array(len);\n\
  \      for(var i = 0; i < len; i++)\n        res[i] = str.charCodeAt(i);\n     \
  \ return res;\n    }\n\n    /* array_to_hex_string: convert a byte array to a hexadecimal\
  \ string */\n    function array_to_hex_string(ary) {\n      var res = \"\";\n  \
  \    for(var i = 0; i < ary.length; i++)\n        res += SHA256_hexchars[ary[i]\
  \ >> 4] + SHA256_hexchars[ary[i] & 0x0f];\n      return res;\n    }\n\n\n    /*\
  \ The following are the SHA256 routines */\n\n    /*\n       SHA256_init: initialize\
  \ the internal state of the hash function. Call this\n       function before calling\
  \ the SHA256_write function.\n    */\n\n    function SHA256_init() {\n      SHA256_H\
  \ = new Array(0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f,\
  \ 0x9b05688c, 0x1f83d9ab, 0x5be0cd19);\n      SHA256_buf = new Array();\n      SHA256_len\
  \ = 0;\n    }\n\n    /*\n       SHA256_write: add a message fragment to the hash\
  \ function's internal state.\n       'msg' may be given as string or as byte array\
  \ and may have arbitrary length.\n\n    */\n\n    function SHA256_write(msg) {\n\
  \      if (typeof(msg) == \"string\")\n        SHA256_buf = SHA256_buf.concat(string_to_array(msg));\n\
  \      else\n        SHA256_buf = SHA256_buf.concat(msg);\n      for(var i = 0;\
  \ i + 64 <= SHA256_buf.length; i += 64)\n        SHA256_Hash_Byte_Block(SHA256_H,\
  \ SHA256_buf.slice(i, i + 64));\n      SHA256_buf = SHA256_buf.slice(i);\n     \
  \ SHA256_len += msg.length;\n    }\n\n    /*\n       SHA256_finalize: finalize the\
  \ hash value calculation. Call this function\n       after the last call to SHA256_write.\
  \ An array of 32 bytes (= 256 bits)\n       is returned.\n    */\n\n    function\
  \ SHA256_finalize() {\n      SHA256_buf[SHA256_buf.length] = 0x80;\n\n      if (SHA256_buf.length\
  \ > 64 - 8) {\n        for(var i = SHA256_buf.length; i < 64; i++)\n          SHA256_buf[i]\
  \ = 0;\n        SHA256_Hash_Byte_Block(SHA256_H, SHA256_buf);\n        SHA256_buf.length\
  \ = 0;\n      }\n\n      for(var i = SHA256_buf.length; i < 64 - 5; i++)\n     \
  \   SHA256_buf[i] = 0;\n        SHA256_buf[59] = (SHA256_len >>> 29) & 0xff;\n \
  \       SHA256_buf[60] = (SHA256_len >>> 21) & 0xff;\n        SHA256_buf[61] = (SHA256_len\
  \ >>> 13) & 0xff;\n        SHA256_buf[62] = (SHA256_len >>> 5) & 0xff;\n       \
  \ SHA256_buf[63] = (SHA256_len << 3) & 0xff;\n        SHA256_Hash_Byte_Block(SHA256_H,\
  \ SHA256_buf);\n        var res = new Array(32);\n\n        for(var i = 0; i < 8;\
  \ i++) {\n            res[4 * i + 0] = SHA256_H[i] >>> 24;\n            res[4 *\
  \ i + 1] = (SHA256_H[i] >> 16) & 0xff;\n            res[4 * i + 2] = (SHA256_H[i]\
  \ >> 8) & 0xff;\n            res[4 * i + 3] = SHA256_H[i] & 0xff;\n        }\n\n\
  \        SHA256_H = undefined;\n        SHA256_buf = undefined;\n        SHA256_len\
  \ = undefined;\n        return res;\n    }\n\n    /*\n       SHA256_hash: calculate\
  \ the hash value of the string or byte array 'msg'\n       and return it as hexadecimal\
  \ string. This shortcut function may be more\n       convenient than calling SHA256_init,\
  \ SHA256_write, SHA256_finalize\n       and array_to_hex_string explicitly.\n  \
  \  */\n\n    function SHA256_hash(msg) {\n      var res;\n      SHA256_init();\n\
  \      SHA256_write(msg);\n      res = SHA256_finalize();\n      return array_to_hex_string(res);\n\
  \    }\n\n    /* The following are the HMAC-SHA256 routines */\n\n    /*\n     \
  \  HMAC_SHA256_init: initialize the MAC's internal state. The MAC key 'key'\n  \
  \     may be given as string or as byte array and may have arbitrary length.\n \
  \   */\n\n    function HMAC_SHA256_init(key) {\n      if (typeof(key) == \"string\"\
  )\n        HMAC_SHA256_key = string_to_array(key);\n      else\n        HMAC_SHA256_key\
  \ = new Array().concat(key);\n\n      if (HMAC_SHA256_key.length > 64) {\n     \
  \   SHA256_init();\n        SHA256_write(HMAC_SHA256_key);\n        HMAC_SHA256_key\
  \ = SHA256_finalize();\n      }\n\n      for(var i = HMAC_SHA256_key.length; i <\
  \ 64; i++)\n        HMAC_SHA256_key[i] = 0;\n      for(var i = 0; i < 64; i++)\n\
  \        HMAC_SHA256_key[i] ^=  0x36;\n      SHA256_init();\n      SHA256_write(HMAC_SHA256_key);\n\
  \    }\n\n    /*\n       HMAC_SHA256_write: process a message fragment. 'msg' may\
  \ be given as\n       string or as byte array and may have arbitrary length.\n \
  \   */\n\n    function HMAC_SHA256_write(msg) {\n      SHA256_write(msg);\n    }\n\
  \n    /*\n       HMAC_SHA256_finalize: finalize the HMAC calculation. An array of\
  \ 32 bytes\n       (= 256 bits) is returned.\n    */\n\n    function HMAC_SHA256_finalize()\
  \ {\n      var md = SHA256_finalize();\n      for(var i = 0; i < 64; i++)\n    \
  \    HMAC_SHA256_key[i] ^= 0x36 ^ 0x5c;\n      SHA256_init();\n      SHA256_write(HMAC_SHA256_key);\n\
  \      SHA256_write(md);\n      for(var i = 0; i < 64; i++)\n        HMAC_SHA256_key[i]\
  \ = 0;\n      HMAC_SHA256_key = undefined;\n      return SHA256_finalize();\n  \
  \  }\n\n    /*\n       HMAC_SHA256_MAC: calculate the HMAC value of message 'msg'\
  \ under key 'key'\n       (both may be of type string or byte array); return the\
  \ MAC as hexadecimal\n       string. This shortcut function may be more convenient\
  \ than calling\n       HMAC_SHA256_init, HMAC_SHA256_write, HMAC_SHA256_finalize\
  \ and\n       array_to_hex_string explicitly.\n    */\n\n    function HMAC_SHA256_MAC(key,\
  \ msg) {\n      var res;\n      HMAC_SHA256_init(key);\n      HMAC_SHA256_write(msg);\n\
  \      res = HMAC_SHA256_finalize();\n      return array_to_hex_string(res);\n \
  \   }\n\n    /* The following lookup tables and functions are for internal use only!\
  \ */\n\n    SHA256_hexchars = new Array('0', '1', '2', '3', '4', '5', '6', '7',\
  \ '8', '9',\n      'a', 'b', 'c', 'd', 'e', 'f');\n\n    SHA256_K = new Array(\n\
  \      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n\
  \      0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\
  \      0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n\
  \      0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\
  \      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n\
  \      0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\
  \      0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n\
  \      0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\
  \      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n\
  \      0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\
  \      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n    );\n\n    function SHA256_sigma0(x)\
  \ {\n      return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);\n\
  \    }\n\n    function SHA256_sigma1(x) {\n      return ((x >>> 17) | (x << 15))\
  \ ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);\n    }\n\n    function SHA256_Sigma0(x)\
  \ {\n      return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^\n       \
  \ ((x >>> 22) | (x << 10));\n    }\n\n    function SHA256_Sigma1(x) {\n      return\
  \ ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^\n        ((x >>> 25) | (x\
  \ << 7));\n    }\n\n    function SHA256_Ch(x, y, z) {\n      return z ^ (x & (y\
  \ ^ z));\n    }\n\n    function SHA256_Maj(x, y, z) {\n      return (x & y) ^ (z\
  \ & (x ^ y));\n    }\n\n    function SHA256_Hash_Word_Block(H, W) {\n      for(var\
  \ i = 16; i < 64; i++)\n        W[i] = (SHA256_sigma1(W[i - 2]) +  W[i - 7] +\n\
  \          SHA256_sigma0(W[i - 15]) + W[i - 16]) & 0xffffffff;\n      var state\
  \ = new Array().concat(H);\n      for(var i = 0; i < 64; i++) {\n        var T1\
  \ = state[7] + SHA256_Sigma1(state[4]) +\n          SHA256_Ch(state[4], state[5],\
  \ state[6]) + SHA256_K[i] + W[i];\n        var T2 = SHA256_Sigma0(state[0]) + SHA256_Maj(state[0],\
  \ state[1], state[2]);\n        state.pop();\n        state.unshift((T1 + T2) &\
  \ 0xffffffff);\n        state[4] = (state[4] + T1) & 0xffffffff;\n      }\n    \
  \  for(var i = 0; i < 8; i++)\n        H[i] = (H[i] + state[i]) & 0xffffffff;\n\
  \    }\n\n    function SHA256_Hash_Byte_Block(H, w) {\n      var W = new Array(16);\n\
  \      for(var i = 0; i < 16; i++)\n        W[i] = w[4 * i + 0] << 24 | w[4 * i\
  \ + 1] << 16 |\n          w[4 * i + 2] << 8 | w[4 * i + 3];\n      SHA256_Hash_Word_Block(H,\
  \ W);\n    }\n\n    /**************************** HMAC_SHA256 end *******************************/\n\
  \n  /**************************** REGEX FORMATTING *******************************/\n\
  \n    var ipRegex = /\\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\\
  b/;\n    var emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\\
  b/;\n    var hashRegex = /[a-fA-F0-9]/;\n    var md5Regex = /\\b[a-fA-F\\d]{32}\\\
  b/gm;\n    var sha1Regex = /\\b[a-fA-F\\d]{40}\\b/gm;\n    var sha256Regex = /\\\
  b[a-fA-F\\d]{64}\\b/gm;\n\n  /**************************** REGEX FORMATTING end\
  \ *******************************/"
scripttarget: 0
system: true
tags:
- infra
- server
tests:
- Test CommonServer
timeout: 0s
toversion: 4.1.9
type: javascript
