commonfields:
  id: RSA NetWitness Security Analytics
  version: -1
name: RSA NetWitness Security Analytics
system: true
fromversion: 5.0.0
display: RSA NetWitness Security Analytics
category: Analytics & SIEM
image: data:image/png;base64,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
description: RSA Security Analytics, compatible with prior to v11. A distributed and modular system that enables highly flexible deployment architectures that scale with the needs of the organization. Security Analytics allows administrators to collect two types of data from the network infrastructure, packet data and log data.
configuration:
- display: Server Url (192.168.56.101)
  name: url
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: username
  defaultvalue: ""
  type: 0
  required: true
- display: Password
  name: password
  defaultvalue: ""
  type: 4
  required: true
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: >-
    var url = params.url;

    if (url.indexOf("https://") < 0) {
        url = 'https://' + url;
    }

    var username = params.username;

    var password = params.password;

    var proxy = params.proxy || false;

    var COOKIE_PREFIX = 'RSA_SA_LICENSE=true; JSESSIONID=';


    function FailedRequestError(message, url, query, reqBody, resBody) {
        return {
            message: message,
            url: url,
            query: query,
            reqBody: reqBody,
            resBody: resBody,
            toString: function() {
                var error = [
                    message,
                    'Request url: ' + url,
                ];

                if (query) {
                    error.push('Request query: ' + JSON.stringify(query));
                }
                if (reqBody) {
                    error.push('Request body:' + JSON.stringify(reqBody));
                }

                error.push('Response: ' + resBody);

                return error.join('\n');
            }
        };
    }


    function escapeRegExp(str) {
        return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    }


    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
    }


    function login(url, username, password) {
        var fullUrl = url + '/j_spring_security_check';
        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Origin': [url],
                    'Content-Type': ['application/x-www-form-urlencoded'],
                    'Referer': [url + '/login']
                },
                Body: 'j_username=' + username + '&j_password=' + password
            },
            true,
            proxy,
            true
        );

        if (res.StatusCode !== 302) {
            throw 'Failed to login with status [' + res.StatusCode + ']. Expected status 302. Check username or password. \nOriginal error: ' + res.Body;
        }

        var sessionId = null;
        res.Cookies.forEach(function(cookie) {
            if (cookie.Name === 'JSESSIONID') {
                sessionId = cookie.Value;
            }
        });

        try {
            getAvailableAssignees(sessionId);
        } catch(err) {
            throw 'Failed to login! Check username or password. Error: ' + err;
        }

        return sessionId;
    }


    function logout(url, sessionId) {
        var fullUrl = url + '/j_spring_security_logout';

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Origin': [url],
                    'Content-Type': ['application/x-www-form-urlencoded'],
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy,
            true
        );

        if (res.StatusCode !== 302) {
            throw 'Failed to logout with status [' + res.StatusCode + ']. Expected status 302.\nOriginal error: ' + res.Body;
        }
    }


    function createQuery(args, defaultQuery) {
        args = args || {};
        defaultQuery = defaultQuery || {};
        var query = {};

        if (args.page || defaultQuery.page) {
            query.page = args.page || defaultQuery.page;
        }

        if (args.start || defaultQuery.start) {
            query.start = args.start || defaultQuery.start;
        }

        if (args.limit || defaultQuery.limit) {
            query.limit = args.limit || defaultQuery.limit;
        }

        if (args.sort || defaultQuery.sort) {
            query.sort = args.sort || defaultQuery.sort;
        }

        if (args.filter || defaultQuery.filter) {
            query.filter = args.filter || defaultQuery.filter;
        }

        return query;
    }


    function createQueryFromString(q) {
        if (!q.match(/(.*=.*&)*(.*=.*)/)) {
            throw 'invalid query. query must be of structure: key1=value1&key2=value2&keyN=valueN';
        }
        var query = replaceAll(q, '\"', '"')
            .split('&')
            .reduce(function(qArgs, nextArg) {
                var na = nextArg.split('=');
                var argKey = na[0];
                var argValue = na[1];
                qArgs[argKey] = argValue;
                return qArgs;
            }, {});

        return query;
    }


    var defaultIncidentFilter = {
        page: 1,
        start: 0,
        limit: 50,
        sort: JSON.stringify([
            {
                property:'created',
                direction: 'DESC'
            }
        ]),
        filter: JSON.stringify([
            {
                property: 'created',
                value: [
                    851171984031, // year 1996
                    new Date().getTime()
                ]
            }
        ])
    };


    function listIncidents(sessionId, args, incidentManagementId) {
        var fullUrl = url + '/ajax/incidents/' + incidentManagementId;
        var query = {};
        if (args.query) {
            query = createQueryFromString(args.query);
        } else {
            query = createQuery(args, defaultIncidentFilter);
        }

        fullUrl += encodeToURLQuery(query);

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch incidents with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            incidentsRes = JSON.parse(res.Body);
            if (incidentsRes.success) {
                var incidents = incidentsRes.data;
                if (!args.loadAlerts) {
                    return incidents;
                }

                // loading all the alerts which related to incident
                // we load the alerts and original alerts which contains the original events which the alert created from
                // this has performance impact
                for (var i = 0; i < incidents.length; i++) {
                    var alerts = filterAlerts(sessionId, {
                        filter: JSON.stringify([
                            {
                                property: 'incidentId',
                                value: incidents[i].id
                            }
                        ])
                    })
                    incidents[i].alerts = [];
                    alerts.forEach(function(alert) {
                        var originalAlert = getOriginalAlertById(sessionId, { alertId: alert.id });
                        incidents[i].alerts.push({
                            alert: alert,
                            orignalAlert: originalAlert
                        });
                    });
                }

                return incidents;
            } else {
                throw FailedRequestError('Fetch incidents failed.', fullUrl, query, null, incidentsRes).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error while fetching incidents. \nOriginal error: ' + err, fullUrl, query, null, res.Body).toString();
        }
    }


    function fetchIncidents(sessionId, args, incidentManagementId) {
        var now = new Date().getTime();
        var lastRun = getLastRun().lastRun || now - 1*60*1000; // last minute
        var lastRunNext = lastRun;

        var tillNow = now;
        var query = {
            loadAlerts: true,
            page: 1,
            start: 0,
            limit: 50,
            filter: JSON.stringify([{
                property: 'created',
                value: [
                    lastRun,
                    tillNow
                ]
            }])
        };

        // TODO handle paging. If number of incidents are more than 50, then we need to
        // fetch the next pages too.
        var lastIncidents = listIncidents(sessionId, query, incidentManagementId);
        var convertedIncidents = [];
        for (var i = 0; i < lastIncidents.length; i++) {
            var inc = lastIncidents[i];
            if (inc.created > lastRunNext) {
                // we get the last incident which created
                lastRunNext = inc.created + 1;
            }

            convertedIncidents.push({
                name: inc.id,
                occurred: new Date(inc.firstAlertTime),
                owner: inc.assignee ? inc.assignee.login : '',
                reason: inc.name,
                rawJSON: JSON.stringify(inc)
            });
        }

        setLastRun({ lastRun: lastRunNext });
        return JSON.stringify(convertedIncidents);
    }


    function getIncidentById(sessionId, args, incidentManagementId) {
        var fullUrl = [
            url,
            'ajax/incident',
            incidentManagementId,
            args.incidentId
        ].join('/');

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to get incident by id with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            incident = JSON.parse(res.Body);
            if (incident.success) {
                return incident.data;
            } else {
                throw FailedRequestError('Fetch incident by id failed.', fullUrl, null, null, incident).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error while fetching incident by id. \nOriginal error: ' + err, fullUrl, null, null, res.Body).toString();
        }
    }


    var defaultComponentFilter = {
        page: 1,
        start: 0,
        limit: 1000,
        sort: replaceAll(JSON.stringify([
            {
                property: 'displayName',
                direction: 'ASC'
            }
        ]), '\"', '"')
    };


    function getComponents(sessionId, argz, types) {
        var fullUrl = url + '/common/devices';
        var query = {};
        if (argz.query) {
            query = createQueryFromString(argz.query);
        } else {
            query = createQuery(argz, defaultComponentFilter);
        }
        fullUrl += types ? '/types/' + types.join('/') : '';
        fullUrl += encodeToURLQuery(query);

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch components with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            components = JSON.parse(res.Body);
            if (components.success) {
                return components.data;
            } else {
                throw FailedRequestError('Fetch components failed.', fullUrl, query, null, components).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error when fetching components. \nOriginal error: ' + err, fullUrl, query, null, res.Body).toString();
        }
    }


    function getIncidentManagementId(sessionId) {
        var incidentManagement = getComponents(sessionId, {}, ['INCIDENT_MANAGEMENT']);

        if (!incidentManagement || incidentManagement.length === 0) {
            throw 'Failed to find RSA NetWitness INCIDENT_MANAGEMENT component/device: ' + JSON.stringify(incidentManagement);
        }

        return incidentManagement[0].id;
    }


    function createEventsQuery(args, predicateIds) {
        args = args || {};
        var query = {};

        query.deviceId = args.deviceId;
        query.collectionName = args.collectionName || '';
        query.predicateIds = predicateIds ? predicateIds.join(',') : '';
        query.timeRangeType = args.timeRangeType;
        query.startDate = args.startDate || '';
        query.endDate = args.endDate || '';
        query.lastCollectionTime = args.lastCollectionTime || '';
        query.mid1 = args.mid1 || 0;
        query.mid2 = args.mid2 || 0;
        query.investigationToken = args.investigationToken || '';
        query.page = args.page || 1;
        query.start = args.start || 0;
        query.limit = args.limit || 25;
        query.sort = args.sort
            ? replaceAll(args.sort, '\"', '"')
            : JSON.stringify([
                {
                    property: 'id',
                    direction: 'ASC'
                }
            ]);

        return query;
    }

    function getEvents(sessionId, args) {
        var predicateIds = [];
        if (args.filter) {
            var eventsViewHTML = getEventsViewHtml(sessionId);
            var csrfToken = extractCsrfTokenFromHTML(eventsViewHTML);
            var filters = args.filter.split(',');
            for (var i = 0; i < filters.length; i++) {
                var predicate = postEventsTransient(sessionId, filters[i], csrfToken);
                predicateIds.push(predicate);
            }
        }
        var query = createEventsQuery(args, predicateIds);
        var fullUrl = url + '/ajax/investigation/events' + encodeToURLQuery(query);

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch events with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            events = JSON.parse(res.Body);
            if (events.success) {
                return events.data;
            } else {
                throw FailedRequestError('Fetch events failed.', fullUrl, query, null, events).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected while fetching events. \nOriginal error: ' + err, fullUrl, query, null, res.Body).toString();
        }
    }

    function postEventsTransient(sessionId, query, ctoken) {
        var fullUrl = url + '/predicates/transient';
        var body = {
            name: query,
            query: query,
            ctoken: ctoken
        };
        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId],
                    'Content-Type': ['application/x-www-form-urlencoded']
                },
                Body: encodeToURLQuery(body).replace(/^\?/, '')
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch events with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            transient = JSON.parse(res.Body);
            if (transient.success) {
                return transient.object;
            } else {
                throw FailedRequestError('Posting transient for events failed.', fullUrl, null, body, transient).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected while posting transient for events. \nOriginal error: ' + err, fullUrl, null, body, res.Body).toString();
        }
    }


    function getEventDetails(sessionId, args) {
        var fullUrl = url + '/investigation/reconstruct/event';
        var eventsViewHTML = getEventsViewHtml(sessionId);
        var csrfToken = extractCsrfTokenFromHTML(eventsViewHTML);

        var body = {
            deviceId: args.deviceId,
            collectionName: args.collectionName || '',
            eventId: args.eventId,
            contentType: 'AUTO',
            contentSide: 'REQUEST_AND_RESPONSE',
            contentLayout: 'TOP_TO_BOTTOM',
            packetOverride: -1,
            ctoken: csrfToken
        };
        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId],
                    'Content-Type': ['application/x-www-form-urlencoded']
                },
                Body: encodeToURLQuery(body).replace(/^\?/, '')
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch event with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            event = JSON.parse(res.Body);
            if (event.success) {
                var content = getEventContent(sessionId, event.data.uri);
                return {data: event.data, content: content};
            } else {
                throw FailedRequestError('Fetching event details', fullUrl, null, body, event).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected while fetching event details. \nOriginal error: ' + err, fullUrl, null, body, res.Body).toString();
        }
    }


    // Returns events/session data content.

    function getEventContent(sessionId, urlSuffix) {
        var fullUrl = url + urlSuffix;
        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch event data (recontruction) with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            return res.Body;
        } catch (err) {
            throw FailedRequestError('Unexpected while fetching event data (recontruction). \nOriginal error: ' + err, fullUrl, query, null, res.Body).toString();
        }
    }


    var defaultAlertQuery = {
        page: 1,
        start: 0,
        limit: 100,
        sort: JSON.stringify([
            {
                property:'alert.timestamp',
                direction: 'DESC'
            }
        ]),
        filter: JSON.stringify([
            {
                property: 'alert.timestamp',
                value: [
                    851171984031, // year 1996
                    new Date().getTime()
                ]
            }
        ])
    };

    function filterAlerts(sessionId, args) {
        var query = createQuery(args, defaultAlertQuery);
        var fullUrl = [
            url,
            '/ajax/alerts/',
            incidentManagementId,
            encodeToURLQuery(query)
        ].join('');

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch alerts with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            alerts = JSON.parse(res.Body);
            if (alerts.success) {
                return alerts.data;
            } else {
                throw FailedRequestError('Fetch alerts failed.', fullUrl, query, null, alerts).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected while fetching alerts. Original error:' + err, fullUrl, query, null, res.Body).toString();
        }
    }


    function getAlertById(sessionId, args) {
        var fullUrl = [
            url,
            'ajax/alerts',
            incidentManagementId,
            args.alertId
        ].join('/');

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to get events of alert with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            alert = JSON.parse(res.Body);
            if (alert.success) {
                return alert.data;
            } else {
                throw FailedRequestError('Fetch alert details failed.', fullUrl, query, null, alert).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected while fetching alert details. \nOriginal error: ' + err, fullUrl, null, null, res.Body).toString();
        }
    }


    function getOriginalAlertById(sessionId, args) {
        var fullUrl = [
            url,
            'ajax/alerts/originalalert',
            incidentManagementId,
            args.alertId
        ].join('/');

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to get events of alert with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            alert = JSON.parse(res.Body);
            if (alert.success) {
                return alert.data;
            } else {
                throw FailedRequestError('Fetch alert details failed.', fullUrl, query, null, alert).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected while fetching alert details. \nOriginal error: ' + err, fullUrl, null, null, res.Body).toString();
        }
    }


    function getAvailableAssignees(sessionId) {
        var fullUrl = url + '/ajax/incident/user/availableAssignees';

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': ['RSA_SA_LICENSE=true; SaneID=10.64.49.14-1456516139492605; s_pers=%20s_fid%3D0D47AAAFD2A1592B-3436DC4A7A7EB300%7C1531522908438%3B%20gpv_pn%3DMYTOOLSSTATIC%252FTOOLS%252FTHE%2520SQUARE%7C1468452708438%3B%20s_lv%3D1468450908454%7C1563058908454%3B%20s_lv_s%3DLess%2520than%25201%2520day%7C1468452708454%3B; s_vi=[CS]v1|2B6795DE050118E9-40001608C00050FA[CE]; s_fid=3D8DF632622AC544-1283F8DF4BA4E8DC; JSESSIONID=' + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch availabe assignees with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            availableAssignees = JSON.parse(res.Body);
            if (availableAssignees.success) {
                return availableAssignees.data;
            } else {
                throw FailedRequestError('Fetch available assignees failed.', fullUrl, null, null, availableAssignees).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error while fetching available assignees. \nOriginal error: ' + err, fullUrl, null, null, res.Body).toString();
        }
    }


    function getEventsViewHtml(sessionId) {
        var fullUrl = url + '/investigation/events';

        var res = http(
            fullUrl,
            {
                Method: 'GET',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId]
                }
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to fetch CSRF token with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        return res.Body;
    }


    function extractCsrfTokenFromHTML(html) {
        var matched = html.match(/<meta name="csrf-token" content=".*"/);
        if (!matched) {
            throw 'CSRF token not found! Internal error in NetWitness. Response  body: \n' + html;
        }

        var csrfToken = replaceAll(matched[0].replace('<meta name="csrf-token" content=', ''), '"', '');
        return csrfToken;
    }


    function extractLoggedUserFromHTML(html) {
        var matchedLoggedUser = html.match(/name: Ext\.htmlDecode\(.*\)/);
        if (!matchedLoggedUser) {
            throw 'Failed to determine logged in user. Html: ' + html;
        }

        var name = matchedLoggedUser[0].replace('name: Ext.htmlDecode(\'', '').replace('\')', '');
        var user = {
            name: name
        };

        return user;
    }


    var DEFAULT_SEVERITY = "50";

    function createAlert(sessionId, args, incidentManagementId, createdUser, csrfToken) {
        var eventListString = replaceAll(args.eventList, ' ', '');
        var fullUrl = [
            url,
            'ajax/alert/create',
            args.deviceId,
            eventListString,
            incidentManagementId + '',
            '?ctoken=' + csrfToken
        ].join('/');

        var body = {
            alertSummary: args.alertSummary,
            event_id_list: eventListString.split(','),
            severity: args.severity ? args.severity + '' : DEFAULT_SEVERITY,
            create_by_user: createdUser.name
        };

        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId],
                    'Content-Type': ['application/json']
                },
                Body: JSON.stringify(body)
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to create new alert with status [' + res.StatusCode + ']. \nOriginal error: ' + res.Body;
        }

        try {
            var alertRes = JSON.parse(res.Body);
            if (alertRes.success) {
                return alertRes.data;
            } else {
                throw FailedRequestError('Failed to create alert.', fullUrl, null, body, alertRes).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error while creating alert. \nOriginal error: ' + err, fullUrl, null, body, res.Body).toString();
        }
    }


    function createIncident(sessionId, args, incidentManagementId, availableAssignees) {
        var eventsViewHTML = getEventsViewHtml(sessionId);
        var csrfToken = extractCsrfTokenFromHTML(eventsViewHTML);
        var loggedUser = extractLoggedUserFromHTML(eventsViewHTML);
        // currently we extract only the name of the logged in user. But the all the user object is exist in the html.
        // it just will take more development time.
        // that is why we look for the user in availableAssigness
        availableAssignees.forEach(function(user) {
            if (user.name === loggedUser.name) {
                loggedUser = user;
            }
        });

        var newAlert = createAlert(sessionId, args, incidentManagementId, loggedUser, csrfToken);

        var fullUrl = [
            url,
            'ajax/incident/create',
            incidentManagementId + '',
            '?ctoken=' + csrfToken
        ].join('/');

        var newIncident = {
            name: args.name,
            summary: args.summary || '',
            priority: args.priority,
            createdBy: loggedUser.name,
            alert_id_list: [
                newAlert.id
            ]
        };

        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId],
                    'Content-Type': ['application/json']
                },
                Body: JSON.stringify(newIncident)
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to create incident with status [' + res.StatusCode + ']\n.'
                + 'Request Body: ' + JSON.stringify(body) + '\n. Response Body: ' + res.Body;
        }

        try {
            var newIncidentRes = JSON.parse(res.Body);
            if (newIncidentRes.success) {
                newIncident.id = newIncidentRes.data.id;
                return newIncident;
            } else {
                throw FailedRequestError('Failed to create incident.', fullUrl, null, body, newIncidentRes).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error while creating incident. \nOriginal error: ' + err, fullUrl, null, body, res.Body).toString();
        }
    }


    function addEventsToIncident(sessionId, args, incidentManagementId, availableAssignees) {
        var eventsViewHTML = getEventsViewHtml(sessionId);
        var csrfToken = extractCsrfTokenFromHTML(eventsViewHTML);
        var loggedUser = extractLoggedUserFromHTML(eventsViewHTML);
        // currently we extract only the name of the logged in user. But the all the user object is exist in the html.
        // it just will take more development time.
        // that is why we look for the user in availableAssigness
        availableAssignees.forEach(function(user) {
            if (user.name === loggedUser.name) {
                loggedUser = user;
            }
        });

        var newAlert = createAlert(sessionId, args, incidentManagementId, loggedUser, csrfToken);

        var fullUrl = [
            url,
            'ajax/incident/addToIncident',
            incidentManagementId + '',
            '?ctoken=' + csrfToken
        ].join('/');

        var reqBody = {
            alertIds: [
                newAlert.id
            ],
            incidentId: args.incidentId
        };

        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId],
                    'Content-Type': ['application/json']
                },
                Body: JSON.stringify(reqBody)
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to add events to incident with status [' + res.StatusCode + ']\n.'
                + 'Request Body: ' + JSON.stringify(body) + '\n. Response Body: ' + res.Body;
        }

        try {
            var resObject = JSON.parse(res.Body);
            if (resObject.success) {
                return true;
            } else {
                throw FailedRequestError('Failed to add events to incident.', fullUrl, null, body, newIncidentRes).toString();
            }
        } catch (err) {
            throw FailedRequestError('Unexpected error while adding new events to incident. \nOriginal error: ' + err, fullUrl, null, body, res.Body).toString();
        }
    }


    function updateIncident(sessionId, args, incidentManagementId, availableAssignees) {
        var eventsViewHTML = getEventsViewHtml(sessionId);
        var csrfToken = extractCsrfTokenFromHTML(eventsViewHTML);
        var loggedUser = extractLoggedUserFromHTML(eventsViewHTML);
        // currently we extract only the name of the logged in user. But the all the user object is exist in the html.
        // it just will take more development time.
        // that is why we look for the user in availableAssigness
        availableAssignees.forEach(function(user) {
            if (user.name === loggedUser.name) {
                loggedUser = user;
            }
        });

        var fullUrl = [
            url,
            'ajax/incidents/update',
            incidentManagementId + '',
            '?ctoken=' + csrfToken
        ].join('/');

        var updatedIncident = {
            id_list: replaceAll(args.idList, ' ', '').split(','),
            attribute_map: {
                lastUpdatedByUser: loggedUser
            },
            benign_domain_list: []
        };
        if (args.name) {
            updatedIncident.attribute_map.name = args.name;
        }
        if (args.priority) {
            updatedIncident.attribute_map.priority = args.priority;
        }
        if (args.status) {
            updatedIncident.attribute_map.status = args.status;
        }
        if (args.summary) {
            updatedIncident.attribute_map.summary = args.summary;
        }
        if (args.comment) {
            updatedIncident.attribute_map.comment = args.comment;
        }
        if (args.assignee) {
            var assigneeUser = null;
            availableAssignees.forEach(function(user) {
                if (user.login === args.assignee) {
                    assigneeUser = user;
                }
            });
            if (!assigneeUser) {
                throw 'assignee argument is invalid. No such [' + args.assignee + '] available assignee user exist';
            }
            updatedIncident.attribute_map.assignee = assigneeUser;
        }
        if (args.categories) {
            updatedIncident.attribute_map.categories = args.categories;
        }

        var res = http(
            fullUrl,
            {
                Method: 'POST',
                Headers: {
                    'Cookie': [COOKIE_PREFIX + sessionId],
                    'Content-Type': ['application/json']
                },
                Body: JSON.stringify(updatedIncident)
            },
            true,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed to create incident with status [' + res.StatusCode + ']\n.'
                + 'Request Body: ' + JSON.stringify(updatedIncident) + '\n. Response Body: ' + res.Body;
        }

        try {
            var updateRes = JSON.parse(res.Body);
            if (updateRes.success) {
                return updateRes;
            } else {
                throw FailedRequestError('Failed to update incident.', fullUrl, null, updatedIncident, updateRes).toString();
            }
        } catch (err) {
            throw FailedRequestError('Failed to update incident.', fullUrl, null, updatedIncident, res.Body).toString();
        }
    }


    function makeUpperCase (o) {
        for (var key in o ) {
            if(o.hasOwnProperty(key)) {
                var newKey = key.charAt(0).toUpperCase() + key.slice(1);
                o[newKey] = o[key];
                delete o[key];
            }
        }
        return o;
    }


    function getIncidentObject(e) {
        return {
            "Id": e.id,
            "Name": e.name,
            "Status": e.status,
            "Priority": e.priority,
            "Summary": e.summary,
            "Assignee": e.assignee ? e.assignee.name : "",
            "CreatedBy": e.createdBy,
            "Created": convertTimestampToString(e.created),
            "FirstAlertTime": convertTimestampToString(e.firstAlertTime),
            "LastUpdatedByUserName": e.lastUpdatedByUserName,
            "RiskScore": e.riskScore,
            "AverageAlertRiskScore": e.averageAlertRiskScore,
            "Categories": e.categories,
            "AlertCount": e.alertCount
        };
    }


    function getAlert (alert) {
        return {
            "Id": alert.id,
            "Name": alert.name,
            "IncidentId": alert.incidentId,
            "Timestamp": convertTimestampToString(alert.timestamp),
            "HostSummary": alert.host_summary,
            "SignatureId": alert.signature_id,
            "Source": alert.source,
            "Type": alert.type,
            "RiskScore": alert.risk_score,
            "SourceCountry": alert.groupby_source_country,
            "DestinationCountry": alert.groupby_destination_country,
            "NumEvents": alert.numEvents,
            "SourceIp": alert.groupby_source_ip,
            "DestonationIp": alert.groupby_destination_ip,
            "DestonationPort": alert.groupby_destination_port
        };
    }

    function buildRetValListIncidents (incidets) {
        var md = [];
        var ctx = {"Netwitness.Incident":[]}
        if (!Array.isArray(incidets)) {
            incidets = [incidets]
        }
        incidets.forEach(function (e) {
            var toPush = getIncidentObject(e);
            md.push(toPush);
            ctx["Netwitness.Incident"].push(toPush);
        })
        return {Type: entryTypes.note, Contents: incidets, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext: ctx};
    }


    function buildRetValGetIncidentDetails (incident) {
        var md = [];
        var ctx = {"Netwitness.Incident":[]}
        var toPush = getIncidentObject(incident);
        md.push(toPush);
        ctx["Netwitness.Incident"].push(toPush);
        return {Type: entryTypes.note, Contents: incident, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext: ctx};
    }


    function buildRetValGetComponents (components) {
        var md = [];
        var ctx = {"Netwitness.Component":[]}
        if (!Array.isArray(components)) {
            components = [components]
        }
        components.forEach(function (e) {
            var toPush = {
                "Id": e.id,
                "DisplayName": e.displayName,
                "DeviceVersion": e.deviceVersion,
                "DisplayType": e.deviceType,
                "Host": e.host,
                "Port": e.port,
                "Validated": e.validated,
                "Licensed": e.licensed,
                "Username": e.username,
                "EnableSSL": e.enableSSL
            };
            md.push(toPush)
            ctx["Netwitness.Component"].push(toPush);
        })
        return {Type: entryTypes.note, Contents: components, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext:  ctx};
    }


    function buildRetValGetEvents (events) {
        var md = [];
        var ctx = {"Netwitness.Event":[]}
        if (!Array.isArray(events)) {
            events = [events]
        }
        events.forEach(function (event) {
            var toPush = {
                "Id": event.id,
                "Medium": event.medium,
                "Service": event.service,
                "Size": event.size
            }
            event["meta"].forEach(function (meta) {
                toPush["meta." + meta.name] = meta.value
            });
            md.push(toPush);
        });
        return {Type: entryTypes.note, Contents: events, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown};
    }


    function buildRetValGetEventDetails (event) {
        var md = [];
        var ctx = {"Netwitness.Event":[]};
        var data = event.data;
        var content = event.content;
        var toPush = {
            "EventId": data.eventId,
            "DeviceId": data.deviceId,
            "ReconstructedContentType": data.reconstructedContentType,
            "PacketsTotal": data.stats ? data.stats.packetsTotal : "",
            "PacketsProcessed": data.stats ? data.stats.packetsProcessed : ""
        };
        data.summaryAttributes.forEach(function (e) {
            toPush[e.name] = e.value
        });
        md.push(toPush);
        ctx["Netwitness.Event"].push(toPush);
        return {Type: entryTypes.note, Contents: event, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext:  ctx};
    }


    function buildRetValGetAlerts (alerts) {
        var md = [];
        var ctx = {"Netwitness.Alert":[]}
        if (!Array.isArray(alerts)) {
            alerts = [alerts]
        }
        alerts.forEach(function (e) {
            var toPush = getAlert(e);
            md.push(toPush);
            ctx["Netwitness.Alert"].push(toPush);
        })
        return {Type: entryTypes.note, Contents: alerts, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext: ctx};
    }


    function buildRetValGetAlert (alert) {
        var ctx = {"Netwitness.Alert":[]}
        var alertValue = getAlert(alert);
        var eventValue = [];
        alert.events.forEach(function (evnt) {
            eventValue.push(treeToFlattenObject(evnt));
        });
        var relatedLinksValue = alert.related_links;
        var hr = tableToMarkdown('Alerts',alertValue)  + tableToMarkdown('Events', eventValue)  + tableToMarkdown('Related Links', relatedLinksValue);
        ctx["Netwitness.Alert"].push(alertValue);
        return {Type: entryTypes.note, Contents: alert, ContentsFormat: formats.json, HumanReadable: hr, ReadableContentsFormat: formats.markdown, EntryContext: ctx};
    }


    function buildRetValGetAlertOrig (alertOrig) {
        var md = [];
        var ctx = {"Netwitness.Event": []}
        if(!alertOrig.events) {
            return {"ContentsFormat": formats["markdown"], "Type": entryTypes["error"], "Contents": "Received an error from NetWitness Please ensure that the referred alert Id exist in NetWitness"};
        }
        alertOrig.events.forEach(function (evnt) {
            for (var key in evnt) {
                if (key === 'time') {
                    evnt[key] = convertTimestampToString(evnt[key]);
                }
            }
        });
        md = alertOrig.events;
        ctx["Netwitness.Event"] = alertOrig.events;
        return {Type: entryTypes.note, Contents: alertOrig, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext: ctx};
    }


    function buildRetValAvailableAssignees(availableAssignees) {
        var md = [];
        var ctx = {"Netwitness.Account":[]}
        if (!Array.isArray(availableAssignees)) {
            availableAssignees = [availableAssignees]
        }
        availableAssignees.forEach(function (e) {
            var toPush ={
                "Id": e.id,
                "Name": e.name,
                "Login": e.login,
                "EmailAddress": e.emailAddress
            };
            md.push(toPush);
            ctx["Netwitness.Account"].push(toPush);
        })
        return {Type: entryTypes.note, Contents: availableAssignees, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext:  ctx};
    }


    function buildRetValCreateIncident (newIncident) {
        var md = [];
        var ctx = {"Netwitness.Incident":[]}
        var toPush = {
            "Id": newIncident.id,
            "Name": newIncident.name,
            "Priority": newIncident.priority,
            "CreatedBy": newIncident.createdBy,
            "AlertIDList": newIncident.alertIdList
        };
        md.push(toPush);
        ctx["Netwitness.Incident"].push(toPush)
        results = {Type: entryTypes.note, Contents: newIncident, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown, EntryContext:  ctx};
    }



    // The command input arg holds the command sent from the user.

    var sessionId = login(url, username, password);

    var incidentManagementId = args.incidentManagementId || getIncidentManagementId(sessionId);

    var results = false;

    switch (command) {
        case 'fetch-incidents':
            results = fetchIncidents(sessionId, args, incidentManagementId);
            break;
        case 'test-module':
            results = 'ok';
            break;
        case 'nw-login':
            results = sessionId;
            break;
        case 'netwitness-im-list-incidents':
            var incidents = listIncidents(sessionId, args, incidentManagementId);
            results = buildRetValListIncidents(incidents);
            break;
        case 'netwitness-im-get-incident-details':
            var incident = getIncidentById(sessionId, args, incidentManagementId);
            results = buildRetValGetIncidentDetails(incident);
            break;
        case 'netwitness-im-get-components':
            var components = getComponents(sessionId, args);
            results = buildRetValGetComponents(components);
            break;
        case 'netwitness-im-get-events':
            var events = getEvents(sessionId, args);
            results = buildRetValGetEvents(events);
            break;
        case 'netwitness-im-get-event-details':
            event = getEventDetails(sessionId, args);
            results = buildRetValGetEventDetails(event);
            break;
        case 'netwitness-im-get-alerts':
            var alerts = filterAlerts(sessionId, args);
            results = buildRetValGetAlerts(alerts);
            break;
        case 'netwitness-im-get-alert-details':
            var alert = getAlertById(sessionId, args);
            results = buildRetValGetAlert(alert);
            break;
        case 'netwitness-im-get-alert-original':
            var alert = getOriginalAlertById(sessionId, args);
            results = buildRetValGetAlertOrig(alert);
            break;
        case 'netwitness-im-get-available-assignees':
            var availableAssignees = getAvailableAssignees(sessionId);
            results = buildRetValAvailableAssignees(availableAssignees);
            break;
        case 'netwitness-im-create-incident':
            var availableAssignees = getAvailableAssignees(sessionId);
            var newIncident = createIncident(sessionId, args, incidentManagementId, availableAssignees);
            results = buildRetValCreateIncident(newIncident);
            break;
        case 'netwitness-im-add-events-to-incident':
            var md = [];
            var availableAssignees = getAvailableAssignees(sessionId, args);
            var isSuccess = addEventsToIncident(sessionId, args, incidentManagementId, availableAssignees);
            md.push({ success: isSuccess })
            results = {Type: entryTypes.note, Contents: { success: isSuccess }, ContentsFormat: formats.json, HumanReadable: tableToMarkdown(command, md), ReadableContentsFormat: formats.markdown};
            break;
        case 'netwitness-im-update-incident':
            var availableAssignees = getAvailableAssignees(sessionId, args);
            var update_incident = updateIncident(sessionId, args, incidentManagementId, availableAssignees);
            if( update_incident.success != true) {
                results = {"ContentsFormat": formats["markdown"], "Type": entryTypes["error"], "Contents": "Didn't succed to update incident.\n" + tableToMarkdown("Data returned:", update_incident)};
            }
            else if (update_incident.success == true && update_incident.data < 1) {
                results = {"ContentsFormat": formats["markdown"], "Type": entryTypes["error"], "Contents": "Received an error from NetWitness Please ensure that the referred incidents exist in NetWitness.  Incidents count = " + update_incident.data};
            }
            else {
                results = {
                    "ContentsFormat": formats["text"],
                    "Type": entryTypes["note"],
                    "Contents": "Incident updated successfully."
                };
            }
            break;
        default:
            // You can use args[argName] or args.argName to get a specific arg. args are strings.
            // You can use params[paramName] or params.paramName to get a specific params.
            // Params are of the type given in the integration page creation.
    }


    logout(url, sessionId);

    return results;
  type: javascript
  commands:
  - name: nw-list-incidents
    deprecated: true
    arguments:
    - name: query
      description: 'If query provided all other parameters ignored. Query should contain page, limit, start, sort and filter, joined by &, For example: page=1&start=0&limit=100&sort=[{"property":"created","direction":"DESC"}]&filter=[{"property":"created","value":[851171984031,1482323984031]}]'
    - name: page
      description: The default is 1. Indicates the page number of incidents
    - name: start
      description: The default is 0. Indicates the start index of incident in page
    - name: limit
      description: The default is 100. Limits the number of incidents per page
    - name: sort
      description: 'By default sorts by "created" field in "DESC" order. Example: "[{\"property\":\"created\",\"direction\":\"DESC\"}]"'
    - name: filter
      description: 'By default filters by "created" from 1996 to this date. Example: "[{\"property\":\"id\", \"value\":\"INC-21\"}]"'
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running nw-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    - name: loadAlerts
      description: '[optinal boolean] By default alerts and events related to incident not loaded. If loadAlerts is true, then command will load all alerts and their events from SA. Please be noticed THIS IS HAS PERFORMANCE IMPACT! For each alert XHR request send to SA.'
    description: Fetches incidents by filter
  - name: nw-login
    arguments: []
    description: Logins to the system and returns valid sessionId
  - name: nw-get-components
    deprecated: true
    arguments:
    - name: query
      description: '[optional string] Query must contain page, start, limit'
    description: Returns all the components in the system
  - name: nw-get-events
    deprecated: true
    arguments:
    - name: timeRangeType
      required: true
      auto: PREDEFINED
      predefined:
      - LAST_5_MINUTES
      - LAST_10_MINUTES
      - LAST_15_MINUTES
      - LAST_30_MINUTES
      - LAST_HOUR
      - LAST_3_HOURS
      - LAST_6_HOURS
      - LAST_12_HOURS
      - LAST_24_HOURS
      - LAST_2_DAYS
      - LAST_5_DAYS
      - EARLY_MORNING
      - MORNING
      - AFTERNOON
      - EVENING
      - TODAY
      - YESTERDAY
      - THIS_WEEK
      - LAST_WEEK
      - ALL_DATA
      - CUSTOM
      description: Filter of time range in which events occured
    - name: deviceId
      required: true
      description: '[number] Id of the device where the events stored/occurred. In order to get list of available devices/components run command nw-get-components'
    - name: collectionName
      description: '[optional]'
    - name: predicateIds
      description: '[optional]'
    - name: startDate
      description: '[optional datetime] If timeRangeType defined as CUSTOM, set this argument'
    - name: endDate
      description: '[optional datetime] If timeRangeType defined as CUSTOM, set this argument'
    - name: lastCollectionTime
      description: '[optional datetime] Last collection time'
    - name: mid1
      description: 'The unique meta id for this field. If nw-get-events was called this will be your starting id for this distinct value'
    - name: mid2
      description: 'The unique meta id for this field. If nw-get-events was called this will be your ending id for this distinct value.'
    - name: investigationToken
      description: '[optional guid] Investigation id token'
    - name: page
      description: '[optional number] Default set to 1. The page number'
    - name: start
      description: '[optional number] Default set to 0. The starting index of event in page.'
    - name: limit
      description: '[optional number] Default set to 25. Limits the number of events per page'
    - name: sort
      description: 'By default sorts by "id" field in "ASC" order. Example: "[{\"property\":\"id\",\"direction\":\"ASC\"}]"'
    - name: filter
      description: '<string> Must provide key value pairs of fieldName and their value separated by comma. Example: "ip.src=1.1.1.1,meta.device.type=\"crowdstrike\""'
    description: Returns all the events in defined time range
  - name: nw-get-available-assignees
    deprecated: true
    arguments: []
    description: Returns the available users to be assigned to incidents
    outputs:
    - contextPath: Netwitness.Component.Id
      description: Netwitness User ID
    - contextPath: Netwitness.Component.Name
      description: Netwitness User Name
    - contextPath: Netwitness.Component.Login
      description: Netwitness User Lofin Name
    - contextPath: Netwitness.Component.EmailAddress
      description: Netwitness User Email Address
  - name: nw-create-incident
    deprecated: true
    arguments:
    - name: alertSummary
      required: true
      description: '[string] Short summary of the alert which will be attached to incident'
    - name: severity
      description: '[optional string] Default set to "50". '
    - name: name
      required: true
      description: '[string] The name of the incident.'
    - name: assigned
      description: '[optional string] Set assignee login name if assignee has changed. You can execute nw-get-available-assignees to get the list of users. Example: demisto123'
    - name: eventList
      required: true
      description: List of event ids separated by comma [,] must not include spaces in it. In order to get list of events you can use nw-get-events
    - name: deviceId
      required: true
      description: The id of the device/component (Concentrator, Log Decoder, Packet Decoder, etc.) from which the events are. You can view the list of devices by executing the command nw-get-components
    - name: priority
      required: true
      auto: PREDEFINED
      predefined:
      - LOW
      - MEDIUM
      - HIGH
      - CRITICAL
      description: Priority of the incident
    - name: summary
      description: Summary of the incident
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running nw-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    description: Creating new incident
    execution: true
  - name: nw-add-events-to-incident
    deprecated: true
    arguments:
    - name: incidentId
      required: true
      default: true
      description: '[string] Existing incident id. '
    - name: eventList
      required: true
      description: '[array of strings] List of event ids separated by comma [,] must not include spaces in it. In order to get list of events you can use nw-get-events. Example: "23,12,3"'
    - name: alertSummary
      required: true
      description: '[string] Short summary of the alert which will be attached to incident'
    - name: severity
      required: true
      description: '[number] Severity of the incident. Example: 50'
    - name: deviceId
      required: true
      description: '[number] The id of the device/component (Concentrator, Log Decoder, Packet Decoder, etc.) from which the events are. You can view the list of devices by executing the command nw-get-components'
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running nw-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    description: This command will add new events to existing incident
    execution: true
  - name: nw-update-incident
    deprecated: true
    arguments:
    - name: idList
      required: true
      description: 'List of incident ids which will be updated, separated by comma [,]. Must not contain spaces. Example: "INC-13,INC-15,INC-23"'
    - name: name
      description: '[optional string] Set name if incident name has been changed'
    - name: summary
      description: '[optional string] Updated incident summary'
    - name: assignee
      description: '[optional string] Set assignee login name if assignee has changed. You can execute nw-get-available-assignees to get the list of users. Example: demisto123'
    - name: comment
      description: '[optional string] Add a journal entry describing your changes'
    - name: status
      auto: PREDEFINED
      predefined:
      - NEW
      - ASSIGNED
      - IN_PROGRESS
      - REMEDIATION_REQUESTED
      - REMEDIATION_COMPLETED
      - CLOSED
      - CLOSED_FALSE_POSITIVE
      description: '[optional status] Set status if changed'
    - name: priority
      auto: PREDEFINED
      predefined:
      - LOW
      - MEDIUM
      - HIGH
      - CRITICAL
      description: '[optional priority] Set priority if incident priority has been changed'
    - name: categories
      description: List of categories.
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running nw-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    description: Updates incident
    execution: true
  - name: fetch-incidents
    description: Simulates fetching incidents. Returns array of incidents from NetWitness.
    arguments: []
  - name: nw-get-alerts
    description: Return all the alerts filtered by filter.
    deprecated: true
    arguments:
    - name: page
      description: The default is 1. Indicates the page number of incidents
    - name: start
      description: The default is 0. Indicates the start index of incident in page
    - name: limit
      description: The default is 100. Limits the number of incidents per page
    - name: sort
      description: 'By default sorts by "alert.timestamp" field in "DESC" order. Example: "[{\"property\":\"alert.timestamp\",\"direction\":\"DESC\"}]"'
    - name: filter
      description: 'By default filters by "alert.timestamp" from 1996 to this date. Example: "[{\"property\":\"incidentId\", \"value\":\"INC-21\"}]"'
  - name: nw-get-alert-details
    description: Return single alert by id
    deprecated: true
    arguments:
    - name: alertId
      description: Alert id
      required: true
  - name: nw-get-event-details
    deprecated: true
    arguments:
    - name: deviceId
      required: true
      description: '[number] Id of the device where the events stored/occurred. In order to get list of available devices/components run command nw-get-components'
    - name: eventId
      required: true
      description: '[number] Id of the event'
    description: Returns two entries. One is event details json and the second is event/session content
  - name: nw-get-incident-details
    deprecated: true
    arguments:
    - name: incidentId
      required: true
      default: true
      description: '[number] ID of incident. Example: "INC-12"'
    description: Returns incident json by id
  - name: nw-get-alert-original
    deprecated: true
    arguments:
    - name: alertId
      required: true
      default: true
      description: Id of the alert
    description: Returns the original events which this alert contains
  - name: netwitness-im-list-incidents
    arguments:
    - name: query
      description: 'If query provided all other parameters ignored. Query should contain page, limit, start, sort and filter, joined by &, For example: page=1&start=0&limit=100&sort=[{"property":"created","direction":"DESC"}]&filter=[{"property":"created","value":[851171984031,1482323984031]}]'
    - name: page
      description: The default is 1. Indicates the page number of incidents
    - name: start
      description: The default is 0. Indicates the start index of incident in page
    - name: limit
      description: The default is 100. Limits the number of incidents per page
    - name: sort
      description: 'By default sorts by "created" field in "DESC" order. Example: "[{\"property\":\"created\",\"direction\":\"DESC\"}]"'
    - name: filter
      description: 'By default filters by "created" from 1996 to this date. Example: "[{\"property\":\"id\", \"value\":\"INC-21\"}]"'
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running netwitness-im-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    - name: loadAlerts
      description: '[optinal boolean] By default alerts and events related to incident not loaded. If loadAlerts is true, then command will load all alerts and their events from SA. Please be noticed THIS IS HAS PERFORMANCE IMPACT! For each alert XHR request send to SA.'
    description: Fetches incidents by filter
    outputs:
    - contextPath: Netwitness.Incident.Id
      description: Netwitness Incident ID
    - contextPath: Netwitness.Incident.Name
      description: Netwitness Incident Name
    - contextPath: Netwitness.Incident.Priority
      description: Netwitness Incident Priority
    - contextPath: Netwitness.Incident.CreatedBy
      description: User who created Netwitness Incident
    - contextPath: Netwitness.Incident.Summary
      description: Netwitness Incident Summary
    - contextPath: Netwitness.Incident.Assignee
      description: User Assigned To Incident
    - contextPath: Netwitness.Incident.Created
      description: Time of Incident Creation
    - contextPath: Netwitness.Incident.FirstAlertTime
      description: Time of Incident Creation
    - contextPath: Netwitness.Incident.LastUpdatedByUserName
      description: User who was last to update Incident
    - contextPath: Netwitness.Incident.RiskScore
      description: Netwitness Incident Risk Score
    - contextPath: Netwitness.Incident.AverageAlertRiskScore
      description: Netwitness Incident Average Risk Score
    - contextPath: Netwitness.Incident.Categories
      description: Netwitness Incident Category
    - contextPath: Netwitness.Incident.AlertCount
      description: Netwitness Incident Alerts Counts
  - name: netwitness-im-login
    arguments: []
    description: Logins to the system and returns valid sessionId
  - name: netwitness-im-get-components
    arguments:
    - name: query
      description: '[optional string] Query must contain page, start, limit'
    description: Returns all the components in the system
    outputs:
    - contextPath: Netwitness.Component.Id
      description: Netwitness Component ID
    - contextPath: Netwitness.Component.DisplayName
      description: Netwitness Component DisplayName
    - contextPath: Netwitness.Component.DeviceVersion
      description: Netwitness Component Device Version
    - contextPath: Netwitness.Component.DisplayType
      description: Netwitness Component Device Type
    - contextPath: Netwitness.Component.Host
      description: Netwitness Component Device Host
    - contextPath: Netwitness.Component.Port
      description: Netwitness Component Device Port
    - contextPath: Netwitness.Component.Validated
      description: Netwitness Component is passed validation
    - contextPath: Netwitness.Component.Licensed
      description: Netwitness Component license
    - contextPath: Netwitness.Component.Username
      description: Netwitness Component User Name
    - contextPath: Netwitness.Component.EnableSSL
      description: Netwitness Component Enable SSL
  - name: netwitness-im-get-events
    arguments:
    - name: timeRangeType
      required: true
      auto: PREDEFINED
      predefined:
      - LAST_5_MINUTES
      - LAST_10_MINUTES
      - LAST_15_MINUTES
      - LAST_30_MINUTES
      - LAST_HOUR
      - LAST_3_HOURS
      - LAST_6_HOURS
      - LAST_12_HOURS
      - LAST_24_HOURS
      - LAST_2_DAYS
      - LAST_5_DAYS
      - EARLY_MORNING
      - MORNING
      - AFTERNOON
      - EVENING
      - TODAY
      - YESTERDAY
      - THIS_WEEK
      - LAST_WEEK
      - ALL_DATA
      - CUSTOM
      description: Filter of time range in which events occured
    - name: deviceId
      required: true
      description: '[number] Id of the device where the events stored/occurred. In order to get list of available devices/components run command netwitness-im-get-components'
    - name: collectionName
      description: '[optional]'
    - name: predicateIds
      description: '[optional]'
    - name: startDate
      description: '[optional datetime] If timeRangeType defined as CUSTOM, set this argument'
    - name: endDate
      description: '[optional datetime] If timeRangeType defined as CUSTOM, set this argument'
    - name: lastCollectionTime
      description: '[optional datetime] Last collection time'
    - name: mid1
      description: 'The unique meta id for this field. If nw-get-events was called this will be your starting id for this distinct value'
    - name: mid2
      description: 'The unique meta id for this field. If nw-get-events was called this will be your ending id for this distinct value.'
    - name: investigationToken
      description: '[optional guid] Investigation id token'
    - name: page
      description: '[optional number] Default set to 1. The page number'
    - name: start
      description: '[optional number] Default set to 0. The starting index of event in page.'
    - name: limit
      description: '[optional number] Default set to 25. Limits the number of events per page'
    - name: sort
      description: 'By default sorts by "id" field in "ASC" order. Example: "[{\"property\":\"id\",\"direction\":\"ASC\"}]"'
    - name: filter
      description: '<string> Must provide key value pairs of fieldName and their value separated by comma. Example: "ip.src=1.1.1.1,meta.device.type=\"crowdstrike\""'
    description: Returns all the events in defined time range
  - name: netwitness-im-get-available-assignees
    arguments: []
    description: Returns the available users to be assigned to incidents
    outputs:
    - contextPath: Netwitness.Account.Id
      description: Netwitness Account ID
    - contextPath: Netwitness.Account.Name
      description: Netwitness Account Name
    - contextPath: Netwitness.Account.Login
      description: Netwitness Account Login Name
    - contextPath: Netwitness.Account.EmailAddress
      description: Netwitness Account Email Address
  - name: netwitness-im-create-incident
    arguments:
    - name: alertSummary
      required: true
      description: '[string] Short summary of the alert which will be attached to incident'
    - name: severity
      description: '[optional string] Default set to "50". '
    - name: name
      required: true
      description: '[string] The name of the incident.'
    - name: assigned
      description: '[optional string] Set assignee login name if assignee has changed. You can execute netwitness-im-get-available-assignees to get the list of users. Example: demisto123'
    - name: eventList
      required: true
      description: List of event ids separated by comma [,] must not include spaces in it. In order to get list of events you can use netwitness-im-get-events
    - name: deviceId
      required: true
      description: The id of the device/component (Concentrator, Log Decoder, Packet Decoder, etc.) from which the events are. You can view the list of devices by executing the command netwitness-im-get-components
    - name: priority
      required: true
      auto: PREDEFINED
      predefined:
      - LOW
      - MEDIUM
      - HIGH
      - CRITICAL
      description: Priority of the incident
    - name: summary
      description: Summary of the incident
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running netwitness-im-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    description: Creating new incident
    outputs:
    - contextPath: Netwitness.Incident.Id
      description: Netwitness Incident ID
    - contextPath: Netwitness.Incident.Name
      description: Netwitness Incident Name
    - contextPath: Netwitness.Incident.Priority
      description: Netwitness Incident Priority
    - contextPath: Netwitness.Incident.CreatedBy
      description: User who created Netwitness.Incident
    - contextPath: Netwitness.Incident.AlertIDList
      description: Alerts which rised by incident
    execution: true
  - name: netwitness-im-add-events-to-incident
    arguments:
    - name: incidentId
      required: true
      default: true
      description: '[string] Existing incident id. '
    - name: eventList
      required: true
      description: '[array of strings] List of event ids separated by comma [,] must not include spaces in it. In order to get list of events you can use netwitness-im-get-events. Example: "23,12,3"'
    - name: alertSummary
      required: true
      description: '[string] Short summary of the alert which will be attached to incident'
    - name: severity
      required: true
      description: '[number] Severity of the incident. Example: 50'
    - name: deviceId
      required: true
      description: '[number] The id of the device/component (Concentrator, Log Decoder, Packet Decoder, etc.) from which the events are. You can view the list of devices by executing the command netwitness-im-get-components'
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running netwitness-im-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    description: This command will add new events to existing incident
    execution: true
  - name: netwitness-im-update-incident
    arguments:
    - name: idList
      required: true
      description: 'List of incident ids which will be updated, separated by comma [,]. Must not contain spaces. Example: "INC-13,INC-15,INC-23"'
    - name: name
      description: '[optional string] Set name if incident name has been changed'
    - name: summary
      description: '[optional string] Updated incident summary'
    - name: assignee
      description: '[optional string] Set assignee login name if assignee has changed. You can execute netwitness-im-get-available-assignees to get the list of users. Example: demisto123'
    - name: comment
      description: '[optional string] Add a journal entry describing your changes'
    - name: status
      auto: PREDEFINED
      predefined:
      - NEW
      - ASSIGNED
      - IN_PROGRESS
      - REMEDIATION_REQUESTED
      - REMEDIATION_COMPLETED
      - CLOSED
      - CLOSED_FALSE_POSITIVE
      description: '[optional status] Set status if changed'
    - name: priority
      auto: PREDEFINED
      predefined:
      - LOW
      - MEDIUM
      - HIGH
      - CRITICAL
      description: '[optional priority] Set priority if incident priority has been changed'
    - name: categories
      description: List of categories.
    - name: incidentManagementId
      description: '[optional number] This is the id of NetWitness INCIDENT_MANAGEMENT device/component id. It can be received by running netwitness-im-get-component command. If this argument is not filled/passed, the script will automatically get the first device of type INCIDENT_MANAGEMENT from the SA server.'
    description: Updates incident
    execution: true
  - name: netwitness-im-get-alerts
    description: Return all the alerts filtered by filter.
    arguments:
    - name: page
      description: The default is 1. Indicates the page number of incidents
    - name: start
      description: The default is 0. Indicates the start index of incident in page
    - name: limit
      description: The default is 100. Limits the number of incidents per page
    - name: sort
      description: 'By default sorts by "alert.timestamp" field in "DESC" order. Example: "[{\"property\":\"alert.timestamp\",\"direction\":\"DESC\"}]"'
    - name: filter
      description: 'By default filters by "alert.timestamp" from 1996 to this date. Example: "[{\"property\":\"incidentId\", \"value\":\"INC-21\"}]"'
  - name: netwitness-im-get-alert-details
    description: Return single alert by id
    arguments:
    - name: alertId
      description: Alert id
      required: true
    outputs:
    - contextPath: Netwitness.Alert.Id
      description: Netwitness Alert ID
    - contextPath: Netwitness.Alert.Name
      description: Netwitness Alert Name
    - contextPath: Netwitness.Alert.IncidentId
      description: Id of Incident which caused to Alert
    - contextPath: Netwitness.Alert.Timestamp
      description: Time of Alert
    - contextPath: Netwitness.Alert.HostSummary
      description: Netwitness Alert Summary
    - contextPath: Netwitness.Alert.SignatureId
      description: Singnature Id of Alert
    - contextPath: Netwitness.Alert.Source
      description: Score of Alert
    - contextPath: Netwitness.Alert.Type
      description: Type of Alert
    - contextPath: Netwitness.Alert.RiskScore
      description: Risk score of Alert
    - contextPath: Netwitness.Alert.SourceCountry
      description: Netwitness Alert Source Country
    - contextPath: Netwitness.Alert.DestinationCountry
      description: Netwitness Alert Destination Country
    - contextPath: Netwitness.Alert.NumEvents
      description: Netwitness Alert Evevts Number
    - contextPath: Netwitness.Alert.SourceIp
      description: Netwitness Alert Source Ip
    - contextPath: Netwitness.Alert.DestonationIp
      description: Netwitness Alert Destonation Ip
    - contextPath: Netwitness.Alert.DestonationPort
      description: Netwitness Alert Destonation Port
  - name: netwitness-im-get-event-details
    arguments:
    - name: deviceId
      required: true
      description: '[number] Id of the device where the events stored/occurred. In order to get list of available devices/components run command netwitness-im-get-components'
    - name: eventId
      required: true
      description: '[number] Id of the event'
    description: Returns two entries. One is event details json and the second is
    outputs:
    - contextPath: Netwitness.Event.EventId
      description: Netwitness Event ID
    - contextPath: Netwitness.Event.DeviceId
      description: Netwitness Event Device Id
    - contextPath: Netwitness.Event.ReconstructedContentType
      description: Netwitness Event Reconstructed Content
    - contextPath: Netwitness.Event.PacketsTotal
      description: Total Packets Netwitness Event
    - contextPath: Netwitness.Event.PacketsProcessed
      description: Packets Processed in Current Event
  - name: netwitness-im-get-incident-details
    arguments:
    - name: incidentId
      required: true
      default: true
      description: '[number] ID of incident. Example: "INC-12"'
    description: Returns incident json by id
    outputs:
    - contextPath: Netwitness.Incident.Id
      description: Netwitness Incident ID
    - contextPath: Netwitness.Incident.Name
      description: Netwitness Incident Name
    - contextPath: Netwitness.Incident.Priority
      description: Netwitness Incident Priority
    - contextPath: Netwitness.Incident.CreatedBy
      description: User who created Netwitness Incident
    - contextPath: Netwitness.Incident.Summary
      description: Netwitness Incident Summary
    - contextPath: Netwitness.Incident.Assignee
      description: User Assigned To Incident
    - contextPath: Netwitness.Incident.Created
      description: Time of Incident Creation
    - contextPath: Netwitness.Incident.FirstAlertTime
      description: Time of Incident Creation
    - contextPath: Netwitness.Incident.LastUpdatedByUserName
      description: User who was last to update Incident
    - contextPath: Netwitness.Incident.RiskScore
      description: Netwitness Incident Risk Score
    - contextPath: Netwitness.Incident.AverageAlertRiskScore
      description: Netwitness Incident Average Risk Score
    - contextPath: Netwitness.Incident.Categories
      description: Netwitness Incident Category
    - contextPath: Netwitness.Incident.AlertCount
      description: Netwitness Incident Alerts Counts
  - name: netwitness-im-get-alert-original
    arguments:
    - name: alertId
      required: true
      default: true
      description: Id of the alert
    description: Returns the original events which this alert contains
  isfetch: true
tests:
- no test
