category: Email
sectionorder:
- Connect
- Collect
commonfields:
  id: EWS v2 FIX3
  version: -1
configuration:
- display: Email address
  name: credentials
  required: true
  type: 9
  section: Connect
- display: Email address from which to fetch incidents
  name: defaultTargetMailbox
  required: true
  type: 0
  additionalinfo: Mailbox to run commands on and to fetch incidents from.
  section: Collect
- defaultvalue: Inbox
  display: Name of the folder from which to fetch incidents (supports Exchange Folder ID and sub-folders e.g. Inbox/Phishing)
  name: folder
  required: true
  type: 0
  section: Collect
- defaultvalue: 'false'
  display: Public Folder
  name: isPublicFolder
  type: 8
  section: Connect
  advanced: true
  required: false
- defaultvalue: 'false'
  display: Has impersonation rights
  name: impersonation
  type: 8
  section: Connect
  advanced: true
  required: false
- defaultvalue: 'false'
  display: Use system proxy settings
  name: proxy
  type: 8
  section: Connect
  advanced: true
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  section: Collect
  required: false
- defaultvalue: 10 minutes
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  type: 0
  section: Collect
  required: false
- display: Mark fetched emails as read
  name: markAsRead
  type: 8
  section: Collect
  advanced: true
  required: false
- display: Incident type
  name: incidentType
  type: 13
  section: Connect
  required: false
- display: "┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉\n‎                                           Manual Mode\nExchange Server Hostname or IP address"
  name: ewsServer
  type: 0
  section: Connect
  advanced: true
  required: false
- display: DOMAIN\USERNAME (e.g. DEMISTO.INT\admin)
  name: domainAndUserman
  type: 0
  section: Connect
  advanced: true
  required: false
- display: 'Exchange Server Version (On-Premise only. Supported versions: 2007, 2010, 2010_SP2, 2013 2016, and 2019)'
  name: defaultServerVersion
  type: 0
  section: Connect
  advanced: true
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  section: Connect
  advanced: true
  required: false
- display: "┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉\n‎                                         Advanced Mode\nOverride Authentication Type (NTLM, Basic, or Digest)."
  name: authType
  type: 0
  section: Connect
  advanced: true
  required: false
- defaultvalue: '120'
  display: Timeout (in seconds) for HTTP requests to Exchange Server
  name: requestTimeout
  type: 0
  section: Connect
  advanced: true
  required: false
- defaultvalue: '50'
  display: Max incidents per fetch
  name: maxFetch
  type: 0
  section: Collect
  required: false
- defaultvalue: 'true'
  display: Run as a separate process (protects against memory depletion)
  name: separate_process
  type: 8
  section: Connect
  advanced: true
  required: false
description: Exchange Web Services and Office 365 (mail).
display: EWS v2 FIX3
name: EWS v2 FIX3
script:
  commands:
  - arguments:
    - description: The ID of the email message for which to get the attachments.
      name: item-id
      required: true
    - description: The mailbox in which this attachment was found. If empty, the default mailbox is used. Otherwise the user might require impersonation rights to this mailbox.
      name: target-mailbox
    - description: The attachments ids to get. If none - all attachments will be retrieve from the message. Support multiple attachments with comma-separated value or array.
      isArray: true
      name: attachment-ids
    description: Retrieves the actual attachments from an item (email message). To get all attachments for a message, only specify the item-id argument.
    name: ews-get-attachment
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The attachment ID. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: The attachment name. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentSHA256
      description: The SHA256 hash of the attached file.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentLastModifiedTime
      description: The attachment last modified time. Used for file attachments only.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeCreated
      description: The created time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeReceived
      description: The received time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeSent
      description: The sent time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.receivedBy
      description: The received by address of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.subject
      description: The subject of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.textBody
      description: The body of the attached email (as text).
      type: string
    - contextPath: EWS.Items.ItemAttachments.headers
      description: The headers of the attached email.
      type: Unknown
    - contextPath: EWS.Items.ItemAttachments.hasAttachments
      description: Whether the attached email has attachments.
      type: boolean
    - contextPath: EWS.Items.ItemAttachments.itemId
      description: The attached email item ID.
      type: string
    - contextPath: EWS.Items.ItemAttachments.toRecipients
      description: A list of recipient email addresses for the attached email.
      type: Unknown
    - contextPath: EWS.Items.ItemAttachments.body
      description: The body of the attached email (as HTML).
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentSHA256
      description: The SHA256 hash of the attached email (as EML file).
      type: string
    - contextPath: EWS.Items.ItemAttachments.FileAttachments.attachmentSHA256
      description: SHA256 hash of the attached files inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.ItemAttachments.attachmentSHA256
      description: SHA256 hash of the attached emails inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.isRead
      description: The read status of the attachment.
      type: String
  - arguments:
    - description: The ID of the email message for which to delete attachments.
      name: item-id
      required: true
    - description: The mailbox in which this attachment was found. If empty, the default mailbox is used. Otherwise the user might require impersonation rights to this mailbox.
      name: target-mailbox
    - description: A CSV list (or array) of attachment IDs to delete. If empty, all attachments will be deleted from the message.
      isArray: true
      name: attachment-ids
    description: Deletes the attachments of an item (email message).
    name: ews-delete-attachment
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The ID of the deleted attachment, in case of file attachment.
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: The ID of the deleted attachment, in case of other attachment (for example, "email").
      type: string
    - contextPath: EWS.Items.FileAttachments.action
      description: "The deletion action in case of file attachment. This is a constant value: 'deleted'."
      type: string
    - contextPath: EWS.Items.ItemAttachments.action
      description: "The deletion action in case of other attachment (for example, \"email\"). This is a constant value: 'deleted'."
      type: string
  - description: Returns a list of searchable mailboxes. This command requires eDiscovery permissions to the Exchange Server. For more information, see the EWSv2 integration documentation.
    name: ews-get-searchable-mailboxes
    outputs:
    - contextPath: EWS.Mailboxes.mailbox
      description: Addresses of the searchable mailboxes.
      type: string
    - contextPath: EWS.Mailboxes.mailboxId
      description: IDs of the searchable mailboxes.
      type: string
    - contextPath: EWS.Mailboxes.displayName
      description: The email display name.
      type: string
    - contextPath: EWS.Mailboxes.isExternal
      description: Whether the mailbox is external.
      type: boolean
    - contextPath: EWS.Mailboxes.externalEmailAddress
      description: The external email address.
      type: string
  - arguments:
    - description: The filter query to search.
      name: filter
      required: true
    - description: The mailbox IDs to search. If empty, all mailboxes are searched.
      isArray: true
      name: mailbox-search-scope
    - defaultValue: '250'
      description: Maximum number of results to return.
      name: limit
    - description: CSV list or array of email addresses.
      isArray: true
      name: email_addresses
    description: Searches over multiple mailboxes or all Exchange mailboxes. Use either the mailbox-search-scope command or the email-addresses command to search specific mailboxes. This command requires eDiscovery permissions to the Exchange Server. For more information, see the EWS v2 integration documentation.
    name: ews-search-mailboxes
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID.
      type: string
    - contextPath: EWS.Items.mailbox
      description: The mailbox address where the item was found.
      type: string
    - contextPath: EWS.Items.subject
      description: The subject of the email.
      type: string
    - contextPath: EWS.Items.toRecipients
      description: List of recipient email addresses.
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender email address.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments?
      type: boolean
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
  - arguments:
    - description: The ID of the item to move.
      name: item-id
      required: true
    - description: The path to the folder to which to move the item. Complex paths are supported, for example, "Inbox\Phishing".
      name: target-folder-path
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the target folder is a public folder.
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Move an item to different folder in the mailbox.
    name: ews-move-item
    outputs:
    - contextPath: EWS.Items.newItemID
      description: The item ID after move.
      type: string
    - contextPath: EWS.Items.messageID
      description: The item message ID.
      type: string
    - contextPath: EWS.Items.itemId
      description: The original item ID.
      type: string
    - contextPath: EWS.Items.action
      description: The action taken. The value will be "moved".
      type: string
  - arguments:
    - description: The item IDs to delete.
      name: item-ids
      required: true
    - defaultValue: soft
      description: Deletion type. Can be "trash", "soft", or "hard".
      name: delete-type
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    description: Delete items from mailbox.
    name: ews-delete-items
    outputs:
    - contextPath: EWS.Items.itemId
      description: The deleted item ID.
      type: string
    - contextPath: EWS.Items.messageId
      description: The deleted message ID.
      type: string
    - contextPath: EWS.Items.action
      description: The deletion action. Can be 'trash-deleted', 'soft-deleted', or 'hard-deleted'.
      type: string
  - arguments:
    - description: 'The search query string. For more information about the query syntax, see the Microsoft documentation: https://msdn.microsoft.com/en-us/library/ee693615.aspx'
      name: query
    - description: The folder path in which to search. If empty, searches all the folders in the mailbox.
      name: folder-path
    - defaultValue: '100'
      description: Maximum number of results to return.
      name: limit
    - description: The mailbox on which to apply the search.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder?
      name: is-public
      predefined:
      - 'True'
      - 'False'
    - description: The message ID of the email. This will be ignored if a query argument is provided.
      name: message-id
    - defaultValue: all
      description: A CSV list of fields to retrieve.
      isArray: true
      name: selected-fields
      predefined:
      - ''
    - auto: PREDEFINED
      description: Whether to surround the message ID with angle brackets (<>) if it does not exist. Default is 'True'.
      name: surround_id_with_angle_brackets
      predefined:
      - 'True'
      - 'False'
    description: Searches for items in the specified mailbox. Specific permissions are needed for this operation to search in a target mailbox other than the default.
    name: ews-search-mailbox
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item ID.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender email address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: List of email recipients addresses.
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
  - arguments:
    - description: The mailbox for which to retrieve the contacts.
      name: target-mailbox
    - defaultValue: '100'
      description: Maximum number of results to return.
      name: limit
    description: Retrieves contacts for a specified mailbox.
    name: ews-get-contacts
    outputs:
    - contextPath: Account.Email.EwsContacts.displayName
      description: The contact name.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.lastModifiedTime
      description: The time that the contact was last modified.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.emailAddresses
      description: Phone numbers of the contact.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.physicalAddresses
      description: Physical addresses of the contact.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.phoneNumbers.phoneNumber
      description: Email addresses of the contact.
      type: Unknown
  - arguments:
    - description: The mailbox for which to get the out-of-office status.
      name: target-mailbox
      required: true
    description: Retrieves the out-of-office status for a specified mailbox.
    name: ews-get-out-of-office
    outputs:
    - contextPath: Account.Email.OutOfOffice.state
      description: 'Out-of-office state. Result can be: Enabled, Scheduled, Disabled.'
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.externalAudience
      description: Out-of-office external audience. Can be "None", "Known", or "All".
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.start
      description: Out-of-office start date.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.end
      description: Out-of-office end date.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.internalReply
      description: Out-of-office internal reply.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.externalReply
      description: Out-of-office external reply.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.mailbox
      description: Out-of-office mailbox.
      type: Unknown
  - arguments:
    - description: A CSV list of message IDs. Run the py-ews-delete-items command to retrieve the message IDs.
      name: message-ids
      required: true
    - defaultValue: Inbox
      description: The folder path to recover the messages to.
      name: target-folder-path
      required: true
    - description: The mailbox in which the messages found. If empty, will use the default mailbox. If you specify a different mailbox, you might need impersonation rights to the mailbox.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the target folder is a Public Folder.
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Recovers messages that were soft-deleted.
    name: ews-recover-messages
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID of the recovered item.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: The message ID of the recovered item.
      type: Unknown
    - contextPath: EWS.Items.action
      description: The action taken on the item. The value will be 'recovered'.
      type: Unknown
  - arguments:
    - description: The name of the new folder.
      name: new-folder-name
      required: true
    - defaultValue: Inbox
      description: Path to locate the new folder. Exchange folder ID is also supported.
      name: folder-path
      required: true
    - description: The mailbox in which to create the folder.
      name: target-mailbox
    description: Creates a new folder in a specified mailbox.
    name: ews-create-folder
  - arguments:
    - description: The item ID to mark as junk.
      name: item-id
      required: true
    - auto: PREDEFINED
      defaultValue: yes
      description: Whether to move the item from the original folder to the junk folder.
      name: move-items
      predefined:
      - yes
      - no
    - description: If empty, will use the default mailbox. If you specify a different mailbox, you might need impersonation rights to the mailbox.
      name: target-mailbox
    description: 'Marks an item as junk. This is commonly used to block an email address. For more information, see the Microsoft documentation: https://msdn.microsoft.com/en-us/library/office/dn481311(v=exchg.150).aspx.'
    name: ews-mark-item-as-junk
  - arguments:
    - description: The mailbox on which to apply the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether to find Public Folders.
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Retrieves information for folders for a specified mailbox. Only folders with read permissions will be returned. Your visual folders on the mailbox, such as "Inbox", are under the folder "Top of Information Store".
    name: ews-find-folders
    outputs:
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.id
      description: Folder ID.
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Number of items in folder.
      type: Unknown
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread items in folder.
      type: number
    - contextPath: EWS.Folders.changeKey
      description: Folder change key.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
  - arguments:
    - description: The folder path from which to get the items.
      name: folder-path
      required: true
    - defaultValue: '100'
      description: Maximum number of items to return.
      name: limit
    - description: The mailbox to on which to apply the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder. Default is 'False'.
      name: is-public
      predefined:
      - 'True'
      - 'False'
    - auto: PREDEFINED
      defaultValue: no
      description: If the email item contains another email as an attachment (EML or MSG file), whether to retrieve the EML/MSG file attachment. Can be "yes" or "no". Default is "no".
      name: get-internal-item
      predefined:
      - yes
      - no
    description: Retrieves items from a specified folder in a mailbox. The items are order by the item created time, most recent is first.
    name: ews-get-items-from-folder
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID of the email.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender mail address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
    - contextPath: EWS.Items.categories
      description: The categories of the email.
      type: unknown
  - arguments:
    - description: 'The text value of this argument is used to resolve names against the following fields: First name, Last name, Display name, Full name, Office, Alias, SMTP address. Eg. `John Doe` or `sip:johndoe@example.com`.'
      isArray: false
      name: identifier
      required: true
    - auto: PREDEFINED
      description: Describes whether the full contact details for public contacts for a resolved name are returned.
      name: full-contact-data
      predefined:
      - 'True'
      - 'False'
      defaultValue: 'True'
    description: This operation verifies aliases and matches display names to the correct mailbox user. It handles one ambiguous name at a time. If there are multiple potential matches, all will be returned, but limited to a maximum of 100 candidates.
    name: ews-resolve-name
    outputs:
    - contextPath: EWS.ResolvedNames.FullContactInfo.contactSource
      description: Whether the contact is located in the Exchange store or Active Directory Domain Services (AD DS).
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.culture
      description: Represents the culture for a given item in a mailbox.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.displayName
      description: The display name of a contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.ItemId
      description: Contains the unique identifier and change key of an item in the Exchange store.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.emailAddresses
      description: Represents a collection of email addresses for a contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.givenName
      description: Contains a contact's given name.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.importance
      description: Describes the importance of an item.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.initials
      description: Represents the initials of a contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.phoneNumbers.label
      description: 'The following are the possible values for this attribute: AssistantPhone, BusinessFax, BusinessPhone, BusinessPhone2, Callback, CarPhone, CompanyMainPhone, HomeFax, HomePhone, HomePhone2, Isdn, MobilePhone, OtherFax, OtherTelephone, Pager, PrimaryPhone, RadioPhone, Telex, TtyTddPhone.'
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.phoneNumbers.phoneNumber
      description: The phone number of the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.city
      description: The physical addresses city associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.country
      description: The physical addresses country associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.label
      description: The physical addresses label associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.state
      description: The physical addresses state associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.street
      description: The physical addresses street associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.zipcode
      description: The physical addresses zipcode associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.postalAddressIndex
      description: Represents the display types for physical addresses.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.sensitivity
      description: Indicates the sensitivity level of an item.
      type: String
    - contextPath: EWS.ResolvedNames.email_address
      description: The primary SMTP address of a mailbox user.
      type: String
    - contextPath: EWS.ResolvedNames.mailbox_type
      description: The type of mailbox that is represented by the email address.
      type: String
    - contextPath: EWS.ResolvedNames.name
      description: The name of a mailbox user.
      type: String
    - contextPath: EWS.ResolvedNames.routing_type
      description: The address type for the mailbox.
      type: String
  - arguments:
    - description: A CSV list if item IDs.
      isArray: true
      name: item-ids
      required: true
    - description: The mailbox on which to run the command on.
      name: target-mailbox
    description: Retrieves items by item ID.
    name: ews-get-items
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item ID.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender mail address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
    - contextPath: Email.CC
      description: Email addresses CC'ed to the email.
      type: String
    - contextPath: Email.BCC
      description: Email addresses BCC'ed to the email.
      type: String
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.HeadersMap
      description: The headers of the email.
      type: String
    - contextPath: EWS.Items.categories
      description: The categories of the email.
      type: unknown
  - arguments:
    - description: The item ID to move.
      name: item-id
      required: true
    - description: The folder in the destination mailbox to which to move the item. You can specify a complex path, for example, "Inbox\Phishing".
      name: destination-folder-path
      required: true
    - description: The mailbox to which to move the item.
      name: destination-mailbox
      required: true
    - description: The mailbox from which to move the item (conventionally called the "target-mailbox", the target mailbox on which to run the command).
      name: source-mailbox
    - auto: PREDEFINED
      description: Whether the destination folder is a Public Folder. Default is "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Moves an item from one mailbox to different mailbox.
    name: ews-move-item-between-mailboxes
    outputs:
    - contextPath: EWS.Items.movedToMailbox
      description: The mailbox wo which the item was moved.
      type: string
    - contextPath: EWS.Items.movedToFolder
      description: The folder to which the item was moved.
      type: string
    - contextPath: EWS.Items.action
      description: The action taken on the item. The value will be "moved".
      type: string
  - arguments:
    - description: The mailbox on which to apply the search.
      name: target-mailbox
    - default: true
      defaultValue: AllItems
      description: The path of the folder to retrieve. If empty, will retrieve the folder "AllItems".
      name: folder-path
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder. Default is "False".
      name: is-public
      predefined:
      - 'True'
      - 'False'
    description: Retrieves a single folder.
    name: ews-get-folder
    outputs:
    - contextPath: EWS.Folders.id
      description: Folder ID.
      type: string
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.changeKey
      description: Folder change key.
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Total number of emails in the folder.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread emails in the folder.
      type: number
  - arguments:
    - default: true
      description: Query to use to find emails.
      name: query
      required: true
    deprecated: true
    description: This command is deprecated. Use the o365-sc-start-search command from Security And Compliance V2 instead. Starts a compliance search.
    name: ews-o365-start-compliance-search
    outputs:
    - contextPath: EWS.ComplianceSearch.Name
      description: The name of the compliance search.
      type: string
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search.
      type: string
  - arguments:
    - default: true
      description: The name of the compliance search.
      name: search-name
      required: true
    - auto: PREDEFINED
      defaultValue: 'False'
      description: Whether to return only mailboxes which contain the email. Default is "False".
      name: show-only-recipients
      predefined:
      - 'True'
      - 'False'
    deprecated: true
    description: This command is deprecated. Use the o365-sc-get-search command Security And Compliance V2 instead. Returns the status and results of a compliance search.
    name: ews-o365-get-compliance-search
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search.
      type: Unknown
    - contextPath: EWS.ComplianceSearch.Results.Location
      description: The mailbox.
      type: String
    - contextPath: EWS.ComplianceSearch.Results.Item Count
      description: The number of emails found in the mailbox.
      type: Number
    - contextPath: EWS.ComplianceSearch.Results.Total Size
      description: Total number of emails in the mailbox.
      type: Number
  - arguments:
    - default: true
      description: The name of the compliance search.
      name: search-name
      required: true
    deprecated: true
    description: This command is deprecated. Use the o365-sc-new-search-action command from Security And Compliance V2. Purges the results found in the compliance search.
    name: ews-o365-purge-compliance-search-results
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search.
      type: string
  - arguments:
    - default: true
      description: The name of the compliance search.
      name: search-name
      required: true
    deprecated: true
    description: This command is deprecated. Use the o365-sc-remove-search command from Security And Compliance V2. Removes the compliance search.
    name: ews-o365-remove-compliance-search
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search.
      type: string
  - arguments:
    - default: true
      description: The name of the compliance search.
      name: search-name
      required: true
    deprecated: true
    description: This command is deprecated. Use the o365-sc-get-search-action command from Security And Compliance V2 instead .Checks the status of the purge operation on the compliance search.
    name: ews-o365-get-compliance-search-purge-status
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search.
      type: Unknown
  - description: Returns the auto-discovery information. Can be used to manually configure the Exchange Server.
    name: ews-get-autodiscovery-config
  - arguments:
    - description: Email address of the group to expand.
      name: email-address
      required: true
    - auto: PREDEFINED
      defaultValue: 'False'
      description: Whether to enable recursive expansion. Default is "False".
      name: recursive-expansion
      predefined:
      - 'True'
      - 'False'
    description: Expands a distribution list to display all members. By default, expands only first layer of the distribution list. If recursive-expansion is "True", the command expands nested distribution lists and returns all members.
    name: ews-expand-group
  - arguments:
    - description: A CSV list of item IDs.
      isArray: true
      name: item-ids
      required: true
    - auto: PREDEFINED
      defaultValue: read
      description: How to mark the item. Can be "read" or "unread". Default is "read".
      name: operation
      predefined:
      - read
      - unread
    - description: The mailbox on which to run the command. If empty, the command will be applied on the default mailbox.
      name: target-mailbox
    description: Marks items as read or unread.
    name: ews-mark-items-as-read
    outputs:
    - contextPath: EWS.Items.action
      description: The action that was performed on item.
      type: String
    - contextPath: EWS.Items.itemId
      description: The ID of the item.
      type: String
    - contextPath: EWS.Items.messageId
      description: The message ID of the item.
      type: String
  - arguments:
    - description: The item ID of item to upload as and EML file.
      name: item-id
      required: true
    - description: The mailbox in which this email was found. If empty, the default mailbox is used. Otherwise the user might require impersonation rights to this mailbox.
      name: target-mailbox
    description: Retrieves items by item ID and uploads it's content as eml file.
    name: ews-get-items-as-eml
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: EntryID of the file.
      type: String
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
  - arguments:
    - name: to
      required: true
      description: A CSV list of email addresses for the 'to' field.
    - name: cc
      description: A CSV list of email addresses for the 'cc' field.
    - name: bcc
      description: A CSV list of email addresses for the 'bcc' field.
    - name: subject
      required: true
      description: Subject for the email to be sent.
    - name: replyTo
      description: The email address specified in the 'reply to' field.
    - name: body
      description: The contents (body) of the email to send.
    - name: htmlBody
      description: HTML formatted content (body) of the email to be sent. This argument overrides the "body" argument.
    - name: bodyType
      description: Whether message response body type is Text, or HTML.
      auto: PREDEFINED
      defaultValue: Text
      predefined:
      - Text
      - HTML
    - name: attachIDs
      description: 'A CSV list of War Room entry IDs that contain files, and are used to attach files to the outgoing email. For example: attachIDs=15@8,19@8.'
      isArray: true
    - name: attachNames
      description: A CSV list of names of attachments to send. Should be the same number of elements as attachIDs.
      isArray: true
    - name: attachCIDs
      description: A CSV list of CIDs to embed attachments within the email itself.
      isArray: true
    - description: Raw email message from MimeContent type.
      name: raw_message
    - description: The email address from which to send mail.
      name: from
    description: Sends an email using EWS.
    name: send-mail
  - arguments:
    - name: inReplyTo
      required: true
      description: ID of the item to reply to.
    - name: to
      required: true
      description: A CSV list of email addresses for the 'to' field.
    - name: cc
      description: A CSV list of email addresses for the 'cc' field.
    - name: bcc
      description: A CSV list of email addresses for the 'bcc' field.
    - name: subject
      description: Subject for the email to be sent.
    - name: body
      description: The contents (body) of the email to be sent.
    - name: htmlBody
      description: HTML formatted content (body) of the email to be sent. This argument overrides the "body" argument.
    - name: renderBody
      description: Indicates whether to render the email body.
      auto: PREDEFINED
      predefined:
      - 'true'
      - 'false'
    - name: attachIDs
      description: 'A CSV list of War Room entry IDs that contain files, and are used to attach files to the outgoing email. For example: attachIDs=15@8,19@8.'
      isArray: true
    - name: attachNames
      description: A CSV list of names of attachments to send. Should be the same number of elements as attachIDDs.
      isArray: true
    - name: attachCIDs
      description: A CSV list of CIDs to embed attachments within the email itself.
      isArray: true
    - description: The email address from which to reply.
      name: from
    description: Replies to an email using EWS.
    name: reply-mail
  dockerimage: demisto/py-ews:5.0.3.84262
  isfetch: true
  runonce: false
  script: >
    register_module_line('EWS v2 FIX3', 'start', __line__())

    ### pack version: 2.1.2

    import email

    import hashlib

    import subprocess

    from multiprocessing import Process


    import dateparser  # type: ignore

    import exchangelib



    from io import StringIO

    from exchangelib import (BASIC, DELEGATE, DIGEST, IMPERSONATION, NTLM, Account,
                             Build, Configuration, Credentials, EWSDateTime,
                             EWSTimeZone, FileAttachment, Folder, HTMLBody,
                             ItemAttachment, Version, Body)
    from exchangelib.errors import (AutoDiscoverFailed, ErrorFolderNotFound,
                                    ErrorInvalidIdMalformed,
                                    ErrorInvalidPropertyRequest,
                                    ErrorIrresolvableConflict, ErrorItemNotFound,
                                    ErrorMailboxMoveInProgress,
                                    ErrorMailboxStoreUnavailable,
                                    ErrorNameResolutionNoResults, RateLimitError,
                                    ResponseMessageError, TransportError, ErrorMimeContentConversionFailed)
    from exchangelib.items import Contact, Item, Message

    from exchangelib.protocol import BaseProtocol, Protocol

    from exchangelib.services import EWSService

    from exchangelib.services.common import EWSAccountService

    from exchangelib.util import add_xml_child, create_element

    from exchangelib.version import (EXCHANGE_2007, EXCHANGE_2010,
                                     EXCHANGE_2010_SP2, EXCHANGE_2013,
                                     EXCHANGE_2016, EXCHANGE_2019)
    from future import utils as future_utils

    from requests.exceptions import ConnectionError

    from exchangelib.version import VERSIONS as EXC_VERSIONS

    from email.policy import SMTP, SMTPUTF8



    # Exchange2 2019 patch - server dosen't connect with 2019 but with other versions creating an error mismatch (see CIAC-3086),

    # overriding this function to remove minor version test and remove error throw.

    # opened bug for exchanglib here https://github.com/ecederstrand/exchangelib/issues/1210

    def our_fullname(self):  # pragma: no cover
        for build, api_version, full_name in EXC_VERSIONS:
            # removed 'or self.build.minor_version != build.minor_version'
            if self.build and self.build.major_version != build.major_version:
                continue
            if self.api_version == api_version:
                return full_name
        return None


    Version.fullname = our_fullname



    class exchangelibSSLAdapter(SSLAdapter):  # pragma: no cover
        def cert_verify(self, conn, url, verify, cert):
            # We're overriding a method, so we have to keep the signature, although verify is unused
            del verify
            super().cert_verify(conn=conn, url=url, verify=False, cert=cert)


    # Ignore warnings print to stdout

    warnings.filterwarnings("ignore")


    MNS, TNS = exchangelib.util.MNS, exchangelib.util.TNS


    # consts

    VERSIONS = {
        '2007': EXCHANGE_2007,
        '2010': EXCHANGE_2010,
        '2010_SP2': EXCHANGE_2010_SP2,
        '2013': EXCHANGE_2013,
        '2016': EXCHANGE_2016,
        '2019': EXCHANGE_2019
    }


    ATTACHMENT_ID = "attachmentId"

    ATTACHMENT_ORIGINAL_ITEM_ID = 'originalItemId'

    NEW_ITEM_ID = 'newItemId'

    MESSAGE_ID = "messageId"

    ITEM_ID = "itemId"

    ACTION = "action"

    MAILBOX = "mailbox"

    MAILBOX_ID = "mailboxId"

    FOLDER_ID = "id"


    MOVED_TO_MAILBOX = "movedToMailbox"

    MOVED_TO_FOLDER = "movedToFolder"


    FILE_ATTACHMENT_TYPE = 'FileAttachment'

    ITEM_ATTACHMENT_TYPE = 'ItemAttachment'

    ATTACHMENT_TYPE = 'attachmentType'


    TOIS_PATH = '/root/Top of Information Store/'


    ENTRY_CONTEXT = "EntryContext"

    CONTEXT_UPDATE_EWS_ITEM = "EWS.Items(val.{0} == obj.{0} || (val.{1} && obj.{1} && val.{1} == obj.{1}))".format(ITEM_ID,
                                                                                                                   MESSAGE_ID)
    CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT = f"EWS.Items(val.{ITEM_ID} == obj.{ATTACHMENT_ORIGINAL_ITEM_ID})"

    CONTEXT_UPDATE_ITEM_ATTACHMENT = ".ItemAttachments(val.{0} == obj.{0})".format(ATTACHMENT_ID)

    CONTEXT_UPDATE_FILE_ATTACHMENT = ".FileAttachments(val.{0} == obj.{0})".format(ATTACHMENT_ID)

    CONTEXT_UPDATE_FOLDER = "EWS.Folders(val.{0} == obj.{0})".format(FOLDER_ID)


    LAST_RUN_TIME = "lastRunTime"

    LAST_RUN_IDS = "ids"

    LAST_RUN_FOLDER = "folderName"

    ERROR_COUNTER = "errorCounter"


    ITEMS_RESULTS_HEADERS = ['sender', 'subject', 'hasAttachments', 'datetimeReceived', 'receivedBy', 'author',
                             'toRecipients', 'textBody', ]

    # Load integratoin params from demisto

    NON_SECURE = demisto.params().get('insecure', True)

    AUTH_METHOD_STR = demisto.params().get('authType', '')

    AUTH_METHOD_STR = AUTH_METHOD_STR.lower() if AUTH_METHOD_STR else ''

    VERSION_STR = demisto.params().get('defaultServerVersion', None)

    MANUAL_USERNAME = demisto.params().get('domainAndUserman', '')

    FOLDER_NAME = demisto.params().get('folder', 'Inbox')

    IS_PUBLIC_FOLDER = demisto.params().get('isPublicFolder', False)

    ACCESS_TYPE = IMPERSONATION if demisto.params().get('impersonation', False) else DELEGATE

    FETCH_ALL_HISTORY = demisto.params().get('fetchAllHistory', False)

    IS_TEST_MODULE = False

    BaseProtocol.TIMEOUT = int(demisto.params().get('requestTimeout', 120))

    AUTO_DISCOVERY = False

    SERVER_BUILD = ""

    MARK_AS_READ = demisto.params().get('markAsRead', False)

    MAX_FETCH = min(50, int(demisto.params().get('maxFetch', 50)))

    FETCH_TIME = demisto.params().get('fetch_time') or '10 minutes'


    LAST_RUN_IDS_QUEUE_SIZE = 500


    START_COMPLIANCE = """

    [CmdletBinding()]

    Param(

    [Parameter(Mandatory=$True)]

    [string]$username,


    [Parameter(Mandatory=$True)]

    [string]$query

    )


    $WarningPreference = "silentlyContinue"

    # Create Credential object

    $password = Read-Host

    $secpasswd = ConvertTo-SecureString $password -AsPlainText -Force

    $UserCredential = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)


    # Generate a unique search name

    $searchName = [guid]::NewGuid().ToString() -replace '[-]'

    $searchName = "DemistoSearch" + $searchName


    # open remote PS session to Office 365 Security & Compliance Center

    $session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri `

    https://ps.compliance.protection.outlook.com/powershell-liveid/ -Credential $UserCredential `

    -Authentication Basic -AllowRedirection


    if (!$session)

    {
       "Failed to create remote PS session"
       return
    }


    Import-PSSession $session -CommandName *Compliance* -AllowClobber -DisableNameChecking -Verbose:$false | Out-Null


    $compliance = New-ComplianceSearch -Name $searchName -ExchangeLocation All -ContentMatchQuery $query -Confirm:$false


    Start-ComplianceSearch -Identity $searchName


    $complianceSearchName = "Action status: " + $searchName


    $complianceSearchName | ConvertTo-Json


    # Close the session

    Remove-PSSession $session

    """

    GET_COMPLIANCE = """[CmdletBinding()]

    Param(

    [Parameter(Mandatory=$True)]

    [string]$username,



    [Parameter(Mandatory=$True)]

    [string]$searchName

    )


    $WarningPreference = "silentlyContinue"

    # Create Credential object

    $password = Read-Host

    $secpasswd = ConvertTo-SecureString $password -AsPlainText -Force

    $UserCredential = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)



    # open remote PS session to Office 365 Security & Compliance Center

    $session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri `

    https://ps.compliance.protection.outlook.com/powershell-liveid/ -Credential $UserCredential `

    -Authentication Basic -AllowRedirection


    if (!$session)

    {
       "Failed to create remote PS session"
       return
    }



    Import-PSSession $session -CommandName Get-ComplianceSearch -AllowClobber -DisableNameChecking -Verbose:$false | Out-Null



    $searchStatus = Get-ComplianceSearch $searchName

    #"Search status: " + $searchStatus.Status

    $searchStatus.Status

    if ($searchStatus.Status -eq "Completed")

    {
       $searchStatus.SuccessResults | ConvertTo-Json
    }


    # Close the session

    Remove-PSSession $session

    """

    PURGE_COMPLIANCE = """

    [CmdletBinding()]

    Param(

    [Parameter(Mandatory=$True)]

    [string]$username,


    [Parameter(Mandatory=$True)]

    [string]$searchName

    )


    $WarningPreference = "silentlyContinue"

    # Create Credential object

    $password = Read-Host

    $secpasswd = ConvertTo-SecureString $password -AsPlainText -Force

    $UserCredential = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)


    # open remote PS session to Office 365 Security & Compliance Center

    $session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri `

    https://ps.compliance.protection.outlook.com/powershell-liveid/ -Credential $UserCredential `

    -Authentication Basic -AllowRedirection

    if (!$session)

    {
       "Failed to create remote PS session"
       return
    }



    Import-PSSession $session -CommandName *Compliance* -AllowClobber -DisableNameChecking -Verbose:$false | Out-Null


    # Delete mails based on an existing search criteria

    $newActionResult = New-ComplianceSearchAction -SearchName $searchName -Purge -PurgeType SoftDelete -Confirm:$false

    if (!$newActionResult)

    {
       # Happens when there are no results from the search
       "No action was created"
    }


    # Close the session

    Remove-PSSession $session

    return

    """

    PURGE_STATUS_COMPLIANCE = """

    [CmdletBinding()]

    Param(

    [Parameter(Mandatory=$True)]

    [string]$username,


    [Parameter(Mandatory=$True)]

    [string]$searchName

    )


    $WarningPreference = "silentlyContinue"

    # Create Credential object

    $password = Read-Host

    $secpasswd = ConvertTo-SecureString $password -AsPlainText -Force

    $UserCredential = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)


    # open remote PS session to Office 365 Security & Compliance Center

    $session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri `

    https://ps.compliance.protection.outlook.com/powershell-liveid/ -Credential $UserCredential `

    -Authentication Basic -AllowRedirection


    if (!$session)

    {
       "Failed to create remote PS session"
       return
    }



    Import-PSSession $session -CommandName *Compliance* -AllowClobber -DisableNameChecking -Verbose:$false | Out-Null


    $actionName = $searchName + "_Purge"

    $actionStatus = Get-ComplianceSearchAction $actionName

    ""

    $actionStatus.Status


    # Close the session

    Remove-PSSession $session

    """

    REMOVE_COMPLIANCE = """

    [CmdletBinding()]

    Param(

    [Parameter(Mandatory=$True)]

    [string]$username,


    [Parameter(Mandatory=$True)]

    [string]$searchName

    )


    $WarningPreference = "silentlyContinue"

    # Create Credential object

    $password = Read-Host

    $secpasswd = ConvertTo-SecureString $password -AsPlainText -Force

    $UserCredential = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)



    # open remote PS session to Office 365 Security & Compliance Center


    $session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri `

    https://ps.compliance.protection.outlook.com/powershell-liveid/ -Credential $UserCredential `

    -Authentication Basic -AllowRedirection


    if (!$session)

    {
       "Failed to create remote PS session"
       return
    }



    Import-PSSession $session -CommandName *Compliance* -AllowClobber -DisableNameChecking -Verbose:$false | Out-Null


    # Remove the search

    Remove-ComplianceSearch $searchName -Confirm:$false


    # Close the session

    Remove-PSSession $session

    """


    # initialized in main()

    EWS_SERVER = ''

    USERNAME = ''

    ACCOUNT_EMAIL = ''

    PASSWORD = ''

    config = None

    credentials = None



    # NOTE: Same method used in EWSMailSender

    # If you are modifying this probably also need to modify in the other file

    def exchangelib_cleanup():  # pragma: no cover
        try:
            exchangelib.close_connections()
        except Exception as ex:
            demisto.error(f"Error was found in exchangelib cleanup, ignoring: {ex}")


    # Prep Functions

    def get_auth_method(auth_method):  # pragma: no cover
        auth_method = auth_method.lower()
        if auth_method == 'ntlm':
            return NTLM
        elif auth_method == 'basic':
            return BASIC
        elif auth_method == 'digest':
            return DIGEST
        raise Exception("{} auth method is not supported. Choose one of {}".format(auth_method, 'ntlm\\basic\\digest'))


    def get_build(version_str):  # pragma: no cover
        if version_str not in VERSIONS:
            raise Exception("{} is unsupported version: {}. Choose one of".format(version_str, "\\".join(list(VERSIONS.keys()))))
        return VERSIONS[version_str]


    def get_build_autodiscover(context_dict):  # pragma: no cover
        build_params = context_dict["build"].split(".")
        build_params = [int(i) for i in build_params]
        return Build(*build_params)


    def get_endpoint_autodiscover(context_dict):  # pragma: no cover
        return context_dict["service_endpoint"]


    def get_version(version_str):  # pragma: no cover
        if version_str not in VERSIONS:
            raise Exception("{} is unsupported version: {}. Choose one of".format(version_str, "\\".join(list(VERSIONS.keys()))))
        return Version(VERSIONS[version_str])


    def create_context_dict(account):  # pragma: no cover
        return {
            "auth_type": account.protocol.auth_type,
            "service_endpoint": account.protocol.service_endpoint,
            "build": str(account.protocol.version.build),
            "api_version": account.protocol.version.api_version
        }


    def prepare_context(credentials):  # pragma: no cover
        context_dict = demisto.getIntegrationContext()
        global SERVER_BUILD, EWS_SERVER
        if not context_dict:
            try:
                account = Account(
                    primary_smtp_address=ACCOUNT_EMAIL, autodiscover=True,
                    access_type=ACCESS_TYPE, credentials=credentials,
                )
                EWS_SERVER = account.protocol.service_endpoint
                SERVER_BUILD = account.protocol.version.build
                demisto.setIntegrationContext(create_context_dict(account))
            except AutoDiscoverFailed:
                return_error("Auto discovery failed. Check credentials or configure manually")
            except Exception as e:
                return_error(str(e))
        else:
            SERVER_BUILD = get_build_autodiscover(context_dict)
            EWS_SERVER = get_endpoint_autodiscover(context_dict)


    def prepare():  # pragma: no cover
        if NON_SECURE:
            BaseProtocol.HTTP_ADAPTER_CLS = exchangelibSSLAdapter
        else:
            BaseProtocol.HTTP_ADAPTER_CLS = requests.adapters.HTTPAdapter

        global AUTO_DISCOVERY, VERSION_STR, AUTH_METHOD_STR, USERNAME
        AUTO_DISCOVERY = not EWS_SERVER
        if AUTO_DISCOVERY:
            credentials = Credentials(username=USERNAME, password=PASSWORD)
            prepare_context(credentials)
            return None, credentials
        else:
            if 'outlook.office365.com' in EWS_SERVER.lower():
                if not AUTH_METHOD_STR:
                    AUTH_METHOD_STR = 'Basic'
                VERSION_STR = '2016'
            else:
                if MANUAL_USERNAME:
                    USERNAME = MANUAL_USERNAME
                if not AUTH_METHOD_STR:
                    AUTH_METHOD_STR = 'ntlm'
                if not VERSION_STR:
                    return_error('Exchange Server Version is required for on-premise Exchange Servers.')

            version = get_version(VERSION_STR)
            credentials = Credentials(username=USERNAME, password=PASSWORD)
            config_args = {
                'credentials': credentials,
                'auth_type': get_auth_method(AUTH_METHOD_STR),
                'version': version
            }
            if not EWS_SERVER:
                return_error("Exchange Server Hostname or IP Address is required for manual configuration.")
            elif 'http' in EWS_SERVER.lower():
                config_args['service_endpoint'] = EWS_SERVER
            else:
                config_args['server'] = EWS_SERVER

            return Configuration(**config_args), None


    def construct_config_args(context_dict, credentials):  # pragma: no cover
        auth_type = context_dict["auth_type"]
        api_version = context_dict["api_version"]
        service_endpoint = context_dict["service_endpoint"]
        version = Version(get_build_autodiscover(context_dict), api_version)

        config_args = {
            'credentials': credentials,
            'auth_type': auth_type,
            'version': version,
            'service_endpoint': service_endpoint
        }
        return config_args


    def get_account_autodiscover(account_email, access_type=ACCESS_TYPE, time_zone=None):  # pragma: no cover
        account = None
        original_exc = None  # type: ignore
        context_dict = demisto.getIntegrationContext()

        if context_dict:
            try:
                config_args = construct_config_args(context_dict, credentials)
                account = Account(
                    primary_smtp_address=account_email, autodiscover=False, config=Configuration(**config_args),
                    access_type=access_type, default_timezone=time_zone
                )
                account.root.effective_rights.read  # noqa: B018 pylint: disable=E1101
                return account
            except Exception as e:
                # fixing flake8 correction where original_exc is assigned but unused
                original_exc = e

        try:
            account = Account(
                primary_smtp_address=ACCOUNT_EMAIL, autodiscover=True, credentials=credentials, access_type=access_type,
            )
        except AutoDiscoverFailed:
            return_error("Auto discovery failed. Check credentials or configure manually")

        autodiscover_result = create_context_dict(account)
        if autodiscover_result == context_dict and original_exc:
            raise original_exc  # pylint: disable=E0702

        if account_email == ACCOUNT_EMAIL:
            demisto.setIntegrationContext(create_context_dict(account))
        return account


    def get_account(account_email, access_type=ACCESS_TYPE, time_zone=None):  # pragma: no cover
        if not AUTO_DISCOVERY:
            return Account(
                primary_smtp_address=account_email, autodiscover=False, config=config, access_type=access_type,
                default_timezone=time_zone
            )
        return get_account_autodiscover(account_email, access_type, time_zone)


    # LOGGING

    log_stream = None

    log_handler = None



    def start_logging():
        global log_stream
        global log_handler
        logging.raiseExceptions = False
        if log_stream is None:
            log_stream = StringIO()
            log_handler = logging.StreamHandler(stream=log_stream)
            log_handler.setFormatter(logging.Formatter(logging.BASIC_FORMAT))
            logger = logging.getLogger()
            logger.addHandler(log_handler)
            logger.setLevel(logging.DEBUG)


    # Exchange 2010 Fixes

    def fix_2010():  # pragma: no cover
        version = SERVER_BUILD if SERVER_BUILD else get_build(VERSION_STR)
        if version <= EXCHANGE_2010_SP2:
            for m in (
                    Item, Message, exchangelib.items.CalendarItem, exchangelib.items.Contact,
                    exchangelib.items.DistributionList,
                    exchangelib.items.PostItem, exchangelib.items.Task, exchangelib.items.MeetingRequest,
                    exchangelib.items.MeetingResponse, exchangelib.items.MeetingCancellation):
                for i, f in enumerate(m.FIELDS):
                    if f.name == 'text_body':
                        m.FIELDS.pop(i)
                        break
            for m in (exchangelib.Folder, exchangelib.folders.Inbox):
                for i, f in enumerate(m.FIELDS):
                    if f.name == 'unread_count':
                        m.FIELDS.pop(i)
                        break

            def repr1(self):
                return self.__class__.__name__ + repr((self.root, self.name, self.total_count, self.child_folder_count,
                                                       self.folder_class, self.id, self.changekey))

            def repr2(self):
                return self.__class__.__name__ + repr(
                    (self.root, self.name, self.total_count, self.child_folder_count, self.folder_class, self.changekey))

            def repr3(self):
                return self.__class__.__name__ + repr((self.account, '[self]', self.name, self.total_count,
                                                       self.child_folder_count, self.folder_class, self.changekey))

            exchangelib.Folder.__repr__ = repr1
            exchangelib.folders.Inbox.__repr__ = exchangelib.folders.JunkEmail.__repr__ = repr2
            exchangelib.folders.Root.__repr__ = repr3

        start_logging()


    def str_to_unicode(obj):  # pragma: no cover
        if isinstance(obj, dict):
            obj = {k: str_to_unicode(v) for k, v in list(obj.items())}
        elif isinstance(obj, list):
            obj = [str_to_unicode(k) for k in obj]
        elif isinstance(obj, str):
            obj = obj.encode("utf-8")
        return obj


    def filter_dict_null(d):  # pragma: no cover
        if isinstance(d, dict):
            return {k: v for k, v in list(d.items()) if v is not None}
        return d


    def is_empty_object(obj):
        return (obj.__sizeof__() if isinstance(obj, map) else len(obj)) == 0


    def get_time_zone() -> EWSTimeZone | None:
        """get the XSOAR user time zone
        :return:
            returns an ``EWSTimeZone`` if TZ available or ``None`` if not
        :rtype: ``Optional[EWSTimeZone]``
        """
        time_zone = demisto.callingContext.get('context', {}).get('User', {}).get('timeZone', None)
        if time_zone:
            time_zone = EWSTimeZone(time_zone)
        return time_zone


    def get_attachment_name(attachment_name):  # pragma: no cover
        if attachment_name is None or attachment_name == "":
            return 'demisto_untitled_attachment'
        return attachment_name


    def switch_hr_headers(obj, hr_header_changes):
        """
        Will swap keys according to hr_header_changes.
        hr_header_changes: a dict, keys are the old value, value is the new value
        """
        if not isinstance(obj, dict):
            return obj
        obj_copy = obj.copy()
        for old_header, new_header in hr_header_changes.items():
            if old_header in obj:
                obj_copy[new_header] = obj_copy.pop(old_header)
        return obj_copy


    def get_entry_for_object(title, context_key, obj, headers=None, hr_header_changes={}):  # pragma: no cover
        if is_empty_object(obj):
            return "There is no output results"
        obj = filter_dict_null(obj)
        hr_obj = switch_hr_headers(obj, hr_header_changes)
        if isinstance(obj, list):
            obj = [filter_dict_null(k) for k in obj]
            hr_obj = [switch_hr_headers(k, hr_header_changes) for k in obj]
        if headers and isinstance(obj, dict):
            headers = list(set(headers).intersection(set(obj.keys())))

        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr_obj, headers),
            ENTRY_CONTEXT: {
                context_key: obj
            }
        }


    def get_items_from_mailbox(account, item_ids):  # pragma: no cover
        if type(item_ids) is not list:
            item_ids = [item_ids]
        items = [Item(id=x) for x in item_ids]
        result = list(account.fetch(ids=items))
        result = [x for x in result if not (isinstance(x, ErrorInvalidIdMalformed | ErrorItemNotFound))]
        if len(result) != len(item_ids):
            raise Exception("One or more items were not found/malformed. Check the input item ids")
        return result


    def get_item_from_mailbox(account, item_id):  # pragma: no cover
        result = get_items_from_mailbox(account, [item_id])
        if len(result) == 0:
            raise Exception("ItemId %s not found" % str(item_id))
        return result[0]


    def is_default_folder(folder_path, is_public):  # pragma: no cover

        if is_public is not None:
            return is_public

        if folder_path == FOLDER_NAME:
            return IS_PUBLIC_FOLDER

        return False


    def get_folder_by_path(account, path, is_public=False):  # pragma: no cover
        # handle exchange folder id
        if len(path) == 120:
            folders_map = account.root._folders_map
            if path in folders_map:
                return account.root._folders_map[path]

        if is_public:
            folder_result = account.public_folders_root
        elif path == 'AllItems':
            folder_result = account.root
        else:
            folder_result = account.inbox.parent  # Top of Information Store
        path = path.replace("/", "\\")
        path = path.split('\\')
        for sub_folder_name in path:
            folder_filter_by_name = [x for x in folder_result.children if x.name.lower() == sub_folder_name.lower()]
            if len(folder_filter_by_name) == 0:
                raise Exception("No such folder %s" % path)
            folder_result = folder_filter_by_name[0]

        return folder_result


    class MarkAsJunk(EWSAccountService):
        SERVICE_NAME = 'MarkAsJunk'

        def call(self, item_id, move_item):  # pragma: no cover
            elements = list(self._get_elements(payload=self.get_payload(item_id=item_id, move_item=move_item)))
            for element in elements:
                if isinstance(element, ResponseMessageError):
                    return element.message
            return "Success"

        def get_payload(self, item_id, move_item):  # pragma: no cover
            junk = create_element('m:%s' % self.SERVICE_NAME,
                                  {"IsJunk": "true",
                                   "MoveItem": ("true" if move_item else "false")})

            items_list = create_element('m:ItemIds')
            item_element = create_element("t:ItemId", {"Id": item_id})
            items_list.append(item_element)
            junk.append(items_list)

            return junk


    def send_email_to_mailbox(account, to, subject, body, body_type, bcc, cc, reply_to, html_body=None, attachments=None,
                              raw_message=None, from_address=None):  # pragma: no cover
        """
        Send an email to a mailbox.

        Args:
            body_type: type of the body. Can be 'html' or 'text' or None.
            account (Account): account from which to send an email.
            to (list[str]): a list of emails to send an email.
            subject (str): subject of the mail.
            body (str): body of the email.
            reply_to (list[str]): list of emails of which to reply to from the sent email.
            bcc (list[str]): list of email addresses for the 'bcc' field.
            cc (list[str]): list of email addresses for the 'cc' field.
            html_body (str): HTML formatted content (body) of the email to be sent. This argument
                overrides the "body" argument.
            attachments (list[str]): list of names of attachments to send.
            raw_message (str): Raw email message from MimeContent type.
            from_address (str): the email address from which to reply.
        """
        if not attachments:
            attachments = []
        message_body = get_message_for_body_type(body, body_type, html_body)
        m = Message(
            account=account,
            mime_content=raw_message.encode('UTF-8') if raw_message else None,
            folder=account.sent,
            cc_recipients=cc,
            bcc_recipients=bcc,
            subject=subject,
            body=message_body,
            to_recipients=to,
            reply_to=reply_to,
            author=from_address
        )
        if account.protocol.version.build <= EXCHANGE_2010_SP2:
            m.save()
            for attachment in attachments:
                m.attach(attachment)
            m.send()
        else:
            for attachment in attachments:
                m.attach(attachment)
            m.send_and_save()
        return m


    def get_message_for_body_type(body, body_type, html_body):
        """
        Compatibility with Data Collection - where body_type is not provided, we will use the html_body if it exists.
        Compatibility with 'send-mail' command - where body_type should be provided, we will use the body_type to decide.
        Args:
            body_type: type of the body. Can be 'html' or 'text' or None.
            body: plain text body.
            html_body: HTML formatted content (body) of the email to be sent.

        Returns:
            Body: the body of the message.
        """
        if body_type is None:  # When called from a data collection task.
            return HTMLBody(html_body) if html_body else Body(body)
        if body_type.lower() == 'html' and html_body:  # When called from 'send-mail' command.
            return HTMLBody(html_body)
        return Body(body)


    def send_email_reply_to_mailbox(account, in_reply_to, to, body, subject=None, bcc=None, cc=None, html_body=None,
                                    attachments=None, from_mailbox=None):  # pragma: no cover
        if attachments is None:
            attachments = []
        item_to_reply_to = account.inbox.get(id=in_reply_to)
        if isinstance(item_to_reply_to, ErrorItemNotFound):
            raise Exception(item_to_reply_to)

        subject = subject or item_to_reply_to.subject
        # `reply-mail` command does not support body_type, so we will use the html_body if it exists.
        message_body = HTMLBody(html_body) if html_body else body
        reply = item_to_reply_to.create_reply(subject='Re: ' + subject, body=message_body, to_recipients=to, cc_recipients=cc,
                                              bcc_recipients=bcc, author=from_mailbox)
        reply = reply.save(account.drafts)
        m = account.inbox.get(id=reply.id)

        for attachment in attachments:
            m.attach(attachment)
        m.send()

        return m


    class GetSearchableMailboxes(EWSService):  # pragma: no cover
        SERVICE_NAME = 'GetSearchableMailboxes'
        element_container_name = '{%s}SearchableMailboxes' % MNS

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find("{%s}PrimarySmtpAddress" % TNS).text if element.find(
                    "{%s}PrimarySmtpAddress" % TNS) is not None else None,
                MAILBOX_ID: element.find("{%s}ReferenceId" % TNS).text if element.find(
                    "{%s}ReferenceId" % TNS) is not None else None,
                'displayName': element.find("{%s}DisplayName" % TNS).text if element.find(
                    "{%s}DisplayName" % TNS) is not None else None,
                'isExternal': element.find("{%s}IsExternalMailbox" % TNS).text if element.find(
                    "{%s}IsExternalMailbox" % TNS) is not None else None,
                'externalEmailAddress': element.find("{%s}ExternalEmailAddress" % TNS).text if element.find(
                    "{%s}ExternalEmailAddress" % TNS) is not None else None
            }

        def call(self):
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = self._get_elements(payload=self.get_payload())
            return [self.parse_element(e) for e in elements]

        def get_payload(self):
            element = create_element(
                'm:%s' % self.SERVICE_NAME,
            )
            return element


    class SearchMailboxes(EWSService):
        SERVICE_NAME = 'SearchMailboxes'
        element_container_name = f'{{{MNS}}}SearchMailboxesResult/{{{TNS}}}Items'

        @staticmethod
        def parse_element(element):  # pragma: no cover
            to_recipients = element.find('{%s}ToRecipients' % TNS)
            if to_recipients:
                to_recipients = [x.text if x is not None else None for x in to_recipients]

            result = {
                ITEM_ID: element.find('{%s}Id' % TNS).attrib['Id'] if element.find('{%s}Id' % TNS) is not None else None,
                MAILBOX: element.find(f'{{{TNS}}}Mailbox/{{{TNS}}}PrimarySmtpAddress').text if element.find(
                    f'{{{TNS}}}Mailbox/{{{TNS}}}PrimarySmtpAddress') is not None else None,
                'subject': element.find("{%s}Subject" % TNS).text if element.find(
                    "{%s}Subject" % TNS) is not None else None,
                'toRecipients': to_recipients,
                'sender': element.find("{%s}Sender" % TNS).text if element.find("{%s}Sender" % TNS) is not None else None,
                'hasAttachments': element.find("{%s}HasAttachment" % TNS).text if element.find(
                    "{%s}HasAttachment" % TNS) is not None else None,
                'datetimeSent': element.find("{%s}SentTime" % TNS).text if element.find(
                    "{%s}SentTime" % TNS) is not None else None,
                'datetimeReceived': element.find("{%s}ReceivedTime" % TNS).text if element.find(
                    "{%s}ReceivedTime" % TNS) is not None else None
            }

            return result

        def call(self, query, mailboxes):  # pragma: no cover
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = list(self._get_elements(payload=self.get_payload(query, mailboxes)))
            return [self.parse_element(x) for x in elements]

        def get_payload(self, query, mailboxes):  # pragma: no cover
            def get_mailbox_search_scope(mailbox_id):
                mailbox_search_scope = create_element("t:MailboxSearchScope")
                add_xml_child(mailbox_search_scope, "t:Mailbox", mailbox_id)
                add_xml_child(mailbox_search_scope, "t:SearchScope", "All")
                return mailbox_search_scope

            mailbox_query_element = create_element("t:MailboxQuery")
            add_xml_child(mailbox_query_element, "t:Query", query)
            mailboxes_scopes = []
            for mailbox in mailboxes:
                mailboxes_scopes.append(get_mailbox_search_scope(mailbox))
            add_xml_child(mailbox_query_element, "t:MailboxSearchScopes", mailboxes_scopes)

            element = create_element('m:%s' % self.SERVICE_NAME)
            add_xml_child(element, "m:SearchQueries", mailbox_query_element)
            add_xml_child(element, "m:ResultType", "PreviewOnly")

            return element


    class ExpandGroup(EWSService):
        SERVICE_NAME = 'ExpandDL'
        element_container_name = '{%s}DLExpansion' % MNS

        @staticmethod
        def parse_element(element):  # pragma: no cover
            return {
                MAILBOX: element.find("{%s}EmailAddress" % TNS).text if element.find(
                    "{%s}EmailAddress" % TNS) is not None else None,
                'displayName': element.find("{%s}Name" % TNS).text if element.find("{%s}Name" % TNS) is not None else None,
                'mailboxType': element.find("{%s}MailboxType" % TNS).text if element.find(
                    "{%s}MailboxType" % TNS) is not None else None
            }

        def call(self, email_address, recursive_expansion=False):  # pragma: no cover
            if self.protocol.version.build < EXCHANGE_2010:
                raise NotImplementedError('%s is only supported for Exchange 2010 servers and later' % self.SERVICE_NAME)
            try:
                if recursive_expansion == 'True':
                    group_members = {}  # type: dict
                    self.expand_group_recursive(email_address, group_members)
                    return list(group_members.values())
                else:
                    return self.expand_group(email_address)
            except ErrorNameResolutionNoResults:
                demisto.results("No results were found.")
                sys.exit()

        def get_payload(self, email_address):  # pragma: no cover
            element = create_element('m:%s' % self.SERVICE_NAME, )
            mailbox_element = create_element('m:Mailbox')
            add_xml_child(mailbox_element, 't:EmailAddress', email_address)
            element.append(mailbox_element)
            return element

        def expand_group(self, email_address):  # pragma: no cover
            elements = self._get_elements(payload=self.get_payload(email_address))
            return [self.parse_element(x) for x in elements]

        def expand_group_recursive(self, email_address, non_dl_emails, dl_emails=set()):  # pragma: no cover
            if email_address in non_dl_emails or email_address in dl_emails:
                return
            dl_emails.add(email_address)

            for member in self.expand_group(email_address):
                if member['mailboxType'] == 'PublicDL' or member['mailboxType'] == 'PrivateDL':
                    self.expand_group_recursive(member['mailbox'], non_dl_emails, dl_emails)
                else:
                    if member['mailbox'] not in non_dl_emails:
                        non_dl_emails[member['mailbox']] = member


    def get_expanded_group(protocol, email_address, recursive_expansion=False):  # pragma: no cover
        group_members = ExpandGroup(protocol=protocol).call(email_address, recursive_expansion)
        group_details = {
            "name": email_address,
            "members": group_members
        }
        entry_for_object = get_entry_for_object("Expanded group", 'EWS.ExpandGroup', group_details)
        entry_for_object['HumanReadable'] = tableToMarkdown('Group Members', group_members)
        return entry_for_object


    def get_searchable_mailboxes(protocol):  # pragma: no cover
        searchable_mailboxes = GetSearchableMailboxes(protocol=protocol).call()
        return get_entry_for_object("Searchable mailboxes", 'EWS.Mailboxes', searchable_mailboxes)


    def search_mailboxes(protocol, filter, limit=100, mailbox_search_scope=None, email_addresses=None):  # pragma: no cover
        mailbox_ids = []
        limit = int(limit)
        if mailbox_search_scope is not None and email_addresses is not None:
            raise Exception("Use one of the arguments - mailbox-search-scope or email-addresses, not both")
        if email_addresses:
            email_addresses = email_addresses.split(",")
            all_mailboxes = get_searchable_mailboxes(protocol)[ENTRY_CONTEXT]['EWS.Mailboxes']
            for email_address in email_addresses:
                for mailbox in all_mailboxes:
                    if MAILBOX in mailbox and email_address.lower() == mailbox[MAILBOX].lower():
                        mailbox_ids.append(mailbox[MAILBOX_ID])
            if len(mailbox_ids) == 0:
                raise Exception("No searchable mailboxes were found for the provided email addresses.")
        elif mailbox_search_scope:
            mailbox_ids = mailbox_search_scope if type(mailbox_search_scope) is list else [mailbox_search_scope]
        else:
            entry = get_searchable_mailboxes(protocol)
            mailboxes = [x for x in entry[ENTRY_CONTEXT]['EWS.Mailboxes'] if MAILBOX_ID in list(x.keys())]
            mailbox_ids = [x[MAILBOX_ID] for x in mailboxes]  # type: ignore

        try:
            search_results = SearchMailboxes(protocol=protocol).call(filter, mailbox_ids)
            search_results = search_results[:limit]
        except TransportError as e:
            if "ItemCount>0<" in str(e):
                return "No results for search query: " + filter
            else:
                raise e

        return get_entry_for_object("Search mailboxes results",
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    search_results)


    def get_last_run():
        last_run = demisto.getLastRun()
        if not last_run or last_run.get(LAST_RUN_FOLDER) != FOLDER_NAME:
            last_run = {
                LAST_RUN_TIME: None,
                LAST_RUN_FOLDER: FOLDER_NAME,
                LAST_RUN_IDS: []
            }
        if LAST_RUN_TIME in last_run and last_run[LAST_RUN_TIME] is not None:
            last_run[LAST_RUN_TIME] = EWSDateTime.from_string(last_run[LAST_RUN_TIME])

        # In case we have existing last_run data
        if last_run.get(LAST_RUN_IDS) is None:
            last_run[LAST_RUN_IDS] = []

        return last_run


    def fetch_last_emails(account, folder_name='Inbox', since_datetime=None, exclude_ids=None):
        qs = get_folder_by_path(account, folder_name, is_public=IS_PUBLIC_FOLDER)
        demisto.debug(f'since_datetime: {since_datetime}')
        if since_datetime:
            qs = qs.filter(datetime_received__gte=since_datetime)
        else:
            if not FETCH_ALL_HISTORY:
                tz = EWSTimeZone('UTC')
                first_fetch_datetime = dateparser.parse(FETCH_TIME)
                if not first_fetch_datetime:
                    raise DemistoException('Failed to parse first last run time')
                first_fetch_ews_datetime = first_fetch_datetime.astimezone(tz)
                qs = qs.filter(datetime_received__gte=first_fetch_ews_datetime)
        qs = qs.filter().only(*[x.name for x in Message.FIELDS])
        qs = qs.filter().order_by('datetime_received')
        result = []
        exclude_ids = exclude_ids if exclude_ids else set()
        demisto.debug(f'Exclude ID list: {exclude_ids}')

        for item in qs:
            try:
                demisto.debug('Looking on subject={}, message_id={}, created={}, received={}'.format(
                    item.subject, item.message_id, item.datetime_created, item.datetime_received))
                if isinstance(item, Message) and item.message_id not in exclude_ids:
                    result.append(item)
                    demisto.debug(f'Appending {item.subject}, {item.message_id}.')
                    if len(result) >= MAX_FETCH:
                        break
            except ValueError as exc:
                future_utils.raise_from(ValueError(
                    'Got an error when pulling incidents. You might be using the wrong exchange version.'
                ), exc)
                raise exc
            except ErrorMimeContentConversionFailed as exc:
                demisto.debug(f"Encountered an ErrorMimeContentConversionFailed error object while iterating: {exc}.\
                    Continuing to next item.")
                continue
            except AttributeError as exc:
                demisto.debug(f"Encountered an Attribute error object while iterating: {exc}.\
                     Continuing to next item.")

        demisto.debug(f'EWS V2 - Got total of {len(result)} from ews query. ')
        return result


    def keys_to_camel_case(value):
        def str_to_camel_case(snake_str):
            # Add condition as Email object arrived in list and raised error
            if not isinstance(snake_str, str):
                return snake_str
            components = snake_str.split('_')
            return components[0] + "".join(x.title() for x in components[1:])

        if value is None:
            return None
        if isinstance(value, list | set):
            return [keys_to_camel_case(v) for v in value]
        if isinstance(value, dict):
            return {keys_to_camel_case(k): keys_to_camel_case(v) if isinstance(v, list | dict) else v
                    for (k, v) in list(value.items())}

        return str_to_camel_case(value)


    def email_ec(item):  # pragma: no cover
        return {
            'CC': None if not item.cc_recipients else [mailbox.email_address for mailbox in item.cc_recipients],
            'BCC': None if not item.bcc_recipients else [mailbox.email_address for mailbox in item.bcc_recipients],
            'To': None if not item.to_recipients else [mailbox.email_address for mailbox in item.to_recipients],
            'From': item.author.email_address,
            'Subject': item.subject,
            'Text': item.text_body,
            'HTML': item.body,
            'HeadersMap': {} if not item.headers else {header.name: header.value for header in item.headers},
        }


    def parse_object_as_dict_with_serialized_items(object):
        raw_dict = {}
        if object is not None:
            for field in object.FIELDS:
                try:
                    v = getattr(object, field.name, None)
                    if v is not None:
                        json.dumps(v)
                        raw_dict[field.name] = v
                except (TypeError, OverflowError):
                    demisto.debug(f'Data in field {field.name} is not serilizable, skipped field')
                    continue
        return raw_dict


    def parse_item_as_dict(item, email_address=None, camel_case=False, compact_fields=False):  # pragma: no cover
        def parse_object_as_dict(object):
            raw_dict = {}
            if object is not None:
                for field in object.FIELDS:
                    raw_dict[field.name] = getattr(object, field.name, None)
            return raw_dict

        def parse_attachment_as_raw_json(attachment):
            raw_dict = parse_object_as_dict(attachment)
            if raw_dict['attachment_id']:
                raw_dict['attachment_id'] = parse_object_as_dict(raw_dict['attachment_id'])
            if raw_dict['last_modified_time']:
                raw_dict['last_modified_time'] = raw_dict['last_modified_time'].ewsformat()
            return raw_dict

        def parse_folder_as_json(folder):  # pragma: no cover
            raw_dict = parse_object_as_dict(folder)
            if 'parent_folder_id' in raw_dict:
                raw_dict['parent_folder_id'] = parse_folder_as_json(raw_dict['parent_folder_id'])
            if 'effective_rights' in raw_dict:
                raw_dict['effective_rights'] = parse_object_as_dict(raw_dict['effective_rights'])
            return raw_dict

        raw_dict = parse_object_as_dict_with_serialized_items(item)

        if getattr(item, 'attachments', None):
            raw_dict['attachments'] = [parse_attachment_as_dict(item.id, x) for x in item.attachments]

        for time_field in ['datetime_sent', 'datetime_created', 'datetime_received', 'last_modified_time',
                           'reminder_due_by']:
            value = getattr(item, time_field, None)
            if value:
                raw_dict[time_field] = value.ewsformat()

        for dict_field in ['effective_rights', 'parent_folder_id', 'conversation_id', 'author',
                           'extern_id', 'received_by', 'received_representing', 'reply_to', 'sender', 'folder']:
            value = getattr(item, dict_field, None)
            if value:
                if type(value) is list:
                    raw_dict[dict_field] = [parse_object_as_dict(x) for x in value]
                else:
                    raw_dict[dict_field] = parse_object_as_dict(value)

        for list_dict_field in ['headers', 'cc_recipients', 'to_recipients']:
            value = getattr(item, list_dict_field, None)
            if value:
                raw_dict[list_dict_field] = [parse_object_as_dict(x) for x in value]

        for list_str_field in ["categories"]:
            value = getattr(item, list_str_field, None)
            if value:
                raw_dict[list_str_field] = value

        if getattr(item, 'folder', None):
            raw_dict['folder'] = parse_folder_as_json(item.folder)
            folder_path = item.folder.absolute[len(TOIS_PATH):] if item.folder.absolute.startswith(
                TOIS_PATH) else item.folder.absolute
            raw_dict['folder_path'] = folder_path

        raw_dict['item_id'] = getattr(item, 'id', None)
        raw_dict['id'] = getattr(item, 'id', None)

        if compact_fields:
            new_dict = {}
            fields_list = ['datetime_created', 'datetime_received', 'datetime_sent', 'sender',
                           'has_attachments', 'importance', 'message_id', 'last_modified_time',
                           'size', 'subject', 'text_body', 'headers', 'body', 'folder_path', 'is_read', 'categories']

            fields_list.append('item_id')

            for field in fields_list:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field)
            for field in ['received_by', 'author', 'sender']:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field, {}).get('email_address')
            for field in ['to_recipients']:
                if field in raw_dict:
                    new_dict[field] = [x.get('email_address') for x in raw_dict[field]]
            attachments = raw_dict.get('attachments')
            if attachments and len(attachments) > 0:
                file_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == FILE_ATTACHMENT_TYPE]
                if len(file_attachments) > 0:
                    new_dict['FileAttachments'] = file_attachments
                item_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == ITEM_ATTACHMENT_TYPE]
                if len(item_attachments) > 0:
                    new_dict['ItemAttachments'] = item_attachments
            raw_dict = new_dict

        if camel_case:
            raw_dict = keys_to_camel_case(raw_dict)

        if email_address:
            raw_dict[MAILBOX] = email_address
        return raw_dict


    def parse_incident_from_item(item, is_fetch):  # pragma: no cover
        incident = {}
        labels = []

        try:
            try:
                incident['details'] = item.text_body or item.body
            except AttributeError:
                incident['details'] = item.body

            incident['name'] = item.subject
            labels.append({'type': 'Email/subject', 'value': item.subject})
            incident['occurred'] = item.datetime_created.ewsformat()

            # handle recipients
            if item.to_recipients:
                for recipient in item.to_recipients:
                    labels.append({'type': 'Email', 'value': recipient.email_address})

            # handle cc
            if item.cc_recipients:
                for recipient in item.cc_recipients:
                    labels.append({'type': 'Email/cc', 'value': recipient.email_address})
            # handle email from
            if item.sender:
                labels.append({'type': 'Email/from', 'value': item.sender.email_address})

            # email format
            email_format = ''
            try:
                if item.text_body:
                    labels.append({'type': 'Email/text', 'value': item.text_body})
                    email_format = 'text'
            except AttributeError:
                pass
            if item.body:
                labels.append({'type': 'Email/html', 'value': item.body})
                email_format = 'HTML'
            labels.append({'type': 'Email/format', 'value': email_format})

            # handle attachments
            if item.attachments:
                incident['attachment'] = []
                for attachment in item.attachments:
                    if attachment is not None:
                        attachment.parent_item = item
                        file_result = None
                        label_attachment_type = None
                        label_attachment_id_type = None
                        if isinstance(attachment, FileAttachment):
                            try:
                                if attachment.content:
                                    # file attachment
                                    label_attachment_type = 'attachments'
                                    label_attachment_id_type = 'attachmentId'

                                    # save the attachment
                                    file_name = get_attachment_name(attachment.name)
                                    file_result = fileResult(file_name, attachment.content)

                                    # check for error
                                    if file_result['Type'] == entryTypes['error']:
                                        demisto.error(file_result['Contents'])
                                        raise Exception(file_result['Contents'])

                                    # save attachment to incident
                                    incident['attachment'].append({
                                        'path': file_result['FileID'],
                                        'name': get_attachment_name(attachment.name)
                                    })
                            except TypeError as e:
                                if str(e) != "must be string or buffer, not None":
                                    raise
                                continue
                        else:
                            # other item attachment
                            label_attachment_type = 'attachmentItems'
                            label_attachment_id_type = 'attachmentItemsId'

                            # save the attachment
                            if hasattr(attachment, 'item') and attachment.item.mime_content:
                                # Some items arrive with bytes attachemnt
                                email_policy = SMTP if attachment.item.mime_content.isascii() else SMTPUTF8
                                if isinstance(attachment.item.mime_content, bytes):
                                    attached_email = email.message_from_bytes(attachment.item.mime_content, policy=email_policy)
                                else:
                                    attached_email = email.message_from_string(attachment.item.mime_content, policy=email_policy)
                                if attachment.item.headers:
                                    attached_email_headers = []
                                    for h, v in list(attached_email.items()):
                                        if not isinstance(v, str):
                                            try:
                                                v = str(v)
                                            except:  # noqa: E722
                                                demisto.debug(f'cannot parse the header "{h}"')
                                                continue

                                        v = ' '.join(map(str.strip, v.split('\r\n')))
                                        attached_email_headers.append((h.lower(), v))

                                    for header in attachment.item.headers:
                                        if (header.name.lower(), header.value) not in attached_email_headers \
                                                and header.name.lower() != 'content-type':
                                            try:
                                                attached_email.add_header(header.name, header.value)
                                            except ValueError as err:
                                                if "There may be at most" not in str(err):
                                                    raise err

                                file_result = fileResult(get_attachment_name(attachment.name) + ".eml",
                                                         attached_email.as_string())

                            if file_result:
                                # check for error
                                if file_result['Type'] == entryTypes['error']:
                                    demisto.error(file_result['Contents'])
                                    raise Exception(file_result['Contents'])

                                # save attachment to incident
                                incident['attachment'].append({
                                    'path': file_result['FileID'],
                                    'name': get_attachment_name(attachment.name) + ".eml"
                                })

                            else:
                                incident['attachment'].append({
                                    'name': get_attachment_name(attachment.name) + ".eml"
                                })

                        labels.append({'type': label_attachment_type, 'value': get_attachment_name(attachment.name)})
                        labels.append({'type': label_attachment_id_type, 'value': attachment.attachment_id.id})

            # handle headers
            if item.headers:
                headers = []
                for header in item.headers:
                    labels.append({'type': f'Email/Header/{header.name}', 'value': str(header.value)})
                    headers.append(f"{header.name}: {header.value}")
                labels.append({'type': 'Email/headers', 'value': "\r\n".join(headers)})

            # handle item id
            if item.message_id:
                labels.append({'type': 'Email/MessageId', 'value': str(item.message_id)})
                # fetch history
                incident['dbotMirrorId'] = str(item.message_id)

            if item.id:
                labels.append({'type': 'Email/ID', 'value': item.id})
                labels.append({'type': 'Email/itemId', 'value': item.id})

            # handle conversion id
            if item.conversation_id:
                labels.append({'type': 'Email/ConversionID', 'value': item.conversation_id.id})

            if MARK_AS_READ and is_fetch:
                item.is_read = True
                try:
                    item.save()
                except ErrorIrresolvableConflict:
                    time.sleep(0.5)
                    item.save()
                except ValueError as e:
                    if item.subject and len(item.subject) > 255:
                        demisto.debug("Length of message subject is greater than 255, item.save could not handle it, "
                                      "cutting the subject.")
                        sub_subject = "Length of subject greater than 255 characters. " \
                                      "Partial subject: {}".format(item.subject[:180])
                        item.subject = sub_subject
                        item.save()
                    else:
                        raise e

            incident['labels'] = labels
            incident['rawJSON'] = json.dumps(parse_item_as_dict(item, None), ensure_ascii=False)

        except Exception as e:
            if 'Message is not decoded yet' in str(e):
                demisto.debug('EWS v2 - Skipped a protected message')
                return None
            else:
                raise e

        return incident


    def fetch_emails_as_incidents(account_email, folder_name):
        last_run = get_last_run()
        excluded_ids = set(last_run.get(LAST_RUN_IDS, []))

        try:
            account = get_account(account_email)
            last_emails = fetch_last_emails(account, folder_name, last_run.get(LAST_RUN_TIME), last_run.get(LAST_RUN_IDS))

            incidents = []
            incident = {}  # type: Dict[Any, Any]
            current_fetch_ids = set()
            last_incident_run_time = None

            for item in last_emails:
                if item.message_id:
                    current_fetch_ids.add(item.message_id)
                    incident = parse_incident_from_item(item, True)
                    demisto.debug(f'Parsed incident: {item.message_id}')
                    if incident:
                        incidents.append(incident)
                        last_incident_run_time = item.datetime_received
                        demisto.debug(f'Appended incident: {item.message_id}')

                    if len(incidents) >= MAX_FETCH:
                        break

            demisto.debug(f'EWS V2 - ending fetch - got {len(incidents)} incidents.')
            last_fetch_time = last_run.get(LAST_RUN_TIME)
            last_incident_run_time = last_incident_run_time if last_incident_run_time else last_fetch_time

            # making sure both last fetch time and the time of last incident are the same type for comparing.
            if isinstance(last_incident_run_time, EWSDateTime):
                last_incident_run_time = last_incident_run_time.ewsformat()

            if isinstance(last_fetch_time, EWSDateTime):
                last_fetch_time = last_fetch_time.ewsformat()

            debug_msg = '#### last_incident_time: {}({}). last_fetch_time: {}({}) ####'
            demisto.debug(debug_msg.format(last_incident_run_time, type(last_incident_run_time),
                                           last_fetch_time, type(last_fetch_time)))

            # If the fetch query is not fully fetched (we didn't have any time progress) - then we keep the
            # id's from current fetch until progress is made. This is for when max_fetch < incidents_from_query.
            if not last_incident_run_time or not last_fetch_time or last_incident_run_time > last_fetch_time:
                ids = current_fetch_ids
            else:
                ids = current_fetch_ids | excluded_ids
            new_last_run = {
                LAST_RUN_TIME: last_incident_run_time,
                LAST_RUN_FOLDER: folder_name,
                LAST_RUN_IDS: list(ids),
                ERROR_COUNTER: 0,
            }

            demisto.setLastRun(new_last_run)
            return incidents

        except RateLimitError:
            if LAST_RUN_TIME in last_run:
                last_run[LAST_RUN_TIME] = last_run[LAST_RUN_TIME].ewsformat()
            if ERROR_COUNTER not in last_run:
                last_run[ERROR_COUNTER] = 0
            last_run[ERROR_COUNTER] += 1
            demisto.setLastRun(last_run)
            if last_run[ERROR_COUNTER] > 2:
                raise
            return []


    def get_entry_for_file_attachment(item_id, attachment):  # pragma: no cover
        entry = fileResult(get_attachment_name(attachment.name), attachment.content)
        ec = {
            CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_FILE_ATTACHMENT: parse_attachment_as_dict(item_id,
                                                                                                              attachment)
        }
        entry[ENTRY_CONTEXT] = filter_dict_null(ec)
        return entry


    def parse_attachment_as_dict(item_id, attachment):  # pragma: no cover
        try:
            # if this is a file attachment or a non-empty email attachment
            if isinstance(attachment, FileAttachment) or hasattr(attachment, 'item'):
                attachment_content = attachment.content if isinstance(attachment, FileAttachment) \
                    else attachment.item.mime_content

                return {
                    ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                    ATTACHMENT_ID: attachment.attachment_id.id,
                    'attachmentName': get_attachment_name(attachment.name),
                    'attachmentSHA256': hashlib.sha256(attachment_content).hexdigest() if attachment_content else None,
                    'attachmentContentType': attachment.content_type,
                    'attachmentContentId': attachment.content_id,
                    'attachmentContentLocation': attachment.content_location,
                    'attachmentSize': attachment.size,
                    'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                    'attachmentIsInline': attachment.is_inline,
                    ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment)
                    else ITEM_ATTACHMENT_TYPE
                }

            # If this is an empty email attachment
            else:
                return {
                    ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                    ATTACHMENT_ID: attachment.attachment_id.id,
                    'attachmentName': get_attachment_name(attachment.name),
                    'attachmentSize': attachment.size,
                    'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                    'attachmentIsInline': attachment.is_inline,
                    ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment)
                    else ITEM_ATTACHMENT_TYPE
                }

        except TypeError as e:
            if str(e) != "must be string or buffer, not None":
                raise
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                'attachmentName': get_attachment_name(attachment.name),
                'attachmentSHA256': None,
                'attachmentContentType': attachment.content_type,
                'attachmentContentId': attachment.content_id,
                'attachmentContentLocation': attachment.content_location,
                'attachmentSize': attachment.size,
                'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                'attachmentIsInline': attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE
            }


    def get_entry_for_item_attachment(item_id, attachment, target_email):  # pragma: no cover
        item = attachment.item
        dict_result = parse_attachment_as_dict(item_id, attachment)
        dict_result.update(parse_item_as_dict(item, target_email, camel_case=True, compact_fields=True))
        title = f'EWS get attachment got item for "{target_email}", "{get_attachment_name(attachment.name)}"'

        return get_entry_for_object(title, CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                                    dict_result)


    def get_attachments_for_item(item_id, account, attachment_ids=None):  # pragma: no cover
        item = get_item_from_mailbox(account, item_id)
        attachments = []
        if attachment_ids and not isinstance(attachment_ids, list):
            attachment_ids = attachment_ids.split(",")
        if item:
            if item.attachments:
                for attachment in item.attachments:
                    if attachment is not None:
                        attachment.parent_item = item
                        if attachment_ids and attachment.attachment_id.id not in attachment_ids:
                            continue
                        attachments.append(attachment)

        else:
            raise Exception('Message item not found: ' + item_id)

        if attachment_ids and len(attachments) < len(attachment_ids):
            raise Exception('Some attachment id did not found for message:' + str(attachment_ids))

        return attachments


    def delete_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        deleted_file_attachments = []
        deleted_item_attachments = []  # type: ignore
        for attachment in attachments:
            attachment_deleted_action = {
                ATTACHMENT_ID: attachment.attachment_id.id,
                ACTION: 'deleted'
            }
            if isinstance(attachment, FileAttachment):
                deleted_file_attachments.append(attachment_deleted_action)
            else:
                deleted_item_attachments.append(attachment_deleted_action)
            attachment.detach()

        entries = []
        if len(deleted_file_attachments) > 0:
            entry = get_entry_for_object("Deleted file attachments",
                                         "EWS.Items" + CONTEXT_UPDATE_FILE_ATTACHMENT,
                                         deleted_file_attachments)
            entries.append(entry)
        if len(deleted_item_attachments) > 0:
            entry = get_entry_for_object("Deleted item attachments",
                                         "EWS.Items" + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                                         deleted_item_attachments)
            entries.append(entry)

        return entries


    def fetch_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        entries = []
        for attachment in attachments:
            if isinstance(attachment, FileAttachment):
                try:
                    if attachment.content:
                        entries.append(get_entry_for_file_attachment(item_id, attachment))
                except TypeError as e:
                    if str(e) != "must be string or buffer, not None":
                        raise
            else:
                entries.append(get_entry_for_item_attachment(item_id, attachment, account.primary_smtp_address))
                if attachment.item.mime_content:
                    entries.append(fileResult(get_attachment_name(attachment.name) + ".eml", attachment.item.mime_content))

        return entries


    def move_item_between_mailboxes(item_id, destination_mailbox, destination_folder_path, source_mailbox=None,
                                    is_public=None):  # pragma: no cover
        source_account = get_account(source_mailbox or ACCOUNT_EMAIL)
        destination_account = get_account(destination_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(destination_folder_path, is_public)
        destination_folder = get_folder_by_path(destination_account, destination_folder_path, is_public)
        item = get_item_from_mailbox(source_account, item_id)

        exported_items = source_account.export([item])
        destination_account.upload([(destination_folder, exported_items[0])])
        source_account.bulk_delete([item])

        move_result = {
            MOVED_TO_MAILBOX: destination_mailbox,
            MOVED_TO_FOLDER: destination_folder_path,
        }

        return {
            'Type': entryTypes['note'],
            'Contents': "Item was moved successfully.",
            'ContentsFormat': formats['text'],
            ENTRY_CONTEXT: {
                f"EWS.Items(val.itemId === '{item_id}')": move_result
            }
        }


    def move_item(item_id, target_folder_path, target_mailbox=None, is_public=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(target_folder_path, is_public)
        target_folder = get_folder_by_path(account, target_folder_path, is_public)
        item = get_item_from_mailbox(account, item_id)
        if isinstance(item, ErrorInvalidIdMalformed):
            raise Exception("Item not found")
        item.move(target_folder)
        move_result = {
            NEW_ITEM_ID: item.id,
            ITEM_ID: item_id,
            MESSAGE_ID: item.message_id,
            ACTION: 'moved'
        }

        return get_entry_for_object('Moved items',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    move_result)


    def delete_items(item_ids, delete_type, target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        deleted_items = []
        if type(item_ids) != list:
            item_ids = item_ids.split(",")
        items = get_items_from_mailbox(account, item_ids)
        delete_type = delete_type.lower()

        for item in items:
            item_id = item.id
            if delete_type == 'trash':
                item.move_to_trash()
            elif delete_type == 'soft':
                item.soft_delete()
            elif delete_type == 'hard':
                item.delete()
            else:
                raise Exception('invalid delete type: %s. Use "trash" \\ "soft" \\ "hard"' % delete_type)
            deleted_items.append({
                ITEM_ID: item_id,
                MESSAGE_ID: item.message_id,
                ACTION: '%s-deleted' % delete_type
            })

        return get_entry_for_object('Deleted items (%s delete type)' % delete_type,
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    deleted_items)


    def prepare_args(d):  # pragma: no cover
        d = {k.replace("-", "_"): v for k, v in list(d.items())}
        if 'is_public' in d:
            d['is_public'] = d['is_public'] == 'True'
        return d


    def get_limited_number_of_messages_from_qs(qs, limit):  # pragma: no cover
        count = 0
        results = []
        for item in qs:
            if count == limit:
                break
            if isinstance(item, Message):
                count += 1
                results.append(item)
        return results


    def search_items_in_mailbox(query=None, message_id=None, folder_path='', limit=100, target_mailbox=None,
                                is_public=None, selected_fields='all', surround_id_with_angle_brackets=True):  # pragma: no cover
        if not query and not message_id:
            return_error("Missing required argument. Provide query or message-id")

        if argToBoolean(surround_id_with_angle_brackets) and message_id and message_id[0] != '<' and message_id[-1] != '>':
            message_id = f'<{message_id}>'

        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        limit = int(limit)
        if folder_path.lower() == 'inbox':
            folders = [account.inbox]
        elif folder_path:
            is_public = is_default_folder(folder_path, is_public)
            folders = [get_folder_by_path(account, folder_path, is_public)]
        else:
            folders = account.inbox.parent.walk()  # pylint: disable=E1101

        items = []  # type: ignore
        selected_all_fields = (selected_fields == 'all')

        if selected_all_fields:
            restricted_fields = {x.name for x in Message.FIELDS}  # type: ignore
        else:
            restricted_fields = set(argToList(selected_fields))  # type: ignore
            restricted_fields.update(['id', 'message_id'])  # type: ignore

        for folder in folders:
            if Message not in folder.supported_item_models:
                continue
            if query:
                items_qs = folder.filter(query).only(*restricted_fields)
            else:
                items_qs = folder.filter(message_id=message_id).only(*restricted_fields)
            items += get_limited_number_of_messages_from_qs(items_qs, limit)
            if len(items) >= limit:
                break

        items = items[:limit]
        searched_items_result = [parse_item_as_dict(item, account.primary_smtp_address, camel_case=True,
                                                    compact_fields=selected_all_fields) for item in items]

        if not selected_all_fields:
            # we show id as 'itemId' for BC
            restricted_fields.remove('id')
            restricted_fields.add('itemId')
            searched_items_result = [
                {k: v for (k, v) in i.items()
                 if k in keys_to_camel_case(restricted_fields)} for i in searched_items_result]

        return get_entry_for_object('Searched items',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    searched_items_result,
                                    headers=ITEMS_RESULTS_HEADERS if selected_all_fields else None)


    def get_out_of_office_state(target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        oof = account.oof_settings
        oof_dict = {
            'state': oof.state,  # pylint: disable=E1101
            'externalAudience': getattr(oof, 'external_audience', None),
            'start': oof.start.ewsformat() if oof.start else None,  # pylint: disable=E1101
            'end': oof.end.ewsformat() if oof.end else None,  # pylint: disable=E1101
            'internalReply': getattr(oof, 'internal_replay', None),
            'externalReply': getattr(oof, 'external_replay', None),
            MAILBOX: account.primary_smtp_address
        }
        return get_entry_for_object("Out of office state for %s" % account.primary_smtp_address,
                                    f'Account.Email(val.Address == obj.{MAILBOX}).OutOfOffice',
                                    oof_dict)


    def recover_soft_delete_item(message_ids, target_folder_path="Inbox", target_mailbox=None, is_public=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(target_folder_path, is_public)
        target_folder = get_folder_by_path(account, target_folder_path, is_public)
        recovered_messages = []
        if type(message_ids) != list:
            message_ids = message_ids.split(",")
        items_to_recover = account.recoverable_items_deletions.filter(  # pylint: disable=E1101
            message_id__in=message_ids).all()  # pylint: disable=E1101
        if items_to_recover.count() != len(message_ids):
            raise Exception("Some message ids are missing in recoverable items directory")
        for item in items_to_recover:
            item.move(target_folder)
            recovered_messages.append({
                ITEM_ID: item.id,
                MESSAGE_ID: item.message_id,
                ACTION: 'recovered'
            })
        return get_entry_for_object("Recovered messages",
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    recovered_messages)


    def parse_physical_address(address):
        result = {}
        for attr in ['city', 'country', 'label', 'state', 'street', 'zipcode']:
            result[attr] = getattr(address, attr, None)
        return result


    def parse_phone_number(phone_number):
        result = {
            attr: getattr(phone_number, attr, None)
            for attr in ['label', 'phone_number']
        }
        return result if result.get('phone_number') else {}


    def is_jsonable(x):
        try:
            json.dumps(x)
            return True
        except Exception:
            return False


    def parse_contact(contact):
        contact_dict = parse_object_as_dict_with_serialized_items(contact)
        for k in contact_dict:
            v = contact_dict[k]
            if isinstance(v, EWSDateTime):
                contact_dict[k] = v.ewsformat()  # pylint: disable=E4702

        contact_dict['id'] = contact.id
        if isinstance(contact, Contact) and contact.physical_addresses:
            contact_dict['physical_addresses'] = list(map(parse_physical_address, contact.physical_addresses))
        if isinstance(contact, Contact) and contact.phone_numbers:
            contact_dict['phone_numbers'] = [elt for elt in map(parse_phone_number, contact.phone_numbers) if elt]
        if isinstance(contact, Contact) and contact.email_addresses and len(contact.email_addresses) > 0:
            contact_dict['emailAddresses'] = [x.email for x in contact.email_addresses]
        contact_dict = keys_to_camel_case(contact_dict)
        contact_dict = {k: v for k, v in contact_dict.items() if (v and is_jsonable(v))}
        return contact_dict


    def get_contacts(limit, target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        contacts = []

        for contact in account.contacts.all()[:int(limit)]:  # pylint: disable=E1101
            contact = parse_contact(contact)
            contact['originMailbox'] = target_mailbox
            contacts.append(contact)
        return get_entry_for_object(f'Email contacts for {target_mailbox or ACCOUNT_EMAIL}',
                                    'Account.Email(val.Address == obj.originMailbox).EwsContacts',
                                    contacts)


    def create_folder(new_folder_name, folder_path, target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        full_path = f"{folder_path}\\{new_folder_name}"
        try:
            if get_folder_by_path(account, full_path):
                return "Folder %s already exists" % full_path
        except Exception:
            pass
        parent_folder = get_folder_by_path(account, folder_path)
        f = Folder(parent=parent_folder, name=new_folder_name)
        f.save()
        get_folder_by_path(account, full_path)
        return "Folder %s created successfully" % full_path


    def find_folders(target_mailbox=None, is_public=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        root = account.root
        if is_public:
            root = account.public_folders_root
        folders = []
        for f in root.walk():  # pylint: disable=E1101
            folder = folder_to_context_entry(f)
            folders.append(folder)
        folders_tree = root.tree()  # pylint: disable=E1101

        return {
            'Type': entryTypes['note'],
            'Contents': folders,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': folders_tree,
            ENTRY_CONTEXT: {
                'EWS.Folders(val.id == obj.id)': folders
            }
        }


    def mark_item_as_junk(item_id, move_items, target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        move_items = (move_items.lower() == "yes")
        ews_result = MarkAsJunk(account=account).call(item_id=item_id, move_item=move_items)
        mark_as_junk_result = {
            ITEM_ID: item_id,
        }
        if ews_result == "Success":
            mark_as_junk_result[ACTION] = 'marked-as-junk'
        else:
            raise Exception("Failed mark-item-as-junk with error: " + ews_result)

        return get_entry_for_object('Mark item as junk',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    mark_as_junk_result)


    def get_items_from_folder(folder_path, limit=100, target_mailbox=None, is_public=None,
                              get_internal_item='no'):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        limit = int(limit)
        get_internal_item = (get_internal_item == 'yes')
        is_public = is_default_folder(folder_path, is_public)
        folder = get_folder_by_path(account, folder_path, is_public)
        qs = folder.filter().order_by('-datetime_created')[:limit]
        items = get_limited_number_of_messages_from_qs(qs, limit)
        items_result = []

        for item in items:
            item_attachment = parse_item_as_dict(item, account.primary_smtp_address, camel_case=True,
                                                 compact_fields=True)

            for attachment in item.attachments:
                if attachment is not None:
                    attachment.parent_item = item
                    if get_internal_item and isinstance(attachment, ItemAttachment) and isinstance(attachment.item,
                                                                                                   Message):
                        # if found item attachment - switch item to the attchment
                        item_attachment = parse_item_as_dict(attachment.item, account.primary_smtp_address, camel_case=True,
                                                             compact_fields=True)
                        break

            items_result.append(item_attachment)
        hm_headers = ['sender', 'subject', 'hasAttachments', 'datetimeReceived',
                      'receivedBy', 'author', 'toRecipients', 'itemId']
        return get_entry_for_object('Items in folder ' + folder_path,
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    items_result,
                                    headers=hm_headers)


    def get_items(item_ids, target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        if type(item_ids) != list:
            item_ids = item_ids.split(",")

        items = get_items_from_mailbox(account, item_ids)
        items = [x for x in items if isinstance(x, Message)]
        items_as_incidents = [parse_incident_from_item(x, False) for x in items]
        items_to_context = [parse_item_as_dict(x, account.primary_smtp_address, True, True) for x in items]

        return {
            'Type': entryTypes['note'],
            'Contents': items_as_incidents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Get items', items_to_context, ITEMS_RESULTS_HEADERS),
            ENTRY_CONTEXT: {
                CONTEXT_UPDATE_EWS_ITEM: items_to_context,
                'Email': [email_ec(item) for item in items],
            }
        }


    def get_folder(folder_path, target_mailbox=None, is_public=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(folder_path, is_public)
        folder = folder_to_context_entry(get_folder_by_path(account, folder_path, is_public))
        return get_entry_for_object(f"Folder {folder_path}", CONTEXT_UPDATE_FOLDER, folder)


    def folder_to_context_entry(f):  # pragma: no cover
        f_entry = {
            'name': f.name,
            'totalCount': f.total_count,
            'id': f.id,
            'childrenFolderCount': f.child_folder_count,
            'changeKey': f.changekey
        }

        if 'unread_count' in [x.name for x in Folder.FIELDS]:
            f_entry['unreadCount'] = f.unread_count
        return f_entry


    def check_cs_prereqs():  # pragma: no cover
        if 'outlook.office365.com' not in EWS_SERVER:
            raise Exception("This command is only supported for Office 365")


    def get_cs_error(stderr):  # pragma: no cover
        return {
            "Type": entryTypes["error"],
            "ContentsFormat": formats["text"],
            "Contents": stderr
        } if stderr else None


    def get_cs_status(search_name, status):  # pragma: no cover
        return {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': f'Search {search_name} status: {status}',
            'EntryContext': {
                'EWS.ComplianceSearch(val.Name === obj.Name)': {'Name': search_name, 'Status': status}
            }
        }


    def start_compliance_search(query):  # pragma: no cover
        check_cs_prereqs()
        try:
            with open("startcompliancesearch2.ps1", "w+") as f:
                f.write(START_COMPLIANCE)

            output = subprocess.Popen(["pwsh", "startcompliancesearch2.ps1", USERNAME, query],
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf8')

            stdout, stderr = output.communicate(input=PASSWORD)

        finally:
            os.remove("startcompliancesearch2.ps1")

        if stderr:
            return get_cs_error(stderr)

        prefix = '"Action status: '
        pref_ind = stdout.find(prefix)
        sub_start = pref_ind + len(prefix)
        sub_end = sub_start + 45
        search_name = stdout[sub_start:sub_end]

        return {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': f'Search started: {search_name!r}',
            'EntryContext': {
                'EWS.ComplianceSearch': {'Name': search_name, 'Status': 'Starting'}
            }
        }


    def get_compliance_search(search_name, show_only_recipients):  # pragma: no cover
        check_cs_prereqs()
        try:
            with open("getcompliancesearch2.ps1", "w+") as f:
                f.write(GET_COMPLIANCE)

            output = subprocess.Popen(["pwsh", "getcompliancesearch2.ps1", USERNAME, search_name],
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf8')
            stdout, stderr = output.communicate(input=PASSWORD)

        finally:
            os.remove("getcompliancesearch2.ps1")

        if stderr:
            return get_cs_error(stderr)

        # Get search status
        stdout = stdout[len(PASSWORD):]
        stdout = stdout.split('\n', 1)  # type: ignore

        results = [get_cs_status(search_name, stdout[0])]

        # Parse search results from script output if the search has completed. Output to warroom as table.
        if stdout[0] == 'Completed':
            if stdout[1] and stdout[1] != '{}':
                res = [r[:-1].split(', ') if r[-1] == ',' else r.split(', ') for r in stdout[1][2:-3].split(r'\r\n')]
                res = [dict(s.split(': ') for s in x) for x in res]
                entry = {
                    'Type': entryTypes['note'],
                    'ContentsFormat': formats['text'],
                    'Contents': stdout,
                    'ReadableContentsFormat': formats['markdown'],
                }
                if show_only_recipients == 'True':
                    res = [x for x in res if int(x['Item count']) > 0]

                    entry['EntryContext'] = {
                        'EWS.ComplianceSearch(val.Name == obj.Name)': {
                            'Name': search_name,
                            'Results': res
                        }
                    }

                entry['HumanReadable'] = tableToMarkdown('Office 365 Compliance search results', res,
                                                         ['Location', 'Item count', 'Total size'])
            else:
                entry = {
                    'Type': entryTypes['note'],
                    'ContentsFormat': formats['text'],
                    'Contents': stdout,
                    'ReadableContentsFormat': formats['markdown'],
                    'HumanReadable': "The compliance search didn't return any results."
                }

            results.append(entry)
        return results


    def purge_compliance_search(search_name):  # pragma: no cover
        check_cs_prereqs()
        try:
            with open("purgecompliancesearch2.ps1", "w+") as f:
                f.write(PURGE_COMPLIANCE)

            output = subprocess.Popen(["pwsh", "purgecompliancesearch2.ps1", USERNAME, search_name],
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf8')
            _, stderr = output.communicate(input=PASSWORD)

        finally:
            os.remove("purgecompliancesearch2.ps1")

        if stderr:
            return get_cs_error(stderr)

        return get_cs_status(search_name, 'Purging')


    def check_purge_compliance_search(search_name):  # pragma: no cover
        check_cs_prereqs()
        try:
            with open("purgestatuscompliancesearch2.ps1", "w+") as f:
                f.write(PURGE_STATUS_COMPLIANCE)

            output = subprocess.Popen(["pwsh", "purgestatuscompliancesearch2.ps1", USERNAME, search_name],
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf8')
            stdout, stderr = output.communicate(input=PASSWORD)

            stdout = stdout[len(PASSWORD):]

        finally:
            os.remove("purgestatuscompliancesearch2.ps1")

        if stderr:
            return get_cs_error(stderr)

        return get_cs_status(search_name, 'Purged' if stdout.split('\n')[-2] == 'Completed' else 'Purging')


    def remove_compliance_search(search_name):  # pragma: no cover
        check_cs_prereqs()
        try:
            with open("removecompliance2.ps1", "w+") as f:
                f.write(REMOVE_COMPLIANCE)

            output = subprocess.Popen(
                ["pwsh", "removecompliance2.ps1", USERNAME, search_name],
                stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf8')
            stdout, stderr = output.communicate(input=PASSWORD)

        finally:
            os.remove("removecompliance2.ps1")

        if stderr:
            return get_cs_error(stderr)

        return get_cs_status(search_name, 'Removed')


    def get_autodiscovery_config():  # pragma: no cover
        config_dict = demisto.getIntegrationContext()
        return {
            'Type': entryTypes['note'],
            'Contents': config_dict,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Auto-Discovery Exchange Configuration', config_dict)
        }


    def format_identifier(identifier):
        """
        Exchangelib has a default smtp routing type. If there's no given routingtype, add explicitly so that
        exchangelib can be searched by secondary email addresses without making cusomter add it manually
        """
        return f'smtp:{identifier}' if '@' in identifier and ':' not in identifier else identifier


    def resolve_name_command(args, protocol):  # pragma: no cover
        unresolved_entry = format_identifier(args['identifier'])
        full_contact_data = argToBoolean(args.get('full_contact_data', True))
        resolved_names = protocol.resolve_names([unresolved_entry], return_full_contact_data=full_contact_data, search_scope='')
        demisto.debug(f'{len(resolved_names)=}')

        output = []
        for rn in resolved_names:
            if isinstance(rn, ErrorNameResolutionNoResults):
                demisto.info(f'got ErrorNameResolutionNoResults error, {str(rn)}')
                return 'No results were found.'
            elif isinstance(rn, tuple):
                mail, contact = rn
            else:
                mail, contact = rn, None
            mail_context = parse_item_as_dict(mail)
            if contact:
                mail_context['FullContactInfo'] = parse_contact(contact)
            output.append(mail_context)
        return get_entry_for_object('Resolved Names',
                                    'EWS.ResolvedNames(val.email_address && val.email_address == obj.email_address)',
                                    remove_empty_elements(output),  # noqa: F405
                                    headers=['primary_email_address', 'name', 'mailbox_type', 'routing_type'],
                                    hr_header_changes={'email_address': 'primary_email_address'})


    def mark_item_as_read(item_ids, operation='read', target_mailbox=None):  # pragma: no cover
        marked_items = []
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        item_ids = argToList(item_ids)
        items = get_items_from_mailbox(account, item_ids)
        items = [x for x in items if isinstance(x, Message)]

        for item in items:
            item.is_read = (operation == 'read')
            item.save()

            marked_items.append({
                ITEM_ID: item.id,
                MESSAGE_ID: item.message_id,
                ACTION: f'marked-as-{operation}'
            })

        return get_entry_for_object(f'Marked items ({operation} marked operation)',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    marked_items)


    def get_item_as_eml(item_id, target_mailbox=None):  # pragma: no cover
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        item = get_item_from_mailbox(account, item_id)

        if item.mime_content:
            mime_content = item.mime_content
            email_policy = SMTP if mime_content.isascii() else SMTPUTF8
            # came across an item with bytes attachemnt which failed in the source code, added this to keep functionality
            if isinstance(mime_content, bytes):
                email_content = email.message_from_bytes(mime_content, policy=email_policy)
            else:
                email_content = email.message_from_string(mime_content, policy=email_policy)
            if item.headers:
                attached_email_headers = []
                for h, v in list(email_content.items()):
                    if not isinstance(v, str):
                        try:
                            v = str(v)
                        except:  # noqa: E722
                            demisto.debug(f'cannot parse the header "{h}"')

                    v = ' '.join(map(str.strip, v.split('\r\n')))
                    attached_email_headers.append((h.lower(), v))
                for header in item.headers:
                    if (header.name.lower(), header.value) not in attached_email_headers and header.name.lower() != 'content-type':
                        try:
                            email_content.add_header(header.name, header.value)
                        except ValueError as err:
                            if "There may be at most" not in str(err):
                                raise err

            eml_name = item.subject if item.subject else 'demisto_untitled_eml'
            file_result = fileResult(eml_name + ".eml", email_content.as_string())
            file_result = file_result if file_result else "Failed uploading eml file to war room"

            return file_result
        return None


    def collect_manual_attachments(manual_attach_obj):  # pragma: no cover
        attachments = []
        for attachment in manual_attach_obj:
            res = demisto.getFilePath(os.path.basename(attachment['RealFileName']))

            file_path = res["path"]
            with open(file_path, 'rb') as f:
                attachments.append(FileAttachment(content=f.read(), name=attachment['FileName']))

        return attachments


    def process_attachments(attach_cids="", attach_ids="", attach_names="", manual_attach_obj=None):  # pragma: no cover
        if manual_attach_obj is None:
            manual_attach_obj = []
        file_entries_for_attachments = []  # type: list
        attachments_names = []  # type: list

        if attach_ids:
            file_entries_for_attachments = attach_ids if isinstance(attach_ids, list) else attach_ids.split(",")
            if attach_names:
                attachments_names = attach_names if isinstance(attach_names, list) else attach_names.split(",")
            else:
                for att_id in file_entries_for_attachments:
                    att_name = demisto.getFilePath(att_id)['name']
                    if isinstance(att_name, list):
                        att_name = att_name[0]
                    attachments_names.append(att_name)
            if len(file_entries_for_attachments) != len(attachments_names):
                raise Exception("attachIDs and attachNames lists should be the same length")

        attachments = collect_manual_attachments(manual_attach_obj)

        if attach_cids:
            file_entries_for_attachments_inline = attach_cids if isinstance(attach_cids, list) else attach_cids.split(",")
            for att_id_inline in file_entries_for_attachments_inline:
                try:
                    file_info = demisto.getFilePath(att_id_inline)
                except Exception as ex:
                    demisto.info(f"EWS error from getFilePath: {ex}")
                    raise Exception("entry %s does not contain a file" % att_id_inline)
                att_name_inline = file_info["name"]
                with open(file_info["path"], 'rb') as f:
                    attachments.append(FileAttachment(content=f.read(), name=att_name_inline, is_inline=True,
                                                      content_id=att_name_inline))

        for i in range(0, len(file_entries_for_attachments)):
            entry_id = file_entries_for_attachments[i]
            attachment_name = attachments_names[i]
            try:
                res = demisto.getFilePath(entry_id)
            except Exception as ex:
                raise Exception(f"entry {entry_id} does not contain a file: {str(ex)}")
            file_path = res["path"]
            with open(file_path, 'rb') as f:
                attachments.append(FileAttachment(content=f.read(), name=attachment_name))
        return attachments, attachments_names


    def get_none_empty_addresses(addresses_ls):
        return [adress for adress in addresses_ls if adress]


    def send_email(args):
        time_zone = get_time_zone()
        account = get_account(account_email=ACCOUNT_EMAIL, time_zone=time_zone)
        bcc = get_none_empty_addresses(argToList(args.get('bcc')))
        cc = get_none_empty_addresses(argToList(args.get('cc')))
        to = get_none_empty_addresses(argToList(args.get('to')))
        replyTo = get_none_empty_addresses(argToList(args.get('replyTo')))
        render_body = argToBoolean(args.get('renderBody') or False)
        subject = args.get('subject')
        subject = subject[:252] + '...' if len(subject) > 255 else subject

        attachments, attachments_names = process_attachments(args.get('attachCIDs', ''), args.get('attachIDs', ''),
                                                             args.get('attachNames', ''), args.get('manualAttachObj') or [])

        body_type = args.get('bodyType', args.get('body_type'))
        send_email_to_mailbox(
            account=account, to=to, subject=subject, body=args.get('body'), body_type=body_type, bcc=bcc, cc=cc, reply_to=replyTo,
            html_body=args.get('htmlBody'), attachments=attachments, raw_message=args.get('raw_message'),
            from_address=args.get('from')
        )
        result_object = {
            'from': args.get('from') or account.primary_smtp_address,
            'to': to,
            'subject': subject,
            'attachments': attachments_names
        }

        results = [{
            'Type': entryTypes['note'],
            'Contents': result_object,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sent email', result_object),
        }]
        if render_body:
            results.append({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['html'],
                'Contents': args.get('htmlBody')
            })

        return results


    def reply_email(args):  # pragma: no cover
        time_zone = get_time_zone()
        account = get_account(account_email=ACCOUNT_EMAIL, time_zone=time_zone)
        bcc = args.get('bcc').split(",") if args.get('bcc') else None
        cc = args.get('cc').split(",") if args.get('cc') else None
        to = args.get('to').split(",") if args.get('to') else None
        subject = args.get('subject')
        subject = subject[:252] + '...' if subject and len(subject) > 255 else subject

        attachments, attachments_names = process_attachments(args.get('attachCIDs', ''), args.get('attachIDs', ''),
                                                             args.get('attachNames', ''), args.get('manualAttachObj') or [])

        send_email_reply_to_mailbox(account, args.get('inReplyTo'), to, args.get('body'), subject, bcc, cc, args.get('htmlBody'),
                                    attachments, args.get('from'))
        result_object = {
            'from': args.get('from') or account.primary_smtp_address,
            'to': to,
            'subject': subject,
            'attachments': attachments_names
        }

        return {
            'Type': entryTypes['note'],
            'Contents': result_object,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sent email', result_object),
        }


    def test_module():  # pragma: no cover
        try:
            global IS_TEST_MODULE
            IS_TEST_MODULE = True
            account = get_account(ACCOUNT_EMAIL)
            folder = get_folder_by_path(account, FOLDER_NAME, IS_PUBLIC_FOLDER)
            if not folder.effective_rights.read:  # pylint: disable=E1101
                raise Exception("Success to authenticate, but user has no permissions to read from the mailbox. "
                                "Need to delegate the user permissions to the mailbox - "
                                "please read integration documentation and follow the instructions")
            folder.test_access()
        except ErrorFolderNotFound as e:
            if "Top of Information Store" in str(e):
                raise Exception(
                    "Success to authenticate, but user probably has no permissions to read from the specific folder."
                    "Check user permissions. You can try !ews-find-folders command to "
                    "get all the folders structure that the user has permissions to")

        demisto.results('ok')


    def get_protocol():  # pragma: no cover
        if AUTO_DISCOVERY:
            protocol = get_account_autodiscover(ACCOUNT_EMAIL).protocol
        else:
            protocol = Protocol(config=config)  # type: ignore
        return protocol


    def encode_and_submit_results(obj):  # pragma: no cover
        demisto.results(obj)


    def sub_main():  # pragma: no cover
        global EWS_SERVER, USERNAME, ACCOUNT_EMAIL, PASSWORD
        global config, credentials
        EWS_SERVER = demisto.params()['ewsServer']
        USERNAME = demisto.params()['credentials']['identifier']
        ACCOUNT_EMAIL = demisto.params()['defaultTargetMailbox']
        PASSWORD = demisto.params()['credentials']['password']
        config, credentials = prepare()
        args = prepare_args(demisto.args())

        fix_2010()
        try:
            protocol = get_protocol()
            if demisto.command() == 'test-module':
                test_module()
            elif demisto.command() == 'fetch-incidents':
                incidents = fetch_emails_as_incidents(ACCOUNT_EMAIL, FOLDER_NAME)
                demisto.incidents(incidents)
            elif demisto.command() == 'ews-get-attachment':
                encode_and_submit_results(fetch_attachments_for_message(**args))
            elif demisto.command() == 'ews-delete-attachment':
                encode_and_submit_results(delete_attachments_for_message(**args))
            elif demisto.command() == 'ews-get-searchable-mailboxes':
                encode_and_submit_results(get_searchable_mailboxes(protocol))
            elif demisto.command() == 'ews-search-mailboxes':
                encode_and_submit_results(search_mailboxes(protocol, **args))
            elif demisto.command() == 'ews-move-item-between-mailboxes':
                encode_and_submit_results(move_item_between_mailboxes(**args))
            elif demisto.command() == 'ews-move-item':
                encode_and_submit_results(move_item(**args))
            elif demisto.command() == 'ews-delete-items':
                encode_and_submit_results(delete_items(**args))
            elif demisto.command() == 'ews-search-mailbox':
                encode_and_submit_results(search_items_in_mailbox(**args))
            elif demisto.command() == 'ews-get-contacts':
                encode_and_submit_results(get_contacts(**args))
            elif demisto.command() == 'ews-get-out-of-office':
                encode_and_submit_results(get_out_of_office_state(**args))
            elif demisto.command() == 'ews-recover-messages':
                encode_and_submit_results(recover_soft_delete_item(**args))
            elif demisto.command() == 'ews-create-folder':
                encode_and_submit_results(create_folder(**args))
            elif demisto.command() == 'ews-mark-item-as-junk':
                encode_and_submit_results(mark_item_as_junk(**args))
            elif demisto.command() == 'ews-find-folders':
                encode_and_submit_results(find_folders(**args))
            elif demisto.command() == 'ews-get-items-from-folder':
                encode_and_submit_results(get_items_from_folder(**args))
            elif demisto.command() == 'ews-get-items':
                encode_and_submit_results(get_items(**args))
            elif demisto.command() == 'ews-get-folder':
                encode_and_submit_results(get_folder(**args))
            elif demisto.command() == 'ews-o365-start-compliance-search':
                encode_and_submit_results(start_compliance_search(**args))
            elif demisto.command() == 'ews-o365-get-compliance-search':
                encode_and_submit_results(get_compliance_search(**args))
            elif demisto.command() == 'ews-o365-purge-compliance-search-results':
                encode_and_submit_results(purge_compliance_search(**args))
            elif demisto.command() == 'ews-o365-get-compliance-search-purge-status':
                encode_and_submit_results(check_purge_compliance_search(**args))
            elif demisto.command() == 'ews-o365-remove-compliance-search':
                encode_and_submit_results(remove_compliance_search(**args))
            elif demisto.command() == 'ews-get-autodiscovery-config':
                encode_and_submit_results(get_autodiscovery_config())
            elif demisto.command() == 'ews-expand-group':
                encode_and_submit_results(get_expanded_group(protocol, **args))
            elif demisto.command() == 'ews-mark-items-as-read':
                encode_and_submit_results(mark_item_as_read(**args))
            elif demisto.command() == 'ews-resolve-name':
                encode_and_submit_results(resolve_name_command(args, protocol))
            elif demisto.command() == 'ews-get-items-as-eml':
                encode_and_submit_results(get_item_as_eml(**args))
            elif demisto.command() == 'send-mail':
                encode_and_submit_results(send_email(args))
            elif demisto.command() == 'reply-mail':
                encode_and_submit_results(reply_email(args))
            else:
                return_error(f'Command: "{demisto.command()}" was not recognized by this integration')

        except Exception as e:
            import time

            time.sleep(2)
            start_logging()
            debug_log = log_stream.getvalue()  # type: ignore
            error_message_simple = ""
            error_message = ""

            # Office365 regular maintenance case
            if (isinstance(e, ErrorMailboxMoveInProgress | ErrorMailboxStoreUnavailable)) and 'outlook.office365.com' in EWS_SERVER:
                log_message = "Office365 is undergoing load balancing operations. " \
                              "As a result, the service is temporarily unavailable."
                if demisto.command() == 'fetch-incidents':
                    demisto.info(log_message)
                    demisto.incidents([])
                    sys.exit(0)
                if IS_TEST_MODULE:
                    demisto.results(log_message + " Please retry the instance configuration test.")
                    sys.exit(0)
                error_message_simple = log_message + " Please retry your request."

            if isinstance(e, ConnectionError):
                error_message_simple = "Could not connect to the server.\n" \
                                       "Verify that the Hostname or IP address is correct.\n\n" \
                                       "Additional information: {}".format(str(e))
            if isinstance(e, ErrorInvalidPropertyRequest):
                error_message_simple = "Verify that the Exchange version is correct."
            else:
                from exchangelib.errors import MalformedResponseError

                if IS_TEST_MODULE and isinstance(e, MalformedResponseError):
                    error_message_simple = "Got invalid response from the server.\n" \
                                           "Verify that the Hostname or IP address is is correct."

            # Legacy error handling
            if "Status code: 401" in debug_log:
                error_message_simple = "Got unauthorized from the server. " \
                                       "Check credentials are correct and authentication method are supported. "

                error_message_simple += "You can try using 'domain\\username' as username for authentication. " \
                    if AUTH_METHOD_STR.lower() == 'ntlm' else ''

            if "SSL: CERTIFICATE_VERIFY_FAILED" in debug_log:
                # same status code (503) but different error.
                error_message_simple = "Certificate verification failed - This error may happen if the server " \
                                       "certificate cannot be validated or as a result of a proxy that is doing SSL/TLS " \
                                       "termination. It is possible to bypass certificate validation by checking " \
                                       "'Trust any certificate' in the instance settings."

            elif "Status code: 503" in debug_log:
                error_message_simple = "Got timeout from the server. " \
                                       "Probably the server is not reachable with the current settings. " \
                                       "Check proxy parameter. If you are using server URL - change to server IP address. "

            if not error_message_simple:
                error_message = error_message_simple = str(e)
            else:
                error_message = error_message_simple + "\n" + str(e)

            stacktrace = traceback.format_exc()
            if stacktrace:
                error_message += "\nFull stacktrace:\n" + stacktrace

            if debug_log:
                error_message += "\nFull debug log:\n" + debug_log

            if demisto.command() == 'fetch-incidents':
                raise Exception(str(e) + traceback.format_exc())
            if demisto.command() == 'ews-search-mailbox' and isinstance(e, ValueError):
                return_error(message="Selected invalid field, please specify valid field name.", error=e)
            if IS_TEST_MODULE:
                demisto.results(error_message_simple)
            else:
                demisto.results(
                    {"Type": entryTypes["error"], "ContentsFormat": formats["text"], "Contents": error_message_simple})
            demisto.error(f"{e.__class__.__name__}: {error_message}")
        finally:
            exchangelib_cleanup()
            if log_stream:
                try:
                    logging.getLogger().removeHandler(log_handler)  # type: ignore
                    log_stream.close()
                except Exception as ex:
                    demisto.error(f"EWS: unexpected exception when trying to remove log handler: {ex}")


    def process_main():  # pragma: no cover
        """setup stdin to fd=0 so we can read from the server"""
        sys.stdin = os.fdopen(0, "r")
        sub_main()


    def main():  # pragma: no cover
        try:
            handle_proxy()
            # When running big queries, like 'ews-search-mailbox' the memory might not freed by the garbage
            # collector. `separate_process` flag will run the integration on a separate process that will prevent
            # memory leakage.
            separate_process = demisto.params().get("separate_process", False)
            demisto.debug(f"Running as separate_process: {separate_process}")
            if separate_process:
                try:
                    p = Process(target=process_main)
                    p.start()
                    p.join()
                except Exception as ex:
                    demisto.error(f"Failed starting Process: {ex}")
            else:
                sub_main()
        except Exception as exc:
            return_error(f"Found error in EWSv2: {exc}",
                         error=f'Error: {exc}\nTraceback: {traceback.format_exc()}')


    # python2 uses __builtin__ python3 uses builtins

    if __name__ in ("__builtin__", "builtins", "__main__"):  # pragma: no cover
        main()

    register_module_line('EWS v2 FIX3', 'end', __line__())
  subtype: python3
  type: python
tests:
- pyEWS_Test
- EWS V2 Send Mail Test
- EWS V2 Send Mail Test 2
- EWS Public Folders Test
defaultmapperin: EWS v2-mapper
defaultclassifier: EWS v2
fromversion: 5.0.0
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADIVJREFUeAHtXHt0FNUZv/fOYzebJ3k1CQ8THiaBBLAEiuIRAu2hoqinSrR6xIqeoq1gRast2rr8UThYPT5QKigeDvScUkCl1lePWiggL4MYFWMMLxMgaTYk2WR3Z+dx7+13JxGBJmQ3BJgN+U4mMztzHzPf737f/b7vfjMYXQLEEcJos1ea21SWUdUSzg1o+PKcZNeiIQr62Uu3jfy0L7NA7ksPZwM5BUmPPeSLqzrRMPh4IDysNmiMzOB0tL6djKC8ZRjjPJViBVWeCKH7ipNpX3r+zp4lZgEGMAniXJr28s7MFtM1tMGkBUMYv0K3+KhARVUuZySLEqJSJEExghADLDmDDWoiHbkUAj/6PjkeYFsqvUiae3lVylet5sCmkJ7fRq3R2RYr1hbvHGoYbBDF4RQmKYhxDEACbgz2Akza5wW02xHqKICFVK6tqI/72z5fVnMofHlDiBRkWdaoMLVGWQdP5FFK0ylRJQpTajuIUEMIpACV6t0+7KVYwDEAZyz5+Pl0JuVbbx8YYZhYqFdPu3oVYIKKtdUrHFPjUsSpx8/sGIBPGMp8G0RbvYJYUgseSmz9dC4ccAzAyOpXsecCZFd1Qff1U1/mgHMk+CJyGSYEmNzB7eoFElZCLzTTa030AwysnLyi/OffhMhcFu65AUdgjGAiaWNUa/1n/vdXY6/XEX52HwIYZEfIYfu/dqs7Qjlo0HFug4avQYbwuXpKoi5HfpNMn5o1swUh7xs9bak368UQwICerNr4EQzH4DYRsQNrW+wwYjpIURh+BCBaxUyGIbAVIWAYGrN96W6sdtyFFrf7ae8rbCKUlpSyGkDqBzjykYqRR0XNOfFog85oYxxRmjjiTUR1t0im0ZzgSWpNdfMADVttlw0YEPq2pWn81nrrA93sBrCOG4jjKKQS1GxJ0gDWWfQLgJUFtpw3wQA6Y9TACYaSKIcAt7gEYDMuJ0b+bOe3ZGxIMCEoXiGHqhZMeACkFWTk7PST5XtMGABnL3TK1fEu9Gp6Bt54pF564ts26X7LFF101AdwVRlrYzKUB5BO35FMelrDASiZlOC6fo/PXGWZHfaVCMo4hGIDYGAWhdUDWPLjqNTbLessiiMT3Y6WVs4tCcFhiM9C8/LG7/LVIemPZof0KyC6eUl83u77x7/WVcelK8r3d6G8u6pywc7HDMBncsTr9ZKjRTcXyUx1n3mtJqgV86ZuBf1ktVXbfYl+PZyEpg0+fnjDxEVjn9+buL8FP4RBegtT2Cv75l+5GjQHWry1OkOicS5RkWqavnDGCJ/dCOhke+/Af469se54lTrhjoSVn/ve9VtkIFhapxSHORHmQdOKXE2+9kXNvZUh6cmnl2xf+eLU3KUN/67N58SFBrv0TxYWJy2Axjm4UvOf2dn0OKXMDf4QSnPxCl6+YhoumRv5SDrlLi/UYcwCHAoQ3GoyosFsa8ewz4FjPoO7WkJWssyk387/T81Mn44KXFhvGJul3jWrdFSwdOW++Xsa9Gd1g4rRY4dEMOcp59DlBavq1KkjIgaAW3SawRNRpU4KSQAb/CHLstDxAC8gkoRyEvnCN2ePq5wM4O4W4OoWFBFaQXTJERauVQxQzEpwWGkVmLgRLPTDemI7q2kHAOfAe0xklC7TD6sXXLVmwrJdd++pDz1jmCKT4IyxxL+fd1VFMTF3pqaOWYCTTE0fkqxuqg/hzKBuIsqYlJWgZPtNKzWg4yFiHo6eMHJJNDxjROLDE5fvufWLRrbCsCDnxw6sfN8egUGV5eZfo7fr7Mm/uiU01U5CiL7D814jZgFeUHaVBiy/FzgkDNx27r87T82vuqMsRPEaakYeV6aMSzanJRllx7F/VjUG8z73sVcNisBL4m2AsGZgNZNbIKXgkw+KY7tfmzl8Dhrh5WNe2DXnqya+CLJNzjtYPekgpudgoTdhs1ME7OMZy3S/haPmdKab1Kki7gkg1Qf5tPJ66+865eAOcZQaLx+bOyZj+tB4ssyjyiYCFd4YZtnz3jv446v/su/2b/x8BWgPiKF+L+E9AeJ81YlpgDtjCqMsqiCHaGNb6sE1RSn4adWlIM3iqTpFLtuggrm8McgLNh3wP7t8Suofpg2Mn5Kqsu0aUoZ82Wy9vrc+tAYsa/lcrfjOnqO3zsWsivau369WmujGD462tRimruclxKHBKW50rNUobhER/yjocVdh+p4hrz9ZYFznO8KUpeYp6p2BZV0bIlNmf/Tfd2bnqdf9YbQ89fZtaFFNK3/U4BhUu7ON6ZgFGCmG56MD2gpYnhuAwaCt8luoujUImpKBpo2O6Zvr9DlDtRsmX53tfkTmAfJ1q7SYU/B5Yb71SJyGTZM06OqkVdXGO1/V6DdVPVL6+I9e3Lujus1c4ddJDqLRDagoxt45F41ZFe02k7hBuQZAQE47Ax+WIgPix0YUEazvuNdiIFajSdPXVzXt+DZoXI+gLQxLkyky33/zsJQ5qkJMbupiuWnSNt21acYLW9P3PDDu7Ruz5GlZHrxTlHUqxSzAvc5QSMeFxaDEkEUmcVnBCTKtunek/NNtxwMFBpJsBLlloDYAeWeb/OaUlzZnrb675Os7c6VrM1T6vvCfnUgxC7AIdBDMPUgBY1dIkAh4EJgSIU58MqsjWo4L3xl83niJVhV76Iwqf2JSncYeZPbyYXtjNshUmXSo1f0KX79eWlpW4i9KUv+ktDta0fZ43ss7c9hF8NgjTTU0PJktqWzS0xNceHDAYImShDMYJymMsR+AnZUctesCUpiisNpJGcrNb6X8+ejwmoe36EzynGlIcZhzgwrPQ0ObxWiiTBHpIM50k2IW4LKyUSKS8ZQYC7DoDk4sbLNm4S1PrVdu+evOe3RZflFIW0Qk4BHgqqz2mgz3DZt+ecX+0c+VP1ar8StVrGscQt7gAMed6g5BcOSkv82pCHU5k2JLRfu8nYqJHeQQAY8NG2hpHg6fCJhtsBwQMcddYIZnqbz+6kzP9QDuZzNe/fSaA23WkyLhqyQr7jeFae5b4t2K3wV6WIUEAFWWkCdG3k6MIQnG0sejfR7unaUh7xYRverSF5JkFtUy08RsZXVynLJ26cxRNfetqcjceDS4SqdSnEeix2/KSXjjkZn5jbPXVU5o0klKyIQwh6IgjxFuQyVzow6qRDzqeqlgbAAM7/b6NVJ47YbqClVZ7CNL0LFsjGrcRD6a4SE+i9PaAYpSn+NJavzduGEtEzZuJ1oUDHq5bOwxURwWKNx5T+9e3WxKw8VLbmEk5yz5vHHdnWsqbl9zW+E3Zzb5nY4gWMzBzqTYABh4BzlZStAkeUGM89qtZUg0h/NHdYYwDAAMKwES0VrfONLQoBCcEDaMiM0eYQ2vHDAuYeyyT547HibX8o73pBik5LZgddpH9eF/3bq6/JZ1d42r6QzG6as+TT+LQumsygU7FzMA2xwR67xiFhZv6wOJw5OWDsIK5EKnAeppYBXBLnKhmuwf/ouKw/4nQpqVe+aqkDDU6oPy2LeOmDtSF+9s/H8gCSRbsgwT8gFOku2qnfx1UQ9iC+CzsgrgFn6sQB2oY9f+o5v/9SGW2WaS3C6/CADrFzommbrOM9v97FMbFH0CuN8lGQiDmrK2U0tczOM+BHDP2QivNUBlcCgikbyuEglEXdhUt4p8geCven43vVuzH2Dg52XxUpOGpIMUXn7pKREYIEGLN+bFm//Yer+2DjsE4n6AAdEP7/nhqjpUtzYbZUej2U8bC3V1CGevLDXwwi0WfvC0Sxf1Rz/AwH6M7TchHO/T9mSk9Fwn9aS3/joXnAOOkWAMq0K2/XLaB8t6rDEvOCOd2qFjAIZVnF+7JFwEHzMrChg8lzL4lBKWFWp/0A6APg14p7LTefflGIBP/H7icoARI/jW5KJHqz2fHDeHHNNCw5tCKD9IaTFHpChM8SDOWJoFr+LaAQ57lQ6OmJD0fmnvbHg5BmBxcyJcgLbAx7G2jGiFn192bAI6jMrL5bsPpaXVBAJDj7Vp+ZCdM7rVRPmagYZZBA2E96/jYRBASBNqnZT2yKNZUKtPkqMA7orDNvAlJSKzrb5j2yHKApZk0ebD6vbDjTmBsJTfEDALwpwXBy1WCEDnQfgwnRFZYvYHSQFskVF7iUl7TAAswOyMAHiGSvPCcO1Qx/aeLe3w8dKFoyuTdzXQQbUBbYRu0TGgEgogEaOQUTzYQiRJUmBB11Khib5NMQ1wZ9DY0u4V30AsPAHXxVYB20Yh7WCmS2Vr92YfaFVzMzx8wqB4ubmzNvrSuf8BON13AZrf558AAAAASUVORK5CYII=
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/ews-v2-fix3)'
