commonfields:
  id: PingOne
  version: -1
name: PingOne
display: PingOne
category: Identity and Access Management
description: 'Integrates with the PingOne Management API to unlock, create, delete
  and update users.  '
detaileddescription: |
  PingOne
  -
    To obtain your PingOne API token, see the PingOne documentation.
    https://apidocs.pingidentity.com/pingone/devguide/v1/api/#getting-started-with-the-pingone-apis
configuration:
- display: Your PingOne Environment ID
  name: environment_id
  type: 0
  required: true
  additionalinfo: Environment ID is available under the PingOne Dashboard->Environment
    Properties
- display: PingOne Region
  name: region
  defaultvalue: US
  type: 15
  required: true
  options:
  - US
  - EU
  - Asia
  additionalinfo: PingOne has 3 regions, US, EU and Asia
- display: Client ID
  displaypassword: Client Secret
  name: credentials
  type: 9
  required: true
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
script:
  script: |
    #from CommonServerPython import *  # noqa: F401

    # IMPORTS
    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    PROFILE_ARGS = [
        'formatted',
        'given',
        'middle',
        'family',
        'nickname',
        'title',
        'locale',
        'email',
        'primaryPhone',
        'mobilePhone',
        'streetAddress',
        'locality',
        'region',
        'postalCode',
        'countryCode',
        'type'
    ]


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def __init__(self, base_url, verify, proxy, auth_params):
            super().__init__(base_url=base_url, verify=verify, proxy=proxy)

            self.client_id = auth_params.get('client_id')
            self.client_secret = auth_params.get('client_secret')
            self.auth_url = auth_params.get('auth_url')
            self._headers = self._request_token()

        def _request_token(self):
            """
            Handles the actual request made to retrieve the access token.
            :return: Access token to be used in the authorization header for each request.
            """
            params = {
                'grant_type': 'client_credentials',
                'client_id': self.client_id,
                'client_secret': self.client_secret
            }

            response = self._http_request(
                method='POST',
                headers={'Content-Type': 'application/x-www-form-urlencoded'},
                full_url=self.auth_url,
                data=params
            )
            access_token = response.get('access_token')
            auth_header = {'Authorization': f'Bearer {access_token}'}
            return auth_header

        # Getting Group Id with a given group name
        def get_group_id(self, group_name):
            uri = 'groups'
            query_params = {
                'filter': encode_string_results(f'name eq "{group_name}"')
            }
            res = self._http_request(
                method="GET",
                url_suffix=uri,
                params=query_params
            )

            if '_embedded' in res and len(res.get('_embedded', {}).get('groups')) == 1:
                return res.get('_embedded', {}).get('groups')[0].get('id')
            raise Exception(f'Failed to find groupID for: {group_name} group name.')

        # Return User Id from username
        def get_user_id(self, username):
            uri = 'users'
            query_params = {
                'filter': encode_string_results(f'username eq "{username}"')
            }
            res = self._http_request(
                method='GET',
                url_suffix=uri,
                params=query_params

            )

            if '_embedded' in res and len(res.get('_embedded', {}).get('users')) == 1:
                return res.get('_embedded', {}).get('users')[0].get('id')
            raise Exception(f'Failed to find userID for: {username} username.')

        # Return user from username
        def get_user_by_username(self, username):
            uri = 'users'
            query_params = {
                'filter': encode_string_results(f'username eq "{username}"')
            }
            res = self._http_request(
                method='GET',
                url_suffix=uri,
                params=query_params

            )

            if '_embedded' in res and len(res.get('_embedded', {}).get('users')) == 1:
                return res.get('_embedded', {}).get('users')[0]
            raise Exception(f'Failed to find user for {username} username.')

        # Return user from id
        def get_user_by_id(self, user_id):
            uri = f'users/{user_id}'

            res = self._http_request(
                method='GET',
                url_suffix=uri,
            )

            if res.get('code') == 'NOT_FOUND':
                raise Exception(f'Failed to find user for {user_id}')

            return res

        def unlock_user(self, user_id):
            """
            sending a POST request to unlock a specific user
            """
            uri = f'users/{user_id}'

            new_headers = self._headers
            new_headers['Content-Type'] = 'application/vnd.pingidentity.account.unlock+json'

            return self._http_request(
                method='POST',
                url_suffix=uri,
                headers=new_headers
            )

        def deactivate_user(self, user_id):
            uri = f'users/{user_id}/enabled'

            body = {
                "enabled": False
            }

            return self._http_request(
                method="PUT",
                url_suffix=uri,
                json_data=body
            )

        def activate_user(self, user_id):
            uri = f'users/{user_id}/enabled'

            body = {
                "enabled": True
            }

            return self._http_request(
                method="PUT",
                url_suffix=uri,
                json_data=body
            )

        def set_password(self, user_id, password):
            uri = f'users/{user_id}/password'

            body = {
                "newPassword": password
            }

            new_headers = self._headers
            new_headers['Content-Type'] = 'application/vnd.pingidentity.password.reset+json'

            return self._http_request(
                method="PUT",
                url_suffix=uri,
                headers=new_headers,
                json_data=body
            )

        def add_user_to_group(self, user_id, group_id):
            uri = f'users/{user_id}/memberOfGroups'

            body = {
                "id": group_id
            }

            return self._http_request(
                method="POST",
                url_suffix=uri,
                json_data=body
            )

        def remove_user_from_group(self, user_id, group_id):
            uri = f'users/{user_id}/memberOfGroups/{group_id}'
            self._http_request(
                method="DELETE",
                url_suffix=uri,
                return_empty_response=True,
                ok_codes=(204, 404)  # PingOne returns 404 if the group has already removed which results in a XSOAR error
            )

        def get_groups_for_user(self, user_id):
            uri = f'users/{user_id}/memberOfGroups?expand=group&filter=type eq "DIRECT"'

            query_params = {
                'expand': 'group',
                'filter': 'username eq "DIRECT"'
            }

            return self._http_request(
                method="GET",
                url_suffix=uri,
                params=query_params
            )

        @staticmethod
        def build_user_profile(args):
            profile = {}
            keys = args.keys()
            for key in PROFILE_ARGS:
                if key in keys:
                    if key in ['formatted', 'given', 'middle', 'family']:
                        if 'name' not in profile:
                            profile['name'] = {}
                        profile['name'][key] = args[key]

                    elif key in ['streetAddress', 'locality', 'region', 'postalCode', 'countryCode']:
                        if 'address' not in profile:
                            profile['address'] = {}
                        profile['address'][key] = args[key]

                    else:
                        profile[key] = args[key]
            return profile

        @staticmethod
        def get_readable_group_membership(raw_groups):
            groups = []
            raw_groups = raw_groups.get('_embedded', {}).get('groupMemberships', [])

            for group in raw_groups:

                if group.get('_embedded', {}).get('group', {}).get('type') == 'DIRECT':
                    grp = {
                        'ID': group.get('_embedded', {}).get('group', {}).get('id'),
                        'Name': group.get('_embedded', {}).get('group', {}).get('name')
                    }
                    groups.append(grp)

            return groups

        @staticmethod
        def get_user_context(raw_user):
            user = {
                'ID': raw_user.get('id'),
                'Username': raw_user.get('username'),
                'DisplayName':
                    raw_user.get('name', {}).get('formatted'),
                'Email': raw_user.get('email'),
                'Enabled': raw_user.get('enabled'),
                'CreatedAt': raw_user.get('createdAt'),
                'UpdatedAt': raw_user.get('updatedAt')
            }
            return user

        @staticmethod
        def get_readable_user(raw_user):
            user_attrs = {
                'ID': raw_user.get('id'),
                'Username': raw_user.get('username'),
                'Email': raw_user.get('email'),
                'First Name': raw_user.get('name', {}).get('given'),
                'Last Name': raw_user.get('name', {}).get('family'),
                'Enabled': raw_user.get('enabled'),
                'Environment': raw_user.get('environment', {}).get('id'),
                'PopulationID': raw_user.get('population', {}).get('id'),
                'AccountStatus': raw_user.get('account', {}).get('status'),
                'CreatedAt': raw_user.get('createdAt'),
                'UpdatedAt': raw_user.get('updatedAt')
            }
            return user_attrs

        def get_user(self, user_id):
            uri = f'users/{user_id}'
            return self._http_request(
                method='GET',
                url_suffix=uri
            )

        def create_user(self, username, pop_id):
            uri = 'users'

            body = {
                "population": {
                    "id": f'{pop_id}'
                },
                "username": f'{username}'
            }

            res = self._http_request(
                method='POST',
                url_suffix=uri,
                json_data=body
            )

            return res

        def update_user(self, user_id, attrs):
            uri = f"users/{user_id}"
            return self._http_request(
                method='PATCH',
                url_suffix=uri,
                json_data=attrs
            )

        def delete_user(self, user_id):
            uri = f"users/{user_id}"
            return self._http_request(
                method="DELETE",
                url_suffix=uri,
                return_empty_response=True,
                ok_codes=(204, 404)  # PingOne returns 404 if the group has already removed which results in a XSOAR error
            )


    def test_module(client, _args):
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        Args:
            client: HelloWorld client

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        uri = '/'
        client._http_request(method='GET', url_suffix=uri)
        return 'ok', None, None


    def unlock_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.unlock_user(user_id)

        readable_output = f"### {args.get('username')} unlocked"

        return (
            readable_output,
            {},
            raw_response  # raw response - the original response
        )


    def activate_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.activate_user(user_id)

        readable_output = f"### {args.get('username')} is active now"
        return (
            readable_output,
            {},
            raw_response
        )


    def deactivate_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.deactivate_user(user_id)

        readable_output = f"### User {args.get('username')} deactivated"

        return (
            readable_output,
            {},
            raw_response  # raw response - the original response
        )


    def set_password_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        password = args.get('password')

        raw_response = client.set_password(user_id, password)
        readable_output = f"{args.get('username')} password was updated."
        return (
            readable_output,
            {},
            raw_response
        )


    def add_user_to_group_command(client, args):
        group_id = args.get('groupId')
        user_id = args.get('userId')

        if (not (args.get('username') or user_id)) or (not (args.get('groupName') or group_id)):
            raise Exception("You must supply either 'Username' or 'userId")
        if not user_id:
            user_id = client.get_user_id(args.get('username'))
        if not group_id:
            group_id = client.get_group_id(args.get('groupName'))

        raw_response = client.add_user_to_group(user_id, group_id)
        readable_output = f"User: {user_id} added to group: {args.get('groupName')} successfully"
        return (
            readable_output,
            {},
            raw_response
        )


    def remove_from_group_command(client, args):
        group_id = args.get('groupId')
        user_id = args.get('userId')

        if (not (args.get('username') or user_id)) or (not (args.get('groupName') or group_id)):
            raise Exception("You must supply either 'Username' or 'userId' and either 'groupName' or 'groupId'")
        if not user_id:
            user_id = client.get_user_id(args.get('username'))
        if not group_id:
            group_id = client.get_group_id(args.get('groupName'))

        client.remove_user_from_group(user_id, group_id)

        readable_output = f"User: {user_id} was removed from group: {args.get('groupName')} successfully"
        return (
            readable_output,
            {},
            '')


    def get_groups_for_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.get_groups_for_user(user_id)
        groups = client.get_readable_group_membership(raw_response)

        context = createContext(groups, removeNull=True)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': {
                'Group': context,
                'ID': args.get('username'),
                'Type': 'PingOne'
            }
        }
        readable_output = f"PingOne groups for user: {args.get('username')}\n {tableToMarkdown('Groups', groups)}"

        return (
            readable_output,
            outputs,
            raw_response
        )


    def get_user_command(client, args):

        if args.get('userId'):
            user_term = args.get('userId')
            raw_response = client.get_user_by_id(args.get('userId'))
        elif args.get('username'):
            user_term = args.get('username')
            raw_response = client.get_user_by_username(args.get('username'))
        else:
            raise Exception("You must supply either 'Username' or 'userId")

        user_context = client.get_user_context(raw_response)
        user_readable = client.get_readable_user(raw_response)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': createContext([user_context])
        }
        readable_output = f"{tableToMarkdown(f'User:{user_term}', [user_readable])} "
        return (
            readable_output,
            outputs,
            raw_response
        )


    def create_user_command(client, args):
        username = args.get('username')
        pop_id = args.get('populationId')
        raw_response = client.create_user(username, pop_id)
        user_context = client.get_user_context(raw_response)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': createContext(user_context)
        }
        readable_output = tableToMarkdown(f"PingOne user created: {args.get('username')}",
                                          client.get_readable_user(raw_response))

        return (
            readable_output,
            outputs,
            raw_response
        )


    def update_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        attrs = Client.build_user_profile(args)

        raw_response = client.update_user(user_id, attrs)
        readable_output = tableToMarkdown(f"PingOne user updated: {args.get('username')}", attrs)

        return (
            readable_output,
            {},
            raw_response
        )


    def delete_user_command(client, args):
        if not (args.get('username') or args.get('userId')):
            raise Exception("You must supply either 'Username' or 'userId")

        if args.get('username'):
            user = client.get_user_by_username(args.get('username'))
            user_id = user.get('id')
        else:
            user_id = args.get('userId')

        client.delete_user(user_id)
        readable_output = f"User: {user_id} was Deleted successfully"
        return (
            readable_output,
            {},
            '')


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # get the service API url
        environment_id = demisto.params().get('environment_id')
        region = demisto.params().get('region')
        tld = '.com'

        if region == 'EU':
            tld = '.eu'
        elif region == 'ASIA':
            tld = '.asia'

        base_url = urljoin(f'https://api.pingone{tld}', f'/v1/environments/{environment_id}/')
        auth_url = urljoin(f'https://auth.pingone{tld}', f'/{environment_id}/as/token')

        client_id = demisto.params().get('credentials', {}).get('identifier')
        client_secret = demisto.params().get('credentials', {}).get('password')

        verify_certificate = not demisto.params().get('insecure', False)
        proxy = demisto.params().get('proxy', False)

        auth_params = {
            'client_id': client_id,
            'client_secret': client_secret,
            'base_url': base_url,
            'auth_url': auth_url,
        }

        LOG(f'Command being called is {demisto.command()}')

        commands = {
            'test-module': test_module,
            'pingone-unlock-user': unlock_user_command,
            'pingone-deactivate-user': deactivate_user_command,
            'pingone-activate-user': activate_user_command,
            'pingone-set-password': set_password_command,
            'pingone-add-to-group': add_user_to_group_command,
            'pingone-remove-from-group': remove_from_group_command,
            'pingone-get-groups': get_groups_for_user_command,
            'pingone-get-user': get_user_command,
            'pingone-create-user': create_user_command,
            'pingone-update-user': update_user_command,
            'pingone-delete-user': delete_user_command,
        }

        command = demisto.command()

        client = Client(
            auth_params=auth_params,
            base_url=base_url,
            verify=verify_certificate,
            proxy=proxy
        )

        try:
            if command in commands:
                human_readable, outputs, raw_response = commands[command](client, demisto.args())
                return_outputs(readable_output=human_readable, outputs=outputs, raw_response=raw_response)

        # Log exceptions
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  commands:
  - name: pingone-unlock-user
    arguments:
    - name: username
      required: true
      default: true
      description: Username to unlock
    description: Unlock an user's account
  - name: pingone-deactivate-user
    arguments:
    - name: username
      required: true
      default: true
      description: 'Username to deactivate '
    description: Deactivate an user's account
  - name: pingone-activate-user
    arguments:
    - name: username
      required: true
      default: true
      description: 'Username to activate '
    description: Activate an user's account
  - name: pingone-set-password
    arguments:
    - name: username
      required: true
      default: true
      description: Username
    - name: password
      required: true
      description: Password
    description: Sets an user's password
  - name: pingone-add-to-group
    arguments:
    - name: username
      description: 'Username '
    - name: groupName
      description: Group Name
    - name: groupId
      description: Group ID
    - name: userId
      description: User ID
    description: Add user to group
  - name: pingone-remove-from-group
    arguments:
    - name: username
      description: Username
    - name: groupName
      description: Group Name
    - name: userId
      description: User ID
    - name: groupId
      description: Group ID
    description: Remove user from group
  - name: pingone-get-groups
    arguments:
    - name: username
      description: Username
    outputs:
    - contextPath: Account.Group
      description: PingOne groups of the user
    - contextPath: Account.ID
      description: PingOne account ID
      type: string
    - contextPath: Account.Type
      description: PingOne account type
      type: string
    - contextPath: Account.Group.ID
      description: Unique ID for the group
      type: string
    - contextPath: Account.Group.Name
      description: Name of the group
    description: Returns user's group memberships
  - name: pingone-get-user
    arguments:
    - name: username
      description: Username
    - name: userId
      description: User ID
    - name: detailed
      description: PingOne User Details
    outputs:
    - contextPath: Account.ID
      description: PingOne account ID
      type: string
    - contextPath: Account.Username
      description: PingOne account username
      type: string
    - contextPath: Account.DisplayName
      description: PingOne account display name
      type: string
    - contextPath: Account.Email
      description: PingOne account email
      type: string
    - contextPath: Account.Enabled
      description: PingOne account enabled status
      type: boolean
    - contextPath: Account.CreatedAt
      description: PingOne account create date
      type: date
    - contextPath: Account.UpdatedAt
      description: PingOne account updated date
      type: date
    description: Returns a PingOne user
  - name: pingone-create-user
    arguments:
    - name: username
      required: true
      description: Username
    - name: populationId
      description: PingOne population ID where the new user will be created
    outputs:
    - contextPath: Account.ID
      description: PingOne account ID
      type: string
    - contextPath: Account.Username
      description: PingOne account username
      type: string
    - contextPath: Account.DisplayName
      description: PingOne account display name
      type: string
    - contextPath: Account.Email
      description: PingOne account email
      type: string
    - contextPath: Account.Enabled
      description: PingOne account enabled status
      type: boolean
    - contextPath: Account.CreatedAt
      description: PingOne account create date
      type: date
    - contextPath: Account.UpdatedAt
      description: PingOne account updated date
      type: date
    description: 'Create a PingOne user '
  - name: pingone-update-user
    arguments:
    - name: username
      required: true
      description: Username
    - name: formatted
      description: Formatted PingOne name
    - name: given
      description: Given name
    - name: middle
      description: Middle name
    - name: family
      description: Family name
    - name: nickname
      description: Nickname
    - name: title
      description: Title
    - name: locale
      description: Locale
    - name: email
      description: Email
    - name: primaryPhone
      description: Primary phone number
    - name: mobilePhone
      description: Mobile phone number
    - name: streetAddress
      description: Street address
    - name: locality
      description: Locality
    - name: region
      description: Region
    - name: postalCode
      description: Zip code
    - name: countryCode
      description: Country code
    - name: Type
      description: Account type
    description: Update a PingOne user
  - name: pingone-delete-user
    arguments:
    - name: username
      description: Username
    - name: userId
      description: User ID
    description: Delete a PingOne user
  dockerimage: demisto/python3:3.9.6.24067
  runonce: false
  subtype: python3
fromversion: 6.0.0
tests:
- PingOnePlaybook_Test
