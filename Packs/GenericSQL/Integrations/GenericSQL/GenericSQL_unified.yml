category: Database
commonfields:
  id: Generic SQL
  version: -1
configuration:
- defaultvalue: MySQL
  display: SQL DB
  hidden: false
  name: dialect
  options:
  - MySQL
  - PostgreSQL
  - Microsoft SQL Server
  - Oracle
  required: true
  type: 15
- display: Database host
  name: host
  required: true
  type: 0
- display: Port
  hidden: false
  name: port (if empty - use default)
  required: false
  type: 0
- display: Database Name
  hidden: false
  name: dbname
  required: false
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: 'Connection Arguments (ex: arg1=val1&arg2=val2)'
  hidden: false
  name: connectParameters
  required: false
  type: 0
description: Generic SQL for the Databases MYSQL, PostgreSQL,Microsoft SQL Server,
  Oracle
detaileddescription: "## Generic SQL\nSupport the databases - mysql, PostgreSQL, Microsoft\
  \ SQL and Oracle.\n\n### Default ports\nIn case the port value is empty a default\
  \ port wiil be chosen according to the database type:\nMySQL - port 3306\nPostgreSQL\
  \ - port 5432\nMicrosoft SQL Server - port 1433\nOracle - port 1521\n\n\n### Connection\
  \ Arguments\nWhen choosing the configuration of an instance, e.g:\ncharset=utf8\n\
  \n\n##Bind Variables \nThere are 2 options to use bind variables:\n1. Use both bind\
  \ variables names and values, e.g.:\n    SELECT * from Table Where ID=:x\" bind_variables_names=x\
  \ bind_variables_values=123\n2. Use only bind variables values, e.g.:\n    INSERT\
  \ into Table(ID, Name) VALUES (%s, %s)\" bind_variables_values= \"123, Benâ€"
display: Generic SQL
name: Generic SQL
script:
  commands:
  - arguments:
    - default: false
      defaultValue: '50'
      description: Number of results you would like to get back
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      isArray: false
      name: query
      required: true
      secret: false
    - default: false
      defaultValue: '0'
      description: Number of results you would like to skip on
      isArray: false
      name: skip
      required: false
      secret: false
    - default: false
      description: 'e.g: "foo","bar","alpha"'
      isArray: true
      name: bind_variables_names
      required: false
      secret: false
    - default: false
      description: 'e.g: 7,"foo",3'
      isArray: true
      name: bind_variables_values
      required: false
      secret: false
    deprecated: false
    execution: false
    name: query
  - arguments:
    - default: false
      isArray: false
      name: query
      required: true
      secret: false
    - default: false
      defaultValue: '50'
      description: Number of results you would like to get back
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      defaultValue: '0'
      description: Number of results you would like to skip on
      isArray: false
      name: skip
      required: false
      secret: false
    - default: false
      description: 'e.g: "foo","bar","alpha"'
      isArray: true
      name: bind_variables_names
      required: false
      secret: false
    - default: false
      description: 'e.g: 7,"foo",3'
      isArray: true
      name: bind_variables_values
      required: false
      secret: false
    deprecated: false
    execution: false
    name: sql-command
  dockerimage: devdemisto/genericsql:1.0.0.6104
  feed: false
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: |-
    from typing import Dict, Callable, Tuple, Any, List





    ''' IMPORTS '''
    import sqlalchemy
    import pymysql
    import psycopg2
    #import pyodbc
    from sqlalchemy.sql import text

    # explain why?
    pymysql.install_as_MySQLdb()


    class Client:
        """
        Client to use in the SQL databases integration. Overrides BaseClient
        makes the connection to the DB server
        """
        def __init__(self, dialect: str, host: str, username: str, password: str, port: str,
                     database: str, connect_parameters: str):
            self.dialect = dialect
            self.host = host
            self.username = username
            self.password = password
            self.port = port
            self.dbname = database
            self.connect_parameters = connect_parameters
            self.connection = self._create_engine_and_connect()

        @staticmethod
        def _convert_dialect_to_module(dialect: str) -> str:
            """
            Converting a dialect to the correct string needed in order to connect the wanted dialect
            :param dialect: the SQL db
            :return: a key string needed for the connection
            """
            if dialect == "MySQL":
                module = "mysql"
            elif dialect == "PostgreSQL":
                module = "postgresql"
            elif dialect == "Oracle":
                module = "oracle"
            elif dialect == "Microsoft SQL Server":
                module = "mssql"
            else:
                module = str(dialect)
            return module

        def _create_engine_and_connect(self):
            """
            Creating and engine according to the instance preferences and connecting
            :return: a connection object that will be used in order to execute SQL queries
            """
            try:
                module = self._convert_dialect_to_module(self.dialect)
                db_preferences = f'{module}://{self.username}:{self.password}@{self.host}:{self.port}/{self.dbname}'
                if self.connect_parameters:
                    db_preferences += f'?{self.connect_parameters}'
                return sqlalchemy.create_engine(db_preferences).connect()
            except Exception as err:
                raise Exception(err)

        def sql_query_execute_request(self, sql_query: str, bind_vars: Any) -> Tuple[Dict, List]:
            """Execute query in DB via engine
            :param bind_vars: in case there are names and values - a bind_var dict, in case there are only values - list
            :param sql_query: the SQL query
            :return: results of query, table headers
            """
            if type(bind_vars) is dict:
                sql_query = text(sql_query)

            result = self.connection.execute(sql_query, bind_vars)
            results = result.fetchall()
            headers = results[0].keys()
            return results, headers


    def generate_default_port_by_dialect(dialect: str) -> str:
        """
        In case no port wash chosen, a default port will be chosen according to the SQL db type
        :param dialect: sql db type
        :return: default port needed for connection
        """
        if dialect == "MySQL":
            return "3306"
        elif dialect == "PostgreSQL":
            return "5432"
        elif dialect == "Oracle":
            return "1521"
        elif dialect == "Microsoft SQL Server":
            return "1433"
        else:
            # set default to mysql
            return "3306"


    def generate_bind_vars(bind_variables_names: str, bind_variables_values: str) -> Any:
        """
        The bind variables can be given in 2 legal ways: as 2 lists - names and values, or only values
        any way defines a different executing way, therefore there are 2 legal return types
        :param bind_variables_names: the names of the bind variables, must be in the length of the values list
        :param bind_variables_values: the values of the bind variables, can be in the length of the names list
                or in case there is no name lists - at any length
        :return: a dict or lists of the bind variables
        """
        bind_variables_names_list = argToList(bind_variables_names)
        bind_variables_values_list = argToList(bind_variables_values)

        if bind_variables_values and not bind_variables_names:
            return [var for var in argToList(bind_variables_values)]
        elif len(bind_variables_names_list) is len(bind_variables_values_list):
            return dict(zip(bind_variables_names_list, bind_variables_values_list))
        else:
            raise Exception("The bind variables lists are not is the same length")


    def test_module(client: Client, *_):
        """
        Performs basic connect to SQL server
        If the connection in the client was successful the test will return OK
        if it wasn't an exception will be raised
        """
        return 'ok', None, None


    def sql_query_execute(client: Client, args: dict, *_) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """
        Executes the sql query with the connection that was configurator in the client
        :param client: the client object with the db connection
        :param args: demisto.args() including the sql query
        :return: Demisto outputs
        """
        try:
            sql_query = args.get('query')
            limit = int(args.get('limit', 50))
            skip = int(args.get('skip', 0))
            bind_variables = generate_bind_vars(args.get('bind_variables_names'), args.get('bind_variables_values'))

            result, headers = client.sql_query_execute_request(sql_query, bind_variables)
            table = [dict(row) for row in result]
            human_readable = tableToMarkdown(name="Query result:", t=table[skip:skip + limit], headers=headers,
                                             removeNull=True)
            context = {
                'Result': table,
                'Query': sql_query,
                'InstanceName': f'{client.dialect}_{client.dbname}'
            }
            entry_context: Dict = {f'GenericSQL(val.Query && val.Query === obj.Query)': {'GenericSQL': context}}
            return human_readable, entry_context, table

        except Exception as err:
            # explain
            if str(err) == "This result object does not return rows. It has been closed automatically.":
                human_readable = "Command executed"
                return human_readable, {}, []
            else:
                return_error(err)


    def main():
        params = demisto.params()
        dialect = params.get('dialect')
        port = params.get('port', generate_default_port_by_dialect(dialect))
        user = params.get("credentials").get("identifier")
        password = params.get("credentials").get("password")
        host = params.get('host')
        database = params.get('dbname')
        connect_parameters = params.get('connectParameters')

        try:
            command = demisto.command()
            LOG(f'Command being called in SQL is: {command}')
            client = Client(dialect=dialect, host=host, username=user, password=password,
                            port=port, database=database, connect_parameters=connect_parameters)
            commands: Dict[str, Callable[[Client, Dict[str, str], str], Tuple[str, Dict[Any, Any], List[Any]]]] = {
                'test-module': test_module,
                'query': sql_query_execute,
                'sql-command': sql_query_execute
            }
            if command in commands:
                return_outputs(*commands[command](client, demisto.args(), command))
            else:
                raise NotImplementedError(f'{command} is not an existing Generic SQL command')
            client.connection.close()
        except Exception as err:
            return_error(err)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAABZBJREFUeAHtmG1oV2UYh89mm5rmWtMFJqakJYtmLwsqkl7ILOhDr6hFkqVRfZgwjfCD0pf6EkFfKiGhJO3lSxlElEEv1uzFVrSV0RYNl5axWnNa023Ormv7H/o3mtt0wVHvG67/c855Xvbsdz/389znJElYKBAKhAKhQCgQCoQCoUAoEAqEAqFAKBAKhAKhQCgQCoQCoUAoEAqEAsegQMEx9P2/uk5n4MuhIscsyjOgGLqgE1rhR9gBH8Nn0ANhGVbgUub2JhweKYWFhTr8MRgHYXkKZCWC72ROG6Fg0qRJh6uqqgogqaioSMrKypLS0tKkuLg46e7uTrq6upL29vakubk5qaurS7Zv3540Njb2/Uv03dHR0VHFjVEehgJZcfDXzKWypqYmWbp0aVJUVDQi5zQ1NSXV1dV9Th8/fvyizs7OV0c0wAnceExG/rdHmcfE1tbW7pKSkjFG7IQJE4acmhFdX1+fbN68OamtrT3c29tb0NPT8w4dvxyy80nSICsRvAe9z8zXvLy8fH9lZWUybdq0IpxdTFQXcNYme/fuTdra2rpbWloONTQ0FLFlD1ykyxlnff5YJ/N11hy8GGcshGugZBiO6aWN2/sWmA23wpEc7GK4Djzzp4DJ2Qfglv4XpDaTi/vATL4QmuAVqIPUFnBxF5gAPAEHIWwQBYxgs+eJuXoXnq9H18MSWAWP5MpqytvAZCp/ETzFvWMsg/8yx3wY/gTbuTgsfb16DtKx5nP9LViXz07uH4LUVnNh/YuQ9k3rohygwEAHD6ge1u1QDvYI+AJ0yjNwAbhQtoHR6gI4HTy/bVMLOvsKMMJ95nv3OaCFg/t1GNbvr7RSwCehbFg9/mmkY3SEHz4cY7AInkndbjgEiyC1/OjzuWPsA7fn1M7i4hewbi24bR8XDj6FiWbBFE6rgRXguboVjLhd4LbaBW6rftWaDDNgXo7hLIp22npeToXHYS68BJ6vqVXmLhoov08fUrowPoFb4FzQwWEjUCDdojfS53fQ4SPhK9qbANlnsAimqu/cdvGkY//G9QaYDpoOt26dNwPM89u6t8FFFhGMCCO1B+hwADz3PCPdJj07PRtNwA6C0dwGbslG2Xvg9ukZfDEcydwRboCbYTH4d5aAW7DZu2NrRf3Fv37H5e66KJ3HcWFZ2aLzxTKrdXuW0baxDOhieBY2wYOwBq6F2bATNCN6EnR4gxXAnL6r/lcrF+FxYVk7S9IoORrxhupr/UpYBH4m03lut2nU6sTX4Q+4Eu4Gn2mXwXzoBtuYqKVmGzHqU9K6KHMK7KH0fDPh8V3zPBiOuW0vgOdB0R1jsDP4XurcXvfDu+D763dgH1+N3KbHgGP1gpHu9TrYCbZ7GcpBWw0++wbeyOM1rqdCJixrW/QsVHk6p4yvTiZOu8Ao0zkKXwpTYAZcCDplOLaRRm6798PV4P/uongf1sJu0Kx3wXlG3wOaydgLsApMAjX7a+fn6Lvhx3HM6n9OH0TZL6jRcAdsAMXxfihMdraBwm/KtV9GOZi5lXq+XgS3w1xwwQy0sTw4G7aAc/gQXEyTwcWlFcOcQfDvZMKyMhEjxmz5NNifU8Z7tzqjIcUEzMhOMVqMbM0segUsh/UwGuZicMu9BPxW3QwuKrPwnyDzlm4zWZxo6sThzs1IG21rYUCTMh2qk2fDPsiybkwve2aSo4NWQtFRTM/35XpwjJuOov8J2yUrW/RCFDZDdT6+pnwEW8EPE7tgYJLlWTgTfJ25CvwoYl/bz4MDEJYxBXTMW+AZZySOhB9ovwZOhbA8BbISwXlT6nuVuZEHZrgzcpi5+ookvtqYZTfm+JTycwgLBUKBUCAUCAVCgVAgFAgFQoFQIBQIBUKBUCAUCAVCgVAgFAgFQoFQIBQYbQX+BjcXfY8k0ur5AAAAAElFTkSuQmCC
