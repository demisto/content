category: Endpoint
commonfields:
  id: ZeroTrustAnalyticsPlatform
  version: -1
configuration:
- defaultvalue: https://portalapi.threatanalytics.io/
  display: ZTAP server URL
  name: url
  required: true
  type: 0
- additionalinfo: The API Key to use for connection
  display: API Key
  name: apikey
  required: true
  type: 4
- additionalinfo: Group to send to when reopening
  defaultvalue: Default
  display: Reopen Group
  name: reopen_group
  required: true
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: Both
  display: Incident Mirroring Direction
  name: mirror_direction
  options:
  - None
  - Incoming
  - Outgoing
  - Both
  required: false
  type: 15
- additionalinfo: Adding this tag to a Note will sync as a comment in ZTAP
  defaultvalue: comment
  display: Comment entry tag
  name: comment_tag
  required: false
  type: 0
- additionalinfo: Adding this tag to a Note will reassign the alert back to Critical
    Start SOC
  defaultvalue: escalate
  display: Escalate entry tag
  name: escalate_tag
  required: false
  type: 0
- defaultvalue: ztap
  display: ZTAP input tag
  name: input_tag
  required: false
  type: 0
- defaultvalue: "false"
  display: Fetch attachments for comments from ZTAP
  name: get_attachments
  required: false
  type: 8
- defaultvalue: "false"
  display: Sync closing incidents with ZTAP
  name: close_incident
  required: false
  type: 8
- defaultvalue: "false"
  display: Sync reopening incidents with ZTAP
  name: reopen_incident
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp
  name: first_fetch
  required: false
  type: 0
- defaultvalue: "100"
  display: Maximum number of incidents to fetch
  name: max_fetch
  required: false
  type: 0
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: eef7186f-fe1c-4365-89a9-075a40d224fb
    packName: testing pack version again
    propagationLabels:
    - all
    toServerVersion: ""
description: Zero Trust Analytics Platform (ZTAP) is the underlying investigation
  platform and user interface for Critical Start's MDR service.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: Critical Start
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [support@criticalstart.com](mailto:support@criticalstart.com)
  - **URL**: [https://support.criticalstart.com/](https://support.criticalstart.com/)
  ***
  ## Critical Start Zero Threat Analytics Platform

  ## Select incident type
  1. Select the default **Incident type** as **ZTAP Alert**

  ### Generate an API Key
  1. In ZTAP go to **User Profile**.
  2. Under Security, select **Create App Token**.
  3. Generate a new App token.
  4. Copy and paste the token.


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/zero-trust-analytics-platform)
display: ZeroTrustAnalyticsPlatform (Partner Contribution)
image: data:image/png;base64,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
name: ZeroTrustAnalyticsPlatform
script:
  commands:
  - arguments: []
    description: Get mapping fields from remote incident.
    name: get-mapping-fields
  - arguments:
    - description: The remote incident id
      name: id
      required: true
    - defaultValue: "0"
      description: UTC timestamp in seconds. The incident is only updated if it was
        modified after the last update time.
      name: lastUpdate
    description: Get remote data from a remote incident. This command should only
      be called manually for debugging purposes.
    name: get-remote-data
  - arguments:
    - description: The remote incident id
      name: id
      required: true
    description: Get the entries data from a remote incident.
    name: ztap-get-alert-entries
  dockerimage: demisto/python3:3.10.9.42476
  isfetch: true
  ismappable: true
  isremotesyncin: true
  isremotesyncout: true
  runonce: false
  script: |
    register_module_line('ZeroTrustAnalyticsPlatform', 'start', __line__())

    ### pack version: 1.1.4




    import traceback
    import re
    import urllib3

    from typing import Dict

    # Disable insecure warnings
    urllib3.disable_warnings()  # pylint: disable=no-member

    """ CONSTANTS """

    INCIDENT_FIELDS = {
        "status": {
            "description": "Current status of the incident",
            "field": "ztapstatus",
        },
    }

    XSOAR_STATUS_TO_ZTAP = {
        "Other": "unresolved",
        "Duplicate": "resolved",
        "False Positive": "resolved",
        "Resolved": "resolved",
    }

    ZTAP_STATUS_TO_XSOAR = {
        "unresolved": "Other",
        "resolved": "Resolved",
    }

    ESCALATE_REASON = "User escalated back to Critical Start."

    # Ignore new comments with this string
    XSOAR_EXCLUDE_MESSAGE = "via Cortex XSOAR"

    # ISO8601 format with UTC, default in XSOAR
    DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"

    # Default time string
    EPOCH = "0001-01-01T00:00:00Z"

    MIRROR_DIRECTION = {"None": None, "Incoming": "In", "Outgoing": "Out", "Both": "Both"}

    """ CLIENT CLASS """


    class Client(BaseClient):
        PAGINATE_LIMIT = 100
        MAXIMUM_EVENTS = 1000
        FIELD_LIMIT = 1000

        def __init__(
            self,
            base_url,
            verify_certificate=True,
            api_key=None,
            proxy=None,
            comment_tag="",
            escalate_tag="",
            max_match=100,
            get_attachments=False,
            close_incident=False,
            reopen_incident=False,
            reopen_group="",
        ):
            headers = {
                "Authorization": api_key,
            }

            super().__init__(
                base_url=base_url, verify=verify_certificate, headers=headers, proxy=proxy
            )
            # Download links already include headers including a request signature,
            # The client cannot have any default headers
            self.download_client = BaseClient(base_url=None, verify=verify_certificate, proxy=proxy)
            self.comment_tag = comment_tag
            self.escalate_tag = escalate_tag
            self.max_match = max_match
            self.get_attachments = get_attachments
            self.close_incident = close_incident
            self.reopen_incident = reopen_incident
            self.reopen_group = reopen_group
            self._active_user = None

        @property
        def active_user(self):
            if not self._active_user:
                self._active_user = self.get_active_user()
            return self._active_user

        def http_request(self, method, url_suffix, params, json_data=None):
            response = self._http_request(
                method=method, url_suffix=url_suffix, params=params, json_data=json_data
            )
            return response

        def get_organizations(self, params):
            response = self.http_request(
                method="GET", url_suffix="/organizations/", params=params
            )
            return response["objects"]

        def get_groups(self):
            return self.paginate(method="GET", url_suffix="/groups/", params={})

        def get_alerts(self, params):
            response = self.http_request(
                method="GET", url_suffix="/incidents/", params=params
            )
            return response["objects"]

        def get_all_alerts(self, params):
            return self.paginate(method="GET", url_suffix="/incidents/", params=params)

        def get_alert(self, alert_id):
            response = self.http_request(
                method="GET", url_suffix=f"/incidents/{alert_id}/", params={}
            )
            return response

        def get_escalation_path(self, alert_id):
            response = self.http_request(
                method="GET",
                url_suffix=f"/incidents/{alert_id}/escalation_path/",
                params={},
            )
            return response["escalation_path"]

        def get_comments(self, alert_id, created_since):
            params = {
                "model": "incident",
                "object_id": alert_id,
                "created": created_since.isoformat(),
            }
            return self.paginate(method="GET", url_suffix="/comments/", params=params)

        def get_events(self, alert_id):
            params = {
                "incident": alert_id,
                "category": "tier1",
                "fields": self.FIELD_LIMIT,
            }
            return self.paginate(method="GET", url_suffix="/events/", params=params)

        def upload_comment(self, alert_id, text):
            json_data = {
                "comment": text,
                "model": "incident",
                "object_id": alert_id,
                "type": "public",
            }
            self.http_request(
                method="POST", url_suffix="/comments/", params={}, json_data=json_data
            )

        def close_alert(self, alert_id, description, outcome):
            json_data = {
                "description": description,
                "outcome": outcome,
                "user_confirmed": True,
            }
            self.http_request(
                method="PUT",
                url_suffix=f"/incidents/{alert_id}/close/",
                params={},
                json_data=json_data,
            )

        def download_attachment(self, link):
            return self.download_client._http_request(method="GET", full_url=link, resp_type="content")

        def reopen_alert(self, alert_id, group_id, description):
            return self.reassign_alert_to_group(alert_id, group_id, description)

        def reassign_alert_to_group(self, alert_id, group_id, description):
            json_data = {
                "group_id": group_id,
                "type": "Group",
                "comment": description,
                "user_confirmed": True,
            }
            self.escalate_alert(alert_id, json_data)

        def reassign_alert_to_org(self, alert_id, org_id, description):
            json_data = {
                "org_id": org_id,
                "type": "Organization",
                "comment": description,
                "user_confirmed": True,
            }
            self.escalate_alert(alert_id, json_data)

        def escalate_alert(self, alert_id, json_data):
            self.http_request(
                method="PUT",
                url_suffix=f"/incidents/{alert_id}/escalate/",
                params={},
                json_data=json_data,
            )

        def get_escalate_org_id(self):
            org = self.get_escalation_organization()
            return org["monitoring_organization"]["id"]

        def get_reopen_group_id(self):
            group = self.get_reopen_group()
            return group["id"]

        def get_active_user(self):
            params = {"active_only": True}
            response = self.http_request(method="GET", url_suffix="/users/", params=params)
            return response["objects"][0]

        def get_reopen_group(self):
            active_org_name = self.active_user["organization"]["name"]
            for group in self.get_groups():
                if group["organization"]["name"].lower() == active_org_name.lower():
                    if group["name"].lower() == self.reopen_group.lower():
                        return group
            full_name = self.get_full_escalation_name()
            raise ValueError(f"Escalation group {full_name} not found")

        def get_escalation_organization(self):
            active_psa_id = self.active_user["organization"]["psa_id"]
            params = {"q": active_psa_id}
            for org in self.get_organizations(params):
                if org["psa_id"] == active_psa_id:
                    return org
            raise ValueError(f"Escalation organization ({active_psa_id}) not found")

        def get_full_escalation_name(self):
            active_org_name = self.active_user["organization"]["name"]
            return f"{self.reopen_group} ({active_org_name})"

        def paginate(self, method, url_suffix, params, json_data=None):
            limit = self.PAGINATE_LIMIT
            if "limit" not in params:
                params["limit"] = self.PAGINATE_LIMIT
            else:
                limit = params["limit"]

            page = 1

            # First request
            response = self.http_request(
                method=method, url_suffix=url_suffix, params=params, json_data=json_data
            )
            objects = response["objects"]

            view_id = response.get("view")
            if view_id:
                params["view"] = view_id

            # Additional requests
            total = response["total"]
            while total > limit * page:
                page += 1
                if limit * page > self.MAXIMUM_EVENTS:
                    break

                params["page"] = page
                response = self.http_request(
                    method=method, url_suffix=url_suffix, params=params, json_data=json_data
                )
                objects.extend(response["objects"])

            return objects


    """ HELPER FUNCTIONS """


    def epoch():
        return dateparser.parse(EPOCH)


    def get_sort(occurred: str, oid: str):
        return f"{occurred}_{oid}"


    def delta_or_data(remote_args, key):
        if remote_args.delta.get(key):
            return remote_args.delta.get(key)
        else:
            return remote_args.data.get(key)


    def alert_to_incident(alert: Dict):
        alert_id = alert["id"]
        description = alert["description"]
        return {
            "name": f"ZTAP Alert ({alert_id}) {description}",
            "occurred": alert["datetime_firstevent"],
            "rawJSON": json.dumps(alert),
        }


    def get_last_closed(investigation):
        return dateparser.parse(investigation.get("closed", EPOCH))


    def get_last_reopened(investigation):
        return dateparser.parse(investigation.get("lastOpen", EPOCH))


    def get_alert_last_closed(alert):
        return dateparser.parse(alert.get("datetime_closed") or EPOCH)


    def get_alert_last_reopened(alert):
        return get_alert_org_escalation_time(alert)


    def get_alert_org_escalation_time(alert):
        return dateparser.parse(alert.get("datetime_org_assigned") or EPOCH)


    def get_alert_last_new_event(alert):
        return dateparser.parse(alert.get("datetime_events_added") or EPOCH)


    def user_to_display(user):
        user_name = user.get("name")
        user_email = user.get("email")
        if user_name and user_email:
            return f"{user_name} ({user_email})"
        elif user_name:
            return user_name
        elif user_email:
            return user_email
        else:
            return "Unknown"


    def get_comments_for_alert(
        client: Client,
        alert_id: str,
        last_update: datetime,
    ):
        """
        Gets comments associated with an incident
        """
        all_comments = client.get_comments(alert_id, last_update)

        comments = []
        for c in all_comments:
            if XSOAR_EXCLUDE_MESSAGE in ["comment"]:
                continue

            date_created = dateparser.parse(c["datetime_created"])
            assert date_created
            if date_created <= last_update:
                continue

            comments.append(c)

        return comments


    def comments_to_notes(client: Client, comments: List):
        """
        Turns comments into XSOAR entries
        """

        def to_note(comment):
            occurred = comment["datetime_created"]
            oid = comment["id"]
            user_display = user_to_display(comment.get("user"))
            comment_text = comment.get("comment")
            footer = f"\n\nSent by {user_display} via ZTAP"
            return {
                "Type": EntryType.NOTE,
                "ContentsFormat": EntryFormat.JSON,
                "Contents": comment,
                "HumanReadable": f"{comment_text}{footer}",
                "ReadableContentsFormat": EntryFormat.TEXT,
                "Note": True,
                "Tags": [],
                "sort": get_sort(occurred, oid),
            }

        entries = []
        for c in comments:
            if client.get_attachments:
                for filename, link in get_comment_links(c):
                    entries.append(attachment_note_from_link(client, filename, link))

            strip_comment_links(c)
            entries.append(to_note(c))

        return entries


    def get_notes_for_alert(
        client: Client,
        investigation: Dict,
        alert: Dict,
        last_update: datetime,
        update_status: bool,
    ):
        """
        Retrieve any comments/attachments as XSOAR entries
        """

        alert_id = str(alert["id"])

        entries = []

        comments = get_comments_for_alert(client, alert_id, last_update)
        entries.extend(comments_to_notes(client, comments))

        entries = sorted(entries, key=lambda x: x.get("sort", ""))

        # Remove sort field from entries now that they are sorted correctly
        for entry in entries:
            entry.pop("sort", None)

        # Times for syncing
        local_last_closed = get_last_closed(investigation)
        local_last_reopened = get_last_reopened(investigation)
        remote_last_closed = get_alert_last_closed(alert)
        remote_last_reopened = get_alert_last_reopened(alert)

        if (
            update_status
            and alert["status"] == "closed"
            and client.close_incident
            and remote_last_closed > local_last_reopened
        ):
            # Use the last comment as a close comment
            if comments:
                last_comment = comments[-1]["comment"]
            else:
                last_comment = ""
            close_reason = ZTAP_STATUS_TO_XSOAR.get(alert["review_outcome"], "Other")
            entries.append(
                {
                    "Type": EntryType.NOTE,
                    "Contents": {
                        "dbotIncidentClose": True,
                        "closeReason": close_reason,
                        "closeNotes": f"From ZTAP: {last_comment}",
                    },
                    "ContentsFormat": EntryFormat.JSON,
                }
            )
            demisto.info(f"Closing incident from ZTAP {alert_id}")

        if (
            update_status
            and alert["status"] != "closed"
            and remote_last_reopened > local_last_closed
            and client.reopen_incident
        ):
            entries.append(
                {
                    "Type": EntryType.NOTE,
                    "Contents": {
                        "dbotIncidentReopen": True,
                    },
                    "ContentsFormat": EntryFormat.JSON,
                }
            )
            demisto.info(f"Reopening incident from ZTAP {alert_id}")

        return entries


    def get_comment_links(comment: Dict):
        # Format [description](link)
        # Extract description, link
        link_regex = re.compile(r"\[([^\]]+)\]\(([^)]+incident_uploads[^)]+)\)")
        return link_regex.findall(comment["comment"])


    def strip_comment_links(comment: Dict):
        # Format [description](link)
        # Remove the (link)
        strip_regex = re.compile(r"(\[[^\]]+\])\([^)]+incident_uploads[^)]+\)")
        comment["comment"] = strip_regex.sub(r"\1", comment["comment"])
        return comment


    def attachment_note_from_link(
        client: Client,
        filename: str,
        link: str,
    ):
        text = client.download_attachment(link)
        result = fileResult(filename, text)
        result["Note"] = True
        result["Tags"] = []
        return result


    def was_alert_first_escalated(
        client: Client, alert_id: str, org_name: str, since: datetime
    ):
        """
        We are searching by alert org assignment time, however an alert could have
        been escalated to a different org. Make sure the alert was escalated
        to the escalation organization within the time window we are searching (last update -> now)
        """
        # Group names are in the format "PATH NAME (GROUP NAME)"
        end_of_group = ("(" + org_name + ")").lower()
        escalation_path = client.get_escalation_path(alert_id)

        for escalation in escalation_path:
            if escalation["type"] == "Group" and escalation["group"].lower().endswith(
                end_of_group
            ):
                escalation_time = dateparser.parse(escalation["time"])
                assert escalation_time is not None
                # Only check against the first escalation to this organization
                return escalation_time > since

        return False


    def extract_trigger_kv(trigger_events: list):
        """
        The main information about the alert is more convenient to have as key/value pairs
        instead of using field weights as it makes writing mapping for individual values easier.
        """
        trigger_event = None
        for event in trigger_events:
            if event.get("trigger"):
                trigger_event = event
                break
        flattened = {}
        if trigger_event:
            for field in trigger_event.get("fields", []):
                key = field["key"]
                value = field["value"]
                flattened[key] = value

        return flattened


    """ COMMAND FUNCTIONS """


    def fetch_incidents(
        client: Client,
        last_run: Dict,
        first_fetch_time: str,
        max_fetch: int,
        mirror_direction: Optional[str],
        integration_instance: str,
    ):
        """
        Fetches incidents from ZTAP
        """
        if last_run:
            oldest_alert_time = dateparser.parse(last_run["last_run"])
            existing_ids = last_run.get("existing_ids", [])
        else:
            oldest_alert_time = dateparser.parse(
                first_fetch_time,
                settings={"TIMEZONE": "UTC", "RETURN_AS_TIMEZONE_AWARE": True},
            )
            existing_ids = []

        assert oldest_alert_time
        org_name = client.active_user["organization"]["name"]
        org_psa_id = client.active_user["organization"]["psa_id"]
        start_time_iso = oldest_alert_time.isoformat()
        now_iso = datetime.now().isoformat() + "Z"
        params = {
            "sort by": "last time org assigned",
            "last time org assigned": f"{start_time_iso}&{now_iso}",
            "incident status": ["open", "reviewing"],
            "assigned organization": org_psa_id,
            "limit": max_fetch,
        }
        alerts = client.get_alerts(params=params)

        incidents = []
        newest_ids = []
        escalation_time = oldest_alert_time
        for alert in alerts:
            alert_orig_escalation_time = get_alert_org_escalation_time(alert)
            assert alert_orig_escalation_time is not None and alert_orig_escalation_time is not None
            escalation_time = max(escalation_time, alert_orig_escalation_time)
            alert_id = str(alert["id"])

            if alert_id in existing_ids:
                newest_ids.append(alert_id)
                continue

            if not was_alert_first_escalated(client, alert_id, org_name, oldest_alert_time):
                continue

            newest_ids.append(alert_id)

            trigger_events = client.get_events(alert_id)
            alert["xsoar_trigger_events"] = trigger_events

            # Parse trigger event as key/value pairs for ease of parsing
            alert["xsoar_trigger_kv"] = extract_trigger_kv(trigger_events)

            # Mirroring fields
            alert["xsoar_mirror_direction"] = mirror_direction
            alert["xsoar_mirror_instance"] = integration_instance
            alert["xsoar_mirror_id"] = alert_id
            alert["xsoar_mirror_tags"] = [client.comment_tag, client.escalate_tag]

            # Link back to ZTAP
            alert["url"] = alert.get("url")

            incident = alert_to_incident(alert)
            incidents.append(incident)

        new_last_run = {
            "last_run": escalation_time.isoformat().replace("+00:00", "Z"),
            "existing_ids": newest_ids,
        }

        return incidents, new_last_run


    def get_mapping_fields():
        """
        Gets mapping fields for ZTAP
        """
        type_scheme = SchemeTypeMapping(type_name="ZTAP Alert")
        for field, info in INCIDENT_FIELDS.items():
            type_scheme.add_field(name=field, description=info["description"])

        return GetMappingFieldsResponse([type_scheme])


    def get_remote_data(
        client: Client,
        investigation: Dict,
        args: Dict,
    ):
        """
        Gets updated data from ZTAP for an alert that has changed
        """
        parsed_args = GetRemoteDataArgs(args)

        try:
            alert_id = parsed_args.remote_incident_id

            alert = client.get_alert(alert_id)

            last_update_utc = dateparser.parse(
                parsed_args.last_update,
                settings={"TIMEZONE": "UTC", "RETURN_AS_TIMEZONE_AWARE": True},
            )
            assert last_update_utc is not None
            entries = get_notes_for_alert(
                client,
                investigation,
                alert,
                last_update_utc,
                update_status=True,
            )

            if last_update_utc <= get_alert_last_new_event(alert):
                trigger_events = client.get_events(alert_id)
                alert["xsoar_trigger_events"] = trigger_events

            alert["in_mirror_error"] = ""

            return GetRemoteDataResponse(alert, entries)
        except Exception as e:
            if "Rate limit" in str(e):
                raise Exception("API rate limit")

            raise Exception(str(e))


    def get_modified_remote_data(client: Client, args: Dict):
        """
        Gets ZTAP alerts that have been modified since the last check
        """
        parsed_args = GetModifiedRemoteDataArgs(args)
        last_update = parsed_args.last_update

        now_iso = datetime.now().isoformat() + "Z"

        params = {
            "sort by": "incident updated",
            "incident updated": f"{last_update}&{now_iso}",
            "incident status": ["open", "closed", "reviewing"],
        }
        alerts = client.get_all_alerts(params=params)

        modified_incident_ids = []
        for alert in alerts:
            modified_incident_ids.append(str(alert["id"]))

        return GetModifiedRemoteDataResponse(modified_incident_ids)


    def update_remote_system(
        client: Client,
        investigation: Dict,
        args: Dict,
    ):
        """
        Updates ZTAP with new comments and/or closes the alert if closed in XSOAR
        """
        parsed_args = UpdateRemoteSystemArgs(args)

        alert_id = parsed_args.remote_incident_id

        if parsed_args.entries:
            for entry in parsed_args.entries:
                user = str(entry.get("user", ""))
                contents = str(entry.get("contents", ""))
                footer = f"Sent by {user} {XSOAR_EXCLUDE_MESSAGE}"
                if client.comment_tag in entry["tags"]:
                    text = f"{contents}\n\n---\n\n{footer}"
                    client.upload_comment(alert_id, text)
                elif client.escalate_tag in entry["tags"]:
                    footer = ESCALATE_REASON + "\n\n" + footer
                    text = f"{contents}\n\n---\n\n{footer}"
                    try:
                        client.reassign_alert_to_org(
                            alert_id, client.get_escalate_org_id(), text
                        )
                    except Exception as e:
                        if "already assigned" in str(e):
                            client.upload_comment(alert_id, text)
                        else:
                            raise e

        alert = client.get_alert(alert_id)

        local_last_closed = get_last_closed(investigation)
        local_last_reopened = get_last_reopened(investigation)
        remote_last_closed = get_alert_last_closed(alert)
        remote_last_reopened = get_alert_last_reopened(alert)

        # Close remote alert
        if parsed_args.incident_changed and client.close_incident:
            if (
                parsed_args.inc_status == IncidentStatus.DONE
                and alert["status"] != "closed"
                and local_last_closed > remote_last_reopened
            ):
                demisto.info(f"Closing ZTAP Alert {alert_id}")
                close_notes = delta_or_data(parsed_args, "closeNotes")
                close_reason = delta_or_data(parsed_args, "closeReason")
                close_description = f"{close_notes}\n\nClose Reason: {close_reason}"
                close_description += "\n\n---\n\nIncident closed in XSOAR."
                close_description += f"\n\nSent {XSOAR_EXCLUDE_MESSAGE}"
                outcome = XSOAR_STATUS_TO_ZTAP.get(close_reason, "unresolved")
                client.close_alert(alert_id, close_description, outcome)

        # Re-open remote alert
        if parsed_args.incident_changed and client.reopen_incident:
            if (
                parsed_args.inc_status != IncidentStatus.DONE
                and alert["status"] == "closed"
                and local_last_reopened > remote_last_closed
            ):
                demisto.info(f"Reopening ZTAP Alert {alert_id}")
                close_description = f"Incident reopened in XSOAR.---\n\nSent {XSOAR_EXCLUDE_MESSAGE}"
                client.reopen_alert(
                    alert_id, client.get_reopen_group_id(), close_description
                )

        return alert_id


    def ztap_get_alert_entries(
        client: Client,
        args: Dict,
    ):
        """
        Gets all entries (comments/attachments) for an alert
        """
        try:
            alert_id = args.get("id")

            alert = {
                "status": "assigned",
                "id": alert_id,
                "datetime_created": EPOCH,
                "datetime_closed": None,
            }

            investigation: Dict = {}
            entries = get_notes_for_alert(
                client, investigation, alert, epoch(), update_status=False
            )

            return entries
        except Exception as e:
            if "Rate limit" in str(e):
                raise Exception("API rate limit")

            raise Exception(str(e))


    def test_module(client: Client) -> str:
        """
        Tests API connectivity and authentication

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type client: ``Client``
        :param Client: client to use

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """
        params = {"limit": 1}

        try:
            client.get_alerts(params=params)
            client.get_escalation_organization()
            client.get_reopen_group()
            message = "ok"
        except DemistoException as e:
            if "Unauthorized" in str(e):
                message = "Authorization Error: make sure API Key is correctly set"
            else:
                raise e
        return message


    """ MAIN FUNCTION """


    def main() -> None:
        """
        main function, parses params and runs command functions
        """

        params = demisto.params()

        # Authentication
        api_key = params.get("apikey")

        # get the service API url
        base_url = urljoin(params["url"], "/api/1.5/")

        verify_certificate = not params.get("insecure", False)
        proxy = params.get("proxy", False)
        comment_tag = params.get("comment_tag")
        escalate_tag = params.get("escalate_tag")
        get_attachments = params.get("get_attachments", False)
        close_incident = params.get("close_incident", False)
        reopen_incident = params.get("reopen_incident", False)
        reopen_group = params.get("reopen_group", "Default")

        demisto.debug(f"Command being called is {demisto.command()}")
        try:

            client = Client(
                base_url=base_url,
                verify_certificate=verify_certificate,
                api_key=api_key,
                proxy=proxy,
                comment_tag=comment_tag,
                escalate_tag=escalate_tag,
                get_attachments=get_attachments,
                close_incident=close_incident,
                reopen_incident=reopen_incident,
                reopen_group=reopen_group,
            )

            if demisto.command() == "test-module":
                # This is the call made when pressing the integration Test button.
                result = test_module(client)
                return_results(result)

            elif demisto.command() == "fetch-incidents":
                max_fetch = params.get("max_fetch", 100)
                last_run = demisto.getLastRun()
                first_fetch_timestamp = params.get(
                    "first_fetch_timestamp", "7 days"
                ).strip()
                mirror_direction = MIRROR_DIRECTION.get(
                    demisto.params().get("mirror_direction", "None"), None
                )
                integration_instance = demisto.integrationInstance()
                incidents, new_last_run = fetch_incidents(
                    client=client,
                    last_run=last_run,
                    max_fetch=max_fetch,
                    first_fetch_time=first_fetch_timestamp,
                    mirror_direction=mirror_direction,
                    integration_instance=integration_instance,
                )
                demisto.setLastRun(new_last_run)
                demisto.incidents(incidents)

            elif demisto.command() == "get-mapping-fields":
                result = get_mapping_fields()
                return_results(result)

            elif demisto.command() == "get-remote-data":
                investigation = demisto.investigation()
                result = get_remote_data(client, investigation, demisto.args())
                return_results(result)

            elif demisto.command() == "get-modified-remote-data":
                result = get_modified_remote_data(client, demisto.args())
                return_results(result)

            elif demisto.command() == "update-remote-system":
                investigation = demisto.investigation()
                result = update_remote_system(client, investigation, demisto.args())
                return_results(result)

            elif demisto.command() == "ztap-get-alert-entries":
                result = ztap_get_alert_entries(client, demisto.args())
                return_results(result)

        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(
                f"Failed to execute {demisto.command()} command.\nError:\n{str(e)}"
            )


    """ ENTRY POINT """


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('ZeroTrustAnalyticsPlatform', 'end', __line__())
  subtype: python3
  type: python
