[MODEL: dataset = google_dns_raw]
filter resource -> type = "dns_query"
| call GCP_MAP_COMMON_FIELDS
| call GCP_MAP_DNS_QUERIES;

[MODEL: dataset = google_cloud_logging_raw]
// Audit Logs 
filter protoPayload -> ["@type"] = "type.googleapis.com/google.cloud.audit.AuditLog" // or logName contains "cloudaudit.googleapis.com"
| call GCP_MAP_COMMON_FIELDS
| call GCP_MAP_AUDIT_LOGS;

// DNS Queries 
filter resource -> type = "dns_query" and protoPayload -> ["@type"] != "type.googleapis.com/google.cloud.audit.AuditLog" 
| call GCP_MAP_COMMON_FIELDS
| call GCP_MAP_DNS_QUERIES;

// All Other Logs  
filter protoPayload -> ["@type"] != "type.googleapis.com/google.cloud.audit.AuditLog" and resource -> type != "dns_query"
| call GCP_MAP_COMMON_FIELDS
| alter xdm.source.cloud.project_id = arrayindex(regextract(logName, "projects\/([^\/]+)\/"), 0);

[RULE: GCP_MAP_COMMON_FIELDS]
alter // Map fields that are common to all log entries. Schema: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry.
    xdm.alert.severity = severity,
    xdm.event.description = coalesce(to_string(protoPayload), to_string(jsonPayload), textPayload),
    xdm.event.id = insertId,
    xdm.event.log_level = if(severity = "DEBUG", XDM_CONST.LOG_LEVEL_DEBUG, severity = "INFO", XDM_CONST.LOG_LEVEL_INFORMATIONAL, severity = "NOTICE", XDM_CONST.LOG_LEVEL_NOTICE, severity = "WARNING", XDM_CONST.LOG_LEVEL_WARNING, severity = "ERROR", XDM_CONST.LOG_LEVEL_ERROR, severity = "CRITICAL", XDM_CONST.LOG_LEVEL_CRITICAL, severity = "ALERT", XDM_CONST.LOG_LEVEL_ALERT, severity = "EMERGENCY", XDM_CONST.LOG_LEVEL_EMERGENCY),
    xdm.event.original_event_type = arrayindex(regextract(logName, "logs\/(.+)"), 0),
    xdm.event.type = arrayindex(regextract(logName, "(?:%2F?|\/?)(\w+)"), -1),
    xdm.session_context_id = coalesce(operation -> id),
    xdm.source.cloud.provider = XDM_CONST.CLOUD_PROVIDER_GCP,
    xdm.target.cloud.project_id = coalesce(resource -> labels.project_id, resource -> labels.resource_container),
    xdm.target.resource.type = resource -> type;

[RULE: GCP_MAP_AUDIT_LOGS]
alter // Audit Log events. Audit protoPayload Schema: https://cloud.google.com/logging/docs/reference/audit/auditlog/rest/Shared.Types/AuditLog 
    authorization_info = protoPayload -> authorizationInfo[], // Authorization information. If there are multiple resources or permissions involved, then there is one AuthorizationInfo element for each {resource, permission} tuple.
    http_request_method = httpRequest -> requestMethod, // The request method. Examples: "GET", "HEAD", "PUT", "POST".
    http_request_url = httpRequest -> requestUrl, // The scheme (http, https), the host name, the path and the query portion of the URL that was requested.
    http_request_size = to_integer(httpRequest -> requestSize), // The size of the HTTP request message in bytes, including the request headers and the request body.
    http_request_useragent = httpRequest -> userAgent, // The user agent sent by the client.
    http_request_client_ip = httpRequest -> remoteIp, // The IP address (IPv4 or IPv6) of the client that issued the HTTP request. This field can include port information
    http_request_server_ip = httpRequest -> serverIp, // The IP address (IPv4 or IPv6) of the origin server that the request was sent to. This field can include port information
    http_request_referrer = httpRequest -> referer, // The referer URL of the request, as defined in HTTP/1.1 Header Field Definitions.
    http_request_protocol = httpRequest -> protocol, // Protocol used for the request. Examples: "HTTP/1.1", "HTTP/2"
    http_response_status = to_integer(httpRequest -> status), // The response code indicating the status of response. Examples: 200, 404.
    http_response_size = to_integer(httpRequest -> responseSize), // The size of the HTTP response message sent back to the client, in bytes, including the response headers and the response body.
    service_name = protoPayload -> serviceName, // The name of the API service performing the operation
    method_name = protoPayload -> methodName, // The name of the service method or operation. For API calls, this should be the name of the API method.
    resource_name = protoPayload -> resourceName, // The resource or collection that is the target of the operation. 
    resource_current_locations = protoPayload -> resourceLocation.currentLocations[], // The locations of a resource after the execution of the operation.
    resource_original_locations = protoPayload -> resourceLocation.originalLocations[], // The locations of a resource prior to the execution of the operation.
    resource_labels_location = resource -> labels.location, 
    resource_labels_region = resource -> labels.region, 
    resource_labels_zone = resource -> labels.zone, 
    principal_email = protoPayload -> authenticationInfo.principalEmail,
    principal_subject = protoPayload -> authenticationInfo.principalSubject,
    service_account_delegations = protoPayload -> authenticationInfo.serviceAccountDelegationInfo[],
    policy_constraint_name = arraystring(arraymap(protoPayload -> policyViolationInfo.orgPolicyViolationInfo.violationInfo[], "@element" -> constraint), ","), // Constraint name
    request_caller_ip = protoPayload -> requestMetadata.callerIp, // The IP address of the caller. 
    request_user_agent = protoPayload -> requestMetadata.callerSuppliedUserAgent, // The user agent of the caller.
    request_destination_ip = protoPayload -> requestMetadata.destinationAttributes.ip, // The IP address of the peer.
    request_destination_port = to_integer(protoPayload -> requestMetadata.destinationAttributes.port), // The network port of the peer.
    request_destination_principal = protoPayload -> requestMetadata.destinationAttributes.principal, // The identity of this peer.
    request_destination_region_code = protoPayload -> requestMetadata.destinationAttributes.regionCode, // The CLDR country/region code associated with the above IP address. 
    request_attr_host = protoPayload -> requestMetadata.requestAttributes.host, // The HTTP request Host header value.
    request_attr_method = protoPayload -> requestMetadata.requestAttributes.method, // The HTTP request method, such as GET, POST.
    request_attr_path = coalesce(protoPayload -> requestMetadata.requestAttributes.path, ""), // The HTTP URL path, excluding the query parameters
    request_attr_protocol = protoPayload -> requestMetadata.requestAttributes.protocol, // The network protocol used with the request
    request_attr_query = coalesce(concat("?", protoPayload -> requestMetadata.requestAttributes.query), ""), // The HTTP URL query in the format of name1=value1&name2=value2, as it appears in the first line of the HTTP request. No decoding is performed
    request_attr_scheme = protoPayload -> requestMetadata.requestAttributes.scheme, // The HTTP URL scheme, such as http and https.
    status_code = to_integer(protoPayload -> status.code), // The status code, which should be an enum value of google.rpc.Code.  (https://cloud.google.com/tasks/docs/reference/rpc/google.rpc)
    status_message = protoPayload -> status.message, // A developer-facing error message
    target_cloud_platform = uppercase(resource -> labels.cloud_platform) // The cloud platform on which the GCS client runs. (relevant for storage.googleapis.com/Client resource)
| alter
    resource_granted_permissions = arraymap(arrayfilter(authorization_info, "@element" -> granted = "True"), "@element" -> permission), // filter to granted permissions only
    resource_uid = arraystring(arraymap(authorization_info, "@element" -> resourceAttributes.uid), ","), // The unique identifier of the resource
    resource_location = arraystring(arraymap(authorization_info, "@element" -> resourceAttributes.location), ","), // The location of the resource.
    user_domain = arrayindex(split(principal_email, "@"), 1),
    delegated_principal_subjects = arraystring(arraymap(service_account_delegations, coalesce("@element" -> principalSubject, "@element" -> firstPartyPrincipal.principalEmail)), ","),
    formatted_principal_subject = arrayindex(regextract(principal_subject, "(?:\w+\:)(.+)"), 0), 
    request_caller_ipv4 = if(request_caller_ip ~= "(?:\d{1,3}\.){3}\d{1,3}", request_caller_ip), 
    request_caller_ipv6 = if(request_caller_ip ~= "(?:[a-fA-F\d]{0,4}\:){1,7}[a-fA-F\d]{0,4}", request_caller_ip), 
    http_request_client_ipv4 = arrayindex(regextract(http_request_client_ip, "((?:\d{1,3}\.){3}\d{1,3})"), 0), 
    http_request_client_ipv6 = if(http_request_client_ip !~= "(?:\d{1,3}\.){3}\d{1,3}", http_request_client_ip), 
    http_request_server_ipv4 = arrayindex(regextract(http_request_server_ip, "((?:\d{1,3}\.){3}\d{1,3})"), 0), 
    http_request_server_ipv6 = if(http_request_server_ip !~= "(?:\d{1,3}\.){3}\d{1,3}", http_request_server_ip), 
    http_method = coalesce(http_request_method, request_attr_method),
    request_destination_ipv4 = if(request_destination_ip ~= "(?:\d{1,3}\.){3}\d{1,3}", request_destination_ip), 
    request_destination_ipv6 = if(request_destination_ip ~= "(?:[a-fA-F\d]{0,4}\:){1,7}[a-fA-F\d]{0,4}", request_destination_ip),
    status_code_description = if(status_code = 0, "OK", status_code = 1, "CANCELLED", status_code = 2, "UNKNOWN", status_code = 3, "INVALID_ARGUMENT", status_code = 4, "DEADLINE_EXCEEDED", status_code = 5, "NOT_FOUND", status_code = 6, "ALREADY_EXISTS", status_code = 7, "PERMISSION_DENIED", status_code = 8, "UNAUTHENTICATED", status_code = 9, "RESOURCE_EXHAUSTED", status_code = 10, "FAILED_PRECONDITION", status_code = 11, "ABORTED", status_code = 12, "OUT_OF_RANGE", status_code = 13, "UNIMPLEMENTED", status_code = 14, "INTERNAL", status_code = 15, "UNAVAILABLE", status_code = 16, "DATA_LOSS"), // https://cloud.google.com/tasks/docs/reference/rpc/google.rpc
    target_url = coalesce(http_request_url, concat(request_attr_scheme, request_attr_host, request_attr_path, request_attr_query))
| alter 
    resource_labels_location_region = coalesce(arrayindex(regextract(resource_labels_location, "(\w+\-\w+)"), 0), resource_labels_location),
    resource_labels_location_zone = if(resource_labels_location ~= "\w+\-\w+\-", resource_labels_location), 
    http_request_src_port = to_integer(arrayindex(regextract(http_request_client_ipv4, ":(\d{1,5})$"), 0)),
    http_request_dst_port = to_integer(arrayindex(regextract(http_request_server_ipv4, ":(\d{1,5})$"), 0)),
    src_ipv4_addresses = arraycreate(request_caller_ipv4, http_request_client_ipv4),
    src_ipv6_addresses = arraycreate(request_caller_ipv6, http_request_client_ipv6),
    dst_ipv4_addresses = arraycreate(request_destination_ipv4, http_request_server_ipv4),
    dst_ipv6_addresses = arraycreate(request_destination_ipv6, http_request_server_ipv6)
| alter // XDM mappings 
    xdm.database.name = coalesce(resource -> labels.database_id, resource -> labels.table_name), 
    xdm.database.tables = arraycreate(resource -> ["labels.table"]),
    xdm.event.operation_sub_type = method_name,
    xdm.event.outcome = if(status_code = 0 or status_message = null, XDM_CONST.OUTCOME_SUCCESS, status_code > 0, XDM_CONST.OUTCOME_FAILED),
    xdm.event.outcome_reason = arraystring(arraycreate(to_string(status_code), status_code_description, status_message), ": "),
    xdm.intermediate.host.hostname = resource -> labels.target_proxy_name, 
    xdm.intermediate.user.username = delegated_principal_subjects,
    xdm.network.application_protocol = coalesce(request_attr_protocol, http_request_protocol),
    xdm.network.http.method = http_method, 
    xdm.network.http.url = target_url,
    xdm.network.http.response_code = to_string(http_response_status), 
    xdm.network.http.referrer = http_request_referrer,
    xdm.network.rule = coalesce(policy_constraint_name, resource -> labels.forwarding_rule_name, resource -> labels.forwarding_rule_id, resource -> labels.policy_name, resource -> labels.firewall_rule_id, resource -> labels.client_ssl_policy_id), 
    xdm.source.application.name = service_name,
    xdm.source.cloud.project_id = coalesce(arrayindex(regextract(logName, "projects\/([^\/]+)\/"), 0), resource -> labels.project_id),
    xdm.source.ipv4 = arrayindex(src_ipv4_addresses, 0),
    xdm.source.ipv6 = arrayindex(src_ipv6_addresses, 0),
    xdm.source.host.ipv4_addresses = src_ipv4_addresses,
    xdm.source.host.ipv6_addresses = src_ipv6_addresses,
    xdm.source.host.ipv4_public_addresses = arrayfilter(src_ipv4_addresses, not incidr("@element", "10.0.0.0/8") and not incidr("@element", "172.16.0.0/12") and not incidr("@element", "192.168.0.0/16") and not incidr("@element", "127.0.0.0/8") and not incidr("@element", "169.254.0.0/16") and not incidr("@element", "100.64.0.0/10")),
    xdm.source.port = http_request_src_port,
    xdm.source.sent_bytes = http_request_size,
    xdm.source.user_agent = coalesce(request_user_agent, http_request_useragent),
    xdm.source.user.domain = user_domain,
    xdm.source.user.groups = resource_granted_permissions,
    xdm.source.user.user_type = if(principal_subject ~= "^user:\S+", XDM_CONST.USER_TYPE_REGULAR, principal_subject ~= "^serviceAccount:\S+", XDM_CONST.USER_TYPE_SERVICE_ACCOUNT),
    xdm.source.user.username = arraystring(arraydistinct(arraycreate(principal_email, formatted_principal_subject)), ","),
    xdm.target.cloud.provider = if(target_cloud_platform ~= "ALIBABA", XDM_CONST.CLOUD_PROVIDER_ALIBABA, target_cloud_platform ~= "AWS|AMAZON", XDM_CONST.CLOUD_PROVIDER_AWS, target_cloud_platform ~= "AZURE|MS|MICROSOFT", XDM_CONST.CLOUD_PROVIDER_AZURE, target_cloud_platform ~= "GOOGLE|GCP", XDM_CONST.CLOUD_PROVIDER_GCP, target_cloud_platform),
    xdm.target.cloud.region = coalesce(resource_labels_region, resource_labels_location_region, request_destination_region_code), 
    xdm.target.cloud.zone = coalesce(resource_labels_zone, resource_labels_location_zone, resource_location, arraystring(resource_current_locations, ","), arraystring(resource_original_locations, ",")), 
    xdm.target.host.fqdn = request_attr_host,
    xdm.target.host.hostname = request_destination_principal,
    xdm.target.host.device_id = resource -> labels.host_id, 
    xdm.target.ipv4 = arrayindex(dst_ipv4_addresses, 0),
    xdm.target.ipv6 = arrayindex(dst_ipv6_addresses, 0),
    xdm.target.host.ipv4_addresses = dst_ipv4_addresses,
    xdm.target.host.ipv6_addresses = dst_ipv6_addresses,
    xdm.target.host.ipv4_public_addresses = arrayfilter(dst_ipv4_addresses, not incidr("@element", "10.0.0.0/8") and not incidr("@element", "172.16.0.0/12") and not incidr("@element", "192.168.0.0/16") and not incidr("@element", "127.0.0.0/8") and not incidr("@element", "169.254.0.0/16") and not incidr("@element", "100.64.0.0/10")),
    xdm.target.port = coalesce(request_destination_port, http_request_dst_port),
    xdm.target.resource.id = coalesce(resource_uid, resource -> labels.instance_id, resource -> labels.database_id, resource -> labels.cluster_uuid, resource -> labels.endpoint_id,resource -> labels.featurestore_id, resource -> labels.index_endpoint_id, resource -> labels.pipeline_job_id, resource -> labels.workflow_id, resource -> labels.tunnel_id, resource -> labels.gateway_id, resource -> labels.vm, resource -> labels.source, resource -> labels.application_id, resource -> labels.appliance_id, resource -> labels.worker_id, resource -> labels.node_id, resource -> labels.matrix_id, resource -> labels.stream_instance_id, resource -> labels.job_id, resource -> labels.event_id, resource -> labels.rollout_id, resource -> labels.service_config_id, resource -> labels.unique_id, resource -> labels.secret_id, resource -> labels.insight_type_id, resource -> labels.recommender_id, resource -> labels.key_id, resource -> labels.topic_id, resource -> labels.subscription_id, resource -> labels.snapshot_id, resource -> labels.organization_id, resource -> labels.id, resource -> labels.volume_id, resource -> labels.router_id, resource -> labels.service_id,  resource -> labels.federation_id, resource -> labels.cluster_id, resource -> labels.bucket_id, resource -> labels.channel_id, resource -> labels.mesh_uid, resource -> labels.restore_plan_id, resource -> labels.backup_plan_id, resource -> labels.operation_id, resource -> labels.dataset_id, resource -> labels.task_id, resource -> labels.url_map_id, resource -> labels.target_ssl_proxy_id, resource -> labels.target_pool_id, resource -> labels.target_http_proxy_id, resource -> labels.target_https_proxy_id, resource -> labels.target_http_instance_id, resource -> labels.subnetwork_id, resource -> labels.service_attachment_id, resource -> labels.router_id, resource -> labels.route_id, resource -> labels.resource_policy_id, resource -> labels.reserved_address_id, resource -> labels.packet_mirroring_id, resource -> labels.node_template_id, resource -> labels.node_group_id, resource -> labels.network_id, resource -> labels.network_endpoint_group_id, resource -> labels.license_id, resource -> labels.instance_template_id, resource -> labels.instance_group_manager_id, resource -> labels.instance_group_id, resource -> labels.image_id, resource -> labels.health_check_id, resource -> labels.forwarding_rule_id, resource -> labels.firewall_rule_id, resource -> labels.disk_id, resource -> labels.commitment_id, resource -> labels.client_ssl_policy_id, resource -> labels.backend_service_id, resource -> labels.backend_bucket_id, resource -> labels.autoscaler_id, resource -> labels.module_id, resource -> labels.folder_id, resource -> labels.prediction_result_id, resource -> labels.engine_config_id, resource -> labels.backtest_result_id, resource -> labels.stream_id, resource -> labels.zone_id, resource -> labels.lake_id, resource -> labels.rule_id, resource -> labels.environment_id, resource -> labels.datascan_id, resource -> labels.asset_id, resource -> labels.migration_job_id, resource -> labels.repository_id, resource -> labels.step_id, resource -> labels.pod_id, resource -> labels.namespace_id, resource -> labels.credential_id, resource -> labels.volume_id, resource -> labels.version_id, resource -> labels.key_ring_id, resource -> labels.crypto_key_id, resource -> labels.pipeline_id, resource -> labels.queue_id, resource -> labels.session_id, resource -> labels.batch_id, resource -> labels.client_id, resource -> labels.brand_id, resource -> labels.build_id, resource -> labels.account_id, resource -> labels.config_id, resource -> labels.model_id, resource -> labels.spark_job_id, resource -> labels.backup_recovery_appliance_id, resource -> labels.management_server_id, resource -> labels.distribution_id, resource -> labels.target_association_id, resource -> labels.action_id),  // https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types
    xdm.target.resource.name = coalesce(resource_name, resource -> labels.bucket_name, resource -> labels.environment_name, resource -> labels.policy_name, resource -> labels.zone_name, resource -> labels.cluster_id, resource -> labels.tunnel_name, resource -> labels.name, resource -> labels.connector_name, resource -> labels.detector_name, resource -> labels.forwarding_rule_name, resource -> labels.service_name, resource -> labels.namespace_name, resource -> labels.service, resource -> labels.gateway_name, resource -> labels.task_name, resource -> labels.fqdn, resource -> labels.mesh, resource -> labels.pod_name, resource -> labels.node_name, resource -> labels.nodepool_name, resource -> labels.component_name, resource -> labels.cluster_name, resource -> labels.cluster_identifier, resource -> labels.integration, resource -> labels.tenant_name, resource -> labels.role_name, resource -> labels.subnetwork_name, resource -> labels.operation_name, resource -> labels.instance_template_name, resource -> labels.instance_group_manager_name, resource -> labels.manifest_name, resource -> labels.instance_group_name, resource -> labels.scope, resource -> labels.ruleset_name, resource -> labels.release_name, resource -> labels.table_name, resource -> labels.domain_name, resource -> labels.site_name, resource -> labels.target_name, resource -> labels.resource_name, resource -> labels.deployment_name, resource -> labels.job_name, resource -> labels.container_name, resource -> labels.connection, resource -> labels.revision_name, resource -> labels.function_name, resource -> labels.app, resource -> labels.queue, resource -> labels.topic, resource -> labels.stream_name, resource -> labels.env, resource -> labels.hostname), // https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types
    xdm.target.resource.parent_id = resource -> labels.producer_project_id, // The id of the project which produces and owns this service (for managed_service resource).
    xdm.target.resource.sub_type = coalesce(resource -> labels.monitored_resource_type, resource -> labels.kind, resource -> labels.service_type),
    xdm.target.sent_bytes = http_response_size, 
    xdm.target.url = target_url,
    xdm.target.user.groups = arraycreate(resource -> labels.role_name); // The name of the IAM custom role; this label appears only on custom roles (iam_role resource)

[RULE: GCP_MAP_DNS_QUERIES]
alter  // DNS Queries events. Schema: https://cloud.google.com/dns/docs/monitoring#dns-log-record-format
    destination_ip = jsonPayload -> destinationIP, // Target IP address, only applicable for forwarding cases
    dns_query_name = jsonPayload -> queryName, // DNS query name, RFC 1035 4.1.2.
    dns_query_type = jsonPayload -> queryType, // 	DNS query type, RFC 1035 4.1.2.
    dns_rdata = jsonPayload -> rdata, // DNS answer in presentation format, RFC 1035 5.1, truncated to 260 bytes
    dns_rcode = jsonPayload -> responseCode, // Response code, RFC 1035 4.1.1.
    ip_protocol = jsonPayload -> protocol, // TCP | UDP
    source_ip = jsonPayload -> sourceIP, // IP originating the query
    vm_instance_id = to_string(jsonPayload -> vmInstanceId), // Compute Engine VM instance ID, only applicable to queries initiated by Compute Engine VMs,
    vm_zone_name = jsonPayload -> vmZoneName // Name of the VM zone from which the query was sent, only applicable to queries initiated by Compute Engine VMs
| alter 
    dns_class = arrayindex(regextract(dns_rdata, "(?:\s+|\\t)\d+(?:\s+|\\t)(IN|CS|CH|HS)(?:\s+|\\t)"), 0),
    dns_record_type = if(dns_query_type = "A", XDM_CONST.DNS_RECORD_TYPE_A, dns_query_type = "AAAA", XDM_CONST.DNS_RECORD_TYPE_AAAA, dns_query_type = "AFSDB", XDM_CONST.DNS_RECORD_TYPE_AFSDB, dns_query_type = "APL", XDM_CONST.DNS_RECORD_TYPE_APL, dns_query_type = "CAA", XDM_CONST.DNS_RECORD_TYPE_CAA, dns_query_type = "CDNSKEY", XDM_CONST.DNS_RECORD_TYPE_CDNSKEY, dns_query_type = "CDS", XDM_CONST.DNS_RECORD_TYPE_CDS, dns_query_type = "CERT", XDM_CONST.DNS_RECORD_TYPE_CERT, dns_query_type = "CNAME", XDM_CONST.DNS_RECORD_TYPE_CNAME, dns_query_type = "CSYNC", XDM_CONST.DNS_RECORD_TYPE_CSYNC, dns_query_type = "DHCID", XDM_CONST.DNS_RECORD_TYPE_DHCID, dns_query_type = "DLV", XDM_CONST.DNS_RECORD_TYPE_DLV, dns_query_type = "DNAME", XDM_CONST.DNS_RECORD_TYPE_DNAME, dns_query_type = "DNSKEY", XDM_CONST.DNS_RECORD_TYPE_DNSKEY, dns_query_type = "DS", XDM_CONST.DNS_RECORD_TYPE_DS, dns_query_type = "EUI48", XDM_CONST.DNS_RECORD_TYPE_EUI48, dns_query_type = "EUI64", XDM_CONST.DNS_RECORD_TYPE_EUI64, dns_query_type = "HINFO", XDM_CONST.DNS_RECORD_TYPE_HINFO, dns_query_type = "HIP", XDM_CONST.DNS_RECORD_TYPE_HIP, dns_query_type = "HTTPS", XDM_CONST.DNS_RECORD_TYPE_HTTPS, dns_query_type = "IPSECKEY", XDM_CONST.DNS_RECORD_TYPE_IPSECKEY, dns_query_type = "KEY", XDM_CONST.DNS_RECORD_TYPE_KEY, dns_query_type = "KX", XDM_CONST.DNS_RECORD_TYPE_KX, dns_query_type = "LOC", XDM_CONST.DNS_RECORD_TYPE_LOC, dns_query_type = "MX", XDM_CONST.DNS_RECORD_TYPE_MX, dns_query_type = "NAPTR", XDM_CONST.DNS_RECORD_TYPE_NAPTR, dns_query_type = "NS", XDM_CONST.DNS_RECORD_TYPE_NS, dns_query_type = "NSEC", XDM_CONST.DNS_RECORD_TYPE_NSEC, dns_query_type = "NSEC3", XDM_CONST.DNS_RECORD_TYPE_NSEC3, dns_query_type = "NSEC3PARAM", XDM_CONST.DNS_RECORD_TYPE_NSEC3PARAM, dns_query_type = "OPENPGPKEY", XDM_CONST.DNS_RECORD_TYPE_OPENPGPKEY, dns_query_type = "PTR", XDM_CONST.DNS_RECORD_TYPE_PTR, dns_query_type = "RRSIG", XDM_CONST.DNS_RECORD_TYPE_RRSIG, dns_query_type = "RP", XDM_CONST.DNS_RECORD_TYPE_RP, dns_query_type = "SIG", XDM_CONST.DNS_RECORD_TYPE_SIG, dns_query_type = "SMIMEA", XDM_CONST.DNS_RECORD_TYPE_SMIMEA, dns_query_type = "SOA", XDM_CONST.DNS_RECORD_TYPE_SOA, dns_query_type = "SRV", XDM_CONST.DNS_RECORD_TYPE_SRV, dns_query_type = "SSHFP", XDM_CONST.DNS_RECORD_TYPE_SSHFP, dns_query_type = "SVCB", XDM_CONST.DNS_RECORD_TYPE_SVCB, dns_query_type = "TA", XDM_CONST.DNS_RECORD_TYPE_TA, dns_query_type = "TKEY", XDM_CONST.DNS_RECORD_TYPE_TKEY, dns_query_type = "TLSA", XDM_CONST.DNS_RECORD_TYPE_TLSA, dns_query_type = "TSIG", XDM_CONST.DNS_RECORD_TYPE_TSIG, dns_query_type = "TXT", XDM_CONST.DNS_RECORD_TYPE_TXT, dns_query_type = "URI", XDM_CONST.DNS_RECORD_TYPE_URI, dns_query_type = "ZONEMD", XDM_CONST.DNS_RECORD_TYPE_ZONEMD, dns_query_type),
    vm_region = arrayindex(regextract(vm_zone_name, "(\S+)\-\w+"), 0)
| alter 
    destination_ipv4 = if(destination_ip ~= "(?:\d{1,3}\.){3}\d{1,3}", destination_ip),
    destination_ipv6 = if(destination_ip ~= "(?:[a-fA-F\d]{0,4}\:){1,7}[a-fA-F\d]{0,4}", destination_ip),
    dns_class_number = if(dns_class = "IN", 1, dns_class = "CS", 2, dns_class = "CH", 3, dns_class = "HS", 4), // see https://datatracker.ietf.org/doc/html/rfc1035#section-3.2.4
    dns_records = coalesce(if(
        dns_query_type = "A", arraystring(regextract(dns_rdata, "((?:\d{1,3}\.){3}\d{1,3})"), ","), // ipv4 records
        dns_query_type = "AAAA", arraystring(regextract(dns_rdata, "((?:[a-fA-F\d]{0,4}\:){1,7}[a-fA-F\d]{0,4})"), ","), // ipv6 records
        dns_query_type in ("CNAME", "PTR", "NS"), arraystring(regextract(dns_rdata, "(?i)(?:\s+|\\t)(?:CNAME|PTR|NS)(?:\s+|\\t)(\S+)\.?"), ",")), // domains,  
        dns_rdata), // default fallback
    source_ipv4 = if(source_ip ~= "(?:\d{1,3}\.){3}\d{1,3}", source_ip),
    source_ipv6 = if(source_ip ~= "(?:[a-fA-F\d]{0,4}\:){1,7}[a-fA-F\d]{0,4}", source_ip)
| alter // XDM mappings
    xdm.event.outcome = if(dns_rcode = "NOERROR", XDM_CONST.OUTCOME_SUCCESS, dns_rcode != "NOERROR" and dns_rcode != null and dns_rcode != "", XDM_CONST.OUTCOME_FAILED),
    xdm.network.dns.authoritative = to_boolean(uppercase(jsonPayload -> authAnswer)), // Authoritative answer, RFC 1035
    xdm.network.dns.dns_question.class = dns_class_number,
    xdm.network.dns.dns_question.name = dns_query_name,
    xdm.network.dns.dns_question.type = dns_record_type,
    xdm.network.dns.dns_resource_record.class = dns_class_number,
    xdm.network.dns.dns_resource_record.name = dns_query_name,
    xdm.network.dns.dns_resource_record.type = if(dns_rdata != null, dns_record_type),
    xdm.network.dns.dns_resource_record.value = if(dns_records != null and dns_records != "", dns_records, dns_rdata),
    xdm.network.dns.is_response = if(dns_rcode != null, true, dns_rcode = null and dns_rdata = null, false),
    xdm.network.dns.response_code = if(dns_rcode = "NOERROR", XDM_CONST.DNS_RESPONSE_CODE_NO_ERROR, dns_rcode = "FORMERR", XDM_CONST.DNS_RESPONSE_CODE_FORMAT_ERROR, dns_rcode = "SERVFAIL", XDM_CONST.DNS_RESPONSE_CODE_SERVER_FAILURE, dns_rcode = "NXDOMAIN", XDM_CONST.DNS_RESPONSE_CODE_NON_EXISTENT_DOMAIN, dns_rcode = "NOTIMP", XDM_CONST.DNS_RESPONSE_CODE_NOT_IMPLEMENTED, dns_rcode = "REFUSED", XDM_CONST.DNS_RESPONSE_CODE_QUERY_REFUSED, dns_rcode = "YXDOMAIN", XDM_CONST.DNS_RESPONSE_CODE_NAME_EXISTS_WHEN_IT_SHOULD_NOT, dns_rcode = "YXRRSET", XDM_CONST.DNS_RESPONSE_CODE_RR_SET_EXISTS_WHEN_IT_SHOULD_NOT, dns_rcode = "NXRRSET", XDM_CONST.DNS_RESPONSE_CODE_RR_SET_THAT_SHOULD_EXIST_DOES_NOT, dns_rcode = "NOTAUTH", XDM_CONST.DNS_RESPONSE_CODE_SERVER_NOT_AUTHORITATIVE_FOR_ZONE, dns_rcode = "NOTZONE", XDM_CONST.DNS_RESPONSE_CODE_NAME_NOT_CONTAINED_IN_ZONE, dns_rcode = "BADVERS", XDM_CONST.DNS_RESPONSE_CODE_BAD_OPT_VERSION, dns_rcode = "BADSIG", XDM_CONST.DNS_RESPONSE_CODE_TSIG_SIGNATURE_FAILURE, dns_rcode = "BADKEY", XDM_CONST.DNS_RESPONSE_CODE_KEY_NOT_RECOGNIZED, dns_rcode = "BADTIME", XDM_CONST.DNS_RESPONSE_CODE_SIGNATURE_OUT_OF_TIME_WINDOW, dns_rcode = "BADMODE", XDM_CONST.DNS_RESPONSE_CODE_BAD_TKEY_MODE, dns_rcode = "BADNAME", XDM_CONST.DNS_RESPONSE_CODE_DUPLICATE_KEY_NAME, dns_rcode = "BADALG", XDM_CONST.DNS_RESPONSE_CODE_ALGORITHM_NOT_SUPPORTED, dns_rcode = "BADTRUNC", XDM_CONST.DNS_RESPONSE_CODE_BAD_TRUNCATION, dns_rcode),
    xdm.network.ip_protocol = if(ip_protocol = "UDP", XDM_CONST.IP_PROTOCOL_UDP, ip_protocol = "TCP", XDM_CONST.IP_PROTOCOL_TCP, ip_protocol),
    xdm.source.agent.identifier = vm_instance_id,
    xdm.source.cloud.project_id = jsonPayload -> vmProjectId, // Google Cloud project ID of the network from which the query was sent, only applicable to queries initiated by Compute Engine VMs,
    xdm.source.cloud.region = vm_region,
    xdm.source.cloud.zone = jsonPayload -> vmZoneName, // Name of the VM zone from which the query was sent, only applicable to queries initiated by Compute Engine VMs
    xdm.source.host.device_category = resource -> labels.source_type, // Source of the query: inbound-forwarding, gce-vm
    xdm.source.host.device_id = vm_instance_id,
    xdm.source.host.hostname = jsonPayload -> vmInstanceName,  // Compute Engine VM instance name, only applicable to queries initiated by Compute Engine VMs
    xdm.source.ipv4 = source_ipv4,
    xdm.source.ipv6 = source_ipv6,
    xdm.source.zone = vm_zone_name,
    xdm.target.cloud.region = resource -> labels.location,
    xdm.target.ipv4 = destination_ipv4,
    xdm.target.ipv6 = destination_ipv6,
    xdm.target.resource.sub_type = resource -> labels.target_type, // Type of target resolving the DNS query: private-zone, forwarding-zone, forwarding-policy, peering-zone, internal, external
    xdm.target.resource.name = resource -> labels.target_name; // The target name, for example zone name, policy name, internal zone name, external domain name