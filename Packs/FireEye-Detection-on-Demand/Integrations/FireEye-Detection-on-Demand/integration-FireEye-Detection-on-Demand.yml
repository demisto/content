commonfields:
  id: FireEye Detection on Demand
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: FireEye Detection on Demand
display: FireEye Detection on Demand (Developer Contribution)
category: Forensics & Malware Analysis
description: FireEye Detection On Demand is a threat detection service delivered as an API for integration into the SOC workflow, SIEM analytics, data repositories, or web applications, etc. It delivers flexible file and content analysis to identify malicious behavior wherever the enterprise needs it.
configuration:
- display: "DoD hostname"
  name: url
  defaultvalue: https://feapi.marketplace.apps.fireeye.com
  type: 0
  required: true
- display: API Key
  name: apikey
  type: 4
  required: true
  additionalinfo: "Visit https://fireeye.dev/docs/detection-on-demand for more information on generating API keys"
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
script:
  script: >
    import json

    import traceback

    from typing import Any, Dict, List, Optional, Tuple, cast


    import dateparser


    import requests



    # Disable insecure warnings

    requests.packages.urllib3.disable_warnings()



    ''' CONSTANTS '''



    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'


    ''' CLIENT CLASS '''



    class Client(BaseClient):
        """Client class to interact with the service API

        This Client implements API calls, and does not contain any Demisto logic.
        Should only do requests and return data.
        It inherits from BaseClient defined in CommonServer Python.
        Most calls use _http_request() that handles proxy, SSL verification, etc.
        For this HelloWorld implementation, no special attributes defined
        """

        def get_file_reputation(self, file: str) -> Dict[str, Any]:
            return self._http_request(
                method='GET',
                url_suffix=f'/hashes/{file}'
            )

        def get_health(self) -> Dict[str, Any]:
            return self._http_request(
                method='GET',
                url_suffix=f'/health'
            )

        def submit_file(self, files: Dict[str, Any], data: Dict[str, Any]) -> Dict[str, Any]:
            return self._http_request(
                method='POST',
                url_suffix='/files',
                files=files,
                data=data
            )

        def submit_urls(self, data: Dict[str, Any]) -> Dict[str, Any]:
            return self._http_request(
                method='POST',
                url_suffix='/urls',
                files=data,
                data=None
            )

        def get_report_url(self, report_id: str, expiration: int) -> Dict[str, Any]:
            return self._http_request(
                method='GET',
                url_suffix=f'/presigned-url/{report_id}',
                params={
                    'expiry': expiration
                }
            )

        def report_status(self, report_id: str, extended: str) -> Dict[str, Any]:
            return self._http_request(
                method='GET',
                url_suffix=f'/reports/{report_id}',
                params={
                    'extended': extended
                }
            )

        def report_artifact(self, report_id: str, artifact_type: str) -> Dict[str, Any]:
            return self._http_request(
                method='GET',
                url_suffix=f'/artifacts/{report_id}',
                params={
                    'type': artifact_type,
                },
                resp_type='content'
            )

    ''' HELPER FUNCTIONS '''



    def convert_to_demisto_severity(severity: str) -> int:
        # In this case the mapping is straightforward, but more complex mappings
        # might be required in your integration, so a dedicated function is
        # recommended. This mapping should also be documented.
        return {
            'Low': 1,  # low severity
            'Medium': 2,  # medium severity
            'High': 3,  # high severity
            'Critical': 4   # critical severity
        }[severity]


    def arg_to_int(arg: Any, arg_name: str, required: bool = False) -> Optional[int]:
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None
        if isinstance(arg, str):
            if arg.isdigit():
                return int(arg)
            raise ValueError(f'Invalid number: "{arg_name}"="{arg}"')
        if isinstance(arg, int):
            return arg
        raise ValueError(f'Invalid number: "{arg_name}"')


    def arg_to_timestamp(arg: Any, arg_name: str, required: bool = False) -> Optional[int]:
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None

        if isinstance(arg, str) and arg.isdigit():
            # timestamp is a str containing digits - we just convert it to int
            return int(arg)
        if isinstance(arg, str):
            # we use dateparser to handle strings either in ISO8601 format, or
            # relative time stamps.
            # For example: format 2019-10-23T00:00:00 or "3 days", etc
            date = dateparser.parse(arg, settings={'TIMEZONE': 'UTC'})
            if date is None:
                # if d is None it means dateparser failed to parse it
                raise ValueError(f'Invalid date: {arg_name}')

            return int(date.timestamp())
        if isinstance(arg, (int, float)):
            # Convert to int if the input is a float
            return int(arg)
        raise ValueError(f'Invalid date: "{arg_name}"')


    ''' COMMAND FUNCTIONS '''



    def test_module(client: Client) -> str:
        # INTEGRATION DEVELOPER TIP
        # Client class should raise the exceptions, but if the test fails
        # the exception text is printed to the Cortex XSOAR UI.
        # If you have some specific errors you want to capture (i.e. auth failure)
        # you should catch the exception here and return a string with a more
        # readable output (for example return 'Authentication Error, API Key
        # invalid').
        # Cortex XSOAR will print everything you return different than 'ok' as
        # an error
        try:
            #
            client.get_health()
        except DemistoException as e:
            if 'Forbidden' in str(e):
                return 'Authorization Error: make sure API Key is correctly set'
            else:
                raise e
        return 'ok'


    def get_hashes_command(client: Client, args: Dict[str, Any]) -> Tuple[str, dict, Any]:

        hashes = argToList(args.get('md5_hashes'))
        if len(hashes) == 0:
            raise ValueError('hash(es) not specified')

        for hash in hashes:
            if md5Regex.match(hash):
                continue
            raise Exception('Invalid hash. Only MD5 is supported.')
        default_threshold = 60
        threshold = int(args.get('threshold', default_threshold))

        dbot_score_list: List[Dict[str, Any]] = []
        file_standard_list: List[Dict[str, Any]] = []
        file_data_list: List[Dict[str, Any]] = []

        for hash in hashes:
            file_data = client.get_file_reputation(hash)
            file_data['MD5'] = file_data['md5']
            del file_data['md5']
            # demisto.results(file_data)
            engines = file_data.get('engine_results', {})
            for key in engines.keys():
                if engines[key].get('sha256'):
                    file_data['SHA256'] = engines[key].get('sha256')
                    del engines[key]['sha256']
            # If the outer `is_malicious` is set to True, assume the score should be bad
            # Otherwise, default to unknown unless at least one engine has returned a verdict besides `not_found`
            if file_data['is_malicious']:
                score = 3  # bad
            else:
                score = 0  # unknown
                for key in engines.keys():
                    if engines[key].get('verdict', 'not_found') != "not_found" and engines[key].get('verdict', 'not_found') != "malicious":
                        score = 1  # good
                        break

            dbot_score = {
                'Indicator': hash,
                'Vendor': 'FireEye DoD',
                'Type': 'file',
                'Score': score
            }
            file_standard_context = {
                'MD5': hash,
            }

            if score == 3:
                # if score is bad must add DBotScore Vendor and Description
                file_standard_context['Malicious'] = {
                    'Vendor': 'FireEye DoD'
                }

            filedata = {}
            filedata['FireEyeDoD'] = file_data
            filedata['MD5'] = file_data['MD5']
            del filedata['FireEyeDoD']['MD5']
            if file_data.get('SHA256'):
                dbot_score_sha256 = {
                    'Indicator': file_data.get('SHA256'),
                    'Vendor': 'FireEye DoD',
                    'Type': 'file',
                    'Score': score
                }
                dbot_score_list.append(dbot_score_sha256)
                filedata['SHA256'] = file_data['SHA256']
                file_standard_context['SHA256'] = file_data['SHA256']
                del filedata['FireEyeDoD']['SHA256']

            file_standard_list.append(file_standard_context)
            dbot_score_list.append(dbot_score)
            file_data_list.append(filedata)

        outputs = {
            'DBotScore(val.Vendor == obj.Vendor && val.Indicator == obj.Indicator)': dbot_score_list,
            outputPaths['file']: file_standard_list,
            'File(val.MD5 == obj.MD5 || val.SHA256 == obj.SHA256)': file_data_list
        }

        readable_output = tableToMarkdown('FireEye DoD Results', file_standard_list, headers=["MD5", "SHA256", "Malicious"])

        return (
            readable_output,
            outputs,
            file_data_list
        )


    def generate_report_url(client: Client, args: Dict[str, Any]) -> Tuple[str, dict, dict]:
        report_id = args.get('report_id')
        expiration = arg_to_int(arg=args.get('expiration'), arg_name='expiration', required=True)
        if expiration:
            if expiration < 1 or expiration > 8760:
                raise ValueError('Expiration must be between 1 and 8760 hours.')
        else:
            raise ValueError('Expiration not specified or not a number.')

        report = client.get_report_url(report_id=report_id, expiration=expiration)
        presigned_report_url = report.get('presigned_report_url')

        readable_output = f'Report {report_id} is available [here]({presigned_report_url})'

        return (
            readable_output,
            {},
            report
        )


    def submit_file_command(client: Client, args: Dict[str, Any]) -> Tuple[str, dict, dict]:
        entry_id = demisto.args().get('entryID')
        file_entry = demisto.getFilePath(entry_id)  # .get('path')
        file_name = file_entry['name']
        file_path = file_entry['path']
        files = {'file': (file_name, open(file_path, 'rb'))}

        # Optional parameters to send along with the file
        optional_params = ['password', 'param', 'screenshot', 'video', 'fileExtraction', 'memoryDump', 'pcap']
        data = {} 
        for param in optional_params:
            value = demisto.args().get(param)
            if value:
                data[param] = value

        scan = client.submit_file(files=files, data=data)

        scan['filename'] = file_name
        del scan['status']
        scan['overall_status'] = 'RUNNING'

        report_id = scan.get('report_id')

        readable_output = f'Started analysis of {file_name} with FireEye Detection on Demand. Results will be published to report id: {report_id}'
        outputs = {
            'FireEyeDoD.Scan(val.report_id == obj.report_id)': scan
        }
        return (
            readable_output,
            outputs,
            scan
        )


    def submit_urls_command(client: Client, args: Dict[str, Any]) -> Tuple[str, dict, dict]:
        urls = argToList(args.get('urls'))
        if len(urls) == 0:
            raise ValueError('hash(es) not specified')

        # Format the URLs into a string list, which the API understands
        formatted_urls = "[" + ",".join(list(map(lambda url: url.replace(url, f'"{url}"'), urls))) + "]"
        data = { 'urls': formatted_urls }
        
        scan = client.submit_urls(data=data)

        del scan['status']
        scan['overall_status'] = 'RUNNING'

        report_id = scan.get('report_id')

        readable_output = f'Started analysis of {urls} with FireEye Detection on Demand. Results will be published to report id: {report_id}'
        outputs = {
            'FireEyeDoD.Scan(val.report_id == obj.report_id)': scan
        }
        return (
            readable_output,
            outputs,
            scan
        )


    def get_reports_command(client: Client, args: Dict[str, Any]) -> Tuple[str, dict, Any]:
        report_id_list = argToList(args.get('report_ids', []))
        extended = args.get('extended_report', "False")
        screenshot = args.get('get_screenshot', "false")
        artifact = args.get('get_artifact', "")
        if len(report_id_list) == 0:
            raise ValueError('report_id(s) not specified')

        report_list: List[Dict[str, Any]] = []
        for report_id in report_id_list:
            report = client.report_status(report_id=report_id, extended=extended)
            if screenshot.lower() == "true":
                screenshot = client.report_artifact(report_id=report_id, artifact_type="screenshot")
                stored_img = fileResult('screenshot.gif', screenshot)
                demisto.results({'Type': entryTypes['image'], 'ContentsFormat': formats['text'],
                                 'File': stored_img['File'], 'FileID': stored_img['FileID'], 'Contents': ''})

            if artifact != "":
                artifacts = client.report_artifact(report_id=report_id, artifact_type=artifact)
                stored_artifacts = fileResult('artifacts.zip', artifacts)
                demisto.results({'Type': entryTypes['file'], 'ContentsFormat': formats['text'],
                                 'File': stored_artifacts['File'], 'FileID': stored_artifacts['FileID'], 'Contents': ''})

            report_list.append(report)

        readable_output = tableToMarkdown('Scan status', report_list)
        outputs = {
            'FireEyeDoD.Scan(val.report_id == obj.report_id)': report_list
        }
        return (
            readable_output,
            outputs,
            report_list
        )

    ''' MAIN FUNCTION '''



    def main() -> None:
        """main function, parses params and runs command functions

        :return:
        :rtype:
        """

        api_key = demisto.params().get('apikey')

        # get the service API url
        base_url = demisto.params()['url']

        # if your Client class inherits from BaseClient, SSL verification is
        # handled out of the box by it, just pass ``verify_certificate`` to
        # the Client constructor
        verify_certificate = not demisto.params().get('insecure', False)

        # if your Client class inherits from BaseClient, system proxy is handled
        # out of the box by it, just pass ``proxy`` to the Client constructor
        proxy = demisto.params().get('proxy', False)

        # INTEGRATION DEVELOPER TIP
        # You can use functions such as ``demisto.debug()``, ``demisto.info()``,
        # etc. to print information in the XSOAR server log. You can set the log
        # level on the server configuration
        # See: https://xsoar.pan.dev/docs/integrations/code-conventions#logging

        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            headers = {
                'feye-auth-key': f'{api_key}'
            }
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                headers=headers,
                proxy=proxy)

            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                result = test_module(client)
                demisto.results(result)

            elif demisto.command() == 'fireeye-dod-get-hashes':
                return_outputs(*get_hashes_command(client, demisto.args()))

            elif demisto.command() == 'fireeye-dod-get-reports':
                return_outputs(*get_reports_command(client, demisto.args()))

            elif demisto.command() == 'fireeye-dod-submit-file':
                return_outputs(*submit_file_command(client, demisto.args()))

            elif demisto.command() == 'fireeye-dod-submit-urls':
                return_outputs(*submit_urls_command(client, demisto.args()))

            elif demisto.command() == 'fireeye-dod-get-report-url':
                return_outputs(*generate_report_url(client, demisto.args()))

        # Log exceptions and return errors
        except Exception as e:
            raise e
            # demisto.error(traceback.format_exc())  # print the traceback
            # return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''



    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  dockerimage: demisto/python3:3.8.2.6981
  runonce: false
  subtype: python3
  commands:
  - name: fireeye-dod-get-hashes
    arguments:
    - name: md5_hashes
      default: true
      description: One or more comma separated MD5 hashes to get the reputation of.
      isArray: true
      required: true
      secret: false
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: File.Malicious.Vendor
      description: "N/A"
    - contextPath: File.MD5
      description: The MD5 hash of the file
    - contextPath: FireEyeDoD.engine_results.cache_lookup.sha256
      description: The sha256 value of the file
      type: String
    - contextPath: FireEyeDoD.engine_results.cache_lookup.signature_name
      description: The name of the virus signature
      type: String
    - contextPath: FireEyeDoD.engine_results.cache_lookup.is_malicious
      description: True/False if the file is malicious
      type: Number
    - contextPath: FireEyeDoD.engine_results.cache_lookup.verdict
      description: The overall verdict of all analysis engines
      type: String
    - contextPath: FireEyeDoD.engine_results.cache_lookup.file_extension
      description: The extension of the file
      type: String
    - contextPath: FireEyeDoD.engine_results.cache_lookup.weight
      description: How important this engine result is to determining malicious activity
      type: Number
    - contextPath: FireEyeDoD.engine_results.dynamic_analysis.verdict
      description: This particular engine's verdict on whether or not the file is malicious
      type: String
    - contextPath: FireEyeDoD.engine_results.av_lookup.verdict
      description: This particular engine's verdict on whether or not the file is malicious
      type: String
    - contextPath: FireEyeDoD.engine_results.avs_lookup.verdict
      description: This particular engine's verdict on whether or not the file is malicious
      type: String
    - contextPath: FireEyeDoD.engine_results.dti_lookup.verdict
      description: This particular engine's verdict on whether or not the file is malicious
      type: String
    - contextPath: FireEyeDoD.md5
      description: The MD5 hash of the file
      type: String
    - contextPath: FireEyeDoD.is_malicious
      description: True/False if the file is malicious
      type: Number
    description: Queries FireEye Detection on Demand reports for the provided md5 hashes
  - name: fireeye-dod-submit-file
    arguments:
    - name: entryID
      required: true
      default: true
      description: The file entry ID to submit.
    - name: password
      required: false
      description: Password to be used by the detection engine to decrypt a password protected file.
    - name: param
      required: false
      description: Command line parameter(s) to be used by detection engine when running the file. Mainly applicable to .exe files. For example, setting param to "start -h localhost -p 5555" will make the detection engine run a file named "malicious.exe" as "malicious.exe start -h localhost -p 5555".
    - name: screenshot
      required: false
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      defaultValue: "False"
      description: Extract screenshot of screen activity during dynamic analysis if true, which later can be downloaded with artifacts api
    - name: video
      required: false
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      defaultValue: "False"
      description: Extract video activity during dynamic analysis if true, which later can be downloaded with artifacts api
    - name: fileExtraction
      required: false
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      defaultValue: "False"
      description: Extract dropped files from vm during dynamic analysis if true, which later can be downloaded with artifacts api
    - name: memoryDump
      required: false
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      defaultValue: "False"
      description: Extract memory dump files from vm during dynamic analysis if true, which later can be downloaded with artifacts api
    - name: pcap
      required: false
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      defaultValue: "False"
      description: Extract pcap files from vm during dynamic analysis if true, which later can be downloaded with artifacts api
    outputs:
    - contextPath: FireEyeDoD.Scan.report_id
      description: The report ID can be used to query the status and results of the file submission
    - contextPath: FireEyeDoD.Scan.status
      description: The current status of the file submission
    - contextPath: FireEyeDoD.Scan.filename
      description: The name of the file that was submitted
    description: Submits file to FireEye Detection on Demand for analysis
  - name: fireeye-dod-submit-urls
    arguments:
    - name: urls
      required: true
      default: true
      isArray: true
      description: A comma separated list of URLs to scan.  Maximum of 10 per request.
    outputs:
    - contextPath: FireEyeDoD.Scan.report_id
      description: The ID of the report
    - contextPath: FireEyeDoD.Scan.status
      description: The status of the file submission.  Will be "DONE" when all engines are finished.
    description: Submits URLs to FireEye Detection on Demand for analysis
  - name: fireeye-dod-get-reports
    arguments:
    - name: report_ids
      description: A comma separated list of one or more report IDs to fetch.
      required: true
      isArray: true
    - name: extended_report
      description: If True, additional information will be returned
      required: false
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      defaultValue: "False"
    - name: get_screenshot
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Whether or not to get screenshot artifacts from the report
      defaultValue: "False"
    - name: get_artifact
      auto: PREDEFINED
      predefined:
      - all
      - screenshot
      description: Which report artifacts to retrieve (if any)
    outputs:
    - contextPath: FireEyeDoD.Scan.report_id
      description: The ID of the report
      type: String
    - contextPath: FireEyeDoD.Scan.overall_status
      description: The overall status of all of the engines
      type: String
    - contextPath: FireEyeDoD.Scan.is_malicious
      description: True/False if the file is malicious
      type: Number
    - contextPath: FireEyeDoD.Scan.started_at
      description: The UTC time the scan was started
      type: Date
    - contextPath: FireEyeDoD.Scan.completed_at
      description: The UTC time the scan was completed
      type: Date
    - contextPath: FireEyeDoD.Scan.duration
      description: How long, in seconds, the scan took to complete.
      type: Number
    - contextPath: FireEyeDoD.Scan.file_name
      description: The name of the submitted file
      type: String
    - contextPath: FireEyeDoD.Scan.file_size
      description: The size of the file in bytes
      type: Number
    - contextPath: FireEyeDoD.Scan.file_extension
      description: The extension of the submitted file.  If a URL was submitted, this will be empty.
      type: String
    - contextPath: FireEyeDoD.Scan.md5
      description: The MD5 hash of the submitted file
      type: String
    - contextPath: FireEyeDoD.Scan.sha256
      description: The sha256 hash of the submitted file
      type: String
    - contextPath: FireEyeDoD.Scan.signature_name
      description: List of signatures extracted by all engines
      type: String
    description: Retrieves one or more reports of file scans
  - name: fireeye-dod-get-report-url
    arguments:
    - name: report_id
      description: The ID of the report to fetch
      required: true
    - name: expiration
      required: false
      default: true
      description: Expiration (in hours) for browser viewable report pre-signed URL link. Default value is 72 hours.  Minimum is 1 hour, and maximum is 8760 hours (365 days).
      defaultValue: "72"
    description: Generates a pre-signed URL for a report

image: data:image/png;base64,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
detaileddescription: >-
  ### Developer Contributed Integration

  #### Integration Author: FireEye Inc.

  Support and maintenance for this integration are provided by the author. Please use the following contact details:

  - **Email**: [developers@fireeye.com](mailto:developers@fireeye.com)

  - **URL**: [https://fireeye.dev/docs/detection-on-demand](https://fireeye.dev/docs/detection-on-demand)

  ***

  ## Hello World

  - This section explains how to configure the instance of HelloWorld in Cortex XSOAR.

  - You can use the following API Key: `43ea9b2d-4998-43a6-ae91-aba62a26868c`
