args:
- defaultValue: created:>="30 days ago" and type:"Phishing"
  description: Query of the phishing incidents.
  name: incidentsQuery
- defaultValue: '2000'
  description: Maximum number of incidents
  name: maxNumberOfIncidents
- defaultValue: name
  description: Incident key to extract email text
  name: emailTextKey
- defaultValue: name
  description: Incident key to extract email subject
  name: emailSubjectKey
- defaultValue: closeReason
  description: Incident key to extract email tag
  name: tagKey
- defaultValue: '*'
  description: 'Comma-separated values of email tags values and mapping (or "*" value
    for all labels). The script going to consider only the tags specify in this field.
    You can map label to another value by using this format: LABEL:MAPPED_LABEL. For
    example: let''s say we have 4 values in email tag: malicious, credentials harvesting,
    inner communitcation, external legit email, unclassified. While training, we want
    to ignore "unclassified" tag, and refer to "credentials harvesting" as "malicious"
    too. Also, we want to merge "inner communitcation" and "external legit email"
    to one tag called "non-malicious". The input will be: malicious, credentials harvesting:malicious,
    inner communitcation:non-malicious, external legit email:non-malicious'
  name: phishingLabels
- auto: PREDEFINED
  defaultValue: 'yes'
  description: Does one of the fields is in the context data?
  name: isContextNeeded
  predefined:
  - 'yes'
  - 'no'
- auto: PREDEFINED
  defaultValue: 'no'
  description: Hash the words of the email
  name: hashData
  predefined:
  - 'yes'
  - 'no'
- description: 'List name: store the file in this list as base64 (compressed).'
  name: storeFileInList
comment: This script is deprecated. See https://xsoar.pan.dev/docs/reference/playbooks/d-bot-create-phishing-classifier-v2
  for more information.
commonfields:
  id: DBotPreparePhishingData
  version: -1
deprecated: true
dockerimage: demisto/dl:1.1
enabled: true
fromversion: 4.1.0
name: DBotPreparePhishingData
outputs:
- contextPath: DBotPreparePhishingDataFilename
  description: 'The path of the training file. '
  type: string
runonce: true
script: "import base64, uuid, re, zlib\nimport demisto_ml\n\nTRAIN_FILE_NAME = str(uuid.uuid4())\
  \ + \".train\"\nALL_LABELS = \"*\"\nTAG_PREFIX = demisto_ml.DEFAULT_LABEL_PREFIX\n\
  \ndef get_context(incident_id):\n    res = demisto.executeCommand(\"getContext\"\
  , {'id': incident_id})\n    try:\n      return res[0]['Contents'].get('context')\
  \ or {}\n    except:\n      return {}\n\ndef canonize_label(label):\n    if label:\n\
  \        return label.lower().strip().replace(\" \",\"_\")\n\ndef get_phishing_map_labels(comma_values):\n\
  \    if comma_values == ALL_LABELS:\n        return comma_values\n    comma_values\
  \ = comma_values.lower()\n    values = map(lambda x: x.strip(), comma_values.split(\"\
  ,\"))\n    labels_dict = {}\n    for v in values:\n        v = v.strip()\n     \
  \   if \":\" in v:\n            splited = v.split(\":\")\n            labels_dict[canonize_label(splited[0].strip())]\
  \ = canonize_label(splited[1].strip())\n        else:\n            labels_dict[canonize_label(v)]\
  \ = canonize_label(v)\n    return labels_dict\n\ndef get_incidents(query, size,\
  \ is_context_data_needed):\n    res = demisto.executeCommand(\"getIncidents\", {\"\
  query\": query, \"size\": size, \"sort\": \"created\"})\n    if res[0]['Type'] ==\
  \ entryTypes['error']:\n        return_error(str(res[0]['Contents']))\n    incident_list\
  \ = res[0]['Contents'].get('data') or []\n\n    for i in incident_list:\n      \
  \  # we flat the custom field to the incident structure, like in the context\n \
  \       custom_fields = i.get('CustomFields', {}) or {}\n        if is_context_data_needed:\n\
  \            i.update(get_context(i['id']))\n        i.update(custom_fields)\n\n\
  \    return incident_list\n\n\nEMAIL_TEXT_DT = demisto.args()['emailTextKey']\n\
  EMAIL_SUBJECT_DT = demisto.args()['emailSubjectKey']\nTAG_DT = demisto.args()['tagKey']\n\
  PHISHING_LABELS = get_phishing_map_labels(demisto.args()['phishingLabels'])\nIS_CONTEXNT_DATA_NEEDED\
  \ = (demisto.args()['isContextNeeded'] == 'yes')\nHASH_WORDS = (demisto.args()['hashData']\
  \ == 'yes')\nLIST_NAME_TO_STORE = demisto.args().get('storeFileInList')\nHASH_SEED\
  \ = 5381\nMAX_INCIDENTS = int(demisto.args()['maxNumberOfIncidents'])\n\n# get the\
  \ incidents for training\nincidents = get_incidents(demisto.args()['incidentsQuery'],\
  \ MAX_INCIDENTS, IS_CONTEXNT_DATA_NEEDED)\n# parse the incidents\nskipped_empty\
  \ = 0\nskipped_missing_labels = 0\nskipped_invalid_label = 0\nskipped_missing_body\
  \ = 0\nskipped_exception = 0\nlabels_value_counts = {}\ndata_texts = []\ndata_labels\
  \ = []\nskipped_labels = []\nif len(incidents) == MAX_INCIDENTS:\n    demisto.log('Number\
  \ of results returned from incidentsQuery has reached the limit (maxNumberOfIncidents=%d).\
  \ Consider increase maxNumberOfIncidents to train on more data.' % MAX_INCIDENTS)\n\
  for i in incidents:\n    try:\n        text = (demisto.dt(i, EMAIL_TEXT_DT) or \"\
  \")\n        subject = (demisto.dt(i, EMAIL_SUBJECT_DT) or \"\")\n        if not\
  \ text and not subject:\n            skipped_empty += 1\n            continue\n\
  \        original_label = canonize_label(demisto.dt(i, TAG_DT))\n        if not\
  \ original_label:\n            skipped_missing_labels += 1\n            continue\n\
  \        if demisto.args()['phishingLabels'] != ALL_LABELS and original_label not\
  \ in PHISHING_LABELS:\n            skipped_invalid_label += 1\n            skipped_labels.append(original_label)\n\
  \            continue\n        original_label = PHISHING_LABELS.get(original_label)\
  \ if demisto.args()['phishingLabels'] != ALL_LABELS else original_label\n      \
  \  if isinstance(text, basestring) and isinstance(subject, basestring) and isinstance(original_label,\
  \ basestring):\n            full_txt = \"%s %s\" % (subject, text)\n           \
  \ labels_value_counts[original_label] = labels_value_counts.get(original_label,\
  \ 0) + 1\n            data_texts.append(full_txt)\n            data_labels.append(original_label)\n\
  \    except Exception, e:\n        skipped_exception += 1\n        demisto.log(\"\
  Error parsing: \" + str(e))\n        continue\ndef store_data_as_list(data, listname):\n\
  \    try:\n        data = zlib.compress(data)\n        res = demisto.executeCommand(\"\
  createList\", {\"listName\": listname,\"listData\": base64.encodestring(data)})\n\
  \        if isError(res[0]):\n            demisto.results(res[0])\n            return\n\
  \        demisto.log(\"Stored file successfully in list \" + listname)\n    except:\n\
  \        demisto.results({\n          'Type': entryTypes['error'],\n          'ContentsFormat':\
  \ formats['text'],\n          'Contents': \"Error storing file in list \" + listname\n\
  \        })\n\n\n# tokenize text and remove empty strings\nres = demisto.executeCommand('WordTokenizer',\
  \ {'value': data_texts, 'hashWordWithSeed': HASH_SEED if HASH_WORDS else None, 'type':\
  \ 'punkt'})\nif isError(res[0]):\n    demisto.results(res)\n    sys.exit(0)\ndata_texts\
  \ = res[0]['Contents']\nif type(data_texts) is not list:\n    data_texts = [data_texts]\n\
  data = [{'txt': txt, 'label': label} for (txt, label) in zip(data_texts, data_labels)]\n\
  skipped_empty += len([x for x in data if len(x['txt']) == 0])\ndata = [x for x in\
  \ data if len(x['txt']) > 0]\n\nif skipped_empty > 0:\n    demisto.log(\"%d incidents\
  \ skipped due to missing text or subject\" % skipped_empty)\nif skipped_missing_labels\
  \ > 0:\n    demisto.log(\"%d incidents skipped due to missing label.\" % skipped_missing_labels)\n\
  if skipped_invalid_label > 0:\n    skipped_labels_str = \",\".join(set(skipped_labels))\n\
  \    demisto.log(\"%d incidents skipped due to label was that not defined in phishingLabels\
  \ value. Skipped labels:\\n%s\" % (skipped_invalid_label, skipped_labels_str))\n\
  if skipped_exception > 0:\n    demisto.log(\"%d incidents skipped due to exception\
  \ in parsing\" % skipped_exception)\n\nif len(data) == 0:\n    return_error(\"There\
  \ is no data to train\")\n\nlabels_value_counts_hr = [{'Email Label': k, 'Count':\
  \ v} for k,v in labels_value_counts.items()]\ndemisto.results({\n    'Type': entryTypes['note'],\n\
  \    'Contents': data,\n    'ContentsFormat': formats['json'],\n    'HumanReadable':\
  \ tableToMarkdown('Training Data', labels_value_counts_hr),\n    'HumanReadableFormat':\
  \ formats['markdown']\n})\n\nfile_lines = map(lambda x: x['txt'] + ' %s%s' % (TAG_PREFIX,\
  \ x['label']), data)\ntxt_to_write = \"\\n\".join(file_lines)\ndata_to_write = txt_to_write.encode('utf-8').lower()\n\
  file_entry = fileResult(TRAIN_FILE_NAME, data_to_write)\nif LIST_NAME_TO_STORE:\n\
  \    store_data_as_list(data_to_write, LIST_NAME_TO_STORE)\ndemisto.results(file_entry)\n\
  demisto.setContext('DBotPreparePhishingDataFilename', TRAIN_FILE_NAME)\n\n\n"
scripttarget: 0
subtype: python2
tags:
- ml
- phishing
tests:
- CreatePhishingClassifierMLTest
timeout: "12\xB5s"
toversion: 4.1.9
type: python
