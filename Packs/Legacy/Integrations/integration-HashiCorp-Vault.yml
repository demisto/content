commonfields:
  id: HashiCorp Vault
  version: -1
name: HashiCorp Vault
display: HashiCorp Vault
category: Authentication
image: data:image/png;base64,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 # guardrails-disable-line
description: Manage Secrets and Protect Sensitive Data through HashiCorp Vault
configuration:
- display: HashiCorp server URL (e.g., https://192.168.0.1:8200)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: false
- display: Authentication token
  name: token
  defaultvalue: ""
  type: 4
  required: false
- display: Trust any certificate (not secure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetches credentials
  name: isFetchCredentials
  defaultvalue: "true"
  type: 8
  required: false
- display: CSV list of secrets engine types to fetch secrets from
  name: engines
  defaultvalue: KV,Cubbyhole
  type: 0
  required: false
script:
  script: |-
    import requests
    import json
    import hcl

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' GLOBAL VARIABLES '''

    CREDENTIALS = demisto.params().get('credentials', {})
    USERNAME = None
    PASSWORD = None
    if CREDENTIALS:
        USERNAME = CREDENTIALS.get('identifier')
        PASSWORD = CREDENTIALS.get('password')
    VERIFY_SSL = not demisto.params().get('unsecure', False)
    TOKEN = demisto.params().get('token')

    def get_server_url():
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    BASE_URL = get_server_url()
    SERVER_URL = BASE_URL + '/v1'

    DEFAULT_STATUS_CODES = {
        429,
        472,
        473
    }

    ''' HELPER FUNCTIONS '''

    def get_headers():
        headers =  {
            'Content-Type': 'application/json',
        }

        if TOKEN:
            headers['X-Vault-Token'] = TOKEN

        return headers

    def login():
        path = 'auth/userpass/login/' + USERNAME
        body = {
            'password': PASSWORD
        }

        url = '{}/{}'.format(SERVER_URL, path)
        res = requests.request('POST', url, headers=get_headers(), data=json.dumps(body), verify=VERIFY_SSL)
        if (res.status_code < 200 or res.status_code >= 300) and res.status_code not in DEFAULT_STATUS_CODES:
            try:
                error_body = res.json()
                if 'errors' in error_body and isinstance(error_body['errors'], list):
                    error_body = ';'.join(error_body['errors']) if len(error_body['errors']) > 0 else 'None'
            except:
                error_body = res.content
            return_error('Login failed. Status code: {}, details: {}'.format(str(res.status_code), error_body))

        auth_res = res.json()
        if not auth_res or 'auth' not in auth_res or 'client_token' not in auth_res['auth']:
            return_error('Could not authenticate user')

        return auth_res['auth']['client_token']

    def send_request(path, method='get', body=None, params=None, headers=None):
        body = body if body is not None else {}
        params = params if params is not None else {}

        url = '{}/{}'.format(SERVER_URL, path)

        headers = headers if headers is not None else get_headers()
        res = requests.request(method, url, headers=headers, data=json.dumps(body), params=params, verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            try:
                error_body = res.json()
                if 'errors' in error_body and isinstance(error_body['errors'], list):
                    error_body = ';'.join(error_body['errors']) if len(error_body['errors']) > 0 else 'None'
            except:
                error_body = res.content
            return_error('Request failed. Status code: {}, details: {}'.format(str(res.status_code), error_body))
        if res.content:
            return res.json()
        return ''

    ''' FUNCTIONS '''

    def list_secrets_engines_command():
        res = list_secrets_engines()

        if not res:
            return_error('No engines found')

        mapped_engines = [{
            'Path': k,
            'Type': v.get('type'),
            'Description': v.get('description'),
            'Accessor': v.get('accessor')
        } for k,v in res.get('data', {}).iteritems()]

        headers = ['Path', 'Type', 'Description', 'Accessor']

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Secrets Engines', mapped_engines, headers=headers, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Engine(val.Path===obj.Path)': createContext(mapped_engines, removeNull=True)
            }
        })

    def list_secrets_engines():
        path = 'sys/mounts'

        return send_request(path)


    def list_secrets_command():
        engine = demisto.args()['engine']
        version = demisto.args().get('version')

        res = list_secrets(engine, version)

        if not res or 'data' not in res:
            return_error('Secrets not found')

        mapped_secrets = [{
            'Path': k
        } for k in res['data'].get('keys', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Secrets in engine path: ' + engine, mapped_secrets, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Secret(val.Path===obj.Path)': createContext(mapped_secrets)
            }
        })


    def list_secrets(engine_path, version):
        path = engine_path

        if version == '2':
            path += '/metadata'

        params = {
            'list': 'true'
        }

        return send_request(path, 'get', params=params)


    def get_secret_metadata_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']

        res = get_secret_metadata(engine_path, secret_path)

        if not res or 'data' not in res:
            return_error('Secret not found')

        data = res['data']

        secret_headers = ['Engine','Created','Updated','CurrentVersion']
        version_headers = ['Number','Created','Deleted','Destroyed']

        mapped_secret = {
            'Path': secret_path,
            'Engine': engine_path,
            'Created': data.get('created_time'),
            'Updated': data.get('updated_time'),
            'CurrentVersion': data.get('current_version')
        }

        mapped_versions = [{
            'Number': k,
            'Created': v['created_time'],
            'Deleted': v['deletion_time'],
            'Destroyed': v['destroyed']
        } for k, v in data.get('versions', {}).iteritems()]

        hr = tableToMarkdown('Secret metadata', mapped_secret, headers=secret_headers, removeNull=True)
        if mapped_versions:
            hr += tableToMarkdown('Versions', mapped_versions, headers=version_headers, removeNull=True)
            mapped_secret['Version'] = mapped_versions

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'HashiCorp.Secret(val.Path===obj.Path)': createContext(mapped_secret, removeNull=True)
            }
        })

    def get_secret_metadata(engine_path, secret_path):
        path = engine_path + '/metadata/' + secret_path

        return send_request(path, 'get')


    def delete_secret_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']
        versions = argToList(demisto.args()['versions'])

        res = delete_secret(engine_path, secret_path, versions)

        demisto.results('Secret versions deleted successfully')


    def delete_secret(engine_path, secret_path, versions):
        path = engine_path + 'delete/' + secret_path

        body = {
            'versions': versions
        }

        return send_request(path, 'post', body=body)

    def undelete_secret_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']
        versions = argToList(demisto.args()['versions'])

        res = undelete_secret(engine_path, secret_path, versions)

        demisto.results('Secret versions undeleted successfully')

    def undelete_secret(engine_path, secret_path, versions):
        path = engine_path + 'undelete/' + secret_path

        body = {
            'versions': versions
        }

        return send_request(path, 'post', body=body)

    def destroy_secret_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']
        versions = argToList(demisto.args()['versions'])

        res = destroy_secret(engine_path, secret_path, versions)

        demisto.results('Secret versions destroyed successfully')

    def destroy_secret(engine_path, secret_path, versions):
        path = engine_path + 'destroy/' + secret_path

        body = {
            'versions': versions
        }

        return send_request(path, 'post', body=body)


    def list_policies_command():
        res = list_policies()

        if not res or 'policies' not in res:
            return_error('No policies found')

        mapped_policies = [{
            'Name': i
        } for i in res['policies']]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Policies', mapped_policies, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Policy(val.Name===obj.Name)': createContext(mapped_policies, removeNull=True)
            }
        })

    def list_policies():
        path = '/sys/policy'

        return send_request(path, 'get')

    def get_policy_command():
        name = demisto.args()['name']

        res = get_policy(name)

        if not res or 'rules' not in res:
            return_error('Policy not found')

        rules = hcl.loads(res['rules'])

        mapped_rules = [{'Path': k, 'Capabilities': v['capabilities']} for k,v in rules.get('path', {}).iteritems()]

        mapped_policy = {
            'Name': res['name'],
            'Rule': mapped_rules
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Policy - ' + name, mapped_rules, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Policy(val.Name===obj.Name)': createContext(mapped_policy, removeNull=True)
            }
        })


    def get_policy(policy_name):
        path = 'sys/policy/' + policy_name

        return send_request(path, 'get')

    def disable_engine_command():
        path = demisto.args()['path']

        res = disable_engine(path)

        demisto.results('Engine disabled successfully')

    def disable_engine(engine_path):
        path = 'sys/mounts/' + engine_path

        return send_request(path, 'delete')


    def enable_engine_command():
        path = demisto.args()['path']
        engine_type = demisto.args()['type']
        description = demisto.args().get('description')
        default_lease_ttl = demisto.args().get('default_lease_ttl')
        max_lease_ttl = demisto.args().get('max_lease_ttl')
        force_no_cache = demisto.args().get('force_no_cache')
        audit_non_hmac_request_keys = argToList(demisto.args().get('audit_non_hmac_request_keys', []))
        audit_non_hmac_response_keys = argToList(demisto.args().get('audit_non_hmac_response_keys', []))
        listing_visibility = demisto.args().get('listing_visibility')
        passthrough_request_headers = argToList(demisto.args().get('passthrough_request_headers', []))
        kv_version = demisto.args().get('kv_version')
        local = demisto.args().get('local')
        seal_wrap = demisto.args().get('seal_wrap')

        res = enable_engine(path, engine_type, description, default_lease_ttl, max_lease_ttl, force_no_cache, audit_non_hmac_request_keys,
                      audit_non_hmac_response_keys, listing_visibility, passthrough_request_headers, kv_version, local, seal_wrap)

        demisto.results('Engine enabled successfully')

    def enable_engine(path, engine_type, description, default_lease_ttl, max_lease_ttl, force_no_cache, audit_non_hmac_request_keys,
                      audit_non_hmac_response_keys, listing_visibility, passthrough_request_headers, kv_version, local, seal_wrap):
            path = 'sys/mounts/' + path

            body = {
                'type': engine_type,
                'config': {}
            }
            if description:
                body['description'] = description

            if default_lease_ttl:
                body['config']['default_lease_ttl'] = default_lease_ttl
            if max_lease_ttl:
                body['config']['max_lease_ttl'] = max_lease_ttl
            if force_no_cache:
                body['config']['force_no_cache'] = force_no_cache
            if audit_non_hmac_request_keys:
                body['config']['audit_non_hmac_request_keys'] = audit_non_hmac_request_keys
            if audit_non_hmac_response_keys:
                body['config']['audit_non_hmac_response_keys'] = audit_non_hmac_response_keys
            if listing_visibility:
                body['config']['listing_visibility'] = listing_visibility
            if passthrough_request_headers:
                body['config']['passthrough_request_headers'] = passthrough_request_headers
            if kv_version:
                body['options'] = {
                    'version': kv_version
                }
            if local:
                body['local'] = local
            if seal_wrap:
                body['seal_wrap'] = seal_wrap

            if not body['config']:
                del body['config']

            return send_request(path, 'post', body=body)


    def seal_vault_command():
        res = seal_vault()

        demisto.results('Vault sealed successfully')


    def seal_vault():
        path = 'sys/seal'

        return send_request(path, 'put')


    def unseal_vault_command():
        reset = demisto.args().get('reset')
        key = demisto.args().get('key')

        if not key and not reset:
            return_error('Either key or reset must be provided')

        res = unseal_vault(key, reset)

        if not res:
            return_error('Could not retrieve unseal state')

        headers = ['Sealed', 'Threshold', 'Shares', 'Progress']

        mapped_unseal = {
            'Sealed': res.get('sealed'),
            'Threshold': res.get('t'),
            'Shares': res.get('n'),
            'Progress': res.get('progress')
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Unseal', mapped_unseal, removeNull=True),
        })


    def unseal_vault(key, reset):
        path = 'sys/unseal'
        body = {}
        if reset:
            body['reset'] = reset
        elif key:
            body['key'] = key

        return send_request(path, 'put', body=body)


    def create_token_command():
        role_name = demisto.args().get('role_name')
        policies = argToList(demisto.args().get('policies', []))
        meta = demisto.args().get('meta')
        no_parent = demisto.args().get('no_parent')
        no_default_policy = demisto.args().get('no_default_policy')
        renewable = demisto.args().get('renewable')
        ttl = demisto.args().get('ttl')
        explicit_max_ttl = demisto.args().get('explicit_max_ttl')
        display_name = demisto.args().get('display_name')
        num_uses = demisto.args().get('num_uses')
        period = demisto.args().get('period')

        res = create_token(role_name, policies, meta, no_parent, no_default_policy, renewable, ttl, explicit_max_ttl,
                    display_name, num_uses, period)

        if not res or 'auth' not in res:
            return_error('Could not get authentication token')

        auth = res['auth']

        headers = ['Token', 'Policy', 'LeaseDuration']

        mapped_auth = {
            'Token': auth.get('client_token'),
            'Policy': auth.get('policies'),
            'LeaseDuration': auth.get('lease_duration')
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Token successfully created', mapped_auth, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Auth(val.Token===obj.Token)': createContext(mapped_auth, removeNull=True)
            }
        })


    def create_token(role_name, policies, meta, no_parent, no_default_policy, renewable, ttl, explicit_max_ttl,
                    display_name, num_uses, period):
        path = 'auth/token/create'
        body = {}
        if role_name:
            body['role_name'] = role_name
        if policies:
            body['policies'] = policies
        if meta:
            body['meta'] = meta
        if no_parent:
            body['no_parent'] = no_parent
        if no_default_policy:
            body['no_default_policy'] = no_default_policy
        if renewable:
            body['renewable'] = renewable
        if ttl:
            body['ttl'] = ttl
        if explicit_max_ttl:
            body['explicit_max_ttl'] = explicit_max_ttl
        if display_name:
            body['display_name'] = display_name
        if num_uses:
            body['num_uses'] = num_uses
        if period:
            body['period'] = period

        return send_request(path, 'post', body=body)

    def configure_engine_command():
        engine_path = demisto.args()['path']
        engine_type = demisto.args()['type']
        version = demisto.args().get('version')

        configure_engine(engine_path, engine_type, version)

        demisto.results('Engine configured successfully')

    def reset_config_command():
        demisto.setIntegrationContext({'configs': []})

        demisto.results('Successfully reset the engines configuration')

    def configure_engine(engine_path, engine_type, version):
        engine_conf = {
            'type': engine_type,
            'path': engine_path
        }
        if version:
            engine_conf['version'] = str(version)

        ENGINE_CONFIGS.append(engine_conf)

        demisto.setIntegrationContext({'configs': ENGINE_CONFIGS})


    def fetch_credentials():
        credentials = []
        engines_to_fetch_from = []
        ENGINES = argToList(demisto.params().get('engines', []))
        identifier = demisto.args().get('identifier')

        if len(ENGINES) == 0:
            return_error('No secrets engines specified')

        for engine_type in ENGINES:
            engines_to_fetch = list(filter(lambda e: e['type'] == engine_type, ENGINE_CONFIGS))
            engines_to_fetch_from += engines_to_fetch

        if len(engines_to_fetch_from) == 0:
                return_error('Engine type not configured, Use the configure-engine command to configure a secrets engine.')

        for engine in engines_to_fetch_from:
            if engine['type'] == 'KV':
                if 'version' not in engine:
                    return_error('Version not configured for KV engine, re-configure the engine')
                if engine['version'] == '1':
                    credentials += get_kv1_secrets(engine['path'])
                elif engine['version'] == '2':
                    credentials += get_kv2_secrets(engine['path'])
            elif engine['type'] == 'Cubbyhole':
                credentials += get_ch_secrets(engine['path'])

        if identifier:
            credentials = list(filter(lambda c: c.get('name', '') == identifier, credentials))

        demisto.credentials(credentials)


    def get_kv1_secrets(engine_path):
        path = engine_path
        params = {
            'list': 'true'
        }

        res = send_request(path, 'get', params=params)

        secrets = []

        if not res or 'data' not in res:
            return []

        for secret in res['data'].get('keys', []):
            secret_data = get_kv1_secret(engine_path, secret)
            for k,v in secret_data.get('data', {}).iteritems():
                secrets.append({
                        'user': k,
                        'password': v,
                        'name': secret
                    })

        return secrets

    def get_kv1_secret(engine_path, secret):
        path = engine_path + secret

        return send_request(path, 'get')

    def get_kv2_secrets(engine_path):
        secrets = []
        res = list_secrets(engine_path, '2')
        if not res or 'data' not in res:
            return []

        for secret in res['data'].get('keys', []):
            secret_data = get_kv2_secret(engine_path, secret)
            for k,v in secret_data.get('data', {}).get('data', {}).iteritems():
                secrets.append({
                        'user': k,
                        'password': v,
                        'name': secret
                    })

        return secrets

    def get_kv2_secret(engine_path, secret):
        path = engine_path + 'data/' + secret

        return send_request(path, 'get')


    def get_ch_secrets(engine_path):
        path = engine_path

        params = {
            'list': 'true'
        }

        res = send_request(path, 'get', params=params)

        secrets = []

        if not res or 'data' not in res:
            return []

        for secret in res['data'].get('keys', []):
            secret_data = get_ch_secret(engine_path, secret)
            for k,v in secret_data.get('data', {}).iteritems():
                secrets.append({
                        'user': k,
                        'password': v,
                        'name': secret
                    })

        return secrets

    def get_ch_secret(engine_path, secret):
        path = engine_path + secret

        return send_request(path, 'get')

    ''' EXECUTION CODE '''

    LOG('Executing command: ' + demisto.command())

    if USERNAME and PASSWORD:
        TOKEN = login()
    elif not TOKEN:
        return_error('Either an authentication token or user credentials must be provided')

    integ_context = demisto.getIntegrationContext()
    if not integ_context or 'configs' not in integ_context:
        integ_context['configs'] = []

    ENGINE_CONFIGS = integ_context['configs']

    try:
        if demisto.command() == 'test-module':
            path = 'sys/health'
            send_request(path)
            demisto.results('ok')
        elif demisto.command() == 'fetch-credentials':
            fetch_credentials()
        elif demisto.command() == 'hashicorp-list-secrets-engines':
            list_secrets_engines_command()
        elif demisto.command() == 'hashicorp-list-secrets':
            list_secrets_command()
        elif demisto.command() == 'hashicorp-list-policies':
            list_policies_command()
        elif demisto.command() == 'hashicorp-get-policy':
            get_policy_command()
        elif demisto.command() == 'hashicorp-get-secret-metadata':
            get_secret_metadata_command()
        elif demisto.command() == 'hashicorp-delete-secret':
            delete_secret_command()
        elif demisto.command() == 'hashicorp-undelete-secret':
            undelete_secret_command()
        elif demisto.command() == 'hashicorp-destroy-secret':
            destroy_secret_command()
        elif demisto.command() == 'hashicorp-disable-engine':
            disable_engine_command()
        elif demisto.command() == 'hashicorp-enable-engine':
            enable_engine_command()
        elif demisto.command() == 'hashicorp-seal-vault':
            seal_vault_command()
        elif demisto.command() == 'hashicorp-unseal-vault':
            unseal_vault_command()
        elif demisto.command() == 'hashicorp-create-token':
            create_token_command()
        elif demisto.command() == 'hashicorp-configure-engine':
            configure_engine_command()
        elif demisto.command() == 'hashicorp-reset-configuration':
            reset_config_command()
    except Exception as e:
        LOG(e)
        LOG.print_log()
        return_error(e.message)
  type: python
  subtype: python2
  commands:
  - name: hashicorp-list-secrets-engines
    arguments: []
    outputs:
    - contextPath: HashiCorp.Engine.Type
      description: Secrets engine type
      type: string
    - contextPath: HashiCorp.Engine.Path
      description: Secrets engine path in HashiCorp
      type: string
    - contextPath: HashiCorp.Engine.Description
      description: Secrets engine description
      type: string
    - contextPath: HashiCorp.Engine.Accessor
      description: Secrets engine accessor
      type: string
    description: List all secrets engines that exist in HashiCorp Vault
  - name: hashicorp-list-secrets
    arguments:
    - name: engine
      required: true
      default: true
      description: Engine path, e.g.,"secret/". Use the list-secrets-engines command
        to retrieve the engine path. command.
    - name: version
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      description: The version of the KV engine
      defaultValue: "1"
    outputs:
    - contextPath: HashiCorp.Secret.Path
      description: Secret path
      type: string
    description: List secrets (names) for a specified KV engine
  - name: hashicorp-get-secret-metadata
    arguments:
    - name: engine_path
      required: true
      description: KV Engine path, e.g., "kv/"
    - name: secret_path
      required: true
      description: Secret path, e.g., "secret"
    outputs:
    - contextPath: HashiCorp.Secret.Created
      description: Secret created time
      type: date
    - contextPath: HashiCorp.Secret.Version.Destroyed
      description: Is the version destroyed
      type: boolean
    - contextPath: HashiCorp.Secret.Version.Created
      description: Version creation time
      type: number
    - contextPath: HashiCorp.Secret.Version.Deleted
      description: Version deletion time
      type: date
    - contextPath: HashiCorp.Secret.Updated
      description: Secret last updated time
      type: date
    - contextPath: HashiCorp.Secret.Engine
      description: Secret engine type
      type: string
    - contextPath: HashiCorp.Secret.CurrentVersion
      description: Secret current version
      type: number
    - contextPath: HashiCorp.Secret.Path
      description: Secret path
      type: string
    description: 'Returns information about a specified secret in a specified KV V2
      engine '
  - name: hashicorp-delete-secret
    arguments:
    - name: secret_path
      required: true
      description: Secret path, e.g., "secret"
    - name: engine_path
      required: true
      description: Engine path, e.g.,"secret/"
    - name: versions
      required: true
      description: CSV list of secret versions to delete
      isArray: true
    description: Deletes the data under a specified secret given the secret path.
      Performs a soft delete that allows you to run the hashicorp-undelete-secret
      command if necessary (for KV V2 engine)
  - name: hashicorp-undelete-secret
    arguments:
    - name: secret_path
      required: true
      description: Secret path, e.g., "secret"
    - name: engine_path
      required: true
      description: Engine path, e.g.,"secret/"
    - name: versions
      required: true
      description: CSV list of secret versions to undelete (restore)
      isArray: true
    description: Undeletes (restores) a secret on HashiCorp (for KV V2 engine)
  - name: hashicorp-destroy-secret
    arguments:
    - name: secret_path
      required: true
      description: Secret path, .e.g., "secret"
    - name: engine_path
      required: true
      description: Engine path, e.g.,"secret/"
    - name: versions
      required: true
      description: CSV list of secret versions to permanently delete
      isArray: true
    description: Permanently deletes a secret (for KV V2 engine)
  - name: hashicorp-disable-engine
    arguments:
    - name: path
      required: true
      default: true
      description: Path of the secrets engine to disable
    description: When a secrets engine is no longer needed, it can be disabled. All
      secrets under the engine are revoked and the corresponding vault data and configurations
      are removed.
  - name: hashicorp-enable-engine
    arguments:
    - name: path
      required: true
      description: The path where the secrets engine will be mounted
    - name: type
      required: true
      description: Type of backend, e.g., "aws"
    - name: description
      description: Human-friendly description of the mount
    - name: default_lease_ttl
      description: The default lease duration, specified as a string duration, e.g.,
        "5s" or "30m"
    - name: max_lease_ttl
      description: The maximum lease duration, specified as a string duration, e.g.,
        "5s" or "30m"
    - name: force_no_cache
      description: Disable caching
    - name: audit_non_hmac_request_keys
      description: CSV list of keys that will not be HMAC'd by audit devices in the
        request data object
      isArray: true
    - name: audit_non_hmac_response_keys
      description: CSV list of keys that will not be HMAC'd by audit devices in the
        response data object
      isArray: true
    - name: listing_visibility
      auto: PREDEFINED
      predefined:
      - unauth
      - hidden
      description: Whether to show this mount in the UI-specific listing endpoint;
        "unauth" or "hidden", default is "hidden" Default is hidden.
    - name: passthrough_request_headers
      description: CSV list of headers to whitelist and pass from the request to the
        backend
      isArray: true
    - name: kv_version
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      description: KV version to mount. Set to "2" for mount KV V2.
    - name: local
      description: Specifies if the secrets engine is a local mount only. Local mounts
        are not replicated, nor (if a secondary) removed by replication. Supported
        only in Vault Enterprise.
    - name: seal_wrap
      description: Enable seal wrapping for the mount. Supported only in Vault Enterprise.
    description: Enables a new secrets engine at the specified path
  - name: hashicorp-list-policies
    arguments: []
    outputs:
    - contextPath: HashiCorp.Policy.Name
      description: Policy name
      type: string
    description: Lists all configured policies
  - name: hashicorp-get-policy
    arguments:
    - name: name
      required: true
      description: Policy name
    outputs:
    - contextPath: HashiCorp.Policy.Name
      description: Policy name
      type: string
    - contextPath: 'HashiCorp.Policy.Rule.Path '
      description: Policy rule path
      type: string
    - contextPath: HashiCorp.Policy.Rule.Capabilities
      description: Policy rule capabilities
    description: Get information for a policy
  - name: hashicorp-seal-vault
    arguments: []
    description: If you suspect your data has been compromised, you can seal your
      vault to prevent access to your secrets
    execution: true
  - name: hashicorp-unseal-vault
    arguments:
    - name: key
      description: 'Single master key '
    - name: reset
      auto: PREDEFINED
      predefined:
      - "true"
      description: Reset the unseal project
    description: Use a single master key share to unseal the vault. If the master
      key shares threshold is met, vault will attempt to unseal the vault. Otherwise,
      this API must be called until the threshold is met.
  - name: hashicorp-configure-engine
    arguments:
    - name: path
      required: true
      description: The engine path, e.g., "secret/"
    - name: type
      required: true
      description: The engine type, e.g., "KV"
    - name: version
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      description: The engine version (for KV engines); "1" or "2"
    description: Configure a secrets engine to fetch secrets from
  - name: hashicorp-reset-configuration
    arguments: []
    description: Reset the engines configuration
  - name: hashicorp-create-token
    arguments:
    - name: role_name
      description: The name of the token role
    - name: policies
      description: CSV list of policies for the token. This must be a subset of the
        policies belonging to the token making the request, unless root. If policies
        are not specified, all policies of the calling token are applied to the new
        token.
      isArray: true
    - name: meta
      description: A map of string-to-string valued metadata. This is passed through
        to the audit devices.
    - name: no_parent
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true and set by a root caller, the token will not have the parent
        token of the caller. This creates a token with no parent.
    - name: no_default_policy
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true the default policy will not be included in this token's
        policy set; "true" or "false"
    - name: renewable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If set to false, the token cannot be renewed past its initial TTL.
        If set to true, the token can be renewed up to the system/mount maximum TTL.
        "true" or "false"
    - name: ttl
      description: The TTL(lease duration) period of the token, provided as "10m"
        or "1h", where hour is the largest suffix. If not provided, the token is valid
        for the default lease TTL, or indefinitely if the root policy is used.
    - name: explicit_max_ttl
      description: ' If set, the token will have an explicit max TTL applied to it.
        The maximum token TTL cannot be changed later, and unlike with normal tokens,
        updates to the system/mount max TTL value will have no effect at renewal time.
        The token can never be renewed or used past the value set at issue time.'
    - name: display_name
      description: The display name of the token
    - name: num_uses
      description: The maximum number of times the token can be used. Supply this
        argument to create a one-time-token, or limited use token. The value of 0
        has no limit to the number of uses.
    - name: period
      description: If specified, the token will be periodic; it will not have a maximum
        TTL (unless an "explicit-max-ttl" is also set), but every renewal will use
        the given period. Requires a root/sudo token to use.
    outputs:
    - contextPath: HashiCorp.Auth.Token
      description: Authentication token
      type: string
    - contextPath: HashiCorp.Auth.Policy
      description: Authentication policies
    - contextPath: HashiCorp.Auth.LeaseDuration
      description: 'Authentication lease duration in seconds, 0 if indefinitely '
      type: number
    description: Creates a new authentication token
  dockerimage: demisto/hashicorp:1.0.0.39
  runonce: false
tests:
  - hashicorp_test