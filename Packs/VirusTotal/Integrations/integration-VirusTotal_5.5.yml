commonfields:
  id: VirusTotal
  version: -1
name: VirusTotal
display: VirusTotal
fromversion: 5.5.0
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Analyze suspicious hashes, URLs, domains and IP addresses
detaileddescription: |-
  ## Get a VirusTotal API Key
  To use this integration, you need a VirusTotal API key.
  1. Log in to your VirusTotal console.
  2. Click your username, and select **My API Key**.

  ## Indicator Thresholds
  Configure the default threshold for each indicator type in the instance settings.
  You can also specify the threshold as an argument when running relevant commands.
  Indicators with positive results equal to or higher than the threshold will be considered malicious.
  Indicators with positive results equal to or higher than half of the threshold value, and lower than the threshold, will be considered suspicious.
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: Server
  defaultvalue: https://www.virustotal.com/vtapi/v2/
  type: 0
  required: true
- display: API Key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: useproxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: File Threshold. Minimum number of positive results from VT scanners to
    consider the file malicious.
  name: fileThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: IP Threshold. Minimum number of positive results from VT scanners to consider
    the IP malicious.
  name: ipThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: URL Threshold. Minimum number of positive results from VT scanners to consider
    the URL malicious.
  name: urlThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: Domain Threshold. Minimum number of positive results from VT scanners to
    consider the domain malicious.
  name: domainThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: Preferred Vendors List. CSV list of vendors which are considered more trustworthy.
  name: preferredVendors
  defaultvalue: ""
  type: 12
  required: false
- display: 'Preferred Vendor Threshold. The minimum number of highly trusted vendors
    required to consider a domain, IP address, URL, or file as malicious. '
  name: preferredVendorsThreshold
  defaultvalue: ""
  type: 0
  required: false
- display: Determines whether to return all results, which can number in the thousands.
    If “true”, returns all results and overrides the _fullResponse_, _long_ arguments
    (if set to “false”) in a command. If “false”, the _fullResponse_, _long_ arguments
    in the command determines how results are returned.
  name: fullResponseGlobal
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    var DBOTSCORE_KEY = "DBotScore(val.Indicator && val.Indicator === obj.Indicator && val.Vendor === obj.Vendor && val.Type === obj.Type)"
    var serverUrl = params.Server;
    if (serverUrl[serverUrl.length - 1] !== '/') {
        serverUrl += '/';
    }
    //THRESHOLDS PARAMETERS
    var FILE_THRESHOLD = params.fileThreshold;
    var IP_THRESHOLD = params.ipThreshold;
    var URL_THRESHOLD = params.urlThreshold;
    var DOMAIN_THRESHOLD = params.domainThreshold;
    var PREFERRED_VENDORS = params.preferredVendors
    var PREFERRED_VENDORS_THRESHOLD = params.preferredVendorsThreshold
    var FULL_RESPONSE = params.fullResponseGlobal
    if (isNaN(FILE_THRESHOLD) || isNaN(IP_THRESHOLD) || isNaN(URL_THRESHOLD) || isNaN(DOMAIN_THRESHOLD)) {
        throw 'Threshold parameters must be numbers.\n';
    }
    function isEnoughPreferredVendors(scanResults) {
        if (!(PREFERRED_VENDORS && PREFERRED_VENDORS_THRESHOLD)) {
            return false;
        }
        if (PREFERRED_VENDORS && !(PREFERRED_VENDORS_THRESHOLD)) {
            return("Error: If you entered Preferred Vendors List you must also enter Preferred Vendors Threshold")
        }
        if (!("scans" in scanResults)) {
            return false;
        }
        counter = 0;
        vendorsScansDict = scanResults["scans"];
        listOfPrefferedVendors = PREFERRED_VENDORS.split(',');
        for (var i=0; i < listOfPrefferedVendors.length; i++) {
            listOfPrefferedVendors[i] = listOfPrefferedVendors[i].toLowerCase();
        }
        for (var vendorName in vendorsScansDict) {
            if (vendorsScansDict.hasOwnProperty(vendorName)) {
                curVendorScan = vendorsScansDict[vendorName];
                vendorNameLowercase = vendorName.toLowerCase();
                if (listOfPrefferedVendors.indexOf(vendorNameLowercase) != -1) {
                    if ("detected" in curVendorScan && curVendorScan["detected"]) {
                        counter++;
                    }
                }
            }
        }
        return (parseInt(PREFERRED_VENDORS_THRESHOLD) <= counter);
    }
    function createScansTable(scans){
        // Returns a table with the scan result for each vendor
        scans_table = [];
        positives_scans_table = [];
        negative_scans_table = [];
        for (var scan in scans) {
            dict_for_table = {};
            dict_for_table['Source'] = scan;
            if (scans[scan]['detected']){
                dict_for_table['Detected'] = scans[scan]['detected'];
            }
            if (scans[scan]['result']){
                dict_for_table['Result'] = scans[scan]['result'];
            }
            if (scans[scan]['update']){
                dict_for_table['Update'] = scans[scan]['update'];
            }
            if (scans[scan]['detail']){
                dict_for_table['Details'] = scans[scan]['detail'];
            }
            if (dict_for_table['Detected'] && dict_for_table['Detected'] === true)
                positives_scans_table.push(dict_for_table);
            else
                negative_scans_table.push(dict_for_table);
        }
        positives_scans_table.sort(function(a, b){
          return a.Source > b.Source;
        });
        negative_scans_table.sort(function(a, b){
          return a.Source > b.Source;
        });
        scans_table = positives_scans_table.concat(negative_scans_table);
        return scans_table;
    }
    function doReq(method, path, parameters) {
        if (!parameters) {
            parameters = {};
        }
        parameters.apikey = params.APIKey;
        var result = http(
            serverUrl + path + (method === 'GET' ? encodeToURLQuery(parameters) : ''),
            {
                Headers: {'Content-Type': ['application/x-www-form-urlencoded'], 'Accept': ['application/json']},
                Method: method,
                Body: method == 'POST' ? encodeToURLQuery(parameters).substring(1) : ''
            },
            params.insecure,
            params.useproxy
        );
        if (result.StatusCode == 401) {
            throw '401 Unauthorized - Wrong or invalid API key.';
        }
        if (result.StatusCode == 403) {
            throw '403 Forbidden - The API key is not valid';
        }
        if (result.StatusCode == 404) {
            throw '404 - Cannot find the requested resource. Check your Server URL.';
        }
        if (result.StatusCode < 200 || result.StatusCode > 299) {
            throw 'Failed to perform request ' + path + ', request status code: ' + result.StatusCode;
        }
        if (result.Body === '' && result.StatusCode === 204) {
            return {statusCode: result.StatusCode};
        }
        if (result.Body === '') {
            throw 'No content received. Maybe you tried a private API?.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (!Array.isArray(obj) && obj.response_code !== 1 && obj.response_code !== 0) {
            throw 'Response code: ' + obj.response_code + ', message: ' + obj.verbose_msg;
        }
        return {
            body: result.Body,
            obj: obj,
            statusCode: result.StatusCode
        };
    }
    function withRetries(waitForRateLimit, retries, reqCall) {
        if (waitForRateLimit) {
            waitForRateLimit = parseInt(waitForRateLimit);
        }
        if (!waitForRateLimit) {
            waitForRateLimit = 60;
        }
        if (retries) {
            retries = parseInt(retries);
        }
        if (!retries) {
            retries = 0;
        }
        var res = reqCall();
        var tries = 0;
        while (res.statusCode === 204 && !res.body && tries < retries && waitForRateLimit > 0) {
            wait(waitForRateLimit);
            tries++;
            res = reqCall();
        }
        if (res.statusCode === 204 && !res.body) {
            throw 'No content received. Possible API rate limit reached.';
        }
        return res;
    }
    function doFile(hash, longFormat, threshold, waitForRateLimit, retries) {
        if (!threshold) {
            threshold = FILE_THRESHOLD || 10;
        }
        threshold = parseInt(threshold);

        var res = withRetries(waitForRateLimit, retries, function() {return doReq('POST', 'file/report', {resource: hash});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec[DBOTSCORE_KEY] = {Indicator: hash, Type: 'hash', Vendor: 'VirusTotal', Score: 0};
            ec[DBOTSCORE_KEY] = {Indicator: hash, Type: 'file', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + hash + '\n' + res.obj.verbose_msg};
        }
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple hashes so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var entryList = [];
        for (var i=0; i<r.length; i++) {
            ec = {};
            ec[DBOTSCORE_KEY] = [];
            ec[outputPaths.file] = [];
            var md = '## VirusTotal Hash Reputation for: ' + r[i].resource + '\n';
            md += 'Scan date: **' + r[i].scan_date + '**\n';
            md += 'Positives / Total: **' + r[i].positives + '/' + r[i].total + '**\n';
            md += 'VT Link: [' + r[i].resource + '](' + r[i].permalink + ')\n';
            var dbotScore = 0;
            if (r[i].positives >= threshold || isEnoughPreferredVendors(r[i])) {
                dbotScore = 3;
                var malFile = {};
                addMalicious(malFile, outputPaths.file, {
                    MD5: r[i].md5,
                    SHA1: r[i].sha1,
                    SHA256: r[i].sha256,
                    PositiveDetections: r[i].positives,
                    DetectionEngines: Object.keys(r[i].scans).length,
                    Malicious: {Vendor: 'VirusTotal', Detections: r[i].positives, TotalEngines: r[i].total}
                });
                ec[outputPaths.file].push(malFile[outputPaths.file]);
            } else if (r[i].positives >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }

            ec[DBOTSCORE_KEY].push({Indicator: r[i].md5, Type: 'hash', Vendor: 'VirusTotal', Score: dbotScore});
            ec[DBOTSCORE_KEY].push({Indicator: r[i].md5, Type: 'file', Vendor: 'VirusTotal', Score: dbotScore});

            ec[DBOTSCORE_KEY].push({Indicator: r[i].sha1, Type: 'hash', Vendor: 'VirusTotal', Score: dbotScore});
            ec[DBOTSCORE_KEY].push({Indicator: r[i].sha1, Type: 'file', Vendor: 'VirusTotal', Score: dbotScore});

            ec[DBOTSCORE_KEY].push({Indicator: r[i].sha256, Type: 'hash', Vendor: 'VirusTotal', Score: dbotScore});
            ec[DBOTSCORE_KEY].push({Indicator: r[i].sha256, Type: 'file', Vendor: 'VirusTotal', Score: dbotScore});

            md += 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\n';
            longFormat = FULL_RESPONSE? 'true': longFormat;
            if (longFormat === 'true' && r[i].scans) { // add scans table
                scansTable = createScansTable(r[i].scans);
                md += tableToMarkdown('Scans', scansTable);
                if (ec[outputPaths.file]){
                    scans_ec = {
                        Scans: scansTable,
                        ScanID: r[i].scan_id,
                        vtLink: r[i].permalink
                    };
                    if (typeof ec[outputPaths.file][i] === 'object') { // malicous
                        ec[outputPaths.file][i].VirusTotal = scans_ec;
                    } else { // not malicious
                        ec[outputPaths.file][i] = {
                            SHA256: r[i].sha256,
                            SHA1: r[i].sha1,
                            MD5: r[i].md5,
                            VirusTotal: scans_ec,
                            PositiveDetections: r[i].positives,
                            DetectionEngines: Object.keys(r[i].scans).length
                        };
                    }
                } else {
                    scans_ec = {
                        MD5: r[i].md5,
                        SHA1: r[i].sha1,
                        SHA256: r[i].sha256,
                        VirusTotal: {
                            Scans: scansTable,
                            ScanID: r[i].scan_id,
                            vtLink: r[i].permalink
                        },
                        PositiveDetections: r[i].positives,
                        DetectionEngines: Object.keys(r[i].scans).length
                    };
                    ec[outputPaths.file] = scans_ec;
                }
            } else { // short format
                if (ec[outputPaths.file]){
                    scans_ec = {
                        ScanID: r[i].scan_id,
                        vtLink: r[i].permalink
                    };
                    if (typeof ec[outputPaths.file][i] === 'object') { // malicious
                        ec[outputPaths.file][i].VirusTotal = scans_ec;
                    } else { // not malicious
                        ec[outputPaths.file][i] = {
                            SHA256: r[i].sha256,
                            SHA1: r[i].sha1,
                            MD5: r[i].md5,
                            VirusTotal: scans_ec,
                            PositiveDetections: r[i].positives,
                            DetectionEngines: Object.keys(r[i].scans).length
                        };
                    }
                } else {
                    scans_ec = {
                        SHA256: r[i].sha256,
                        SHA1: r[i].sha1,
                        MD5: r[i].md5,
                        VirusTotal: {
                            ScanID: r[i].scan_id,
                            vtLink: r[i].permalink
                        },
                        PositiveDetections: r[i].positives,
                        DetectionEngines: Object.keys(r[i].scans).length
                    };
                    ec[outputPaths.file] = scans_ec;
                }
            }
            md += '\n';
            entryList.push(
                {
                    Type: entryTypes.note,
                    Contents: res.body,
                    ContentsFormat: formats.json,
                    HumanReadable: md,
                    EntryContext: ec
                }
            );
        }
        return entryList
    }
    function calcRecentDownloads(checks) {
        var badDownloads = 0;
        var millisec_in_day = 1000 * 60 * 60 * 24;
        var now = Date.now();
        for (var c=0; c<checks.length; c++) {
            if (checks[c]) {
                for (var ci=0; ci<checks[c].length; ci++) {
                    if (checks[c][ci].date) {
                        var d = new Date(checks[c][ci].date.replace(' ', 'T'));
                        if (((now - d.getTime()) / millisec_in_day < 30) && (checks[c][ci].positives > 0)) {
                            badDownloads++;
                        }
                    }
                }
            }
        }
        return badDownloads;
    }
    function doIP(ip, longFormat, threshold, sampleSize, waitForRateLimit, retries, fullResponse) {

        var ipList = argToList(ip);
        var entryList = [];
        for (z = 0; z < ipList.length; z++) {
            ip = ipList[z];
            if (!isValidIP(ip)) {
                entryList.push({Type: entryTypes.error, Contents: 'IP - ' + ip + ' is not valid IP', ContentsFormat: formats.text});
                continue;
            }
            if (!threshold) {
                threshold = IP_THRESHOLD || 10;
            }
            threshold = parseInt(threshold);
            if (!sampleSize) {
                sampleSize = 10;
            }
            var res = withRetries(waitForRateLimit, retries, function() {return doReq('GET', 'ip-address/report', {ip: ip});});
            var o = res.obj;
            var ec = {};
            if (o.response_code === 0) {
                ec[DBOTSCORE_KEY]  = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: 0};
                entryList.push({Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                    HumanReadable: 'VirusTotal does not have details about ' + ip + ' ,it sent the following response:\n' + res.obj.verbose_msg});
                continue;
            }
            full_response = FULL_RESPONSE? 'true': fullResponse;
            if (fullResponse === 'true'){
                maxLen = 1000;
            } else {
                maxLen = 50;
            }
            // Calculate score based on recently found downloads
            var badDownloads = calcRecentDownloads([o.detected_downloaded_samples, o.undetected_downloaded_samples]);
            var dbotScore = 0;
            if (badDownloads >= threshold) {
                dbotScore = 3;
                addMalicious(ec, outputPaths.ip,{
                    Address: ip,
                    ASN: o.asn,
                    Geo: {Country: o.country},
                    Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}
                });
            } else if (badDownloads >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }
            ec[DBOTSCORE_KEY] = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: dbotScore};
            var md = '## VirusTotal IP Reputation for: ' + ip + '\n';
            md += (o.asn) ? 'ASN: **' + o.asn + ' (' + o.as_owner + ')**\n' : 'ASN: N/A\n';
            md += 'Country: **' + o.country + '**\n';
            md += 'VT Link: [' + ip + '](https://www.virustotal.com/en/search?query=' + encodeURIComponent(ip) + ')\n';
            var detectedUrls = o.detected_urls || [];
            var detectedDownloadedSamples = o.detected_downloaded_samples || [];
            var undetectedDownloadedSamples = o.undetected_downloaded_samples || [];
            var detectedCommunicatingSamples = o.detected_communicating_samples || [];
            var undetectedCommunicatingSamples = o.undetected_communicating_samples || [];
            var detectedReferrerSamples = o.detected_referrer_samples || [];
            var undetectedReferrerSamples = o.undetected_referrer_samples || [];
            var resolutions = o.resolutions || [];
            var arrTitle = [{a: detectedUrls, t: 'Detected URL'}, {a: detectedDownloadedSamples, t: 'Detected downloaded sample'},
                {a: undetectedDownloadedSamples, t: 'Undetected downloaded sample'}, {a: detectedCommunicatingSamples, t: 'Detected communicating sample'},
                {a: undetectedCommunicatingSamples, t: 'Undetected communicating sample'},{a: detectedReferrerSamples, t: 'Detected referrer sample'},
                {a: undetectedReferrerSamples, t: 'Undetected referrer sample'}, {a: resolutions, t: 'Resolutions'}];
            for (var i = 0; i<arrTitle.length; i++) {
                if (arrTitle[i].a) {
                    md += arrTitle[i].t + ' count: **' + arrTitle[i].a.length + '**\n';
                }
            }
            if (ec[outputPaths.ip]){ // malicious
                ec[outputPaths.ip]['VirusTotal'] = {
                    'DownloadedHashes': detectedDownloadedSamples.slice(0,maxLen),
                    'UnAVDetectedDownloadedHashes': undetectedDownloadedSamples.slice(0,maxLen),
                    "DetectedURLs": detectedUrls.slice(0,maxLen),
                    'CommunicatingHashes': detectedCommunicatingSamples.slice(0,maxLen),
                    'UnAVDetectedCommunicatingHashes': undetectedCommunicatingSamples.slice(0,maxLen),
                    'Resolutions': resolutions.slice(0,maxLen),
                    'ReferrerHashes': detectedReferrerSamples.slice(0,maxLen),
                    'UnAVDetectedReferrerHashes': undetectedReferrerSamples.slice(0,maxLen)
                };
            } else { // not malicious
                ec[outputPaths.ip] = {
                    "Address": ip,
                    "VirusTotal": {
                        'DownloadedHashes': detectedDownloadedSamples.slice(0,maxLen),
                        'UnAVDetectedDownloadedHashes': undetectedDownloadedSamples.slice(0,maxLen),
                        "DetectedURLs": detectedUrls.slice(0,maxLen),
                        'CommunicatingHashes': detectedCommunicatingSamples.slice(0,maxLen),
                        'UnAVDetectedCommunicatingHashes': undetectedCommunicatingSamples.slice(0,maxLen),
                        'Resolutions': resolutions.slice(0,maxLen),
                        'ReferrerHashes': detectedReferrerSamples.slice(0,maxLen),
                        'UnAVDetectedReferrerHashes': undetectedReferrerSamples.slice(0,maxLen)
                    },
                    'ASN': o.asn,
                    'Geo': {Country: o.country}
                };
            }
            longFormat = FULL_RESPONSE? 'true': longFormat;
            if (longFormat === 'true') {
                for (var j=0; j<arrTitle.length; j++) {
                    if (arrTitle[j].a) {
                        md += '### ' + arrTitle[j].t + '\n';
                        // Print only the first 10 rows
                        var curr = [];
                        for (var k=0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {
                            curr.push(arrTitle[j].a[k]);
                        }
                        md += arrToMd(curr) + '\n';
                    }
                }
            }
            entryList.push({
                Type: entryTypes.note,
                Contents: res.body,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: ec
            });
        }
        return entryList;
    }
    function getURLs(url) {
        var urls = [];
        var urlList = argToList(url);
        for (z = urlList.length - 1; z >= 0; z--) {
            var isURL = urlList[z].match(/(?:(?:https?|ftp|hxxps?):\/\/|www\[?\.\]?|ftp\[?\.\]?)(?:[-\w\d]+\[?\.\]?)+[-\w\d]+(?::\d+)?(?:(?:\/|\?)[-\w\d+&@#\/%=~_$?!\-:,.\(\);]*[\w\d+&@#\/%=~_$\(\);])?/);
            if (isURL == null){
                var i = z;
                var url;
                var optionalURL;
                while(i>=0 && z > 0 && optionalURL == null) {
                    i--;
                    optionalURL = urlList.slice(i, z).join("").match(/(?:(?:https?|ftp|hxxps?):\/\/|www\[?\.\]?|ftp\[?\.\]?)(?:[-\w\d]+\[?\.\]?)+[-\w\d]+(?::\d+)?(?:(?:\/|\?)[-\w\d+&@#\/%=~_$?!\-:,.\(\);]*[\w\d+&@#\/%=~_$\(\);])?/);
                }
                if (optionalURL !== null) {
                    urls.push(urlList.slice(i, z+1).join(","));
                }
                z = i;
            } else {
                urls.push(urlList[z]);
            }
        }

        return urls;
    }
    function doURL(url, threshold, longFormat, sampleSize, submitWait, waitForRateLimit, retries) {
        //lowercase the URL protocol
        //Example: https://www.demisto.com --> https://www.demisto.com, Http://www.demisto.com --> http://www.demisto.com, www.demisto.com --> www.demisto.com

        var urlList = getURLs(url);
        var entryList = [];
        for (z = 0; z < urlList.length; z++) {
            url = urlList[z];
            var protocol = url.match(/\b^[^:]+(?=:\/\/)\b/);
            if (protocol !== null) { // if url doesn't start with a protocol, ignore
              protocol = protocol[0].toLowerCase();
              var not_protocol = url.replace(/(^\w+:|^)\/\//, '');
              url = protocol + '://' + not_protocol;
            }
            if (!submitWait) {
                submitWait = 0;
            }
            if (!sampleSize) {
                sampleSize = 10;
            }
            if (!threshold) {
                threshold = URL_THRESHOLD || 10;
            }
            threshold = parseInt(threshold);
            var res = withRetries(waitForRateLimit, retries, function() {return doReq('POST', 'url/report', {resource: url, scan:1});});
            var o = res.obj;
            var ec = {};
            if (o.response_code === 0) {
                ec[DBOTSCORE_KEY] = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: 0};
                entryList({Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                    HumanReadable: 'VirusTotal does not have details about ' + url + '\n' + res.obj.verbose_msg});
                continue;
            }
            var md = '## VirusTotal URL Reputation for: ' + url + '\n';
            if (!o.scans && submitWait>0) {
                wait(parseInt(submitWait));
                res = doReq('GET', 'url/report', {resource: url});
                o = res.obj;
            }
            if (!o.scans) { // URL doesn't exist in VT
                md += 'URL submitted for scan. Please retry command later\n';
                ec[outputPaths.url] = {
                    Data: url,
                    VirusTotal: {
                        ScanID: o.scan_id
                    },
                    DetectionEngines: 0,
                    PositiveDetections: 0
                };
            } else {
                md += 'Last scan date: *' + o.scan_date + '*\n';
                md += 'Total scans: **' + o.total + '**\n';
                md += 'Positive scans: **' + o.positives + '**\n';
                md += 'VT Link: [' + url + '](' + o.permalink + ')\n';
                var dbotScore = 0;
                if (o.positives >= threshold  || isEnoughPreferredVendors(o)) {
                    dbotScore = 3;
                    addMalicious(ec, outputPaths.url, {
                        Data: url,
                        Malicious: {Vendor: 'VirusTotal', Description: 'Positives / Total: ' + o.positives + ' / ' + o.total},
                        DetectionEngines: Object.keys(o.scans).length,
                        PositiveDetections: o.positives
                    });
                } else if (o.positives >= threshold / 2) {
                    dbotScore = 2;
                } else {
                    dbotScore = 1;
                }
                ec[DBOTSCORE_KEY] = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: dbotScore};
                longFormat = FULL_RESPONSE? 'true': longFormat;
                if (longFormat === 'true') { // add scans table
                    scansTable = createScansTable(o.scans);
                    md += tableToMarkdown('Scans', scansTable);
                    if (ec[outputPaths.url]){ // malicious
                        scans_ec = {
                            Scans: scansTable,
                            ScanID: o.scan_id,
                            vtLink: o.permalink
                        };
                        ec[outputPaths.url].VirusTotal = scans_ec;
                    } else { // not malicious
                        scans_ec = {
                            Data: url,
                            "VirusTotal": {
                                Scans: scansTable,
                                ScanID: o.scan_id,
                                vtLink: o.permalink
                            },
                            DetectionEngines: Object.keys(o.scans).length,
                            PositiveDetections: o.positives
                        };
                        ec[outputPaths.url] = scans_ec;
                    }
                } else { // short format
                    if (ec[outputPaths.url]){ // malicious
                        ec[outputPaths.url]['VirusTotal'] = {
                            ScanID: o.scan_id,
                            vtLink: o.permalink
                        };
                    } else { // not malicious
                        ec[outputPaths.url] = {
                            Data: url,
                            VirusTotal: {
                                ScanID: o.scan_id,
                                vtLink: o.permalink
                            },
                            DetectionEngines: Object.keys(o.scans).length,
                            PositiveDetections: o.positives
                        };
                    }
                }
            }
            entryList.push({
                Type: entryTypes.note,
                Contents: res.body,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: ec
            });
        }
        return entryList;
    }
    function doDomain(domain, threshold, longFormat, sampleSize, waitForRateLimit, retries, fullResponse) {
        if (!sampleSize) {
            sampleSize = 10;
        }
        if (!threshold) {
            threshold = DOMAIN_THRESHOLD || 10;
        }
        threshold = parseInt(threshold);
        var domainList = argToList(domain);
        var entryList = [];
        for (z = 0; z < domainList.length; z++) {
            domain = domainList[z];
            var res = withRetries(waitForRateLimit, retries, function() {return doReq('GET', 'domain/report', {domain: domain});});
            var o = res.obj;
            var ec = {};
            if (o.response_code === 0) {
                ec[DBOTSCORE_KEY] = {Indicator: domain, Type: 'domain', Vendor: 'VirusTotal', Score: 0};
                entryList.push({Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                    HumanReadable: 'VirusTotal does not have details about ' + domain + '\n' + res.obj.verbose_msg});
                continue;
            }
            full_response = FULL_RESPONSE? 'true': fullResponse;
            if (fullResponse === 'true') {
                maxLen = 1000;
            } else {
                maxLen = 50;
            }
            // Calculate score based on recently found downloads
            var badDownloads = calcRecentDownloads([o.detected_downloaded_samples, o.undetected_downloaded_samples]);
            var dbotScore = 0;
            if (badDownloads >= threshold) {
                dbotScore = 3;
                addMalicious(ec, outputPaths.domain, {Name: domain,
                    Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}});
            } else if (badDownloads >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }
            ec[DBOTSCORE_KEY] = {Indicator: domain, Type: 'domain', Vendor: 'VirusTotal', Score: dbotScore};
            var md = '## VirusTotal Domain Reputation for: ' + domain + '\n';
            md += '#### Domain categories: *' + o.categories + "*\n";
            md += 'VT Link: [' + domain + '](https://www.virustotal.com/en/search?query=' + encodeURIComponent(domain) + ')\n';
            var detectedUrls = o.detected_urls || [];
            var detectedDownloadedSamples = o.detected_downloaded_samples || [];
            var undetectedDownloadedSamples = o.undetected_downloaded_samples || [];
            var detectedCommunicatingSamples = o.detected_communicating_samples || [];
            var undetectedCommunicatingSamples = o.undetected_communicating_samples || [];
            var detectedReferrerSamples = o.detected_referrer_samples || [];
            var undetectedReferrerSamples = o.undetected_referrer_samples || [];
            var resolutions = o.resolutions || [];
            var arrTitle = [{a: detectedUrls, t: 'Detected URL'}, {a: detectedDownloadedSamples, t: 'Detected downloaded sample'},
                {a: undetectedDownloadedSamples, t: 'Undetected downloaded sample'}, {a: detectedCommunicatingSamples, t: 'Detected communicating sample'},
                {a: undetectedCommunicatingSamples, t: 'Undetected communicating sample'},{a: detectedReferrerSamples, t: 'Detected referrer sample'},
                {a: undetectedReferrerSamples, t: 'Undetected referrer sample'}, {a: resolutions, t: 'Resolutions'}];
            for (var i = 0; i<arrTitle.length; i++) {
                if (arrTitle[i].a) {
                    md += arrTitle[i].t + ' count: **' + arrTitle[i].a.length + '**\n';
                }
            }
            longFormat = FULL_RESPONSE? 'true': longFormat;
            if (longFormat === 'true') {
                for (var j = 0; j<arrTitle.length; j++) {
                    if (arrTitle[j].a) {
                        md += '### ' + arrTitle[j].t + '\n';
                        // Print only the first 10 rows
                        var curr = [];
                        for (var k = 0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {
                            curr.push(arrTitle[j].a[k]);
                        }
                        md += arrToMd(curr) + '\n';
                    }
                }
            }
            if (o.domain_siblings && o.domain_siblings.length > 0) {
                md += "### Observed subdomains\n";
                for (i = 0; i < o.domain_siblings.length; i++) {
                    md += "- " + o.domain_siblings[i] + "\n";
                }
            }
            if (o.whois) {
                var whoIs = o.whois.trim();
                var lines = whoIs ? whoIs.split("\n") : [];
                md += '### Whois Lookup\n';
                for (i = 0; i < lines.length; i++) {
                    var parts = lines[i].split(': ');
                    if (parts[0] && parts[1]) {
                        md += "**" + parts[0].trim() + "**: " + parts[1] + "\n";
                    }
                }
            }
            var detected_downloaded_samples = o.detected_downloaded_samples;
            if (detected_downloaded_samples === undefined) {
                detected_downloaded_samples = [];
            } else {
                detected_downloaded_samples = detected_downloaded_samples.slice(0,maxLen);
            }
            var undetected_downloaded_samples = o.undetected_downloaded_samples;
            if (undetected_downloaded_samples === undefined) {
                undetected_downloaded_samples = [];
            } else {
                undetected_downloaded_samples = undetected_downloaded_samples.slice(0,maxLen);
            }
            var detected_urls = o.detected_urls;
            if (detected_urls === undefined) {
                detected_urls = [];
            } else {
                detected_urls = detected_urls.slice(0,maxLen);
            }
            var detected_communicating_samples = o.detected_communicating_samples;
            if (detected_communicating_samples === undefined) {
                detected_communicating_samples = [];
            } else {
                detected_communicating_samples = detected_communicating_samples.slice(0,maxLen);
            }
            var undetected_communicating_samples = o.undetected_communicating_samples;
            if (undetected_communicating_samples === undefined) {
                undetected_communicating_samples = [];
            } else {
                undetected_communicating_samples = undetected_communicating_samples.slice(0,maxLen);
            }
            resolutions = o.resolutions;
            if (resolutions === undefined) {
                resolutions = [];
            } else {
                resolutions = resolutions.slice(0,maxLen);
            }
            var detected_referrer_samples = o.detected_referrer_samples;
            if (detected_referrer_samples === undefined) {
                detected_referrer_samples = [];
            } else {
                detected_referrer_samples = detected_referrer_samples.slice(0,maxLen);
            }
            var undetected_referrer_samples = o.undetected_referrer_samples;
            if (undetected_referrer_samples === undefined) {
                undetected_referrer_samples = [];
            } else {
                undetected_referrer_samples = undetected_referrer_samples.slice(0,maxLen);
            }
            var domain_siblings = o.domain_siblings;
            if (domain_siblings === undefined) {
                domain_siblings = [];
            } else {
                domain_siblings = domain_siblings.slice(0,maxLen);
            }
            domain_ec = {
                "Name": domain,
                "VirusTotal": {
                    'DownloadedHashes': detected_downloaded_samples,
                    'UnAVDetectedDownloadedHashes': undetected_downloaded_samples,
                    "DetectedURLs": detected_urls,
                    'CommunicatingHashes': detected_communicating_samples,
                    'UnAVDetectedCommunicatingHashes': undetected_communicating_samples,
                    'Resolutions': resolutions,
                    'ReferrerHashes': detected_referrer_samples,
                    'UnAVDetectedReferrerHashes': undetected_referrer_samples,
                    'Whois': o.whois,
                    'Subdomains': domain_siblings,
                }
            };
            if (ec[outputPaths.domain]){ // malicious
                ec[outputPaths.domain].VirusTotal = {
                    'DownloadedHashes': detected_downloaded_samples,
                    'UnAVDetectedDownloadedHashes': undetected_downloaded_samples,
                    "DetectedURLs": detected_urls,
                    'CommunicatingHashes': detected_communicating_samples,
                    'UnAVDetectedCommunicatingHashes': undetected_communicating_samples,
                    'Resolutions': resolutions,
                    'ReferrerHashes': detected_referrer_samples,
                    'UnAVDetectedReferrerHashes': undetected_referrer_samples,
                    'Whois': o.whois,
                    'Subdomains': domain_siblings,
                };
            } else { // not malicious
                ec[outputPaths.domain] = domain_ec;
            }

            entryList.push({
                Type: entryTypes.note,
                Contents: res.body,
                ContentsFormat: formats.json,
                HumanReadable: md,
                EntryContext: ec
            });
        }
        return entryList;
    }
    function scanURL(url) {
        var res = doReq('POST', 'url/scan', {url: url});
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple URLs so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        var ec = {vtScanID: [], vtLink: []};
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal URL scan for: [' + r[i].url + '](' + r[i].permalink + ')\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            ec.vtScanID.push(r[i].scan_id);
            ec.vtLink.push(r[i].permalink);
            md += 'Scan Date: **' + r[i].scan_date + '**\n\n';
        }
        return {
            Type: entryTypes.note,
            Contents: res.body,
            ContentsFormat: formats.json,
            HumanReadable: md,
            EntryContext: ec
        };
    }
    function scanFile(entry, uploadURL) {
        var url = uploadURL ? uploadURL : serverUrl + 'file/scan';
        var fileName = dq(invContext, "File(val.EntryID == '" + entry + "').Name");
        if (Array.isArray(fileName)) {
            if (fileName.length > 0) {
                fileName = fileName[0];
            } else {
                fileName = undefined;
            }
        }
        var result = httpMultipart(url, entry, {Method: 'POST', Headers: {'Accept': ['application/json']}}, {apikey: params.APIKey},
            params.insecure, params.proxy, undefined, 'file', fileName);
        if (result.StatusCode < 200 || result.StatusCode > 299) {
            throw 'Failed to perform request ' + url + ', request status code: ' + result.StatusCode;
        }
        if (result.Body === '' && result.StatusCode == 204) {
            throw 'No content recieved. Possible API rate limit reached.';
        }
        if (result.Body === '') {
            throw 'No content recieved. Maybe you tried a private API?.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (obj.response_code !== 1) {
            throw 'Response code: ' + obj.response_code + ', message: ' + obj.verbose_msg;
        }
        var ec = {};
        ec.vtScanID = obj.scan_id;
        ec.vtLink = obj.permalink;
        var md = '## VirusTotal scan file for [' + entry + '](' + obj.permalink + ')\n';
        md += 'Resource: **' + obj.resource + '**\n';
        md += 'MD5 / SHA1 / SHA256: **' + obj.md5 + ' / ' + obj.sha1 + ' / ' + obj.sha256 + '**\n';
        return {
            Type: entryTypes.note,
            Contents: result.Body,
            ContentsFormat: formats.json,
            HumanReadable: md,
            EntryContext: ec
        };
    }
    function rescanFile(hash) {
        var res = doReq('POST', 'file/rescan', {resource: hash});
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple hashes so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        var ec = {vtScanID: [], vtLink: []};
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal File Rescan for: [' + r[i].resource + '](' + r[i].permalink + ')\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            ec.vtScanID.push(r[i].scan_id);
            ec.vtLink.push(r[i].permalink);
            md += 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\n\n';
        }
        return {
            Type: entryTypes.note,
            Contents: res.body,
            ContentsFormat: formats.json,
            HumanReadable: md,
            EntryContext: ec
        };
    }
    function doComments(resource, comment) {
        var res = doReq('POST', 'comments/put', {resource: resource, comment: comment});
        return {
            Type: entryTypes.note,
            Contents: res.body,
            ContentsFormat: formats.json,
            HumanReadable: res.obj.verbose_msg
        };
    }
    function getComments(resource, before) {
        var params = {resource: resource};
        if (before) {
            params.before = before;
        }
        var res = doReq('GET', 'comments/get', params);
        return {
            Type: entryTypes.note,
            Contents: res.body,
            ContentsFormat: formats.json,
            HumanReadable: arrToMd(res.obj.comments)
        };
    }
    function fileScanUploadURL() {
        var res = doReq('GET', 'file/scan/upload_url');
        return {
            Type: entryTypes.note,
            Contents: res.body,
            ContentsFormat: formats.json,
            HumanReadable: res.obj.upload_url,
            EntryContext: {vtUploadURL: res.obj.upload_url}
        };
    }
    function test() {
        // if getting "No content received. Possible API rate limit reached." it's means that the api key use not usable right now, but it's working
        try
        {
            doFile('7657fcb7d772448a6d8504e4b20168b8'); // Check sample file - it will throw an error if not successful
        } catch(err)
        {
            if (err == "No content received. Possible API rate limit reached."){
                return true;
            }
            return String(err);
        }
        return true;
    }
    try {
        switch (command) {
            case 'test-module':
                return test();
            case 'file':
                return doFile(args.file, args.long, args.threshold, args.wait, args.retries);
            case 'ip':
                return doIP(args.ip, args.long, args.threshold, args.sampleSize, args.wait, args.retries, args.fullResponse);
            case 'url':
                return doURL(args.url, args.threshold, args.long, args.sampleSize, args.submitWait, args.wait, args.retries);
            case 'domain':
                return doDomain(args.domain, args.threshold, args.long, args.sampleSize, args.wait, args.retries);
            case 'file-scan':
                return scanFile(args.entryID, args.uploadURL);
            case 'file-rescan':
                return rescanFile(args.file);
            case 'url-scan':
                return scanURL(args.url);
            case 'vt-comments-add':
                return doComments(args.resource, args.comment);
            case 'vt-comments-get':
                return getComments(args.resource, args.before);
            case 'vt-file-scan-upload-url':
                return fileScanUploadURL();
            default:
                throw 'Unknown command - ' + command;
        }
    } catch (err) {
        return {
            'Type' : entryTypes.error,
            'ContentsFormat' : formats.text,
            'Contents': err,
            'EntryContext': {'Error': err}
        };
    }
  type: javascript
  commands:
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: A CSV list of hashes of the file to query. Supports MD5, SHA1,
        and SHA256.
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return full response for scans. Default is "false".
      defaultValue: "false"
    - name: threshold
      description: If the number of positives is higher than the threshold, the file
        will be considered malicious. If the threshold is not specified, the default
        file threshold, as configured in the instance settings, will be used.
    - name: wait
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      defaultValue: "60"
    - name: retries
      description: Number of retries for the API rate limit. Default is "0".
      defaultValue: "0"
    outputs:
    - contextPath: File.MD5
      description: Bad MD5 hash.
    - contextPath: File.SHA1
      description: Bad SHA1 hash.
    - contextPath: File.SHA256
      description: Bad SHA256 hash.
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
    - contextPath: File.Malicious.Detections
      description: For malicious files, the total number of detections.
    - contextPath: File.Malicious.TotalEngines
      description: For malicious files, the total number of engines that checked the
        file hash.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: File.VirusTotal.Scans.Source
      description: Vendor used to scan the hash.
    - contextPath: File.VirusTotal.Scans.Detected
      description: Scan detection for this hash (True or False).
    - contextPath: File.VirusTotal.Scans.Result
      description: Scan result for this hash, for example, signature.
    - contextPath: File.VirusTotal.ScanID
      description: Scan ID for this hash.
      type: string
    - contextPath: File.PositiveDetections
      description: Number of engines that positively detected the indicator as malicious.
      type: number
    - contextPath: File.DetectionEngines
      description: Total number of engines that checked the indicator.
      type: number
    - contextPath: File.VirusTotal.vtLink
      description: Virus Total permanent link.
      type: string
    description: Checks the file reputation of the specified hash.
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check.
      isArray: true
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return full response for detected URLs. Default is "false".
      defaultValue: "false"
    - name: threshold
      description: If the number of positives is higher than the threshold, the IP
        address will be considered malicious. If the threshold is not specified, the
        default IP threshold, as configured in the instance settings, will be used.
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format. Default is "10".
      defaultValue: "10"
    - name: wait
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit. Default is "0".
      defaultValue: "0"
    - name: fullResponse
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return all results, which can be thousands. Default
        is "false". We recommend that you don't return full results in playbooks.
      defaultValue: "false"
    outputs:
    - contextPath: IP.Address
      description: Bad IP address.
    - contextPath: IP.ASN
      description: Bad IP ASN.
    - contextPath: IP.Geo.Country
      description: Bad IP country.
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision.
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: IP.VirusTotal.DownloadedHashes
      description: Latest files that were detected by at least one antivirus solution,
        and were downloaded by VirusTotal from the IP address.
    - contextPath: IP.VirusTotal.UnAVDetectedDownloadedHashes
      description: Latest files that were not detected by any antivirus solution,
        and were downloaded by VirusTotal from the specified IP address.
    - contextPath: IP.VirusTotal.DetectedURLs
      description: Latest URLs hosted in this IP address that were detected by at
        least one URL scanner.
    - contextPath: IP.VirusTotal.CommunicatingHashes
      description: Latest detected files that communicate with this IP address.
    - contextPath: IP.VirusTotal.UnAVDetectedCommunicatingHashes
      description: Latest undetected files that communicate with this IP address.
    - contextPath: IP.VirusTotal.Resolutions.hostname
      description: Domains that resolved to the specified IP address.
    - contextPath: IP.VirusTotal.ReferrerHashes
      description: Latest detected files that embed this IP address in their strings.
    - contextPath: IP.VirusTotal.UnAVDetectedReferrerHashes
      description: Latest undetected files that embed this IP address in their strings.
    - contextPath: IP.VirusTotal.Resolutions.last_resolved
      description: Last resolution times of the domains that resolved to the specified
        IP address.
    description: Checks the reputation of an IP address.
  - name: url
    arguments:
    - name: url
      required: true
      default: true
      description: The URL to check.
      isArray: true
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format.
      defaultValue: "10"
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return the full response for the detected URLs.
      defaultValue: "false"
    - name: threshold
      description: If the number of positives is higher than the threshold, the URL
        will be considered malicious. If the threshold is not specified, the default
        URL threshold, as configured in the instance settings, will be used.
    - name: submitWait
      description: Time (in seconds) to wait if the URL does not exist and is submitted
        for scanning. Default is "0".
      defaultValue: "0"
    - name: wait
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit. Default is "0".
      defaultValue: "0"
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found.
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: URL.VirusTotal.Scans.Source
      description: Vendor that scanned this URL.
    - contextPath: URL.VirusTotal.Scans.Detected
      description: Scan detection for this URL (True or False).
    - contextPath: URL.VirusTotal.Scans.Result
      description: Scan result for this URL, for example, signature.
    - contextPath: URL.DetectionEngines
      description: Total number of engines that checked the indicator.
      type: number
    - contextPath: URL.PositiveDetections
      description: Number of engines that positively detected the indicator as malicious.
      type: number
    - contextPath: url.VirusTotal.ScanID
      description: Scan ID for this URL.
      type: string
    - contextPath: File.VirusTotal.vtLink
      description: Virus Total permanent link.
      type: string
    description: Checks the reputation of a URL.
  - name: domain
    arguments:
    - name: domain
      required: true
      default: true
      description: Domain name to check.
      isArray: true
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return the full response for detected URLs. Default
        is "false".
      defaultValue: "false"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format.
      defaultValue: "10"
    - name: threshold
      description: If the number of positives is higher than the threshold, the domain
        will be considered malicious. If the threshold is not specified, the default
        domain threshold, as configured in the instance settings, will be used.
    - name: wait
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit. Default is "0".
      defaultValue: "0"
    - name: fullResponse
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return all results, which can be thousands. Default
        is "false". We recommend that you don't return full results in playbooks.
      defaultValue: "false"
    outputs:
    - contextPath: Domain.Name
      description: Bad domain found.
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: Domain.VirusTotal.DownloadedHashes
      description: Hashes of files that were downloaded from this domain.
    - contextPath: Domain.VirusTotal.CommunicatingHashes
      description: Hashes of files that communicated with this domain in a sandbox.
    - contextPath: Domain.VirusTotal.Resolutions.ip_address
      description: IP addresses that resolved to this domain.
    - contextPath: Domain.VirusTotal.Whois
      description: Whois report.
    - contextPath: Domain.VirusTotal.Subdomains
      description: Subdomains.
    - contextPath: Domain.VirusTotal.UnAVDetectedDownloadedHashes
      description: Latest files that were not detected by any antivirus solution,
        and were downloaded by VirusTotal from the specified IP address.
    - contextPath: Domain.VirusTotal.DetectedURLs
      description: Latest URLs hosted in this domain address that were detected by
        at least one URL scanner.
    - contextPath: Domain.VirusTotal.ReferrerHashes
      description: Latest detected files that embed this domain address in their strings.
    - contextPath: Domain.VirusTotal.UnAVDetectedReferrerHashes
      description: Latest undetected files that embed this domain address in their
        strings.
    - contextPath: Domain.VirusTotal.UnAVDetectedCommunicatingHashes
      description: Latest undetected files that communicated with this domain in a
        sandbox.
    - contextPath: Domain.VirusTotal.Resolutions.last_resolved
      description: Last resolution times of the IP addresses that resolve to this
        domain.
    description: Checks the reputation of a domain.
  - name: file-scan
    arguments:
    - name: entryID
      required: true
      default: true
      description: The file entry ID to submit.
    - name: uploadURL
      description: Private API extension. Special upload URL for files larger than
        32 MB.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files.
    - contextPath: vtLink
      description: Virus Total permanent link.
      type: string
    description: Submits a file for scanning.
  - name: file-rescan
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to re-scan. Supports MD5, SHA1, and SHA256.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files.
    - contextPath: vtLink
      description: Virus Total permanent link.
      type: string
    description: Re-scans an already submitted file. This avoids having to upload
      the file again.
  - name: url-scan
    arguments:
    - name: url
      required: true
      default: true
      description: The URL to scan.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted URLs.
    - contextPath: vtLink
      description: Virus Total permanent link.
      type: string
    description: Scans a specified URL.
  - name: vt-comments-add
    arguments:
    - name: resource
      required: true
      default: true
      description: The file hash (MD5, SHA1, or SHA256) or URL on which you're commenting.
    - name: comment
      required: true
      description: 'The actual review, which you can tag by using the "#" twitter-like
        syntax, for example, #disinfection #zbot, and reference users using the "@"
        syntax, for example, @VirusTotalTeam).'
    description: Adds comments to files and URLs.
  - name: vt-file-scan-upload-url
    arguments: []
    outputs:
    - contextPath: vtUploadURL
      description: The special upload URL for large files.
    description: Private API. Get a special URL for files larger than 32 MB.
  - name: vt-comments-get
    arguments:
    - name: resource
      required: true
      default: true
      description: The file hash (MD5, SHA1, orSHA256) or URL from which you're retrieving
        comments.
    - name: before
      description: Datetime token in the format YYYYMMDDHHMISS. You can use this for
        paging.
    description: Private API. Retrieves comments for a given resource.
  runonce: false
tests:
 -  virusTotal-test-playbook
