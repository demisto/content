category: Analytics & SIEM
sectionOrder:
- Connect
- Collect
commonfields:
  id: Azure Sentinel - test
  version: -1
configuration:
- defaultvalue: Worldwide
  display: Azure Cloud
  name: azure_cloud
  type: 15
  options:
  - Worldwide
  - US GCC
  - US GCC-High
  - DoD
  - Germany
  - China
  - Custom
  section: Connect
  advanced: true
  additionalinfo: When selecting the Custom option, the Server URL parameter must be filled. More information about National clouds can be found here - https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#using-national-cloud
  required: false
- name: limit
  type: 0
  section: Collect
  required: false
  defaultvalue: '20'
  display: Maximum number of incidents per fetch.
- name: creds_tenant_id
  type: 9
  section: Connect
  required: false
  displaypassword: Tenant ID
  hiddenusername: true
- display: Tenant ID
  name: tenant_id
  type: 4
  section: Connect
  required: false
  hidden: true
- display: Client ID
  name: credentials
  type: 9
  section: Connect
  required: false
- additionalinfo: Used for certificate authentication. As appears in the "Certificates & secrets" page of the app.
  display: Certificate Thumbprint
  name: creds_certificate
  type: 9
  section: Connect
  advanced: true
  required: false
  displaypassword: Private Key
- additionalinfo: Used for certificate authentication. As appears in the "Certificates & secrets" page of the app.
  display: Certificate Thumbprint
  name: certificate_thumbprint
  type: 4
  hidden: true
  section: Connect
  advanced: true
  required: false
- additionalinfo: Used for certificate authentication. The private key of the registered certificate.
  display: Private Key
  name: private_key
  type: 14
  section: Connect
  advanced: true
  required: false
  hidden: true
- additionalinfo: Relevant only if the integration is running on Azure VM. If selected, authenticates based on the value provided for the Azure Managed Identities Client ID field. If no value is provided for the Azure Managed Identities Client ID field, authenticates based on the System Assigned Managed Identity. For additional information, see the Help tab.
  name: use_managed_identities
  type: 8
  section: Connect
  advanced: true
  required: false
  display: Use Azure Managed Identities
- name: managed_identities_client_id
  required: false
  additionalinfo: The Managed Identities client id for authentication - relevant only if the integration is running on Azure VM.
  type: 9
  section: Connect
  displaypassword: Azure Managed Identities Client ID
  hiddenusername: true
  advanced: true
- display: Default Subscription ID
  name: subscriptionID
  required: true
  additionalinfo: The parameter can be saved as 000-000 and added as an argument to each command, but Test button will fail.
  type: 0
  section: Connect
- display: Default Resource Group Name
  name: resourceGroupName
  required: true
  type: 0
  section: Connect
  additionalinfo: The parameter can be saved as 000-000 and added as an argument to each command, but the Test button will fail.
- display: Workspace Name
  name: workspaceName
  type: 0
  section: Connect
  required: true
- display: Fetch incidents
  name: isFetch
  type: 8
  section: Collect
  required: false
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  type: 0
  section: Collect
  required: false
- display: The minimum severity of incidents to fetch
  name: min_severity
  type: 15
  section: Collect
  required: false
  defaultvalue: Informational
  options:
  - Informational
  - Low
  - Medium
  - High
  advanced: true
- display: Incident type
  name: incidentType
  type: 13
  section: Connect
  required: false
- display: Server URL
  name: server_url
  type: 0
  section: Connect
  advanced: true
  required: false
  defaultvalue: https://management.azure.com
  additionalinfo: Use this option when required to customize the URL to the Azure management endpoint. More information can be found here - https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#using-national-cloud
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  section: Connect
  advanced: true
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  section: Connect
  advanced: true
  required: false
- display: Additional info to fetch
  name: fetch_additional_info
  type: 16
  section: Collect
  options:
  - Alerts
  - Entities
  - Comments
  - Relations
  required: false
  additionalinfo: "Choose what additional info to fetch for each incident.\nNote that this will increase the number of API calls.\n"
  advanced: true
- defaultvalue: None
  display: Mirroring Direction
  name: mirror_direction
  type: 15
  hidden: false
  section: Collect
  required: false
  options:
  - None
  - Incoming
  - Outgoing
  - Incoming And Outgoing
- additionalinfo: When selected, closing the Microsoft Sentinel ticket is mirrored in Cortex XSOAR.
  defaultvalue: 'false'
  display: Close Mirrored XSOAR Incident
  name: close_incident
  type: 8
  hidden: false
  section: Collect
  advanced: true
  required: false
- additionalinfo: When selected, closing the Cortex XSOAR incident is mirrored in Microsoft Sentinel.
  defaultvalue: 'false'
  display: Close Mirrored Microsoft Sentinel Ticket
  name: close_ticket
  type: 8
  hidden: false
  section: Collect
  advanced: true
  required: false
- additionalinfo: The statuses of the incidents that will be fetched. If no status is provided then incidents of all the statuses will be fetched.
  display: Incident Statuses to Fetch
  name: statuses_to_fetch
  options:
  - New
  - Active
  - Closed
  type: 16
  section: Collect
  advanced: true
  required: false
- defaultvalue: '1'
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
  section: Collect
  advanced: true
description: 'Microsoft Sentinel is a scalable, cloud-native solution that provides: Security information and event management (SIEM) Security orchestration, automation, and response (SOAR).'
display: Microsoft Sentinel - test
name: Azure Sentinel - test
script:
  commands:
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a single incident from Azure Sentinel.
    name: azure-sentinel-get-incident-by-id
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeObjectID
      description: The object ID of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.AssigneeUPN
      description: The user principal name of incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.IncidentUrl
      description: The deep-link URL to the incident in the Azure portal.
      type: String
  - arguments:
    - defaultValue: '50'
      description: The maximum number of incidents to return. The maximum value is 200.
      name: limit
    - description: 'Filter results using OData syntax. For example: properties/createdTimeUtc gt 2020-02-02T14:00:00Z`). For more information, see the Azure documentation: https://docs.microsoft.com/bs-latn-ba/azure/search/search-query-odata-filter.'
      name: filter
    - description: A link that specifies a starting point to use for subsequent calls. This argument overrides all of the other command arguments.
      name: next_link
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of incidents from Azure Sentinel.
    name: azure-sentinel-list-incidents
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.NextLink.Description
      description: Description of NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns partial results. If a response contains a NextLink element, its value specifies a starting point to use for subsequent calls.
      type: String
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
  - arguments:
    - description: Alias of the specific watchlist to get.
      name: watchlist_alias
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of watchlists from Azure Sentinel.
    name: azure-sentinel-list-watchlists
    outputs:
    - contextPath: AzureSentinel.Watchlist.ID
      description: The watchlist ID.
      type: String
    - contextPath: AzureSentinel.Watchlist.Description
      description: A description of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.DisplayName
      description: The display name of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Provider
      description: The provider of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Source
      description: The source of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Created
      description: The time the watchlist was created.
      type: Date
    - contextPath: AzureSentinel.Watchlist.Updated
      description: The last time the watchlist was updated.
      type: Date
    - contextPath: AzureSentinel.Watchlist.CreatedBy
      description: The name of the user who created the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.UpdatedBy
      description: The name of the user who updated the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Alias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Label
      description: Label that will be used to tag and filter on.
      type: unknown
    - contextPath: AzureSentinel.Watchlist.ItemsSearchKey
      description: The search key is used to optimize query performance when using watchlists for joins with other data. For example, enable a column with IP addresses to be the designated SearchKey field, then use this field as the key field when joining to other event data by IP address.
      type: String
    - contextPath: AzureSentinel.NextLink.Description
      description: Description of NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns partial results. If a response contains a NextLink element, its value specifies a starting point to use for subsequent calls.
      type: String
  - arguments:
    - description: Alias of the watchlist to be deleted.
      name: watchlist_alias
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Delete a watchlist from Azure Sentinel.
    name: azure-sentinel-delete-watchlist
  - arguments:
    - description: The alias of the new watchlist or the watchlist to update.
      name: watchlist_alias
      required: true
    - description: The display name of the watchlist.
      name: watchlist_display_name
      required: true
    - description: The description of the watchlist.
      name: description
    - defaultValue: XSOAR
      description: The provider of the watchlist.
      name: provider
    - description: The labels of the watchlist.
      isArray: true
      name: labels
    - defaultValue: '0'
      description: The number of lines in the CSV content to skip before the header.
      name: lines_to_skip
    - description: A file entry with raw content that represents the watchlist items to create.
      name: file_entry_id
      required: true
    - description: The search key is used to optimize query performance when using watchlists for joins with other data. For example, enable a column with IP addresses to be the designated SearchKey field, then use this field as the key field when joining to other event data by IP address.
      name: items_search_key
      required: true
    - defaultValue: Text/Csv
      description: The content type of the raw content. For now, only text/csv is valid.
      name: content_type
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Create or update a watchlist in Azure Sentinel.
    name: azure-sentinel-watchlist-create-update
    outputs:
    - contextPath: AzureSentinel.Watchlist.Name
      description: The name of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.ID
      description: The ID (GUID) of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Description
      description: A description of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Provider
      description: The provider of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Source
      description: The source of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Created
      description: The time the watchlist was created.
      type: Date
    - contextPath: AzureSentinel.Watchlist.Updated
      description: The time the watchlist was updated.
      type: Date
    - contextPath: AzureSentinel.Watchlist.CreatedBy
      description: The user who created the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.UpdatedBy
      description: The user who updated the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Alias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Label
      description: List of labels relevant to this watchlist.
      type: Unknown
    - contextPath: AzureSentinel.Watchlist.ItemsSearchKey
      description: The search key is used to optimize query performance when using watchlists for joins with other data.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The incident's title.
      name: title
    - description: Description of the incident.
      name: description
    - auto: PREDEFINED
      description: The incident severity.
      name: severity
      predefined:
      - High
      - Medium
      - Low
      - Informational
    - auto: PREDEFINED
      description: The incident status.
      name: status
      predefined:
      - New
      - Active
      - Closed
    - auto: PREDEFINED
      description: The reason the incident was closed. Required when updating the status to Closed.
      name: classification
      predefined:
      - BenignPositive
      - FalsePositive
      - TruePositive
      - Undetermined
    - description: Describes the reason the incident was closed.
      name: classification_comment
    - auto: PREDEFINED
      description: The classification reason the incident was closed with. Required when updating the status to Closed and the classification is determined.
      name: classification_reason
      predefined:
      - InaccurateData
      - IncorrectAlertLogic
      - SuspiciousActivity
      - SuspiciousButExpected
    - description: The email address of the incident assignee. It is recommended to update *user_principal_name* instead of this field. Note that the updated API field is `owner.email`.
      name: assignee_email
    - description: The user principal name of the client. Note that the updated API field is `owner.userPrincipalName`.
      name: user_principal_name
    - description: Object ID of assignee. This is the unique object ID of a user to update the assignee of the incident. Updated key is owner.objectId.
      name: assignee_objectid
    - description: Incident labels. Note that all labels will be set as labelType='User'.
      name: labels
      isArray: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    - auto: PREDEFINED
      description: If set to true, the assignee will be removed and the incident will remain unassigned. Overrides the other arguments related to the assignee.
      name: unassign
      predefined:
      - 'false'
      - 'true'
      type: unknown
    description: Updates a single incident in Azure Sentinel.
    name: azure-sentinel-update-incident
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident's title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeObjectID
      description: The object ID of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.AssigneeUPN
      description: The user principal name of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes a single incident in Azure Sentinel.
    name: azure-sentinel-delete-incident
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - defaultValue: '50'
      description: The maximum number of incident comments to return. The maximum value is 50.
      name: limit
    - description: A link that specifies a starting point to use for subsequent calls. Using this argument overrides all of the other command arguments.
      name: next_link
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets the comments of an incident from Azure Sentinel.
    name: azure-sentinel-list-incident-comments
    outputs:
    - contextPath: AzureSentinel.IncidentComment.ID
      description: The ID of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.IncidentID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.IncidentComment.Message
      description: The incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorName
      description: The name of the author of the incident's comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorEmail
      description: The email address of the author of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.CreatedTimeUTC
      description: The date and time that the incident comment was created.
      type: Date
    - contextPath: AzureSentinel.NextLink.Description
      description: Description of NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns a partial result. If a response contains a NextLink element, its value specifies a starting point to use for subsequent calls.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The comment message.
      name: message
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Adds a comment to an incident in Azure Sentinel.
    name: azure-sentinel-incident-add-comment
    outputs:
    - contextPath: AzureSentinel.IncidentComment.ID
      description: The ID of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.IncidentID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.IncidentComment.Message
      description: The incident's comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorName
      description: The name of the author of the incident's comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorEmail
      description: The email address of the author of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.CreatedTimeUTC
      description: The date and time that the incident comment was created.
      type: Date
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The comment ID.
      name: comment_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes a comment from incident in Azure Sentinel.
    name: azure-sentinel-incident-delete-comment
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - defaultValue: '50'
      description: The maximum number of related entities to return.
      name: limit
    - description: A link that specifies a starting point to use for subsequent calls. Using this argument overrides all of the other command arguments.
      name: next_link
    - description: "A comma-separated list of entity kinds to filter by. By default, the results won't be filtered by kind.\nThe optional kinds are: Account, Host, File, AzureResource, CloudApplication, DnsResolution, FileHash, Ip, Malware, Process, RegistryKey, RegistryValue, SecurityGroup, Url, IoTDevice, SecurityAlert, Bookmark."
      isArray: true
      name: entity_kinds
      predefined:
      - ''
    - description: 'Filter results using OData syntax. For example: properties/createdTimeUtc gt 2020-02-02T14:00:00Z`). For more information see the Azure documentation: https://docs.microsoft.com/bs-latn-ba/azure/search/search-query-odata-filter.'
      name: filter
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of an incident's related entities from Azure Sentinel.
    name: azure-sentinel-list-incident-relations
    outputs:
    - contextPath: AzureSentinel.IncidentRelatedResource.ID
      description: The ID of the incident's related resource.
      type: String
    - contextPath: AzureSentinel.IncidentRelatedResource.Kind
      description: The kind of the incident's related resource.
      type: String
    - contextPath: AzureSentinel.NextLink.Description
      description: The description about NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns a partial result. If a response contains a NextLink element, its value specifies a starting point to use for subsequent calls.
      type: String
    - contextPath: AzureSentinel.IncidentRelatedResource.IncidentID
      description: The incident ID.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of an incident's entities from Azure Sentinel.
    name: azure-sentinel-list-incident-entities
    outputs:
    - contextPath: AzureSentinel.IncidentEntity.ID
      description: The ID of the entity.
      type: String
    - contextPath: AzureSentinel.IncidentEntity.IncidentId
      description: The ID of the incident.
      type: String
    - contextPath: AzureSentinel.IncidentEntity.Kind
      description: The kind of the entity.
      type: String
    - contextPath: AzureSentinel.IncidentEntity.Properties
      description: The properties of the entity.
      type: Unknown
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of an incident's alerts from Azure Sentinel.
    name: azure-sentinel-list-incident-alerts
    outputs:
    - contextPath: AzureSentinel.IncidentAlert.ID
      description: The ID of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.IncidentId
      description: The ID of the incident.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Kind
      description: The kind of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Tactic
      description: The tactics of the alert.
      type: Unknown
    - contextPath: AzureSentinel.IncidentAlert.Techniques
      description: The techniques of the alert.
      type: Unknown
    - contextPath: AzureSentinel.IncidentAlert.DisplayName
      description: The display name of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Description
      description: The description of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.ConfidenceLevel
      description: The confidence level of this alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Severity
      description: The severity of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.VendorName
      description: The name of the vendor that raised the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.ProductName
      description: The name of the product that published this alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.ProductComponentName
      description: The name of a component inside the product which generated the alert.
      type: String
  - arguments:
    - description: The alias of the watchlist.
      name: watchlist_alias
      required: true
    - description: The ID of the single watchlist item.
      name: watchlist_item_id
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Get a single watchlist item or list of watchlist items.
    name: azure-sentinel-list-watchlist-items
    outputs:
    - contextPath: AzureSentinel.WatchlistItem.WatchlistAlias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ID
      description: The ID (GUID) of the watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.Created
      description: The time the watchlist item was created.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.Updated
      description: The last time the watchlist item was updated.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.CreatedBy
      description: The name of the user.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.UpdatedBy
      description: The user who updated this item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ItemsKeyValue
      description: Key-value pairs for a watchlist item.
      type: Unknown
  - arguments:
    - description: The watchlist alias.
      name: watchlist_alias
      required: true
    - description: The watchlist item ID to be deleted.
      name: watchlist_item_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Delete a watchlist item.
    name: azure-sentinel-delete-watchlist-item
  - arguments:
    - description: The watchlist alias.
      name: watchlist_alias
      required: true
    - description: The watchlist item ID (GUID) to update.
      name: watchlist_item_id
    - description: The JSON for the itemsKeyValue of the item (the key value is different from watchlist to watchlist).
      name: item_key_value
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Create or update a watchlist item.
    name: azure-sentinel-create-update-watchlist-item
    outputs:
    - contextPath: AzureSentinel.WatchlistItem.WatchlistAlias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ID
      description: The ID (GUID) of the watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.Created
      description: The time the watchlist item was created.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.Updated
      description: The last time the watchlist item was updated.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.CreatedBy
      description: The name of the user who created this watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.UpdatedBy
      description: The user who updated this watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ItemsKeyValue
      description: Key-value pairs for a watchlist item.
      type: Unknown
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
    - defaultValue: '50'
      description: The maximum number of indicators to return.
      name: limit
    - description: "A link that specifies a starting point to use for subsequent calls.\nThis argument overrides all of the other command arguments.\nThere may be no support for pagination."
      name: next_link
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Returns a list of threat indicators.
    name: azure-sentinel-threat-indicator-list
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between 0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - defaultValue: '50'
      description: The maximum number of indicators to return.
      name: limit
    - description: "A link that specifies a starting point to use for subsequent calls.\nThis argument overrides all of the other command arguments.\nThere may be no support for pagination."
      name: next_link
    - description: The minimum confidence number for a threat indicator.
      name: min_confidence
    - description: The maximum confidence number for a threat indicator.
      name: max_confidence
    - description: Minimum valid until value of indicators to query.
      name: min_valid_until
    - description: Maximum valid until value of indicators to query.
      name: max_valid_until
    - auto: PREDEFINED
      defaultValue: 'false'
      description: If true, the query also returns disabled indicators.
      name: include_disabled
      predefined:
      - 'true'
      - 'false'
    - description: The sources of the threat indicator.
      isArray: true
      name: sources
    - auto: PREDEFINED
      description: The indicator types of the threat indicator.
      isArray: true
      name: indicator_types
      predefined:
      - ipv4
      - ipv6
      - file
      - url
      - domain
    - auto: PREDEFINED
      description: A comma-separated list of threat types of the threat indicator.
      isArray: true
      name: threat_types
      predefined:
      - anomalous-activity
      - attribution
      - anonymization
      - benign
      - malicious-activity
      - compromised
      - unknown
    - description: A comma-separated list of keywords.
      isArray: true
      name: keywords
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Returns a list of threat indicators with specific entities.
    name: azure-sentinel-threat-indicator-query
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between 0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: The value of the threat indicator.
      name: value
      required: true
    - description: The display name of the new indicator.
      name: display_name
      required: true
    - description: The description of the new indicator.
      name: description
    - auto: PREDEFINED
      description: The type of the new indicator.
      name: indicator_type
      predefined:
      - ipv4
      - ipv6
      - file
      - url
      - domain
      required: true
    - auto: PREDEFINED
      description: The hash type of the new indicator. This argument is mandatory if the indicator type is file.
      name: hash_type
      predefined:
      - MD5
      - SHA-1
      - SHA-256
      - SHA-512
    - description: The confidence of the new threat indicator. Should be a number between 0-100.
      name: confidence
    - auto: PREDEFINED
      description: A comma-separated list of threat types of the threat indicator.
      isArray: true
      name: threat_types
      predefined:
      - anomalous-activity
      - attribution
      - anonymization
      - benign
      - malicious-activity
      - compromised
      - unknown
      required: true
    - description: The kill chains phases of the indicator.
      isArray: true
      name: kill_chains
    - description: A comma-separated list of tags of the new threat indicator.
      isArray: true
      name: tags
    - description: The date from which the indicator is valid.
      name: valid_from
    - description: The date until which the indicator is valid.
      name: valid_until
    - description: The creator of the new indicator.
      name: created_by
    - auto: PREDEFINED
      defaultValue: 'false'
      description: If true, the indicator is revoked.
      name: revoked
      predefined:
      - 'true'
      - 'false'
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Creates a new threat indicator.
    name: azure-sentinel-threat-indicator-create
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between 0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
      required: true
    - description: The value of the indicator.
      name: value
      required: true
    - description: The display name of the indicator.
      name: display_name
      required: true
    - description: The description of the threat indicator.
      name: description
    - auto: PREDEFINED
      description: The type of the indicator.
      name: indicator_type
      predefined:
      - ipv4
      - ipv6
      - file
      - url
      - domain
      required: true
    - description: If indicator_type is a file, this entry is mandatory.
      name: hash_type
    - description: Whether the indicator is revoked.
      name: revoked
    - description: The confidence of the threat indicator. This is a number between 0-100.
      name: confidence
    - auto: PREDEFINED
      description: A comma-separated list of threat types of the threat indicator.
      isArray: true
      name: threat_types
      predefined:
      - anomalous-activity
      - attribution
      - anonymization
      - benign
      - malicious-activity
      - compromised
      - unknown
    - description: A comma-separated list of  kill chains phases of the indicator.
      isArray: true
      name: kill_chains
    - description: A comma-separated list of tags of the threat indicator.
      isArray: true
      name: tags
    - description: The date from which the indicator is valid.
      name: valid_from
    - description: The date until which the indicator is valid.
      name: valid_until
    - description: The creator of the indicator.
      name: created_by
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Updates an existing threat indicator.
    name: azure-sentinel-threat-indicator-update
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between 0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Was the threat indicator revoked or not.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: A comma-separated list of indicators to delete.
      isArray: true
      name: indicator_names
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes an existing threat indicator.
    name: azure-sentinel-threat-indicator-delete
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
      required: true
    - description: A comma-separated list of tags to append.
      isArray: true
      name: tags
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Appends new tags to an existing indicator.
    name: azure-sentinel-threat-indicator-tags-append
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between 0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Was the threat indicator revoked or not.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
      required: true
    - description: A comma-separated list of tags to replace.
      isArray: true
      name: tags
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Replaces the tags of a given indicator.
    name: azure-sentinel-threat-indicator-tags-replace
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between 0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: Date string representing the local time. The incident is only returned if it was modified after the last update time.
      name: lastUpdate
      required: true
    description: Gets the list of incidents and detections that were modified since the last update time. This method is used for debugging purposes.
    name: get-modified-remote-data
  - arguments:
    - description: The remote incident ID.
      name: id
      required: true
    - defaultValue: '0'
      description: The UTC timestamp in seconds of the last update. The incident is only updated if it was modified after the last update time.
      name: lastUpdate
    description: Gets data from a remote incident. This method does not update the current incident, and should be used for debugging purposes only.
    name: get-remote-data
  - description: Returns the list of fields to map in outgoing mirroring. This command is only used for debugging purposes.
    name: get-mapping-fields
  - description: Updates the remote incident with local incident changes. This method is only used for debugging purposes and will not update the current incident.
    name: update-remote-system
  - arguments:
    - description: The rule ID. If not given, will return all rules.
      name: rule_id
    - defaultValue: '50'
      description: The maximum number of rules to return.
      name: limit
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of all alert rules.
    name: azure-sentinel-list-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.type
      description: The type of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRule.etag
      description: ETag of the Azure resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertRuleTemplateName
      description: The name of the alert rule template used to create this rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayName
      description: The display name for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.description
      description: The description of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.enabled
      description: Determines whether this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.tactics
      description: The tactics of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule to run.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks at.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerOperator
      description: The operation against the threshold that triggers the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerThreshold
      description: The threshold that triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRule.properties.suppressionDuration
      description: The suppression (in ISO 8601 duration format) to wait since the last time this alert rule was triggered.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.suppressionEnabled
      description: Determines whether the suppression for this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.lastModifiedUtc
      description: The last time this alert rule was modified.
      type: Date
    - contextPath: AzureSentinel.AlertRule.properties.eventGroupingSettings.aggregationKind
      description: The event grouping aggregation kinds.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings.entityType
      description: The V3 type of the mapped entity.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings.fieldMappings.identifier
      description: The V3 identifier of the entity.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings.fieldMappings.columnName
      description: The column name to be mapped to the identifier.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertDisplayNameFormat
      description: The format containing the columns' name(s) used to override the alert name.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertDescriptionFormat
      description: The format containing columns' name(s) used to override the alert description.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertTacticsColumnName
      description: The column name to take the alert tactics from.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertSeverityColumnName
      description: The column name to take the alert severity from.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.createIncident
      description: Create incidents from alerts triggered by this analytics rule.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.enabled
      description: Whether grouping is enabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.reopenClosedIncident
      description: Re-open closed matching incidents.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.lookbackDuration
      description: Limit the group to alerts created within the lookback duration (in ISO 8601 duration format).
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.matchingMethod
      description: Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.groupByEntities
      description: A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.groupByAlertDetails
      description: A list of alert details to group by (when matchingMethod is Selected).
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.groupByCustomDetails
      description: A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severitiesFilter
      description: The alerts' severities on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayNamesFilter
      description: The alerts' displayNames on which the cases will be generated.
      type: Unknown
  - arguments:
    - description: The alert rule template ID. If not given, will return all alert rule templates.
      name: template_id
    - defaultValue: '50'
      description: The maximum number of templates to return.
      name: limit
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of all alert rule templates.
    name: azure-sentinel-list-alert-rule-template
    outputs:
    - contextPath: AzureSentinel.AlertRuleTemplate.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.type
      description: The type of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule to run.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks at.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.triggerOperator
      description: The operation against the threshold that triggers alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.triggerThreshold
      description: The threshold that triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.displayName
      description: The display name for the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.description
      description: The description of the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.tactics
      description: The tactics of the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.lastUpdatedDateUTC
      description: The time this alert rule template was last updated.
      type: Date
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.createdDateUTC
      description: The time this alert rule template was added.
      type: Date
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.status
      description: The alert rule template status.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.version
      description: The version of this template in the format <a.b.c>, where all are numbers. For example <1.0.2>.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.requiredDataConnectors.connectorId
      description: The connector ID that provides the following data types.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.requiredDataConnectors.dataTypes
      description: The data types used by the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.alertRulesCreatedByTemplateCount
      description: The number of alert rules that were created by this template.
      type: Number
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
  - arguments:
    - description: The alert rule ID to delete.
      name: rule_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes the specified alert rule.
    name: azure-sentinel-delete-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.ID
      description: The alert rule ID.
      type: String
    - contextPath: AzureSentinel.AlertRule.Deleted
      description: Whether the alert rule was deleted.
      type: Boolean
  - arguments:
    - description: The alert rule name to create.
      name: rule_name
      required: true
    - auto: PREDEFINED
      description: "The alert rule kind to create.\nRequired for all types.\n"
      name: kind
      predefined:
      - fusion
      - microsoft_security_incident_creation
      - scheduled
    - description: "The name of the alert rule template used to create this rule.\nRequired for Fusion, optional for Scheduled rules.\n"
      name: template_name
    - auto: PREDEFINED
      description: "Determines whether this alert rule is enabled or disabled.\nRequired for all types.\n"
      name: enabled
      predefined:
      - yes
      - no
    - description: ETag of the Azure resource.
      name: etag
    - description: "The display name for alerts created by this alert rule.\nRequired for MicrosoftSecurityIncidentCreation and scheduled rules.\n"
      name: displayName
    - auto: PREDEFINED
      description: "The alerts' productName on which the cases will be generated.\nRequired for MicrosoftSecurityIncidentCreation rules.\n"
      name: product_filter
      predefined:
      - azure_active_directory_identity_protection
      - azure_advanced_threat_protection
      - azure_security_center
      - azure_security_center_for_iot
      - microsoft_cloud_app_security
    - description: "The description of the alert rule.\nRelevant for MicrosoftSecurityIncidentCreation and scheduled rules.\n"
      name: description
    - description: "Alerts' displayNames on which the cases will not be generated.\nRelevant for MicrosoftSecurityIncidentCreation rules.\n"
      isArray: true
      name: name_exclude_filter
    - description: "Alerts' displayNames on which the cases will be generated.\nRelevant for MicrosoftSecurityIncidentCreation rules.\n"
      isArray: true
      name: name_include_filter
    - description: "Alerts' severities on which the cases will be generated.\nRelevant for MicrosoftSecurityIncidentCreation rules.\n"
      isArray: true
      name: severity_filter
    - description: "The query that creates alerts for this rule.\nRequired for scheduled rules.\n"
      name: query
    - description: "The frequency (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) for this alert rule to run.\nRequired for scheduled rules.\n"
      name: query_frequency
    - description: "The period (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) that this alert rule looks at.\nRequired for scheduled rules.\n"
      name: query_period
    - auto: PREDEFINED
      description: "The severity for alerts created by this alert rule.\nRequired for scheduled rules.\n"
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
    - description: "The suppression (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) to wait since the last time this alert rule was triggered.\nRequired for scheduled rules.\n"
      name: suppression_duration
    - auto: PREDEFINED
      description: "Determines whether the suppression for this alert rule is enabled or disabled.\nRequired for scheduled rules.\n"
      name: suppression_enabled
      predefined:
      - yes
      - no
    - auto: PREDEFINED
      description: "The operation against the threshold that triggers the alert rule.\nRequired for scheduled rules.\n"
      name: trigger_operator
      predefined:
      - equal
      - greater_than
      - less_than
      - not_equal
    - description: "The threshold that triggers this alert rule.\nRequired for scheduled rules.\n"
      name: trigger_threshold
    - description: "The tactics of the alert rule.\nRelevant for scheduled rules.\n"
      isArray: true
      name: tactics
    - description: "The techniques of the alert rule.\nRelevant for scheduled rules.\n"
      isArray: true
      name: techniques
    - description: "Option to insert a configured rule JSON instead of using the arguments.\n"
      name: rule_json
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Creates a new alert rule.
    name: azure-sentinel-create-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.etag
      description: ETag of the Azure resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.type
      description: The type of the resource, e.g., "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
      type: String
    - contextPath: AzureSentinel.AlertRule.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.displayName
      description: The display name for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.description
      description: The description of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertRuleTemplateName
      description: The name of the alert rule template used to create this rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.tactics
      description: The tactics of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.enabled
      description: Determines whether this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.lastModifiedUtc
      description: The last time that this alert was modified.
      type: Date
    - contextPath: AzureSentinel.AlertRule.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severitiesFilter
      description: The alerts' severities on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayNamesFilter
      description: The alerts' displayNames on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule to run.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks at.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerOperator
      description: The operation against the threshold that triggers the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerThreshold
      description: The threshold that triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRule.properties.suppressionDuration
      description: The suppression (in ISO 8601 duration format) to wait since the last time this alert rule was triggered.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.suppressionEnabled
      description: Determines whether the suppression for this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.eventGroupingSettings
      description: The event grouping settings.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.customDetails
      description: Dictionary of string key-value pairs of columns to be attached to the alert.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings
      description: Array of the entity mappings of the alert rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride
      description: The alert details override settings.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration
      description: The settings of the incidents that were created from alerts triggered by this analytics rule.
      type: Unknown
  - arguments:
    - description: The alert rule name to update.
      name: rule_name
      required: true
    - auto: PREDEFINED
      description: "The alert rule kind to update.\nRequired for all types.\n"
      name: kind
      predefined:
      - fusion
      - microsoft_security_incident_creation
      - scheduled
    - description: "The name of the alert rule template used to update this rule.\nRequired for Fusion, optional for Scheduled rules.\n"
      name: template_name
    - auto: PREDEFINED
      description: "Determines whether this alert rule is enabled or disabled.\nRequired for all types.\n"
      name: enabled
      predefined:
      - yes
      - no
    - description: ETag of the Azure resource.
      name: etag
    - description: "The display name for alerts created by this alert rule.\nRequired for MicrosoftSecurityIncidentCreation and scheduled rules.\n"
      name: displayName
    - auto: PREDEFINED
      description: "The alerts' productName on which the cases will be generated.\nRequired for MicrosoftSecurityIncidentCreation rules.\n"
      name: product_filter
      predefined:
      - azure_active_directory_identity_protection
      - azure_advanced_threat_protection
      - azure_security_center
      - azure_security_center_for_iot
      - microsoft_cloud_app_security
    - description: "The description of the alert rule.\nRelevant for MicrosoftSecurityIncidentCreation and scheduled rules.\n"
      name: description
    - description: "Alerts' displayNames on which the cases will not be generated.\nRelevant for MicrosoftSecurityIncidentCreation rules.\n"
      isArray: true
      name: name_exclude_filter
    - description: "Alerts' displayNames on which the cases will be generated.\nRelevant for MicrosoftSecurityIncidentCreation rules.\n"
      isArray: true
      name: name_include_filter
    - description: "Alerts' severities on which the cases will be generated.\nRelevant for MicrosoftSecurityIncidentCreation rules.\n"
      isArray: true
      name: severity_filter
    - description: "The query that creates alerts for this rule.\nRequired for scheduled rules.\n"
      name: query
    - description: "The frequency (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) for this alert rule to run.\nRequired for scheduled rules.\n"
      name: query_frequency
    - description: "The period (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) that this alert rule looks at.\nRequired for scheduled rules.\n"
      name: query_period
    - auto: PREDEFINED
      description: "The severity for alerts created by this alert rule.\nRequired for scheduled rules.\n"
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
    - description: "The suppression (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) to wait since the last time this alert rule was triggered.\nRequired for scheduled rules.\n"
      name: suppression_duration
    - auto: PREDEFINED
      description: "Determines whether the suppression for this alert rule is enabled or disabled.\nRequired for scheduled rules.\n"
      name: suppression_enabled
      predefined:
      - yes
      - no
    - auto: PREDEFINED
      description: "The operation against the threshold that triggers the alert rule.\nRequired for scheduled rules.\n"
      name: trigger_operator
      predefined:
      - equal
      - greater_than
      - less_than
      - not_equal
    - description: "The threshold that triggers this alert rule.\nRequired for scheduled rules.\n"
      name: trigger_threshold
    - description: "The tactics of the alert rule.\nRelevant for scheduled rules.\n"
      isArray: true
      name: tactics
    - description: "The techniques of the alert rule.\nRelevant for scheduled rules.\n"
      isArray: true
      name: techniques
    - description: "Option to insert a configured rule JSON instead of using the arguments.\n"
      name: rule_json
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Updates an alert rule.
    name: azure-sentinel-update-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.etag
      description: ETag of the Azure resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.type
      description: The type of the resource, e.g., "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
      type: String
    - contextPath: AzureSentinel.AlertRule.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.displayName
      description: The display name for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.description
      description: The description of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertRuleTemplateName
      description: The name of the alert rule template used to update this rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.tactics
      description: The tactics of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.enabled
      description: Determines whether this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.lastModifiedUtc
      description: The last time this alert was modified.
      type: Date
    - contextPath: AzureSentinel.AlertRule.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severitiesFilter
      description: The alerts' severities on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayNamesFilter
      description: The alerts' displayNames on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule to run.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks at.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerOperator
      description: The operation against the threshold that triggers alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerThreshold
      description: The threshold triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRule.properties.suppressionDuration
      description: The suppression (in ISO 8601 duration format) to wait since the last time this alert rule been triggered.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.suppressionEnabled
      description: Determines whether the suppression for this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.eventGroupingSettings
      description: The event grouping settings.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.customDetails
      description: Dictionary of string key-value pairs of columns to be attached to the alert.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings
      description: Array of the entity mappings of the alert rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride
      description: The alert details override settings.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration
      description: The settings of the incidents that were created from alerts triggered by this analytics rule.
      type: Unknown
  - name: azure-sentinel-subscriptions-list
    description: Lists all subscriptions.
    outputs:
    - contextPath: AzureSentinel.SubscriptionId
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.displayName
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.authorizationSource
      description: The authorization source of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.managedByTenants
      description: The subscriptions that are managed by tenants of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.tenetId
      description: The tenet ID of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.state
      description: The state of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.subscriptionPolicies
      description: The subscription policies of the resource.
      type: String
  - name: azure-sentinel-resource-group-list
    description: List all resource groups for a subscription.
    arguments:
    - name: subscription_id
      description: 'The subscription ID. Note: The integration default Subscription ID will be used unless this argument is provided.'
      type: String
    - name: tag
      description: A single tag in the form of '{"Tag Name":"Tag Value"}' to filter the list by.
      type: String
    - name: limit
      description: The maximum number of resource groups to return.
      defaultValue: 50
      type: Number
    outputs:
    - contextPath: AzureSentinel.ResourceGroup.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.ResourceGroup.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.ResourceGroup.type
      description: The type of the resource. E.g., "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
      type: String
    - contextPath: AzureSentinel.ResourceGroup.location
      description: The location of the resource group.
      type: String
    - contextPath: AzureSentinel.ResourceGroup.tags
      description: The tags of the resource group.
      type: Dictionary
    - contextPath: AzureSentinel.ResourceGroup.properties
      description: The properties of the resource group.
      type: dictionary
  - description: Run this command if for some reason you need to rerun the authentication process.
    execution: false
    name: azure-sentinel-auth-reset
    arguments: []
  - arguments:
    - name: title
      description: The incident's title.
      required: true
    - auto: PREDEFINED
      description: The incident severity.
      name: severity
      predefined:
      - High
      - Medium
      - Low
      - Informational
    - auto: PREDEFINED
      description: The incident status.
      name: status
      predefined:
      - New
      - Active
      - Closed
      required: true
    - description: The incident description.
      name: description
    - description: Incident labels. Note that all labels will be set as labelType='User'.
      isArray: true
      name: labels
    description: Create a sentinel incident.
    name: azure-sentinel-create-incident
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident's title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeObjectID
      description: The object ID of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.AssigneeUPN
      description: The user principal name of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
  dockerimage: demisto/crypto:1.0.0.4834757
  isfetch: true
  runonce: false
  script: >
    register_module_line('Azure Sentinel', 'start', __line__())

    CONSTANT_PACK_VERSION = '1.5.72'

    demisto.debug('pack id = AzureSentinel, pack version = 1.5.72')





    # IMPORTS


    import json

    import urllib3

    import requests

    import dateparser

    import uuid

    from enum import Enum


    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402

    # This code was inserted in place of an API module.

    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)

    import base64

    import re


    # pylint: disable=E9010, E9011

    import traceback



    import requests


    from cryptography.hazmat.primitives.ciphers.aead import AESGCM





    class Scopes:
        graph = "https://graph.microsoft.com/.default"
        security_center = "https://api.securitycenter.windows.com/.default"
        security_center_apt_service = "https://securitycenter.onmicrosoft.com/windowsatpservice/.default"
        management_azure = "https://management.azure.com/.default"  # resource_manager


    class Resources:
        graph = "https://graph.microsoft.com/"
        security_center = "https://api.securitycenter.microsoft.com/"
        security = "https://api.security.microsoft.com/"
        management_azure = "https://management.azure.com/"  # resource_manager
        manage_office = "https://manage.office.com/"


    # authorization types

    OPROXY_AUTH_TYPE = "oproxy"

    SELF_DEPLOYED_AUTH_TYPE = "self_deployed"


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = "client_credentials"

    AUTHORIZATION_CODE = "authorization_code"

    REFRESH_TOKEN = "refresh_token"  # guardrails-disable-line

    DEVICE_CODE = "urn:ietf:params:oauth:grant-type:device_code"

    REGEX_SEARCH_URL = r"(?P<url>https?://[^\s]+)"

    REGEX_SEARCH_ERROR_DESC = r"^[^:]+:\s(?P<desc>.*?)(?:\s*Trace ID:| Correlation ID:| Timestamp:|$)"

    SESSION_STATE = "session_state"


    # Deprecated, prefer using AZURE_CLOUDS

    TOKEN_RETRIEVAL_ENDPOINTS = {
        "com": "https://login.microsoftonline.com",
        "gcc": "https://login.microsoftonline.com",
        "gcc-high": "https://login.microsoftonline.us",
        "dod": "https://login.microsoftonline.us",
        "de": "https://login.microsoftonline.de",
        "cn": "https://login.chinacloudapi.cn",
    }


    # Deprecated, prefer using AZURE_CLOUDS

    GRAPH_ENDPOINTS = {
        "com": "https://graph.microsoft.com",
        "gcc": "https://graph.microsoft.us",
        "gcc-high": "https://graph.microsoft.us",
        "dod": "https://dod-graph.microsoft.us",
        "de": "https://graph.microsoft.de",
        "cn": "https://microsoftgraph.chinacloudapi.cn",
    }


    # Deprecated, prefer using AZURE_CLOUDS

    GRAPH_BASE_ENDPOINTS = {
        "https://graph.microsoft.com": "com",
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        "https://graph.microsoft.us": "gcc-high",
        "https://dod-graph.microsoft.us": "dod",
        "https://graph.microsoft.de": "de",
        "https://microsoftgraph.chinacloudapi.cn": "cn",
    }


    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }


    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"

    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"



    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris

    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api

    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gov.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }


    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        "com": "https://login.microsoftonline.com",
        "geo-us": "https://login.microsoftonline.com",
        "geo-eu": "https://login.microsoftonline.com",
        "geo-uk": "https://login.microsoftonline.com",
        "gcc": "https://login.microsoftonline.com",
        "gcc-high": "https://login.microsoftonline.us",
        "dod": "https://login.microsoftonline.us",
    }


    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints

    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        "com": "https://graph.microsoft.com",
        "geo-us": "https://graph.microsoft.com",
        "geo-eu": "https://graph.microsoft.com",
        "geo-uk": "https://graph.microsoft.com",
        "gcc": "https://graph.microsoft.com",
        "gcc-high": "https://graph.microsoft.us",
        "dod": "https://dod-graph.microsoft.us",
    }


    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        "com": "https://securitycenter.onmicrosoft.com",
        "geo-us": "https://securitycenter.onmicrosoft.com",
        "geo-eu": "https://securitycenter.onmicrosoft.com",
        "geo-uk": "https://securitycenter.onmicrosoft.com",
        "gcc": "https://securitycenter.onmicrosoft.com",
        "gcc-high": "https://securitycenter.onmicrosoft.us",
        "dod": "https://securitycenter.onmicrosoft.us",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }



    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        "com": "https://login.microsoftonline.com",
        "gcc": "https://login.microsoftonline.com",
        "gcc-high": "https://login.microsoftonline.us",
    }


    # Azure Managed Identities

    MANAGED_IDENTITIES_TOKEN_URL = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01"

    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = "SYSTEM_ASSIGNED"

    TOKEN_EXPIRED_ERROR_CODES = {
        50173,
        700082,
        70008,
        54005,
        7000222,
    }  # See: https://login.microsoftonline.com/error?code=


    # Moderate Retry Mechanism

    MAX_DELAY_REQUEST_COUNTER = 6



    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
        def __init__(
            self,  # pylint: disable=unused-argument
            management=None,
            resource_manager=None,
            sql_management=None,
            batch_resource_id=None,
            gallery=None,
            active_directory=None,
            active_directory_resource_id=None,
            active_directory_graph_resource_id=None,
            microsoft_graph_resource_id=None,
            active_directory_data_lake_resource_id=None,
            vm_image_alias_doc=None,
            media_resource_id=None,
            ossrdbms_resource_id=None,
            log_analytics_resource_id=None,
            app_insights_resource_id=None,
            app_insights_telemetry_channel_resource_id=None,
            synapse_analytics_resource_id=None,
            attestation_resource_id=None,
            portal=None,
            keyvault=None,
            exchange_online=None,
        ):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault
            self.exchange_online = exchange_online

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
        def __init__(
            self,  # pylint: disable=unused-argument
            storage_endpoint=None,
            storage_sync_endpoint=None,
            keyvault_dns=None,
            mhsm_dns=None,
            sql_server_hostname=None,
            azure_datalake_store_file_system_endpoint=None,
            azure_datalake_analytics_catalog_and_job_endpoint=None,
            acr_login_server_endpoint=None,
            mysql_server_endpoint=None,
            postgresql_server_endpoint=None,
            mariadb_server_endpoint=None,
            synapse_analytics_endpoint=None,
            attestation_endpoint=None,
        ):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """Represents an Azure Cloud instance"""

        def __init__(self, origin, name, abbreviation, endpoints=None, suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        "Embedded",
        "AzureCloud",
        "com",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.windows.net/",
            resource_manager="https://management.azure.com/",
            sql_management="https://management.core.windows.net:8443/",
            batch_resource_id="https://batch.core.windows.net/",
            gallery="https://gallery.azure.com/",
            active_directory="https://login.microsoftonline.com",
            active_directory_resource_id="https://management.core.windows.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://graph.microsoft.com/",
            active_directory_data_lake_resource_id="https://datalake.azure.net/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.azure.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.windows.net",
            app_insights_resource_id="https://api.applicationinsights.io",
            log_analytics_resource_id="https://api.loganalytics.io",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.azure.com/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.net",
            attestation_resource_id="https://attest.azure.net",
            portal="https://portal.azure.com",
            keyvault="https://vault.azure.net",
            exchange_online="https://outlook.office365.com",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.windows.net",
            storage_sync_endpoint="afs.azure.net",
            keyvault_dns=".vault.azure.net",
            mhsm_dns=".managedhsm.azure.net",
            sql_server_hostname=".database.windows.net",
            mysql_server_endpoint=".mysql.database.azure.com",
            postgresql_server_endpoint=".postgres.database.azure.com",
            mariadb_server_endpoint=".mariadb.database.azure.com",
            azure_datalake_store_file_system_endpoint="azuredatalakestore.net",
            azure_datalake_analytics_catalog_and_job_endpoint="azuredatalakeanalytics.net",
            acr_login_server_endpoint=".azurecr.io",
            synapse_analytics_endpoint=".dev.azuresynapse.net",
            attestation_endpoint=".attest.azure.net",
        ),
    )


    AZURE_US_GCC_CLOUD = AzureCloud(
        "Embedded",
        "AzureUSGovernment",
        "gcc",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.usgovcloudapi.net/",
            resource_manager="https://management.usgovcloudapi.net/",
            sql_management="https://management.core.usgovcloudapi.net:8443/",
            batch_resource_id="https://batch.core.usgovcloudapi.net/",
            gallery="https://gallery.usgovcloudapi.net/",
            active_directory="https://login.microsoftonline.com",
            active_directory_resource_id="https://management.core.usgovcloudapi.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://graph.microsoft.us/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.usgovcloudapi.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.usgovcloudapi.net",
            app_insights_resource_id="https://api.applicationinsights.us",
            log_analytics_resource_id="https://api.loganalytics.us",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.us/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.usgovcloudapi.net",
            portal="https://portal.azure.us",
            keyvault="https://vault.usgovcloudapi.net",
            exchange_online="https://outlook.office365.com",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.usgovcloudapi.net",
            storage_sync_endpoint="afs.azure.us",
            keyvault_dns=".vault.usgovcloudapi.net",
            mhsm_dns=".managedhsm.usgovcloudapi.net",
            sql_server_hostname=".database.usgovcloudapi.net",
            mysql_server_endpoint=".mysql.database.usgovcloudapi.net",
            postgresql_server_endpoint=".postgres.database.usgovcloudapi.net",
            mariadb_server_endpoint=".mariadb.database.usgovcloudapi.net",
            acr_login_server_endpoint=".azurecr.us",
            synapse_analytics_endpoint=".dev.azuresynapse.usgovcloudapi.net",
        ),
    )


    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        "Embedded",
        "AzureUSGovernment",
        "gcc-high",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.usgovcloudapi.net/",
            resource_manager="https://management.usgovcloudapi.net/",
            sql_management="https://management.core.usgovcloudapi.net:8443/",
            batch_resource_id="https://batch.core.usgovcloudapi.net/",
            gallery="https://gallery.usgovcloudapi.net/",
            active_directory="https://login.microsoftonline.us",
            active_directory_resource_id="https://management.core.usgovcloudapi.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://graph.microsoft.us/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.usgovcloudapi.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.usgovcloudapi.net",
            app_insights_resource_id="https://api.applicationinsights.us",
            log_analytics_resource_id="https://api.loganalytics.us",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.us/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.usgovcloudapi.net",
            portal="https://portal.azure.us",
            keyvault="https://vault.usgovcloudapi.net",
            exchange_online="https://outlook.office365.us",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.usgovcloudapi.net",
            storage_sync_endpoint="afs.azure.us",
            keyvault_dns=".vault.usgovcloudapi.net",
            mhsm_dns=".managedhsm.usgovcloudapi.net",
            sql_server_hostname=".database.usgovcloudapi.net",
            mysql_server_endpoint=".mysql.database.usgovcloudapi.net",
            postgresql_server_endpoint=".postgres.database.usgovcloudapi.net",
            mariadb_server_endpoint=".mariadb.database.usgovcloudapi.net",
            acr_login_server_endpoint=".azurecr.us",
            synapse_analytics_endpoint=".dev.azuresynapse.usgovcloudapi.net",
        ),
    )


    AZURE_DOD_CLOUD = AzureCloud(
        "Embedded",
        "AzureUSGovernment",
        "dod",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.usgovcloudapi.net/",
            resource_manager="https://management.usgovcloudapi.net/",
            sql_management="https://management.core.usgovcloudapi.net:8443/",
            batch_resource_id="https://batch.core.usgovcloudapi.net/",
            gallery="https://gallery.usgovcloudapi.net/",
            active_directory="https://login.microsoftonline.us",
            active_directory_resource_id="https://management.core.usgovcloudapi.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://dod-graph.microsoft.us/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.usgovcloudapi.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.usgovcloudapi.net",
            app_insights_resource_id="https://api.applicationinsights.us",
            log_analytics_resource_id="https://api.loganalytics.us",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.us/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.usgovcloudapi.net",
            portal="https://portal.azure.us",
            keyvault="https://vault.usgovcloudapi.net",
            exchange_online="https://outlook-dod.office365.us",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.usgovcloudapi.net",
            storage_sync_endpoint="afs.azure.us",
            keyvault_dns=".vault.usgovcloudapi.net",
            mhsm_dns=".managedhsm.usgovcloudapi.net",
            sql_server_hostname=".database.usgovcloudapi.net",
            mysql_server_endpoint=".mysql.database.usgovcloudapi.net",
            postgresql_server_endpoint=".postgres.database.usgovcloudapi.net",
            mariadb_server_endpoint=".mariadb.database.usgovcloudapi.net",
            acr_login_server_endpoint=".azurecr.us",
            synapse_analytics_endpoint=".dev.azuresynapse.usgovcloudapi.net",
        ),
    )



    AZURE_GERMAN_CLOUD = AzureCloud(
        "Embedded",
        "AzureGermanCloud",
        "de",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.cloudapi.de/",
            resource_manager="https://management.microsoftazure.de",
            sql_management="https://management.core.cloudapi.de:8443/",
            batch_resource_id="https://batch.cloudapi.de/",
            gallery="https://gallery.cloudapi.de/",
            active_directory="https://login.microsoftonline.de",
            active_directory_resource_id="https://management.core.cloudapi.de/",
            active_directory_graph_resource_id="https://graph.cloudapi.de/",
            microsoft_graph_resource_id="https://graph.microsoft.de",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.cloudapi.de",
            ossrdbms_resource_id="https://ossrdbms-aad.database.cloudapi.de",
            portal="https://portal.microsoftazure.de",
            keyvault="https://vault.microsoftazure.de",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.cloudapi.de",
            keyvault_dns=".vault.microsoftazure.de",
            mhsm_dns=".managedhsm.microsoftazure.de",
            sql_server_hostname=".database.cloudapi.de",
            mysql_server_endpoint=".mysql.database.cloudapi.de",
            postgresql_server_endpoint=".postgres.database.cloudapi.de",
            mariadb_server_endpoint=".mariadb.database.cloudapi.de",
        ),
    )


    AZURE_CHINA_CLOUD = AzureCloud(
        "Embedded",
        "AzureChinaCloud",
        "cn",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.chinacloudapi.cn/",
            resource_manager="https://management.chinacloudapi.cn",
            sql_management="https://management.core.chinacloudapi.cn:8443/",
            batch_resource_id="https://batch.chinacloudapi.cn/",
            gallery="https://gallery.chinacloudapi.cn/",
            active_directory="https://login.chinacloudapi.cn",
            active_directory_resource_id="https://management.core.chinacloudapi.cn/",
            active_directory_graph_resource_id="https://graph.chinacloudapi.cn/",
            microsoft_graph_resource_id="https://microsoftgraph.chinacloudapi.cn",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.chinacloudapi.cn",
            ossrdbms_resource_id="https://ossrdbms-aad.database.chinacloudapi.cn",
            app_insights_resource_id="https://api.applicationinsights.azure.cn",
            log_analytics_resource_id="https://api.loganalytics.azure.cn",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.azure.cn/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.azure.cn",
            portal="https://portal.azure.cn",
            keyvault="https://vault.azure.cn",
            exchange_online="https://partner.outlook.cn",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.chinacloudapi.cn",
            keyvault_dns=".vault.azure.cn",
            mhsm_dns=".managedhsm.azure.cn",
            sql_server_hostname=".database.chinacloudapi.cn",
            mysql_server_endpoint=".mysql.database.chinacloudapi.cn",
            postgresql_server_endpoint=".postgres.database.chinacloudapi.cn",
            mariadb_server_endpoint=".mariadb.database.chinacloudapi.cn",
            acr_login_server_endpoint=".azurecr.cn",
            synapse_analytics_endpoint=".dev.azuresynapse.azure.cn",
        ),
    )



    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }


    AZURE_CLOUD_NAME_CUSTOM = "Custom"


    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }



    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(
        origin: str,
        name: str | None = None,
        abbreviation: str | None = None,
        defaults: AzureCloud | None = None,
        endpoints: dict | None = None,
        suffixes: dict | None = None,
    ):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get("management", defaults.endpoints.management),
                resource_manager=endpoints.get("resource_manager", defaults.endpoints.resource_manager),
                sql_management=endpoints.get("sql_management", defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get("batch_resource_id", defaults.endpoints.batch_resource_id),
                gallery=endpoints.get("gallery", defaults.endpoints.gallery),
                active_directory=endpoints.get("active_directory", defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get(
                    "active_directory_resource_id", defaults.endpoints.active_directory_resource_id
                ),
                active_directory_graph_resource_id=endpoints.get(
                    "active_directory_graph_resource_id", defaults.endpoints.active_directory_graph_resource_id
                ),
                microsoft_graph_resource_id=endpoints.get(
                    "microsoft_graph_resource_id", defaults.endpoints.microsoft_graph_resource_id
                ),
                active_directory_data_lake_resource_id=endpoints.get(
                    "active_directory_data_lake_resource_id", defaults.endpoints.active_directory_data_lake_resource_id
                ),
                vm_image_alias_doc=endpoints.get("vm_image_alias_doc", defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get("media_resource_id", defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get("ossrdbms_resource_id", defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get("app_insights_resource_id", defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get("log_analytics_resource_id", defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    "app_insights_telemetry_channel_resource_id", defaults.endpoints.app_insights_telemetry_channel_resource_id
                ),
                synapse_analytics_resource_id=endpoints.get(
                    "synapse_analytics_resource_id", defaults.endpoints.synapse_analytics_resource_id
                ),
                attestation_resource_id=endpoints.get("attestation_resource_id", defaults.endpoints.attestation_resource_id),
                portal=endpoints.get("portal", defaults.endpoints.portal),
                keyvault=endpoints.get("keyvault", defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get("storage_endpoint", defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get("storage_sync_endpoint", defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get("keyvault_dns", defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get("mhsm_dns", defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get("sql_server_hostname", defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get("mysql_server_endpoint", defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get("postgresql_server_endpoint", defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get("mariadb_server_endpoint", defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    "azure_datalake_store_file_system_endpoint", defaults.suffixes.azure_datalake_store_file_system_endpoint
                ),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    "azure_datalake_analytics_catalog_and_job_endpoint",
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint,
                ),
                acr_login_server_endpoint=suffixes.get("acr_login_server_endpoint", defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get("synapse_analytics_endpoint", defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get("attestation_endpoint", defaults.suffixes.attestation_endpoint),
            ),
        )


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, "com")
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get("azure_cloud")
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if "server_url" in params:
                return create_custom_azure_cloud(
                    integration_name,
                    defaults=AZURE_WORLDWIDE_CLOUD,
                    endpoints={"resource_manager": params.get("server_url") or "https://management.azure.com"},
                )
            if "azure_ad_endpoint" in params:
                return create_custom_azure_cloud(
                    integration_name,
                    defaults=AZURE_WORLDWIDE_CLOUD,
                    endpoints={"active_directory": params.get("azure_ad_endpoint") or "https://login.microsoftonline.com"},
                )
            # in multiple Graph integrations, the url is called 'url' or 'host' instead of 'server_url' and the default url is
            # different.
            if "url" in params or "host" in params:
                return create_custom_azure_cloud(
                    integration_name,
                    defaults=AZURE_WORLDWIDE_CLOUD,
                    endpoints={
                        "microsoft_graph_resource_id": params.get("url") or params.get("host") or "https://graph.microsoft.com"
                    },
                )

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(
            self,
            tenant_id: str = "",
            auth_id: str = "",
            enc_key: str | None = "",
            token_retrieval_url: str = "{endpoint}/{tenant_id}/oauth2/v2.0/token",
            app_name: str = "",
            refresh_token: str = "",
            auth_code: str = "",
            scope: str = "{graph_endpoint}/.default",
            grant_type: str = CLIENT_CREDENTIALS,
            redirect_uri: str = "https://localhost/myapp",
            resource: str | None = "",
            multi_resource: bool = False,
            resources: list[str] = None,
            verify: bool = True,
            self_deployed: bool = False,
            timeout: int | None = None,
            azure_ad_endpoint: str = "{endpoint}",
            azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
            endpoint: str = "__NA__",  # Deprecated
            certificate_thumbprint: str | None = None,
            retry_on_rate_limit: bool = False,
            private_key: str | None = None,
            managed_identities_client_id: str | None = None,
            managed_identities_resource_uri: str | None = None,
            base_url: str | None = None,
            command_prefix: str | None = "command_prefix",
            *args,
            **kwargs,
        ):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            demisto.debug(f"Initializing MicrosoftClient with: {endpoint=} | {azure_cloud.abbreviation}")
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split("@")
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = "https://oproxy.demisto.ninja/obtain-token"  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(
                    tenant_id=tenant_id, endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/")
                )
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401

                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key, "RS256", certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException("Unable to use certificate authentication because `msal` is missing.")
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get("context", {})
            executed_commands = ctx.get("ExecutedCommands", [{"moduleBrand": "Scripts"}])

            if executed_commands:
                return executed_commands[0].get("moduleBrand", "") != "Scripts"

            return True

        def http_request(
            self,
            *args,
            resp_type="json",
            headers=None,
            return_empty_response=False,
            scope: str | None = None,
            resource: str = "",
            overwrite_rate_limit_retry=False,
            **kwargs,
        ):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if "ok_codes" not in kwargs and not self._ok_codes:
                kwargs["ok_codes"] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs["timeout"] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get("error_handler"):
                kwargs["error_handler"] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, status_list_to_retry=[503], retries=3, **kwargs
            )

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = response.status_code == 204
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = "Not Found - 404 Response"
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge("6.2.0"):
                command_args = demisto.args()
                ran_once_flag = command_args.get("ran_once_flag")
                demisto.info(f"429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}")
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = "Rate limit reached on retry - 429 Response"
                    demisto.info(f"Error in retry for MS rate limit - {error_message}")
                    raise DemistoException(error_message)

                else:
                    demisto.info(f"Scheduling command {demisto.command()}")
                    command_args["ran_once_flag"] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == "json":
                    return response.json()
                if resp_type == "text":
                    return response.text
                if resp_type == "content":
                    return response.content
                if resp_type == "xml":
                    try:
                        import defusedxml.ElementTree as defused_ET

                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug("defused_ET is not supported, using ET instead.")
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f"Failed to parse json object from response: {response.content}", exception)

        def get_access_token(self, resource: str = "", scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get("current_refresh_token", "")
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f"{scope}_access_token" if scope else "access_token"
            valid_until_keyword = f"{scope}_valid_until" if scope else "valid_until"

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update(
                {access_token_keyword: access_token, valid_until_keyword: valid_until, "current_refresh_token": refresh_token}
            )

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug("Set integration context successfully.")

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = "Error in Microsoft authorization."
            try:
                demisto.info(
                    f"Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} "
                    f"{oproxy_response.text}"
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r"{.*}", oproxy_response.text)
                microsoft_response = (
                    self.extract_microsoft_error(json.loads(search_microsoft_response.group())) if search_microsoft_response else ""
                )
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f" body: {err_str}"
                err_response = oproxy_response.json()
                server_msg = err_response.get("message", "") or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f" Server message: {server_msg}"
            except Exception as ex:
                demisto.error(f"Failed parsing error response - Exception: {ex}")
            raise Exception(msg)

        def _oproxy_authorize_build_request(
            self, headers: dict[str, str], content: str, scope: str | None = None, resource: str = ""
        ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    "app_name": self.app_name,
                    "registration_id": self.auth_id,
                    "encrypted_token": self.get_encrypted(content, self.enc_key),
                    "scope": scope,
                    "resource": resource,
                },
                verify=self.verify,
            )

        def _oproxy_authorize(self, resource: str = "", scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get("delay_request_counter", 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(
                    next_request_time=next_request_time, delay_request_counter=delay_request_counter, context=context
                )
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get("Function-Execution-Id")
                demisto.info(f"Google Cloud Function Execution ID: {gcloud_function_exec_id}")
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    "There was a problem in retrieving an updated access token.\n"
                    "The response from the Oproxy server did not contain the expected content."
                )

            return (
                parsed_response.get("access_token", ""),
                parsed_response.get("expires_in", 3595),
                parsed_response.get("refresh_token", ""),
            )

        def _get_self_deployed_token(
            self, refresh_token: str = "", scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:
                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return "", expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token, resource)
                    self.resource_to_access_token[resource] = access_token

                return "", expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return "", expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(
            self, scope: str | None = None, resource: str | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {"client_id": self.client_id, "client_secret": self.client_secret, "grant_type": CLIENT_CREDENTIALS}

            if self.jwt:
                data.pop("client_secret", None)
                data["client_assertion_type"] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data["client_assertion"] = self.jwt

            # Set scope.
            if self.scope or scope:
                data["scope"] = scope or self.scope

            if self.resource or resource:
                data["resource"] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")

            access_token = response_json.get("access_token", "")
            expires_in = int(response_json.get("expires_in", 3595))

            return access_token, expires_in, ""

        def _get_self_deployed_token_auth_code(
            self, refresh_token: str = "", resource: str = "", scope: str | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri,
            )

            if self.jwt:
                data.pop("client_secret", None)
                data["client_assertion_type"] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data["client_assertion"] = self.jwt

            if scope:
                data["scope"] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data["grant_type"] = REFRESH_TOKEN
                data["refresh_token"] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError(
                        "Malformed auth_code parameter: Please copy the auth code from the redirected uri "
                        'without any additional info and without the "session_state" query parameter.'
                    )
                data["grant_type"] = AUTHORIZATION_CODE
                data["code"] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")

            access_token = response_json.get("access_token", "")
            expires_in = int(response_json.get("expires_in", 3595))
            refresh_token = response_json.get("refresh_token", "")

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED
                resource = resource or self.managed_identities_resource_uri

                demisto.debug("try to get Managed Identities token")

                params = {"resource": resource}
                if not use_system_assigned:
                    params["client_id"] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={"Metadata": "True"}).json()
                access_token = response_json.get("access_token")
                expires_in = int(response_json.get("expires_in", 3595))
                if access_token:
                    return access_token, expires_in, ""

                err = response_json.get("error_description")
            except Exception as e:
                err = f"{e!s}"

            return_error(f"Error in Microsoft authorization with Azure Managed Identities: {err}")
            return None

        def _get_token_device_code(
            self, refresh_token: str = "", scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {"client_id": self.client_id, "scope": scope}

            if refresh_token:
                data["grant_type"] = REFRESH_TOKEN
                data["refresh_token"] = refresh_token
            else:
                data["grant_type"] = DEVICE_CODE
                if integration_context:
                    data["code"] = integration_context.get("device_code")

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")

            access_token = response_json.get("access_token", "")
            expires_in = int(response_json.get("expires_in", 3595))
            refresh_token = response_json.get("refresh_token", "")

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix) :]
            return ""

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(
                readable_output="Rate limit reached, rerunning the command in 1 min",
                scheduled_command=ScheduledCommand(
                    command=demisto.command(), next_run_in_seconds=60, args=args_for_next_run, timeout_in_seconds=900
                ),
            )

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ["test-module", "fetch-incidents"]:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get("error", {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get("error_description", "")

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += (
                        f"\nGot the following error codes from Microsoft: {error_codes}."
                        f"\nYou can run the ***{self.command_prefix}-auth-reset*** command to reset the authentication process."
                    )
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(
                        f"Error in Microsoft authorization: {err!s} Please check authentication related parameters.",
                        error=traceback.format_exc(),
                    )

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f"{now}:{content}", key).decode("utf-8")
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f"Failed getting integration info: {e!s}")

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f"{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode",
                    data={"client_id": self.client_id, "scope": self.scope},
                    verify=self.verify,
                )
                if not response.ok:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")
            set_integration_context({"device_code": response_json.get("device_code")})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get("message", "")
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search["url"] if re_search else None
            user_code = response.get("user_code")

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
        Calculates the next request time based on the delay_request_counter.
        This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2**delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
        Sets the next_request_time in the integration context.
        This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context["next_request_time"] = next_request_time
        context["delay_request_counter"] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context["delay_request_counter"] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
        Checks if the request should be delayed based on context variables.
        This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get("auth_type") or params.get("authentication_type")
        if params and (argToBoolean(params.get("use_managed_identities") or auth_type == "Azure Managed Identities")):
            client_id = params.get("managed_identities_client_id", {}).get("password")
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient, login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException(
                f"Please make sure you entered the Authorization configuration correctly. Missing:{','.join(missing)}"
            )

        login_url = urljoin(
            login_url,
            f'{client.tenant_id}/oauth2/v2.0/authorize?'
            f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
            f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}',
        )

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.

    You will be automatically redirected to a link with the following structure:

    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```

    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)

    and paste it in your instance configuration under the **Authorization code** parameter.
     """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f"No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.")



    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(
            readable_output="Authorization was reset successfully. Please regenerate the credentials, "
            "and then click **Test** to validate the credentials and connection."
        )

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###

    from typing import Literal


    # Disable insecure warnings

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


    """ CONSTANTS """


    APP_NAME = "ms-azure-sentinel"


    DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"

    DATE_FORMAT_WITH_MILLISECONDS = "%Y-%m-%dT%H:%M:%S.%fZ"


    API_VERSION = "2024-03-01"


    NEXT_LINK_DESCRIPTION = "NextLink for listing commands"


    XSOAR_USER_AGENT = "SentinelPartner-PaloAltoNetworks-CortexXsoar/1.0.0"


    AUTHORIZATION_ERROR_MSG = (
        "There was a problem in retrieving an updated access token.\n"
        "The response from the server did not contain the expected content."
    )


    INCIDENT_HEADERS = [
        "ID",
        "IncidentNumber",
        "Title",
        "Description",
        "Severity",
        "Status",
        "IncidentUrl",
        "ProviderIncidentUrl",
        "AssigneeName",
        "AssigneeEmail",
        "AssigneeObjectID",
        "AssigneeUPN",
        "Label",
        "FirstActivityTimeUTC",
        "LastActivityTimeUTC",
        "LastModifiedTimeUTC",
        "CreatedTimeUTC",
        "AlertsCount",
        "BookmarksCount",
        "CommentsCount",
        "AlertProductNames",
        "Tactics",
        "FirstActivityTimeGenerated",
        "LastActivityTimeGenerated",
    ]


    COMMENT_HEADERS = [
        "ID",
        "IncidentID",
        "Message",
        "AuthorName",
        "AuthorEmail",
        "CreatedTimeUTC",
    ]


    ENTITIES_RETENTION_PERIOD_MESSAGE = (
        "\nNotice that in the current Azure Sentinel API version, the retention period for GetEntityByID is 30 days."
    )


    DEFAULT_LIMIT = 50

    FETCH_MAX_LIMIT = 1000

    FETCH_DEFAULT_LIMIT = 20

    COMMAND_MAX_LIMIT = 200

    MAX_INCIDENT_COMMENT_LIMIT = 50


    DEFAULT_SOURCE = "Microsoft Sentinel"


    THREAT_INDICATORS_HEADERS = [
        "Name",
        "DisplayName",
        "Values",
        "Types",
        "Source",
        "Confidence",
        "Tags",
    ]


    # =========== Mirroring Mechanism Globals ===========


    MIRROR_DIRECTION_DICT = {
        "None": None,
        "Incoming": "In",
        "Outgoing": "Out",
        "Incoming And Outgoing": "Both",
    }


    MIRROR_STATUS_DICT = {
        "Undetermined": "Other",
        "TruePositive": "Resolved",
        "BenignPositive": "Resolved",
        "FalsePositive": "False Positive",
    }


    MIRROR_DIRECTION = MIRROR_DIRECTION_DICT.get(demisto.params().get("mirror_direction"))

    INTEGRATION_INSTANCE = demisto.integrationInstance()


    INCOMING_MIRRORED_FIELDS = [
        "ID",
        "Etag",
        "Title",
        "Description",
        "Severity",
        "Status",
        "owner",
        "tags",
        "FirstActivityTimeUTC",
        "LastActivityTimeUTC",
        "LastModifiedTimeUTC",
        "CreatedTimeUTC",
        "IncidentNumber",
        "AlertsCount",
        "AlertProductNames",
        "Tactics",
        "relatedAnalyticRuleIds",
        "IncidentUrl",
        "ProviderIncidentUrl",
        "classification",
        "classificationReason",
        "classificationComment",
        "alerts",
        "entities",
        "comments",
        "relations",
    ]


    OUTGOING_MIRRORED_FIELDS = {
        "etag",
        "title",
        "description",
        "severity",
        "status",
        "tags",
        "firstActivityTimeUtc",
        "lastActivityTimeUtc",
        "classification",
        "classificationComment",
        "classificationReason",
    }

    OUTGOING_MIRRORED_FIELDS = {filed: pascalToSpace(filed) for filed in OUTGOING_MIRRORED_FIELDS}


    LEVEL_TO_SEVERITY = {
        0: "Informational",
        0.5: "Informational",
        1: "Low",
        2: "Medium",
        3: "High",
        4: "High",
    }

    CLASSIFICATION_REASON = {
        "TruePositive": "SuspiciousActivity",
        "BenignPositive": "SuspiciousButExpected",
    }



    class Action(Enum):
        CLOSE = 1
        REOPEN = 2
        UNCHANGED = 3


    class AzureSentinelClient:
        def __init__(
            self,
            tenant_id: str,
            client_id: str,
            client_secret: str,
            subscription_id: str,
            resource_group_name: str,
            workspace_name: str,
            certificate_thumbprint: Optional[str],
            private_key: Optional[str],
            verify: bool = True,
            proxy: bool = False,
            managed_identities_client_id: Optional[str] = None,
            azure_cloud: Optional[AzureCloud] = None,
        ):
            """
            AzureSentinelClient class that make use client credentials for authorization with Azure.

            :type azure_cloud: ``AzureCloud | None``
            :param azure_cloud: The Azure Cloud settings.

            :type tenant_id: ``str``
            :param tenant_id: The tenant id.

            :type client_id: ``str``
            :param client_id: The client id.

            :type client_secret: ``str``
            :param client_secret: The client secret from Azure registered application.

            :type subscription_id: ``str``
            :param subscription_id: The subscription id.

            :type resource_group_name: ``str``
            :param resource_group_name: The resource group name.

            :type workspace_name: ``str``
            :param workspace_name: The workspace name.

            :type certificate_thumbprint: ``str``
            :param certificate_thumbprint: The certificate thumbprint as appears in the AWS GUI.

            :type private_key: ``str``
            :param private_key: The certificate private key.

            :type verify: ``bool``
            :param verify: Whether the request should verify the SSL certificate.

            :type proxy: ``bool``
            :param proxy: Whether to run the integration using the system proxy.

            :type managed_identities_client_id: ``str``
            :param managed_identities_client_id: The Azure Managed Identities client id.
            """

            self.azure_cloud = azure_cloud or AZURE_WORLDWIDE_CLOUD
            base_url = urljoin(
                self.azure_cloud.endpoints.resource_manager,
                f"subscriptions/{subscription_id}/"
                f"resourceGroups/{resource_group_name}/providers/Microsoft.OperationalInsights/workspaces/"
                f"{workspace_name}/providers/Microsoft.SecurityInsights",
            )
            self._client = MicrosoftClient(
                tenant_id=tenant_id,
                auth_id=client_id,
                enc_key=client_secret,
                self_deployed=True,
                grant_type=CLIENT_CREDENTIALS,
                scope=urljoin(self.azure_cloud.endpoints.resource_manager, ".default"),
                ok_codes=(200, 201, 202, 204),
                verify=verify,
                proxy=proxy,
                azure_cloud=self.azure_cloud,
                certificate_thumbprint=certificate_thumbprint,
                private_key=private_key,
                managed_identities_client_id=managed_identities_client_id,
                managed_identities_resource_uri=self.azure_cloud.endpoints.resource_manager,
                base_url=base_url,
                command_prefix="azure-sentinel",
            )

        def http_request(self, method, url_suffix=None, full_url=None, params=None, data=None):
            """
            Wrapped the client's `http_request` for adding some required params and headers
            """
            if not full_url:
                params = params or {}
                params["api-version"] = API_VERSION

            res = self._client.http_request(
                method=method,  # disable-secrets-detection
                url_suffix=url_suffix,
                full_url=full_url,
                headers={"User-Agent": XSOAR_USER_AGENT},
                json_data=data,
                params=params,
                error_handler=error_handler,
                resp_type="response",
            )

            if res.content:
                return res.json()

            return res


    """ INTEGRATION HELPER METHODS """



    def get_error_kind(code):
        """
        Get the kind of the error based on the http error code.
        """
        return {
            400: "BadRequest",
            401: "UnAuthorized",
            403: "Forbidden",
            404: "NotFound",
        }.get(code)


    def error_handler(response: requests.Response):
        """
        raise informative exception in case of error response
        """
        if response.status_code in (400, 401, 403, 404):
            try:
                error_json = response.json()
            except json.JSONDecodeError:
                error_json = {
                    "error": {
                        "code": get_error_kind(code=response.status_code),
                        "message": response.text,
                    }
                }
            error_kind = error_json.get("error", {}).get("code", "BadRequest")
            error_msg = error_json.get("error", {}).get("message", error_json)
            raise ValueError(f"[{error_kind} {response.status_code}] {error_msg}")


    def format_date(date):
        if not date:
            return None
        return dateparser.parse(date).strftime(DATE_FORMAT)  # type:ignore


    def incident_data_to_xsoar_format(inc_data, is_fetch_incidents=False):
        """
        Convert the incident data from the raw to XSOAR format.

        :param inc_data: (dict) The incident raw data.
        :param is_fetch_incidents: (bool) Is it part of a fetch incidents command.
        """
        properties = inc_data.get("properties", {})

        formatted_data = {
            "ID": inc_data.get("name"),
            "IncidentNumber": properties.get("incidentNumber"),
            "IncidentUrl": properties.get("incidentUrl"),
            "Title": properties.get("title"),
            "Description": properties.get("description"),
            "Severity": properties.get("severity"),
            "Status": properties.get("status"),
            "AssigneeName": properties.get("owner", {}).get("assignedTo"),
            "AssigneeEmail": properties.get("owner", {}).get("email"),
            "AssigneeObjectID": properties.get("owner", {}).get("objectId"),
            "AssigneeUPN": properties.get("owner", {}).get("userPrincipalName"),
            "Label": [{"Name": label.get("labelName"), "Type": label.get("labelType")} for label in properties.get("labels", [])],
            "FirstActivityTimeUTC": format_date(properties.get("firstActivityTimeUtc")),
            "LastActivityTimeUTC": format_date(properties.get("lastActivityTimeUtc")),
            "LastModifiedTimeUTC": format_date(properties.get("lastModifiedTimeUtc")),
            "CreatedTimeUTC": format_date(properties.get("createdTimeUtc")),
            "AlertsCount": properties.get("additionalData", {}).get("alertsCount"),
            "BookmarksCount": properties.get("additionalData", {}).get("bookmarksCount"),
            "CommentsCount": properties.get("additionalData", {}).get("commentsCount"),
            "AlertProductNames": properties.get("additionalData", {}).get("alertProductNames"),
            "ProviderIncidentUrl": properties.get("additionalData", {}).get("providerIncidentUrl"),
            "Tactics": properties.get("additionalData", {}).get("tactics"),
            "Techniques": properties.get("additionalData", {}).get("techniques"),
            "FirstActivityTimeGenerated": format_date(properties.get("firstActivityTimeGenerated")),
            "LastActivityTimeGenerated": format_date(properties.get("lastActivityTimeGenerated")),
            "Etag": inc_data.get("etag"),
            "Deleted": False,
        }
        if is_fetch_incidents:
            formatted_data |= {
                "tags": [label.get("labelName") for label in properties.get("labels", [])],
                "owner": properties.get("owner"),
                "relatedAnalyticRuleIds": [rule_id.split("/")[-1] for rule_id in properties.get("relatedAnalyticRuleIds", [])],
                "classification": properties.get("classification"),
                "classificationComment": properties.get("classificationComment"),
                "classificationReason": properties.get("classificationReason"),
            }
        return formatted_data


    def watchlist_data_to_xsoar_format(watchlist_data):
        """
        Convert the watchlist data from the raw to XSOAR format.

        :param watchlist_data: (dict) The alert raw data.
        """
        properties = watchlist_data.get("properties", {})

        formatted_data = {
            "Name": watchlist_data.get("name"),
            "ID": properties.get("watchlistId"),
            "Description": properties.get("description"),
            "Provider": properties.get("provider"),
            "Source": properties.get("source"),
            "Created": format_date(properties.get("created")),
            "Updated": format_date(properties.get("updated")),
            "CreatedBy": properties.get("createdBy", {}).get("name"),
            "UpdatedBy": properties.get("updatedBy", {}).get("name"),
            "Alias": properties.get("watchlistAlias"),
            "Label": properties.get("labels", []),
            "ItemsSearchKey": properties.get("itemsSearchKey"),
        }
        return formatted_data


    def alert_data_to_xsoar_format(alert_data):
        """
        Convert the alert data from the raw to XSOAR format.

        :param alert_data: (dict) The alert raw data.
        """
        properties = alert_data.get("properties", {})
        formatted_data = {
            "ID": properties.get("systemAlertId"),
            "Kind": alert_data.get("kind"),
            "Tactic": properties.get("tactics"),
            "Technique": properties.get("additionalData", {}).get("MitreTechniques"),
            "DisplayName": properties.get("alertDisplayName"),
            "Description": properties.get("description"),
            "ConfidenceLevel": properties.get("confidenceLevel"),
            "Severity": properties.get("severity"),
            "VendorName": properties.get("vendorName"),
            "ProductName": properties.get("productName"),
            "ProductComponentName": properties.get("productComponentName"),
        }
        return formatted_data


    def watchlist_item_data_to_xsoar_format(item_data):
        """
        Convert the watchlist item from the raw to XSOAR format.

        :param item_data: (dict) The item raw data.
        """
        properties = item_data.get("properties", {})
        formatted_data = {
            "Name": item_data.get("name"),
            "ID": properties.get("watchlistItemId"),
            "Created": format_date(properties.get("created")),
            "Updated": format_date(properties.get("updated")),
            "CreatedBy": demisto.get(properties, "createdBy.name"),
            "UpdatedBy": demisto.get(properties, "updatedBy.name"),
            "ItemsKeyValue": properties.get("itemsKeyValue"),
        }
        return formatted_data


    def get_update_incident_request_data(client: AzureSentinelClient, args: Dict[str, str]):
        """
        Prepare etag and other mandatory incident properties for update_incident command.

        :param client: The client.
        :param args: The args for the command.
        """
        fetched_incident_data = get_incident_by_id_command(client, args).raw_response

        title = args.get("title")
        description = args.get("description")
        severity = args.get("severity")
        status = args.get("status")
        classification = args.get("classification")
        classification_comment = args.get("classification_comment")
        classification_reason = args.get("classification_reason")
        assignee_email = args.get("assignee_email")
        assignee_objectid = args.get("assignee_objectid")
        user_principal_name = args.get("user_principal_name")
        labels = argToList(args.get("labels", ""))
        unassign = args.get("unassign")
        owner = demisto.get(fetched_incident_data, "properties.owner", {})

        if not title:
            title = demisto.get(fetched_incident_data, "properties.title")
        if not description:
            description = demisto.get(fetched_incident_data, "properties.description")
        if not severity:
            severity = demisto.get(fetched_incident_data, "properties.severity")
        if not status:
            status = demisto.get(fetched_incident_data, "properties.status")
        if unassign == "true":
            owner = {}
        elif assignee_objectid:
            owner = {"objectId": assignee_objectid}
        else:
            if user_principal_name:
                owner = {"userPrincipalName": user_principal_name}
            if assignee_email:
                owner["email"] = assignee_email

        existing_labels = demisto.get(fetched_incident_data, "properties.labels")
        if not labels:  # not provided as arg
            labels_formatted = existing_labels

        else:
            labels_formatted = [
                {"labelName": label, "labelType": "User"} for label in argToList(labels) if label
            ]  # labels can not be blank
        incident_data = {
            "etag": fetched_incident_data.get("etag"),
            "properties": {
                "title": title,
                "description": description,
                "severity": severity,
                "status": status,
                "classification": classification,
                "classificationComment": classification_comment,
                "classificationReason": classification_reason,
                "labels": labels_formatted,
                "owner": owner,
            },
        }
        remove_nulls_from_dictionary(incident_data["properties"])

        return incident_data


    def comment_data_to_xsoar_format(comment_data, inc_id):
        """
        Convert the comment data from the raw to XSOAR format.

        :param comment_data: (dict) The comment raw data.
        :param inc_id: The id of the incident hold this comment.
        """
        properties = comment_data.get("properties", {})

        formatted_data = {
            "ID": comment_data.get("name"),
            "IncidentID": inc_id,
            "Message": properties.get("message"),
            "AuthorName": properties.get("author", {}).get("assignedTo"),
            "AuthorEmail": properties.get("author", {}).get("email"),
            "CreatedTimeUTC": format_date(properties.get("createdTimeUtc")),
        }
        return formatted_data


    def incident_related_resource_data_to_xsoar_format(resource_data, incident_id):
        """
        Convert the incident relation from the raw to XSOAR format.

        :param resource_data: (dict) The related resource raw data.
        :param incident_id: The incident id.
        """
        properties = resource_data.get("properties", {})

        formatted_data = {
            "ID": properties.get("relatedResourceName"),
            "Kind": properties.get("relatedResourceKind"),
            "IncidentID": incident_id,
        }
        return formatted_data


    def entity_related_resource_data_to_xsoar_format(resource_data, entity_id):
        """
        Convert the entity relation from the raw to XSOAR format.

        :param resource_data: (dict) The related resource raw data.
        :param entity_id: The entity id.
        """
        properties = resource_data.get("properties", {})

        formatted_data = {
            "ID": properties.get("relatedResourceName"),
            "Kind": properties.get("relatedResourceKind"),
            "EntityID": entity_id,
        }
        return formatted_data


    def severity_to_level(severity):
        """
        Maps severity to a level represented by number.
        """
        if severity == "Informational":
            return 0.5
        elif severity == "Low":
            return 1
        elif severity == "Medium":
            return 2
        elif severity == "High":
            return 3
        return 0


    def severity_filter(min_severity):
        """
        Create Severity Filter when min_severity >= Low.
        """
        severity_levels = ["Low", "Medium", "High"]
        severity_filter = ""
        if min_severity in severity_levels:
            min_level = severity_to_level(min_severity)
            conditions = [f"properties/severity eq '{s}'" for s in severity_levels if severity_to_level(s) >= min_level]
            severity_filter = f"and ({ ' or '.join(conditions) })"
        return severity_filter


    def status_filter(statuses):
        """
        Create a Status Filter string when statuses is not empty.
        """
        status_filter = ""
        if statuses:
            conditions = [f"properties/status eq '{s}'" for s in statuses]
            status_filter = f"and ({ ' or '.join(conditions) })"

        return status_filter


    def generic_list_incident_items(
        client,
        incident_id,
        items_kind,
        key_in_raw_result,
        outputs_prefix,
        xsoar_transformer,
    ):
        """
        Get a list of incident's items

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param incident_id:  (str) the incident id.
        :param items_kind: (str) the name of the entity e.g. entities, alerts.
        :param key_in_raw_result: (str) the key hold the relevant result in the raw data.
        :param outputs_prefix: (str) the context output key that will hold the command result.
        :param xsoar_transformer: (function) a function to transform the raw data to xsoar format.
        """

        url_suffix = f"incidents/{incident_id}/{items_kind}"

        result = client.http_request("POST", url_suffix)
        raw_items = result.get(key_in_raw_result, [])
        items = [dict(IncidentId=incident_id, **xsoar_transformer(item)) for item in raw_items]

        readable_output = tableToMarkdown(
            f"Incident {incident_id} {items_kind.capitalize()} ({len(items)} results)",
            items,
            headers=["ID", "Kind", "IncidentId"],
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs=items,
            outputs_prefix=outputs_prefix,
            outputs_key_field=["ID", "IncidentId"],
            raw_response=result,
        )


    """ MIRRORING COMMANDS """



    def add_mirroring_fields(incident: Dict):
        """
        Updates the given incident to hold the needed mirroring fields.
        """
        incident["mirror_direction"] = MIRROR_DIRECTION
        incident["mirror_instance"] = INTEGRATION_INSTANCE


    def get_modified_remote_data_command(client: AzureSentinelClient, args: Dict[str, Any]) -> GetModifiedRemoteDataResponse:
        """
        Gets the modified remote incidents IDs.
        Args:
            client: The client object.
            args: The command arguments.

        Returns:
            GetModifiedRemoteDataResponse object, which contains a list of the modified incidents IDs.
        """
        remote_args = GetModifiedRemoteDataArgs(args)
        last_update = dateparser.parse(remote_args.last_update, settings={"TIMEZONE": "UTC"}).strftime(  # type: ignore[union-attr]
            DATE_FORMAT_WITH_MILLISECONDS
        )
        demisto.debug(f"Getting modified incidents from {last_update}")

        raw_incidents = []

        next_link = True
        while next_link:
            full_url = next_link if isinstance(next_link, str) else None
            params = None if full_url else {"$filter": f"properties/lastModifiedTimeUtc ge {last_update}"}

            response = client.http_request("GET", "incidents", full_url=full_url, params=params)
            raw_incidents += response.get("value", [])
            next_link = response.get("nextLink")

        modified_ids_to_mirror = [raw_incident.get("name") for raw_incident in raw_incidents]

        demisto.debug(f"All ids to mirror in are: {modified_ids_to_mirror}")
        return GetModifiedRemoteDataResponse(modified_ids_to_mirror)


    def get_remote_incident_data(client: AzureSentinelClient, incident_id: str):
        """
        Gets the remote incident data.
        Args:
            client: The client object.
            incident_id: The incident ID to retrieve.

        Returns:
            mirrored_data: The raw mirrored data.
            updated_object: The updated object to set in the XSOAR incident.
        """
        mirrored_data = client.http_request("GET", f"incidents/{incident_id}")
        incident_mirrored_data = incident_data_to_xsoar_format(mirrored_data, is_fetch_incidents=True)
        fetch_incidents_additional_info(client, incident_mirrored_data)
        updated_object: Dict[str, Any] = {}

        for field in INCOMING_MIRRORED_FIELDS:
            value = incident_mirrored_data.get(field)
            if value is not None:
                updated_object[field] = value

        return mirrored_data, updated_object


    def set_xsoar_incident_entries(updated_object: Dict[str, Any], entries: List, remote_incident_id: str) -> None:
        """
        Sets the XSOAR incident entries.
        Args:
            updated_object: The updated object to set in the XSOAR incident.
            entries: The entries to set.
            remote_incident_id: The remote incident ID.
        Returns:
            None.
        """
        if demisto.params().get("close_incident"):
            if updated_object.get("Status") == "Closed":
                close_reason = updated_object.get("classification", "")
                close_notes = updated_object.get("classificationComment", "")
                close_in_xsoar(entries, remote_incident_id, close_reason, close_notes)
            elif updated_object.get("Status") in ("New", "Active"):
                reopen_in_xsoar(entries, remote_incident_id)


    def close_in_xsoar(entries: List, remote_incident_id: str, close_reason: str, close_notes: str) -> None:
        demisto.debug(f"Incident is closed: {remote_incident_id}")
        entries.append(
            {
                "Type": EntryType.NOTE,
                "Contents": {
                    "dbotIncidentClose": True,
                    "closeReason": MIRROR_STATUS_DICT.get(close_reason, close_reason),
                    "closeNotes": f"{close_notes}\nClosed on Microsoft Sentinel".strip(),
                },
                "ContentsFormat": EntryFormat.JSON,
            }
        )


    def reopen_in_xsoar(entries: List, remote_incident_id: str):
        demisto.debug(f"Incident is opened (or reopened): {remote_incident_id}")
        entries.append(
            {
                "Type": EntryType.NOTE,
                "Contents": {"dbotIncidentReopen": True},
                "ContentsFormat": EntryFormat.JSON,
            }
        )


    def get_remote_data_command(client: AzureSentinelClient, args: Dict[str, Any]) -> GetRemoteDataResponse:
        """
        Args:
            client: The client object.
            args: The command arguments.
        Returns:
            GetRemoteDataResponse object, which contain the incident data to update.
        """
        remote_args = GetRemoteDataArgs(args)
        remote_incident_id = remote_args.remote_incident_id

        mirrored_data: Dict[str, Any] = {}
        entries: list = []

        try:
            demisto.debug(
                f"Performing get-remote-data command with incident id: {remote_incident_id} "
                f"and last_update: {remote_args.last_update}"
            )

            mirrored_data, updated_object = get_remote_incident_data(client, remote_incident_id)
            if updated_object:
                demisto.debug(f"Update incident {remote_incident_id} with fields: {updated_object}")
                set_xsoar_incident_entries(updated_object, entries, remote_incident_id)

            return GetRemoteDataResponse(mirrored_object=updated_object, entries=entries)

        except Exception as e:
            demisto.debug(f"Error in Microsoft Sentinel incoming mirror for incident: {remote_incident_id}\nError message: {e!s}")

            if not mirrored_data:
                mirrored_data = {"id": remote_incident_id}
            mirrored_data["in_mirror_error"] = str(e)

            return GetRemoteDataResponse(mirrored_object=mirrored_data, entries=[])


    def get_mapping_fields_command() -> GetMappingFieldsResponse:
        mapping_response = GetMappingFieldsResponse()
        incident_type_scheme = SchemeTypeMapping(type_name="Microsoft Sentinel Incident")

        for argument, description in OUTGOING_MIRRORED_FIELDS.items():
            incident_type_scheme.add_field(name=argument, description=description)
        mapping_response.add_scheme_type(incident_type_scheme)

        return mapping_response


    def check_required_action_on_incident(
        delta: Dict[str, Any], data: Dict[str, Any], incident_status: IncidentStatus
    ) -> Literal[Action.CLOSE, Action.UNCHANGED, Action.REOPEN]:
        """
        Checking if we need to close the incident or re-open in the remote system.
            1. should close the incident - will return Action.CLOSE
            2. should open the incident - will return Action.REOPEN
            3. no action needed - will return Action.UNCHANGED
        """
        closing_field = "classification"
        if incident_status == IncidentStatus.DONE:
            closing_reason = bool(delta.get(closing_field, data.get(closing_field, "")))
            return Action.CLOSE if demisto.params().get("close_ticket", False) and closing_reason else Action.UNCHANGED
        elif incident_status == IncidentStatus.ACTIVE:
            return Action.REOPEN if delta.get(closing_field) == "" else Action.UNCHANGED
        else:
            return Action.UNCHANGED


    def extract_classification_reason(delta: Dict[str, str], data: Dict[str, str]):
        """
        Returns the classification reason based on `delta` and `data`.

        Args:
            delta (dict): Contains potential 'classification' and 'classificationReason' keys.
            data (dict): Default classification information, with 'classification' and 'classificationReason'.

        Returns:
            The resolved classification reason.
        """

        classification: str = delta.get("classification", "") or data.get("classification", "")
        if classification == "FalsePositive":
            return delta.get("classificationReason") or data.get("classificationReason", "InaccurateData")
        return CLASSIFICATION_REASON.get(classification, "")


    def update_incident_request(
        client: AzureSentinelClient,
        incident_id: str,
        data: Dict[str, Any],
        delta: Dict[str, Any],
        required_action: Literal[Action.CLOSE, Action.UNCHANGED, Action.REOPEN] = Action.UNCHANGED,
    ) -> Dict[str, Any]:
        """
        Args:
            client (AzureSentinelClient)
            incident_id (str): the incident ID
            data (Dict[str, Any]): all the data of the incident
            delta (Dict[str, Any]): the delta of the changes in the incident's data
            required_action Literal[Action.CLOSE, Action.UNCHANGED,Action.REOPEN]: Describe the action preformed on the incident.
        Returns:
            Dict[str, Any]: the response of the update incident request
        """

        fetched_incident_data = get_incident_by_id_command(client, {"incident_id": incident_id}).raw_response
        required_fields = ("severity", "status", "title")
        if any(field not in data for field in required_fields):
            raise DemistoException(f"Update incident request is missing one of the required fields for the API: {required_fields}")

        severity = data.get("severity", "")
        status = data.get("status", "Active")
        if required_action == Action.REOPEN:
            # classification='' it's mean the XSOAR incident was reopen
            # need to update the remote incident status to Active
            demisto.debug(f"Reopen remote incident {incident_id}, set status to Active")
            status = "Active"
        properties = {
            "title": data.get("title"),
            "description": delta.get("description"),
            "severity": (severity if severity in LEVEL_TO_SEVERITY.values() else LEVEL_TO_SEVERITY[severity]),
            "status": status,
            "firstActivityTimeUtc": delta.get("firstActivityTimeUtc"),
            "lastActivityTimeUtc": delta.get("lastActivityTimeUtc"),
            "owner": demisto.get(fetched_incident_data, "properties.owner", {}),
            "labels": demisto.get(fetched_incident_data, "properties.labels", []),
        }

        properties["labels"] += [{"labelName": label, "type": "User"} for label in delta.get("tags", [])]

        if required_action == Action.CLOSE:
            status = "Closed"
            properties |= {
                "status": status,
                "classification": delta.get("classification") or data.get("classification"),
                "classificationComment": delta.get("classificationComment") or data.get("classificationComment"),
                "classificationReason": extract_classification_reason(delta, data),
            }
        remove_nulls_from_dictionary(properties)
        data = {
            "etag": fetched_incident_data.get("etag") or delta.get("etag") or data.get("etag"),
            "properties": properties,
        }
        demisto.debug(f"Updating incident with remote ID {incident_id} with data: {data}")
        response = client.http_request("PUT", f"incidents/{incident_id}", data=data)
        return response


    def update_remote_incident(
        client: AzureSentinelClient,
        data: Dict[str, Any],
        delta: Dict[str, Any],
        incident_status: IncidentStatus,
        incident_id: str,
    ) -> str:
        # we will run the mirror-out update only if there is relevant changes
        # (or closingUserId was changed meaning the incident wa reopened) or need to close the remote ticket
        relevant_keys_delta = OUTGOING_MIRRORED_FIELDS.keys() | {"closingUserId"}
        relevant_keys_delta &= delta.keys()
        # those fields are close incident fields and handled separately in check_required_action_on_incident
        relevant_keys_delta -= {"classification", "classificationComment"}
        if incident_status in (IncidentStatus.DONE, IncidentStatus.ACTIVE):
            demisto.debug(f"{incident_status=}")
            required_action = check_required_action_on_incident(delta, data, incident_status)

            if relevant_keys_delta or required_action != Action.UNCHANGED:
                demisto.debug(
                    f"Updating incident with remote ID {incident_id} in " f"remote system {required_action=}, {relevant_keys_delta=}."
                )
                return str(update_incident_request(client, incident_id, data, delta, required_action))
            else:
                demisto.debug(f"No relevant changes detected for the incident with remote ID {incident_id}, not updating.")

        demisto.debug(f"Incident with remote ID {incident_id} is not Active or Closed, not updating. (status: {incident_status})")
        return ""


    def update_remote_system_command(client: AzureSentinelClient, args: Dict[str, Any]):
        """Mirrors out local changes to the remote system.
        Args:
            client: The client object.
            args: The command arguments.
        Returns:
            The remote incident id that was modified. This is important when the incident is newly created remotely.
        """
        parsed_args = UpdateRemoteSystemArgs(args)
        delta = parsed_args.delta
        data = parsed_args.data
        remote_incident_id = parsed_args.remote_incident_id
        demisto.debug(f"Got the following data {data}, and delta {delta}.")
        if parsed_args.incident_changed and delta:
            demisto.debug(f"Got the following delta keys {list(delta.keys())}.")
            try:
                if result := update_remote_incident(client, data, delta, parsed_args.inc_status, remote_incident_id):
                    demisto.debug(f"Incident updated successfully. Result: {result}")

            except Exception as e:
                demisto.error(f"Error in Microsoft Sentinel outgoing mirror for incident {remote_incident_id}. Error message: {e!s}")
        else:
            demisto.debug(f"Skipping updating remote incident {remote_incident_id} as it didn't change.")

        return remote_incident_id


    """ INTEGRATION COMMANDS """



    def get_incident_by_id_command(client, args):
        inc_id = args.get("incident_id")
        url_suffix = f"incidents/{inc_id}"

        result = client.http_request("GET", url_suffix)
        incident = incident_data_to_xsoar_format(result)
        readable_output = tableToMarkdown(
            f"Incident {inc_id} details",
            incident,
            url_keys=["IncidentUrl"],
            headers=INCIDENT_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.Incident",
            outputs=incident,
            outputs_key_field="ID",
            raw_response=result,
        )


    def test_module(client: AzureSentinelClient, _: Dict[str, Any]):
        """
        Test connection to Azure by calling the list incidents API with limit=1
        """
        client.http_request("GET", "incidents", params={"$top": 1})
        return "ok"


    def list_incidents_command(
        client: AzureSentinelClient,
        args,
        is_fetch_incidents=False,
    ):
        """Retrieves incidents from Sentinel.
        Args:
            client: An AzureSentinelClient client.
            args: Demisto args.
            is_fetch_incidents: Is it part of a fetch incidents command.
        Returns:
            A CommandResult object with the array of incidents as output.
        """
        filter_expression = args.get("filter")
        next_link = args.get("next_link", "")
        limit = (
            min(arg_to_number(args.get("limit")) or FETCH_DEFAULT_LIMIT, FETCH_MAX_LIMIT)
            if is_fetch_incidents
            else min(arg_to_number(args.get("limit")) or DEFAULT_LIMIT, COMMAND_MAX_LIMIT)
        )

        if next_link:
            next_link = next_link.replace("%20", " ")  # Next link syntax can't handle '%' character
            result = client.http_request("GET", full_url=next_link)
        else:
            url_suffix = "incidents"
            params = {
                "$top": limit,
                "$filter": filter_expression,
                "$orderby": args.get("orderby", "properties/createdTimeUtc asc"),
            }
            remove_nulls_from_dictionary(params)

            result = client.http_request("GET", url_suffix, params=params)

        incidents = [incident_data_to_xsoar_format(inc, is_fetch_incidents) for inc in result.get("value")]

        if is_fetch_incidents:
            return CommandResults(outputs=incidents, outputs_prefix="AzureSentinel.Incident")

        outputs = {"AzureSentinel.Incident(val.ID === obj.ID)": incidents}

        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f"Incidents List ({len(incidents)} results)",
            incidents,
            headers=INCIDENT_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(readable_output=readable_output, outputs=outputs, raw_response=result)


    def list_watchlists_command(client, args):
        url_suffix = "watchlists"
        specific_watchlists_alias = args.get("watchlist_alias")
        if specific_watchlists_alias:
            url_suffix += f"/{specific_watchlists_alias}"

        result = client.http_request("GET", url_suffix)

        iterable_watchlists = [result] if specific_watchlists_alias else result.get("value")
        watchlists = [watchlist_data_to_xsoar_format(watchlist) for watchlist in iterable_watchlists]
        readable_output = tableToMarkdown(
            "Watchlists results",
            watchlists,
            headers=["Name", "ID", "Description"],
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.Watchlist",
            outputs=watchlists,
            outputs_key_field="ID",
            raw_response=result,
        )


    def delete_watchlist_command(client, args):
        alias = args.get("watchlist_alias")
        url_suffix = f"watchlists/{alias}"
        client.http_request("DELETE", url_suffix)
        return CommandResults(readable_output=f"Watchlist {alias} was deleted successfully.")


    def delete_watchlist_item_command(client, args):
        alias = args.get("watchlist_alias")
        item_id = args.get("watchlist_item_id")
        url_suffix = f"watchlists/{alias}/watchlistItems/{item_id}"
        client.http_request("DELETE", url_suffix)
        return CommandResults(readable_output=f"Watchlist item {item_id} was deleted successfully.")


    def create_update_watchlist_command(client, args):
        """Create or update a watchlist in Azure Sentinel.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        # prepare the request
        alias = args.get("watchlist_alias")
        raw_content = ""
        path = args.get("file_entry_id")
        if path:
            path = demisto.getFilePath(path)
            with open(path["path"], "rb") as file:
                raw_content = file.read().decode()
        data = {
            "properties": {
                "watchlistAlias": alias,
                "displayName": args.get("watchlist_display_name"),
                "description": args.get("description", ""),
                "provider": args.get("provider", "XSOAR"),
                "source": "Local file",
                "labels": argToList(args.get("labels", ""), ","),
                "numberOfLinesToSkip": arg_to_number(args.get("lines_to_skip", "0")),
                "rawContent": raw_content,
                "itemsSearchKey": args.get("items_search_key"),
                "contentType": args.get("content_type", "Text/Csv"),
            }
        }

        # request
        raw_result = client.http_request("PUT", url_suffix=f"watchlists/{alias}", data=data)

        # prepare result
        watchlist = watchlist_data_to_xsoar_format(raw_result)

        readable_output = tableToMarkdown(
            "Create watchlist results",
            watchlist,
            headers=["Name", "ID", "Description"],
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.Watchlist",
            outputs=watchlist,
            outputs_key_field="ID",
            raw_response=raw_result,
        )


    def create_update_watchlist_item_command(client, args):
        """Create or update a watchlist item in Azure Sentinel.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        # prepare the request
        alias = args.get("watchlist_alias")
        watchlist_item_id = args.get("watchlist_item_id", uuid.uuid4())
        item_key_value_str = args.get("item_key_value", "{}")
        item_key_value = json.loads(item_key_value_str)
        item_data = {"properties": {"itemsKeyValue": item_key_value}}

        # request
        url_suffix = f"watchlists/{alias}/watchlistItems/{watchlist_item_id}"
        raw_item = client.http_request("PUT", url_suffix=url_suffix, data=item_data)

        # prepare result
        item = {"WatchlistAlias": alias, **watchlist_item_data_to_xsoar_format(raw_item)}
        readable_output = tableToMarkdown(
            "Create watchlist item results",
            item,
            headers=["ID", "ItemsKeyValue"],
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.WatchlistItem",
            outputs=item,
            outputs_key_field="ID",
            raw_response=raw_item,
        )


    def list_watchlist_items_command(client, args):
        """
        Get specific watchlist item or list of watchlist items.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        # prepare the request
        alias = args.get("watchlist_alias", "")
        url_suffix = f"watchlists/{alias}/watchlistItems"
        item_id = args.get("watchlist_item_id")
        if item_id:
            url_suffix += f"/{item_id}"

        # request
        result = client.http_request("GET", url_suffix)

        # prepare result
        raw_items = [result] if item_id else result.get("value")
        items = [{"WatchlistAlias": alias, **watchlist_item_data_to_xsoar_format(item)} for item in raw_items]
        readable_output = tableToMarkdown(
            "Watchlist items results",
            items,
            headers=["ID", "ItemsKeyValue"],
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.WatchlistItem",
            outputs=items,
            outputs_key_field="ID",
            raw_response=result,
        )


    def update_incident_command(client: AzureSentinelClient, args: Dict[str, Any]):
        inc_id = args.get("incident_id")
        inc_data = get_update_incident_request_data(client, args)

        url_suffix = f"incidents/{inc_id}"
        result = client.http_request("PUT", url_suffix, data=inc_data)
        incident = incident_data_to_xsoar_format(result)
        readable_output = tableToMarkdown(
            f"Updated incidents {inc_id} details",
            incident,
            headers=INCIDENT_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.Incident",
            outputs=incident,
            outputs_key_field="ID",
            raw_response=result,
        )


    def create_incident_command(client: AzureSentinelClient, args: Dict[str, Any]):
        inc_id = uuid.uuid4()
        inc_data = {
            "properties": {
                "severity": args.get("severity"),
                "status": args.get("status"),
                "title": args.get("title"),
                "description": args.get("description"),
                "labels": argToList(args.get("labels", "")),
            }
        }
        remove_nulls_from_dictionary(inc_data["properties"])

        url_suffix = f"incidents/{inc_id}"
        result = client.http_request("PUT", url_suffix, data=inc_data)
        incident = incident_data_to_xsoar_format(result)
        readable_output = tableToMarkdown(
            f"Created incident {inc_id} details",
            incident,
            headers=INCIDENT_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.Incident",
            outputs=incident,
            outputs_key_field="ID",
            raw_response=result,
        )


    def delete_incident_command(client, args):
        inc_id = args.get("incident_id")
        url_suffix = f"incidents/{inc_id}"

        client.http_request("DELETE", url_suffix)

        context = {"ID": inc_id, "Deleted": True}

        return CommandResults(
            readable_output=f"Incident {inc_id} was deleted successfully.",
            outputs_prefix="AzureSentinel.Incident",
            outputs=context,
            outputs_key_field="ID",
            raw_response={},
        )


    def list_incident_comments_command(client, args):
        inc_id = args.get("incident_id")
        limit = min(MAX_INCIDENT_COMMENT_LIMIT, int(args.get("limit")))
        next_link = args.get("next_link", "")

        if next_link:
            next_link = next_link.replace("%20", " ")  # Next link syntax can't handle '%' character
            result = client.http_request("GET", full_url=next_link)
        else:
            url_suffix = f"incidents/{inc_id}/comments"
            params = {"$top": limit}
            remove_nulls_from_dictionary(params)

            result = client.http_request("GET", url_suffix, params=params)

        comments = [comment_data_to_xsoar_format(inc, inc_id) for inc in result.get("value")]

        outputs = {f"AzureSentinel.IncidentComment(val.ID === obj.ID && val.IncidentID === {inc_id})": comments}

        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f"Incident {inc_id} Comments ({len(comments)} results)",
            comments,
            headers=COMMENT_HEADERS,  # disable-secrets-detection
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(readable_output=readable_output, outputs=outputs, raw_response=result)


    def incident_add_comment_command(client, args):
        import random

        inc_id = args.get("incident_id")
        url_suffix = f"incidents/{inc_id}/comments/{random.getrandbits(128)!s}"
        comment_data = {"properties": {"message": args.get("message")}}

        result = client.http_request("PUT", url_suffix, data=comment_data)
        comment = comment_data_to_xsoar_format(result, inc_id)

        readable_output = tableToMarkdown(
            f"Incident {inc_id} new comment details",
            comment,
            headers=COMMENT_HEADERS,  # disable-secrets-detection
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.IncidentComment",
            outputs=comment,
            outputs_key_field=["ID", "IncidentID"],
            raw_response=result,
        )


    def incident_delete_comment_command(client, args):
        inc_id = args.get("incident_id")
        comment_id = args.get("comment_id")
        url_suffix = f"incidents/{inc_id}/comments/{comment_id}"

        res = client.http_request("DELETE", url_suffix)
        if isinstance(res, requests.Response) and res.status_code == 204:
            readable_output = f"Comment {comment_id} does not exist."
        else:
            readable_output = f"Comment {comment_id} was deleted successfully."

        return CommandResults(readable_output=readable_output)


    def list_incident_entities_command(client, args):
        """
        Get a list of incident's entities.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        def xsoar_transformer(entity):
            return {
                "ID": entity.get("name"),
                "Kind": entity.get("kind"),
                "Properties": entity.get("properties"),
            }

        return generic_list_incident_items(
            client=client,
            incident_id=args.get("incident_id"),
            items_kind="entities",
            key_in_raw_result="entities",
            outputs_prefix="AzureSentinel.IncidentEntity",
            xsoar_transformer=xsoar_transformer,
        )


    def list_incident_alerts_command(client, args):
        """
        Get a list of incident's alerts.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """
        return generic_list_incident_items(
            client=client,
            incident_id=args.get("incident_id"),
            items_kind="alerts",
            key_in_raw_result="value",
            outputs_prefix="AzureSentinel.IncidentAlert",
            xsoar_transformer=alert_data_to_xsoar_format,
        )


    def list_incident_relations_command(client, args):
        inc_id = args.get("incident_id")
        limit = min(50, int(args.get("limit")))
        next_link = args.get("next_link", "")
        entity_kinds = args.get("entity_kinds")
        filter_expression = args.get("filter", "")

        if next_link:
            next_link = next_link.replace("%20", " ")  # Next link syntax can't handle '%' character
            result = client.http_request("GET", full_url=next_link)
        else:
            # Handle entity kinds to filter by
            if entity_kinds:
                if filter_expression:
                    filter_expression += " and "
                filter_expression += f"search.in(properties/relatedResourceKind, '{entity_kinds}', ',')"

            url_suffix = f"incidents/{inc_id}/relations"
            params = {"$top": limit, "$filter": filter_expression}
            remove_nulls_from_dictionary(params)

            result = client.http_request("GET", url_suffix, params=params)

        relations = [incident_related_resource_data_to_xsoar_format(resource, inc_id) for resource in result.get("value")]

        outputs = {f"AzureSentinel.IncidentRelatedResource(val.ID === obj.ID && val.IncidentID == {inc_id})": relations}

        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f"Incident {inc_id} Relations ({len(relations)} results)",
            relations,
            headerTransform=pascalToSpace,
            removeNull=True,
        )
        return CommandResults(readable_output=readable_output, outputs=outputs, raw_response=result)


    def update_next_link_in_context(result: dict, outputs: dict):
        """
        Update the output context with the next link if exist
        """
        # we don't want whitespaces in this value, so it won't be considered as two arguments in the CLI by mistake
        next_link = result.get("nextLink", "").replace(" ", "%20")
        if next_link:
            next_link_item = {
                "Description": NEXT_LINK_DESCRIPTION,
                "URL": next_link,
            }
            outputs[f'AzureSentinel.NextLink(val.Description == "{NEXT_LINK_DESCRIPTION}")'] = next_link_item


    def fetch_incidents_additional_info(client: AzureSentinelClient, incidents: List | Dict):
        """Fetches additional info of an incidents array or a single incident.

        Args:
            client: An AzureSentinelClient client.
            incidents: An incidents array or a single incident to fetch additional info for.

        Returns:
            None. Updates the incidents array with the additional info.
        """
        additional_fetch = {
            "Alerts": {"method": "POST", "result_key": "value"},
            "Entities": {"method": "POST", "result_key": "entities"},
            "Comments": {"method": "GET", "result_key": "value"},
            "Relations": {"method": "GET", "result_key": "value"},
        }

        if isinstance(incidents, dict):
            incidents = [incidents]

        for incident in incidents:
            for additional_info in demisto.params().get("fetch_additional_info", []):
                info_type = additional_info.lower()
                method = additional_fetch[additional_info]["method"]
                results_key = additional_fetch[additional_info]["result_key"]
                incident_id = incident.get("ID")

                incident[info_type] = client.http_request(method, f"incidents/{incident_id}/{info_type}").get(results_key)


    def fetch_incidents(
        client: AzureSentinelClient,
        last_run: dict,
        first_fetch_time: str,
        min_severity: str,
        statuses_to_fetch: list = [],
    ) -> tuple:
        """Fetching incidents.
        Args:
            first_fetch_time: The first fetch time.
            client: An AzureSentinelClient client.
            last_run: An dictionary of the last run.
            min_severity: A minimum severity of incidents to fetch.
            statuses_to_fetch: A list of statuses to fetch.

        Returns:
            (tuple): 1. The LastRun object updated with the last run details.
            2. An array of incidents.

        """
        # Get the last fetch details, if exist
        limit = min(arg_to_number(demisto.params().get("limit")) or FETCH_MAX_LIMIT, FETCH_MAX_LIMIT)
        last_fetch_time = last_run.get("last_fetch_time")
        last_fetch_ids = last_run.get("last_fetch_ids", [])
        last_incident_number = last_run.get("last_incident_number")
        demisto.debug(f"{last_fetch_time=}, {last_fetch_ids=}, {last_incident_number=}")

        if last_fetch_time is None or not last_incident_number:
            demisto.debug("handle via timestamp")
            if last_fetch_time is None:
                last_fetch_time_str, _ = parse_date_range(first_fetch_time, DATE_FORMAT)
                latest_created_time = dateparser.parse(last_fetch_time_str)
                if not latest_created_time:
                    raise DemistoException(f"Got empty latest_created_time. {last_fetch_time_str=} {last_fetch_time=}")
            else:
                latest_created_time = dateparser.parse(last_fetch_time)
                if not latest_created_time:
                    raise DemistoException(f"Got empty latest_created_time. {last_fetch_time=}")

            latest_created_time_str = latest_created_time.strftime(DATE_FORMAT)
            command_args = {
                "filter": (
                    f"properties/createdTimeUtc ge {latest_created_time_str} {severity_filter(min_severity)}"
                    f" {status_filter(statuses_to_fetch)}".strip()
                ),
                "orderby": "properties/createdTimeUtc asc",
                "limit": limit,
            }
            demisto.debug(f"Filter query used:{command_args['filter']}")

        else:
            demisto.debug("last fetch time is empty, trying to fetch incidents by last incident id")
            latest_created_time = dateparser.parse(last_fetch_time)
            if latest_created_time is None:
                raise DemistoException(f"{last_fetch_time=} couldn't be parsed")
            command_args = {
                "filter": (
                    f"properties/incidentNumber gt {last_incident_number} {severity_filter(min_severity)}"
                    f" {status_filter(statuses_to_fetch)}".strip()
                ),
                "orderby": "properties/incidentNumber asc",
                "limit": limit,
            }
            demisto.debug(f"Filter query used:{command_args['filter']}")

        raw_incidents = list_incidents_command(client, command_args, is_fetch_incidents=True).outputs
        if isinstance(raw_incidents, dict):
            raw_incidents = [raw_incidents]
        demisto.debug(f"raw incidents id before dedup: {[incident['ID'] for incident in raw_incidents]}")
        raw_incidents = list(filter(lambda incident: incident["ID"] not in last_fetch_ids, raw_incidents))
        demisto.debug(f"raw incidents id after dedup: {[incident['ID'] for incident in raw_incidents]}")

        fetch_incidents_additional_info(client, raw_incidents)

        return process_incidents(raw_incidents, latest_created_time, last_incident_number)  # type: ignore[attr-defined]


    def fetch_incidents_command(client, params):
        # How much time before the first fetch to retrieve incidents
        first_fetch_time = params.get("fetch_time", "3 days").strip()
        min_severity = params.get("min_severity", "Informational")
        statuses_to_fetch = argToList(params.get("statuses_to_fetch", []))
        # Set and define the fetch incidents command to run after activated via integration settings.
        last_run = demisto.getLastRun()
        demisto.debug(f"Current last run is {last_run}")
        next_run, incidents = fetch_incidents(
            client=client,
            last_run=last_run,
            first_fetch_time=first_fetch_time,
            min_severity=min_severity,
            statuses_to_fetch=statuses_to_fetch,
        )
        demisto.debug(f"New last run is {last_run}")
        demisto.setLastRun(next_run)
        demisto.incidents(incidents)


    def process_incidents(raw_incidents: list, latest_created_time: datetime, last_incident_number):
        """Processing the raw incidents
        Args:
            raw_incidents: The incidents that were fetched from the API.
            last_incident_number: The last incident number that was fetched.
            latest_created_time: The latest created time.

        Returns:
            A next_run dictionary, and an array of incidents.
        """

        incidents = []
        current_fetch_ids = []
        if not last_incident_number:
            last_incident_number = 0

        for incident in raw_incidents:
            incident_severity = severity_to_level(incident.get("Severity"))
            demisto.debug(f"{incident.get('ID')=}, {incident_severity=}, {incident.get('IncidentNumber')=}")

            incident_created_time = dateparser.parse(incident.get("CreatedTimeUTC"))
            current_fetch_ids.append(incident.get("ID"))
            add_mirroring_fields(incident)
            xsoar_incident = {
                "name": "[Azure Sentinel] " + incident.get("Title"),
                "occurred": incident.get("CreatedTimeUTC"),
                "severity": incident_severity,
                "rawJSON": json.dumps(incident),
            }

            # Update last run to the latest fetch time
            if incident_created_time is None:
                raise DemistoException(f"{incident.get('CreatedTimeUTC')=} couldn't be parsed")

            incidents.append(xsoar_incident)

            if incident_created_time > latest_created_time:
                latest_created_time = incident_created_time
            if incident.get("IncidentNumber") > last_incident_number:
                last_incident_number = incident.get("IncidentNumber")
        next_run = {
            "last_fetch_time": latest_created_time.strftime(DATE_FORMAT),
            "last_fetch_ids": current_fetch_ids,
            "last_incident_number": last_incident_number,
        }
        return next_run, incidents


    def threat_indicators_data_to_xsoar_format(ind_data):
        """
        Convert the threat indicators data from the raw to XSOAR format.

        :param ind_data: (dict) The incident raw data.
        """

        properties = ind_data.get("properties", {})
        pattern = properties.get("parsedPattern", [])[0] if properties.get("parsedPattern", []) else {}

        formatted_data = {
            "ID": ind_data.get("id"),
            "Name": ind_data.get("name"),
            "ETag": ind_data.get("etag"),
            "Type": ind_data.get("type"),
            "Kind": ind_data.get("kind"),
            "Confidence": properties.get("confidence", ""),
            "Created": format_date(properties.get("created", "")),
            "CreatedByRef": properties.get("createdByRef", ""),
            "ExternalId": properties.get("externalId", ""),
            "LastUpdatedTimeUtc": format_date(properties.get("lastUpdatedTimeUtc", "")),
            "Revoked": properties.get("revoked", ""),
            "Source": properties.get("source", ""),
            "Tags": properties.get("threatIntelligenceTags", "No Tags"),
            "DisplayName": properties.get("displayName", ""),
            "Description": properties.get("description", ""),
            "Types": properties.get("threatTypes", ""),
            "KillChainPhases": [
                {
                    "KillChainName": phase.get("killChainName"),
                    "PhaseName": phase.get("phaseName"),
                }
                for phase in properties.get("KillChainPhases", [])
            ],
            "ParsedPattern": (
                {
                    "PatternTypeKey": pattern.get("patternTypeKey"),
                    "PatternTypeValues": {
                        "Value": dict_safe_get(pattern, ["patternTypeValues", 0, "value"]),
                        "ValueType": dict_safe_get(pattern, ["patternTypeValues", 0, "valueType"]),
                    },
                }
                if pattern
                else None
            ),
            "Pattern": properties.get("pattern", ""),
            "PatternType": properties.get("patternType", ""),
            "ValidFrom": format_date(properties.get("validFrom", "")),
            "ValidUntil": format_date(properties.get("validUntil", "")),
            "Values": dict_safe_get(pattern, ["patternTypeValues", 0, "value"]),
            "Deleted": False,
        }
        remove_nulls_from_dictionary(formatted_data)

        return formatted_data


    def build_query_filter(args):
        filtering_args = {
            "minConfidence": args.get("min_confidence", ""),
            "maxConfidence": args.get("max_confidence", ""),
            "minValidUntil": format_date(args.get("min_valid_from", "")),
            "maxValidUntil": format_date(args.get("max_valid_from", "")),
            "sources": argToList(args.get("sources")),
            "keywords": " ".join(argToList(args.get("keywords"))),
            "threatTypes": argToList(args.get("threat_types")),
            "patternTypes": [],
        }

        indicator_types = argToList(args.get("indicator_types"))
        if indicator_types:
            for ind_type in indicator_types:
                pattern_type = {
                    "ipv4": "{ind_type}-address",
                    "ipv6": "{ind_type}-address",
                    "domain": "{ind_type}-name",
                }.get(ind_type, "{ind_type}").format(ind_type=ind_type)
                filtering_args["patternTypes"].append(pattern_type)

        include_disabled = args.get("include_disabled", "false") == "true"
        filtering_args["includeDisabled"] = include_disabled

        remove_nulls_from_dictionary(filtering_args)

        return filtering_args


    def build_threat_indicator_data(args, source):
        value = args.get("value")

        data = {
            "displayName": args.get("display_name"),
            "description": args.get("description"),
            "revoked": args.get("revoked", ""),
            "confidence": arg_to_number(args.get("confidence")),
            "threatTypes": argToList(args.get("threat_types")),
            "includeDisabled": args.get("include_disabled", ""),
            "source": source,
            "threatIntelligenceTags": argToList(args.get("tags")),
            "validFrom": format_date(args.get("valid_from", "")),
            "validUntil": format_date(args.get("valid_until", "")),
            "createdByRef": args.get("created_by", ""),
        }

        indicator_type = args.get("indicator_type")
        if indicator_type == "ipv4":
            indicator_type = "ipv4-addr"
        elif indicator_type == "ipv6":
            indicator_type = "ipv6-addr"
        elif indicator_type == "domain":
            indicator_type = "domain-name"

        data["patternType"] = indicator_type

        if indicator_type == "file":
            hash_type = args.get("hash_type")
            data["hashType"] = hash_type
            data["pattern"] = f"[file:hashes.'{hash_type}' = '{value}']"
        else:
            data["pattern"] = f"[{indicator_type}:value = '{value}']"

        data["killChainPhases"] = []

        kill_chains = argToList(args.get("kill_chains", []))
        if kill_chains:
            for kill_chain_phase in kill_chains:
                data["killChainPhases"].append({"killChainName": kill_chain_phase, "phaseName": kill_chain_phase})

        remove_nulls_from_dictionary(data)

        return data


    def build_updated_indicator_data(new_ind_data, original_ind_data):
        original_extracted_data = extract_original_data_from_indicator(original_ind_data.get("properties"))
        # When updating an indicator, one can not change the original source
        source = original_extracted_data.get("source")
        new_data = build_threat_indicator_data(new_ind_data, source)

        original_extracted_data.update(new_data)

        return original_extracted_data


    def extract_original_data_from_indicator(original_data):
        extracted_data = {
            "description": original_data.get("description", ""),
            "revoked": original_data.get("revoked", ""),
            "confidence": arg_to_number(original_data.get("confidence")),
            "threatTypes": argToList(original_data.get("threatTypes")),
            "killChainPhases": argToList(original_data.get("killChainPhases")),
            "threatIntelligenceTags": argToList(original_data.get("threatIntelligenceTags")),
            "validFrom": original_data.get("validFrom", ""),
            "validUntil": original_data.get("validUntil", ""),
            "createdByRef": original_data.get("createdByRef", ""),
            "created": original_data.get("created", ""),
            "externalId": original_data.get("externalId"),
            "displayName": original_data.get("displayName"),
            "source": original_data.get("source", DEFAULT_SOURCE),
        }

        remove_nulls_from_dictionary(extracted_data)
        return extracted_data


    def list_threat_indicator_command(client, args):
        url_suffix = "threatIntelligence/main/indicators"
        limit = arg_to_number(args.get("limit", DEFAULT_LIMIT))  # the default limit is 50

        next_link = args.get("next_link", "")
        if next_link:
            next_link = next_link.replace("%20", " ")  # Next link syntax can't handle '%' character
            result = client.http_request("GET", full_url=next_link)
        else:
            if indicator_name := args.get("indicator_name"):
                url_suffix += f"/{indicator_name}"

            result = client.http_request("GET", url_suffix, params={"$top": limit})

        num_of_threat_indicators = 0
        threat_indicators = []

        if result.get("value"):
            threat_indicators = [threat_indicators_data_to_xsoar_format(ind) for ind in result.get("value")]
            num_of_threat_indicators = len(threat_indicators)

        outputs = {"AzureSentinel.ThreatIndicator": threat_indicators}
        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f"Threat Indicators ({num_of_threat_indicators} results)",
            threat_indicators,
            headers=THREAT_INDICATORS_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            outputs_key_field="ID",
            raw_response=result,
        )


    def query_threat_indicators_command(client, args):
        url_suffix = "threatIntelligence/main/queryIndicators"
        limit = arg_to_number(args.get("limit", DEFAULT_LIMIT))  # the default limit is 50
        data = build_query_filter(args)
        next_link = args.get("next_link", "")
        if next_link:
            next_link = next_link.replace("%20", " ")  # Next link syntax can't handle '%' character
            result = client.http_request("POST", full_url=next_link, data=data)
        else:
            result = client.http_request("POST", url_suffix, params={"$top": limit}, data=data)

        num_of_threat_indicators = 0
        threat_indicators = []

        if result.get("value") is not None:
            threat_indicators = [threat_indicators_data_to_xsoar_format(ind) for ind in result.get("value")]
            num_of_threat_indicators = len(threat_indicators)

        outputs = {"AzureSentinel.ThreatIndicator": threat_indicators}
        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f"Threat Indicators ({num_of_threat_indicators} results)",
            threat_indicators,
            headers=THREAT_INDICATORS_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            outputs_key_field="ID",
            raw_response=result,
        )


    def create_threat_indicator_command(client, args):
        url_suffix = "threatIntelligence/main/createIndicator"

        data = {
            "kind": "indicator",
            "properties": build_threat_indicator_data(args, source=DEFAULT_SOURCE),
        }

        result = client.http_request("POST", url_suffix, data=data)

        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        readable_output = tableToMarkdown(
            "New threat Indicator was created",
            threat_indicators,
            headers=THREAT_INDICATORS_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.ThreatIndicator",
            outputs=threat_indicators,
            outputs_key_field="ID",
            raw_response=result,
        )


    def update_threat_indicator_command(client, args):
        indicator_name = args.get("indicator_name")
        get_indicator_url_suffix = f"threatIntelligence/main/indicators/{indicator_name}"

        original_data = client.http_request("GET", get_indicator_url_suffix)

        updated_data = build_updated_indicator_data(args, original_data)

        data = {"kind": "indicator", "properties": updated_data}

        update_indicator_url_suffix = f"threatIntelligence/main/indicators/{indicator_name}"

        result = client.http_request("PUT", update_indicator_url_suffix, data=data)
        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        readable_output = tableToMarkdown(
            f"Threat Indicator {indicator_name} was updated",
            threat_indicators,
            headers=THREAT_INDICATORS_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.ThreatIndicator",
            outputs=threat_indicators,
            outputs_key_field="ID",
            raw_response=result,
        )


    def delete_threat_indicator_command(client, args):
        indicator_names = argToList(args.get("indicator_names"))
        outputs = []

        for indicator_name in indicator_names:
            url_suffix = f"threatIntelligence/main/indicators/{indicator_name}"
            client.http_request("DELETE", url_suffix)
            outputs.append({"Name": indicator_name, "Deleted": True})

        return CommandResults(
            readable_output="Threat Intelligence Indicators " + ", ".join(indicator_names) + " were deleted successfully",
            outputs_prefix="AzureSentinel.ThreatIndicator",
            outputs_key_field="Name",
            outputs=outputs,
            raw_response={},
        )


    def append_tags_threat_indicator_command(client, args):
        indicator_name = args.get("indicator_name")
        tags = argToList(args.get("tags"))
        url_suffix = f"threatIntelligence/main/indicators/{indicator_name}/appendTags"

        data = {"threatIntelligenceTags": tags}

        result = client.http_request("POST", url_suffix, data=data)

        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        return CommandResults(
            readable_output=f"Tags were appended to {indicator_name} Threat Indicator.",
            outputs_prefix="AzureSentinel.ThreatIndicator",
            outputs=threat_indicators,
            outputs_key_field="ID",
            raw_response=result,
        )


    def replace_tags_threat_indicator_command(client, args):
        indicator_name = args.get("indicator_name")
        tags = argToList(args.get("tags"))
        url_suffix = f"threatIntelligence/main/indicators/{indicator_name}/replaceTags"

        data = {"properties": {"threatIntelligenceTags": tags}}

        result = client.http_request("POST", url_suffix, data=data)

        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        return CommandResults(
            readable_output=f"Tags were replaced to {indicator_name} Threat Indicator.",
            outputs_prefix="AzureSentinel.ThreatIndicator",
            outputs=threat_indicators,
            outputs_key_field="ID",
            raw_response=result,
        )


    def list_alert_rule_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        limit = int(args.get("limit", 50))
        rule_id = args.get("rule_id")

        url_suffix = "alertRules" + (f"/{rule_id}" if rule_id else "")

        raw_results: list = []
        next_link = True
        while next_link:
            full_url = next_link if isinstance(next_link, str) else None

            response = client.http_request("GET", url_suffix, full_url=full_url)

            raw_results += [response] if rule_id else response.get("value", [])

            next_link = response.get("nextLink")
            if len(raw_results) >= limit:
                next_link = False

        raw_results = raw_results[:limit]

        readable_result = [
            {
                "ID": rule.get("name"),
                "Kind": rule.get("kind"),
                "Severity": rule.get("properties", {}).get("severity"),
                "Display Name": rule.get("properties", {}).get("displayName"),
                "Description": rule.get("properties", {}).get("description"),
                "Enabled": rule.get("properties", {}).get("enabled"),
            }
            for rule in raw_results
        ]
        tabel_name = "Azure Sentinel Alert Rules" + (f" ({len(raw_results)} results)" if len(raw_results) > 1 else "")
        readable_output = tableToMarkdown(tabel_name, readable_result, sort_headers=False)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.AlertRule",
            outputs=raw_results,
            outputs_key_field="name",
            raw_response=raw_results,
        )


    def list_alert_rule_template_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        limit = int(args.get("limit", 50))
        template_id = args.get("template_id")

        url_suffix = "alertRuleTemplates" + (f"/{template_id}" if template_id else "")

        raw_results: list = []
        next_link = True
        while next_link:
            full_url = next_link if isinstance(next_link, str) else None

            response = client.http_request("GET", url_suffix, full_url=full_url)

            raw_results += [response] if template_id else response.get("value", [])

            next_link = response.get("nextLink")
            if len(raw_results) >= limit:
                next_link = False

        raw_results = raw_results[:limit]

        readable_result = [
            {
                "ID": rule.get("name"),
                "Kind": rule.get("kind"),
                "Severity": rule.get("properties", {}).get("severity"),
                "Display Name": rule.get("properties", {}).get("displayName"),
                "Description": rule.get("properties", {}).get("description"),
                "Status": rule.get("properties", {}).get("status"),
                "Created Date UTC": rule.get("properties", {}).get("createdDateUTC"),
                "Last Updated Date UTC": rule.get("properties", {}).get("lastUpdatedDateUTC"),
                "Alert Rules Created By Template Count": rule.get("properties", {}).get("alertRulesCreatedByTemplateCount"),
            }
            for rule in raw_results
        ]
        tabel_name = "Azure Sentinel Alert Rule Template" + (f" ({len(raw_results)} results)" if len(raw_results) > 1 else "")
        readable_output = tableToMarkdown(tabel_name, readable_result, sort_headers=False)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.AlertRuleTemplate",
            outputs=raw_results,
            outputs_key_field="name",
            raw_response=raw_results,
        )


    def delete_alert_rule_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        rule_id = args.get("rule_id")
        url_suffix = f"alertRules/{rule_id}"
        response = client.http_request("DELETE", url_suffix)

        if isinstance(response, requests.Response) and response.status_code == 204:
            return CommandResults(readable_output=f"Alert rule {rule_id} does not exist.")

        return CommandResults(readable_output=f"Alert rule {rule_id} was deleted successfully.")


    def list_subscriptions_command(
        client: AzureSentinelClient,
    ) -> CommandResults:  # pragma: no cover
        full_url = urljoin(
            client.azure_cloud.endpoints.resource_manager,
            "subscriptions?api-version=2020-01-01",
        )

        response = client.http_request("GET", full_url=full_url)
        data_from_response = response.get("value", [])

        readable_output = tableToMarkdown(
            "Azure Sentinel Subscriptions",
            data_from_response,
            ["subscriptionId", "tenantId", "displayName", "state"],
            removeNull=True,
            headerTransform=string_to_table_header,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.Subscription",
            outputs=data_from_response,
            outputs_key_field="subscriptionId",
            raw_response=response,
        )


    def list_resource_groups_command(
        client: AzureSentinelClient, args: Dict[str, Any], subscription_id: str
    ) -> CommandResults:  # pragma: no cover
        tag = args.get("tag")
        limit = arg_to_number(args.get("limit", 50))
        subscription_id = subscription_id

        # extracting the tag name and value from the tag argument that is received from the user as a string
        filter_by_tag = azure_tag_formatter(tag) if tag else ""

        full_url = urljoin(
            client.azure_cloud.endpoints.resource_manager,
            f"subscriptions/{subscription_id}/resourcegroups?$filter=\
    {filter_by_tag}&$top={limit}&api-version=2021-04-01",
        )

        response = client.http_request("GET", full_url=full_url)
        data_from_response = response.get("value", [])

        readable_output = tableToMarkdown(
            "Azure Sentinel Resource Groups",
            data_from_response,
            ["name", "location", "tags", "properties.provisioningState"],
            removeNull=True,
            headerTransform=string_to_table_header,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.ResourceGroup",
            outputs=data_from_response,
            outputs_key_field="name",
            raw_response=response,
        )


    def validate_required_arguments_for_alert_rule(args: Dict[str, Any]) -> None:
        required_args_by_kind = {
            "fusion": ["rule_name", "template_name", "enabled"],
            "microsoft_security_incident_creation": [
                "rule_name",
                "displayName",
                "enabled",
                "product_filter",
            ],
            "scheduled": [
                "rule_name",
                "displayName",
                "enabled",
                "query",
                "query_frequency",
                "query_period",
                "severity",
                "suppression_duration",
                "suppression_enabled",
                "trigger_operator",
                "trigger_threshold",
            ],
        }

        kind = args.get("kind", "")
        if not kind:
            raise DemistoException('The "kind" argument is required for alert rule.')
        for arg in required_args_by_kind.get(kind, []):
            if not args.get(arg):
                raise DemistoException(f'"{arg}" is required for "{kind}" alert rule.')


    def create_data_for_alert_rule(args: Dict[str, Any]) -> Dict[str, Any]:
        validate_required_arguments_for_alert_rule(args)

        properties = {
            "alertRuleTemplateName": args.get("template_name"),
            "enabled": argToBoolean(args.get("enabled")) if args.get("enabled") else None,
            "displayName": args.get("displayName"),
            "productFilter": string_to_table_header(args.get("product_filter", "")),
            "description": args.get("description"),
            "displayNamesExcludeFilter": args.get("name_exclude_filter"),
            "displayNamesFilter": args.get("name_include_filter"),
            "severitiesFilter": args.get("severity_filter"),
            "query": args.get("query"),
            "queryFrequency": args.get("query_frequency"),
            "queryPeriod": args.get("query_period"),
            "severity": pascalToSpace(args.get("severity")),
            "suppressionDuration": args.get("suppression_duration"),
            "suppressionEnabled": (argToBoolean(args.get("suppression_enabled")) if args.get("suppression_enabled") else None),
            "triggerOperator": underscoreToCamelCase(args.get("trigger_operator")),
            "triggerThreshold": args.get("trigger_threshold"),
            "tactics": argToList(args.get("tactics")),
            "techniques": argToList(args.get("techniques")),
        }
        remove_nulls_from_dictionary(properties)

        return {
            "kind": underscoreToCamelCase(args.get("kind")),
            "etag": args.get("etag"),
            "properties": properties,
        }


    def create_and_update_alert_rule_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        rule_json = json.loads(args.get("rule_json", "")) if args.get("rule_json") else None
        data = rule_json or create_data_for_alert_rule(args)
        demisto.debug(f"Try to creating/updating alert rule with the following data: {data}")

        response = client.http_request("PUT", f'alertRules/{args.get("rule_name")}', data=data)

        readable_result = {
            "ID": response.get("id").split("/")[-1],
            "Name": response.get("name"),
            "Kind": response.get("kind"),
            "Severity": response.get("properties", {}).get("severity"),
            "Display Name": response.get("properties", {}).get("displayName"),
            "Description": response.get("properties", {}).get("description"),
            "Enabled": response.get("properties", {}).get("enabled"),
            "Etag": response.get("etag"),
        }
        readable_output = tableToMarkdown(
            "Azure Sentinel Alert Rule successfully created/updated",
            readable_result,
            removeNull=True,
            sort_headers=False,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix="AzureSentinel.AlertRule",
            outputs=response,
            outputs_key_field="name",
            raw_response=response,
        )


    def main():
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        args = demisto.args()
        command = demisto.command()

        demisto.debug(f"Command being called is {command}")
        try:
            client_secret = params.get("credentials", {}).get("password")
            certificate_thumbprint = params.get("creds_certificate", {}).get("identifier") or params.get("certificate_thumbprint")
            private_key = replace_spaces_in_credential(params.get("creds_certificate", {}).get("password")) or params.get(
                "private_key"
            )
            managed_identities_client_id = get_azure_managed_identities_client_id(params)
            if not managed_identities_client_id and not client_secret and not (certificate_thumbprint and private_key):
                raise DemistoException("Key or Certificate Thumbprint and Private Key must be provided.")

            tenant_id = params.get("creds_tenant_id", {}).get("password", "") or params.get("tenant_id", "")

            if not tenant_id:
                raise ValueError("Tenant ID must be provided.")

            subscription_id = args.get("subscription_id") or params.get("subscriptionID", "")
            resource_group_name = args.get("resource_group_name") or params.get("resourceGroupName", "")

            client = AzureSentinelClient(
                azure_cloud=get_azure_cloud(params, "AzureSentinel"),
                tenant_id=tenant_id,
                client_id=params.get("credentials", {}).get("identifier"),
                client_secret=client_secret,
                subscription_id=subscription_id,
                resource_group_name=resource_group_name,
                workspace_name=params.get("workspaceName", ""),
                verify=not params.get("insecure", False),
                proxy=params.get("proxy", False),
                certificate_thumbprint=certificate_thumbprint,
                private_key=private_key,
                managed_identities_client_id=managed_identities_client_id,
            )

            commands = {
                "test-module": test_module,
                "azure-sentinel-get-incident-by-id": get_incident_by_id_command,
                "azure-sentinel-list-incidents": list_incidents_command,
                "azure-sentinel-update-incident": update_incident_command,
                "azure-sentinel-create-incident": create_incident_command,
                "azure-sentinel-delete-incident": delete_incident_command,
                "azure-sentinel-list-incident-comments": list_incident_comments_command,
                "azure-sentinel-incident-add-comment": incident_add_comment_command,
                "azure-sentinel-incident-delete-comment": incident_delete_comment_command,
                "azure-sentinel-list-incident-relations": list_incident_relations_command,
                "azure-sentinel-list-incident-entities": list_incident_entities_command,
                "azure-sentinel-list-incident-alerts": list_incident_alerts_command,
                "azure-sentinel-list-watchlists": list_watchlists_command,
                "azure-sentinel-delete-watchlist": delete_watchlist_command,
                "azure-sentinel-watchlist-create-update": create_update_watchlist_command,
                "azure-sentinel-list-watchlist-items": list_watchlist_items_command,
                "azure-sentinel-delete-watchlist-item": delete_watchlist_item_command,
                "azure-sentinel-create-update-watchlist-item": create_update_watchlist_item_command,
                "azure-sentinel-threat-indicator-list": list_threat_indicator_command,
                "azure-sentinel-threat-indicator-query": query_threat_indicators_command,
                "azure-sentinel-threat-indicator-create": create_threat_indicator_command,
                "azure-sentinel-threat-indicator-update": update_threat_indicator_command,
                "azure-sentinel-threat-indicator-delete": delete_threat_indicator_command,
                "azure-sentinel-threat-indicator-tags-append": append_tags_threat_indicator_command,
                "azure-sentinel-threat-indicator-tags-replace": replace_tags_threat_indicator_command,
                "azure-sentinel-list-alert-rule": list_alert_rule_command,
                "azure-sentinel-list-alert-rule-template": list_alert_rule_template_command,
                "azure-sentinel-delete-alert-rule": delete_alert_rule_command,
                "azure-sentinel-create-alert-rule": create_and_update_alert_rule_command,
                "azure-sentinel-update-alert-rule": create_and_update_alert_rule_command,
                # mirroring commands
                "get-modified-remote-data": get_modified_remote_data_command,
                "get-remote-data": get_remote_data_command,
                "update-remote-system": update_remote_system_command,
            }

            if command == "fetch-incidents":
                fetch_incidents_command(client, params)

            # mirroring command
            elif command == "get-mapping-fields":
                return_results(get_mapping_fields_command())
            elif command == "azure-sentinel-subscriptions-list":
                return_results(list_subscriptions_command(client))
            elif command == "azure-sentinel-resource-group-list":
                return_results(list_resource_groups_command(client, args, subscription_id))
            elif command == "azure-sentinel-auth-reset":
                return_results(reset_auth())

            elif command in commands:
                return_results(commands[command](client, args))  # type: ignore

        except Exception as e:
            return_error(f"Failed to execute {command} command. Error: {e!s}")


    if __name__ in ("__main__", "__builtin__", "builtins"):  # pragma: no cover
        main()

    register_module_line('Azure Sentinel', 'end', __line__())
  subtype: python3
  type: python
  ismappable: true
  isremotesyncin: true
  isremotesyncout: true
  nativeimage:
  - '8.8'
  - '8.6'
tests:
- TestAzureSentinelPlaybookV2
- No test - Manual test playbook-TestAzureSentinelPlaybook is available in NonCircleTests folder
fromversion: 5.0.0
defaultclassifier: Microsoft Sentinel - Classifier
defaultmapperin: Microsoft Sentinel - Incoming Mapper
defaultmapperout: Microsoft Sentinel - Outgoing Mapper
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAspQTFRFAAAAAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInXAIjWAIrWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWlY44CQAAAO50Uk5TAAwnAiyWKAAmvqUDBwRY1+NDMIALCOX+qhNz3D0SkfL/90AdwbcJG5LFSOhLAcj97luaxCREHxDb9XZg7fxcVAZ95hWbigqNM9nnUIfd0U1M1C9qtg8OeQXAX1X56Rz68SINnt5dLs/7k3uLOOu0FvhCGbolxyHiPy0aKmFiRnKEOjTwlep6v5RxNfTzMTxSwrw+OYHYycrLzM27R86Zol6wdStWAwMDaOR8kKlZr8Of0ndvrtBs9t8Uxn7VazJaTlOOjOzgf3Qe1juzpKOrgjYXV2PTGKggrCNpN4agbeGmsbmhnGV4RZ2IZ4mD701pBogAAAVxSURBVHic7Zf7WxRVGMfPOuGSw8pVjpbou6F4axjiIi7ucllog0REEFlzcRENF+OyYkKIYYp4RRQRBDMw7aJ5SUUltTTzUpaU3dSgu920+h+amTOzM7ssz1M9tP4Q31/OzDvvvp95z3nnPWcRGtSgBvUfSzWEui/cB7yG3g+s2vvBYTTl43GuZrivnz8KCAzyMHfE8GA8chT90MOjPYpVh4wZC9pH1KHj8PgwT4InTNQCTApDk6eA9lHGY1g6IJwFiHgMMZHcGBXtMXDMJAwA46ai2GncqIvzEFY1Xc/hwBBPMQn8C8CUIWpPcBOTjDwNpiWjoBThCh439eesMZkGqrfFPsEKMC03walpBPzkjH6c1ekzM2YNEDiT5AuzsxDK1pFrdk4//SsnDdjIgVmHueGEBblmZJ4nXgP7FO3OmZmP9Za8BQPBpeKtBKX3RmhovgSGcQvdeRcswiMX46cH4jsvXEJAtiI10ix1cMHyjLsaKl5cMsuLLS37FyBG4xRQnW4nIL9lCJUvl8FgfNbNr+PsKyoSIiqfI3cTqhxaidTRVWVk8UdER/MVUlA91ER7r3p+JW8z1ax+IW6N3IvVa2tFzjpuT8qsU4BhUWwfrmkJrNcs2MAWEcJGq6T8TYgOt+aSnDZvqd/KDTXBMxty8wASuMa4bTuLWWxvrJKyzokUKfYdXKz5eiXYmNkH3GTXbkbmndCcQ/Jv2dXa2rY7wwYvRiO6DZaSsMWsIZUb9tRVxun9Gl+agahlldi3fWdHLZ4jNeO9Igq/zBexaZ9FSQ6f68INK4INGoT21+NXhPJiqFdfo18PO2A7WMVl1QpvuIDrKw8tQD4mtDXDcjiZs0z2taWQSKooTBgRR8gEHDUowNZ4l/ry3m3J5YbEN+FYgWIajtefoJzAWATjtHLBEGhpzeJHn0AoEQzmTpELR5NJkKknlSmfKnQGZ+ua+cVDp7veWuMwnjnLjuFnngMnEXCTBLaeE+5Nb8M75Ml5KwhjdavULi6IuTGFixVge7pTj6JL8TBhcc83C5mT6V9vSKvg3ehdfcD6d4X76C046aKgA1oBTEdKE7tL3hNqmhXk2rXKVlGogw3vXeLkNROOq4hNveryFVKEdAtcdQEfJIeoBqwIyRsCpCLuel+O7jPdrnCLzFEkvI8rQlFg2UGMH1zDV8nhkOLApM2ukcB+Hwr3o4H96Pr1693d3R0dHdx92cdS+Chle2TO5ctg/V75QcVZdsVGonVGaBdw5YcNpeJsUWfhE1rM0BlcaDHcUC7Z8BIp/Amz0v5pigzGUSqHfUZJxGc+otrZjGreFje2WUwdqedBEdnSLoIEJiVYlgefK5bszBdS9CtfIifFjrfJ5E7ppaibeHuo5BJj1K7mTP75um2OT24RjrrFj6NuEnBNXSUBM7fxvK+IjyYRaXqkyjIcct1setvknNv2i8ZyI3ydKHmsbIRGDVq43PbNCMevsrtqO7lI1LclDnATeXJEr/MSikU1fQfq9ZVCXzvvwkXq1O8cYEMKWTiqB7pkR6oHa3vDvjfYW0oF/TAfoVs/gvZO56abJYdtLuCgJC2cutTT2X48Px79ZGdFTez7l4X6Wd4u9AFkZY7CbsVB37sWAvd0ya/3C1f1Db4stlh06XsMAvjXPAmMYtODgbVbsK67GqX2Et24McqJSatCCzNP/2aUJ/u2sPsGFcdUK9yY4pis0BiH/IXVLUu4OzGuiSnw9+c7asjoBsfHSE299/uYu6uq+jkn0iFbLwbeiWq+rPyU4fIR997upEns7wjKmBM1fc5qjDmkonjb0mMtwVZwo9nJf5/8T2SqvvDHyZYrf9rcQYUFvOf24DeoQQ3q/6q/ADbMp/aIHsXEAAAAAElFTkSuQmCC
detaileddescription: "Full documentation for this integration is available at our [reference docs](https://xsoar.pan.dev/docs/reference/integrations/azure-sentinel).\n\n#### Self-Deployed Authentication\nFollow these steps for a self-deployed configuration:\n\n1. To use a self-configured Azure application, add a new Azure App Registration in the Azure Portal. To add the registration, see the [Microsoft article](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n2. In your registered app - create a new Client secret.\n   1. Navigate in the Azure Portal to **App registrations** > your registered application > **Certificates & secrets** and click **+ New client secret**.\n   2. Copy and save the new secret value to use in the add credentials step.\n3. Assign a role to the registered app.\n   1. In Azure portal, go to the Subscriptions and select the subscription you are using -> Access control (IAM).\n   2. Click Add -> Add role assignment.\n   3. Select the Microsoft Sentinel Contributor role -> Select your registered app, and click Save.\n4. In Cortex XSOAR, go to  **Settings** > **Integrations** > **Credentials** and create a new credentials set. \n5. In the *Username* parameter, enter your registered app Application (client) ID.\n6. In the *Password* parameter, enter the secret value you created.\n7. Copy your tenant ID for the integration configuration usage.\n\n#### Azure Managed Identities Authentication\n##### Note: This option is relevant only if the integration is running on Azure VM.\nFollow one of these steps for authentication based on Azure Managed Identities:\n\n- ##### To use System Assigned Managed Identity\n   - Select the **Use Azure Managed Identities** checkbox and leave the **Azure Managed Identities Client ID** field empty.\n\n- ##### To use User Assigned Managed Identity\n   1. Go to [Azure Portal](https://portal.azure.com/) -> **Managed Identities**.\n   2. Select your User Assigned Managed Identity -> copy the Client ID -> paste it in the **Azure Managed Identities Client ID** field in the instance settings.\n   3. Select the **Use Azure Managed Identities** checkbox.\n\nFor information, see [Managed identities for Azure resources](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview).\n## Configure the Server URL\nIf you have a dedicated server URL, enter it in the *Server Url* parameter. \n\n## Get the Additional Instance Parameters\n\nTo get the *Subscription ID*, *Workspace Name*, and *Resource Group* parameters, in the Azure Portal navigate to **Azure Sentinel** > your workspace > **Settings** and click the **Workspace Settings** tab.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/azure-sentinel)"
