category: Email Gateway
commonfields:
  id: FireEye ETP
  version: -1
configuration:
- defaultvalue: https://etp.us.fireeye.com
  display: 'Server URL. Valid values: https://etp.us.fireeye.com, https://etp.eu.fireeye.com,
    https://etp.us.fireeyegov.com '
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: API key
  name: api_key
  required: true
  type: 4
- defaultvalue: "true"
  display: Trust any certificate (unsecure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: delivered (retroactive)
  display: Messages status. All messages with the status specified will be imported
    as incidents.
  name: message_status
  required: false
  type: 0
description: FireEye Email Threat Prevention (ETP Cloud) is a cloud-based platform
  that protects against advanced email attacks.
detaileddescription: |
  FireEye Email Threat Prevention (ETP Cloud) is a cloud-based platform that protects against advanced email attacks.
display: FireEye ETP
image: data:image/png;base64,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
name: FireEye ETP
script:
  commands:
  - arguments:
    - description: 'List of ''From'' email-addresses, max limit of entries is 10. '
      name: from_email
    - description: 'List of ''From'' email-addresses not to be included, max limit
        of entries is 10. '
      name: from_email_not_in
    - description: List of 'To'/'Cc' email-addresses, max limit of entries is 10.
      name: recipients
    - description: 'list of ''To''/''Cc'' email-addresses not to be included, max
        limit of entries is 10. '
      name: recipients_not_in
    - description: List of strings, max limit of entries is 10.
      name: subject
    - description: ' The time stamp of the email-accepted date to specify the beginning
        of the date range to search, e.g. 2017-10- 24T10:48:51.000Z . Specify ''to_accepted_date_time''  as
        well to set the complete date range for the search.'
      name: from_accepted_date_time
    - description: ' The time stamp of the email-accepted date to specify the end
        of the date range to search, e.g. 2017-10- 24T10:48:51.000Z . Specify ''from_accepted_date_time''  as
        well to set the complete date range for the search.'
      name: to_accepted_date_time
    - description: 'list of ETP rejection reason codes ( "ETP102", "ETP103", "ETP104",
        "ETP200", "ETP201", "ETP203", "ETP204", "ETP205", "ETP300", "ETP301", "ETP302",
        "ETP401", "ETP402", "ETP403", "ETP404", "ETP405") '
      name: rejection_reason
    - description: List of sender IP addresses, max limit of entries is 10.
      name: sender_ip
    - description: List of email status values( "accepted", "deleted", "delivered",
        "delivered (retroactive)", "dropped", "dropped oob", "dropped (oob retroactive)",
        "permanent failure", "processing", "quarantined", "rejected", "temporary failure").
      name: status
    - description: List of email status values not to include( "accepted", "deleted",
        "delivered", "delivered (retroactive)", "dropped", "dropped oob", "dropped
        (oob retroactive)", "permanent failure", "processing", "quarantined", "rejected",
        "temporary failure").
      name: status_not_in
    - description: 'Date corresponding to last modified date, along with one of the
        following operators: ">", "<", ">=", "<=".  E.g. use value "<2017-10-24T18:00:00.000Z"
        to search for messages that were last modified after the specified time stamp.'
      name: last_modified_date_time
    - description: List of domain names.
      name: domain
    - auto: PREDEFINED
      description: Boolean value to indicate if the message has attachments.
      name: has_attachments
      predefined:
      - "true"
      - "false"
    - description: The default value is 20kb and maximum value is 100kb.
      name: max_message_size
    description: Search for messages that include specified message attributes that
      are accessible in he ETP portal.
    name: fireeye-etp-search-messages
    outputs:
    - contextPath: FireEyeETP.Message.acceptedDateTime
      description: Message accepted date.
    - contextPath: FireEyeETP.Message.countryCode
      description: Sender country code.
    - contextPath: FireEyeETP.Message.domain
      description: Domain.
    - contextPath: FireEyeETP.Message.emailSize
      description: Email size in kb.
    - contextPath: FireEyeETP.Message.lastModifiedDateTime
      description: Message last modified date.
    - contextPath: FireEyeETP.Message.recipientHeader
      description: List of message recipients header (includes the display name of
        the user).
    - contextPath: FireEyeETP.Message.recipients
      description: List of message recipients.
    - contextPath: FireEyeETP.Message.senderHeader
      description: Message sender header (includes the display name of the user).
    - contextPath: FireEyeETP.Message.sender
      description: Message sender address.
    - contextPath: FireEyeETP.Message.senderSMTP
      description: Message sender SMTP.
    - contextPath: FireEyeETP.Message.senderIP
      description: Message sender IP.
    - contextPath: FireEyeETP.Message.status
      description: Message status.
    - contextPath: FireEyeETP.Message.subject
      description: Message subject
    - contextPath: FireEyeETP.Message.verdicts.AS
      description: pass/fail verdict for AS.
    - contextPath: FireEyeETP.Message.verdicts.AV
      description: pass/fail verdict for AV
    - contextPath: FireEyeETP.Message.verdicts.AT
      description: pass/fail verdict for AT
    - contextPath: FireEyeETP.Message.verdicts.PV
      description: pass/fail verdict for PV
    - contextPath: FireEyeETP.Message.id
      description: Message ID.
  - arguments:
    - description: The message ID.
      name: message_id
      required: true
    description: Get the data of a specific message.
    name: fireeye-etp-get-message
    outputs:
    - contextPath: FireEyeETP.Message.acceptedDateTime
      description: Message accepted date.
    - contextPath: FireEyeETP.Message.countryCode
      description: Sender country code.
    - contextPath: FireEyeETP.Message.domain
      description: Domain.
    - contextPath: FireEyeETP.Message.emailSize
      description: Email size in kb.
    - contextPath: FireEyeETP.Message.lastModifiedDateTime
      description: Message last modified date.
    - contextPath: FireEyeETP.Message.recipientHeader
      description: List of message recipients header (includes the display name of
        the user).
    - contextPath: FireEyeETP.Message.recipients
      description: List of message recipients.
    - contextPath: FireEyeETP.Message.senderHeader
      description: Message sender header (includes the display name of the user).
    - contextPath: FireEyeETP.Message.sender
      description: Message sender address.
    - contextPath: FireEyeETP.Message.senderSMTP
      description: Message sender SMTP.
    - contextPath: FireEyeETP.Message.senderIP
      description: Message sender IP.
    - contextPath: FireEyeETP.Message.status
      description: Message status.
    - contextPath: FireEyeETP.Message.subject
      description: Message subject
    - contextPath: FireEyeETP.Message.verdicts.AS
      description: pass/fail verdict for AS.
    - contextPath: FireEyeETP.Message.verdicts.AV
      description: pass/fail verdict for AV
    - contextPath: FireEyeETP.Message.verdicts.AT
      description: pass/fail verdict for AT
    - contextPath: FireEyeETP.Message.verdicts.PV
      description: pass/fail verdict for PV
    - contextPath: FireEyeETP.Message.id
      description: Message ID.
  - arguments:
    - description: Alert ID as shown in ETP Web Portal.
      name: legacy_id
    - description: Datetime in yyy-mm-ddThh:mm:ss.fff format. Default last 90 days.
      name: from_last_modified_on
    - description: Email message id.
      name: etp_message_id
    - description: Number of alerts intended in response. Default 20. Valid range
        1-100 .
      name: size
    description: Get summary format information about the alerts.
    name: fireeye-etp-get-alerts
    outputs:
    - contextPath: FireEyeETP.Alerts.meta.read
      description: Email read flag.
    - contextPath: FireEyeETP.Alerts.meta.last_modified_on
      description: Last modified timestamp.
    - contextPath: FireEyeETP.Alerts.meta.legacy_id
      description: 'Alert ID as shown in ETP Web Portal '
    - contextPath: FireEyeETP.Alerts.alert.product
      description: Product alerted
    - contextPath: FireEyeETP.Alerts.alert.timestamp
      description: Alert timestamp
    - contextPath: FireEyeETP.Alerts.alert.malware_md5
      description: md5 of file attached
    - contextPath: FireEyeETP.Alerts.email.status
      description: The email status.
    - contextPath: FireEyeETP.Alerts.email.source_ip
      description: Email source IP.
    - contextPath: FireEyeETP.Alerts.email.smtp.rcpt_to
      description: Recipient SMTP.
    - contextPath: FireEyeETP.Alerts.email.smtp.mail_from
      description: Sender SMTP.
    - contextPath: FireEyeETP.Alerts.email.etp_message_id
      description: The message ID.
    - contextPath: FireEyeETP.Alerts.email.headers.cc
      description: Email 'cc' recipients.
    - contextPath: FireEyeETP.Alerts.email.headers.to
      description: Email recipients.
    - contextPath: FireEyeETP.Alerts.email.headers.from
      description: Email sender.
    - contextPath: FireEyeETP.Alerts.email.headers.subject
      description: Email subject.
    - contextPath: FireEyeETP.Alerts.email.attachment
      description: File name or URL pointing to file.
    - contextPath: FireEyeETP.Alerts.email.timestamp.accepted
      description: Email accepted time.
    - contextPath: FireEyeETP.Alerts.id
      description: The alert ID.
  - arguments:
    - description: The alert ID.
      name: alert_id
      required: true
    description: Detailed information from any particular alert. Alerts more than
      90 days old are not available.
    name: fireeye-etp-get-alert
    outputs:
    - contextPath: FireEyeETP.Alerts.meta.read
      description: Email read flag.
    - contextPath: FireEyeETP.Alerts.meta.last_modified_on
      description: Last modified timestamp.
    - contextPath: FireEyeETP.Alerts.meta.legacy_id
      description: 'Alert ID as shown in ETP Web Portal '
    - contextPath: FireEyeETP.Alerts.meta.acknowledged
      description: Acknowledged
    - contextPath: FireEyeETP.Alerts.alert.product
      description: Product generate the alert.
    - contextPath: FireEyeETP.Alerts.alert.alert_type
      description: Alert type code.
    - contextPath: FireEyeETP.Alerts.alert.severity
      description: Severity code.
    - contextPath: FireEyeETP.Alerts.alert.explanation.analysis
      description: Analysis
    - contextPath: FireEyeETP.Alerts.alert.explanation.anomaly
      description: Anomaly
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.domain
      description: Malware domain
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.downloaded_at
      description: Malware downloaded at timestamp
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.executed_at
      description: Malware executed at timestamp
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.name
      description: Malware name
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.sid
      description: Malware sid
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.stype
      description: Malware type
    - contextPath: FireEyeETP.Alerts.alert.explanation.malware_detected.malware.submitted_at
      description: Malware submitted at
    - contextPath: FireEyeETP.Alerts.alert.explanation.protocol
      description: Protocol
    - contextPath: FireEyeETP.Alerts.alert.explanation.timestamp
      description: Explanation timestamp
    - contextPath: FireEyeETP.Alerts.alert.timestamp
      description: Alert timestamp.
    - contextPath: FireEyeETP.Alerts.alert.action
      description: Alert acrion
    - contextPath: FireEyeETP.Alerts.alert.name
      description: Alert name.
    - contextPath: FireEyeETP.Alerts.email.status
      description: The email status.
    - contextPath: FireEyeETP.Alerts.email.source_ip
      description: Email source IP.
    - contextPath: FireEyeETP.Alerts.email.smtp.rcpt_to
      description: Recipient SMTP.
    - contextPath: FireEyeETP.Alerts.email.smtp.mail_from
      description: Sender SMTP.
    - contextPath: FireEyeETP.Alerts.email.etp_message_id
      description: FE ETP unique message ID.
    - contextPath: FireEyeETP.Alerts.email.headers.cc
      description: Email cc recipients.
    - contextPath: FireEyeETP.Alerts.email.headers.to
      description: Email recipients.
    - contextPath: FireEyeETP.Alerts.email.headers.from
      description: 'Email sender '
    - contextPath: FireEyeETP.Alerts.email.headers.subject
      description: Email subject
    - contextPath: FireEyeETP.Alerts.email.attachment
      description: File name or URL pointing to file
    - contextPath: FireEyeETP.Alerts.email.timestamp.accepted
      description: Email eccepted time
    - contextPath: FireEyeETP.Alerts.id
      description: The alert unique ID
  isfetch: true
  runonce: false
  script: |2-





    '''
    IMPORTS
    '''

    from datetime import timedelta, datetime
    import requests
    import os
    import re
    import copy
    import json
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()


    '''
    GLOBAL VARS
    '''

    API_KEY = demisto.params().get('api_key')
    BASE_PATH = '{}/api/v1'.format(demisto.params().get('server'))
    HTTP_HEADERS = {
        'Content-Type': 'application/json'
    }
    USE_SSL = not demisto.params().get('unsecure')
    MESSAGE_STATUS = demisto.params().get('message_status')


    '''
    SEARCH ATTRIBUTES VALID VALUES
    '''

    REJECTION_REASONS = ['ETP102', 'ETP103', 'ETP104', 'ETP200', 'ETP201', 'ETP203', 'ETP204', 'ETP205',
                         'ETP300', 'ETP301', 'ETP302', 'ETP401', 'ETP402', 'ETP403', 'ETP404', 'ETP405']

    STATUS_VALUES = ["accepted", "deleted", "delivered", "delivered (retroactive)", "dropped",
                     "dropped oob", "dropped (oob retroactive)", "permanent failure", "processing",
                     "quarantined", "rejected", "temporary failure"]


    '''
    BASIC FUNCTIONS
    '''


    def set_proxies():

        if not demisto.params().get('proxy', False):
            del os.environ['HTTP_PROXY']
            del os.environ['HTTPS_PROXY']
            del os.environ['http_proxy']
            del os.environ['https_proxy']


    def listify(comma_separated_list):

        if isinstance(comma_separated_list, list):
            return comma_separated_list
        return comma_separated_list.split(',')


    def http_request(method, url, body=None, headers={}, url_params=None):

        '''
        returns the http response
        '''

        # add API key to headers
        headers['x-fireeye-api-key'] = API_KEY

        request_kwargs = {
            'headers': headers,
            'verify': USE_SSL
        }

        # add optional arguments if specified
        if body is not None:
            request_kwargs['data'] = json.dumps(body)
        if url_params is not None:
            request_kwargs['params'] = json.dumps(url_params)

        LOG('attempting {} request sent to {} with body:\n{}'.format(method, url, json.dumps(body, indent=4)))
        response = requests.request(
            method,
            url,
            **request_kwargs
        )
        # handle request failure
        if response.status_code not in range(200, 205):
            raise ValueError('Request failed with status code {}\n{}'.format(response.status_code, response.text))
        return response.json()


    def return_error_entry(message):

        entry = {
            'Type': entryTypes['error'],
            'Contents': message,
            'ContentsFormat': formats['text'],
        }
        demisto.results(entry)


    def to_search_attribute_object(value, filter=None, is_list=False, valid_values=None):

        values = listify(value) if is_list else value
        if valid_values:
            for val in values:
                if val not in valid_values:
                    raise ValueError('{} is not a valid value'.format(val))

        attribute = {
            'value': values
        }
        if filter:
            attribute['filter'] = filter
        return attribute


    def format_search_attributes(from_email=None, from_email_not_in=None, recipients=None,
                                 recipients_not_in=None, subject=None, from_accepted_date_time=None,
                                 to_accepted_date_time=None, rejection_reason=None, sender_ip=None, status=None,
                                 status_not_in=None, last_modified_date_time=None, domains=None):

        search_attributes = {}  # type: Dict

        # handle from_email attribute
        if from_email and from_email_not_in:
            raise ValueError('Only one of the followings can be specified: from_email, from_email_not_in')
        if from_email:
            search_attributes['fromEmail'] = to_search_attribute_object(from_email, filter='in', is_list=True)
        elif from_email_not_in:
            search_attributes['fromEmail'] = to_search_attribute_object(from_email_not_in, filter='not in', is_list=True)

        # handle recipients attributes
        if recipients and recipients_not_in:
            raise ValueError('Only one of the followings can be specified: recipients, recipients_not_in')
        if recipients:
            search_attributes['recipients'] = to_search_attribute_object(recipients, filter='in', is_list=True)
        elif recipients_not_in:
            search_attributes['recipients'] = to_search_attribute_object(recipients_not_in, filter='not in', is_list=True)

        # handle status attributes
        if status and status_not_in:
            raise ValueError('Only one of the followings can be specified: status, status_not_in')
        if status:
            search_attributes['status'] = to_search_attribute_object(status, filter='in', is_list=True, valid_values=STATUS_VALUES)
        elif status_not_in:
            search_attributes['status'] = to_search_attribute_object(status, filter='in', is_list=True, valid_values=STATUS_VALUES)

        if subject:
            search_attributes['subject'] = to_search_attribute_object(subject, filter='in', is_list=True)
        if rejection_reason:
            search_attributes['rejectionReason'] = to_search_attribute_object(rejection_reason, is_list=True,
                                                                              valid_values=REJECTION_REASONS)
        if sender_ip:
            search_attributes['senderIP'] = to_search_attribute_object(sender_ip, filter='in', is_list=True)
        if domains:
            search_attributes['domains'] = to_search_attribute_object(domains, is_list=True)
        if from_accepted_date_time and to_accepted_date_time:
            search_attributes['period'] = {
                'range': {
                    'fromAcceptedDateTime': from_accepted_date_time,
                    'toAcceptedDateTime': to_accepted_date_time
                }
            }
        if last_modified_date_time:
            # try to parse '>timestamp' | '>=timestamp' | '<timestamp' | '<=timestamp'
            operator_ends_at = 0 if last_modified_date_time.find('=') == 1 else 1
            search_attributes["lastModifiedDateTime"] = {
                'value': last_modified_date_time[operator_ends_at:],
                'filter': last_modified_date_time[:operator_ends_at]
            }
        return search_attributes


    def readable_message_data(message):

        return {
            'Message ID': message['id'],
            'Accepted Time': message['acceptedDateTime'],
            'From': message['from'],
            'Recipients': message.get('recipients'),
            'Subject': message['subject'],
            'Message Status': message['status']
        }


    def message_context_data(message):

        context_data = copy.deepcopy(message)

        # remove 'attributes' level
        context_data.update(context_data.pop('attributes', {}))

        # parse email sddresses
        match = re.search('<(.*)>', context_data['senderHeader'].replace('\\"', ''))
        context_data['from'] = match.group() if match else context_data['senderHeader']

        if context_data.get('recipientHeader') is None:
            context_data['recipients'] = []
            return context_data

        recipients = []
        for recipient_header in context_data.get('recipientHeader', []):
            match = re.search('<(.*)>', recipient_header)
            recipient_address = match.group() if match else recipient_header
            recipients.append(recipient_address)
        context_data['recipients'] = ','.join(recipients)

        return context_data


    def search_messages_request(attributes={}, has_attachments=None, max_message_size=None):

        url = '{}/messages/trace'.format(BASE_PATH)
        body = {
            'attributes': attributes,
            'type': 'MessageAttributes',
            'size': max_message_size or 20
        }
        if has_attachments is not None:
            body['hasAttachments'] = has_attachments
        response = http_request(
            'POST',
            url,
            body=body,
            headers=HTTP_HEADERS
        )
        # no results
        if response['meta']['total'] == 0:
            return []
        return response['data']


    def search_messages_command():

        args = demisto.args()
        if 'size' in args.keys():
            # parse to int
            args['size'] = int(args['size'])
        if args.get('has_attachments') is not None:
            # parse to boolean
            args['hasAttachments'] = args['hasAttachments'] == 'true'

        search_attributes = format_search_attributes(
            from_email=args.get('from_email'),
            from_email_not_in=args.get('from_email_not_in'),
            recipients=args.get('recipients'),
            recipients_not_in=args.get('recipients_not_in'),
            subject=args.get('subject'),
            from_accepted_date_time=args.get('from_accepted_date_time'),
            to_accepted_date_time=args.get('to_accepted_date_time'),
            rejection_reason=args.get('rejection_reason'),
            sender_ip=args.get('sender_ip'),
            status=args.get('status'),
            status_not_in=args.get('status_not_in'),
            last_modified_date_time=args.get('last_modified_date_time'),
            domains=args.get('domains')
        )

        # raw data
        messages_raw = search_messages_request(search_attributes, args.get('hasAttachments'), args.get('size'))

        # create context data
        messages_context = [message_context_data(message) for message in messages_raw]

        # create readable data
        messages_readable_data = [readable_message_data(message) for message in messages_context]
        messages_md_headers = [
            'Message ID',
            'Accepted Time',
            'From',
            'Recipients',
            'Subject',
            'Message Status'
        ]
        md_table = tableToMarkdown(
            'FireEye ETP - Search Messages',
            messages_readable_data,
            headers=messages_md_headers
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': messages_raw,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeETP.Messages(obj.id==val.id)": messages_context
            }
        }
        demisto.results(entry)


    def get_message_request(message_id):

        url = '{}/messages/{}'.format(BASE_PATH, message_id)
        response = http_request(
            'GET',
            url
        )
        if response['meta']['total'] == 0:
            return {}
        return response['data'][0]


    def get_message_command():

        # get raw data
        raw_message = get_message_request(demisto.args()['message_id'])

        if raw_message:
            # create context data
            context_data = message_context_data(raw_message)

            # create readable data
            message_readable_data = readable_message_data(context_data)
            messages_md_headers = [
                'Message ID',
                'Accepted Time',
                'From',
                'Recipients',
                'Subject',
                'Message Status'
            ]
            md_table = tableToMarkdown(
                'FireEye ETP - Get Message',
                message_readable_data,
                headers=messages_md_headers
            )

            entry = {
                'Type': entryTypes['note'],
                'Contents': raw_message,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': md_table,
                'EntryContext': {
                    "FireEyeETP.Messages(obj.id==val.id)": context_data
                }
            }
            demisto.results(entry)
        # no results
        else:
            entry = {
                'Type': entryTypes['note'],
                'Contents': {},
                'ContentsFormat': formats['text'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': '### FireEye ETP - Get Message \n no results'
            }
            demisto.results(entry)


    def alert_readable_data_summery(alert):

        return {
            'Alert ID': alert['id'],
            'Alert Timestamp': alert['alert']['timestamp'],
            'From': alert['email']['headers']['from'],
            'Recipients': '{}|{}'.format(alert['email']['headers']['to'], alert['email']['headers']['cc']),
            'Subject': alert['email']['headers']['subject'],
            'MD5': alert['alert'].get('malware_md5'),
            'URL/Attachment': alert['email']['attachment'],
            'Email Status': alert['email']['status'],
            'Email Accepted': alert['email']['timestamp']['accepted'],
            'Threat Intel': alert['ati']
        }


    def alert_readable_data(alert):

        return {
            'Alert ID': alert['id'],
            'Alert Timestamp': alert['alert']['timestamp'],
            'From': alert['email']['headers']['from'],
            'Recipients': '{}|{}'.format(alert['email']['headers']['to'], alert['email']['headers']['cc']),
            'Subject': alert['email']['headers']['subject'],
            'MD5': alert['alert'].get('malware_md5'),
            'URL/Attachment': alert['email']['attachment'],
            'Email Status': alert['email']['status'],
            'Email Accepted': alert['email']['timestamp']['accepted'],
            'Sevirity': alert['alert']['severity']
        }


    def malware_readable_data(malware):

        return {
            'Name': malware['name'],
            'Domain': malware.get('domain'),
            'Downloaded At': malware['downloaded_at'],
            'Executed At': malware['executed_at'],
            'Type': malware['stype'],
            'Submitted At': malware['submitted_at'],
            'SID': malware['sid']
        }


    def alert_context_data(alert):

        context_data = copy.deepcopy(alert)
        # remove 'attributes' level
        context_data.update(context_data.pop('attributes', {}))
        return context_data


    def get_alerts_request(legacy_id=None, from_last_modified_on=None, etp_message_id=None, size=None, raw_response=False):

        url = '{}/alerts'.format(BASE_PATH)

        # constract the body for the request
        body = {}
        attributes = {}
        if legacy_id:
            attributes['legacy_id'] = legacy_id
        if etp_message_id:
            attributes['etp_message_id'] = etp_message_id
        if attributes:
            body['attribute'] = attributes
        if size:
            body['size'] = size
        if from_last_modified_on:
            body['fromLastModifiedOn'] = from_last_modified_on

        response = http_request(
            'POST',
            url,
            body=body,
            headers=HTTP_HEADERS
        )
        if raw_response:
            return response
        if response['meta']['total'] == 0:
            return []
        return response['data']


    def get_alerts_command():

        args = demisto.args()

        if 'size' in args.keys():
            args['size'] = int(args['size'])

        if 'legacy_id' in args.keys():
            args['legacy_id'] = int(args['legacy_id'])

        # get raw data
        alerts_raw = get_alerts_request(
            legacy_id=args.get('legacy_id'),
            from_last_modified_on=args.get('from_last_modified_on'),
            etp_message_id=args.get('etp_message_id'),
            size=args.get('size')
        )

        # create context data
        alerts_context = [alert_context_data(alert) for alert in alerts_raw]

        # create readable data
        alerts_readable_data = [alert_readable_data_summery(alert) for alert in alerts_context]
        alerts_summery_headers = [
            'Alert ID',
            'Alert Timestamp',
            'Email Accepted',
            'From',
            'Recipients',
            'Subject',
            'MD5',
            'URL/Attachment',
            'Email Status',
            'Threat Intel'
        ]
        md_table = tableToMarkdown(
            'FireEye ETP - Get Alerts',
            alerts_readable_data,
            headers=alerts_summery_headers
        )
        entry = {
            'Type': entryTypes['note'],
            'Contents': alerts_raw,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeETP.Alerts(obj.id==val.id)": alerts_context
            }
        }
        demisto.results(entry)


    def get_alert_request(alert_id):

        url = '{}/alerts/{}'.format(BASE_PATH, alert_id)
        response = http_request(
            'GET',
            url
        )
        if response['meta']['total'] == 0:
            return {}
        return response['data'][0]


    def get_alert_command():

        # get raw data
        alert_raw = get_alert_request(demisto.args()['alert_id'])

        if alert_raw:
            # create context data
            alert_context = alert_context_data(alert_raw)

            # create readable data
            readable_data = alert_readable_data(alert_context)
            alert_md_table = tableToMarkdown(
                'Alert Details',
                readable_data
            )
            data = alert_context['alert']['explanation']['malware_detected']['malware']
            malware_data = [malware_readable_data(malware) for malware in data]
            malware_md_table = tableToMarkdown(
                'Malware Details',
                malware_data
            )

            entry = {
                'Type': entryTypes['note'],
                'Contents': alert_raw,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': '## FireEye ETP - Get Alert\n{}\n{}'.format(alert_md_table, malware_md_table),
                'EntryContext': {
                    "FireEyeETP.Alerts(obj.id==val.id)": alert_context
                }
            }
            demisto.results(entry)
        # no results
        else:
            entry = {
                'Type': entryTypes['note'],
                'Contents': {},
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': '### FireEye ETP - Get Alert\nno results',

            }
            demisto.results(entry)


    def parse_string_in_iso_format_to_datetime(iso_format_string):

        alert_last_modified = None
        try:
            alert_last_modified = datetime.strptime(iso_format_string, "%Y-%m-%dT%H:%M:%S.%f")
        except ValueError:
            try:
                alert_last_modified = datetime.strptime(iso_format_string, "%Y-%m-%dT%H:%M:%S")
            except ValueError:
                alert_last_modified = datetime.strptime(iso_format_string, "%Y-%m-%dT%H:%M")
        return alert_last_modified


    def parse_alert_to_incident(alert):

        context_data = alert_context_data(alert)
        incident = {
            'name': context_data['email']['headers']['subject'],
            'rawJSON': json.dumps(context_data)
        }
        return incident


    def fetch_incidents():

        last_run = demisto.getLastRun()
        week_ago = datetime.now() - timedelta(days=7)
        iso_format = "%Y-%m-%dT%H:%M:%S.%f"

        if 'last_modified' not in last_run.keys():
            # parse datetime to iso format string yyy-mm-ddThh:mm:ss.fff
            last_run['last_modified'] = week_ago.strftime(iso_format)[:-3]
        if 'last_created' not in last_run.keys():
            last_run['last_created'] = week_ago.strftime(iso_format)

        alerts_raw_response = get_alerts_request(
            from_last_modified_on=last_run['last_modified'],
            size=100,
            raw_response=True
        )
        # end if no results returned
        if not alerts_raw_response or 'data' not in alerts_raw_response.keys():
            return

        alerts = alerts_raw_response['data']
        last_alert_created = parse_string_in_iso_format_to_datetime(last_run['last_created'])
        alert_creation_limit = parse_string_in_iso_format_to_datetime(last_run['last_created'])
        incidents = []

        for alert in alerts:
            # filter by message status if specified
            if MESSAGE_STATUS and alert['attributes']['email']['status'] != MESSAGE_STATUS:
                continue
            # filter alerts created before 'last_created'
            current_alert_created = parse_string_in_iso_format_to_datetime(alert['attributes']['alert']['timestamp'])
            if current_alert_created < alert_creation_limit:
                continue
            # append alert to incident
            incidents.append(parse_alert_to_incident(alert))
            # set last created
            if current_alert_created > last_alert_created:
                last_alert_created = current_alert_created

        last_run['last_modified'] = alerts_raw_response['meta']['fromLastModifiedOn']['end']
        last_run['last_created'] = last_alert_created.strftime(iso_format)

        demisto.incidents(incidents)
        demisto.setLastRun(last_run)


    '''
    EXECUTION
    '''

    set_proxies()

    try:
        if demisto.command() == 'test-module':
            alerts = get_alerts_request(size=1)
            # request was succesful
            demisto.results('ok')
        if demisto.command() == 'fetch-incidents':
            fetch_incidents()
        if demisto.command() == 'fireeye-etp-search-messages':
            search_messages_command()
        if demisto.command() == 'fireeye-etp-get-message':
            get_message_command()
        if demisto.command() == 'fireeye-etp-get-alerts':
            get_alerts_command()
        if demisto.command() == 'fireeye-etp-get-alert':
            get_alert_command()
    except ValueError as e:
        LOG(e)
        LOG.print_log()
        return_error_entry(e)
  type: python
system: true
