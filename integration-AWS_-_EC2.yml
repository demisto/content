category: IT Services
commonfields:
  id: AWS - EC2
  version: -1
configuration:
- defaultvalue: ""
  display: AWS Default Region
  name: defaultRegion
  options:
  - us-east-1
  - us-east-2
  - us-west-1
  - us-west-2
  - ca-central-1
  - eu-west-1
  - eu-central-1
  - eu-west-2
  - ap-northeast-1
  - ap-northeast-2
  - ap-southeast-1
  - ap-southeast-2
  - ap-south-1
  - sa-east-1
  - eu-north-1
  - eu-west-3
  required: false
  type: 15
- defaultvalue: ""
  display: Role Arn
  name: roleArn
  required: false
  type: 0
- defaultvalue: ""
  display: Role Session Name
  name: roleSessionName
  required: false
  type: 0
- defaultvalue: ""
  display: Role Session Duration
  name: sessionDuration
  required: false
  type: 0
- defaultvalue: ""
  display: Access Key
  name: access_key
  required: false
  type: 0
- defaultvalue: ""
  display: Secret Key
  name: secret_key
  required: false
  type: 4
- defaultvalue: ""
  display: Use System Proxy
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Trust any certificate (Not Secure)
  name: insecure
  required: false
  type: 8
description: Amazon Web Services Elastic Compute Cloud (EC2)
detaileddescription: "Before you can use AWS EC2, you need to perform several configuration
  steps in your AWS environment.\n\n### Prerequisites\n- Attach an instance profile
  with the required permissions to the Demisto server or engine that is running \non
  your AWS environment.\n- Instance profile requires minimum permission: sts:AssumeRole.\n-
  Instance profile requires permission to assume the roles needed by the AWS integrations.\n\n###
  Configure AWS Settings\n- Create an IAM Role for the Instance Profile.\n- Attach
  a Role to the Instance Profile.\n- Configure the Necessary IAM Roles that the AWS
  Integration Can Assume.\n\nFor detailed instructions, [see the AWS Integrations
  Configuration Guide](https://support.demisto.com/hc/en-us/articles/360005686854-AWS-Integrations-Configuration-Guide).\n"
display: AWS - EC2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAG/dJREFUeAHtXAecFNX9/03dvQKI9Ct7u1dFQFAURYooFvT/J0EF68fE2NAUe/4xdkVj7xhRg1E0xQpqpMhfBVFJ6FLEa9ztNbijSLmyOzNvXr6/2dvl7jhUwiW5S3h3uzPz5rX5fd+vvjerSCTqgOSiDYW4KYk/lQ+kSJcUVfHudEAX36sJBel7FfwvKQQkOiZxQwr+CODW15WRE9lKQo3lemh3TDeHWjlACugHVp65Mw4kzuO8D6YRjkU1G5bSVwteo8bSJXTy6DHkH3QG0cDxpCf1bK7HUIOrMQliLUnv/MDGcKj0gVBAORARzaBIiF3mSxegKhJAKYIav9lOCx+5krasmk8yYtGAjD50+og80pwmihw+kIwjzyLfkaeRntqXBOoyvDFRzlB3rEQ9JKJbw3+AHIzKnoqLwSKAjU4a2Y27aMf6hWQwbH4f8gS5WgrAM8m/s4Tkkscosu5t0gb+gAzm6h4DPD6O6ezWAzp01bEU2A/AzKtxzooJVY0NJgW8i+OW4tW0fe1HFDzyKKKCk0jVAa2RRGTvYcYkVzVIdQU+DvSwD4ZWMqn1teQu/S01bniTlCMmkDl4Ihk9g97TxCU9X8R79W4c+jpoCuwHYG6X7WIkVrSguoOvypULae27M2nLiveob08fBauHkLX2HbL6DoqV5eLN4pc5XaJezPBCbUwOxQDYjXtIWzaLnHUfknPEqWQOOYvUPnkesAr69PR6ot4huBOE/QdP2gWYOSpGWhW6FlA7EdJ1P61/5xnasuh9olSTkswkj3OV2vUkS5eRGm0gweI7YXm1PyJFhfg2AbS9neSXs8jaOJeU3LGkDTuXtH4AWtHQN0bA8+p74Ou6LlVVVdGO7dtJNwxKS0vrXVNTs61N72pGRobP7/e7JSUlUX68UCgUUKJRuammpqJF2W6ZmZl90ebO6urq7S3yE6e5ubndI5FIlq7rKcjciWNZc5uJMsFg0J9SXt4ubaO5uXbb8qjYHf32EULYGHs1rtlUSaRx0IQlGRlGjx49xIYNGyzcMAKBQCbGGcWzc/n9pnYHoYC4AkDVlfyNvpr/OqWp2yh77CTo1CaiZDasYiPgcroKnjV03BP4Y/MLEwLi2UvtASQ1YIfyikPsRblOPbkb5pAo/IhE9mhSh51DRvpggNvu0GLtNn8vmD+fXn5xJm38eiNFoxFvbnXz+dfmZ4VmR6S4vaKi4hsumpsRvMM0tUscRzQE0gM3+nX1JkiW0a7PL/NDoQWWlFeZrvtDqJrbYXSmAf+ducHg70rKy6ehuuN1V1DQLTtq3yZd93yfYQYMVVWZwCREYXZG1sObqsJ/4HLDabixk7bPdkI5A1mdeUkypdCqIhVFiLU4nYQP30zNDgZvRVMXgFRpim5YecGcDZbjPBKuCr+D+5yUcDD4WpKqHdtU31SYlZZ1v8+nPoEWB5GmW3jWv1iKvLa8vHxnrHjr7wQVXc/sabZpwTrr582iL568mlzLorRRQ4gWl5FSuZE0jQUp/oAOW9JS6l7NuM5mkSwdMInARAP4iYdM9MtukoU6XF/HOa51H8ohr2g+OZs+oabQOEoaAh0dGAb9baIZtNOGnefPm0c3/OJamHhIGEswmE08+R3LGqBo6k/JhoVHdKXXrULZiqrl8MzzGdpLhm4E2BuAC4GJpk6RluiPBxulqRq6At2lTNZU/c5gMLgRhPsz2tBzLWumqRtT+Hkc190ihNugqUoO6h9FhjIrmJFRXV5VtWhX7i7MdSVH07Qs5gS3WaKpGD+rKSkcGCoEdAaZkayGWT7dPLu5za0YT4quqSdAir2Jvq9A37/nspqi5ZsYvy2d7rqhvmZqRsjFONB2im7ol7iOU4Zid3HZtinGcqCfir/GPXW0du5LtGv1bGqoXg/usshMMjwAVM1A3ZiGZWIrLksKnoQgEhOlVWIQ0Wi7idnamwbNZWLXQBIiP4UMV5KvZC65s2+khjl3UHTT55Amrdvn4Nurr7yCB8eE1DSaMfN39N68D+ipZ6eTcF0wJPpX6LR+/fqxGOWmHc+9U1XIf0WxI9FfCEd4HMcAGKY2BoP52IrY17qOWM2VOWlSGcVHcM0Q9DSFc23HWSSalKFNjjXEEeL3fF8HC0JUT+BziF9LWPI8K2Kd3GRFxzq2+3OMN8r9CEg2yxZPopjbmLHnPJ+ux8B13LmisWFw1JajhONu4fZMRX0QIPdHWTijrjd+5PdBZNCJWpGrbeG8x+wYe1Z5MvfdXvI4mEVu+ZrFtOSpn5GzvZhyxh1DauUOMnWd4UM9fjT+cGLoABD0MqZjLKtDvnnywOrWMGyZgnOXjPKFZH8TJvPiwUT+HoleOBp597RpVLt5C/nglh03YgQ5jkM5Obl4YMkc0gvTK6mboiTXEjXEKzIXRS33kbKq8PScfv3e0JOSzwKn9QRH7nai0ctZH0Pc7vDr2mteHSlZClBERIp01z9Kc0VPiNg1pbXldSC+H9NuXbxtkCI+QFleXb6G86Gvfapwf6OpcCWQopbzPPqeyeeGpl/IRzwoWa79YnltbR2u6vKzgp+A3S4EmH2lcHnSvIxPLGGSWMK5qayi4n3o4CWq4p6JSW6AlbuhAAuzfQDxAGbothWuoIaiDZSS1oNcuDyKbIAYxiNgAAIiV6HUWCetvnGzA5M3jUApT/SzTGHxrLXm3nh3eXl5lJyUTH95/32aMf1ZCofDtGPHN8yghwPleLF9joYiKzlTpqSAq6gBVOmJ0ruMmhpPX+MahkZzahZYtbW1DZgoX2SnB8ZDvN8KvX0sdGAGOuvFnMkTp72k2mK6rmuj+R44/696Zfkv+RwGXxKq5PG54wr0IjfzOSdXUStiZzh3aJh33vw4mIgRxXW/5jzd0esBKRuMBis5+DHahv0B7FVgbsV8hThg/sQfn6kQU2jdtVEE41Dgxnj3cAW5F+Pq/ROT2z3QxBKDTRImWYy+OGMR0yYt/PBDuv2WX1PDnnqv3CiERk8Y2Zfeev2NJjSR3Kb43ksZawwGEux1byUExUkWNpdQVRgVbdKgQYNMq77hOXDdZQr0vSOcCkHy/2FlZUJFnNymuHeZkxG6Cir9Cr4AMHWWJS8LE3n6119VZbjBkJ9ZjhMmSGIWwx5j3eclDLB7/JyPoIJwVLghSJBUuMT/d6R9HuY7yneK2zt37qT7751GDbt3kw6Xa/rzz9HoMWOovr6e3nzjjUY8OAMsoco6ZPY17G4412/ql/HD2479acQVk9hCz83IukLXlZM5nycJHzmBQ0dohvIoczZsgoi0xTXhzeGNsbtEvkGDInZD026+xhgVaNi9E1IqnjiPlVV28PG7YYyVbu+b2bDLpbJNm6B/N3sU7d2ntwcuP0RpSQkTI6YLYatFDTjGHZBApLFxQgGMj+PuFzj06HjzQvX0oOeHwzJ+CTq0G4tvcBq8QuXa/GBwdl5W6DboziM9X1bK1VyXJ4GuGDAympOkxDn09+ecm5g58TIHcOySHJycHJvwTMC62lr60x/+QDm5ufTwAw/AotUNAT0O3XcY1Nt1oMUtB0CPdotCVHrcxjcVXTk7OxD4SGraQCgyTwTzOHRVmxjKyDgKZ4f7VMUL7TF4MOJg0KgnNTc8SbHlz8Hhg2zXeUFxlYtggKmarlwXCgSKFKnn6SqNZ451HHd9UVV4oVfvIFi4SwLM1vLYk8fR54uXQCk5dN9dd3t0MH0+Nmbm6rp6FmcgruCpOdj9JvugnGyJSAsS62C4HH7PNyXXjyyPjAAL9I6VxcGzouGjvK677jXMlaamDQW4S7ieLezltiNSTcMYCESaEBNIhlGou7B+EBAphrcGK1tuVhRHxxwIwK5hx763Zts9ymprlyCYch/y7tQ1PQ9Af8jj4nbhftVEHfdKXNZ7WRQfp0iK6V60Ch0MIzEpNlbB4283dUmA4dzTg488Qi/PfIlWLl/Oeo5y8nLpwosuosFDhkyEKHwIdCouDpe9wE+N+NHHjrCZCKCzWsJ5ELO7crKy/qgIZwCidjXIgt/HVqxShLJv4lQhR/mE82ChrwLXngUAfwojMwibqB6Bho9KysueDfQPBFRF3hSR8tFwdXhjenp6hinlBJ9lfbYW1jfXj6fc/v37uJp5fGpt72qiWkKk7K68jKwvha7+GA56DsymJsyMzxsca3pVdZU3TtSVtnTfwUwuFELWY2J6ESvXdHdJqc6CwdcNSBfDgo5F3OKdNR8T68Gr336Klk6/nrr37kaTxh5HX5UW08qvN3tW9Khj8qkgsx8t+NsaquYxQ/Sk9UmiU0YMJQMk29Ho0LwlK2AtgldgD/Y6TKcJI+FLcxizHQu4zRj2cwmG4kjgYUFKOv9F0pJaGZT7qcNDw+C+I3EAJMU0B26qrGQ9uI/v+B3VD/p2dnp6vtD1PZg4CfeIQ5wraSWPJWFRH3RHaCBuO3REW12mjR6G/yTT8C1HjHrMv3rQwWDwMNX0fY519Okt+wa47It2KLjc/n8DwFpWVtbAUFqoIE5QW3Fhy7Ah48js7Gy2utuL4nBxjYMSfNI2Nefvz0qPu7htqxHiyzuFY18cFdY9LW7qHPVqcZ04xeoYW5T74MQc32ZsXGYf6dUldTA//ROPP04lxSX0DOLPW7dupRuuvY6uu+F6vkU5gcBULIaMhLEyLVnTZyLrWDaX8rOzFzda1iWuVG0O2Wg+8w7NlYMLQtmWI91HS8vLn/YaAEFDodDPDEWZCkOmR14w9JUQzm0Q6SswWQb4FPUB6PVT8oOhRovkDID2ZHZm9mUwsIaAwgzUMUKoszCLzhXCmlpa5enT1Jxg8FUsCf5ZI+0srLOwX7w2Lxi8GgH1axVHJMN2eLPBjt6FJcNGnpAI5D0EjTMc/W+HPfBwcdWmP0IC+BEjv7Ve/eaCJDL9iKr9FcH3/0OEa4iqaQOk42D1RynUdO0a2CCT95kZzQ/Y6Q/sKn20cCHVVNfQ6lWrad2aNbRw3nxv3LCDr4BllYIltmeglPMRmB8Xke7pwHS0XzPuAah2zP+UA6Wj3IiA/Wc+TX8qlJl5OjeAkOTJPlV7Gm7WF1j9uR2WbS58mddZvAKcV1H3BzDO7oDJ8bZf1Z8IpQcmY93oOL9uXo+yF8N6/xxx6zCs+VMUXZ/MbaLtE3VNmwQDbDf85/GYPIOCmZlnIDr2HEz6VQ7Jl+BS3Zxi+NitSzUMOQdx5iFYyPklInsrFINehRs2AkBikUK7w3Xln2F43Q+mPQNiZAbaCCOyVo0JloQg78XSlSdwv10W4DFjxsINkrRy2XJas3IltJek1atXEzgsBLFUgHW/TQgrngp35a8qfNNkLK0ByI1Y7TwHS4F9OXpgC+UO5oomIW7miJNBmrcAoBlqAGFM1ohfQjG+51iRM8HBP4FMH4a15PHg9hdENDqvMRqdgXqluqldxcTEapFEoxcUhctuKq4OfwgLtxCT4ZwYobWzcbvUqtKXwu6UKOliCXCq7bpVZrjssk3l5fdarvMyHmpEKCMwydD1I1wpHhVNTR9HouIJANeoKvpP4E4FeezYDrVSraj4YzQqxjmOcmfUdUuiUn6BZ3kFT3anK50zud8uK6Jz4RalZWTQXCwT1m2po8ysLKqqrCSfUK7CwjpcVzUM8WZAlJ6IiPNQoWjIllGH3I1CV0zeNwLu2MREqKzsvi0v2FiDqESQryHy5jMBsUlguuYqj2Mhfl3UsR9WyfB0tSqVqeRPviIVlAbh/eCmrYg4doO7tW2XHfmU20CyXaG8Daf6V8H09GGqppyO/ueUU/nOPJmN0SBerqh58Gc3wMXx4s8A+XLoYjiB7r3AEFNMuQ/9TOMtEkhgcBoQcd3pCG5eihDtHAEVAd9veVQ4D7BYRxn+xFMVn3RZDjZNk04cM5o+/3QJFRcV0hVXTyXMelJN7ecwRdfBX1zFYhi69omiirICcFVB007xv1KIayDKtvFaqlAENDNRMNgAV5ZgTLlexIrdlz3RyISIbU1E/UfAeUkQpa+itRFMaywI/BrcdVKU5JiIJcZGpXsxcqMA0AYKHhrcbpScObhQNN24CxMhzZFiNrI9AwzCB0MkC5MwYeBlZ2YOVyP2eEgfi6NjWBq8jPuxFBqNGPhYbGa4Fv77hkbbGiNs63xIgeeggnKwEeGN0IABWdxn29RlAeYHGT16NEeM6LAePejU00+jvCMKOGSYikjlZ3qSvhpWMjZGqZcg/hsI9g+mp/Qy30XU6CmIVQ5jYU1WOxfNIHRE4xDaHACQPuJ2c7Oyb8TWn/nYs7WsuKzsdli8tyOKhcmgbMfmAws6blgJCI29WRWmqT/md9UrGawYQ3MLsdS9e/cvMb61fl2fhLbDMPxWQI8bvOkJYc4GSOqlAP4YWMN5bBHzJMIq3S1Njljk2QgIh3I/tm3XY0PBTFXzTczNCj2arPt+p3frNqckXHYzxvMsxtadNH+/eL8tj10a4KOPOQY0Vyl/4BEEYtKIE0Z6wkyQs5g3tlmuuFqqSl8YQht8fmUDmKIHDK67wURY4HGaQOTJsKDX+HTlLazLLoMee5WJ49rOMhxytOSUdVgkmOfXfS8iNvw14i5PY8fFY5qmTs3LCn5xWHLyKg06E/J1Prbv8P4jTyJwG5xiG+Tk+7BuoZ9pAaztiGVhfrClrZKvUdhPAuTdKYb5MT7LwI1Bh5z7KqorPo46zp8QV38AFvSiVN23DJX6WYr4xBXuUjzyeLuhcSPuzYchdoctxOJGuxGSft/UpQHu27cvPTvjObr5V2x4Ek0+bwo1RJsuQLx5CV+XV1Yu2BNpGg7qXopw34+cxvrhZVVVy7BgsBpx5DNgFI2BtbkMO2kebLTtM+OrRJtqKj5zbOs4gDkfnD4B7vJrTa49vqyurLaksvw224peBA4bCg1cZ9nWCeVV5YsRk17C5aALo9x3PEFnzoja1lWupjzOebgfgXK+FFz5JHZElkSj0ZMQ/SuCLjYxI8eVVVZyTFr6U1MuxWS4Hhw+VqrysybXHYnxfYXNfW/D4DsBIcIi3DtdWO59NslJvCkh3mfLI9QG5jXSf1OosiUB/tPPu6wVfbDAFBQUpDlR5yiYWk2GTCraGN6YiAsfbNudqX6XBfjFGc/TQw88uA8tcwLBhBULHVtfUlHGG9ISKS8r+1xsOH3GaYrCqIIsxMfCIk5uILQQe7GvKw4XJ3Ze8P38/Pze0nImQ9Adg8Ld4cMWw5J7pbS0NL7aw8U6beqyAMcpes7kyZSekR6/pOlPP3Nv/AKgeP5l/BqhwEewzHczjJm1cFZuUVxtPVyegCIFolzyPOx4XloQCh1fWFZWyHUKsgpCTsRagOBDJgzfFXCksXGNzkMw4yas5V6I5b5342131mOXB3jK+VO8bbNxAl9/4w13xc9bHgsCOaPghzK4H/hTk89pfgWEi6zCZ05uKDQfG7DfFa7yPK7H4YN1RGsa/Jn+iAeNKqko4XK8FTYHAG8A0C9iM968Fu3w7U6XWlnR3gVkFocHOE6HmCom7r93zBhBhwwAm3F/g4YEwpa/bA+UkrKy9xDbegjd1fIuSu4Uq9mjcFhcEo6By3lwv0qRPxvSoU+0PuptzeH8zpoSHMxbZPkNQhdRbezNBb4ccIEWixnZ3vm/NvAVG4tHuIOcZABDQYDgWESN1rfVsS2BKanYFPO3kDly5MikrTWbPwHK81qW4XNM/MMBMgIlLm+p6dQpATC/VqE2gFsObyBVREjFBhCBje861I6KNws5dQwvfT96MOcaMkpNvEsEoan9pWefnk69evdK3AaQr8UvsIX5+aKysiVsMSMvGU2G4/e+67h06dImlLmsbbmcQM5wvIRyGkT31+f/6Eeld999d9sineraA5iByxv9Q6rfsYXqlr9HVo9siuINB6O4igQCa/xLOXs3usfGH2fsg2SuZmLwCOItNU8j4SBaDy7ucwRUYGyCNRdudVi/bh3eLdq77g7OGh8vgGB/zAiyKGZJK1QXv/ePHHMCoasw7Z+EJNiDyfNjgNvhOzD+kXF9Wx0PYCZtzwEhOmXqg9Rw3o143wdi+i28yNUwjxTsd/B+lYNfCY2jitCLxm8EIjqH+Pp+2kctV8c6Na+4MB3iALYuzrmersfCFtbaEIFHSFcxSWYcR/qws6l76PhYX62rJa6ee/H5VkYWiO+5P4kCOME+xzL4QrzG3268tmXZ9s5hWA1C5P+3mDxYo8Rar0qXxy3t9sp3pjwP4JYDSunZ17vMOX4ibdu4jLYsn4e9b3vAyf1JMVMAMhZcPFTaB8yrDD3OO1ah+1D02wW7Bz2aUvFWpVCwoJM1isyjziU9+1hkNnMu7+T7lu5ajr+9c45L52YFwxhJfnv343ko8zgGPkUa6onwcys5H1x7pbSdpwHsLlXRflJUVvIKJtG3P1S8wU5w3AdgHhO/2ZeWP5QmTnuLyld+SkbdetIBOFXeSLK8Eozbplqcs7262JjK3I0X6qQbQc7+kWEDTsOLbZaWSk7oVNKPxo+0BI5FHMH09oCq0L38hhQvKBxsAiKrMePOgf96EvzXxW3bixlVWy5H/u44uAh+TAHXvoC8uZrP+HFRUdE2gNu2aqe+boNUbKywnT2hiuUpyh1xGgA/zYNJ7xXCxnJ+nQ0bTFCUAXKdRryN2A0YsOUdm9htacBc7FnmOPLL3CwrSdjkaBDFeePBseeQGTga22zB+WiXLVReVcV7AR0CLj+Vriq3YkXnfwDy4xC5E8DVWzk/nmAx34+hdQd87E7F029wXY2F5gsBrrdWHL/RVY7tAsykbcsz/AMNY6++h7KGj6O1s58nsW0VOWYqaUMvJqN3iNwvLsAeBm9PdvOzAyH+99COv6WIOSDgkWLPgpJ7BplDzyYtE6/iQOcCcXxYpDOH4MMHLyVO4hmtjrNefoUWzFuQyMsJZD+ZuMCJv1vS7fB761lnIpJ1P+bgvQhULIe1/QLWdVcjktUfK0qToE5+gE4/y8jOeqykopwGh0L9moTMBccuRvlfoXzLZr1zzW8+W1hYWLPPjU6UsR+A946QOYp3s/MOCL//MDpizNmUc8IE2la8goy+GeQHuNHaUnAlB0b21tt7xpkAVWB/g9aD1NxTYDz9kMz0oZ6eZvgQKvSg9ZbB91b8XmfzPpjbttx1LTOwHIeNad4rIFRUvum+/FBOFcB8CJ/7edLyJASIUXzflxnKumfRokXeGwJRl9/uhyyR8iTU588+yWly3kFmpwY4sVy4z+gTGSxSY6aSpw+9fA8W5Mf2n3yzeRO9dcUwzxhTwJ39+vSkU48fQoYdwVIsRLHZHdbKWDJgFZsDwLFoL9aiZ2KBiLHO8HsXsZOD+AZY387yaHvKlCna2hUrcqWr5LiGGsZuisI4sAfRdaes+j0A/rZxM/jgT/xkYdFnH9BXc35LO75cRL36JdEZx8NY0rEYl38GGUdNJG3AkdCo2OrmWcQHD+T+RvV9AN5f3f/E/IMCmBmPxSv/PhZvM3WijVS67GPasfI9vAQ2mPxDJkCM53EpFnXN+vifG/A8BHDraXpQALduqnNcHQK4NQ7/PFnZup9DV/8mCvwd36lR2/WIQ3MAAAAASUVORK5CYII=
name: AWS - EC2
script:
  commands:
  - arguments:
    - description: One or more filters.See documentation for details & filter options.
      name: filters
    - description: One or more instance IDs. Seprated by comma.
      name: instanceIds
    - description: The AWS Region, if not specified the default region will be used
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of your instances.
    name: aws-ec2-describe-instances
    outputs:
    - contextPath: AWS.EC2.Instances.AmiLaunchIndex
      description: The AMI launch index, which can be used to find this instance in
        the launch group.
      type: number
    - contextPath: AWS.EC2.Instances.ImageId
      description: The ID of the AMI used to launch the instance.
      type: string
    - contextPath: AWS.EC2.Instances.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.InstanceType
      description: The instance type.
      type: string
    - contextPath: AWS.EC2.Instances.KernelId
      description: The kernel associated with this instance, if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.KeyName
      description: The name of the key pair, if this instance was launched with an
        associated key pair.
      type: string
    - contextPath: AWS.EC2.Instances.LaunchTime
      description: The time the instance was launched.
      type: date
    - contextPath: AWS.EC2.Instances.Monitoring.State
      description: Indicates whether detailed monitoring is enabled. Otherwise, basic
        monitoring is enabled.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.AvailabilityZone
      description: The Availability Zone of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.Affinity
      description: The affinity setting for the instance on the Dedicated Host.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.GroupName
      description: The name of the placement group the instance is in (for cluster
        compute instances).
      type: string
    - contextPath: AWS.EC2.Instances.Placement.HostId
      description: he ID of the Dedicated Host on which the instance resides.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.Tenancy
      description: The tenancy of the instance (if the instance is running in a VPC).
      type: string
    - contextPath: AWS.EC2.Instances.Platform
      description: The value is Windows for Windows instances; otherwise blank.
      type: string
    - contextPath: AWS.EC2.Instances.PrivateDnsName
      description: (IPv4 only) The private DNS hostname name assigned to the instance.
        This DNS hostname can only be used inside the Amazon EC2 network. This name
        is not available until the instance enters the running state.
      type: string
    - contextPath: AWS.EC2.Instances.PrivateIpAddress
      description: The private IPv4 address assigned to the instance.
      type: string
    - contextPath: AWS.EC2.Instances.ProductCodes.ProductCodeId
      description: The product code.
      type: string
    - contextPath: AWS.EC2.Instances.ProductCodes.ProductCodeType
      description: The type of product code.
      type: string
    - contextPath: AWS.EC2.Instances.PublicDnsName
      description: (IPv4 only) The public DNS name assigned to the instance. This
        name is not available until the instance enters the running state.
      type: string
    - contextPath: AWS.EC2.Instances.PublicIpAddress
      description: The public IPv4 address assigned to the instance, if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.RamdiskId
      description: The RAM disk associated with this instance, if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.State.Code
      description: The low byte represents the state.
      type: string
    - contextPath: AWS.EC2.Instances.State.Name
      description: The current state of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.StateTransitionReason
      description: The reason for the most recent state transition. This might be
        an empty string.
      type: string
    - contextPath: AWS.EC2.Instances.SubnetId
      description: The ID of the subnet in which the instance is running.
      type: string
    - contextPath: AWS.EC2.Instances.VpcId
      description: The ID of the VPC in which the instance is running.
      type: string
    - contextPath: AWS.EC2.Instances.Architecture
      description: The architecture of the image.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.DeviceName
      description: The device name (for example, /dev/sdh or xvdh).
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.AttachTime
      description: The time stamp when the attachment initiated.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.DeleteOnTermination
      description: Indicates whether the volume is deleted on instance termination.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.Status
      description: The attachment state.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.VolumeId
      description: The ID of the EBS volume.
      type: string
    - contextPath: AWS.EC2.Instances.ClientToken
      description: The idempotency token you provided when you launched the instance,
        if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.EbsOptimized
      description: Indicates whether the instance is optimized for Amazon EBS I/O.
      type: boolean
    - contextPath: AWS.EC2.Instances.EnaSupport
      description: Specifies whether enhanced networking with ENA is enabled.
      type: boolean
    - contextPath: AWS.EC2.Instances.Hypervisor
      description: The hypervisor type of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.IamInstanceProfile.Arn
      description: The Amazon Resource Name (ARN) of the instance profile.
      type: string
    - contextPath: AWS.EC2.Instances.IamInstanceProfile.Id
      description: The ID of the instance profile.
      type: string
    - contextPath: AWS.EC2.Instances.InstanceLifecycle
      description: Indicates whether this is a Spot Instance or a Scheduled Instance.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuId
      description: The ID of the Elastic GPU.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuAssociationId
      description: The ID of the association.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuAssociationState
      description: The state of the association between the instance and the Elastic
        GPU.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuAssociationTime
      description: The time the Elastic GPU was associated with the instance.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Association.IpOwnerId
      description: The ID of the owner of the Elastic IP address.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Association.PublicDnsName
      description: The public DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Association.PublicIp
      description: The public IP address or Elastic IP address bound to the network
        interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.AttachTime
      description: The time stamp when the attachment initiated.
      type: date
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.AttachmentId
      description: The ID of the network interface attachment.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.DeleteOnTermination
      description: Indicates whether the network interface is deleted when the instance
        is terminated.
      type: boolean
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.DeviceIndex
      description: The index of the device on the instance for the network interface
        attachment.
      type: number
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.Status
      description: The attachment state.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Description
      description: The description.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Groups.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Groups.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Ipv6Addresses.Ipv6Address
      description: The IPv6 addresses associated with the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.MacAddress
      description: The MAC address.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.NetworkInterfaceId
      description: The ID of the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.OwnerId
      description: The ID of the AWS account that created the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateDnsName
      description: The private DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddress
      description: The IPv4 address of the network interface within the subnet.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Association.IpOwnerId
      description: The ID of the owner of the Elastic IP address.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Association.PublicDnsName
      description: The public DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Association.PublicIp
      description: The public IP address or Elastic IP address bound to the network
        interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Primary
      description: Indicates whether this IPv4 address is the primary private IP address
        of the network interface.
      type: boolean
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.PrivateDnsName
      description: The private IPv4 DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.PrivateIpAddress
      description: The private IPv4 address of the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.SourceDestCheck
      description: Indicates whether to validate network traffic to or from this network
        interface.
      type: boolean
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Status
      description: The status of the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.SubnetId
      description: The ID of the subnet.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.VpcId
      description: The ID of the VPC.
      type: string
    - contextPath: AWS.EC2.Instances.RootDeviceName
      description: The device name of the root device volume (for example, /dev/sda1).
      type: string
    - contextPath: AWS.EC2.Instances.RootDeviceType
      description: The root device type used by the AMI. The AMI can use an EBS volume
        or an instance store volume.
      type: string
    - contextPath: AWS.EC2.Instances.SecurityGroups.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.SecurityGroups.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.SourceDestCheck
      description: Specifies whether to enable an instance launched in a VPC to perform
        NAT.
      type: boolean
    - contextPath: AWS.EC2.Instances.SpotInstanceRequestId
      description: If the request is a Spot Instance request, the ID of the request.
      type: string
    - contextPath: AWS.EC2.Instances.SriovNetSupport
      description: Specifies whether enhanced networking with the Intel 82599 Virtual
        Function interface is enabled.
      type: string
    - contextPath: AWS.EC2.Instances.StateReason.Code
      description: The reason code for the state change.
      type: string
    - contextPath: AWS.EC2.Instances.StateReason.Message
      description: The message for the state change.
      type: string
    - contextPath: AWS.EC2.Instances.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Instances.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Instances.VirtualizationType
      description: The virtualization type of the instance.
      type: string
  - arguments:
    - description: One or more filters.
      name: filters
    - description: One or more image IDs, Seperated by comma
      name: imageIds
    - description: Filters the images by the owner. Specify an AWS account ID, self
        (owner is the sender of the request), or an AWS owner alias (valid values
        are amazon | aws-marketplace | microsoft ). Omitting this option returns all
        images for which you have launch permissions, regardless of ownership.
      name: owners
    - description: Scopes the images by users with explicit launch permissions. Specify
        an AWS account ID, self (the sender of the request), or all (public AMIs).
      name: executableUsers
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of the images (AMIs, AKIs, and ARIs) available
      to you. Images available to you include public images, private images that you
      own, and private images owned by other AWS accounts but for which you have explicit
      launch permissions.
    name: aws-ec2-describe-images
    outputs:
    - contextPath: AWS.EC2.Images.Architecture
      description: The architecture of the image.
      type: string
    - contextPath: AWS.EC2.Images.CreationDate
      description: The date and time the image was created.
      type: date
    - contextPath: AWS.EC2.Images.ImageId
      description: The ID of the AMI.
      type: string
    - contextPath: AWS.EC2.Images.ImageLocation
      description: The location of the AMI.
      type: string
    - contextPath: AWS.EC2.Images.ImageType
      description: The type of image.
      type: string
    - contextPath: AWS.EC2.Images.Public
      description: Indicates whether the image has public launch permissions. The
        value is true if this image has public launch permissions or false if it has
        only implicit and explicit launch permissions.
      type: boolean
    - contextPath: AWS.EC2.Images.KernelId
      description: The kernel associated with the image, if any. Only applicable for
        machine images.
      type: string
    - contextPath: AWS.EC2.Images.OwnerId
      description: The AWS account ID of the image owner.
      type: string
    - contextPath: AWS.EC2.Images.Platform
      description: The value is Windows for Windows AMIs; otherwise blank.
      type: string
    - contextPath: AWS.EC2.Images.ProductCodes.ProductCodeId
      description: The product code.
      type: string
    - contextPath: AWS.EC2.Images.ProductCodes.ProductCodeType
      description: The type of product code.
      type: string
    - contextPath: AWS.EC2.Images.RamdiskId
      description: The RAM disk associated with the image, if any. Only applicable
        for machine images.
      type: string
    - contextPath: AWS.EC2.Images.State
      description: The current state of the AMI. If the state is available , the image
        is successfully registered and can be used to launch an instance.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.DeviceName
      description: The device name (for example, /dev/sdh or xvdh).
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.VirtualName
      description: The virtual device name (ephemeral N).
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.Encrypted
      description: Indicates whether the EBS volume is encrypted.
      type: boolean
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.DeleteOnTermination
      description: Indicates whether the EBS volume is deleted on instance termination.
      type: boolean
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.Iops
      description: The number of I/O operations per second (IOPS) that the volume
        supports.
      type: number
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.KmsKeyId
      description: Identifier (key ID, key alias, ID ARN, or alias ARN) for a user-managed
        CMK under which the EBS volume is encrypted.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.SnapshotId
      description: The ID of the snapshot.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.VolumeSize
      description: The size of the volume, in GiB.
      type: number
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.VolumeType
      description: The volume type.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.NoDevice
      description: Suppresses the specified device included in the block device mapping
        of the AMI.
      type: string
    - contextPath: AWS.EC2.Images.Description
      description: The description of the AMI that was provided during image creation.
      type: string
    - contextPath: AWS.EC2.Images.EnaSupport
      description: Specifies whether enhanced networking with ENA is enabled.
      type: boolean
    - contextPath: AWS.EC2.Images.Hypervisor
      description: The hypervisor type of the image.
      type: string
    - contextPath: AWS.EC2.Images.ImageOwnerAlias
      description: The AWS account alias (for example, amazon , self ) or the AWS
        account ID of the AMI owner.
      type: string
    - contextPath: AWS.EC2.Images.Name
      description: The name of the AMI that was provided during image creation.
      type: string
    - contextPath: AWS.EC2.Images.RootDeviceName
      description: The device name of the root device volume (for example, /dev/sda1).
      type: string
    - contextPath: AWS.EC2.Images.RootDeviceType
      description: The type of root device used by the AMI. The AMI can use an EBS
        volume or an instance store volume.
      type: string
    - contextPath: AWS.EC2.Images.SriovNetSupport
      description: Specifies whether enhanced networking with the Intel 82599 Virtual
        Function interface is enabled.
      type: string
    - contextPath: AWS.EC2.Images.StateReason.Code
      description: The reason code for the state change.
      type: string
    - contextPath: AWS.EC2.Images.StateReason.Message
      description: The message for the state change.
      type: string
    - contextPath: AWS.EC2.Images.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Images.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Images.VirtualizationType
      description: The type of virtualization of the AMI.
      type: string
  - arguments:
    - description: The name of the region (for example, us-east-1 ).
      name: regionNames
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more regions that are currently available to you.
    name: aws-ec2-describe-regions
    outputs:
    - contextPath: AWS.Regions.Endpoint
      description: The region service endpoint.
      type: string
    - contextPath: AWS.Regions.RegionName
      description: The name of the region.
      type: string
  - arguments:
    - description: One or more filters. See documentation for filters list.
      name: filters
    - description: One or more Elastic IP addresses.
      name: publicIps
    - description: One or more allocation IDs.
      name: allocationIds
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of your Elastic IP addresses.
    name: aws-ec2-describe-addresses
    outputs:
    - contextPath: AWS.EC2.ElasticIPs.InstanceId
      description: The ID of the instance that the address is associated with (if
        any).
      type: string
    - contextPath: AWS.EC2.ElasticIPs.PublicIp
      description: The Elastic IP address.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.AllocationId
      description: The ID representing the allocation of the address for use with
        EC2-VPC.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.AssociationId
      description: The ID representing the association of the address with an instance
        in a VPC.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.Domain
      description: dicates whether this Elastic IP address is for use with instances
        in EC2-Classic (standard) or instances in a VPC.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.NetworkInterfaceId
      description: The ID of the network interface.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.NetworkInterfaceOwnerId
      description: The ID of the AWS account that owns the network interface.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.PrivateIpAddress
      description: The private IP address associated with the Elastic IP address.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.Region
      description: The aws region were the elastic ip is located.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.Tags.Value
      description: The value of the tag.
      type: string
  - arguments:
    - description: One or more filters. See documentation for filters list.
      name: filters
    - description: Returns the snapshots owned by the specified owner. Multiple owners
        can be specified.
      name: ownerIds
    - description: One or more snapshot IDs. Seperated by commas
      name: snapshotIds
    - description: One or more AWS accounts IDs that can create volumes from the snapshot.
      name: restorableByUserIds
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of the EBS snapshots available to you.
    name: aws-ec2-describe-snapshots
    outputs:
    - contextPath: AWS.EC2.Snapshots.DataEncryptionKeyId
      description: The data encryption key identifier for the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.Description
      description: The description for the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.Encrypted
      description: Indicates whether the snapshot is encrypted.
      type: boolean
    - contextPath: AWS.EC2.Snapshots.KmsKeyId
      description: The full ARN of the AWS Key Management Service (AWS KMS) customer
        master key (CMK) that was used to protect the volume encryption key for the
        parent volume.
      type: string
    - contextPath: AWS.EC2.Snapshots.OwnerId
      description: The AWS account ID of the EBS snapshot owner.
      type: string
    - contextPath: AWS.EC2.Snapshots.Progress
      description: The progress of the snapshot, as a percentage.
      type: string
    - contextPath: AWS.EC2.Snapshots.SnapshotId
      description: The ID of the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.StartTime
      description: The time stamp when the snapshot was initiated.
      type: string
    - contextPath: AWS.EC2.Snapshots.State
      description: The snapshot state.
      type: string
    - contextPath: AWS.EC2.Snapshots.StateMessage
      description: this field displays error state details to help you diagnose why
        the error occurred.
      type: string
    - contextPath: AWS.EC2.Snapshots.VolumeId
      description: The ID of the volume that was used to create the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.VolumeSize
      description: The size of the volume, in GiB.
      type: number
    - contextPath: AWS.EC2.Snapshots.OwnerAlias
      description: Value from an Amazon-maintained list of snapshot owners.
      type: string
    - contextPath: AWS.EC2.Snapshots.Region
      description: The aws region were the snapshot is located
      type: string
    - contextPath: AWS.EC2.Snapshots.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Snapshots.Tags.Value
      description: The value of the tag.
      type: string
  - arguments:
    - description: One or more filters.See documentation for filters list.
      name: Filters
    - description: One or more launch template names. Sepereted by comma.
      name: LaunchTemplateNames
    - description: One or more launch template IDs. Sepereted by comma.
      name: LaunchTemplateIds
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more launch templates.
    name: aws-ec2-describe-launch-templates
    outputs:
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplateId
      description: The ID of the launch template.
      type: string
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplateName
      description: The name of the launch template.
      type: string
    - contextPath: AWS.EC2.LaunchTemplates.CreateTime
      description: The time launch template was created.
      type: date
    - contextPath: AWS.EC2.LaunchTemplates.CreatedBy
      description: The principal that created the launch template.
      type: string
    - contextPath: AWS.EC2.LaunchTemplates.DefaultVersionNumber
      description: The version number of the default version of the launch template.
      type: number
    - contextPath: AWS.EC2.LaunchTemplates.LatestVersionNumber
      description: The version number of the latest version of the launch template.
      type: number
    - contextPath: AWS.EC2.LaunchTemplates.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.LaunchTemplates.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.LaunchTemplates.Region
      description: The aws region where the template is located
      type: string
  - arguments:
    - description: One or more filters. See documentation for filters list.
      name: filters
    - description: One or more key pair names. Sepereted by comma.
      name: keyNames
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of your key pairs.
    name: aws-ec2-describe-key-pairs
    outputs:
    - contextPath: AWS.EC2.KeyPairs.KeyFingerprint
      description: If you used CreateKeyPair to create the key pair, this is the SHA-1
        digest of the DER encoded private key. If you used ImportKeyPair to provide
        AWS the public key, this is the MD5 public key fingerprint as specified in
        section 4 of RFC4716.
      type: Unknown
    - contextPath: AWS.EC2.KeyPairs.KeyName
      description: The name of the key pair.
      type: Unknown
    - contextPath: AWS.EC2.KeyPairs.Region
      description: The aws region where the key pair is located
      type: Unknown
  - arguments:
    - description: One or more filters. See documentation for filters list.
      name: filters
    - description: One or more volume IDs. Sepereted by comma.
      name: volumeIds
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes the specified EBS volumes.
    name: aws-ec2-describe-volumes
    outputs:
    - contextPath: AWS.EC2.Volumes.AvailabilityZone
      description: The Availability Zone for the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.CreateTime
      description: The time stamp when volume creation was initiated.
      type: date
    - contextPath: AWS.EC2.Volumes.Encrypted
      description: Indicates whether the volume will be encrypted.
      type: boolean
    - contextPath: AWS.EC2.Volumes.KmsKeyId
      description: The full ARN of the AWS Key Management Service customer master
        key that was used to protect the volume encryption key for the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Size
      description: The snapshot from which the volume was created, if applicable.
      type: number
    - contextPath: AWS.EC2.Volumes.State
      description: The volume state.
      type: string
    - contextPath: AWS.EC2.Volumes.VolumeId
      description: The ID of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Iops
      description: The number of I/O operations per second (IOPS) that the volume
        supports.
      type: number
    - contextPath: AWS.EC2.Volumes.VolumeType
      description: The volume type. This can be gp2 for General Purpose SSD, io1 for
        Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD,
        or standard for Magnetic volumes.
      type: string
    - contextPath: AWS.EC2.Volumes.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Volumes.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.AttachTime
      description: The time stamp when the attachment initiated.
      type: date
    - contextPath: AWS.EC2.Volumes.Attachments.Device
      description: The device name.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.State
      description: The attachment state of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.VolumeId
      description: The ID of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.DeleteOnTermination
      description: Indicates whether the EBS volume is deleted on instance termination.
      type: boolean
  - arguments:
    - description: One or more filters. See documentation for filters list.
      name: filters
    - description: One or more VPC IDs. Sepereted by comma.
      name: vpcIds
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of your VPCs.
    name: aws-ec2-describe-vpcs
    outputs:
    - contextPath: AWS.EC2.Vpcs.CidrBlock
      description: The primary IPv4 CIDR block for the VPC.
      type: string
    - contextPath: AWS.EC2.Vpcs.DhcpOptionsId
      description: The ID of the set of DHCP options you have associated with the
        VPC.
      type: string
    - contextPath: AWS.EC2.Vpcs.State
      description: The current state of the VPC.
      type: string
    - contextPath: AWS.EC2.Vpcs.VpcId
      description: The ID of the VPC.
      type: string
    - contextPath: AWS.EC2.Vpcs.InstanceTenancy
      description: The allowed tenancy of instances launched into the VPC.
      type: string
    - contextPath: AWS.EC2.Vpcs.IsDefault
      description: Indicates whether the VPC is the default VPC.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.Ipv6CidrBlockAssociationSet.AssociationId
      description: The association ID for the IPv6 CIDR block.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.Ipv6CidrBlockAssociationSet.Ipv6CidrBlock
      description: The IPv6 CIDR block.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.Ipv6CidrBlockAssociationSet.Ipv6CidrBlockState.State
      description: The state of the CIDR block.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.Ipv6CidrBlockAssociationSet.Ipv6CidrBlockState.StatusMessage
      description: A message about the status of the CIDR block, if applicable.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.CidrBlockAssociationSet.AssociationId
      description: The association ID for the IPv4 CIDR block.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.CidrBlockAssociationSet.CidrBlock
      description: The IPv4 CIDR block.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.CidrBlockAssociationSet.CidrBlockState.State
      description: The state of the CIDR block.
      type: string
    - contextPath: AWS.EC2.Vpcs.Tags.CidrBlockAssociationSet.CidrBlockState.StatusMessage
      description: A message about the status of the CIDR block, if applicable.
      type: string
  - arguments:
    - description: One or more filters. See documetation for filters list.
      name: filters
    - description: One or more subnet IDs. Sepereted by comma.
      name: subnetIds
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of your subnets.
    name: aws-ec2-describe-subnets
    outputs:
    - contextPath: AWS.EC2.Subnets.AvailabilityZone
      description: The Availability Zone of the subnet.
      type: string
    - contextPath: AWS.EC2.Subnets.AvailableIpAddressCount
      description: The number of unused private IPv4 addresses in the subnet. Note
        that the IPv4 addresses for any stopped instances are considered unavailable.
      type: number
    - contextPath: AWS.EC2.Subnets.CidrBlock
      description: The IPv4 CIDR block assigned to the subnet.
      type: string
    - contextPath: AWS.EC2.Subnets.DefaultForAz
      description: Indicates whether this is the default subnet for the Availability
        Zone.
      type: boolean
    - contextPath: AWS.EC2.Subnets.MapPublicIpOnLaunch
      description: Indicates whether instances launched in this subnet receive a public
        IPv4 address.
      type: boolean
    - contextPath: AWS.EC2.Subnets.State
      description: The current state of the subnet.
      type: string
    - contextPath: AWS.EC2.Subnets.SubnetId
      description: The ID of the subnet.
      type: string
    - contextPath: AWS.EC2.Subnets.VpcId
      description: The ID of the VPC the subnet is in.
      type: string
    - contextPath: AWS.EC2.Subnets.AssignIpv6AddressOnCreation
      description: Indicates whether a network interface created in this subnet (including
        a network interface created by RunInstances) receives an IPv6 address.
      type: boolean
    - contextPath: AWS.EC2.Subnets.Ipv6CidrBlockAssociationSet.AssociationId
      description: The association ID for the CIDR block.
      type: string
    - contextPath: AWS.EC2.Subnets.Ipv6CidrBlockAssociationSet.Ipv6CidrBlock
      description: The IPv6 CIDR block.
      type: string
    - contextPath: AWS.EC2.Subnets.Ipv6CidrBlockAssociationSet.Ipv6CidrBlockState.State
      description: The state of a CIDR block.
      type: string
    - contextPath: AWS.EC2.Subnets.Ipv6CidrBlockAssociationSet.Ipv6CidrBlockState.StatusMessage
      description: A message about the status of the CIDR block, if applicable.
      type: string
    - contextPath: AWS.EC2.Subnets.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Subnets.Tags.Value
      description: The value of the tag.
      type: string
  - arguments:
    - description: One or more filters. See documetation for filters list.
      name: filters
    - description: One or more security group IDs. Required for security groups in
        a nondefault VPC. Sepereted by comma.
      name: groupIds
    - description: One or more security group names. Sepereted by comma.
      name: groupNames
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of your security groups.
    name: aws-ec2-describe-security-groups
    outputs:
    - contextPath: AWS.EC2.SecurityGroups.Description
      description: A description of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.FromPort
      description: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
        type number. A value of -1 indicates all ICMP/ICMPv6 types.
      type: number
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.IpProtocol
      description: The IP protocol name (tcp , udp , icmp ) or number.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.IpRanges.CidrIp
      description: The IPv4 CIDR range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.IpRanges.Description
      description: A description for the security group rule that references this
        IPv4 address range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.Ipv6Ranges.CidrIpv6
      description: The IPv6 CIDR range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.Ipv6Ranges.Description
      description: A description for the security group rule that references this
        IPv6 address range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.PrefixListIds.Description
      description: A description for the security group rule that references this
        prefix list ID.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.PrefixListIds.PrefixListId
      description: The ID of the prefix.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.ToPort
      description: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
        code.
      type: number
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.Description
      description: A description for the security group rule that references this
        user ID group pair.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.PeeringStatus
      description: The status of a VPC peering connection, if applicable.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.UserId
      description: The ID of an AWS account.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.VpcId
      description: The ID of the VPC for the referenced security group, if applicable.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissions.UserIdGroupPairs.VpcPeeringConnectionId
      description: The ID of the VPC peering connection, if applicable.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.OwnerId
      description: The AWS account ID of the owner of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.FromPort
      description: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
        type number.
      type: number
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.IpProtocol
      description: The IP protocol name (tcp , udp , icmp) or number.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.IpRanges.CidrIp
      description: The IPv4 CIDR range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.IpRanges.Description
      description: A description for the security group rule that references this
        IPv4 address range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.Ipv6Ranges.CidrIpv6
      description: The IPv6 CIDR range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.Ipv6Ranges.Description
      description: A description for the security group rule that references this
        IPv6 address range.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.PrefixListIds.Description
      description: A description for the security group rule that references this
        prefix list ID.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.PrefixListIds.PrefixListId
      description: The ID of the prefix.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.ToPort
      description: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
        code.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.Description
      description: A description for the security group rule that references this
        user ID group pair.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.PeeringStatus
      description: The status of a VPC peering connection, if applicable.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.UserId
      description: The ID of an AWS account.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.VpcId
      description: The ID of the VPC for the referenced security group, if applicable.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.IpPermissionsEgress.UserIdGroupPairs.VpcPeeringConnectionId
      description: The ID of the VPC peering connection, if applicable.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.VpcId
      description: The ID of the VPC for the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.Tags.Value
      description: The value of the tag.
      type: string
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Allocates an Elastic IP address.
    execution: true
    name: aws-ec2-allocate-address
    outputs:
    - contextPath: AWS.EC2.ElasticIPs.PublicIp
      description: The Elastic IP address.
      type: Unknown
    - contextPath: AWS.EC2.ElasticIPs.AllocationId
      description: The ID that AWS assigns to represent the allocation of the Elastic
        IP address for use with instances in a VPC.
      type: string
    - contextPath: AWS.EC2.ElasticIPs.Domain
      description: Indicates whether this Elastic IP address is for use with instances
        in EC2-Classic (standard ) or instances in a VPC (vpc).
      type: string
    - contextPath: AWS.EC2.ElasticIPs.Region
      description: The aws region where the elastic IP is located.
      type: Unknown
  - arguments:
    - description: The allocation ID.
      name: allocationId
      required: true
    - description: The ID of the instance. For EC2-VPC, you can specify either the
        instance ID or the network interface ID, but not both. The operation fails
        if you specify an instance ID unless exactly one network interface is attached.
      name: instanceId
    - auto: PREDEFINED
      defaultValue: "False"
      description: For a VPC in an EC2-Classic account, specify true to allow an Elastic
        IP address that is already associated with an instance or network interface
        to be reassociated with the specified instance or network interface. Otherwise,
        the operation fails. In a VPC in an EC2-VPC-only account, reassociation is
        automatic, therefore you can specify false to ensure the operation fails if
        the Elastic IP address is already associated with another resource.
      name: allowReassociation
      predefined:
      - "True"
      - "False"
    - description: The ID of the network interface. If the instance has more than
        one network interface, you must specify a network interface ID.
      name: networkInterfaceId
    - description: The primary or secondary private IP address to associate with the
        Elastic IP address. If no private IP address is specified, the Elastic IP
        address is associated with the primary private IP address.
      name: privateIpAddress
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Associates an Elastic IP address with an instance or a network interface.
    execution: true
    name: aws-ec2-associate-address
    outputs:
    - contextPath: AWS.EC2.ElasticIPs.AssociationId
      description: The ID that represents the association of the Elastic IP address
        with an instance.
      type: string
  - arguments:
    - description: The ID of the EBS volume.
      name: volumeId
      required: true
    - description: A description for the snapshot.
      name: description
    - description: The tags to apply to the snapshot during creation.
      name: tags
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Creates a snapshot of an EBS volume and stores it in Amazon S3. You
      can use snapshots for backups, to make copies of EBS volumes, and to save data
      before shutting down an instance.
    execution: true
    name: aws-ec2-create-snapshot
    outputs:
    - contextPath: AWS.EC2.Snapshots.DataEncryptionKeyId
      description: The data encryption key identifier for the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.Description
      description: The description for the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.Encrypted
      description: Indicates whether the snapshot is encrypted.
      type: number
    - contextPath: AWS.EC2.Snapshots.KmsKeyId
      description: The full ARN of the AWS Key Management Service (AWS KMS) customer
        master key (CMK) that was used to protect the volume encryption key for the
        parent volume.
      type: string
    - contextPath: AWS.EC2.Snapshots.OwnerId
      description: The AWS account ID of the EBS snapshot owner.
      type: string
    - contextPath: AWS.EC2.Snapshots.Progress
      description: The progress of the snapshot, as a percentage.
      type: string
    - contextPath: AWS.EC2.Snapshots.SnapshotId
      description: The ID of the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.StartTime
      description: The time stamp when the snapshot was initiated.
      type: date
    - contextPath: AWS.EC2.Snapshots.State
      description: The snapshot state.
      type: string
    - contextPath: AWS.EC2.Snapshots.StateMessage
      description: this field displays error state details to help you diagnose why
        the error occurred.
      type: string
    - contextPath: AWS.EC2.Snapshots.VolumeId
      description: The ID of the volume that was used to create the snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.VolumeSize
      description: The size of the volume, in GiB.
      type: number
    - contextPath: AWS.EC2.Snapshots.OwnerAlias
      description: Value from an Amazon-maintained list of snapshot owners.
      type: string
    - contextPath: AWS.EC2.Snapshots.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Snapshots.Tags.Value
      description: The value of the tag.
      type: string
  - arguments:
    - description: The ID of the EBS snapshot.
      name: snapshotId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Deletes the specified snapshot.
    execution: true
    name: aws-ec2-delete-snapshot
  - arguments:
    - description: A name for the new image.
      name: name
      required: true
    - description: The ID of the instance.
      name: instanceId
      required: true
    - description: A description for the new image.
      name: description
    - auto: PREDEFINED
      description: By default, Amazon EC2 attempts to shut down and reboot the instance
        before creating the image. If the noReboot option is set, Amazon EC2 wont
        shut down the instance before creating the image. When this option is used,
        file system integrity on the created image cant be guaranteed.
      name: noReboot
      predefined:
      - "True"
      - "False"
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Creates an Amazon EBS-backed AMI from an Amazon EBS-backed instance
      that is either running or stopped.
    execution: true
    name: aws-ec2-create-image
    outputs:
    - contextPath: AWS.EC2.Images.ImageId
      description: The ID of the new AMI.
      type: string
    - contextPath: AWS.EC2.Images.Name
      description: The name of the new AMI.
      type: string
    - contextPath: AWS.EC2.Images.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Images.Region
      description: The aws region where the image is located
      type: string
  - arguments:
    - description: The ID of the AMI.
      name: imageId
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Deregisters the specified AMI.
    execution: true
    name: aws-ec2-deregister-image
  - arguments:
    - description: The ID of the volume.
      name: volumeId
      required: true
    - description: Target size in GiB of the volume to be modified.
      name: size
    - description: Target EBS volume type of the volume to be modified  The API does
        not support modifications for volume type standard . You also cannot change
        the type of a volume to standard .
      name: volumeType
    - description: Target IOPS rate of the volume to be modified.
      name: iops
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: You can modify several parameters of an existing EBS volume, including
      volume size, volume type, and IOPS capacity.
    execution: true
    name: aws-ec2-modify-volume
    outputs:
    - contextPath: AWS.EC2.Volumes.Modification.VolumeId
      description: ID of the volume being modified.
      type: string
    - contextPath: AWS.EC2.Volumes.Modification.ModificationState
      description: Current state of modification. Modification state is null for unmodified.
        volumes.
      type: string
    - contextPath: AWS.EC2.Volumes.Modification.StatusMessage
      description: Generic status message on modification progress or failure.
      type: string
    - contextPath: AWS.EC2.Volumes.Modification.TargetSize
      description: Target size of the volume being modified.
      type: number
    - contextPath: AWS.EC2.Volumes.Modification.TargetIops
      description: Target IOPS rate of the volume being modified.
      type: number
    - contextPath: AWS.EC2.Volumes.Modification.TargetVolumeType
      description: Target EBS volume type of the volume being modified.
      type: string
    - contextPath: AWS.EC2.Volumes.Modification.OriginalSize
      description: Original size of the volume being modified.
      type: number
    - contextPath: AWS.EC2.Volumes.Modification.OriginalIops
      description: Original IOPS rate of the volume being modified.
      type: number
    - contextPath: AWS.EC2.Volumes.Modification.OriginalVolumeType
      description: Original EBS volume type of the volume being modified.
      type: string
    - contextPath: AWS.EC2.Volumes.Modification.Progress
      description: Modification progress from 0 to 100%.
      type: string
    - contextPath: AWS.EC2.Volumes.Modification.StartTime
      description: Modification start time.
      type: date
    - contextPath: AWS.EC2.Volumes.Modification.EndTime
      description: Modification completion or failure time.
      type: date
  - arguments:
    - description: The IDs of one or more resources to tag. For example, ami-1a2b3c4d.
      name: resources
    - description: One or more tags.
      name: tags
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Adds or overwrites one or more tags for the specified Amazon EC2
      resource or resources.
    execution: true
    name: aws-ec2-create-tags
  - arguments:
    - description: The association ID.
      name: associationId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Disassociates an Elastic IP address from the instance or network
      interface its associated with.
    execution: true
    name: aws-ec2-disassociate-address
  - arguments:
    - description: The allocation ID.
      name: allocationId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Releases the specified Elastic IP address.
    execution: true
    name: aws-ec2-release-address
  - arguments:
    - description: One or more instance IDs. Sepereted by comma.
      name: instanceIds
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Starts an Amazon EBS-backed instance that you have previously stopped.
    execution: true
    name: aws-ec2-start-instances
  - arguments:
    - description: One or more instance IDs.
      name: instanceIds
      required: true
    - description: The AWS Region, if not specified the default region will be used
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Stops an Amazon EBS-backed instance.
    execution: true
    name: aws-ec2-stop-instances
  - arguments:
    - description: One or more instance IDs.
      name: instanceIds
      required: true
    - description: The AWS Region, if not specified the default region will be used
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Shuts down one or more instances. This operation is idempotent; if
      you terminate an instance more than once, each call succeeds.
    execution: true
    name: aws-ec2-terminate-instances
  - arguments:
    - description: The Availability Zone in which to create the volume. Use DescribeAvailabilityZones
        to list the Availability Zones that are currently available to you.
      name: availabilityZone
      required: true
    - auto: PREDEFINED
      description: Specifies whether the volume should be encrypted.
      name: encrypted
      predefined:
      - "True"
      - "False"
    - description: The number of I/O operations per second (IOPS) to provision for
        the volume, with a maximum ratio of 50 IOPS/GiB. Range is 100 to 32000 IOPS
        for volumes in most regions.
      name: iops
    - description: An identifier for the AWS Key Management Service (AWS KMS) customer
        master key (CMK) to use when creating the encrypted volume. This parameter
        is only required if you want to use a non-default CMK; if this parameter is
        not specified, the default CMK for EBS is used. If a KmsKeyId is specified,
        the Encrypted flag must also be set.
      name: kmsKeyId
    - description: The size of the volume, in GiBs.
      name: size
    - description: The snapshot from which to create the volume.
      name: snapshotId
    - auto: PREDEFINED
      description: The volume type.
      name: volumeType
      predefined:
      - standard
      - io1
      - gp2
      - sc1
      - st1
    - description: One or more tags.Example key=Name,value=test;key=Owner,value=Bob
      name: tags
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Creates an EBS volume that can be attached to an instance in the
      same Availability Zone.
    execution: true
    name: aws-ec2-create-volume
    outputs:
    - contextPath: AWS.EC2.Volumes.AvailabilityZone
      description: The Availability Zone for the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.CreateTime
      description: The time stamp when volume creation was initiated.
      type: date
    - contextPath: AWS.EC2.Volumes.Encrypted
      description: Indicates whether the volume will be encrypted.
      type: boolean
    - contextPath: AWS.EC2.Volumes.KmsKeyId
      description: The full ARN of the AWS Key Management Service (AWS KMS) customer
        master key (CMK) that was used to protect the volume encryption key for the
        volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Size
      description: The size of the volume, in GiBs.
      type: number
    - contextPath: AWS.EC2.Volumes.SnapshotId
      description: The snapshot from which the volume was created, if applicable.
      type: string
    - contextPath: AWS.EC2.Volumes.State
      description: The volume state.
      type: string
    - contextPath: AWS.EC2.Volumes.VolumeId
      description: The ID of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Iops
      description: The number of I/O operations per second (IOPS) that the volume
        supports.
      type: number
    - contextPath: AWS.EC2.Volumes.VolumeType
      description: The volume type. This can be gp2 for General Purpose SSD, io1 for
        Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD,
        or standard for Magnetic volumes.
      type: string
    - contextPath: AWS.EC2.Volumes.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Volumes.Tags.Value
      description: The value of the tag.
      type: string
  - arguments:
    - description: The device name (for example, /dev/sdh or xvdh).
      name: device
      required: true
    - description: The ID of the instance.
      name: instanceId
      required: true
    - description: The ID of the EBS volume. The volume and instance must be within
        the same Availability Zone.
      name: volumeId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Attaches an EBS volume to a running or stopped instance and exposes
      it to the instance with the specified device name.
    execution: true
    name: aws-ec2-attach-volume
    outputs:
    - contextPath: AWS.EC2.Volumes.Attachments.AttachTime
      description: The time stamp when the attachment initiated.
      type: date
    - contextPath: AWS.EC2.Volumes.Attachments.Device
      description: The device name.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.State
      description: The attachment state of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.VolumeId
      description: The ID of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.DeleteOnTermination
      description: Indicates whether the EBS volume is deleted on instance termination.
      type: boolean
  - arguments:
    - description: The ID of the volume.
      name: volumeId
      required: true
    - description: Forces detachment if the previous detachment attempt did not occur
        cleanly. This option can lead to data loss or a corrupted file system. Use
        this option only as a last resort to detach a volume from a failed instance.
      name: force
    - description: The device name (for example, /dev/sdh or xvdh).
      name: device
    - description: The ID of the instance.
      name: instanceId
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Detaches an EBS volume from an instance.
    execution: true
    name: aws-ec2-detach-volume
    outputs:
    - contextPath: AWS.EC2.Volumes.Attachments.AttachTime
      description: The time stamp when the attachment initiated.
      type: date
    - contextPath: AWS.EC2.Volumes.Attachments.Device
      description: The device name.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.State
      description: The attachment state of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.VolumeId
      description: The ID of the volume.
      type: string
    - contextPath: AWS.EC2.Volumes.Attachments.DeleteOnTermination
      description: Indicates whether the EBS volume is deleted on instance termination.
      type: boolean
  - arguments:
    - description: The ID of the volume.
      name: volumeId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Deletes the specified EBS volume. The volume must be in the available
      state (not attached to an instance).
    execution: true
    name: aws-ec2-delete-volume
  - arguments:
    - defaultValue: "1"
      description: The number of instances to launch. must be grater then 0.
      name: count
      required: true
    - description: The ID of the AMI, which you can get by calling DescribeImages
        . An AMI is required to launch an instance and must be specified here or in
        a launch template.
      name: imageId
    - description: 'The instance type. for example: t2.large'
      name: instanceType
    - description: One or more security group IDs. Sepereted by comma.
      name: securityGroupIds
    - description: One or more security group names. For a nondefault VPC, you must
        use security group IDs instead.
      name: securityGroups
    - description: The ID of the subnet to launch the instance into.
      name: subnetId
    - description: The user data to make available to the instance.This value will
        be base64 encoded automatically. Do not base64 encode this value prior to
        performing the operation.
      name: userData
    - auto: PREDEFINED
      description: If you set this parameter to true , you cant terminate the instance
        using the Amazon EC2 console, CLI, or API.
      name: disableApiTermination
      predefined:
      - "True"
      - "False"
    - description: The Amazon Resource Name (ARN) of the instance profile. Both iamInstanceProfileArn
        and iamInstanceProfile are required if you would like to associate an instance
        profile.
      name: iamInstanceProfileArn
    - description: The name of the instance profile. Both iamInstanceProfileArn and
        iamInstanceProfile are required if you would like to associate an instance
        profile.
      name: iamInstanceProfileName
    - description: The name of the key pair. Warning - If you do not specify a key
        pair, you cant connect to the instance unless you choose an AMI that is configured
        to allow users another way to log in.
      name: keyName
    - auto: PREDEFINED
      description: Indicates whether the instance is optimized for Amazon EBS I/O.
      name: ebsOptimized
      predefined:
      - "True"
      - "False"
    - description: The device name (for example, /dev/sdh or xvdh).
      name: deviceName
    - description: The size of the volume, in GiB.
      name: ebsVolumeSize
    - auto: PREDEFINED
      description: The volume type.
      name: ebsVolumeType
      predefined:
      - gp2
      - io1
      - st1
      - sc1
      - standard
    - description: The number of I/O operations per second (IOPS) that the volume
        supports.
      name: ebsIops
    - auto: PREDEFINED
      description: Indicates whether the EBS volume is deleted on instance termination.
      name: ebsDeleteOnTermination
      predefined:
      - "True"
      - "False"
    - description: Identifier (key ID, key alias, ID ARN, or alias ARN) for a user-managed
        CMK under which the EBS volume is encrypted.
      name: ebsKmsKeyId
    - description: The ID of the snapshot.
      name: ebsSnapshotId
    - description: Indicates whether the EBS volume is encrypted.
      name: ebsEncrypted
    - description: The ID of the launch template. The launch template to use to launch
        the instances. Any parameters that you specify in RunInstances override the
        same parameters in the launch template. You can specify either the name or
        ID of a launch template, but not both.
      name: launchTemplateId
    - description: The name of the launch template. The launch template to use to
        launch the instances. Any parameters that you specify in RunInstances override
        the same parameters in the launch template. You can specify either the name
        or ID of a launch template, but not both.
      name: launchTemplateName
    - description: The version number of the launch template.
      name: launchTemplateVersion
    - description: The tags to apply to the instance.
      name: tags
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Launches the specified number of instances using an AMI for which
      you have permissions. You can create a launch template , which is a resource
      that contains the parameters to launch an instance. When you launch an instance
      using RunInstances , you can specify the launch template instead of specifying
      the launch parameters. An instance is ready for you to use when its in the running
      state. You can check the state of your instance using DescribeInstances.
    execution: true
    name: aws-ec2-run-instances
    outputs:
    - contextPath: AWS.EC2.Instances.AmiLaunchIndex
      description: The AMI launch index, which can be used to find this instance in
        the launch group.
      type: number
    - contextPath: AWS.EC2.Instances.ImageId
      description: The ID of the AMI used to launch the instance.
      type: string
    - contextPath: AWS.EC2.Instances.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.InstanceType
      description: The instance type.
      type: string
    - contextPath: AWS.EC2.Instances.KernelId
      description: The kernel associated with this instance, if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.KeyName
      description: The name of the key pair, if this instance was launched with an
        associated key pair.
      type: string
    - contextPath: AWS.EC2.Instances.LaunchTime
      description: The time the instance was launched.
      type: date
    - contextPath: AWS.EC2.Instances.Monitoring.State
      description: Indicates whether detailed monitoring is enabled. Otherwise, basic
        monitoring is enabled.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.AvailabilityZone
      description: The Availability Zone of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.Affinity
      description: The affinity setting for the instance on the Dedicated Host.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.GroupName
      description: The name of the placement group the instance is in (for cluster
        compute instances).
      type: string
    - contextPath: AWS.EC2.Instances.Placement.HostId
      description: he ID of the Dedicated Host on which the instance resides.
      type: string
    - contextPath: AWS.EC2.Instances.Placement.Tenancy
      description: The tenancy of the instance (if the instance is running in a VPC).
      type: string
    - contextPath: AWS.EC2.Instances.Platform
      description: The value is Windows for Windows instances; otherwise blank.
      type: string
    - contextPath: AWS.EC2.Instances.PrivateDnsName
      description: (IPv4 only) The private DNS hostname name assigned to the instance.
        This DNS hostname can only be used inside the Amazon EC2 network. This name
        is not available until the instance enters the running state.
      type: string
    - contextPath: AWS.EC2.Instances.PrivateIpAddress
      description: The private IPv4 address assigned to the instance.
      type: string
    - contextPath: AWS.EC2.Instances.ProductCodes.ProductCodeId
      description: The product code.
      type: string
    - contextPath: AWS.EC2.Instances.ProductCodes.ProductCodeType
      description: The type of product code.
      type: string
    - contextPath: AWS.EC2.Instances.PublicDnsName
      description: (IPv4 only) The public DNS name assigned to the instance. This
        name is not available until the instance enters the running state.
      type: string
    - contextPath: AWS.EC2.Instances.PublicIpAddress
      description: The public IPv4 address assigned to the instance, if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.RamdiskId
      description: The RAM disk associated with this instance, if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.State.Code
      description: The low byte represents the state.
      type: string
    - contextPath: AWS.EC2.Instances.State.Name
      description: The current state of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.StateTransitionReason
      description: The reason for the most recent state transition. This might be
        an empty string.
      type: string
    - contextPath: AWS.EC2.Instances.SubnetId
      description: The ID of the subnet in which the instance is running.
      type: string
    - contextPath: AWS.EC2.Instances.VpcId
      description: The ID of the VPC in which the instance is running.
      type: string
    - contextPath: AWS.EC2.Instances.Architecture
      description: The architecture of the image.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.DeviceName
      description: The device name (for example, /dev/sdh or xvdh).
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.AttachTime
      description: The time stamp when the attachment initiated.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.DeleteOnTermination
      description: Indicates whether the volume is deleted on instance termination.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.Status
      description: The attachment state.
      type: string
    - contextPath: AWS.EC2.Instances.BlockDeviceMappings.Ebs.VolumeId
      description: The ID of the EBS volume.
      type: string
    - contextPath: AWS.EC2.Instances.ClientToken
      description: The idempotency token you provided when you launched the instance,
        if applicable.
      type: string
    - contextPath: AWS.EC2.Instances.EbsOptimized
      description: Indicates whether the instance is optimized for Amazon EBS I/O.
      type: boolean
    - contextPath: AWS.EC2.Instances.EnaSupport
      description: Specifies whether enhanced networking with ENA is enabled.
      type: boolean
    - contextPath: AWS.EC2.Instances.Hypervisor
      description: The hypervisor type of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.IamInstanceProfile.Arn
      description: The Amazon Resource Name (ARN) of the instance profile.
      type: string
    - contextPath: AWS.EC2.Instances.IamInstanceProfile.Id
      description: The ID of the instance profile.
      type: string
    - contextPath: AWS.EC2.Instances.InstanceLifecycle
      description: Indicates whether this is a Spot Instance or a Scheduled Instance.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuId
      description: The ID of the Elastic GPU.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuAssociationId
      description: The ID of the association.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuAssociationState
      description: The state of the association between the instance and the Elastic
        GPU.
      type: string
    - contextPath: AWS.EC2.Instances.ElasticGpuAssociations.ElasticGpuAssociationTime
      description: The time the Elastic GPU was associated with the instance.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Association.IpOwnerId
      description: The ID of the owner of the Elastic IP address.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Association.PublicDnsName
      description: The public DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Association.PublicIp
      description: The public IP address or Elastic IP address bound to the network
        interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.AttachTime
      description: The time stamp when the attachment initiated.
      type: date
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.AttachmentId
      description: The ID of the network interface attachment.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.DeleteOnTermination
      description: Indicates whether the network interface is deleted when the instance
        is terminated.
      type: boolean
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.DeviceIndex
      description: The index of the device on the instance for the network interface
        attachment.
      type: number
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Attachment.Status
      description: The attachment state.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Description
      description: The description.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Groups.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Groups.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Ipv6Addresses.Ipv6Address
      description: The IPv6 addresses associated with the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.MacAddress
      description: The MAC address.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.NetworkInterfaceId
      description: The ID of the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.OwnerId
      description: The ID of the AWS account that created the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateDnsName
      description: The private DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddress
      description: The IPv4 address of the network interface within the subnet.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Association.IpOwnerId
      description: The ID of the owner of the Elastic IP address.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Association.PublicDnsName
      description: The public DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Association.PublicIp
      description: The public IP address or Elastic IP address bound to the network
        interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.Primary
      description: Indicates whether this IPv4 address is the primary private IP address
        of the network interface.
      type: boolean
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.PrivateDnsName
      description: The private IPv4 DNS name.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.PrivateIpAddresses.PrivateIpAddress
      description: The private IPv4 address of the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.SourceDestCheck
      description: Indicates whether to validate network traffic to or from this network
        interface.
      type: boolean
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.Status
      description: The status of the network interface.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.SubnetId
      description: The ID of the subnet.
      type: string
    - contextPath: AWS.EC2.Instances.NetworkInterfaces.VpcId
      description: The ID of the VPC.
      type: string
    - contextPath: AWS.EC2.Instances.RootDeviceName
      description: The device name of the root device volume (for example, /dev/sda1).
      type: string
    - contextPath: AWS.EC2.Instances.RootDeviceType
      description: The root device type used by the AMI. The AMI can use an EBS volume
        or an instance store volume.
      type: string
    - contextPath: AWS.EC2.Instances.SecurityGroups.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.SecurityGroups.GroupId
      description: The ID of the security group.
      type: string
    - contextPath: AWS.EC2.Instances.SourceDestCheck
      description: Specifies whether to enable an instance launched in a VPC to perform
        NAT.
      type: boolean
    - contextPath: AWS.EC2.Instances.SpotInstanceRequestId
      description: If the request is a Spot Instance request, the ID of the request.
      type: string
    - contextPath: AWS.EC2.Instances.SriovNetSupport
      description: Specifies whether enhanced networking with the Intel 82599 Virtual
        Function interface is enabled.
      type: string
    - contextPath: AWS.EC2.Instances.StateReason.Code
      description: The reason code for the state change.
      type: string
    - contextPath: AWS.EC2.Instances.StateReason.Message
      description: The message for the state change.
      type: string
    - contextPath: AWS.EC2.Instances.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Instances.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Instances.VirtualizationType
      description: The virtualization type of the instance.
      type: string
  - arguments:
    - description: One or more filters. See documentation for details & filter options.
      name: filter
    - description: One or more instance IDs. Sepreted by comma.
      name: instanceIds
    - description: The amount of time in seconds to wait between attempts. Default
        15
      name: waiterDelay
    - description: The maximum number of attempts to be made. Default 40
      name: waiterMaxAttempts
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: A waiter function that runs every 15  seconds until a successful
      state is reached.
    name: aws-ec2-waiter-instance-running
  - arguments:
    - description: One or more filters. See documentation for details & filter options.
      name: filter
    - description: One or more instance IDs. Seprated by comma.
      name: instanceIds
    - description: The amount of time in seconds to wait between attempts. Default
        15
      name: waiterDelay
    - description: The maximum number of attempts to be made. Default 40.
      name: waiterMaxAttempts
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: A waiter function that runs every 15  seconds until a successful
      state is reached
    name: aws-ec2-waiter-instance-status-ok
  - arguments:
    - description: One or more filters. See documentation for details & filter options.
      name: filter
    - description: One or more instance IDs. Seprated by comma.
      name: instanceIds
    - description: The amount of time in seconds to wait between attempts. Default
        15
      name: waiterDelay
    - description: The maximum number of attempts to be made. Default 40
      name: waiterMaxAttempts
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: A waiter function that runs every 15  seconds until a successful
      state is reached
    name: aws-ec2-waiter-instance-stopped
  - arguments:
    - description: One or more filters. See documentation for details & filter options.
      name: filter
    - description: One or more instance IDs. Seprated by comma.
      name: instanceIds
    - description: The amount of time in seconds to wait between attempts. Default
        15
      name: waiterDelay
    - description: The maximum number of attempts to be made. Default 40
      name: waiterMaxAttempts
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: A waiter function that runs every 15  seconds until a successful
      state is reached
    name: aws-ec2-waiter-instance-terminated
  - arguments:
    - description: One or more filters. See documentation for available filters.
      name: filters
    - description: One or more image IDs. Sperated by comma.
      name: imageIds
    - description: Filters the images by the owner. Specify an AWS account ID, self
        (owner is the sender of the request), or an AWS owner alias (valid values
        are amazon | aws-marketplace | microsoft ). Omitting this option returns all
        images for which you have launch permissions, regardless of ownership.
      name: owners
    - description: Scopes the images by users with explicit launch permissions. Specify
        an AWS account ID, self (the sender of the request), or all (public AMIs).
      name: executableUsers
    - description: The amount of time in seconds to wait between attempts. Default
        15
      name: waiterDelay
    - description: The maximum number of attempts to be made. Default 40
      name: waiterMaxAttempts
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: A waiter function that waits until image is avilable
    name: aws-ec2-waiter-image-available
  - arguments:
    - description: One or more filters. See documentation for available filters.
      name: filters
    - description: Returns the snapshots owned by the specified owner. Multiple owners
        can be specified. Sperated by comma.
      name: ownerIds
    - description: One or more snapshot IDs. Sperated by comma.
      name: snapshotIds
    - description: One or more AWS accounts IDs that can create volumes from the snapshot.
      name: restorableByUserIds
    - description: The amount of time in seconds to wait between attempts. Default
        15
      name: waiterDelay
    - description: The maximum number of attempts to be made. Default 40
      name: waiterMaxAttempts
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: A waiter function that waits until the snapshot is complate
    name: aws-ec2-waiter-snapshot_completed
  - arguments:
    - description: One or more filters. See documentation for available filters.
      name: filters
    - description: Filters the images by the owner. Specify an AWS account ID, self
        (owner is the sender of the request), or an AWS owner alias (valid values
        are amazon | aws-marketplace | microsoft ). Omitting this option returns all
        images for which you have launch permissions, regardless of ownership.
      name: owners
    - description: Scopes the images by users with explicit launch permissions. Specify
        an AWS account ID, self (the sender of the request), or all (public AMIs).
      name: executableUsers
    - description: The AWS Region, if not specified the default region will be used
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Get The latest AMI
    name: aws-ec2-get-latest-ami
    outputs:
    - contextPath: AWS.EC2.Images.Architecture
      description: The architecture of the image.
      type: string
    - contextPath: AWS.EC2.Images.CreationDate
      description: The date and time the image was created.
      type: date
    - contextPath: AWS.EC2.Images.ImageId
      description: The ID of the AMI.
      type: string
    - contextPath: AWS.EC2.Images.ImageLocation
      description: The location of the AMI.
      type: string
    - contextPath: AWS.EC2.Images.ImageType
      description: The type of image.
      type: string
    - contextPath: AWS.EC2.Images.Public
      description: Indicates whether the image has public launch permissions. The
        value is true if this image has public launch permissions or false if it has
        only implicit and explicit launch permissions.
      type: boolean
    - contextPath: AWS.EC2.Images.KernelId
      description: The kernel associated with the image, if any. Only applicable for
        machine images.
      type: string
    - contextPath: AWS.EC2.Images.OwnerId
      description: The AWS account ID of the image owner.
      type: string
    - contextPath: AWS.EC2.Images.Platform
      description: The value is Windows for Windows AMIs; otherwise blank.
      type: string
    - contextPath: AWS.EC2.Images.ProductCodes.ProductCodeId
      description: The product code.
      type: string
    - contextPath: AWS.EC2.Images.ProductCodes.ProductCodeType
      description: The type of product code.
      type: string
    - contextPath: AWS.EC2.Images.RamdiskId
      description: The RAM disk associated with the image, if any. Only applicable
        for machine images.
      type: string
    - contextPath: AWS.EC2.Images.State
      description: The current state of the AMI. If the state is available , the image
        is successfully registered and can be used to launch an instance.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.DeviceName
      description: The device name (for example, /dev/sdh or xvdh ).
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.VirtualName
      description: The virtual device name (ephemeral N).
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.Encrypted
      description: Indicates whether the EBS volume is encrypted.
      type: boolean
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.DeleteOnTermination
      description: Indicates whether the EBS volume is deleted on instance termination.
      type: boolean
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.Iops
      description: The number of I/O operations per second (IOPS) that the volume
        supports.
      type: number
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.KmsKeyId
      description: Identifier (key ID, key alias, ID ARN, or alias ARN) for a user-managed
        CMK under which the EBS volume is encrypted.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.SnapshotId
      description: The ID of the snapshot.
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.VolumeSize
      description: The size of the volume, in GiB.
      type: number
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.Ebs.VolumeType
      description: The volume type
      type: string
    - contextPath: AWS.EC2.Images.BlockDeviceMappings.NoDevice
      description: Suppresses the specified device included in the block device mapping
        of the AMI.
      type: string
    - contextPath: AWS.EC2.Images.Description
      description: The description of the AMI that was provided during image creation.
      type: string
    - contextPath: AWS.EC2.Images.EnaSupport
      description: Specifies whether enhanced networking with ENA is enabled.
      type: boolean
    - contextPath: AWS.EC2.Images.Hypervisor
      description: The hypervisor type of the image.
      type: string
    - contextPath: AWS.EC2.Images.ImageOwnerAlias
      description: The AWS account alias (for example, amazon , self ) or the AWS
        account ID of the AMI owner.
      type: string
    - contextPath: AWS.EC2.Images.Name
      description: The name of the AMI that was provided during image creation.
      type: string
    - contextPath: AWS.EC2.Images.RootDeviceName
      description: The device name of the root device volume (for example, /dev/sda1).
      type: string
    - contextPath: AWS.EC2.Images.RootDeviceType
      description: The type of root device used by the AMI. The AMI can use an EBS
        volume or an instance store volume.
      type: string
    - contextPath: AWS.EC2.Images.SriovNetSupport
      description: Specifies whether enhanced networking with the Intel 82599 Virtual
        Function interface is enabled.
      type: string
    - contextPath: AWS.EC2.Images.StateReason.Code
      description: The reason code for the state change.
      type: string
    - contextPath: AWS.EC2.Images.StateReason.Message
      description: The message for the state change.
      type: string
    - contextPath: AWS.EC2.Images.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Images.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Images.VirtualizationType
      description: The type of virtualization of the AMI.
      type: string
  - arguments:
    - description: The name of the security group.
      name: groupName
      required: true
    - description: A description for the security group.
      name: description
      required: true
    - description: The ID of the VPC.
      name: vpcId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Creates a security group.
    execution: true
    name: aws-ec2-create-security-group
    outputs:
    - contextPath: AWS.EC2.SecurityGroups.GroupName
      description: The name of the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.Description
      description: A description for the security group.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.VpcId
      description: The ID of the VPC.
      type: string
    - contextPath: AWS.EC2.SecurityGroups.GroupId
      description: The ID of the security group.
      type: string
  - arguments:
    - description: The ID of the security group. Required for a nondefault VPC.
      name: groupId
    - description: default VPC only.  The name of the security group. You can specify
        either the security group name or the security group ID.
      name: groupName
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Deletes a security group.
    execution: true
    name: aws-ec2-delete-security-group
  - arguments:
    - description: The ID of the security group. You must specify either the security
        group ID or the security group name in the request. For security groups in
        a nondefault VPC, you must specify the security group ID.
      name: groupId
      required: true
    - description: The start of port range for the TCP and UDP protocols.
      name: fromPort
    - description: The end of port range for the TCP and UDP protocols.
      name: toPort
    - description: The CIDR IPv4 address range.
      name: cidrIp
    - description: The IP protocol name (tcp , udp , icmp) or number.  Use -1 to specify
        all protocols.
      name: ipProtocol
    - description: The name of the source security group. The source security group
        must be in the same VPC.
      name: sourceSecurityGroupName
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
        type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify
        all ICMP/ICMPv6 types, you must specify all codes.
      name: IpPermissionsfromPort
    - description: The IP protocol name (tcp, udp, icmp, icmpv6) or number.
      name: IpPermissionsIpProtocol
    - description: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
        code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6
        types, you must specify all codes.
      name: IpPermissionsToPort
    - description: The IPv4 CIDR range. You can either specify a CIDR range or a source
        security group, not both. To specify a single IPv4 address, use the /32 prefix
        length.
      name: IpRangesCidrIp
    - description: |-
        A description for the security group rule that references this IPv4 address range.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
      name: IpRangesDesc
    - description: The IPv6 CIDR range. You can either specify a CIDR range or a source
        security group, not both. To specify a single IPv6 address, use the /128 prefix
        length.
      name: Ipv6RangesCidrIp
    - description: |-
        A description for the security group rule that references this IPv6 address range.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
      name: Ipv6RangesDesc
    - description: The ID of the prefix.
      name: PrefixListId
    - description: |-
        A description for the security group rule that references this prefix list ID.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
      name: PrefixListIdDesc
    - description: |-
        A description for the security group rule that references this user ID group pair.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
      name: UserIdGroupPairsDescription
    - description: The ID of the security group.
      name: UserIdGroupPairsGroupId
    - description: The name of the security group. In a request, use this parameter
        for a security group in EC2-Classic or a default VPC only. For a security
        group in a nondefault VPC, use the security group ID.
      name: UserIdGroupPairsGroupName
    - description: The status of a VPC peering connection, if applicable.
      name: UserIdGroupPairsPeeringStatus
    - description: The ID of an AWS account.
      name: UserIdGroupPairsUserId
    - description: The ID of the VPC for the referenced security group, if applicable.
      name: UserIdGroupPairsVpcId
    - description: The ID of the VPC peering connection, if applicable.
      name: UserIdGroupPairsVpcPeeringConnectionId
    description: Adds ingress rule to a security group.
    execution: true
    name: aws-ec2-authorize-security-group-ingress-rule
  - arguments:
    - description: The ID of the security group.
      name: groupId
      required: true
    - description: The start of port range for the TCP and UDP protocols.
      name: fromPort
    - description: The end of port range for the TCP and UDP protocols.
      name: toPort
    - description: The CIDR IPv4 address range.
      name: cidrIp
    - description: The IP protocol name (tcp , udp , icmp) or number.  Use -1 to specify
        all protocols.
      name: ipProtocol
    - description: The name of the source security group. The source security group
        must be in the same VPC.
      name: sourceSecurityGroupName
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Removes egress rule from a security group. To remove a rule, the
      values that you specify (for example, ports) must match the existing rule's
      values exactly.
    execution: true
    name: aws-ec2-revoke-security-group-ingress-rule
  - arguments:
    - description: The name of the new AMI in the destination region.
      name: name
      required: true
    - description: The ID of the AMI to copy.
      name: sourceImageId
      required: true
    - description: The name of the region that contains the AMI to copy.
      name: sourceRegion
      required: true
    - description: A description for the new AMI in the destination region.
      name: description
    - auto: PREDEFINED
      description: Specifies whether the destination snapshots of the copied image
        should be encrypted. The default CMK for EBS is used unless a non-default
        AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId .
      name: encrypted
      predefined:
      - "True"
      - "False"
    - description: An identifier for the AWS Key Management Service (AWS KMS) customer
        master key (CMK) to use when creating the encrypted volume. This parameter
        is only required if you want to use a non-default CMK; if this parameter is
        not specified, the default CMK for EBS is used. If a KmsKeyId is specified,
        the Encrypted flag must also be set.
      name: kmsKeyId
    - description: nique, case-sensitive identifier you provide to ensure idempotency
        of the request.
      name: clientToken
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Initiates the copy of an AMI from the specified source region to
      the current region.
    execution: true
    name: aws-ec2-copy-image
    outputs:
    - contextPath: AWS.EC2.Images.ImageId
      description: The ID of the new AMI.
      type: string
    - contextPath: AWS.EC2.Images.Region
      description: The Region where the image is located.
      type: string
  - arguments:
    - description: The ID of the EBS snapshot to copy.
      name: sourceSnapshotId
      required: true
    - description: The ID of the region that contains the snapshot to be copied.
      name: sourceRegion
      required: true
    - description: A description for the EBS snapshot.
      name: description
    - description: ' Specifies whether the destination snapshot should be encrypted.
        You can encrypt a copy of an unencrypted snapshot using this flag, but you
        cannot use it to create an unencrypted copy from an encrypted snapshot. Your
        default CMK for EBS is used unless a non-default AWS Key Management Service
        (AWS KMS) CMK is specified with KmsKeyId .'
      name: encrypted
    - description: An identifier for the AWS Key Management Service (AWS KMS) customer
        master key (CMK) to use when creating the encrypted volume. This parameter
        is only required if you want to use a non-default CMK; if this parameter is
        not specified, the default CMK for EBS is used. If a KmsKeyId is specified,
        the Encrypted flag must also be set.
      name: kmsKeyId
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Copies a point-in-time snapshot of an EBS volume and stores it in
      Amazon S3. You can copy the snapshot within the same region or from one region
      to another.
    execution: true
    name: aws-ec2-copy-snapshot
    outputs:
    - contextPath: AWS.EC2.Snapshots.SnapshotId
      description: The ID of the new snapshot.
      type: string
    - contextPath: AWS.EC2.Snapshots.Region
      description: The Region where the snapshot is located.
      type: string
  - arguments:
    - description: ne or more filters.
      name: filters
    - description: One or more Reserved Instance IDs. Separated by comma.
      name: reservedInstancesIds
    - auto: PREDEFINED
      description: Describes whether the Reserved Instance is Standard or Convertible.
      name: offeringClass
      predefined:
      - standard
      - convertible
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Describes one or more of the Reserved Instances that you purchased.
    name: aws-ec2-describe-reserved-instances
    outputs:
    - contextPath: AWS.EC2.ReservedInstances.AvailabilityZone
      description: The Availability Zone in which the Reserved Instance can be used.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.Duration
      description: The duration of the Reserved Instance, in seconds.
      type: number
    - contextPath: AWS.EC2.ReservedInstances.End
      description: The time when the Reserved Instance expires.
      type: date
    - contextPath: AWS.EC2.ReservedInstances.FixedPrice
      description: The purchase price of the Reserved Instance.
      type: number
    - contextPath: AWS.EC2.ReservedInstances.InstanceCount
      description: The number of reservations purchased.
      type: number
    - contextPath: AWS.EC2.ReservedInstances.InstanceType
      description: The instance type on which the Reserved Instance can be used.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.ProductDescription
      description: The Reserved Instance product platform description.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.ReservedInstancesId
      description: The ID of the Reserved Instance.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.Start
      description: The date and time the Reserved Instance started.
      type: date
    - contextPath: AWS.EC2.ReservedInstances.State
      description: The state of the Reserved Instance purchase.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.UsagePrice
      description: The usage price of the Reserved Instance, per hour.
      type: number
    - contextPath: AWS.EC2.ReservedInstances.CurrencyCode
      description: The currency of the Reserved Instance. It's specified using ISO
        4217 standard currency codes. At this time, the only supported currency is
        USD .
      type: string
    - contextPath: AWS.EC2.ReservedInstances.InstanceTenancy
      description: The tenancy of the instance.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.OfferingClass
      description: The offering class of the Reserved Instance.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.OfferingType
      description: The Reserved Instance offering type.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.RecurringCharges.Amount
      description: The amount of the recurring charge.
      type: number
    - contextPath: AWS.EC2.ReservedInstances.RecurringCharges.Frequency
      description: he frequency of the recurring charge.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.Scope
      description: The scope of the Reserved Instance.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.ReservedInstances.Region
      description: The AWS region where the reserved instance is located.
      type: string
  - arguments:
    - description: One or more instance IDs. Separated by comma.
      name: instancesIds
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Enables detailed monitoring for a running instance.
    execution: true
    name: aws-ec2-monitor-instances
    outputs:
    - contextPath: AWS.EC2.Instances.InstanceId
      description: The ID of the instance.
      type: string
    - contextPath: AWS.EC2.Instances.Monitoring.State
      description: Indicates whether detailed monitoring is enabled. Otherwise, basic
        monitoring is enabled.
      type: string
  - arguments:
    - description: One or more instance IDs. Separated by comma.
      name: instancesIds
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Disables detailed monitoring for a running instance.
    execution: true
    name: aws-ec2-unmonitor-instances
    outputs:
    - contextPath: AWS.EC2.Instances.InstanceId
      description: The ID of the instance.
      type: Unknown
    - contextPath: AWS.EC2.Instances.Monitoring.State
      description: Indicates whether detailed monitoring is enabled. Otherwise, basic
        monitoring is enabled.
      type: Unknown
  - arguments:
    - description: One or more instance IDs. Separated by comma.
      name: instanceIds
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Requests a reboot of one or more instances. This operation is asynchronous;
      it only queues a request to reboot the specified instances. The operation succeeds
      if the instances are valid and belong to you. Requests to reboot terminated
      instances are ignored. If an instance does not cleanly shut down within four
      minutes, Amazon EC2 performs a hard reboot.
    execution: true
    name: aws-ec2-reboot-instances
  - arguments:
    - description: The ID of the Windows instance.
      name: instanceId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Retrieves the encrypted administrator password for a running Windows
      instance.
    execution: true
    name: aws-ec2-get-password-data
    outputs:
    - contextPath: AWS.EC2.Instances.PasswordData.PasswordData
      description: The password of the instance. Returns an empty string if the password
        is not available.
      type: string
    - contextPath: AWS.EC2.Instances.PasswordData.Timestamp
      description: The time the data was last updated.
      type: date
  - arguments:
    - description: The ID of the network interface.
      name: networkInterfaceId
      required: true
    - description: Changes the security groups for the network interface. The new
        set of groups you specify replaces the current set. You must specify at least
        one group, even if it's just the default security group in the VPC. You must
        specify the ID of the security group, not the name.
      name: groups
    - auto: PREDEFINED
      description: Indicates whether source/destination checking is enabled. A value
        of true means checking is enabled, and false means checking is disabled. This
        value must be false for a NAT instance to perform NAT.
      name: sourceDestCheck
      predefined:
      - "True"
      - "False"
    - description: A description for the network interface.
      name: description
    - description: The ID of the network interface attachment. Information about the
        interface attachment. If modifying the 'delete on termination' attribute,
        you must specify the ID of the interface attachment.
      name: attachmentId
    - auto: PREDEFINED
      description: Indicates whether the network interface is deleted when the instance
        is terminated. Information about the interface attachment. If modifying the
        'delete on termination' attribute, you must specify the ID of the interface
        attachment.
      name: deleteOnTermination
      predefined:
      - "True"
      - "False"
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Modifies the specified network interface attribute. You can specify
      only one attribute at a time.
    execution: true
    name: aws-ec2-modify-network-interface-attribute
  - arguments:
    - description: The ID of the instance.
      name: instanceId
      required: true
    - auto: PREDEFINED
      description: Specifies whether source/destination checking is enabled. A value
        of true means that checking is enabled, and false means that checking is disabled.
        This value must be false for a NAT instance to perform NAT.
      name: sourceDestCheck
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: If the value is true , you can't terminate the instance using the
        Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this parameter
        for Spot Instances.
      name: disableApiTermination
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: Specifies whether the instance is optimized for Amazon EBS I/O.
        This optimization provides dedicated throughput to Amazon EBS and an optimized
        configuration stack to provide optimal EBS I/O performance. This optimization
        isn't available with all instance types. Additional usage charges apply when
        using an EBS Optimized instance.
      name: ebsOptimized
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: Set to true to enable enhanced networking with ENA for the instance.  This
        option is supported only for HVM instances. Specifying this option with a
        PV instance can make it unreachable.
      name: enaSupport
      predefined:
      - "True"
      - "False"
    - description: Changes the instance type to the specified value.
      name: instanceType
    - auto: PREDEFINED
      description: Specifies whether an instance stops or terminates when you initiate
        shutdown from the instance (using the operating system command for system
        shutdown)
      name: instanceInitiatedShutdownBehavior
      predefined:
      - Stop
      - Terminate
    - description: '[EC2-VPC] Changes the security groups of the instance. You must
        specify at least one security group, even if it''s just the default security
        group for the VPC. You must specify the security group ID, not the security
        group name.'
      name: groups
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Modifies the specified attribute of the specified instance. You can
      specify only one attribute at a time. Using this action to change the security
      groups associated with an elastic network interface (ENI) attached to an instance
      in a VPC can result in an error if the instance has more than one ENI. To change
      the security groups associated with an ENI attached to an instance that has
      multiple ENIs, we recommend that you use the ModifyNetworkInterfaceAttribute
      action.
    execution: true
    name: aws-ec2-modify-instance-attribute
  - arguments:
    - auto: PREDEFINED
      description: Checks whether you have the required permissions for the action,
        without actually making the request, and provides an error response.
      name: DryRun
      predefined:
      - "True"
      - "False"
    - description: The ID of the VPC.
      name: VpcId
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Creates a network ACL in a VPC. Network ACLs provide an optional
      layer of security (in addition to security groups) for the instances in your
      VPC.
    name: aws-ec2-create-network-acl
    outputs:
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Associations.NetworkAclAssociationId
      description: The ID of the association between a network ACL and a subnet.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Associations.NetworkAclId
      description: The ID of the network ACL.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Associations.SubnetId
      description: The ID of the subnet.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.CidrBlock
      description: The IPv4 network range to allow or deny, in CIDR notation.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.Egress
      description: Indicates whether the rule is an egress rule (applied to traffic
        leaving the subnet).
      type: Boolean
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.IcmpTypeCode.Code
      description: The ICMP code. A value of -1 means all codes for the specified
        ICMP type.
      type: Number
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.IcmpTypeCode.Type
      description: The ICMP type. A value of -1 means all types.
      type: Number
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.Ipv6CidrBlock
      description: The IPv6 network range to allow or deny, in CIDR notation.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.PortRange.From
      description: The first port in the range.
      type: Number
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.PortRange.To
      description: The last port in the range.
      type: Number
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.Protocol
      description: The protocol number. A value of "-1" means all protocols.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.RuleAction
      description: Indicates whether to allow or deny the traffic that matches the
        rule.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Entries.RuleNumber
      description: The rule number for the entry. ACL entries are processed in ascending
        order by rule number.
      type: Number
    - contextPath: AWS.EC2.VpcId.NetworkAcl.NetworkAclId
      description: The ID of the network ACL.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Tags.Key
      description: The key of the tag.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.Tags.Value
      description: The value of the tag.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.VpcId
      description: The ID of the VPC for the network ACL.
      type: String
    - contextPath: AWS.EC2.VpcId.NetworkAcl.OwnerId
      description: The ID of the AWS account that owns the network ACL.
      type: String
  - arguments:
    - description: The IPv4 network range to allow or deny, in CIDR notation (for
        example 172.16.0.0/24 ).
      name: CidrBlock
    - auto: PREDEFINED
      description: Checks whether you have the required permissions for the action,
        without actually making the request, and provides an error response.
      name: DryRun
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: Indicates whether this is an egress rule (rule is applied to traffic
        leaving the subnet).
      name: Egress
      predefined:
      - "True"
      - "False"
      required: true
    - description: The ICMP code. A value of -1 means all codes for the specified
        ICMP type.
      name: Code
    - description: The ICMP type. A value of -1 means all types.
      name: Type
    - description: The IPv6 network range to allow or deny, in CIDR notation (for
        example 2001:db8:1234:1a00::/64 ).
      name: Ipv6CidrBlock
    - description: The ID of the network ACL.
      name: NetworkAclId
      required: true
    - description: The first port in the range.
      name: From
    - description: The last port in the range.
      name: To
    - description: The protocol number. A value of "-1" means all protocols. If you
        specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or "1"
        (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types
        or codes that you specify. If you specify protocol "58" (ICMPv6) and specify
        an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless
        of any that you specify. If you specify protocol "58" (ICMPv6) and specify
        an IPv6 CIDR block, you must specify an ICMP type and code.
      name: Protocol
      required: true
    - description: Indicates whether to allow or deny the traffic that matches the
        rule.
      name: RuleAction
      required: true
    - description: The rule number for the entry (for example, 100). ACL entries are
        processed in ascending order by rule number.
      name: RuleNumber
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Creates an entry (a rule) in a network ACL with the specified rule
      number.
    name: aws-ec2-create-network-acl-entry
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - auto: PREDEFINED
      description: Checks whether you have the required permissions for the action,
        without actually making the request, and provides an error response.
      name: DryRun
      predefined:
      - "True"
      - "False"
    - description: Unique, case-sensitive identifier you provide to ensure the idempotency
        of the request.
      name: ClientToken
    - description: Indicates how to allocate the target capacity across the Spot pools
        specified by the Spot Fleet request.
      name: SpotAllocationStrategy
    - description: The behavior when a Spot Instance is interrupted.
      name: InstanceInterruptionBehavior
    - description: The number of Spot pools across which to allocate your target Spot
        capacity.
      name: InstancePoolsToUseCount
    - auto: PREDEFINED
      description: Indicates that the fleet uses a single instance type to launch
        all Spot Instances in the fleet.
      name: SpotSingleInstanceType
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: Indicates that the fleet launches all Spot Instances into a single
        Availability Zone.
      name: SpotSingleInstanceType
      predefined:
      - "True"
      - "False"
    - description: The minimum target capacity for Spot Instances in the fleet. If
        the minimum target capacity is not reached, the fleet launches no instances.
      name: SpotMinTargetCapacity
    - description: The order of the launch template overrides to use in fulfilling
        On-Demand capacity.
      name: OnDemandAllocationStrategy
    - description: Indicates that the fleet uses a single instance type to launch
        all On-Demand Instances in the fleet.
      name: OnDemandSingleInstanceType
    - description: Indicates that the fleet launches all On-Demand Instances into
        a single Availability Zone.
      name: OnDemandSingleAvailabilityZone
    - description: The minimum target capacity for On-Demand Instances in the fleet.
        If the minimum target capacity is not reached, the fleet launches no instances.
      name: OnDemandMinTargetCapacity
    - description: ' Indicates whether running instances should be terminated if the
        total target capacity of the EC2 Fleet is decreased below the current size
        of the EC2 Fleet.'
      name: ExcessCapacityTerminationPolicy
    - description: The ID of the launch template.
      name: LaunchTemplateId
      required: true
    - description: The name of the launch template.
      name: LaunchTemplateName
      required: true
    - description: The version number of the launch template.
      name: Version
      required: true
    - description: The instance type.
      name: OverrideInstanceType
    - description: The maximum price per unit hour that you are willing to pay for
        a Spot Instance.
      name: OverrideMaxPrice
    - description: The ID of the subnet in which to launch the instances.
      name: OverrideSubnetId
    - description: The Availability Zone in which to launch the instances.
      name: OverrideAvailabilityZone
    - description: The number of units provided by the specified instance type.
      name: OverrideWeightedCapacity
    - description: The priority for the launch template override.
      name: OverridePriority
    - description: The number of units to request, filled using DefaultTargetCapacityType
        .
      name: TotalTargetCapacity
      required: true
    - description: The number of On-Demand units to request.
      name: OnDemandTargetCapacity
      required: true
    - description: The number of Spot units to request.
      name: SpotTargetCapacity
      required: true
    - description: The default TotalTargetCapacity, which is either Spot or On-Demand
        .
      name: DefaultTargetCapacityType
      required: true
    - description: The type of the request.
      name: Type
    - description: The start date and time of the request, in UTC format (for example,
        YYYY -MM -DD T*HH* :MM :SS Z).
      name: ValidFrom
    - description: The end date and time of the request, in UTC format (for example,
        YYYY -MM -DD T*HH* :MM :SS Z).
      name: ValidUntil
    - description: Indicates whether EC2 Fleet should replace unhealthy instances.
      name: ReplaceUnhealthyInstances
    - description: The tags to apply to the resource.
      name: Tags
    description: Launches an EC2 Fleet.
    name: aws-ec2-create-fleet
    outputs:
    - contextPath: AWS.EC2.Fleet.FleetId
      description: The ID of the EC2 Fleet.
      type: String
    - contextPath: AWS.EC2.Fleet.Errors
      description: Information about the instances that could not be launched by the
        fleet. Valid only when Type is set to instant.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateId
      description: The ID of the launch template. You must specify either a template
        ID or a template name.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateName
      description: The name of the launch template. You must specify either a template
        name or a template ID.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.LaunchTemplateSpecification.Version
      description: The version number of the launch template. You must specify a version
        number.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.InstanceType
      description: The instance type.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.MaxPrice
      description: The maximum price per unit hour that you are willing to pay for
        a Spot Instance.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.SubnetId
      description: The ID of the subnet in which to launch the instances.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.AvailabilityZone
      description: The Availability Zone in which to launch the instances.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.WeightedCapacity
      description: The number of units provided by the specified instance type.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.Priority
      description: The priority for the launch template override.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Overrides.Placement.GroupName
      description: The name of the placement group the instance is in.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.Lifecycle
      description: Indicates if the instance that could not be launched was a Spot
        Instance or On-Demand Instance.
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.ErrorCode
      description: 'The error code that indicates why the instance could not be launched. '
      type: String
    - contextPath: AWS.EC2.Fleet.LaunchTemplateAndOverrides.ErrorMessage
      description: The error message that describes why the instance could not be
        launched.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateId
      description: The ID of the launch template. You must specify either a template
        ID or a template name.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateName
      description: The name of the launch template. You must specify either a template
        name or a template ID.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.LaunchTemplateSpecification.Version
      description: The version number of the launch template. You must specify a version
        number.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.InstanceType
      description: The instance type.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.MaxPrice
      description: The maximum price per unit hour that you are willing to pay for
        a Spot Instance.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.SubnetId
      description: The ID of the subnet in which to launch the instances.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.AvailabilityZone
      description: The Availability Zone in which to launch the instances.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.WeightedCapacity
      description: The number of units provided by the specified instance type.
      type: Number
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.Priority
      description: The priority for the launch template override.
      type: Number
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.Placement.GroupName
      description: The name of the placement group the instance is in.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.Lifecycle
      description: Indicates if the instance that was launched is a Spot Instance
        or On-Demand Instance.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.InstanceIds
      description: The IDs of the instances.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.InstanceType
      description: The instance type.
      type: String
    - contextPath: AWS.EC2.Fleet.Instances.LaunchTemplateAndOverrides.Overrides.Platform
      description: The value is Windows for Windows instances; otherwise blank.
      type: String
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: Checks whether you have the required permissions for the action,
        without actually making the request, and provides an error response.
      name: DryRun
    - description: The IDs of the EC2 Fleets.
      name: FleetIds
      required: true
    - description: Indicates whether to terminate instances for an EC2 Fleet if it
        is deleted successfully.
      name: TerminateInstances
      required: true
    description: Deletes the specified EC2 Fleet.
    name: aws-ec2-delete-fleet
    outputs:
    - contextPath: AWS.EC2.DeletedFleets.SuccessfulFleetDeletions.CurrentFleetState
      description: The current state of the EC2 Fleet.
      type: String
    - contextPath: AWS.EC2.DeletedFleets.SuccessfulFleetDeletions.PreviousFleetState
      description: The previous state of the EC2 Fleet.
      type: String
    - contextPath: AWS.EC2.DeletedFleets.SuccessfulFleetDeletions.FleetId
      description: The ID of the EC2 Fleet.
      type: String
    - contextPath: AWS.EC2.DeletedFleets.UnsuccessfulFleetDeletions.Error.Code
      description: The error code.
      type: String
    - contextPath: AWS.EC2.DeletedFleets.UnsuccessfulFleetDeletions.Error.Message
      description: The description for the error code.
      type: String
    - contextPath: AWS.EC2.DeletedFleets.UnsuccessfulFleetDeletions.FleetId
      description: The ID of the EC2 Fleet.
      type: String
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: One or more filters.
      name: filters
    - description: The ID of the EC2 Fleets.
      name: FleetIds
    - description: The maximum number of results to return in a single call. Specify
        a value between 1 and 1000.
      name: MaxResults
    - description: The token for the next set of results.
      name: NextToken
    description: Describes one or more of your EC2 Fleets.
    name: aws-ec2-describe-fleets
    outputs:
    - contextPath: AWS.EC2.Fleet.NextToken
      description: The token for the next set of results.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.ActivityStatus
      description: 'The progress of the EC2 Fleet. If there is an error, the status
        is error . '
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.CreateTime
      description: The creation date and time of the EC2 Fleet.
      type: date
    - contextPath: AWS.EC2.Fleet.Fleets.FleetId
      description: The ID of the EC2 Fleet.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.FleetState
      description: The state of the EC2 Fleet.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.ClientToken
      description: Unique, case-sensitive identifier you provide to ensure the idempotency
        of the request.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.ExcessCapacityTerminationPolicy
      description: Indicates whether running instances should be terminated if the
        target capacity of the EC2 Fleet is decreased below the current size of the
        EC2 Fleet.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.FulfilledCapacity
      description: The number of units fulfilled by this request compared to the set
        target capacity.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.FulfilledOnDemandCapacity
      description: The number of units fulfilled by this request compared to the set
        target On-Demand capacity.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.LaunchTemplateId
      description: The ID of the launch template. You must specify either a template
        ID or a template name.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.LaunchTemplateName
      description: The name of the launch template. You must specify either a template
        name or a template ID.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Version
      description: The version number of the launch template. You must specify a version
        number.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.InstanceType
      description: The instance type.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.MaxPrice
      description: The maximum price per unit hour that you are willing to pay for
        a Spot Instance.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.SubnetId
      description: The ID of the subnet in which to launch the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.AvailabilityZone
      description: The Availability Zone in which to launch the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.WeightedCapacity
      description: The number of units provided by the specified instance type.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.Priority
      description: The priority for the launch template override.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.LaunchTemplateConfigs.LaunchTemplateSpecification.Overrides.Placement.GroupName
      description: The name of the placement group the instance is in.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.TargetCapacitySpecification.TotalTargetCapacity
      description: The number of units to request, filled using DefaultTargetCapacityType
        .
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.TargetCapacitySpecification.OnDemandTargetCapacity
      description: The number of On-Demand units to request.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.TargetCapacitySpecification.SpotTargetCapacity
      description: The maximum number of Spot units to launch.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.TargetCapacitySpecification.DefaultTargetCapacityType
      description: The default TotalTargetCapacity , which is either Spot or On-Demand.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.TerminateInstancesWithExpiration
      description: Indicates whether running instances should be terminated when the
        EC2 Fleet expires.
      type: boolean
    - contextPath: AWS.EC2.Fleet.Fleets.Type
      description: The type of request. Indicates whether the EC2 Fleet only requests
        the target capacity, or also attempts to maintain it.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.ValidFrom
      description: The start date and time of the request, in UTC format (for example,
        YYYY -MM -DD T*HH* :MM :SS Z).
      type: date
    - contextPath: AWS.EC2.Fleet.Fleets.ValidUntil
      description: The end date and time of the request, in UTC format (for example,
        YYYY -MM -DD T*HH* :MM :SS Z).
      type: date
    - contextPath: AWS.EC2.Fleet.Fleets.ReplaceUnhealthyInstances
      description: Indicates whether EC2 Fleet should replace unhealthy instances.
      type: boolean
    - contextPath: AWS.EC2.Fleet.Fleets.SpotOptions.AllocationStrategy
      description: Indicates how to allocate the target capacity across the Spot pools
        specified by the Spot Fleet request.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.SpotOptions.InstanceInterruptionBehavior
      description: The behavior when a Spot Instance is interrupted. The default is
        terminate.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.SpotOptions.InstancePoolsToUseCount
      description: The number of Spot pools across which to allocate your target Spot
        capacity.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.SpotOptions.SingleInstanceType
      description: Indicates that the fleet uses a single instance type to launch
        all Spot Instances in the fleet.
      type: boolean
    - contextPath: AWS.EC2.Fleet.Fleets.SpotOptions.SingleAvailabilityZone
      description: Indicates that the fleet launches all Spot Instances into a single
        Availability Zone.
      type: boolean
    - contextPath: AWS.EC2.Fleet.Fleets.SpotOptions.MinTargetCapacity
      description: The minimum target capacity for Spot Instances in the fleet.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.OnDemandOptions.AllocationStrategy
      description: The order of the launch template overrides to use in fulfilling
        On-Demand capacity.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.OnDemandOptions.SingleInstanceType
      description: Indicates that the fleet uses a single instance type to launch
        all On-Demand Instances in the fleet.
      type: boolean
    - contextPath: AWS.EC2.Fleet.Fleets.OnDemandOptions.SingleAvailabilityZone
      description: Indicates that the fleet launches all On-Demand Instances into
        a single Availability Zone.
      type: boolean
    - contextPath: AWS.EC2.Fleet.Fleets.OnDemandOptions.MinTargetCapacity
      description: 'The minimum target capacity for On-Demand Instances in the fleet. '
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.Tags.Key
      description: The key of the tag.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Tags.Value
      description: The value of the tag.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateId
      description: The ID of the launch template. You must specify either a template
        ID or a template name.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateName
      description: The name of the launch template. You must specify either a template
        name or a template ID.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.LaunchTemplateAndOverrides.LaunchTemplateSpecification.Version
      description: The version number of the launch template. You must specify a version
        number.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.InstanceType
      description: The instance type.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.MaxPrice
      description: The maximum price per unit hour that you are willing to pay for
        a Spot Instance.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.SubnetId
      description: The ID of the subnet in which to launch the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.AvailabilityZone
      description: The Availability Zone in which to launch the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.WeightedCapacity
      description: The number of units provided by the specified instance type.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.Priority
      description: The priority for the launch template override.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Overrides.Placement.GroupName
      description: The name of the placement group the instance is in.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.Lifecycle
      description: Indicates if the instance that could not be launched was a Spot
        Instance or On-Demand Instance.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.ErrorCode
      description: The error code that indicates why the instance could not be launched.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Errors.ErrorMessage
      description: The error message that describes why the instance could not be
        launched.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateId
      description: The ID of the launch template. You must specify either a template
        ID or a template name.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.LaunchTemplateSpecification.LaunchTemplateName
      description: The name of the launch template. You must specify either a template
        name or a template ID.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.LaunchTemplateSpecification.Version
      description: The version number of the launch template. You must specify a version
        number.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.InstanceType
      description: The instance type.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.MaxPrice
      description: The maximum price per unit hour that you are willing to pay for
        a Spot Instance.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.SubnetId
      description: The ID of the subnet in which to launch the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.AvailabilityZone
      description: The Availability Zone in which to launch the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.WeightedCapacity
      description: The number of units provided by the specified instance type.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.Priority
      description: The priority for the launch template override.
      type: number
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.LaunchTemplateAndOverrides.Overrides.Placement.GroupName
      description: The name of the placement group the instance is in.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.Lifecycle
      description: Indicates if the instance that was launched is a Spot Instance
        or On-Demand Instance.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.InstanceIds
      description: The IDs of the instances.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.InstanceType
      description: The instance type.
      type: string
    - contextPath: AWS.EC2.Fleet.Fleets.Instances.Platform
      description: The value is Windows for Windows instances; otherwise blank.
      type: string
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: A filter name and value pair that is used to return a more specific
        list of results from a describe operation.
      name: filters
    - description: The ID of the EC2 Fleet.
      name: FleetId
      required: true
    - description: The maximum number of results to return in a single call. Specify
        a value between 1 and 1000.
      name: MaxResults
    - description: The token for the next set of results.
      name: NextToken
    description: Describes the running instances for the specified EC2 Fleet.
    name: aws-ec2-describe-fleet-instances
    outputs:
    - contextPath: AWS.EC2.Fleet.ActiveInstances.InstanceId
      description: The ID of the instance.
      type: String
    - contextPath: AWS.EC2.Fleet.ActiveInstances.InstanceType
      description: The instance type.
      type: String
    - contextPath: AWS.EC2.Fleet.ActiveInstances.SpotInstanceRequestId
      description: The ID of the Spot Instance request.
      type: String
    - contextPath: AWS.EC2.Fleet.ActiveInstances.InstanceHealth
      description: The health status of the instance.
      type: String
    - contextPath: AWS.EC2.Fleet.NextToken
      description: The token for the next set of results.
      type: String
    - contextPath: AWS.EC2.Fleet.FleetId
      description: The ID of the EC2 Fleet.
      type: String
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: The ID of the EC2 Fleet.
      name: FleetId
      required: true
    - description: The number of units to request, filled using DefaultTargetCapacityType.
      name: TotalTargetCapacity
      required: true
    - description: The number of On-Demand units to request.
      name: OnDemandTargetCapacity
    - description: The number of Spot units to request.
      name: SpotTargetCapacity
    - description: The default TotalTargetCapacity, which is either Spot or On-Demand.
      name: DefaultTargetCapacityType
    description: Modifies the specified EC2 Fleet.
    name: aws-ec2-modify-fleet
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: Unique, case-sensitive identifier you provide to ensure the idempotency
        of the request.
      name: ClientToken
    - description: A name for the launch template.
      name: LaunchTemplateName
      required: true
    - description: A description for the first version of the launch template.
      name: VersionDescription
    - description: The ID of the kernel.
      name: KernelId
    - auto: PREDEFINED
      description: Indicates whether the instance is optimized for Amazon EBS I/O.
      name: EbsOptimized
      predefined:
      - "True"
      - "False"
    - description: The Amazon Resource Name (ARN) of the instance profile.
      name: iamInstanceProfileArn
    - description: The name of the instance profile.
      name: iamInstanceProfileName
    - description: The device name (for example, /dev/sdh or xvdh).
      name: deviceName
    - description: The virtual device name (ephemeralN). Instance store volumes are
        numbered starting from 0.
      name: VirtualName
    - auto: PREDEFINED
      description: Indicates whether the EBS volume is encrypted.
      name: ebsEncrypted
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: Indicates whether the EBS volume is deleted on instance termination.
      name: ebsDeleteOnTermination
      predefined:
      - "True"
      - "False"
    - description: The number of I/O operations per second (IOPS) that the volume
        supports.
      name: ebsIops
    - description: The ARN of the AWS Key Management Service (AWS KMS) CMK used for
        encryption.
      name: ebsKmsKeyId
    - description: The ID of the snapshot.
      name: ebsSnapshotId
    - description: The size of the volume, in GiB.
      name: ebsVolumeSize
    - description: The volume type.
      name: ebsVolumeType
    - description: Suppresses the specified device included in the block device mapping
        of the AMI.
      name: NoDevice
    - auto: PREDEFINED
      description: Associates a public IPv4 address with eth0 for a new network interface.
      name: AssociatePublicIpAddress
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: Indicates whether the network interface is deleted when the instance
        is terminated.
      name: NetworkInterfacesDeleteOnTermination
      predefined:
      - "True"
      - "False"
    - description: A description for the network interface.
      name: NetworkInterfacesDescription
    - description: The device index for the network interface attachment.
      name: NetworkInterfacesDeviceIndex
    - description: The IDs of one or more security groups.
      name: NetworkInterfaceGroups
    - description: 'The number of IPv6 addresses to assign to a network interface. '
      name: Ipv6AddressCount
    - description: One or more specific IPv6 addresses from the IPv6 CIDR block range
        of your subnet.
      name: Ipv6Addresses
    - description: The ID of the network interface.
      name: NetworkInterfaceId
    - description: The primary private IPv4 address of the network interface.
      name: PrivateIpAddress
    - description: The ID of the subnet for the network interface.
      name: SubnetId
    - description: The ID of the AMI, which you can get by using DescribeImages.
      name: ImageId
    - description: The instance type.
      name: InstanceType
    - description: The name of the key pair.
      name: KeyName
    - auto: PREDEFINED
      description: Specify true to enable detailed monitoring. Otherwise, basic monitoring
        is enabled.
      name: Monitoring
      predefined:
      - "True"
      - "False"
    - description: The Availability Zone for the instance.
      name: AvailabilityZone
    - description: The affinity setting for an instance on a Dedicated Host.
      name: PlacementAffinity
    - description: The name of the placement group for the instance.
      name: AvailabilityZoneGroupName
    - description: The ID of the Dedicated Host for the instance.
      name: PlacementHostId
    - description: The tenancy of the instance (if the instance is running in a VPC).
      name: PlacementTenancy
    - description: Reserved for future use.
      name: PlacementSpreadDomain
    - description: The ID of the RAM disk.
      name: RamDiskId
    - auto: PREDEFINED
      description: If set to true , you can't terminate the instance using the Amazon
        EC2 console, CLI, or API.
      name: DisableApiTermination
      predefined:
      - "True"
      - "False"
    - description: Indicates whether an instance stops or terminates when you initiate
        shutdown from the instance (using the operating system command for system
        shutdown).
      name: InstanceInitiatedShutdownBehavior
    - description: The Base64-encoded user data to make available to the instance.
      name: UserData
    - description: The tags to apply to the resource.
      name: Tags
    - description: The type of Elastic Graphics accelerator.
      name: ElasticGpuSpecificationsType
    - description: The type of elastic inference accelerator. The possible values
        are eia1.medium, eia1.large, and eia1.xlarge.
      name: ElasticInferenceAcceleratorsType
    - description: One or more security group IDs.
      name: securityGroupIds
    - description: One or more security group names.
      name: securityGroups
    - description: The market type.
      name: MarketType
    - description: The Spot Instance request type.
      name: SpotInstanceType
    - description: The required duration for the Spot Instances (also known as Spot
        blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240,
        300, or 360).
      name: BlockDurationMinutes
    - description: The end date of the request.
      name: SpotValidUntil
    - description: The behavior when a Spot Instance is interrupted. The default is
        terminate.
      name: SpotInstanceInterruptionBehavior
    - description: The maximum hourly price you're willing to pay for the Spot Instances.
      name: SpotMaxPrice
    description: Creates a launch template. A launch template contains the parameters
      to launch an instance.
    name: aws-ec2-create-launch-template
    outputs:
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.LaunchTemplateId
      description: The ID of the launch template.
      type: String
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.LaunchTemplateName
      description: The name of the launch template.
      type: String
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.CreateTime
      description: The time launch template was created.
      type: Date
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.CreatedBy
      description: The principal that created the launch template.
      type: String
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.DefaultVersionNumber
      description: The version number of the default version of the launch template.
      type: Number
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.LatestVersionNumber
      description: The version number of the latest version of the launch template.
      type: Number
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.Tags.Key
      description: The key of the tag.
      type: String
    - contextPath: AWS.EC2.LaunchTemplates.LaunchTemplate.Tags.Value
      description: The value of the tag.
      type: String
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: The ID of the launch template.
      name: LaunchTemplateId
    - description: The name of the launch template.
      name: LaunchTemplateName
    description: Deletes a launch template. Deleting a launch template deletes all
      of its versions.
    name: aws-ec2-delete-launch-template
    outputs:
    - contextPath: AWS.EC2.DeletedLaunchTemplates.LaunchTemplate.LaunchTemplateId
      description: The ID of the launch template.
      type: String
    - contextPath: AWS.EC2.DeletedLaunchTemplates.LaunchTemplate.LaunchTemplateName
      description: The name of the launch template.
      type: String
    - contextPath: AWS.EC2.DeletedLaunchTemplates.LaunchTemplate.CreateTime
      description: The time launch template was created.
      type: Date
    - contextPath: AWS.EC2.DeletedLaunchTemplates.LaunchTemplate.CreatedBy
      description: The principal that created the launch template.
      type: String
    - contextPath: AWS.EC2.DeletedLaunchTemplates.LaunchTemplate.DefaultVersionNumber
      description: The version number of the default version of the launch template.
      type: Number
    - contextPath: AWS.EC2.DeletedLaunchTemplates.LaunchTemplate.LatestVersionNumber
      description: The version number of the latest version of the launch template.
      type: Number
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    - description: The name of the attribute to modify. The valid values are description,
        launchPermission, and productCodes.
      name: Attribute
    - description: A new description for the AMI.
      name: Description
    - description: The ID of the AMI.
      name: ImageId
      required: true
    - description: The name of the group.
      name: LaunchPermission-Add-Group
    - description: The AWS account ID.
      name: LaunchPermission-Add-UserId
    - description: The name of the group.
      name: LaunchPermission-Remove-Group
    - description: The AWS account ID.
      name: LaunchPermission-Remove-UserId
    - description: The operation type.
      name: OperationType
    - description: One or more DevPay product codes. After you add a product code
        to an AMI, it can't be removed.
      name: ProductCodes
    - description: One or more user groups. This parameter can be used only when the
        Attribute parameter is launchPermission.
      name: UserGroups
    - description: One or more AWS account IDs. This parameter can be used only when
        the Attribute parameter is launchPermission.
      name: UserIds
    - description: The value of the attribute being modified. This parameter can be
        used only when the Attribute parameter is description or productCodes.
      name: Value
    description: Modifies the specified attribute of the specified AMI.
    name: aws-ec2-modify-image-attribute
  dockerimage: demisto/boto3:1.9.55
  runonce: false
  script: |2-



    import boto3
    import json
    import re
    from datetime import datetime, date
    from botocore.config import Config
    from botocore.parsers import ResponseParserError

    import urllib3.util

    # Disable insecure warnings
    urllib3.disable_warnings()

    """PARAMETERS"""
    AWS_DEFAULT_REGION = demisto.params().get('defaultRegion')
    AWS_ROLE_ARN = demisto.params().get('roleArn')
    AWS_ROLE_SESSION_NAME = demisto.params().get('roleSessionName')
    AWS_ROLE_SESSION_DURATION = demisto.params().get('sessionDuration')
    AWS_ROLE_POLICY = None
    AWS_ACCESS_KEY_ID = demisto.params().get('access_key')
    AWS_SECRET_ACCESS_KEY = demisto.params().get('secret_key')
    VERIFY_CERTIFICATE = not demisto.params().get('insecure', True)
    proxies = handle_proxy(proxy_param_name='proxy', checkbox_default_value=False)
    config = Config(
        connect_timeout=1,
        retries=dict(
            max_attempts=5
        ),
        proxies=proxies
    )


    """HELPER FUNCTIONS"""


    def aws_session(service='ec2', region=None, roleArn=None, roleSessionName=None, roleSessionDuration=None,
                    rolePolicy=None):
        kwargs = {}
        if roleArn and roleSessionName is not None:
            kwargs.update({
                'RoleArn': roleArn,
                'RoleSessionName': roleSessionName,
            })
        elif AWS_ROLE_ARN and AWS_ROLE_SESSION_NAME is not None:
            kwargs.update({
                'RoleArn': AWS_ROLE_ARN,
                'RoleSessionName': AWS_ROLE_SESSION_NAME,
            })

        if roleSessionDuration is not None:
            kwargs.update({'DurationSeconds': int(roleSessionDuration)})
        elif AWS_ROLE_SESSION_DURATION is not None:
            kwargs.update({'DurationSeconds': int(AWS_ROLE_SESSION_DURATION)})

        if rolePolicy is not None:
            kwargs.update({'Policy': rolePolicy})
        elif AWS_ROLE_POLICY is not None:
            kwargs.update({'Policy': AWS_ROLE_POLICY})
        if kwargs and AWS_ACCESS_KEY_ID is None:

            if AWS_ACCESS_KEY_ID is None:
                sts_client = boto3.client('sts', config=config, verify=VERIFY_CERTIFICATE)
                sts_response = sts_client.assume_role(**kwargs)
                if region is not None:
                    client = boto3.client(
                        service_name=service,
                        region_name=region,
                        aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                        aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                        aws_session_token=sts_response['Credentials']['SessionToken'],
                        verify=VERIFY_CERTIFICATE,
                        config=config
                    )
                else:
                    client = boto3.client(
                        service_name=service,
                        region_name=AWS_DEFAULT_REGION,
                        aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                        aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                        aws_session_token=sts_response['Credentials']['SessionToken'],
                        verify=VERIFY_CERTIFICATE,
                        config=config
                    )
        elif AWS_ACCESS_KEY_ID and AWS_ROLE_ARN:
            sts_client = boto3.client(
                service_name='sts',
                aws_access_key_id=AWS_ACCESS_KEY_ID,
                aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
                verify=VERIFY_CERTIFICATE,
                config=config
            )
            kwargs.update({
                'RoleArn': AWS_ROLE_ARN,
                'RoleSessionName': AWS_ROLE_SESSION_NAME,
            })
            sts_response = sts_client.assume_role(**kwargs)
            client = boto3.client(
                service_name=service,
                region_name=AWS_DEFAULT_REGION,
                aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                aws_session_token=sts_response['Credentials']['SessionToken'],
                verify=VERIFY_CERTIFICATE,
                config=config
            )
        else:
            if region is not None:
                client = boto3.client(
                    service_name=service,
                    region_name=region,
                    aws_access_key_id=AWS_ACCESS_KEY_ID,
                    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
                    verify=VERIFY_CERTIFICATE,
                    config=config
                )
            else:
                client = boto3.client(
                    service_name=service,
                    region_name=AWS_DEFAULT_REGION,
                    aws_access_key_id=AWS_ACCESS_KEY_ID,
                    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
                    verify=VERIFY_CERTIFICATE,
                    config=config
                )

        return client


    def parse_filter_field(filter_str):
        filters = []
        regex = re.compile(r'name=([\w\d_:.-]+),values=([ /\w\d@_,.*-]+)', flags=re.I)
        for f in filter_str.split(';'):
            match = regex.match(f)
            if match is None:
                demisto.log('could not parse filter: %s' % (f,))
                continue

            filters.append({
                'Name': match.group(1),
                'Values': match.group(2).split(',')
            })

        return filters


    def parse_tag_field(tags_str):
        tags = []
        regex = re.compile(r'key=([\w\d_:.-]+),value=([ /\w\d@_,.*-]+)', flags=re.I)
        for f in tags_str.split(';'):
            match = regex.match(f)
            if match is None:
                demisto.log('could not parse field: %s' % (f,))
                continue

            tags.append({
                'Key': match.group(1),
                'Value': match.group(2)
            })

        return tags


    class DatetimeEncoder(json.JSONEncoder):
        # pylint: disable=method-hidden
        def default(self, obj):
            if isinstance(obj, datetime):
                return obj.strftime('%Y-%m-%dT%H:%M:%S')
            elif isinstance(obj, date):
                return obj.strftime('%Y-%m-%d')
            # Let the base class default method raise the TypeError
            return json.JSONEncoder.default(self, obj)


    def parse_resource_ids(resource_id):
        id_list = resource_id.replace(" ", "")
        resourceIds = id_list.split(",")
        return resourceIds


    def multi_split(data):
        data = data.replace(" ", "")
        data = data.split(";")
        return data


    def parse_date(dt):
        try:
            arr = dt.split("-")
            parsed_date = (datetime(int(arr[0]), int(arr[1]), int(arr[2]))).isoformat()
        except ValueError as e:
            return_error("Date could not be parsed. Please check the date again.\n{error}".format(error=type(e)))
        return parsed_date


    """MAIN FUNCTIONS"""


    def describe_regions_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        data = []
        kwargs = {}
        if args.get('regionNames') is not None:
            kwargs.update({'RegionNames': parse_resource_ids(args.get('regionNames'))})

        response = client.describe_regions(**kwargs)
        for region in response['Regions']:
            data.append({
                'Endpoint': region['Endpoint'],
                'RegionName': region['RegionName']
            })

        ec = {'AWS.Regions(val.RegionName === obj.RegionName)': data}
        human_readable = tableToMarkdown('AWS Regions', data)
        return_outputs(human_readable, ec)


    def describe_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        data = []
        kwargs = {}
        output = []
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('instanceIds') is not None:
            kwargs.update({'InstanceIds': parse_resource_ids(args.get('instanceIds'))})

        response = client.describe_instances(**kwargs)
        for i, reservation in enumerate(response['Reservations']):
            for instance in reservation['Instances']:
                try:
                    launch_date = datetime.strftime(instance['LaunchTime'], '%Y-%m-%dT%H:%M:%SZ')
                except ValueError as e:
                    return_error('Date could not be parsed. Please check the date again.\n{error}'.format(error=type(e)))
                data.append({
                    'InstanceId': instance['InstanceId'],
                    'ImageId': instance['ImageId'],
                    'State': instance['State']['Name'],
                    'PublicIPAddress': instance.get('PublicIpAddress'),
                    'Region': obj['_user_provided_options']['region_name'],
                    'Type': instance['InstanceType'],
                    'LaunchDate': launch_date,
                    'PublicDNSName': instance['PublicDnsName'],
                    'Monitoring': instance['Monitoring']['State'],
                })
                if 'Tags' in instance:
                    for tag in instance['Tags']:
                        data[i].update({
                            tag['Key']: tag['Value']
                        })
                if 'KeyName' in instance:
                    data[i].update({'KeyName': instance['KeyName']})

            instance.update({'Region': obj['_user_provided_options']['region_name']})
            output.append(instance)

        try:
            raw = json.loads(json.dumps(output, cls=DatetimeEncoder))
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Instances(val.InstanceId === obj.InstanceId)': raw}
        human_readable = tableToMarkdown('AWS Instances', data)
        return_outputs(human_readable, ec)


    def describe_images_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('imageIds') is not None:
            kwargs.update({'ImageIds': parse_resource_ids(args.get('imageIds'))})
        if args.get('owners') is not None:
            kwargs.update({'Owners': parse_resource_ids(args.get('owners'))})
        if args.get('executableUsers') is not None:
            kwargs.update({'ExecutableUsers': parse_resource_ids(args.get('executableUsers'))})

        response = client.describe_images(**kwargs)
        for i, image in enumerate(response['Images']):
            data.append({
                'CreationDate': image['CreationDate'],
                'ImageId': image['ImageId'],
                'Public': image['Public'],
                'State': image['State'],
                'Region': obj['_user_provided_options']['region_name'],
            })
            if 'Description' in image:
                data[i].update({'Description': image['Description']})
            if 'EnaSupport' in image:
                data[i].update({'EnaSupport': image['EnaSupport']})
            if 'Name' in image:
                data[i].update({'Name': image['Name']})
            if 'Tags' in image:
                for tag in image['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })
        try:
            output = json.dumps(response['Images'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Images(val.ImageId === obj.ImageId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Images', data)
        return_outputs(human_readable, ec)


    def describe_addresses_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('publicIps') is not None:
            kwargs.update({'PublicIps': parse_resource_ids(args.get('publicIps'))})
        if args.get('allocationIds') is not None:
            kwargs.update({'AllocationIds': parse_resource_ids(args.get('allocationIds'))})

        response = client.describe_addresses(**kwargs)

        for i, address in enumerate(response['Addresses']):
            data.append({
                'PublicIp': address['PublicIp'],
                'AllocationId': address['AllocationId'],
                'Domain': address['Domain'],
                'Region': obj['_user_provided_options']['region_name'],
            })
            if 'InstanceId' in address:
                data[i].update({'InstanceId': address['InstanceId']})
            if 'AssociationId' in address:
                data[i].update({'AssociationId': address['AssociationId']})
            if 'NetworkInterfaceId' in address:
                data[i].update({'NetworkInterfaceId': address['NetworkInterfaceId']})
            if 'PrivateIpAddress' in address:
                data[i].update({'PrivateIpAddress': address['PrivateIpAddress']})
            if 'Tags' in address:
                for tag in address['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })

        raw = response['Addresses']
        raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        ec = {'AWS.EC2.ElasticIPs(val.AllocationId === obj.AllocationId)': raw}
        human_readable = tableToMarkdown('AWS EC2 ElasticIPs', data)
        return_outputs(human_readable, ec)


    def describe_snapshots_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('ownerIds') is not None:
            kwargs.update({'OwnerIds': parse_resource_ids(args.get('ownerIds'))})
        if args.get('snapshotIds') is not None:
            kwargs.update({'SnapshotIds': parse_resource_ids(args.get('snapshotIds'))})
        if args.get('restorableByUserIds') is not None:
            kwargs.update({'RestorableByUserIds': parse_resource_ids(args.get('restorableByUserIds'))})

        response = client.describe_snapshots(**kwargs)

        for i, snapshot in enumerate(response['Snapshots']):
            try:
                start_time = datetime.strftime(snapshot['StartTime'], '%Y-%m-%dT%H:%M:%SZ')
            except ValueError as e:
                return_error('Date could not be parsed. Please check the date again.\n{error}'.format(error=type(e)))
            data.append({
                'Description': snapshot['Description'],
                'Encrypted': snapshot['Encrypted'],
                'OwnerId': snapshot['OwnerId'],
                'Progress': snapshot['Progress'],
                'SnapshotId': snapshot['SnapshotId'],
                'StartTime': start_time,
                'State': snapshot['State'],
                'VolumeId': snapshot['VolumeId'],
                'VolumeSize': snapshot['VolumeSize'],
                'Region': obj['_user_provided_options']['region_name'],
            })
            if 'Tags' in snapshot:
                for tag in snapshot['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })

        try:
            output = json.dumps(response['Snapshots'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Snapshots(val.SnapshotId === obj.SnapshotId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Snapshots', data)
        return_outputs(human_readable, ec)


    def describe_volumes_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('volumeIds') is not None:
            kwargs.update({'VolumeIds': parse_resource_ids(args.get('volumeIds'))})

        response = client.describe_volumes(**kwargs)

        for i, volume in enumerate(response['Volumes']):
            try:
                create_date = datetime.strftime(volume['CreateTime'], '%Y-%m-%dT%H:%M:%SZ')
            except ValueError as e:
                return_error('Date could not be parsed. Please check the date again.\n{error}'.format(error=type(e)))
            data.append({
                'AvailabilityZone': volume['AvailabilityZone'],
                'Encrypted': volume['Encrypted'],
                'State': volume['State'],
                'VolumeId': volume['VolumeId'],
                'VolumeType': volume['VolumeType'],
                'CreateTime': create_date,
            })
            if 'Tags' in volume:
                for tag in volume['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })
        try:
            output = json.dumps(response['Volumes'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Volumes(val.VolumeId === obj.VolumeId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Volumes', data)
        return_outputs(human_readable, ec)


    def describe_launch_templates_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('launchTemplateIds') is not None:
            kwargs.update({'LaunchTemplateIds': parse_resource_ids(args.get('launchTemplateIds'))})
        if args.get('launchTemplateNames') is not None:
            kwargs.update({'LaunchTemplateNames': parse_resource_ids(args.get('launchTemplateNamess'))})

        response = client.describe_launch_templates(**kwargs)

        for i, template in enumerate(response['LaunchTemplates']):
            try:
                create_time = datetime.strftime(template['CreateTime'], '%Y-%m-%dT%H:%M:%SZ')
            except ValueError as e:
                return_error('Date could not be parsed. Please check the date again.\n{error}'.format(error=type(e)))
            data.append({
                'LaunchTemplateId': template['LaunchTemplateId'],
                'LaunchTemplateName': template['LaunchTemplateName'],
                'CreatedBy': template['CreatedBy'],
                'DefaultVersionNumber': template['DefaultVersionNumber'],
                'LatestVersionNumber': template['LatestVersionNumber'],
                'CreateTime': create_time,
                'Region': obj['_user_provided_options']['region_name'],
            })

            if 'Tags' in template:
                for tag in template['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })

        try:
            output = json.dumps(response['LaunchTemplates'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.LaunchTemplates(val.LaunchTemplateId === obj.LaunchTemplateId)': raw}
        human_readable = tableToMarkdown('AWS EC2 LaunchTemplates', data)
        return_outputs(human_readable, ec)


    def describe_key_pairs_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('keyNames') is not None:
            kwargs.update({'KeyNames': parse_resource_ids(args.get('keyNames'))})

        response = client.describe_key_pairs(**kwargs)

        for key in response['KeyPairs']:
            data.append({
                'KeyFingerprint': key['KeyFingerprint'],
                'KeyName': key['KeyName'],
                'Region': obj['_user_provided_options']['region_name'],
            })

        ec = {'AWS.EC2.KeyPairs(val.KeyName === obj.KeyName)': data}
        human_readable = tableToMarkdown('AWS EC2 Key Pairs', data)
        return_outputs(human_readable, ec)


    def describe_vpcs_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('vpcIds') is not None:
            kwargs.update({'VpcIds': parse_resource_ids(args.get('vpcIds'))})

        response = client.describe_vpcs(**kwargs)

        for i, vpc in enumerate(response['Vpcs']):
            data.append({
                'CidrBlock': vpc['CidrBlock'],
                'DhcpOptionsId': vpc['DhcpOptionsId'],
                'State': vpc['State'],
                'VpcId': vpc['VpcId'],
                'InstanceTenancy': vpc['InstanceTenancy'],
                'IsDefault': vpc['IsDefault'],
                'Region': obj['_user_provided_options']['region_name'],
            })

            if 'Tags' in vpc:
                for tag in vpc['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })

        try:
            output = json.dumps(response['Vpcs'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Vpcs(val.VpcId === obj.VpcId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Vpcs', data)
        return_outputs(human_readable, ec)


    def describe_subnets_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('subnetIds') is not None:
            kwargs.update({'SubnetIds': parse_resource_ids(args.get('subnetIds'))})

        response = client.describe_subnets(**kwargs)

        for i, subnet in enumerate(response['Subnets']):
            data.append({
                'AvailabilityZone': subnet['AvailabilityZone'],
                'AvailableIpAddressCount': subnet['AvailableIpAddressCount'],
                'CidrBlock': subnet['CidrBlock'],
                'DefaultForAz': subnet['DefaultForAz'],
                'State': subnet['State'],
                'SubnetId': subnet['SubnetId'],
                'VpcId': subnet['VpcId'],
                'Region': obj['_user_provided_options']['region_name'],
            })

            if 'Tags' in subnet:
                for tag in subnet['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })

        try:
            output = json.dumps(response['Subnets'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Subnets(val.SubnetId === obj.SubnetId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Subnets', data)
        return_outputs(human_readable, ec)


    def describe_security_groups_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {}
        data = []

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('groupIds') is not None:
            kwargs.update({'GroupIds': parse_resource_ids(args.get('groupIds'))})
        if args.get('groupNames') is not None:
            kwargs.update({'GroupNames': parse_resource_ids(args.get('groupNames'))})

        response = client.describe_security_groups(**kwargs)

        for i, sg in enumerate(response['SecurityGroups']):
            data.append({
                'Description': sg['Description'],
                'GroupName': sg['GroupName'],
                'OwnerId': sg['OwnerId'],
                'GroupId': sg['GroupId'],
                'VpcId': sg['VpcId'],
                'Region': obj['_user_provided_options']['region_name'],
            })

            if 'Tags' in sg:
                for tag in sg['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })

        try:
            output = json.dumps(response['SecurityGroups'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.SecurityGroups(val.GroupId === obj.GroupId)': raw}
        human_readable = tableToMarkdown('AWS EC2 SecurityGroups', data)
        return_outputs(human_readable, ec)


    def allocate_address_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)

        response = client.allocate_address(Domain='vpc')
        data = ({
            'PublicIp': response['PublicIp'],
            'AllocationId': response['AllocationId'],
            'Domain': response['Domain'],
            'Region': obj['_user_provided_options']['region_name']
        })
        ec = {'AWS.EC2.ElasticIPs': data}
        human_readable = tableToMarkdown('AWS EC2 ElasticIP', data)
        return_outputs(human_readable, ec)


    def associate_address_command(args):
        client = aws_session(
            service='ec2',
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {'AllocationId': args.get('allocationId')}

        if args.get('instanceId') is not None:
            kwargs.update({'InstanceId': args.get('instanceId')})
        if args.get('allowReassociation') is not None:
            kwargs.update({'AllowReassociation': True if args.get('allowReassociation') == 'True' else False})
        if args.get('networkInterfaceId') is not None:
            kwargs.update({'NetworkInterfaceId': args.get('networkInterfaceId')})
        if args.get('privateIpAddress') is not None:
            kwargs.update({'PrivateIpAddress': args.get('privateIpAddress')})

        response = client.associate_address(**kwargs)
        data = ({
            'AllocationId': args.get('allocationId'),
            'AssociationId': response['AssociationId'],
            'Region': obj['_user_provided_options']['region_name']
        })

        ec = {"AWS.EC2.ElasticIPs(val.AllocationId === obj.AllocationId)": data}
        human_readable = tableToMarkdown('AWS EC2 ElasticIP', data)
        return_outputs(human_readable, ec)


    def create_snapshot_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {'VolumeId': args.get('volumeId')}

        if args.get('description') is not None:
            kwargs.update({'Description': args.get('description')})
        if args.get('tags') is not None:
            kwargs.update({
                'TagSpecifications': [{
                    'ResourceType': 'snapshot',
                    'Tags': parse_tag_field(args.get('tags'))}]
            })

        response = client.create_snapshot(**kwargs)

        try:
            start_time = datetime.strftime(response['StartTime'], '%Y-%m-%dT%H:%M:%SZ')
        except ValueError as e:
            return_error('Date could not be parsed. Please check the date again.\n{error}'.format(error=type(e)))

        data = ({
            'Description': response['Description'],
            'Encrypted': response['Encrypted'],
            'Progress': response['Progress'],
            'SnapshotId': response['SnapshotId'],
            'State': response['State'],
            'VolumeId': response['VolumeId'],
            'VolumeSize': response['VolumeSize'],
            'StartTime': start_time,
            'Region': obj['_user_provided_options']['region_name'],
        })

        if 'Tags' in response:
            for tag in response['Tags']:
                data.update({
                    tag['Key']: tag['Value']
                })

        try:
            output = json.dumps(response, cls=DatetimeEncoder)
            raw = json.loads(output)
            del raw['ResponseMetadata']
            raw.update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Snapshots': raw}
        human_readable = tableToMarkdown('AWS EC2 Snapshots', data)
        return_outputs(human_readable, ec)


    def delete_snapshot_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        response = client.delete_snapshot(SnapshotId=args.get('snapshotId'))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Snapshot with ID: {snapshot_id} was deleted".format(snapshot_id=args.get('snapshotId')))


    def create_image_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {
            'Name': args.get('name'),
            'InstanceId': args.get('instanceId')
        }

        if args.get('description') is not None:
            kwargs.update({'Description': args.get('description')})
        if args.get('noReboot') is not None:
            kwargs.update({'NoReboot': True if args.get('noReboot') == 'True' else False})

        response = client.create_image(**kwargs)

        data = ({
            'ImageId': response['ImageId'],
            'Name': args.get('name'),
            'InstanceId': args.get('instanceId'),
            'Region': obj['_user_provided_options']['region_name'],
        })

        ec = {'AWS.EC2.Images': data}
        human_readable = tableToMarkdown('AWS EC2 Images', data)
        return_outputs(human_readable, ec)


    def deregister_image_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.deregister_image(ImageId=args.get('imageId'))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The AMI with ID: {image_id} was deregistered".format(image_id=args.get('imageId')))


    def modify_volume_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        obj = vars(client._client_config)
        kwargs = {'VolumeId': args.get('volumeId')}

        if args.get('size') is not None:
            kwargs.update({'Size': int(args.get('size'))})
        if args.get('volumeType') is not None:
            kwargs.update({'VolumeType': args.get('volumeType')})
        if args.get('iops') is not None:
            kwargs.update({'Iops': int(args.get('iops'))})

        response = client.modify_volume(**kwargs)
        volumeModification = response['VolumeModification']

        try:
            start_time = datetime.strftime(volumeModification['StartTime'], '%Y-%m-%dT%H:%M:%SZ')
        except ValueError as e:
            return_error('Date could not be parsed. Please check the date again.\n{error}'.format(error=type(e)))

        data = ({
            'VolumeId': volumeModification['VolumeId'],
            'ModificationState': volumeModification['ModificationState'],
            'TargetSize': volumeModification['TargetSize'],
            'TargetIops': volumeModification['TargetIops'],
            'TargetVolumeType': volumeModification['TargetVolumeType'],
            'OriginalSize': volumeModification['OriginalSize'],
            'OriginalIops': volumeModification['OriginalIops'],
            'OriginalVolumeType': volumeModification['OriginalVolumeType'],
            'StartTime': start_time,
            'Progress': volumeModification['Progress'],
            'Region': obj['_user_provided_options']['region_name'],
        })

        output = json.dumps(response['VolumeModification'], cls=DatetimeEncoder)
        raw = json.loads(output)
        raw.update({'Region': obj['_user_provided_options']['region_name']})

        ec = {'AWS.EC2.Volumes(val.VolumeId === obj.VolumeId).Modification': raw}
        human_readable = tableToMarkdown('AWS EC2 Volume Modification', data)
        return_outputs(human_readable, ec)


    def create_tags_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {
            'Resources': parse_resource_ids(args.get('resources')),
            'Tags': parse_tag_field(args.get('tags'))
        }
        response = client.create_tags(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The recources where taged successfully")


    def disassociate_address_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.disassociate_address(AssociationId=args.get('associationId'))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Elastic IP was disassociated")


    def release_address_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.release_address(AllocationId=args.get('allocationId'))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Elastic IP was released")


    def start_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.start_instances(InstanceIds=parse_resource_ids(args.get('instanceIds')))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Instances were started")


    def stop_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.stop_instances(InstanceIds=parse_resource_ids(args.get('instanceIds')))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Instances were stopped")


    def terminate_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.terminate_instances(InstanceIds=parse_resource_ids(args.get('instanceIds')))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Instances were terminated")


    def create_volume_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {'AvailabilityZone': args.get('availabilityZone')}

        if args.get('encrypted') is not None:
            kwargs.update({'Encrypted': True if args.get('encrypted') == 'True' else False})
        if args.get('iops') is not None:
            kwargs.update({'Iops': int(args.get('iops'))})
        if args.get('kmsKeyId') is not None:
            kwargs.update({'KmsKeyId': args.get('kmsKeyId')})
        if args.get('size') is not None:
            kwargs.update({'Size': int(args.get('size'))})
        if args.get('snapshotId') is not None:
            kwargs.update({'SnapshotId': args.get('snapshotId')})
        if args.get('volumeType') is not None:
            kwargs.update({'VolumeType': args.get('volumeType')})
        if args.get('kmsKeyId') is not None:
            kwargs.update({'KmsKeyId': args.get('kmsKeyId')})
        if args.get('tags') is not None:
            kwargs.update({
                'TagSpecifications': [{
                    'ResourceType': 'volume',
                    'Tags': parse_tag_field(args.get('tags'))}]
            })

        response = client.create_volume(**kwargs)

        try:
            create_time = datetime.strftime(response['CreateTime'], '%Y-%m-%dT%H:%M:%SZ')
        except ValueError as e:
            return_error('Date could not be parsed. Please check the date again.\n{error}'.format(type(e)))

        data = ({
            'AvailabilityZone': response['AvailabilityZone'],
            'CreateTime': create_time,
            'Encrypted': response['Encrypted'],
            'Size': response['Size'],
            'State': response['State'],
            'VolumeId': response['VolumeId'],
            'Iops': response['Iops'],
            'VolumeType': response['VolumeType'],
            'Region': obj['_user_provided_options']['region_name'],
        })
        if 'SnapshotId' in response:
            data.update({'SnapshotId': response['SnapshotId']})
        if 'KmsKeyId' in response:
            data.update({'KmsKeyId': response['KmsKeyId']})
        if 'Tags' in response:
            for tag in response['Tags']:
                data.update({
                    tag['Key']: tag['Value']
                })

        ec = {'AWS.EC2.Volumes': data}
        human_readable = tableToMarkdown('AWS EC2 Volumes', data)
        return_outputs(human_readable, ec)


    def attach_volume_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        kwargs = {
            'Device': args.get('device'),
            'InstanceId': args.get('instanceId'),
            'VolumeId': args.get('volumeId'),
        }
        response = client.attach_volume(**kwargs)
        try:
            attach_time = datetime.strftime(response['AttachTime'], '%Y-%m-%dT%H:%M:%SZ')
        except ValueError as e:
            return_error('Date could not be parsed. Please check the date again.\n{error}'.format(type(e)))
        data = ({
            'AttachTime': attach_time,
            'Device': response['Device'],
            'InstanceId': response['InstanceId'],
            'State': response['State'],
            'VolumeId': response['VolumeId'],
        })
        if 'DeleteOnTermination' in response:
            data.update({'DeleteOnTermination': response['DeleteOnTermination']})

        ec = {'AWS.EC2.Volumes(val.VolumeId === obj.VolumeId).Attachments': data}
        human_readable = tableToMarkdown('AWS EC2 Volume Attachments', data)
        return_outputs(human_readable, ec)


    def detach_volume_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        kwargs = {'VolumeId': args.get('volumeId')}

        if args.get('force') is not None:
            kwargs.update({'Force': True if args.get('force') == 'True' else False})
        if args.get('device') is not None:
            kwargs.update({'Device': int(args.get('device'))})
        if args.get('instanceId') is not None:
            kwargs.update({'InstanceId': args.get('instanceId')})

        response = client.detach_volume(**kwargs)
        try:
            attach_time = datetime.strftime(response['AttachTime'], '%Y-%m-%dT%H:%M:%SZ')
        except ValueError as e:
            return_error('Date could not be parsed. Please check the date again.\n{error}'.format(type(e)))
        data = ({
            'AttachTime': attach_time,
            'Device': response['Device'],
            'InstanceId': response['InstanceId'],
            'State': response['State'],
            'VolumeId': response['VolumeId'],
        })
        if 'DeleteOnTermination' in response:
            data.update({'DeleteOnTermination': response['DeleteOnTermination']})

        ec = {'AWS.EC2.Volumes(val.VolumeId === obj.VolumeId).Attachments': data}
        human_readable = tableToMarkdown('AWS EC2 Volume Attachments', data)
        return_outputs(human_readable, ec)


    def delete_volume_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        response = client.delete_volume(VolumeId=args.get('volumeId'))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Volume was deleted")


    def run_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {
            'MinCount': int(args.get('count')),
            'MaxCount': int(args.get('count'))
        }  # type: dict
        BlockDeviceMappings = {}  # type: dict
        if args.get('imageId') is not None:
            kwargs.update({'ImageId': (args.get('imageId'))})
        if args.get('instanceType') is not None:
            kwargs.update({'InstanceType': args.get('instanceType')})
        if args.get('securityGroupIds') is not None:
            kwargs.update({'SecurityGroupIds': parse_resource_ids(args.get('securityGroupIds'))})
        if args.get('securityGroups') is not None:
            kwargs.update({'SecurityGroups': parse_resource_ids(args.get('securityGroups'))})
        if args.get('subnetId') is not None:
            kwargs.update({'SubnetId': args.get('subnetId')})
        if args.get('userData') is not None:
            kwargs.update({'UserData': args.get('userData')})
        if args.get('keyName') is not None:
            kwargs.update({'KeyName': args.get('keyName')})
        if args.get('ebsOptimized') is not None:
            kwargs.update({'EbsOptimized': args.get('ebsOptimized')})
        if args.get('disableApiTermination') is not None:
            kwargs.update({'DisableApiTermination': True if args.get('disableApiTermination') == 'True' else False})
        if args.get('deviceName') is not None:
            BlockDeviceMappings = {'DeviceName': args.get('deviceName')}
            BlockDeviceMappings.update({'Ebs': {}})
        if args.get('ebsVolumeSize') is not None:
            BlockDeviceMappings['Ebs'].update({'VolumeSize': int(args.get('ebsVolumeSize'))})
        if args.get('ebsVolumeType') is not None:
            BlockDeviceMappings['Ebs'].update({'VolumeType': args.get('ebsVolumeType')})
        if args.get('ebsIops') is not None:
            BlockDeviceMappings['Ebs'].update({'Iops': int(args.get('ebsIops'))})
        if args.get('ebsDeleteOnTermination') is not None:
            BlockDeviceMappings['Ebs'].update(
                {'DeleteOnTermination': True if args.get('ebsDeleteOnTermination') == 'True' else False})
        if args.get('ebsKmsKeyId') is not None:
            BlockDeviceMappings['Ebs'].update({'KmsKeyId': args.get('ebsKmsKeyId')})
        if args.get('ebsSnapshotId') is not None:
            BlockDeviceMappings['Ebs'].update({'SnapshotId': args.get('ebsSnapshotId')})
        if args.get('ebsEncrypted') is not None:
            BlockDeviceMappings['Ebs'].update({'Encrypted': True if args.get('ebsEncrypted') == 'True' else False})
        if BlockDeviceMappings:
            kwargs.update({'BlockDeviceMappings': [BlockDeviceMappings]})  # type: ignore

        if args.get('iamInstanceProfileArn') is not None:
            kwargs.update({
                'IamInstanceProfile': {
                    'Arn': args.get('iamInstanceProfileArn')}
            })
        if args.get('iamInstanceProfileName') is not None:
            kwargs.update({  # type: ignore
                'IamInstanceProfile': {
                    'Name': args.get('iamInstanceProfileName')}
            })
        if args.get('launchTemplateId') is not None:
            kwargs.update({
                'LaunchTemplate': {
                    'LaunchTemplateId': args.get('launchTemplateId')}
            })
        if args.get('launchTemplateName') is not None:
            kwargs.update({
                'LaunchTemplate': {
                    'LaunchTemplateName': args.get('launchTemplateName')}
            })
        if args.get('launchTemplateVersion') is not None:
            kwargs['LaunchTemplate'].update({  # type: ignore
                'Version': args.get('launchTemplateVersion')
            })
        if args.get('tags') is not None:
            kwargs.update({
                'TagSpecifications': [{
                    'ResourceType': 'instance',
                    'Tags': parse_tag_field(args.get('tags'))}]
            })

        response = client.run_instances(**kwargs)
        data = []
        for i, instance in enumerate(response['Instances']):
            try:
                launch_date = datetime.strftime(instance['LaunchTime'], '%Y-%m-%dT%H:%M:%SZ')
            except ValueError as e:
                return_error('Date could not be parsed. Please check the date again.\n{error}'.format(type(e)))
            data.append({
                'InstanceId': instance['InstanceId'],
                'ImageId': instance['ImageId'],
                'State': instance['State']['Name'],
                'PublicIPAddress': instance.get('PublicIpAddress'),
                'Region': obj['_user_provided_options']['region_name'],
                'Type': instance['InstanceType'],
                'LaunchDate': launch_date,
                'PublicDNSName': instance['PublicDnsName'],
                'KeyName': instance['KeyName'],
                'Monitoring': instance['Monitoring']['State'],
            })
            if 'Tags' in instance:
                for tag in instance['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })
        try:
            output = json.dumps(response['Instances'], cls=DatetimeEncoder)
            raw = json.loads(output)
            raw[0].update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Instances': raw}
        human_readable = tableToMarkdown('AWS Instances', data)
        return_outputs(human_readable, ec)


    def waiter_instance_running_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('instanceIds') is not None:
            kwargs.update({'InstanceIds': parse_resource_ids(args.get('instanceIds'))})
        if args.get('waiterDelay') is not None:
            kwargs.update({'WaiterConfig': {'Delay': int(args.get('waiterDelay'))}})
        if args.get('waiterMaxAttempts') is not None:
            kwargs.update({'WaiterConfig': {'MaxAttempts': int(args.get('waiterMaxAttempts'))}})

        waiter = client.get_waiter('instance_running')
        waiter.wait(**kwargs)
        demisto.results("success")


    def waiter_instance_status_ok_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('instanceIds') is not None:
            kwargs.update({'InstanceIds': parse_resource_ids(args.get('instanceIds'))})
        if args.get('waiterDelay') is not None:
            kwargs.update({'WaiterConfig': {'Delay': int(args.get('waiterDelay'))}})
        if args.get('waiterMaxAttempts') is not None:
            kwargs.update({'WaiterConfig': {'MaxAttempts': int(args.get('waiterMaxAttempts'))}})

        waiter = client.get_waiter('instance_status_ok')
        waiter.wait(**kwargs)
        demisto.results("success")


    def waiter_instance_stopped_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('instanceIds') is not None:
            kwargs.update({'InstanceIds': parse_resource_ids(args.get('instanceIds'))})
        if args.get('waiterDelay') is not None:
            kwargs.update({'WaiterConfig': {'Delay': int(args.get('waiterDelay'))}})
        if args.get('waiterMaxAttempts') is not None:
            kwargs.update({'WaiterConfig': {'MaxAttempts': int(args.get('waiterMaxAttempts'))}})

        waiter = client.get_waiter('instance_stopped')
        waiter.wait(**kwargs)
        demisto.results("success")


    def waiter_instance_terminated_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('instanceIds') is not None:
            kwargs.update({'InstanceIds': parse_resource_ids(args.get('instanceIds'))})
        if args.get('waiterDelay') is not None:
            kwargs.update({'WaiterConfig': {'Delay': int(args.get('waiterDelay'))}})
        if args.get('waiterMaxAttempts') is not None:
            kwargs.update({'WaiterConfig': {'MaxAttempts': int(args.get('waiterMaxAttempts'))}})

        waiter = client.get_waiter('instance_terminated')
        waiter.wait(**kwargs)
        demisto.results("success")


    def waiter_image_available_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('imageIds') is not None:
            kwargs.update({'ImageIds': parse_resource_ids(args.get('imageIds'))})
        if args.get('executableUsers') is not None:
            kwargs.update({'ExecutableUsers': parse_resource_ids(args.get('executableUsers'))})
        if args.get('owners') is not None:
            kwargs.update({'Owners': parse_resource_ids(args.get('owners'))})
        if args.get('waiterDelay') is not None:
            kwargs.update({'WaiterConfig': {'Delay': int(args.get('waiterDelay'))}})
        if args.get('waiterMaxAttempts') is not None:
            kwargs.update({'WaiterConfig': {'MaxAttempts': int(args.get('waiterMaxAttempts'))}})

        waiter = client.get_waiter('image_available')
        waiter.wait(**kwargs)
        demisto.results("success")


    def waiter_snapshot_completed_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('ownerIds') is not None:
            kwargs.update({'OwnerIds': parse_resource_ids(args.get('ownerIds'))})
        if args.get('restorableByUserIds') is not None:
            kwargs.update({'RestorableByUserIds': parse_resource_ids(args.get('restorableByUserIds'))})
        if args.get('snapshotIds') is not None:
            kwargs.update({'SnapshotIds': parse_resource_ids(args.get('snapshotIds'))})
        if args.get('waiterDelay') is not None:
            kwargs.update({'WaiterConfig': {'Delay': int(args.get('waiterDelay'))}})
        if args.get('waiterMaxAttempts') is not None:
            kwargs.update({'WaiterConfig': {'MaxAttempts': int(args.get('waiterMaxAttempts'))}})

        waiter = client.get_waiter('snapshot_completed')
        waiter.wait(**kwargs)
        demisto.results("Success")


    def get_latest_ami_command(args):
        client = aws_session(
            service='ec2',
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {}
        data = {}  # type: dict

        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('imageIds') is not None:
            kwargs.update({'ImageIds': parse_resource_ids(args.get('imageIds'))})
        if args.get('owners') is not None:
            kwargs.update({'Owners': parse_resource_ids(args.get('owners'))})
        if args.get('executableUsers') is not None:
            kwargs.update({'ExecutableUsers': parse_resource_ids(args.get('executableUsers'))})
        response = client.describe_images(**kwargs)
        amis = sorted(response['Images'],
                      key=lambda x: x['CreationDate'],
                      reverse=True)
        image = amis[0]
        data = ({
            'CreationDate': image['CreationDate'],
            'ImageId': image['ImageId'],
            'Public': image['Public'],
            'Name': image['Name'],
            'State': image['State'],
            'Region': obj['_user_provided_options']['region_name'],
        })
        if 'Description' in image:
            data.update({'Description': image['Description']})
        if 'Tags' in image:
            for tag in image['Tags']:
                data.update({
                    tag['Key']: tag['Value']
                })

        try:
            raw = json.loads(json.dumps(image, cls=DatetimeEncoder))
            raw.update({'Region': obj['_user_provided_options']['region_name']})
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Images': image}
        human_readable = tableToMarkdown('AWS EC2 Images', data)
        return_outputs(human_readable, ec)


    def create_security_group_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {
            'GroupName': args.get('groupName'),
            'Description': args.get('description'),
            'VpcId': args.get('vpcId'),
        }
        response = client.create_security_group(**kwargs)
        data = ({
            'GroupName': args.get('groupName'),
            'Description': args.get('description'),
            'VpcId': args.get('vpcId'),
            'GroupId': response['GroupId']
        })
        ec = {'AWS.EC2.SecurityGroups': data}
        human_readable = tableToMarkdown('AWS EC2 Security Groups', data)
        return_outputs(human_readable, ec)


    def delete_security_group_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('groupId') is not None:
            kwargs.update({'GroupId': args.get('groupId')})
        if args.get('groupName') is not None:
            kwargs.update({'GroupName': args.get('groupName')})

        response = client.delete_security_group(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Security Group was Deleted")


    def authorize_security_group_ingress_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {'GroupId': args.get('groupId')}
        IpPermissions = []
        IpPermissions_dict = {}
        UserIdGroupPairs = []
        UserIdGroupPairs_dict = {}

        if args.get('IpPermissionsfromPort') is not None:
            IpPermissions_dict.update({'FromPort': int(args.get('IpPermissionsfromPort'))})
        if args.get('IpPermissionsIpProtocol') is not None:
            IpPermissions_dict.update({'IpProtocol': str(args.get('IpPermissionsIpProtocol'))})  # type: ignore
        if args.get('IpPermissionsToPort') is not None:
            IpPermissions_dict.update({'ToPort': int(args.get('IpPermissionsToPort'))})

        if args.get('IpRangesCidrIp') is not None:
            IpRanges = [{
                'CidrIp': args.get('IpRangesCidrIp'),
                'Description': args.get('IpRangesDesc', None)
            }]
            IpPermissions_dict.update({'IpRanges': IpRanges})  # type: ignore
        if args.get('Ipv6RangesCidrIp') is not None:
            Ipv6Ranges = [{
                'CidrIp': args.get('Ipv6RangesCidrIp'),
                'Description': args.get('Ipv6RangesDesc', None)
            }]
            IpPermissions_dict.update({'Ipv6Ranges': Ipv6Ranges})  # type: ignore
        if args.get('PrefixListId') is not None:
            PrefixListIds = [{
                'PrefixListId': args.get('PrefixListId'),
                'Description': args.get('PrefixListIdDesc', None)
            }]
            IpPermissions_dict.update({'PrefixListIds': PrefixListIds})  # type: ignore

        if args.get('UserIdGroupPairsDescription') is not None:
            UserIdGroupPairs_dict.update({'Description': args.get('UserIdGroupPairsDescription')})
        if args.get('UserIdGroupPairsGroupId') is not None:
            UserIdGroupPairs_dict.update({'GroupId': args.get('UserIdGroupPairsGroupId')})
        if args.get('UserIdGroupPairsGroupName') is not None:
            UserIdGroupPairs_dict.update({'GroupName': args.get('UserIdGroupPairsGroupName')})
        if args.get('UserIdGroupPairsPeeringStatus') is not None:
            UserIdGroupPairs_dict.update({'PeeringStatus': args.get('UserIdGroupPairsPeeringStatus')})
        if args.get('UserIdGroupPairsUserId') is not None:
            UserIdGroupPairs_dict.update({'UserId': args.get('UserIdGroupPairsUserId')})
        if args.get('UserIdGroupPairsVpcId') is not None:
            UserIdGroupPairs_dict.update({'VpcId': args.get('UserIdGroupPairsVpcId')})
        if args.get('UserIdGroupPairsVpcPeeringConnectionId') is not None:
            UserIdGroupPairs_dict.update({'VpcPeeringConnectionId': args.get('UserIdGroupPairsVpcPeeringConnectionId')})

        if args.get('fromPort') is not None:
            kwargs.update({'FromPort': int(args.get('fromPort'))})
        if args.get('cidrIp') is not None:
            kwargs.update({'CidrIp': args.get('cidrIp')})
        if args.get('toPort') is not None:
            kwargs.update({'ToPort': int(args.get('toPort'))})
        if args.get('ipProtocol') is not None:
            kwargs.update({'IpProtocol': args.get('ipProtocol')})
        if args.get('sourceSecurityGroupName') is not None:
            kwargs.update({'SourceSecurityGroupName': args.get('sourceSecurityGroupName')})
        if args.get('SourceSecurityGroupOwnerId') is not None:
            kwargs.update({'SourceSecurityGroupOwnerId': args.get('SourceSecurityGroupOwnerId')})

        if UserIdGroupPairs_dict is not None:
            UserIdGroupPairs.append(UserIdGroupPairs_dict)
            IpPermissions_dict.update({'UserIdGroupPairs': UserIdGroupPairs})  # type: ignore

        if IpPermissions_dict is not None:
            IpPermissions.append(IpPermissions_dict)
            kwargs.update({'IpPermissions': IpPermissions})

        response = client.authorize_security_group_ingress(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Security Group ingress rule was created")


    def revoke_security_group_ingress_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {'GroupId': args.get('groupId')}

        if args.get('fromPort') is not None:
            kwargs.update({'FromPort': int(args.get('fromPort'))})
        if args.get('cidrIp') is not None:
            kwargs.update({'CidrIp': args.get('cidrIp')})
        if args.get('toPort') is not None:
            kwargs.update({'ToPort': int(args.get('toPort'))})
        if args.get('ipProtocol') is not None:
            kwargs.update({'IpProtocol': args.get('ipProtocol')})
        if args.get('sourceSecurityGroupName') is not None:
            kwargs.update({'SourceSecurityGroupName': args.get('sourceSecurityGroupName')})

        response = client.revoke_security_group_ingress(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Security Group ingress rule was revoked")


    def copy_image_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {
            'Name': args.get('name'),
            'SourceImageId': args.get('sourceImageId'),
            'SourceRegion': args.get('sourceRegion'),
        }
        if args.get('clientToken') is not None:
            kwargs.update({'ClientToken': args.get('clientToken')})
        if args.get('description') is not None:
            kwargs.update({'Description': args.get('description')})
        if args.get('encrypted') is not None:
            kwargs.update({'Encrypted': True if args.get('ebsEncrypted') == 'True' else False})
        if args.get('kmsKeyId') is not None:
            kwargs.update({'KmsKeyId': args.get('kmsKeyId')})

        response = client.copy_image(**kwargs)
        data = ({
            'ImageId': response['ImageId'],
            'Region': obj['_user_provided_options']['region_name']
        })

        ec = {'AWS.EC2.Images(val.ImageId === obj.ImageId)': data}
        human_readable = tableToMarkdown('AWS EC2 Images', data)
        return_outputs(human_readable, ec)


    def copy_snapshot_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {
            'SourceSnapshotId': args.get('sourceSnapshotId'),
            'SourceRegion': args.get('sourceRegion'),
        }
        if args.get('description') is not None:
            kwargs.update({'Description': args.get('description')})
        if args.get('encrypted') is not None:
            kwargs.update({'Encrypted': True if args.get('ebsEncrypted') == 'True' else False})
        if args.get('kmsKeyId') is not None:
            kwargs.update({'KmsKeyId': args.get('kmsKeyId')})

        response = client.copy_snapshot(**kwargs)
        data = ({
            'SnapshotId': response['SnapshotId'],
            'Region': obj['_user_provided_options']['region_name']
        })

        ec = {'AWS.EC2.Snapshots(val.SnapshotId === obj.SnapshotId)': data}
        human_readable = tableToMarkdown('AWS EC2 Snapshots', data)
        return_outputs(human_readable, ec)


    def describe_reserved_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        kwargs = {}
        data = []
        output = []
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('offeringClass') is not None:
            kwargs.update({'OfferingClass': args.get('offeringClass')})
        if args.get('reservedInstancesIds') is not None:
            kwargs.update({'ReservedInstancesIds': parse_resource_ids(args.get('reservedInstancesIds'))})

        response = client.describe_reserved_instances(**kwargs)
        for i, reservation in enumerate(response['ReservedInstances']):
            try:
                start_time = datetime.strftime(reservation['Start'], '%Y-%m-%dT%H:%M:%SZ')
                end_time = datetime.strftime(reservation['End'], '%Y-%m-%dT%H:%M:%SZ')
            except ValueError as e:
                return_error('Date could not be parsed. Please check the date again.\n{error}'.format(type(e)))
            data.append({
                'ReservedInstancesId': reservation['ReservedInstancesId'],
                'Start': start_time,
                'End': end_time,
                'Duration': reservation['Duration'],
                'InstanceType': reservation['InstanceType'],
                'InstanceCount': reservation['InstanceCount'],
                'OfferingClass': reservation['OfferingClass'],
                'Scope': reservation['Scope'],
                'State': reservation['State']
            })
            if 'Tags' in reservation:
                for tag in reservation['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })
            reservation.update({'Region': obj['_user_provided_options']['region_name']})
            output.append(reservation)

        try:
            raw = json.loads(json.dumps(output, cls=DatetimeEncoder))
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.ReservedInstances(val.ReservedInstancesId === obj.ReservedInstancesId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Reserved Instances', data)
        return_outputs(human_readable, ec)


    def monitor_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        data = []
        response = client.monitor_instances(InstanceIds=parse_resource_ids(args.get('instancesIds')))

        for instance in response['InstanceMonitorings']:
            data.append({
                'InstanceId': instance['InstanceId'],
                'MonitoringState': instance['Monitoring']['State']
            })

        ec = {'AWS.EC2.Instances(val.InstancesId === obj.InstancesId)': response['InstanceMonitorings']}
        human_readable = tableToMarkdown('AWS EC2 Instances', data)
        return_outputs(human_readable, ec)


    def unmonitor_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        data = []
        response = client.unmonitor_instances(InstanceIds=parse_resource_ids(args.get('instancesIds')))

        for instance in response['InstanceMonitorings']:
            data.append({
                'InstanceId': instance['InstanceId'],
                'MonitoringState': instance['Monitoring']['State']
            })

        ec = {'AWS.EC2.Instances(val.InstancesId === obj.InstancesId)': response['InstanceMonitorings']}
        human_readable = tableToMarkdown('AWS EC2 Instances', data)
        return_outputs(human_readable, ec)


    def reboot_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.reboot_instances(InstanceIds=parse_resource_ids(args.get('instanceIds')))
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Instances were rebooted")


    def get_password_data_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )

        response = client.get_password_data(InstanceId=args.get('instanceId'))
        try:
            time_stamp = datetime.strftime(response['Timestamp'], '%Y-%m-%dT%H:%M:%SZ')
        except ValueError as e:
            return_error('Date could not be parsed. Please check the date again.\n{error}'.format(type(e)))
        data = {
            'InstanceId': response['InstanceId'],
            'PasswordData': response['PasswordData'],
            'Timestamp': time_stamp
        }

        ec = {'AWS.EC2.Instances(val.InstancesId === obj.InstancesId).PasswordData': data}
        human_readable = tableToMarkdown('AWS EC2 Instances', data)
        return_outputs(human_readable, ec)


    def modify_network_interface_attribute_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {'NetworkInterfaceId': args.get('networkInterfaceId')}

        if args.get('sourceDestCheck') is not None:
            kwargs.update({'SourceDestCheck': {'Value': True if args.get('sourceDestCheck') == 'True' else False}})
        if args.get('attachmentId') is not None and args.get('deleteOnTermination') is not None:
            kwargs.update({
                'Attachment': {
                    'AttachmentId': args.get('attachmentId'),
                    'DeleteOnTermination': True if args.get('deleteOnTermination') == 'True' else False
                }})
        if args.get('description') is not None:
            kwargs.update({'Description': {'Value': args.get('description')}})
        if args.get('groups') is not None:
            kwargs.update({'Groups': parse_resource_ids(args.get('groups'))})

        response = client.modify_network_interface_attribute(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Network Interface Atttribute was successfully modified")


    def modify_instance_attribute_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {'InstanceId': args.get('instanceId')}

        if args.get('sourceDestCheck') is not None:
            kwargs.update({'SourceDestCheck': {'Value': True if args.get('sourceDestCheck') == 'True' else False}})
        if args.get('disableApiTermination') is not None:
            kwargs.update(
                {'DisableApiTermination': {'Value': True if args.get('disableApiTermination') == 'True' else False}})
        if args.get('ebsOptimized') is not None:
            kwargs.update({'EbsOptimized': {'Value': True if args.get('ebsOptimized') == 'True' else False}})
        if args.get('enaSupport') is not None:
            kwargs.update({'EnaSupport': {'Value': True if args.get('enaSupport') == 'True' else False}})
        if args.get('instanceType') is not None:
            kwargs.update({'InstanceType': {'Value': args.get('instanceType')}})
        if args.get('instanceInitiatedShutdownBehavior') is not None:
            kwargs.update(
                {'InstanceInitiatedShutdownBehavior': {'Value': args.get('instanceInitiatedShutdownBehavior')}})
        if args.get('groups') is not None:
            kwargs.update({'Groups': parse_resource_ids(args.get('groups'))})

        response = client.modify_instance_attribute(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Instance attribute was successfully modified")


    def create_network_acl_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {'VpcId': args.get('VpcId')}

        if args.get('DryRun') is not None:
            kwargs.update({'DryRun': True if args.get('DryRun') == 'True' else False})

        response = client.create_network_acl(**kwargs)
        network_acl = response['NetworkAcl']

        data = {
            'Associations': network_acl['Associations'],
            'IsDefault': network_acl['IsDefault'],
            'NetworkAclId': network_acl['NetworkAclId'],
            'Tags': network_acl['Tags'],
            'VpcId': network_acl['VpcId']
        }
        entries = []
        for entry in network_acl['Entries']:
            entries.append(entry)
        hr_entries = tableToMarkdown('AWS EC2 ACL Entries', entries, removeNull=True)
        ec = {'AWS.EC2.VpcId(val.VpcId === obj.VpcId).NetworkAcl': network_acl}
        hr_acl = tableToMarkdown('AWS EC2 Instance ACL', data, removeNull=True)
        human_readable = hr_acl + hr_entries
        return_outputs(human_readable, ec)


    def create_network_acl_entry_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {
            'Egress': True if args.get('Egress') == 'True' else False,
            'NetworkAclId': args.get('NetworkAclId'),
            'Protocol': args.get('Protocol'),
            'RuleAction': args.get('RuleAction'),
            'RuleNumber': int(args.get('RuleNumber'))
        }

        if args.get('CidrBlock') is not None:
            kwargs.update({'CidrBlock': args.get('CidrBlock')})
        if args.get('Code') is not None:
            kwargs.update({'IcmpTypeCode': {'Code': int(args.get('Code'))}})
        if args.get('Type') is not None:
            kwargs.update({'IcmpTypeCode': {'Type': int(args.get('Type'))}})
        if args.get('Ipv6CidrBlock') is not None:
            kwargs.update({'Ipv6CidrBlock': args.get('Ipv6CidrBlock')})
        if args.get('From') is not None:
            kwargs.update({'PortRange': {'From': int(args.get('From'))}})
        if args.get('To') is not None:
            kwargs.update({'PortRange': {'To': int(args.get('To'))}})
        if args.get('DryRun') is not None:
            kwargs.update({'DryRun': True if args.get('DryRun') == 'True' else False})

        response = client.create_network_acl_entry(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results("The Instance ACL was successfully modified")


    def create_fleet_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}  # type: dict

        if args.get('DryRun') is not None:
            kwargs.update({'DryRun': True if args.get('DryRun') == 'True' else False})

        if args.get('ClientToken') is not None:
            kwargs.update({'ClientToken': (args.get('ClientToken'))})

        SpotOptions = {}
        if args.get('SpotAllocationStrategy') is not None:
            SpotOptions.update({
                'AllocationStrategy': args.get('SpotAllocationStrategy')
            })
        if args.get('InstanceInterruptionBehavior') is not None:
            SpotOptions.update({
                'InstanceInterruptionBehavior': args.get('InstanceInterruptionBehavior')
            })
        if args.get('InstancePoolsToUseCount') is not None:
            SpotOptions.update({
                'InstancePoolsToUseCount': args.get('InstancePoolsToUseCount')
            })
        if args.get('SingleInstanceType') is not None:
            SpotOptions.update({'SingleInstanceType': True if args.get('SingleInstanceType') == 'True' else False})
        if args.get('SingleAvailabilityZone') is not None:
            SpotOptions.update({
                'SingleAvailabilityZone': True if args.get('SingleAvailabilityZone') == 'True' else False
            })
        if args.get('MinTargetCapacity') is not None:
            SpotOptions.update({
                'MinTargetCapacity': int(args.get('MinTargetCapacity'))
            })

        if SpotOptions:
            kwargs.update({'SpotOptions': SpotOptions})

        OnDemandOptions = {}
        if args.get('OnDemandAllocationStrategy') is not None:
            OnDemandOptions.update({
                'AllocationStrategy': args.get('OnDemandAllocationStrategy')
            })
        if args.get('OnDemandSingleInstanceType') is not None:
            SpotOptions.update({
                'SingleInstanceType': True if args.get('OnDemandSingleInstanceType') == 'True' else False
            })
        if args.get('OnDemandSingleAvailabilityZone') is not None:
            SpotOptions.update({
                'SingleAvailabilityZone': True if args.get('OnDemandSingleAvailabilityZone') == 'True' else False
            })
        if args.get('OnDemandMinTargetCapacity') is not None:
            SpotOptions.update({
                'MinTargetCapacity': int(args.get('OnDemandMinTargetCapacity'))
            })

        if OnDemandOptions:
            kwargs.update({'OnDemandOptions': OnDemandOptions})

        if args.get('ExcessCapacityTerminationPolicy') is not None:
            kwargs.update({'ExcessCapacityTerminationPolicy': (args.get('ExcessCapacityTerminationPolicy'))})

        LaunchTemplateConfigs = {}  # type: dict
        LaunchTemplateSpecification = {}
        if args.get('LaunchTemplateId') is not None:
            LaunchTemplateSpecification.update({
                'LaunchTemplateId': args.get('LaunchTemplateId')
            })
        if args.get('LaunchTemplateName') is not None:
            LaunchTemplateSpecification.update({
                'LaunchTemplateName': args.get('LaunchTemplateName')
            })
        if args.get('LaunchTemplateVersion') is not None:
            LaunchTemplateSpecification.update({
                'Version': str(args.get('LaunchTemplateVersion'))
            })

        if LaunchTemplateSpecification:
            LaunchTemplateConfigs.update({'LaunchTemplateSpecification': LaunchTemplateSpecification})

        Overrides = []  # type: list

        if args.get('OverrideInstanceType') is not None:
            arr = multi_split(args.get('OverrideInstanceType'))
            for i, item in enumerate(arr):
                if len(Overrides) - 1 < i:
                    Overrides.append({})
                Overrides[i].update({
                    'InstanceType': item
                })
        if args.get('OverrideMaxPrice') is not None:
            arr = multi_split(args.get('OverrideMaxPrice'))
            for i, item in enumerate(arr):
                if len(Overrides) - 1 < i:
                    Overrides.append({})
                Overrides[i].update({
                    'MaxPrice': item
                })

        if args.get('OverrideSubnetId') is not None:
            arr = multi_split(args.get('OverrideSubnetId'))
            for i, item in enumerate(arr):
                if len(Overrides) - 1 < i:
                    Overrides.append({})
                Overrides[i].update({
                    'SubnetId': item
                })

        if args.get('OverrideAvailabilityZone') is not None:
            arr = multi_split(args.get('OverrideAvailabilityZone'))
            for i, item in enumerate(arr):
                if len(Overrides) - 1 < i:
                    Overrides.append({})
                Overrides[i].update({
                    'AvailabilityZone': item
                })

        if args.get('OverrideWeightedCapacity') is not None:
            arr = multi_split(args.get('OverrideWeightedCapacity'))
            for i, item in enumerate(arr):
                if len(Overrides) - 1 < i:
                    Overrides.append({})
                Overrides[i].update({
                    'WeightedCapacity': item
                })

        if args.get('OverridePriority') is not None:
            arr = multi_split(args.get('OverridePriority'))
            for i, item in enumerate(arr):
                if len(Overrides) - 1 < i:
                    Overrides.append({})
                Overrides[i].update({
                    'Priority': item
                })

        if Overrides:
            LaunchTemplateConfigs.update({'Overrides': Overrides})

        if LaunchTemplateConfigs:
            kwargs.update({'LaunchTemplateConfigs': [LaunchTemplateConfigs]})

        TargetCapacitySpecification = {}
        if args.get('TotalTargetCapacity') is not None:
            TargetCapacitySpecification.update({
                'TotalTargetCapacity': int(args.get('TotalTargetCapacity'))
            })
        if args.get('OnDemandTargetCapacity') is not None:
            TargetCapacitySpecification.update({
                'OnDemandTargetCapacity': int(args.get('OnDemandTargetCapacity'))
            })
        if args.get('SpotTargetCapacity') is not None:
            TargetCapacitySpecification.update({
                'SpotTargetCapacity': int(args.get('SpotTargetCapacity'))
            })
        if args.get('DefaultTargetCapacityType') is not None:
            TargetCapacitySpecification.update({
                'DefaultTargetCapacityType': args.get('DefaultTargetCapacityType')
            })
        if TargetCapacitySpecification:
            kwargs.update({'TargetCapacitySpecification': TargetCapacitySpecification})

        if args.get('TerminateInstancesWithExpiration') is not None:
            kwargs.update({'TerminateInstancesWithExpiration': True if args.get(
                'TerminateInstancesWithExpiration') == 'True' else False})

        if args.get('Type') is not None:
            kwargs.update({'Type': (args.get('Type'))})

        if args.get('ValidFrom') is not None:
            kwargs.update({'ValidFrom': (parse_date(args.get('ValidFrom')))})

        if args.get('ValidUntil') is not None:
            kwargs.update({'ValidUntil': (parse_date(args.get('ValidUntil')))})

        if args.get('ReplaceUnhealthyInstances') is not None:
            kwargs.update({'ReplaceUnhealthyInstances': (args.get('ReplaceUnhealthyInstances'))})

        TagSpecifications = []  # type: List[dict]
        if args.get('Tags') is not None:
            arr = args.get('Tags').split('#')
            for i, item in enumerate(arr):
                if len(TagSpecifications) - 1 < (i):
                    TagSpecifications.append({})
                tg = item.split(':')
                TagSpecifications[i].update({
                    'ResourceType': tg[0],
                    'Tags': parse_tag_field(tg[1])
                })

        if TagSpecifications:
            kwargs.update({'TagSpecifications': TagSpecifications})
        response = client.create_fleet(**kwargs)
        data = [{
            'FleetId': response['FleetId'],
        }]
        output = json.dumps(response)
        raw = json.loads(output)
        ec = {'AWS.EC2.Fleet': raw}
        human_readable = tableToMarkdown('AWS EC2 Fleet', data)
        return_outputs(human_readable, ec)


    def delete_fleet_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        data = []
        kwargs = {}
        output = []
        if args.get('DryRun') is not None:
            kwargs.update({'DryRun': True if args.get('DryRun') == 'True' else False})
        if args.get('FleetIds') is not None:
            kwargs.update({'FleetIds': parse_resource_ids(args.get('FleetIds'))})
        if args.get('TerminateInstances') is not None:
            kwargs.update({'TerminateInstances': bool(args.get('TerminateInstances'))})

        response = client.delete_fleets(**kwargs)
        for i, item in enumerate(response['SuccessfulFleetDeletions']):
            data.append({'SuccessfulFleetDeletions': {
                'CurrentFleetState': item['CurrentFleetState'],
                'PreviousFleetState': item['PreviousFleetState'],
                'FleetId': item['FleetId'],
                'Region': obj['_user_provided_options']['region_name'],
            }})
            output.append(item)
        for i, item in enumerate(response['UnsuccessfulFleetDeletions']):
            data.append({'UnsuccessfulFleetDeletions': {
                'Error-Code': item['Error']['Code'],
                'Error-Message': item['Error']['Message'],
                'FleetId': item['FleetId'],
                'Region': obj['_user_provided_options']['region_name'],
            }})
            output.append(item)

        try:
            raw = json.loads(json.dumps(output, cls=DatetimeEncoder))
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.DeletedFleets': raw}
        human_readable = tableToMarkdown('AWS Deleted Fleets', data)
        return_outputs(human_readable, ec)


    def describe_fleets_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)  # noqa:F841
        data = []
        kwargs = {}
        output = []
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('FleetIds') is not None:
            kwargs.update({'FleetIds': parse_resource_ids(args.get('FleetIds'))})
        if args.get('MaxResults') is not None:
            kwargs.update({'MaxResults': args.get('MaxResults')})
        if args.get('NextToken') is not None:
            kwargs.update({'NextToken': args.get('NextToken')})

        response = client.describe_fleets(**kwargs)
        for i, item in enumerate(response['Fleets']):

            data.append({
                'ActivityStatus': item['ActivityStatus'] if 'ActivityStatus' in item.keys() is not None else "None",
                'FleetId': item['FleetId'],
                'FleetState': item['FleetState'],
                'FulfilledCapacity': item['FulfilledCapacity'],
                'FulfilledOnDemandCapacity': item['FulfilledOnDemandCapacity'],
                'LaunchTemplateId': item['LaunchTemplateConfigs'][0]['LaunchTemplateSpecification'][
                    'LaunchTemplateId'],
                'CreateTime': datetime.strftime(item['CreateTime'], '%Y-%m-%dT%H:%M:%SZ'),
                'TotalTargetCapacity': item['TargetCapacitySpecification']['TotalTargetCapacity'],
                'OnDemandTargetCapacity': item['TargetCapacitySpecification']['OnDemandTargetCapacity'],
                'SpotTargetCapacity': item['TargetCapacitySpecification']['SpotTargetCapacity'],
                'DefaultTargetCapacityType': item['TargetCapacitySpecification']['DefaultTargetCapacityType'],
                'TerminateInstancesWithExpiration': item['TerminateInstancesWithExpiration'],
                'Type': item['Type'],
                'InstanceInterruptionBehavior': item['SpotOptions']['InstanceInterruptionBehavior'],
            })
            if 'Tags' in item:
                for tag in item['Tags']:
                    data[i].update({
                        tag['Key']: tag['Value']
                    })
            output.append(item)

        try:
            raw = json.loads(json.dumps(output, cls=DatetimeEncoder))
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Fleet(val.FleetId === obj.FleetId)': raw}
        human_readable = tableToMarkdown('AWS EC2 Fleets', data)
        return_outputs(human_readable, ec)


    def describe_fleet_instances_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)
        data = []
        kwargs = {}
        output = []
        if args.get('filters') is not None:
            kwargs.update({'Filters': parse_filter_field(args.get('filters'))})
        if args.get('FleetId') is not None:
            kwargs.update({'FleetId': args.get('FleetId')})
        if args.get('MaxResults') is not None:
            kwargs.update({'MaxResults': int(args.get('MaxResults'))})
        if args.get('NextToken') is not None:
            kwargs.update({'NextToken': args.get('NextToken')})

        response = client.describe_fleet_instances(**kwargs)
        for i, item in enumerate(response['ActiveInstances']):
            demisto.log(str(item))
            data.append({
                'InstanceId': item['InstanceId'],
                'InstanceType': item['InstanceType'],
                'SpotInstanceRequestId': item['SpotInstanceRequestId'],
                'FleetId': response['FleetId'],
                'Region': obj['_user_provided_options']['region_name'],
            })
            if 'InstanceHealth' in item:
                data.append({'InstanceHealth': item['InstanceHealth']})
            output.append(item)

        try:
            raw = json.loads(json.dumps(output, cls=DatetimeEncoder))
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.Fleet(val.FleetId === obj.FleetId).ActiveInstances': raw}
        human_readable = tableToMarkdown('AWS EC2 Fleets Instances', data)
        return_outputs(human_readable, ec)


    def modify_fleet_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        kwargs = {}
        if args.get('FleetId') is not None:
            kwargs.update({'FleetIds': args.get('FleetId')})
        if args.get('ExcessCapacityTerminationPolicy') is not None:
            kwargs.update({'ExcessCapacityTerminationPolicy': args.get('ExcessCapacityTerminationPolicy')})
        TargetCapacitySpecification = {}
        if args.get('TotalTargetCapacity') is not None:
            TargetCapacitySpecification.update({
                'TotalTargetCapacity': int(args.get('TotalTargetCapacity'))
            })
        if args.get('OnDemandTargetCapacity') is not None:
            TargetCapacitySpecification.update({
                'OnDemandTargetCapacity': int(args.get('OnDemandTargetCapacity'))
            })
        if args.get('SpotTargetCapacity') is not None:
            TargetCapacitySpecification.update({
                'SpotTargetCapacity': int(args.get('SpotTargetCapacity'))
            })
        if args.get('DefaultTargetCapacityType') is not None:
            TargetCapacitySpecification.update({
                'DefaultTargetCapacityType': args.get('DefaultTargetCapacityType')
            })
        if TargetCapacitySpecification:
            kwargs.update({'TargetCapacitySpecification': TargetCapacitySpecification})

        response = client.modify_fleet(**kwargs)

        if response['Return'] == 'True':
            demisto.results("AWS EC2 Fleet was successfully modified")
        else:
            demisto.results("AWS EC2 Fleet was not successfully modified: " + response['Return'])


    def create_launch_template_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)  # noqa:F841
        kwargs = {}

        BlockDeviceMappings = {}  # type: dict

        LaunchTemplateData = {}  # type: dict

        if args.get('ClientToken') is not None:
            kwargs.update({'ClientToken': args.get('ClientToken')})
        if args.get('LaunchTemplateName') is not None:
            kwargs.update({'LaunchTemplateName': args.get('LaunchTemplateName')})
        if args.get('VersionDescription') is not None:
            kwargs.update({'VersionDescription': args.get('VersionDescription')})

        if args.get('KernelId') is not None:
            LaunchTemplateData.update({'KernelId': args.get('KernelId')})
        if args.get('EbsOptimized') is not None:
            LaunchTemplateData.update({'EbsOptimized': args.get('EbsOptimized')})

        if args.get('iamInstanceProfileArn') is not None and args.get('iamInstanceProfileName') is not None:
            LaunchTemplateData.update({
                'IamInstanceProfile': {
                    'Arn': args.get('iamInstanceProfileArn'),
                    'Name': args.get('iamInstanceProfileName')}
            })

        if args.get('deviceName') is not None:
            BlockDeviceMappings = {'DeviceName': args.get('deviceName')}
            BlockDeviceMappings.update({'Ebs': {}})
        if args.get('VirtualName') is not None:
            BlockDeviceMappings.update({'VirtualName': {args.get('VirtualName')}})
        if args.get('ebsVolumeSize') is not None:
            BlockDeviceMappings['Ebs'].update({'VolumeSize': int(args.get('ebsVolumeSize'))})
        if args.get('ebsVolumeType') is not None:
            BlockDeviceMappings['Ebs'].update({'VolumeType': args.get('ebsVolumeType')})
        if args.get('ebsIops') is not None:
            BlockDeviceMappings['Ebs'].update({'Iops': int(args.get('ebsIops'))})
        if args.get('ebsDeleteOnTermination') is not None:
            BlockDeviceMappings['Ebs'].update(
                {'DeleteOnTermination': True if args.get('ebsDeleteOnTermination') == 'True' else False})
        if args.get('ebsKmsKeyId') is not None:
            BlockDeviceMappings['Ebs'].update({'KmsKeyId': args.get('ebsKmsKeyId')})
        if args.get('ebsSnapshotId') is not None:
            BlockDeviceMappings['Ebs'].update({'SnapshotId': args.get('ebsSnapshotId')})
        if args.get('ebsEncrypted') is not None:
            BlockDeviceMappings['Ebs'].update({'Encrypted': True if args.get('ebsEncrypted') == 'True' else False})
        if args.get('NoDevice') is not None:
            BlockDeviceMappings.update({'NoDevice': {args.get('NoDevice')}})
        if BlockDeviceMappings:
            LaunchTemplateData.update({'BlockDeviceMappings': [BlockDeviceMappings]})

        NetworkInterfaces = {}  # type: dict
        if args.get('AssociatePublicIpAddress') is not None:
            NetworkInterfaces.update({'AssociatePublicIpAddress': args.get('AssociatePublicIpAddress')})
        if args.get('NetworkInterfacesDeleteOnTermination') is not None:
            NetworkInterfaces.update({'DeleteOnTermination': args.get('NetworkInterfacesDeleteOnTermination')})
        if args.get('NetworkInterfacesDescription') is not None:
            NetworkInterfaces.update({'Description': args.get('NetworkInterfacesDescription')})
        if args.get('NetworkInterfacesDeviceIndex') is not None:
            NetworkInterfaces.update({'DeviceIndex': args.get('NetworkInterfacesDeviceIndex')})
        if args.get('NetworkInterfaceGroups') is not None:
            NetworkInterfaces.update({'Groups': parse_resource_ids(args.get('NetworkInterfaceGroups'))})
        if args.get('Ipv6AddressCount') is not None:
            NetworkInterfaces.update({'Ipv6AddressCount': args.get('Ipv6AddressCount')})
        if args.get('Ipv6Addresses') is not None:
            arr = args.get('Ipv6Addresses').split(',')
            NetworkInterfaces.update({'Ipv6Addresses': []})
            for a in arr:
                NetworkInterfaces['Ipv6Addresses'].append({'Ipv6Address': a})
        if args.get('NetworkInterfaceId') is not None:
            NetworkInterfaces.update({'NetworkInterfaceId': args.get('NetworkInterfaceId')})
        if args.get('PrivateIpAddress') is not None:
            NetworkInterfaces.update({'PrivateIpAddress': args.get('PrivateIpAddress')})
        if args.get('SubnetId') is not None:
            NetworkInterfaces.update({'SubnetId': args.get('SubnetId')})
        if NetworkInterfaces:
            LaunchTemplateData.update({'NetworkInterfaces': [NetworkInterfaces]})
        if args.get('ImageId') is not None:
            LaunchTemplateData.update({'ImageId': args.get('ImageId')})
        if args.get('InstanceType') is not None:
            LaunchTemplateData.update({'InstanceType': args.get('InstanceType')})
        if args.get('KeyName') is not None:
            LaunchTemplateData.update({'KeyName': args.get('KeyName')})
        if args.get('Monitoring') is not None:
            LaunchTemplateData.update({'Monitoring': {'Enabled': args.get('Monitoring')}})
        if args.get('AvailabilityZone') is not None:
            LaunchTemplateData.update({
                'Placement': {
                    'AvailabilityZone': args.get('AvailabilityZone')}
            })
        if args.get('AvailabilityZoneGroupName') is not None:
            LaunchTemplateData.update({
                'Placement': {
                    'GroupName': args.get('AvailabilityZoneGroupName')}
            })
        if args.get('PlacementTenancy') is not None:
            LaunchTemplateData.update({
                'Placement': {
                    'Tenancy': args.get('PlacementTenancy')}
            })
        if args.get('PlacementAffinity') is not None:
            LaunchTemplateData.update({
                'Placement': {
                    'Affinity': args.get('PlacementAffinity')}
            })
        if args.get('PlacementHostId') is not None:
            LaunchTemplateData.update({
                'Placement': {
                    'HostId': args.get('PlacementHostId')}
            })
        if args.get('PlacementSpreadDomain') is not None:
            LaunchTemplateData.update({
                'Placement': {
                    'SpreadDomain': args.get('PlacementSpreadDomain')}
            })
        if args.get('RamDiskId') is not None:
            LaunchTemplateData.update({'RamDiskId': args.get('RamDiskId')})
        if args.get('DisableApiTermination') is not None:
            LaunchTemplateData.update({'DisableApiTermination': args.get('DisableApiTermination')})
        if args.get('InstanceInitiatedShutdownBehavior') is not None:
            LaunchTemplateData.update(
                {'InstanceInitiatedShutdownBehavior': args.get('InstanceInitiatedShutdownBehavior')})
        if args.get('UserData') is not None:
            LaunchTemplateData.update({'UserData': args.get('UserData')})
        TagSpecifications = []  # type: list
        if args.get('Tags') is not None:
            arr = args.get('Tags').split('#')
            for i, item in enumerate(arr):
                if len(TagSpecifications) - 1 < (i):
                    TagSpecifications.append({})
                tg = item.split(':')
                TagSpecifications[i].update({
                    'ResourceType': tg[0],
                    'Tags': parse_tag_field(tg[1])
                })

        ElasticGpuSpecifications = []  # type: list
        if args.get('ElasticGpuSpecificationsType') is not None:
            arr = multi_split(args.get('ElasticGpuSpecificationsType'))
            for i, item in enumerate(arr):
                if len(ElasticGpuSpecifications) - 1 < i:
                    ElasticGpuSpecifications.append({})
                ElasticGpuSpecifications[i].update({
                    'Type': item
                })

        if ElasticGpuSpecifications:
            LaunchTemplateData.update({'ElasticGpuSpecifications': ElasticGpuSpecifications})

        ElasticInferenceAccelerators = []  # type: list
        if args.get('ElasticInferenceAcceleratorsType') is not None:
            arr = multi_split(args.get('ElasticInferenceAcceleratorsType'))
            for i, item in enumerate(arr):
                if len(ElasticInferenceAccelerators) - 1 < i:
                    ElasticInferenceAccelerators.append({})
                ElasticInferenceAccelerators[i].update({
                    'Type': item
                })
        if ElasticGpuSpecifications:
            LaunchTemplateData.update({'ElasticInferenceAccelerators': ElasticInferenceAccelerators})
        if TagSpecifications:
            LaunchTemplateData.update({'TagSpecifications': TagSpecifications})
        if args.get('securityGroupIds') is not None:
            LaunchTemplateData.update({'SecurityGroupIds': parse_resource_ids(args.get('securityGroupIds'))})
        if args.get('securityGroups') is not None:
            LaunchTemplateData.update({'SecurityGroups': parse_resource_ids(args.get('securityGroups'))})

        InstanceMarketOptions = {}  # type: dict
        if args.get('MarketType') is not None:
            InstanceMarketOptions.update({
                'MarketType': args.get('MarketType')
            })

        SpotOptions = {}  # type: dict
        if args.get('SpotInstanceType') is not None:
            SpotOptions.update({
                'SpotInstanceType': args.get('SpotInstanceType')
            })
        if args.get('BlockDurationMinutes') is not None:
            SpotOptions.update({
                'BlockDurationMinutes': args.get('BlockDurationMinutes')
            })
        if args.get('SpotValidUntil') is not None:
            SpotOptions.update({
                'ValidUntil': parse_date(args.get('SpotValidUntil'))
            })
        if args.get('SpotInstanceInterruptionBehavior') is not None:
            SpotOptions.update({
                'InstanceInterruptionBehavior': args.get('SpotInstanceInterruptionBehavior')
            })
        if args.get('SpotMaxPrice') is not None:
            SpotOptions.update({
                'MaxPrice': args.get('SpotMaxPrice')
            })

        if SpotOptions:
            InstanceMarketOptions.update({'SpotOptions': SpotOptions})

        if InstanceMarketOptions:
            LaunchTemplateData.update({'InstanceMarketOptions': InstanceMarketOptions})

        if LaunchTemplateData:
            kwargs.update({'LaunchTemplateData': LaunchTemplateData})

        response = client.create_launch_template(**kwargs)

        data = []
        template = response['LaunchTemplate']
        data.append({
            'LaunchTemplateId': response['LaunchTemplate']['LaunchTemplateId'],
            'LaunchTemplateName': response['LaunchTemplate']['LaunchTemplateName'],
            'CreateTime': response['LaunchTemplate']['CreateTime'],
            'CreatedBy': response['LaunchTemplate']['CreatedBy'],
            'DefaultVersionNumber': response['LaunchTemplate']['DefaultVersionNumber'],
            'LatestVersionNumber': response['LaunchTemplate']['LatestVersionNumber'],
        })
        try:
            output = json.dumps(template, cls=DatetimeEncoder)
            data_json = json.dumps(data, cls=DatetimeEncoder)
            data_hr = json.loads(data_json)  # type: ignore
            raw = json.loads(output)
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.LaunchTemplates': raw}
        human_readable = tableToMarkdown('AWS LaunchTemplates', data_hr)
        return_outputs(human_readable, ec)


    def delete_launch_template_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)  # noqa:F841
        data = []
        kwargs = {}
        output = []
        if args.get('LaunchTemplateId') is not None:
            kwargs.update({'LaunchTemplateId': args.get('LaunchTemplateId')})
        if args.get('LaunchTemplateName') is not None:
            kwargs.update({'LaunchTemplateName': args.get('LaunchTemplateName')})

        response = client.delete_launch_template(**kwargs)
        item = response['LaunchTemplate']
        data.append({
            'LaunchTemplateId': item['LaunchTemplateId'],
            'LaunchTemplateName': item['LaunchTemplateName'],
            'CreateTime': datetime.strftime(item['CreateTime'], '%Y-%m-%dT%H:%M:%SZ'),
            'CreatedBy': item['CreatedBy'],
            'DefaultVersionNumber': item['DefaultVersionNumber'],
            'LatestVersionNumber': item['LatestVersionNumber'],
        })
        output.append(item)

        try:
            raw = json.loads(json.dumps(output, cls=DatetimeEncoder))
        except ValueError as e:
            return_error('Could not decode/encode the raw response - {err_msg}'.format(err_msg=e))
        ec = {'AWS.EC2.DeletedLaunchTemplates': raw}
        human_readable = tableToMarkdown('AWS Deleted Launch Templates', data)
        return_outputs(human_readable, ec)


    def modify_image_attribute_command(args):
        client = aws_session(
            region=args.get('region'),
            roleArn=args.get('roleArn'),
            roleSessionName=args.get('roleSessionName'),
            roleSessionDuration=args.get('roleSessionDuration'),
        )
        obj = vars(client._client_config)  # noqa:F841
        kwargs = {}

        if args.get('Attribute') is not None:
            kwargs.update({'Attribute': args.get('Attribute')})
        if args.get('Description') is not None:
            kwargs.update({'Description': {'Value': args.get('Description')}})
        if args.get('ImageId') is not None:
            kwargs.update({'ImageId': args.get('ImageId')})

        LaunchPermission = {"Add": [], "Remove": []}  # type: dict
        if args.get('LaunchPermission-Add-Group') is not None:
            LaunchPermission["Add"].append({'Group': args.get('LaunchPermission-Add-Group')})
        if args.get('LaunchPermission-Add-UserId') is not None:
            LaunchPermission["Add"].append({'UserId': args.get('LaunchPermission-Add-UserId')})

        if args.get('LaunchPermission-Remove-Group') is not None:
            LaunchPermission["Remove"].append({'Group': args.get('LaunchPermission-Remove-Group')})
        if args.get('LaunchPermission-Remove-UserId') is not None:
            LaunchPermission["Remove"].append({'UserId': args.get('LaunchPermission-Remove-UserId')})

        if LaunchPermission:
            kwargs.update({'LaunchPermission': LaunchPermission})

        if args.get('OperationType') is not None:
            kwargs.update({'OperationType': args.get('OperationType')})
        if args.get('ProductCodes') is not None:
            kwargs.update({'ProductCodes': parse_resource_ids(args.get('ProductCodes'))})
        if args.get('UserGroups') is not None:
            kwargs.update({'UserGroups': parse_resource_ids(args.get('UserGroups'))})
        if args.get('UserIds') is not None:
            kwargs.update({'UserIds': parse_resource_ids(args.get('UserIds'))})
        if args.get('Value') is not None:
            kwargs.update({'Value': args.get('Value')})

        response = client.modify_image_attribute(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == 200:
            demisto.results('Image attribute sucessfully modified')


    """COMMAND BLOCK"""
    try:
        LOG('Command being called is {command}'.format(command=demisto.command()))
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            client = aws_session()
            response = client.describe_regions()
            if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                demisto.results('ok')

        elif demisto.command() == 'aws-ec2-describe-regions':
            describe_regions_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-instances':
            describe_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-images':
            describe_images_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-addresses':
            describe_addresses_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-snapshots':
            describe_snapshots_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-volumes':
            describe_volumes_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-launch-templates':
            describe_launch_templates_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-key-pairs':
            describe_key_pairs_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-vpcs':
            describe_vpcs_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-subnets':
            describe_subnets_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-security-groups':
            describe_security_groups_command(demisto.args())

        elif demisto.command() == 'aws-ec2-allocate-address':
            allocate_address_command(demisto.args())

        elif demisto.command() == 'aws-ec2-associate-address':
            associate_address_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-snapshot':
            create_snapshot_command(demisto.args())

        elif demisto.command() == 'aws-ec2-delete-snapshot':
            delete_snapshot_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-image':
            create_image_command(demisto.args())

        elif demisto.command() == 'aws-ec2-deregister-image':
            deregister_image_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-volume':
            modify_volume_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-tags':
            create_tags_command(demisto.args())

        elif demisto.command() == 'aws-ec2-disassociate-address':
            disassociate_address_command(demisto.args())

        elif demisto.command() == 'aws-ec2-release-address':
            release_address_command(demisto.args())

        elif demisto.command() == 'aws-ec2-start-instances':
            start_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-stop-instances':
            stop_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-terminate-instances':
            terminate_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-volume':
            create_volume_command(demisto.args())

        elif demisto.command() == 'aws-ec2-attach-volume':
            attach_volume_command(demisto.args())

        elif demisto.command() == 'aws-ec2-detach-volume':
            detach_volume_command(demisto.args())

        elif demisto.command() == 'aws-ec2-delete-volume':
            delete_volume_command(demisto.args())

        elif demisto.command() == 'aws-ec2-run-instances':
            run_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-waiter-instance-running':
            waiter_instance_running_command(demisto.args())

        elif demisto.command() == 'aws-ec2-waiter-instance-status-ok':
            waiter_instance_status_ok_command(demisto.args())

        elif demisto.command() == 'aws-ec2-waiter-instance-stopped':
            waiter_instance_stopped_command(demisto.args())

        elif demisto.command() == 'aws-ec2-waiter-instance-terminated':
            waiter_instance_terminated_command(demisto.args())

        elif demisto.command() == 'aws-ec2-waiter-image-available':
            waiter_image_available_command(demisto.args())

        elif demisto.command() == 'aws-ec2-waiter-snapshot_completed':
            waiter_snapshot_completed_command(demisto.args())

        elif demisto.command() == 'aws-ec2-get-latest-ami':
            get_latest_ami_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-security-group':
            create_security_group_command(demisto.args())

        elif demisto.command() == 'aws-ec2-delete-security-group':
            delete_security_group_command(demisto.args())

        elif demisto.command() == 'aws-ec2-authorize-security-group-ingress-rule':
            authorize_security_group_ingress_command(demisto.args())

        elif demisto.command() == 'aws-ec2-revoke-security-group-ingress-rule':
            revoke_security_group_ingress_command(demisto.args())

        elif demisto.command() == 'aws-ec2-copy-image':
            copy_image_command(demisto.args())

        elif demisto.command() == 'aws-ec2-copy-snapshot':
            copy_snapshot_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-reserved-instances':
            describe_reserved_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-monitor-instances':
            monitor_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-unmonitor-instances':
            unmonitor_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-reboot-instances':
            reboot_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-get-password-data':
            get_password_data_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-network-interface-attribute':
            modify_network_interface_attribute_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-instance-attribute':
            modify_instance_attribute_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-network-acl':
            create_network_acl_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-network-acl-entry':
            create_network_acl_entry_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-fleet':
            create_fleet_command(demisto.args())

        elif demisto.command() == 'aws-ec2-delete-fleet':
            delete_fleet_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-fleets':
            describe_fleets_command(demisto.args())

        elif demisto.command() == 'aws-ec2-describe-fleet-instances':
            describe_fleet_instances_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-fleet':
            modify_fleet_command(demisto.args())

        elif demisto.command() == 'aws-ec2-create-launch-template':
            create_launch_template_command(demisto.args())

        elif demisto.command() == 'aws-ec2-delete-launch-template':
            delete_launch_template_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-image-attribute':
            modify_image_attribute_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-network-interface-attribute':
            modify_network_interface_attribute_command(demisto.args())

        elif demisto.command() == 'aws-ec2-modify-instance-attribute':
            modify_instance_attribute_command(demisto.args())

    except ResponseParserError as e:
        return_error('Could not connect to the AWS endpoint. Please check that the region is valid.\n {error}'.format(
            error=type(e)))
        LOG(e.message)

    except Exception as e:
        LOG(e.message)
        return_error('Error has occurred in the AWS EC2 Integration: {code}\n {message}'.format(
            code=type(e), message=e.message))
  subtype: python2
  type: python
system: true
