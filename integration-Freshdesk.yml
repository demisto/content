category: Case Management
commonfields:
  id: Freshdesk
  version: -1
configuration:
- defaultvalue: https://domain.freshdesk.com
  display: Server URL (e.g., https://demistohelp.freshdesk.com)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: API Token. (You must enter either the API token or your Freshdesk credentials)
  name: token
  required: false
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: 24 hours
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: ""
  display: Username
  name: credentials
  required: false
  type: 9
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
description: The Freshdesk integration allows you to create, update, and delete tickets;
  reply to and create notes for tickets as well as view Groups, Agents and Contacts.
detaileddescription: |
  Follow these instructions to successfully instantiate an instance of the Freshdesk integration.
  Enter an API token or Freshdesk user credentials
  To use an API token:
  Follow these instructions to retrieve the API token.
  1. Log in to your Freshdesk support portal.
  2. Click on your profile picture in the top right corner.
  3. Go to the Profile settings page.
  4. Your API key is below the change password section.

  To use User Credentials:
  Enter the same user/password login credentials you use when logging in to your Freshdesk support portal.

  Enter your Server URL -
  If the Freshdesk helpdesk name for your company is, for example, 'dodecahedron', then the Server URL configuration parameter you would enter would be 'https://dodecahedron.freshdesk.com'.
display: Freshdesk
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADOtJREFUeAHtmnt0lcURwPe7eWNCHkoSQiS8QgzhGQqKEKzPojYgWNHwODykWPQgiQpa8JS0PXIq+KDSWgpUsUig5BAgtFawlQPKQySACoYECIkaSCKByCPv5PY3X+53z3eTe0MUgv3j23Pm7u7M7OzszOzs7pcoZRXLApYFLAtYFrAsYFnAsoBlAcsClgUsC1gWsCxgWcCygGUBywKWBSwLWBawLNC+FvBqX/GepY8dOza8d+/etyckJFTl5uZe8szZfpSHH344tlevXp/Hx8d/lZeX9+XVzvTII490Qd6XcXFxl5GXc7XyWhufnJycwDw70Z2p8go88do8EdoLL45FuW319fWldrt9O/Xf22uuK8ll7gHwdAFGXom3LfS6urpbWFM0vKPbwn+VPEMYH898d7Um57o6GGW0hoaGbSh0n6Zph4Dfe3l5pbWmoEW7Ogt4t3X44APPB1+63BDWGr+fn63us1tfLsZxdnd8Y8aMScbJA6Htj4yMHLFixYo6d3wW7tpZwKOD++6bH1FXW5mCp8Yquz3xwuXqwCtNW1WjVO9dqaW3fPTMjGNJr/3TDX+i4Gw223rLuW6s0w6oFg4etictoLzO/nxtTeVzdmW/4QfMGdHY2LieAOl55LZFpc3Gh0sf+vlmeKvbThZwcXDvPWldyusbt7BrB1/NfBIYtbWVw5Cx2ZAzevToZ0nPSY7+TPp3078QGBi4cN26dWdJ3wvo99iyZcsMaPNI8xPgbeCMvnfTpk3lMg78vYKHbwAQRruAeuXWrVvXOeTqFTgN3il0ZgK94PMFd5h6QXZ29m4zr9GGfxTtuUBf4AKQB7wK/w5qlwJvFIh0YBByuyH3BLCR9hcujKbOQw89dDf3j4mg5GJ3E1DAmFXIX2ti05uOo+wJOrHI9IPvMO3fwnvI4CULamwUo+tSy0WWuRYz9j3nJSt+V2pne13jPrv96pxrzKQpmzOlT5gwIRT8YkCMJ2UYk0+ifrKyslLOZE4B+1PAdIz3Pt0/0O5PHYSiehCCF4W3saip4CNZtKzuDiAD2ipqZ8FAC+m8DQyDL4RxwbSFdye0Fpc6ZI6D5z3oI4AKIIj+g8CH3Phn03cWjCeB+zm0X1IPQP45qZGxBJzbFwH6LWIdH8A3DYgA7MAd8L8LbTW1Rl8v9OcgKxvcgyC6AzG0x1DvQ3dxequF8YN4HXzKmCnoNlR38P3H3/BrUGoTI+WK77b4at4q2LuDW9qVkBkZGefZifFMqJ/L1Ok+Pj6DqWPZsf+R8ShkLPJeonORt7d3BBEbC5QS/fdBnwu/RP0QcFFAD3CyOw9TP87iHzDJmUP7MjDMz88vwN/fP4i27PxvMV6K8DUrXZCziotfKHLjgEh0GAWuDliUkpIiO04vGG8pcm6k80ZMTEyQ8DPuJvglqJx8TdxKESB3wf9r+seQNYBsEw3Iro8HlwttCronG/zU86FVIW+46B4SEiIb5VGgHN1nmfhaNHHuYyAlQ3UFVqHfAn13nDhdQJTab20xAsSdYQlqTrf7Ve8bOitvzUsVV59TW8oOqD8XbVN1dsKijYU0m48C3wg7iyrKyso66GHoapy+wEwj+tOlT5BMRs4Bg4ahTmFAWfReZEp0vzd+/HgfaonEIuj7qKVcAtbNnj07q6ampsXHHQxaiJOeMl/80GEbsrMY92hVVZVcDreze0fg4KG0DyJbgkgvjKuk8Tv4RfZvmrBNv8hORzdF/RjB8LlBo50nuxXadofu2TNnzvQpKSkJgaeY+fc4eCVQN6D7lqKiIl9jPM6WLKCX9PR0W05OzkvIeYF5JChnIX+5EG237kvvyKtmfhOr629qtwfU8oQZ6sTlEjXv2Fo144u/qqzS/Wpi5xEqc1Ca8reJLa9tYee+ZZYoyqOw3AmKce5eM03agwcP3k9VzeL09J+ZmVlLfycQiwHfxeiS5vSybNmyGoczDJRR7zc710BS50kbY/aUmkCTXSevgHelbl4IwF1mHDpJVvoJcMzsXIMnLCzsI9bWCPQTnEOH3Yzrju4ZfGnrYfCK7si4aPSNGt7ggwcPZtN/ASgB7jScKzzeFbUXRhNgcka6lCHBPdWvbr5Hzcl9R71/Vs74prLrfK7acGavyhjwtHq2+8/VSycls1+7wmJPmqUdPXo0mkVI5EbgrG/NNGkTubI7hO5v0AiSKey0Dxgnl5oJGGsH9duJiYnrCZh6g89Ul5naziZyLyFD5BuyJfXpGcjJ1EqD1NuZ8QGM7+lO9/LychkNWfMzxKD7NHTfwbiU2traxxi3k4B6OyIiYp2HIJwFr368IecIa9yLgw1xytaoGsc4e6bG5KgklV2W4+Jcg1xa+51aeCJTpXQerryUfowbpKuu2S1VZiHV1dVB5r6H9lnwfzNopP8zLHQgC34c2I8B5BxcQ6Qfweh9DD6jhseZ7gych9pwhKTkthRdd8MB7gYwtwStWfcidnYfnPoMeMkgP8Um75C6cwnUQW5kIEJbCnzDPPewxnQzj7dGanO3ur5BN6slBVvNvC7tvefzVT1ncLcOndTJylIX2rXscMkorKiokDAvIjJ7tVW2Y6dKun9L/qjAbkjFAE/S38ZZ18PDbmhVPDoUIkN2cBd3jDhC/24AXc58haOK2KVi3mK5WAmuLWX16tXV8L0ugFMlxYvuko220+/RLFW/ST+Nnf4P9NsJ34vwfALuX/ArG5tb3nQtSiffjqq4Rl4A7kuDalRltRdUOHztWdasWSOXjBIU7zFu3DiPt3yzDvDqKcvAbdy48TgGfop+BrTosrKy4Qbt+9SMLRB+DJnkbhx4/SylzhW6OIq2XCxjeAl0E9z3LTjqADAJOesZexMwyiwD/HfSd1wo5eLHnrWvweH63UPyq7cwuCvL4qep7UMWqO4B4S5kuXgJvotfmAve3LFrdnHMtSorEKRxNi3nNmmkSV32xIkTOxKx80i9unEx5GT6p4Ep5snlhkpfXzSXpbaeKy6Bwk37vxj0FHJSCLYhZvnMF8UOFgNL2dFU6b8r5RfaX6ZOnWqc5TqBMUHAXG7nAwRBexyQx1rG6gyOH0fAinMluCQjyEXPRTfBEQjLwa+mGQrfRpnPW9m101wb3Ka+zv6hMk752lxfFlE4tltAJ53m6ceuGpF7bQrKvsIiHwceLCwsPIwR1oMrph9/8eLFSdThgCz4C5x3nLoj/dVEcRoLPkS7ijPsLvBxjPs6ODj4kx+imaR15p6PvAz+NPgR7bXIy8V5N4ObjEwx7FoMvcuQz1yvccTMgD7q3Llzhu5yXsqfFiXtRqKzBO1n3MLLCOKu4LOQvYs6B/2raN8DfSiyz/j6+n5oyHZXh4aGzuJY6M/YROpXCQN7vjvGmsY6d+gWuEv1clw0K3L1D/A+2Qwr3RL5YSHuDu2vWEBFeHh4i52PwS7ysWIQdHmXimHSMepK6mcAcewMeBaLbElVfERJgncfXfnCNBUeuWnG0f+UuZMdaV92laRPKV81VS1+dTx8xQaFedYjQ9Kk/D17OrQltJ9mPn/gN3ycmG7wSi1zcTNOhJYpOgALGSO6PwvOB3iCC+Ei4eUZ+DG6jwS3B/pIUGnwzqcW5+7G2Q/wDNTPTehiX9nNhYCzyLGAjHEg5PLWX4vblTqr0W5/08nhaMyOGaUEpCTnvKzyLp9xUEgFifPULYFR6uNzx9T0I/p72kmThqapPfkj/zjcBUnH8ZDvyyNevgvrqcbg4b8hAoneDiyyzMC5q+EL5sKUwPhw4ER0dPRxeSO643VcrvrAV49TCpCtn41mXuR13bBhw9fN9TF45OzcvHlzodE314yNROc4DF/ar1+/Ex6eYM4hojv8fXBOhDioa9eu+Z50J01LVpAvdfXs2gIc6wwyQ6B8ApavhEbfXDNXJ8bVaAn750bWVtWeguhvZpD2jT6BKtDLX52uOe/y1SrKL1RN4hm1+FR28yF6X9Nss/NHvv4nt0QLeV0tYDs6dEmJTbMtczdred0lVVR91uncXh0iVf+gruq2kFiVb9rR5rGa0gp7du6+0oyz2j+eBfQbdECQfVHlRfULnnjdW1PFh2/Rfnye3FORr0pq5I8uzQoHOsEy+9+xT7tNmc24re51sIDzqh2/+7m+DQ31cri35cuRe9Vs2ovHk5a+5J5oYX8MC9iMSXOHv3LEpnndSYptcZgbPB5rbs38ReB5y7keLfSjEZwOFg2OJb2a4xPgI5/GMhTptk1aadpRbno/yxu5VH+mtGmMxXTdLOBM0c1njN2dOtBWr03ji9QY0naMmc4u563K3zFtWubAEbdvyNTGN5jpVvv/xwIeHWxWceCh1JC6i15RjapBnlJn+ibdXmY51Wwhq21ZwLKAZQHLApYFLAtYFrAsYFnAsoBlAcsClgUsC1gWsCxgWcCygGUBywKtWOB/Pq3GNehrJMkAAAAASUVORK5CYII=
name: Freshdesk
script:
  commands:
  - arguments:
    - description: Subject of the ticket
      name: subject
      required: true
    - description: Details of the issue that you are creating a ticket for
      name: description
      required: true
    - defaultValue: "1"
      description: Priority of the ticket. Each number has a corresponding value.
        1 - Low, 2 - Medium, 3 - High, 4 - Urgent. This argument accepts the priority
        number or string.
      name: priority
      predefined:
      - Low
      - Medium
      - High
      - Urgent
    - defaultValue: "2"
      description: Status of the ticket. Each number has a corresponding value. 2
        - Open, 3 - Pending, 4 - Resolved, 5 - Closed, 6 - Waiting on Customer, 7
        - Waiting on Third Party. This argument accepts the ticket status number or
        string.
      name: status
      predefined:
      - Open
      - Pending
      - Resolved
      - Closed
      - Waiting on Customer
      - Waiting on Third Party
    - description: Email address or a Twitter handle of the requesting user. If an
        email address is entered and no contact exists with this email address in
        Freshdesk, it will be added as a new contact. If a Twitter handle is entered
        and no contact exists with this handle in Freshdesk, it will be added as a
        new contact.
      name: identifier
      required: true
    - description: ID or name of the group or agent to assign the ticket to. Use the
        `fd-list-groups` command to find potential assignees.
      name: responder
    - description: CSV list of entry IDs of files to attach to the ticket, e.g., "468@73f988d1-bda2-4adc-8e02-926f02190070,560@73f988d1-bda2-4adc-8e02-926f02190070".
        The total size of these attachments cannot exceed 15MB.
      isArray: true
      name: attachments
    - description: Additional, optional ticket fields. Format - "field=value" where
        field value pairs are delimited from subsequent pairs by a semicolon symbol
        ';' and where values that are lists are delimited by commas ',', e.g., "name=Example
        Example;email=example@example.com;tags=new,attention needed,billing related"
      isArray: true
      name: additional_fields
      predefined:
      - name
      - requester_id
      - facebook_id
      - phone
      - unique_external_id
      - type
      - cc_emails
      - due_by
      - email_config_id
      - fr_due_by
      - product_id
      - source
      - tags
      - company_id
      - email
      - twitter_id
      - responder_id
      - group_id
    description: Creates a new Freshdesk ticket.
    name: fd-create-ticket
    outputs:
    - contextPath: Freshdesk.Ticket.ID
      description: ID number of the ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Priority
      description: Ticket priority
      type: Number
    - contextPath: Freshdesk.Ticket.DueBy
      description: Timestamp that denotes when the ticket is due to be resolved
      type: Date
    - contextPath: Freshdesk.Ticket.Subject
      description: Ticket subject
      type: String
    - contextPath: Freshdesk.Ticket.Status
      description: Status of the ticket
      type: Number
    - contextPath: Freshdesk.Ticket.RequesterID
      description: User ID of the requester
      type: Number
    - contextPath: Freshdesk.Ticket.Tag
      description: Tags associated with the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.GroupID
      description: ID of the group the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.Source
      description: The channel through which the ticket was created
      type: Number
    - contextPath: Freshdesk.Ticket.CreatedAt
      description: Ticket creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.ResponderID
      description: ID of the agent the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.FrDueBy
      description: Timestamp that denotes when the first response is due
      type: Date
    - contextPath: Freshdesk.Ticket.AdditionalFields
      description: Additional fields and values that were entered using the 'additional_fields'
        arguments
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.AttachmentURL
      description: URL to download the file attached to the ticket to your local machine
      type: String
    - contextPath: Freshdesk.Ticket.Attachment.Name
      description: The name of the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Attachment.ID
      description: ID number for the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Size
      description: Size of the file attached to the ticket
      type: String
  - arguments:
    - description: ID number of the ticket to fetch
      name: id
      required: true
    - description: If set to `true`, the ticket requester's ID, email address, mobile
        number, name, and phone number will be included in the ticket's output. Note
        that this is not set by default because setting this to 'true' will consume
        an additional API credit per API call. To see more details, please turn to
        the Freshdesk API documentation - https://developers.freshdesk.com/api/#embedding
      name: include_requester
      predefined:
      - "true"
      - "false"
    - description: If set to `true` then the ticket’s closed_at, resolved_at and first_responded_at
        time will be included in the response. Note that this is not set by default
        because setting this to 'true' will consume an additional API credit per API
        call. To see more details, please turn to the Freshdesk API documentation
        - https://developers.freshdesk.com/api/#embedding
      name: include_stats
      predefined:
      - "true"
      - "false"
    description: Gets details of a ticket, specified by the ticket ID number.
    name: fd-get-ticket
    outputs:
    - contextPath: Freshdesk.Ticket.ID
      description: ID number of the fetched ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Priority
      description: Ticket priority
      type: Number
    - contextPath: Freshdesk.Ticket.DueBy
      description: Timestamp that denotes when the ticket is due to be resolved
      type: Date
    - contextPath: Freshdesk.Ticket.Subject
      description: Ticket subject
      type: String
    - contextPath: Freshdesk.Ticket.Status
      description: Ticket status
      type: Number
    - contextPath: Freshdesk.Ticket.RequesterID
      description: User ID of the requester
      type: Number
    - contextPath: Freshdesk.Ticket.Tag
      description: Tags associated with the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.GroupID
      description: ID of the group the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.Source
      description: The channel through which the ticket was created
      type: Number
    - contextPath: Freshdesk.Ticket.CreatedAt
      description: Ticket creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.ResponderID
      description: ID of the agent the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.FrDueBy
      description: Timestamp that denotes when the first response is due
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation
      description: Conversations associated with this ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.AttachmentURL
      description: URL to download the file attached to the ticket to your local machine
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Name
      description: The name of the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Attachment.ID
      description: ID number of the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Size
      description: Size of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.UpdatedAt
      description: Ticket update timestamp
      type: Date
  - arguments:
    - description: Subject of the ticket
      name: subject
    - defaultValue: "2"
      description: Status of the ticket. Each number has a corresponding value. 2
        is Open, 3 is Pending, 4 is Resolved, 5 is Closed, 6 is Waiting on Customer,
        7 is Waiting on Third Party. Acceptable values for this command argument are
        the digits 2,3,4,5,6,7, or their corresponding strings 'Open','Pending','Resolved','Closed','Waiting
        on Customer','Waiting on Third Party'.
      name: status
      predefined:
      - Open
      - Pending
      - Resolved
      - Closed
      - Waiting on Customer
      - Waiting on Third Party
    - defaultValue: "1"
      description: Priority of the ticket. Each number has a corresponding value.
        1 is Low, 2 is Medium, 3 is High, 4 is Urgent. Acceptable values for this
        command argument are the digits 1,2,3,4, or their corresponding strings 'Low','Medium','High','Urgent'.
      name: priority
      predefined:
      - Low
      - Medium
      - High
      - Urgent
    - description: HTML content of the ticket.
      name: description
    - description: ID number of the ticket to update
      name: id
      required: true
    - description: Update which agent is assigned to respond to this ticket by entering
        either their unique agent ID, name, or email.
      name: assigned_agent
    - description: Update the group assigned to respond to this ticket by entering
        the group's unique ID or the name of the group.
      name: assigned_group
    - description: Fields not included in the default command arguments that you wish
        to enter the value for. Format - "field=value" where field value pairs are
        delimited from subsequent pairs by a semicolon symbol ';' and where values
        that are lists are delimited by commas ','. E.g. - "name=Example Example;email=example@example.com;tags=new,attention
        needed,billing related"
      isArray: true
      name: additional_fields
      predefined:
      - name
      - requester_id
      - email
      - facebook_id
      - phone
      - twitter_id
      - unique_external_id
      - type
      - attachments
      - email_config_id
      - product_id
      - source
      - tags
      - company_id
      - due_by
      - fr_due_by
    description: Update the ticket specified by the ID
    name: fd-update-ticket
    outputs:
    - contextPath: Freshdesk.Ticket.ID
      description: ID of the updated ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Priority
      description: Ticket priority
      type: Number
    - contextPath: Freshdesk.Ticket.DueBy
      description: Timestamp that denotes when the ticket is due to be resolved
      type: Date
    - contextPath: Freshdesk.Ticket.Subject
      description: Ticket subject
      type: String
    - contextPath: Freshdesk.Ticket.Status
      description: Ticket status
      type: Number
    - contextPath: Freshdesk.Ticket.RequesterID
      description: User ID of the requester
      type: Number
    - contextPath: Freshdesk.Ticket.Tag
      description: Tags associated with the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.GroupID
      description: ID of the group assigned to the ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Source
      description: The channel through which the ticket was created
      type: Number
    - contextPath: Freshdesk.Ticket.CreatedAt
      description: Ticket creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.ResponderId
      description: ID of the agent the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.FrDueBy
      description: Timestamp that denotes when the first response is due
      type: Date
    - contextPath: Freshdesk.Ticket.UpdatedAt
      description: Ticket update timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.AdditionalFields
      description: Additional fields and values that were updated using the 'additional_fields'
        argument
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.AttachmentURL
      description: URL to download the file attached to the ticket to your local machine
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Name
      description: The name of the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.ContentType
      description: Content type of the attached file
      type: String
    - contextPath: Freshdesk.Ticket.Attachment.ID
      description: ID number for the attached file
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Size
      description: Size of the attached file in bytes
      type: String
  - arguments:
    - description: mobile number to filter the contacts by
      name: mobile
    - description: phone number to filter contacts by
      name: phone
    - description: The state of contacts by which you want to filter the contacts
      name: state
      predefined:
      - blocked
      - deleted
      - unverified
      - verified
    - description: Return contacts that have been updated after the timestamp given
        as this argument value. Acceptable format is 'YYYY-MM-DDTHH:MM:SSZ' E.g. '2018-01-19T02:00:00Z'.
      name: updated_since
    description: List all contacts matching the specified filters. If no filters are
      provided then all unblocked and undeleted contacts will be returned.
    name: fd-list-contacts
    outputs:
    - contextPath: Freshdesk.Contact.Active
      description: Set to true if the contact has been verified
      type: Boolean
    - contextPath: Freshdesk.Contact.Address
      description: Address of the contact
      type: String
    - contextPath: Freshdesk.Contact.CompanyID
      description: ID of the primary company to which this contact belongs
      type: Number
    - contextPath: Freshdesk.Contact.ViewAllTickets
      description: Set to true if the contact can see all tickets that are associated
        with the company to which s/he belong
      type: Boolean
    - contextPath: Freshdesk.Contact.Deleted
      description: Set to true if the contact has been deleted
      type: Boolean
    - contextPath: Freshdesk.Contact.Description
      description: A short description of the contact
      type: String
    - contextPath: Freshdesk.Contact.Email
      description: Primary email address of the contact
      type: String
    - contextPath: Freshdesk.Contact.ID
      description: ID of the contact
      type: Number
    - contextPath: Freshdesk.Contact.JobTitle
      description: Job Title of the contact
      type: String
    - contextPath: Freshdesk.Contact.Language
      description: Language of the contact
      type: String
    - contextPath: Freshdesk.Contact.Mobile
      description: Mobile number of the contact
      type: Number
    - contextPath: Freshdesk.Contact.Name
      description: Name of the contact
      type: String
    - contextPath: Freshdesk.Contact.Phone
      description: Telephone number of the contact
      type: Number
    - contextPath: Freshdesk.Contact.Tag
      description: Tags associated with this contact
      type: Unknown
    - contextPath: Freshdesk.Contact.TimeZone
      description: Time zone in which the contact resides
      type: String
    - contextPath: Freshdesk.Contact.TwitterID
      description: Twitter handle of the contact
      type: String
    - contextPath: Freshdesk.Contact.UniqueExternalID
      description: External ID of the contact
      type: String
    - contextPath: Freshdesk.Contact.CreatedAt
      description: Contact creation stamp
      type: Date
    - contextPath: Freshdesk.Contact.UpdatedAt
      description: Contact updated timestamp
      type: Date
  - arguments:
    - description: ID of the contact you wish to view the details of. To find ID numbers
        for your contacts try executing the 'fd-list-contacts' command.
      name: id
    - description: Mobile number of the contact you wish to view the details of
      name: mobile
    - description: Email address of the contact you wish to view the details of
      name: email
    description: View the details of the contact specified by the ID number
    name: fd-get-contact
    outputs:
    - contextPath: Freshdesk.Contact.Active
      description: Set to true if the contact has been verified
      type: Boolean
    - contextPath: Freshdesk.Contact.Address
      description: Address of the contact
      type: String
    - contextPath: Freshdesk.Contact.CompanyID
      description: ID of the primary company to which this contact belongs
      type: Number
    - contextPath: Freshdesk.Contact.ViewAllTickets
      description: Set to true if the contact can see all tickets that are associated
        with the company to which s/he belong
      type: Boolean
    - contextPath: Freshdesk.Contact.Deleted
      description: Set to true if the contact has been deleted
      type: Boolean
    - contextPath: Freshdesk.Contact.Description
      description: A short description of the contact
      type: String
    - contextPath: Freshdesk.Contact.Email
      description: Primary email address of the contact
      type: String
    - contextPath: Freshdesk.Contact.Id
      description: ID of the contact
      type: Number
    - contextPath: Freshdesk.Contact.JobTitle
      description: Job Title of the contact
      type: String
    - contextPath: Freshdesk.Contact.Language
      description: Language of the contact
      type: String
    - contextPath: Freshdesk.Contact.Mobile
      description: Mobile number of the contact
      type: Number
    - contextPath: Freshdesk.Contact.Name
      description: Name of the contact
      type: String
    - contextPath: Freshdesk.Contact.Phone
      description: Telephone number of the contact
      type: Number
    - contextPath: Freshdesk.Contact.Tag
      description: Tags associated with this contact
      type: Unknown
    - contextPath: Freshdesk.Contact.TimeZone
      description: Time zone in which the contact resides
      type: String
    - contextPath: Freshdesk.Contact.TwitterID
      description: Twitter handle of the contact
      type: String
    - contextPath: Freshdesk.Contact.UniqueExternalID
      description: External ID of the contact
      type: String
    - contextPath: Freshdesk.Contact.CreatedAt
      description: Contact creation timestamp
      type: Date
    - contextPath: Freshdesk.Contact.UpdatedAt
      description: Contact updated timestamp
      type: Date
  - arguments: []
    description: List all Canned Response Folders (Only users with Admin Privileges)
    name: fd-list-canned-response-folders
    outputs:
    - contextPath: Freshdesk.CRFolder.ID
      description: Unique ID of the canned response folder
      type: Number
    - contextPath: Freshdesk.CRFolder.Name
      description: Name of the canned response folder
      type: String
    - contextPath: Freshdesk.CRFolder.Personal
      description: Set true if the folder can only be accessed by you
      type: Boolean
    - contextPath: Freshdesk.CRFolder.ResponsesCount
      description: Number of canned responses in the folder
      type: Number
    - contextPath: Freshdesk.CRFolder.CreatedAt
      description: Canned Response Folder's creation timestamp
      type: Date
    - contextPath: Freshdesk.CRFolder.UpdatedAt
      description: Canned Response Folder's updated timestamp
      type: Date
  - arguments:
    - description: ID of the Folder containing the Canned Responses you wish to view
        the details of. To find ID numbers for your Canned Response folders try executing
        the 'fd-list-canned-response-folders' command.
      name: id
      required: true
    description: View the details of all the Canned Responses in a Folder.
    name: fd-get-canned-response-folder
    outputs:
    - contextPath: Freshdesk.CRFolder.CR.ID
      description: Unique ID of the canned response
      type: Number
    - contextPath: Freshdesk.CRFolder.CR.Title
      description: Title of the canned response
      type: String
    - contextPath: Freshdesk.CRFolder.CR.FolderID
      description: ID of the containing folder
      type: Number
    - contextPath: Freshdesk.CRFolder.CR.Content
      description: Plaintext version of the canned response content
      type: String
    - contextPath: Freshdesk.CRFolder.CR.ContentHTML
      description: HTML version of the canned response content
      type: String
    - contextPath: Freshdesk.CRFolder.CR.Attachment.AttachmentURL
      description: URL to download the file attached to the ticket to your local machine
      type: String
    - contextPath: Freshdesk.CRFolder.CR.Attachment.Name
      description: The name of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.CRFolder.CR.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.CRFolder.CR.Attachment.ID
      description: ID number for the file attached to the ticket
      type: Number
    - contextPath: Freshdesk.CRFolder.CR.Attachment.Size
      description: Size of the file attached to the file
      type: Number
  - arguments: []
    description: Lists all groups.
    name: fd-list-groups
    outputs:
    - contextPath: Freshdesk.Group.AgentID
      description: Array of agent user IDs separated by commas
      type: Unknown
    - contextPath: Freshdesk.Group.AutoTicketAssign
      description: Set to true when automatic ticket assignment was enabled. Automatic
        ticket assignment is only available on certain plans
      type: Boolean
    - contextPath: Freshdesk.Group.BusinessHourID
      description: Unique ID of the business hour associated with the group
      type: Number
    - contextPath: Freshdesk.Group.Description
      description: Description of the group
      type: String
    - contextPath: Freshdesk.Group.EscalateTo
      description: The ID of the user that an escalation email is sent to if a ticket
        is unassigned
      type: Number
    - contextPath: Freshdesk.Group.ID
      description: Unique ID of the group
      type: Number
    - contextPath: Freshdesk.Group.Name
      description: Name of the group
      type: String
    - contextPath: Freshdesk.Group.UnassignedFor
      description: The time after which an escalation email is sent if a ticket remains
        unassigned
      type: String
    - contextPath: Freshdesk.Group.CreatedAt
      description: Group creation timestamp
      type: Date
    - contextPath: Freshdesk.Group.UpdatedAt
      description: Grup updated timestamp
      type: Date
    - contextPath: Freshdesk.Group.GroupType
      description: Group Type of the group
      type: String
  - arguments:
    - description: ID of the ticket to add a reply to
      name: ticket_id
      required: true
    - description: Content of the reply (in HTML format)
      name: body
      required: true
    - description: The email address from which the reply is sent. By default, the
        global support email is used.
      name: from_email
    - description: ID of the agent who is adding the reply to the ticket
      name: user_id
    - description: CSV list of email addresses to add to the 'cc' field of the outgoing
        ticket email, e.g., "example1@example.com,example2@example.com,example3@example.com"
      isArray: true
      name: cc_emails
    - description: CSV list of email addresses to add to the 'bcc' field of the outgoing
        ticket email, e.g., "example1@example.com,example2@example.com,example3@example.com"
      isArray: true
      name: bcc_emails
    - description: CSV list of Entry IDs of files to attach to the reply, e.g., "468@73f988d1-bda2-4adc-8e02-926f02190070,560@73f988d1-bda2-4adc-8e02-926f02190070".
        The total size of these attachments cannot exceed 15MB.
      isArray: true
      name: attachments
    description: Adds a reply to a specified ticket.
    name: fd-ticket-reply
    outputs:
    - contextPath: Freshdesk.Ticket.Conversation.BodyHTML
      description: Content of the conversation (in HTML format)
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.BodyText
      description: Content of the conversation (in plain text format)
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.ID
      description: ID of the conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.Incoming
      description: Set to true when a particular conversation should appear as being
        created outside of the web portal
      type: Boolean
    - contextPath: Freshdesk.Ticket.Conversation.ToEmail
      description: Array of email addresses of agents/users who need to be notified
        about this conversation
      type: Unknown
    - contextPath: Freshdesk.Ticket.Conversation.Private
      description: Set to true if the note is private
      type: Boolean
    - contextPath: Freshdesk.Ticket.Conversation.Source
      description: Denotes the type of conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.SupportEmail
      description: Email address from which the reply is sent. For notes
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.TicketID
      description: ID of the ticket that the conversation was added to
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.UserID
      description: ID of the agent/user who added the conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.CreatedAt
      description: Conversation creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation.UpdatedAt
      description: Conversation updated timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation.FromEmail
      description: The email address that the reply was sent from. By default
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.AttachmentURL
      description: URL of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.Name
      description: The name of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.ID
      description: ID number of the file attached to the ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.Size
      description: Size of the file attached to the ticket
      type: Number
  - arguments:
    - description: ID of the ticket for which you would like to list all of its conversations
      name: ticket_id
      required: true
    description: Lists all replies and notes for a specified ticket.
    name: fd-get-ticket-conversations
    outputs:
    - contextPath: Freshdesk.Ticket.Conversation.BodyHTML
      description: Content of the conversation (in HTML format)
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.BodyText
      description: Content of the conversation (in plain text format)
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.ID
      description: ID of the conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.Incoming
      description: Set to true when a particular conversation should appear as being
        created outside of the web portal
      type: Boolean
    - contextPath: Freshdesk.Ticket.Conversation.ToEmail
      description: Array of email addresses of agents/users who need to be notified
        about this conversation
      type: Unknown
    - contextPath: Freshdesk.Ticket.Conversation.Private
      description: Set to true if the note is private
      type: Boolean
    - contextPath: Freshdesk.Ticket.Conversation.Source
      description: Denotes the type of conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.SupportEmail
      description: Email address from which the reply is sent. For notes
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.TicketID
      description: ID of the ticket that the conversation was added to
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.UserID
      description: ID of the agent/user who added the conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.CreatedAt
      description: Conversation creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation.UpdatedAt
      description: Conversation updated timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation.FromEmail
      description: The email address that the reply was sent from. By default
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.AttachmentURL
      description: URL of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.Name
      description: The name of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.ID
      description: ID number of the file attached to the ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.Size
      description: Size of the file attached to the ticket
      type: Number
  - arguments:
    - description: Mobile phone number to filter agents by. Enter the number without
        dashes or spaces between the numbers. Numbers should be entered as they appear
        in your Freshdesk web portal. If the number appears in your web portal with
        a plus sign and country code, then that is how you should enter here, e.g.,
        '+972501231231'.
      name: mobile
    - description: Telephone number to filter agents by. Enter the number without
        dashes or spaces between the numbers. Numbers should be entered as they appear
        in your Freshdesk web portal. If the number appears in your web portal with
        a plus sign and country code, then that is how you should enter it here, e.g.,
        '+972501231231'.
      name: phone
    - description: List all agents who are either 'fulltime' or 'occasional'
      name: state
      predefined:
      - fulltime
      - occasional
    description: Returns a list of agents that match the filter criteria.
    name: fd-list-agents
    outputs:
    - contextPath: Freshdesk.Agent.Available
      description: Set to `true` when the agent is in a group that has enabled "Automatic
        Ticket Assignment" and is accepting new tickets
      type: Boolean
    - contextPath: Freshdesk.Agent.AvailableSince
      description: Timestamp that denotes when the agent became available/unavailable
        (depending on the value of the 'available' attribute)
      type: Date
    - contextPath: Freshdesk.Agent.ID
      description: User ID of the agent
      type: Number
    - contextPath: Freshdesk.Agent.Occasional
      description: Set to true when the agent is an occasional agent (true => occasional
      type: Boolean
    - contextPath: Freshdesk.Agent.Signature
      description: Signature of the agent (in HTML format)
      type: String
    - contextPath: Freshdesk.Agent.TicketScope
      description: |-
        Ticket permission of the agent
        (1 - Global Access, 2 - Group Access, 3 - Restricted Access)
      type: Number
    - contextPath: Freshdesk.Agent.GroupID
      description: Group IDs associated with the agent
      type: Unknown
    - contextPath: Freshdesk.Agent.RoleID
      description: Role IDs associated with the agent
      type: Unknown
    - contextPath: Freshdesk.Agent.CreatedAt
      description: Agent creation timestamp
      type: Date
    - contextPath: Freshdesk.Agent.UpdatedAt
      description: Agent updated timestamp
      type: Date
    - contextPath: Freshdesk.Agent.Contact.Active
      description: Set to true when the agent is verified
      type: Boolean
    - contextPath: Freshdesk.Agent.Contact.Email
      description: Email Address of the agent
      type: String
    - contextPath: Freshdesk.Agent.Contact.JobTitle
      description: Job title of the agent
      type: String
    - contextPath: Freshdesk.Agent.Contact.Language
      description: Language of the agent. Default language is "en"
      type: String
    - contextPath: Freshdesk.Agent.Contact.LastLoginAt
      description: Timestamp of the agent's last successful login
      type: Date
    - contextPath: Freshdesk.Agent.Contact.Mobile
      description: Mobile number of the agent
      type: Number
    - contextPath: Freshdesk.Agent.Contact.Name
      description: Name of the agent
      type: String
    - contextPath: Freshdesk.Agent.Contact.Phone
      description: Telephone number of the agent
      type: Number
    - contextPath: Freshdesk.Agent.Contact.TimeZone
      description: Time zone of the agent
      type: String
    - contextPath: Freshdesk.Agent.Contact.CreatedAt
      description: Contact creation timestamp
      type: Date
    - contextPath: Freshdesk.Agent.Contact.UpdatedAt
      description: Contact updated timestamp
      type: Date
    - contextPath: Freshdesk.Agent.Type
      description: Type of agent
      type: String
  - arguments:
    - description: ID of the ticket to make a note for
      name: ticket_id
      required: true
    - description: Content of the note (in HTML format)
      name: body
      required: true
    - description: Set to false if the note is public
      name: private
      predefined:
      - "true"
      - "false"
    - description: ID of the agent who is adding the note. To find agent ID numbers,
        run the 'fd-list-agents' command.
      name: user_id
    - description: CSV list of agent email addresses to be notify about this note,
        e.g., "example1@example.com,example2@example.com,example3@example.com"
      isArray: true
      name: notify_emails
    - description: Set to true if a particular note should appear as being created
        outside of the web portal
      name: incoming
      predefined:
      - "true"
      - "false"
    - description: CSV list of entry IDs of files to attach to the note, e.g., "468@73f988d1-bda2-4adc-8e02-926f02190070,560@73f988d1-bda2-4adc-8e02-926f02190070".
        The total size of these attachments cannot exceed 15MB.
      isArray: true
      name: attachments
    description: Creates a note for a specified ticket. By default, notes are private.
      To make a note public, set the 'private' argument to false.
    name: fd-create-ticket-note
    outputs:
    - contextPath: Freshdesk.Ticket.Conversation.BodyHTML
      description: Content of the conversation (in HTML)
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.BodyText
      description: Content of the conversation (in plain text)
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.ID
      description: ID of the conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.Incoming
      description: Set to true when a particular conversation should appear as being
        created outside of the web portal
      type: Boolean
    - contextPath: Freshdesk.Ticket.Conversation.ToEmail
      description: List of agent/user email addresses of agents/users who need to
        be notified about this conversation
      type: Unknown
    - contextPath: Freshdesk.Ticket.Conversation.Private
      description: Is the conversation private
      type: Boolean
    - contextPath: Freshdesk.Ticket.Conversation.Source
      description: Conversation type
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.SupportEmail
      description: Email address the reply is sent from. For notes
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.TicketID
      description: ID of the ticket the conversation was added to
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.UserID
      description: ID of the agent/user who added the conversation
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.CreatedAt
      description: Conversation creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation.UpdatedAt
      description: Conversation updated timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation.FromEmail
      description: The email address that the reply/note was sent from. By default
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.AttachmentURL
      description: URL of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.Name
      description: The name of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.ID
      description: ID number of the file attached to the ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Conversation.Attachment.Size
      description: ize of the file attached to the ticket
      type: Number
  - arguments:
    - description: ID of the ticket to delete
      name: id
      required: true
    description: Deletes a ticket.
    name: fd-delete-ticket
  - arguments:
    - description: |-
        Predefined filters for filtering tickets. The options are:
        'new_and_my_open' - New and my open tickets.
        'watching' - Tickets I'm watching.
        'spam' - Tickets that have been marked as spam.
        'deleted' - Tickets that have been soft-deleted, aka moved to Trash.
      name: filter
      predefined:
      - new_and_my_open
      - watching
      - spam
      - deleted
    - description: Filter results by the ticket requester's email address or ID. To
        find your contacts' ID numbers or email addresses, run the 'fd-list-contacts'
        command.
      name: requester
    - description: By default, tickets created within the previous 30 days are returned.
        For older tickets, use this filter ("2015-01-19T02:00:00Z")
      name: updated_since
    - description: Field for ordering the list of tickets. The default sort order
        uses the 'created_at' field.
      name: order_by
      predefined:
      - created_at
      - due_by
      - updated_at
      - status
    - description: Return list results in ascending or descending order according
        to the order_by value, default is descending
      name: order_type
      predefined:
      - asc
      - desc
    - description: If set to 'true' then ticket’s closed_at, resolved_at and first_responded_at
        time will be included. Note that this is not set by default because setting
        this to 'true' will consume an additional 2 API credits per API call. To see
        more details, see the Freshdesk API documentation - https://developers.freshdesk.com/api/#embedding
      name: include_stats
      predefined:
      - "true"
      - "false"
    - description: If set to 'true' then the ticket requester's ID, email address,
        mobile number, name, and phone number are included in the ticket's output
        for each ticket. Note that this is not set by default because setting this
        to 'true' will consume an additional 2 API credits per API call. To see more
        details, see the Freshdesk API documentation - https://developers.freshdesk.com/api/#embedding
      name: include_requester
      predefined:
      - "true"
      - "false"
    - description: If set to 'true' then the ticket's description and description_text
        are included the tickets' outputs. Note that this is not set by default because
        setting this to 'true' will consume an additional 2 API credits per API call.
        To see more details, see the Freshdesk API documentation - https://developers.freshdesk.com/api/#embedding
      name: include_description
      predefined:
      - "true"
      - "false"
    - description: |-
        Filter tickets using a custom query.

        Format - "(ticket_field:integer OR ticket_field:'string') AND ticket_field:boolean"
        Example - "(type:'Question' OR type:'Problem') AND (due_by:>'2017-10-01' AND due_by:<'2017-10-07')"
        For more examples, see the Freshdesk API documentation https://developers.freshdesk.com/api/#filter_tickets

        Note that the custom_query argument cannot be used in conjunction with this command's other arguments.
      name: custom_query
    description: |-
      Returns a list of all tickets that match the filter criteria. If
      no filters are specified, all tickets from the last 30 days are returned.
      Note that this command can consume multiple API credits - this can occur
      if the count of tickets resulting from your query exceeds 30 - in that instance
      this command makes additional calls to the API to retrieve additional tickets
      matching your query.
    name: fd-search-tickets
    outputs:
    - contextPath: Freshdesk.Ticket.ID
      description: ID number of the fetched ticket
      type: Number
    - contextPath: Freshdesk.Ticket.Priority
      description: Ticket priority
      type: Number
    - contextPath: Freshdesk.Ticket.DueBy
      description: Timestamp that denotes when the ticket is due to be resolved
      type: Date
    - contextPath: Freshdesk.Ticket.Subject
      description: Ticket subject
      type: String
    - contextPath: Freshdesk.Ticket.Status
      description: Ticket status
      type: Number
    - contextPath: Freshdesk.Ticket.RequesterID
      description: User ID of the requester
      type: Number
    - contextPath: Freshdesk.Ticket.Tag
      description: Tags associated with the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.GroupID
      description: ID of the group the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.Source
      description: The channel through which the ticket was created
      type: Number
    - contextPath: Freshdesk.Ticket.CreatedAt
      description: Ticket creation timestamp
      type: Date
    - contextPath: Freshdesk.Ticket.ResponderID
      description: ID of the agent the ticket was assigned to
      type: Number
    - contextPath: Freshdesk.Ticket.FrDueBy
      description: Timestamp that denotes when the first response is due
      type: Date
    - contextPath: Freshdesk.Ticket.Conversation
      description: Conversations associated with this ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.AttachmentURL
      description: URL to download the file attached to the ticket to your local machine
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Name
      description: The name of the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.ContentType
      description: Content type of the file attached to the ticket
      type: String
    - contextPath: Freshdesk.Ticket.Attachment.ID
      description: ID number of the file attached to the ticket
      type: Unknown
    - contextPath: Freshdesk.Ticket.Attachment.Size
      description: Size of the file attached to the ticket
      type: String
  isfetch: true
  runonce: false
  script: |2-



    ''' IMPORTS '''


    import requests

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' GLOBALS/PARAMS '''

    PARAMS = demisto.params()
    CREDS = PARAMS.get('credentials')
    USERNAME = CREDS.get('identifier') if CREDS else None
    PASSWORD = CREDS.get('password') if CREDS else None
    TOKEN = PARAMS.get('token')

    if not (USERNAME and PASSWORD) and not TOKEN:
        err_msg = 'You must provide either your Freshdesk account API key or the ' \
                  'username and password you use to sign into your Freshdesk account ' \
                  'when instantiating an instance of the Freshdesk integration.'
        return_error(err_msg)

    AUTH = (TOKEN, 'X') if TOKEN else (USERNAME, PASSWORD)

    # How much time before the first fetch to retrieve incidents
    FETCH_TIME = PARAMS.get('fetch_time', '24 hours')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = PARAMS['url'][:-1] if (PARAMS.get('url') and PARAMS['url'].endswith('/')) else PARAMS['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # Service base URL
    BASE_URL = SERVER + '/api/v2/'

    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    # Headers to be used when making a request to POST a multi-part encoded file
    MULTIPART_HEADERS = {'Accept': 'application/json'}

    # Default amount of results returned per-page/per-api-call when the
    # fd-search-tickets command's results that match the command's specified
    # filter criteria exceeds 30
    PER_PAGE = 30

    # The API response ticket attributes that will be included
    # in most command's context outputs
    DEFAULT_TICKET_CONTEXT_FIELDS = [
        'priority', 'due_by', 'subject', 'status',
        'requester_id', 'tags', 'group_id', 'source', 'created_at',
        'responder_id', 'fr_due_by', 'id'
    ]


    ''' HELPER FUNCTIONS '''


    def reformat_canned_response_context(context):
        """
        Reformat context for canned-response related commands (from having used string_to_context_key)
        to desired output format.

        parameter: (dict) context
            The context to reformat

        returns:
            The reformatted context
        """
        for key, val in context.iteritems():
            if 'Id' in key:
                new_key = key.replace('Id', 'ID')
                context[new_key] = val
                del context[key]
            elif 'Html' in key:
                new_key = key.replace('Html', 'HTML')
                context[new_key] = val
                del context[key]
        return context


    def reformat_conversation_context(context):
        """
        Reformat context for conversation related commands (from having used string_to_context_key)
        to desired output format.

        parameter: (dict) context
            The context to reformat

        returns:
            The reformatted context
        """
        to_emails = context.get('ToEmails')
        body = context.get('Body')
        attachments = context.get('Attachments')
        if to_emails:
            context['ToEmail'] = to_emails
            del context['ToEmails']
        if body:
            context['BodyHTML'] = body
            del context['Body']
        if attachments:
            del context['Attachments']
        return context


    def format_contact_context(contact):
        """
        Format context for contact related commands.

        parameter: (dict) contact
            The API response from executing a contact related command whose attributes need
            to be parsed into context

        returns:
            The formatted context
        """
        dont_include = ['other_companies', 'other_emails', 'custom_fields', 'avatar']
        # Parse response into context
        context = {}
        for key, val in contact.iteritems():
            if key not in dont_include and val:
                new_key = string_to_context_key(key)
                if 'Id' in new_key:
                    new_key = new_key.replace('Id', 'ID')
                elif new_key == 'Tags':
                    new_key = 'Tag'
                context[new_key] = val
        return context


    def reformat_ticket_context(context):
        """
        Reformat context outputs (from having used string_to_context_key) to desired output format.

        parameter: (dict) context
            The context to reformat

        returns:
            The reformatted context
        """
        standard_context_outputs = [
            'Priority', 'DueBy', 'Subject', 'Status', 'RequesterID',
            'Tag', 'GroupID', 'Source', 'CreatedAt', 'ResponderID',
            'FrDueBy', 'ID', 'UpdatedAt', 'Attachment', 'AdditionalFields',
            'UserID', 'BodyText', 'Category', 'Private', 'Incoming'
        ]

        for key, val in context.iteritems():
            if key == 'Tags':
                new_key = key[:-1]
                context[new_key] = val
                del context[key]
            elif key == 'CustomFields':
                new_key = key[:-1]
                context[new_key] = val
                del context[key]
            elif key == 'FwdEmails':
                new_key = key[:-1]
                context[new_key] = val
                del context[key]
            elif key == 'Description':
                new_key = 'DescriptionHTML'
                context[new_key] = val
                del context[key]
            elif 'Id' in key:
                new_key = key.replace('Id', 'ID')
                context[new_key] = val
                del context[key]
            elif 'Cc' in key:
                if key.endswith('s'):
                    new_key = key[:-1].replace('Cc', 'CC')
                else:
                    new_key = key.replace('Cc', 'CC')
                context[new_key] = val
                del context[key]

        # If 'Attachments' are still in context get rid of them - should be 'Attachment'
        attachments = context.get('Attachments')
        if attachments:
            del context['Attachments']

        new_context = {}
        new_context['AdditionalFields'] = context.get('AdditionalFields') if context.get('AdditionalFields') else {}
        additional_fields = {}
        for key, val in context.iteritems():
            if key not in standard_context_outputs:
                if not ((isinstance(val, list) or isinstance(val, dict)) and len(val) == 0):
                    additional_fields[key] = val
            else:
                new_context[key] = val
        new_context['AdditionalFields'] = dict(new_context.get('AdditionalFields', {}), **additional_fields)
        return new_context


    def handle_search_tickets_pagination(args, response):
        """
        Retrieve all resulting tickets even over the default 30 returned by a single API call.

        When the search_tickets_command results in more tickets than the default per page count (30) returned from
        making an API call, then this function retrieves the remaining tickets by iterating and making API calls
        per additional page of results.

        parameter: (dict) args
            search_tickets_command arguments

        parameter: (dict) response
            The initial json response from making an API call in the search_tickets function

        returns:
            All Ticket Objects
        """
        # If user entered custom_query arg, the resulting tickets are in the 'results' attribute of the response
        if args.get('custom_query'):
            # Max page count allowed by API when using custom query
            max_pages = 10
            # Deal with pagination if necessary
            tickets = response.get('results')
            total_tickets = response.get('total')
            total_tickets -= PER_PAGE
            page = 1
            while total_tickets > 0 and page <= max_pages:
                page += 1
                args['page'] = page
                tickets_page = search_tickets(args)
                tickets.extend(tickets_page.get('results'))
                total_tickets -= PER_PAGE
        else:
            # Max page count allowed by API when using normal filters
            max_pages = 300
            tickets = response
            page = 1
            next_page = tickets
            while next_page and page <= max_pages:
                page += 1
                args['page'] = page
                next_page = search_tickets(args)
                if next_page:
                    tickets.extend(next_page)
        return tickets


    def attachments_into_context(api_response, context):
        """
        Get the attachments field from the api_response argument if present and parse it into the context.

        parameter: (dict) api_response
            The json response returned by the calling function's associated 'requests' function in which calls
            to the API are made.

        parameter: (dict) context
            The context that will be modified and returned to the war room

        returns:
            The modified context, and the modified context with the attachments in readable format for the
            human readable output
        """
        attachment_keys_to_include = [
            'attachment_url', 'content_type', 'id', 'name', 'size'
        ]

        context_readable = dict(**context)
        # Parse attachments into context
        attachments = api_response.get('attachments')
        if attachments:
            attachments_context = []
            attachments_context_readable = []
            for attachment in attachments:
                attachment_context = {}
                for key, val in attachment.iteritems():
                    if key in attachment_keys_to_include:
                        if key == 'attachment_url':
                            key = 'AttachmentURL'
                        elif key == 'id':
                            key = 'ID'
                        else:
                            key = string_to_context_key(key)
                        attachment_context[key] = val
                attachment_formatted = formatCell(attachment_context).split('\n')
                attachment_formatted = ', '.join(attachment_formatted)
                attachments_context_readable.append(attachment_formatted)

                attachments_context.append(attachment_context)
            context['Attachment'] = attachments_context
            context_readable['Attachment'] = attachments_context_readable
        return context, context_readable


    def additional_fields_to_context(context, already_in_context, additional_fields, additional_values):
        """
        Parses fields not presented as part of the command's standard arguments into the context.

        For commands where the user can enter additional fields and their associated values beyond what
        is offered by the standard arguments (but are still supported by the API endpoint). If the additional
        fields are not part of the standard context output for that command, then those fields and values
        from the API call are parsed and subcategorized under the 'AdditionalFields' context output.

        parameter: (dict) context
            The context that will be modified and returned to the war room

        parameter: (list) already_in_context
            List of fields which are ordinarily/already parsed into the context

        parameter: (list) additional_fields
            List of the fields beyond the command's standard arguments that the user entered as part
            of the call to the API endpoint

        parameter: (list) additional_values
            List of values corresponding to the additional_fields argument

        returns:
            The modified context
        """
        # Parse additional fields into context
        if additional_fields and additional_values:
            added_context = {}
            for field, value in zip(additional_fields, additional_values):
                if field not in already_in_context and field != 'attachments':
                    key = string_to_context_key(field)
                    added_context[key] = value
            context['AdditionalFields'] = added_context
        return context


    def additional_fields_to_args(args, additional_fields_arg_name):
        """
        Parses the additional_fields command argument for the individual fields and values and
        reassigns them to the args dictionary.

        parameter: (dict) args
            The command's arguments

        parameter: (string) additional_fields_arg_name
            The name of the command argument that contains the additional fields and values

        returns:
            The args dictionary that has been updated with the additional fields and values,
            the list of additional fields, and the list of additional values.
        """
        additional_fields = args.get(additional_fields_arg_name)
        if additional_fields:
            fields, values = [], []
            fields_and_vals = additional_fields.split(';')
            # For the case there is only one additional field + value
            if len(fields_and_vals) == 1:
                fields_and_vals = list(fields_and_vals)
            for field_and_val in fields_and_vals:
                field_and_val = field_and_val.split('=')
                # If the length doesn't equal 2, means there were either no equal signs or more than one
                if not len(field_and_val) == 2:
                    err_msg = 'It appears you entered either too many or too few' \
                              ' equal signs in the \'additional_fields\' argument.'
                    return_error(err_msg)
                field = field_and_val[0].strip()
                val = field_and_val[1]

                # If the value contains commas, then it is a list
                if ',' in val:
                    val = argToList(val)
                args[field] = val
                fields.append(field)
                values.append(val)
            del args[additional_fields_arg_name]
            return args, fields, values
        return args, None, None


    def ticket_to_incident(ticket):
        """
        Create incident from ticket object.

        parameter: (object) ticket
            Ticket object

        returns:
            Incident Object
        """
        incident = {}
        # Incident Title
        incident['name'] = 'Freshdesk Ticket: "{}"'.format(ticket.get('subject'))
        # Incident occurrence time - the ticket's creation time
        incident['occurred'] = ticket.get('created_at')
        # The raw response from the service, providing full info regarding the item
        incident['rawJSON'] = json.dumps(ticket)
        return incident


    def get_additional_fields(args):
        """
        Determine which fields need to be added to context based off arguments given in the search_tickets_command.

        parameter: (dict) args
            The search_tickets_command arguments

        returns:
            List of fields to be added to the context outputs
        """
        additional_fields = []  # fields that should be added to output context
        filter = args.get('filter')
        if filter:
            if filter == 'deleted':
                additional_fields.append('deleted')
            elif filter == 'spam':
                additional_fields.append('spam')
        requester = args.get('requester')
        if requester:
            if '@' in requester:
                additional_fields.append('email')
        company_id = args.get('company_id')
        if company_id:
            additional_fields.append('company_id')
        if args.get('include_description') and args.get('include_description').lower() == 'yes':
            additional_fields.extend(['description', 'description_text'])
        return additional_fields


    def entries_to_files(entry_ids):
        """
        Format file details (retrieved using the files' entry IDs) to API expectations to include files in API call.

        parameter: (list) entry_ids
            List of entry ID strings for files uploaded to the warroom

        returns:
            List of attachment field, value tuples formatted according to API expectations
        """
        attachments = []
        for entry_id in entry_ids:
            execute_results = demisto.getFilePath(entry_id)
            file_path = execute_results['path']
            file_name = execute_results['name']
            attachments.append(('attachments[]', (file_name, open(file_path, 'rb'))))

        return attachments


    def handle_array_input(args):
        """
        Format any command argument that is supposed to be an array from a string to a list.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with field values transformed from strings to lists where necessary
        """
        array_inputs = [
            'tags', 'attachments', 'cc_emails', 'bcc_emails', 'to_emails',
            'update_fields', 'update_values', 'notify_emails'
        ]
        attchs_present = args.get('attachments')
        if attchs_present:
            for arr_input in array_inputs:
                if arr_input in args.keys():
                    if arr_input != 'attachments':
                        args[arr_input + '[]'] = argToList(args.get(arr_input))
                        del args[arr_input]
                    else:
                        args[arr_input] = argToList(args.get(arr_input))
        else:
            for arr_input in array_inputs:
                if arr_input in args.keys():
                    args[arr_input] = argToList(args.get(arr_input))
        return args


    def validate_priority_input(args):
        """
        Check entered value for command argument 'priority' and format to API expectations.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with the value for 'priority' field reformatted if necessary
        """
        # Parse and ensure valid command argument
        priority = args.get('priority', None)

        # If priority wasn't given by the user as a cmd arg
        # then no need to alter it to API expectations
        if not priority:
            return args

        priorities = ['low', 'medium', 'high', 'urgent']

        # Check if the user entered status as words - aka the
        # options listed above in 'statuses'
        err_msg = 'priority should be one of these values: 1, 2, 3, 4, {}'.format(', '.join(priorities))
        if len(priority) > 1:
            if priority.lower() in priorities:
                # Add 1 since API status numbers for tickets start at 1
                # Cast to string so clean_arguments helper function doesn't throw any errors
                args['priority'] = str(priorities.index(priority.lower()) + 1)
            else:
                return_error(err_msg)
        # Otherwise make sure the user entered valid status number
        elif not (0 < int(priority) < 5):
            return_error(err_msg)
        return args


    def validate_status_input(args):
        """
        Check entered value for command argument 'status' and format to API expectations.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with the value for 'status' field reformatted if necessary
        """
        # Parse and ensure valid command argument
        status = args.get('status', None)

        # If status wasn't given by the user as a cmd arg
        # then no need to alter it to API expectations
        if not status:
            return args

        statuses = [
            'open', 'pending', 'resolved', 'closed',
            'waiting on customer', 'waiting on third party'
        ]

        # Check if the user entered status as words - aka the
        # options listed above in 'statuses'
        err_msg = 'status should be one of these values: 2, 3, 4, 5, 6, 7, {}'.format(', '.join(statuses))
        if len(status) > 1:
            if status.lower() in statuses:
                # Add 2 since API status numbers for tickets start at 2
                # Cast to string so clean_arguments helper function doesn't throw any errors
                args['status'] = str(statuses.index(status.lower()) + 2)
            else:
                return_error(err_msg)
        # Otherwise make sure the user entered valid status number
        elif not (1 < int(status) < 8):
            return_error(err_msg)
        return args


    def handle_number_input(args):
        """
        Format any command argument that is supposed to be a number from a string to an int.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with field values transformed from strings to numbers where necessary
        """
        # Command args that should be numbers
        number_args = [
            'requester_id', 'status', 'priority', 'responder_id',
            'email_config_id', 'group_id', 'product_id', 'source', 'company_id'
        ]
        # Convert cmd args that are expected to be numbers from strings to numbers
        for num_arg in number_args:
            if num_arg in args.keys():
                args[num_arg] = int(args.get(num_arg))
        return args


    def clean_arguments(args):
        """
        Perform all validation and reformatting of command arguments.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with all field values reformatted where necessary
        """
        args = validate_status_input(args)
        args = validate_priority_input(args)
        args = handle_array_input(args)
        args = handle_number_input(args)
        return args


    def determine_identifier(args):
        """
        Determine whether the input for the 'identifier' argument is an
        email or twitter handle and adjust 'args' accordingly.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with the email or twitter_id field (depending on what the value was)
            assigned the value entered for the 'identifier' argument
        """
        identifier = args.get('identifier')
        if identifier.startswith('@'):
            # Then it's a twitter handle
            args['twitter_id'] = identifier
        elif '@' in identifier:
            # Otherwise assume it's an email address
            args['email'] = identifier
        else:
            err_msg = 'The entered value for the \'identifier\' argument must ' \
                      'be either a Twitter handle or an Email Address.'
            return_error(err_msg)
        # Delete identifier field from args since it doesn't match API expected inputs
        del args['identifier']
        return args


    def determine_responder(args):
        """
        Determine whether the input for the 'responder' argument is a group or an agent and adjust 'args' accordingly.

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with the group_id or responder_id field (depending on what the value was)
            assigned the value entered for the 'responder' argument
        """
        responder = args.get('responder', None)
        if responder:
            args = determine_group(args, 'responder')
            args = determine_agent(args, 'responder')
        return args


    def determine_agent(args, key_name):
        """
        Determine if the value points to an agent by checking against all agent names, emails, and IDs, and adjust
        'args' accordingly.

        parameter: (string) key_name
            The name of the command argument

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with responder_id field assigned the appropriate value if the value passed
            for the command argument represented by 'key_name' is associated with an Agent's details
        """
        assigned_agent = args.get(key_name, None)
        if assigned_agent:
            agent_emails, agent_names, agent_ids = [], [], []
            # Get names, emails and ids of agents
            agents = list_agents()
            for agent in agents:
                agent_ids.append(agent.get('id'))
                contact_info = agent.get('contact')
                if contact_info:
                    agent_names.append(contact_info.get('name', '').lower())
                    agent_emails.append(contact_info.get('email', '').lower())
            # Check if responder value is a contact ID
            if assigned_agent in agent_ids:
                args['responder_id'] = assigned_agent
                # Delete assigned_agent field from args since it doesn't match API expected inputs
                del args[key_name]
            elif assigned_agent.lower() in agent_names:
                agent_name_idx = agent_names.index(assigned_agent.lower())
                args['responder_id'] = agent_ids[agent_name_idx]
                del args[key_name]
            elif assigned_agent.lower() in agent_emails:
                agent_email_idx = agent_emails.index(assigned_agent.lower())
                args['responder_id'] = agent_ids[agent_email_idx]
                del args[key_name]

        return args


    def determine_group(args, key_name):
        """
        Determine if the value points to a group by checking against all group names and IDs, and adjust
        'args' accordingly.

        parameter: (string) key_name
            The name of the command argument

        parameter: (dict) args
            The command arguments dictionary

        returns:
            The arguments dict with group_id field assigned the appropriate value if the value passed
            for the command argument represented by 'key_name' is associated with a Group's details
        """
        assigned_group = args.get(key_name, None)
        if assigned_group:
            group_names, group_ids = [], []
            # Get names and ids of groups
            groups = list_groups()
            for group in groups:
                group_ids.append(group.get('id'))
                group_names.append(group.get('name', '').lower())
            # Check if responder value is a group ID
            if assigned_group in group_ids:
                args['group_id'] = assigned_group
                del args[key_name]
            # Or the name of a group
            elif assigned_group.lower() in group_names:
                group_name_idx = group_names.index(assigned_group.lower())
                args['group_id'] = group_ids[group_name_idx]
                del args[key_name]
        return args


    def http_request(method, url_suffix, params=None, data=None, files=None, headers=HEADERS):
        """
        A wrapper for requests lib to send our requests and handle requests and responses better.

        parameter: (string) method
            A string denoting the http request method to use.
            Can be 'GET', 'POST, 'PUT', 'DELETE', etc.

        parameter: (string) url_suffix
            The API endpoint that determines which data we are trying to access/change in our
            call to the API

        parameter: (dict) params
            The key/value pairs to be encoded as part of the URL's query string

        parameter: (dict) data
            The key/value pairs to be form-encoded

        parameter: (list) files
            The multipart-encoded files to upload

        parameter: (dict) headers
            The headers to use with the request

        returns:
            JSON Response Object
        """
        res = requests.request(
            method,
            BASE_URL + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=headers,
            auth=AUTH,
            files=files
        )
        # Handle error responses gracefully
        if res.status_code not in {200, 201, 202, 204}:
            LOG(res.json())
            LOG(res.text)
            LOG.print_log()
            err_msg = 'Error in API call to Freshdesk Integration [{}] - {}'.format(res.status_code, res.reason)
            err = json.loads(res.content)
            if err.get('errors'):
                for error in err.get('errors'):
                    err_msg += '\n' + json.dumps(error, indent=2)
            else:
                for key, value in res.json().iteritems():
                    err_msg += '\n{}: {}'.format(key, value)
            return_error(err_msg)
        # Handle response with no content
        elif res.status_code == 204:
            return res

        return res.json()


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Will try to make a request to the API endpoint for listing all tickets.
        """
        http_request('GET', 'tickets')


    def fetch_incidents():
        # demisto.getLastRun() will returns an obj with the previous run in it.
        last_run = demisto.getLastRun()
        # Get the last fetch time, if exists
        last_fetch = last_run.get('last_created_incident_timestamp')

        # Handle first time fetch, fetch incidents retroactively
        if not last_fetch:
            last_fetch, _ = parse_date_range(FETCH_TIME, to_timestamp=True)
        updated_since = timestamp_to_datestring(last_fetch, date_format='%Y-%m-%dT%H:%M:%SZ')
        args = {'updated_since': updated_since, 'order_type': 'asc'}

        tickets = search_tickets(args)
        # convert the ticket/events to demisto incidents
        incidents = []
        for ticket in tickets:
            incident = ticket_to_incident(ticket)
            incident_date = date_to_timestamp(incident.get('occurred'), '%Y-%m-%dT%H:%M:%SZ')
            # Update last run and add incident if the incident is newer than last fetch
            if incident_date > last_fetch:
                last_fetch = incident_date
                incidents.append(incident)

        demisto.setLastRun({'last_created_incident_timestamp': last_fetch})
        demisto.incidents(incidents)


    '''<------ TICKETS ------>'''


    def create_ticket(args):
        args = determine_identifier(args)
        args = determine_responder(args)
        args = clean_arguments(args)
        endpoint_url = 'tickets'

        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments, headers=MULTIPART_HEADERS)
        return response


    def create_ticket_command():
        """
        Create a new Freshdesk ticket.

        demisto parameter: (string) subject
            Subject of the ticket. The default Value is null.

        demisto parameter: (string) description
            Details of the issue for which you are creating a ticket.

        demisto parameter: (number) priority
            Priority of the ticket. Each number has a corresponding value.
            1 is Low, 2 is Medium, 3 is High, 4 is Urgent.

        demisto parameter: (number) status
            Status of the ticket. Each number has a corresponding value.
            2 is Open, 3 is Pending, 4 is Resolved, 5 is Closed, 6 is Waiting
            on Customer, 7 is Waiting on Third Party.

        demisto parameter: (string) identifier
            This can be an email address or a twitter handle

        demisto parameter: (list) responder
            ID or name of the group or agent to whom you wish to assign this ticket.
            To find potential assignees, try executing the fd-list-groups command.

        demisto parameter: (list) attachments
            Entry IDs of files to attach to the ticket.
            The total size of these attachments cannot exceed 15MB.

        demisto parameter: (list) additional_fields
            Additional ticket fields you wish to set the value of

        returns:
            Ticket Object
        """
        # Get command arguments from user
        args = demisto.args()

        # Handle additional_fields command arguments
        args, additional_fields, additional_values = additional_fields_to_args(args, 'additional_fields')

        # Make request and get raw response
        ticket = create_ticket(args)
        # Parse response into context
        include_in_context = DEFAULT_TICKET_CONTEXT_FIELDS[:]

        context = {string_to_context_key(key): val for key, val in ticket.iteritems() if val}
        context = additional_fields_to_context(context, include_in_context, additional_fields, additional_values)
        context, context_readable = attachments_into_context(ticket, context)
        context = reformat_ticket_context(context)
        context_readable = reformat_ticket_context(context_readable)
        title = 'Newly Created Ticket #{}'.format(context.get('ID'))
        human_readable = tableToMarkdown(title, context_readable, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': context
            }
        })


    def update_ticket(args):
        # Get ticket number
        ticket_number = args.get('id')
        # Remove ticket number from args
        del args['id']

        args = determine_agent(args, 'assigned_agent')
        args = determine_group(args, 'assigned_group')

        args = clean_arguments(args)

        # The service endpoint to request from
        endpoint_url = 'tickets/{}'.format(ticket_number)

        response = None
        if not args.get('attachments'):
            # Send a request using our http_request wrapper
            response = http_request('PUT', endpoint_url, data=json.dumps(args))
        else:
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('PUT', endpoint_url, data=args, files=attachments, headers=MULTIPART_HEADERS)
        return response


    def update_ticket_command():
        """
        Update the ticket specified by a ticket ID number.

        demisto parameter: (string) subject
            Update the ticket's subject field

        demisto parameter: (number,string) status
            Update the ticket's status. Possible values are 2,3,4,5,6,7 or
            'Open' , 'Pending', 'Resolved', 'Closed', 'Waiting on Customer',
            'Waiting on Third Party'

        demisto parameter: (number,string) priority
            Update the ticket's priority. Possible values are 1,2,3,4 or
            'Low', 'Medium', 'High', 'Urgent'

        demisto parameter: (string) description
            The HTML content of the ticket

        demisto parameter: (number) id
            ID number of the ticket to update

        demisto parameter: assigned_agent
            Update which agent is assigned to respond to this ticket.
            Values can be either the agent's ID number, name, or email.

        demisto parameter: assigned_group
            Update which group is assigned to respond to this ticket.
            Values can be either the group's ID number or name.

        demisto parameter: (list) additional_fields
            Fields not included in the default command arguments that
            you wish to enter the value for

        returns:
            Ticket specified by the ticket ID number with its updated values
        """
        args = demisto.args()
        args, additional_fields, additional_fields_values = additional_fields_to_args(args, 'additional_fields')

        # Make request and get raw response
        ticket = update_ticket(args)

        # Parse response into context
        include_in_context = DEFAULT_TICKET_CONTEXT_FIELDS[:]
        include_in_context.append('updated_at')
        # Parse default context fields
        context = {string_to_context_key(key): val for key, val in ticket.iteritems() if val}
        # Parse additional fields into context
        context = additional_fields_to_context(context, include_in_context, additional_fields, additional_fields_values)
        # Parse attachments into context
        context, context_readable = attachments_into_context(ticket, context)
        context = reformat_ticket_context(context)
        context_readable = reformat_ticket_context(context_readable)
        title = 'Ticket #{} Updated'.format(context.get('ID'))
        human_readable = tableToMarkdown(title, context_readable, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': context
            }
        })


    def get_ticket(args):
        ticket_number = args.get('id')
        endpoint_url = 'tickets/{}'.format(ticket_number)
        url_params = {}

        # Check if embedding additional info in API response was specified in cmd args
        include = ''
        if args.get('include_stats') and args.get('include_stats').lower() == 'true':
            include += 'stats'
        if args.get('include_requester') and args.get('include_requester').lower() == 'true':
            include += 'requester' if include == '' else ', requester'
        if include != '':
            url_params['include'] = include

        response = http_request('GET', endpoint_url, params=url_params)
        return response


    def get_ticket_command():
        """
        View a Ticket.

        demisto parameter: (number) id
            ID number of the ticket to fetch

        demisto parameter: (string) include_requester
            If set to 'yes' then the ticket requester's id, email, mobile, name, and phone
            will be included in the ticket's output.

        demisto parameter: (string) include_stats
            If set to 'yes' then the ticket's closed_at, resolved_at and first_responded_at times will be included.

        returns:
            Ticket Object
        """
        # Get command arguments from user
        args = demisto.args()
        # Make request and get raw response
        ticket = get_ticket(args)

        nonstd_context_fields = ['requester', 'stats']

        # Parse response into context
        context = {
            string_to_context_key(key): val
            for key, val in ticket.iteritems()
            if key not in nonstd_context_fields and val is not None
        }

        # Parse attachments into context
        context, context_readable = attachments_into_context(ticket, context)

        context['AdditionalFields'] = {}
        requester = ticket.get('requester')
        if requester:
            requester_context = {string_to_context_key(key): val for key, val in requester.iteritems() if val}
            context['AdditionalFields']['Requestor'] = requester_context
        stats = ticket.get('stats')
        if stats:
            stats_context = {string_to_context_key(key): val for key, val in stats.iteritems() if val}
            context['AdditionalFields']['Stats'] = stats_context

        if not ticket.get('deleted'):
            context['AdditionalFields']['Deleted'] = False

        context = reformat_ticket_context(context)
        context_readable = reformat_ticket_context(context_readable)
        title = 'Viewing Ticket #{}'.format(ticket.get('id'))
        human_readable = tableToMarkdown(title, context_readable, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': context
            }
        })


    def delete_ticket(ticket_id):
        endpoint_url = 'tickets/{}'.format(ticket_id)
        response = http_request('DELETE', endpoint_url)
        return response


    def delete_ticket_command():
        """
        Soft-Delete the ticket specified by the 'id' command argument.

        demisto parameter: (number) id
            ID of the ticket to delete

        returns:
            Success Message
        """
        ticket_id = demisto.args().get('id')
        # Make request
        delete_ticket(ticket_id)
        ticket_context = {
            'ID': int(ticket_id),
            'AdditionalFields': {'Deleted': True}
        }
        message = 'Soft-Deleted Ticket #{}'.format(ticket_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket_context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': message,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': ticket_context
            }
        })


    def search_tickets(args):
        endpoint_url = 'tickets'
        url_params = {}

        # Filter By
        filter = args.get('filter')
        if filter:
            url_params['filter'] = filter
        requester = args.get('requester')
        if requester:
            if '@' in requester:
                url_params['email'] = requester
            else:
                url_params['requester_id'] = requester
        updated_since = args.get('updated_since')
        if updated_since:
            url_params['updated_since'] = updated_since

        # Sort By
        order_by = args.get('order_by')
        if order_by:
            url_params['order_by'] = order_by
        order_type = args.get('order_type')
        if order_type:
            url_params['order_type'] = order_type

        # Embeddings (include additional information)
        include = ''
        if args.get('include_stats') and args.get('include_stats').lower() == 'true':
            include += 'stats'
        if args.get('include_requester') and args.get('include_requester').lower() == 'true':
            include += 'requester' if include == '' else ', requester'
        if args.get('include_description') and args.get('include_description').lower() == 'true':
            include += 'description' if include == '' else ', description'
        if include != '':
            url_params['include'] = include

        # Custom Query
        custom_query = args.get('custom_query')
        if custom_query and url_params:
            err_msg = 'You cannot use the custom_query argument in conjunction with the other command arguments. You can ' \
                      'either use the other arguments that allow you to choose options for filtering, sorting, ' \
                      'and including information for tickets, or to use the custom_query alone to create a custom filter ' \
                      'that determines which tickets are listed.'
            return_error(err_msg)
        elif custom_query:
            endpoint_url = 'search/tickets'
            url_params['query'] = '"' + custom_query + '"'

        page = args.get('page')
        if page:
            url_params['page'] = page

        # Make request and get raw response
        response = http_request('GET', endpoint_url, params=url_params)
        return response


    def search_tickets_command():
        """
        List all tickets that match the filter criteria you specify.

        demisto parameter: (string) filter
            Predefined filters

        demisto parameter: requester
            Filter by either the ticket requester's email or ID

        demisto parameter: (datetime) updated_since
            By default, only tickets that have been created within the past 30 days will be returned.
            For older tickets, use this filter. Example value for this field would be '2015-01-19T02:00:00Z'

        demisto parameter: (string) order_by
            Reference field for ordering the list of tickets. The default sort order is created_at.

        demisto parameter: (string) order_type
            Whether to order the resulting tickets in ascending or descending order.
            The default is descending. Value can be either 'asc' or 'desc'.

        demisto parameter: (string) include_stats
            If set to 'yes' then the ticket's closed_at, resolved_at and first_responded_at times will be included.

        demisto parameter: (string) include_requester
            If set to 'yes' then the ticket requester's id, email, mobile, name, and phone
            will be included in the ticket's output for each ticket.

        demisto parameter: (string) include_description
            If set to 'yes' then the ticket's description and description_text will be included the tickets' outputs.

        demisto parameter: (string) custom_query
            Filter tickets using a custom query.
            Format  -  "(ticket_field:integer OR ticket_field:'string') AND ticket_field:boolean"
            Example -  "(type:'Question' OR type:'Problem') AND (due_by:>'2017-10-01' AND due_by:<'2017-10-07')"
            Note that the custom_query argument cannot be used in conjunction with this command's other arguments.

        returns:
            Ticket Objects
        """
        args = demisto.args()
        additional_fields = get_additional_fields(args)
        response = search_tickets(args)   # page 1

        tickets = handle_search_tickets_pagination(args, response)

        context_outputs = DEFAULT_TICKET_CONTEXT_FIELDS[:]
        context_outputs.append('updated_at')

        # Parse response into context
        contexts = []
        readable_contexts = []
        for ticket in tickets:
            # Parse ticket into the standard outputs
            context = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in context_outputs}

            # Parse ticket attachments into context
            context, context_readable = attachments_into_context(ticket, context)

            # Parse ticket for the additionally requested fields
            context['AdditionalFields'] = {
                string_to_context_key(key): val for key, val in ticket.iteritems() if key in additional_fields
            }
            requester = ticket.get('requester')
            if requester:
                requester_context = {string_to_context_key(key): val for key, val in requester.iteritems() if val}
                context['AdditionalFields']['Requestor'] = requester_context
            stats = ticket.get('stats')
            if stats:
                stats_context = {string_to_context_key(key): val for key, val in stats.iteritems() if val}
                context['AdditionalFields']['Stats'] = stats_context

            context_readable = reformat_ticket_context(context_readable)
            readable_contexts.append(context_readable)
            context = reformat_ticket_context(context)
            contexts.append(context)

        table_headers = [
            'ID', 'Priority', 'Status', 'Subject', 'DueBy', 'FrDueBy', 'RequesterID', 'GroupID',
            'Source', 'CreatedAt', 'UpdatedAt', 'Tag', 'AdditionalFields', 'Attachment'
        ]
        title = 'Viewing All Requested Tickets'
        human_readable = tableToMarkdown(title, readable_contexts, headers=table_headers, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': tickets,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': contexts
            }
        })


    '''<------ CONVERSATIONS ------>'''


    def ticket_reply(args):
        ticket_id = args.get('ticket_id')
        del args['ticket_id']
        args = handle_array_input(args)
        endpoint_url = 'tickets/{}/reply'.format(ticket_id)

        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments, headers=MULTIPART_HEADERS)
        return response


    def ticket_reply_command():
        """
        Reply to a specified ticket.

        demisto parameter: (number) ticket_id
            ID of the ticket you wish to respond to

        demisto parameter: (string) body
            Content of the reply in HTML format

        demisto parameter: (string) from_email
            The email address from which the reply is sent. By default the global support email will be used.

        demisto parameter: (number) user_id
            ID of the agent who is adding the note

        demisto parameter: (list) cc_emails
            Array of email address strings added in the 'cc' field of the outgoing ticket email.

        demisto parameter: (list) bcc_emails
            Array of email address strings added in the 'bcc' field of the outgoing ticket email.

        demisto parameter: (list) attachments
            Entry IDs of files to attach to the reply. The total size of these attachments cannot exceed 15MB.

        returns:
            Ticket Reply Object
        """
        args = demisto.args()
        # Make request and get raw response
        reply = ticket_reply(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in reply.iteritems() if val}
        context = reformat_conversation_context(context)
        # Parse attachments into context
        context, context_readable = attachments_into_context(reply, context)
        context = reformat_ticket_context(context)
        context_readable = reformat_ticket_context(context_readable)
        complete_context = {
            'ID': int(reply.get('ticket_id')),
            'Conversation': context
        }
        title = 'Reply to Ticket #{}'.format(reply.get('ticket_id'))
        human_readable = tableToMarkdown(title, context_readable, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': reply,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': complete_context
            }
        })


    def create_ticket_note(args):
        ticket_id = args.get('ticket_id')
        del args['ticket_id']
        args = handle_array_input(args)
        # Set defaults for 'private' and 'incoming' fields if not set by user
        args['private'] = args.get('private', 'true')
        args['incoming'] = args.get('incoming', 'false')
        endpoint_url = 'tickets/{}/notes'.format(ticket_id)

        response = None
        if not args.get('attachments'):
            # Format boolean args to API expectations
            dumped_args = json.dumps(args).replace('"false"', 'false').replace('"true\"', 'true')
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=dumped_args)
        else:
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments, headers=MULTIPART_HEADERS)
        return response


    def create_ticket_note_command():
        """
        Create a note for a specified ticket.

        Notes by default are private (AKA not visible to non-agents) unless you
        set the 'private' command argument to False.

        demisto parameter: (number) ticket_id
            ID of the ticket you wish to make a note for

        demisto parameter: (string) body
            Content of the note in HTML format

        demisto parameter: (boolean) private
            Set to false if the note is not private

        demisto parameter: (number) user_id
            ID of the agent who is adding the note

        demisto parameter: (list) notify_emails
            Array of email addresses of agents/users who need to be notified about this note

        demisto parameter: (boolean) incoming
            Set to true if a particular note should appear as being created from outside (i.e., not through web portal).

        demisto parameter: (list) attachments
            Entry IDs of files to attach to the note. The total size of these attachments cannot exceed 15MB.

        returns:
            Note Object
        """
        # Get command arguments
        args = demisto.args()
        # Make request and get raw response
        note = create_ticket_note(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in note.iteritems() if val}
        context = reformat_conversation_context(context)
        # Parse attachments into context
        context, context_readable = attachments_into_context(note, context)
        context = reformat_ticket_context(context)
        context_readable = reformat_ticket_context(context_readable)
        complete_context = {
            'ID': int(note.get('ticket_id')),
            'Conversation': context
        }
        title = 'Note for Ticket #{}'.format(note.get('ticket_id'))
        human_readable = tableToMarkdown(title, context_readable, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': note,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': complete_context
            }
        })


    def get_ticket_conversations(ticket_id):
        endpoint_url = 'tickets/{}/conversations'.format(ticket_id)
        response = http_request('GET', endpoint_url)
        return response


    def get_ticket_conversations_command():
        """
        Lists all replies and notes for a specified ticket.

        demisto parameter: (number) ticket_id
            ID of the ticket for which you would like to list all of its conversations

        returns:
            Conversation Objects
        """
        # Get id number of ticket as cmd arg for which you want to see all the conversations
        ticket_id = demisto.args().get('ticket_id')
        # Make request and get raw response
        conversations = get_ticket_conversations(ticket_id)
        # Parse response into context
        contexts = []
        readable_contexts = []
        for conversation in conversations:
            context = {string_to_context_key(key): val for key, val in conversation.iteritems() if val}
            context = reformat_conversation_context(context)
            # Parse attachments into context
            context, context_readable = attachments_into_context(conversation, context)
            context = reformat_ticket_context(context)
            context_readable = reformat_ticket_context(context_readable)
            contexts.append(context)
            readable_contexts.append(context_readable)
        complete_context = {
            'ID': int(ticket_id),
            'Conversation': contexts
        }
        title = 'Conversations of Ticket #{}'.format(ticket_id)
        human_readable = tableToMarkdown(title, readable_contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': conversations,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Ticket(val.ID && val.ID === obj.ID)': complete_context
            }
        })


    '''<------ CONTACTS ------>'''


    def list_contacts(filters):
        # Alter to match API expected inputs
        updated_since = filters.get('updated_since', None)
        if updated_since:
            del filters['updated_since']
            filters['_updated_since'] = updated_since

        endpoint_url = 'contacts'
        response = http_request('GET', endpoint_url, params=filters)
        return response


    def list_contacts_command():
        """
        List all contacts.

        Lists all contacts matching the specified filters. If no filters are provided
        then all unblocked and undeleted contacts will be returned.

        demisto parameter: (number) mobile
            mobile number to filter the contacts by

        demisto parameter: (number) phone
            phone number to filter contacts by

        demisto parameter: (string) state
            The state of contacts by which you want to filter the contacts. Values
            are 'verified', 'unverified', 'blocked', or 'deleted'.

        demisto parameter: (datetime) updated_since
            return contacts that have been updated after the timestamp given as this argument value

        returns:
            Contact Objects
        """
        # Get command arguments from user
        filters = demisto.args()
        # Make request and get raw response
        contacts = list_contacts(filters)
        # Parse response into context
        contexts = []
        for contact in contacts:
            # Parse individual contact response in context
            context = format_contact_context(contact)
            contexts.append(context)
        filters_as_strings = ', '.join(['{}: {}'.format(key, val) for key, val in filters.iteritems()])
        title = 'Contacts Filtered by {}'.format(filters_as_strings) if filters else 'All Contacts'
        human_readable = tableToMarkdown(title, contexts, removeNull=False)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contacts,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Contact(val.ID && val.ID === obj.ID)': contexts
            }
        })


    def get_contact(args):
        contact_id = 0
        if not args:
            err_msg = 'You must provide a value for either the mobile, email or id command argument fields.'
            return_error(err_msg)
        elif args.get('id') is not None:
            contact_id = args.get('id')
        elif args.get('email') is not None:
            try:
                filters = {'email': args.get('email')}
                # Get id field of first result of contacts with that email (There should only be one)
                contact_id = list_contacts(filters)[0].get('id')
            # If there is an IndexError, it means no results were returned for the given filter
            except IndexError as e:
                err_msg = 'Couldn\'t find a contact with that email address.'\
                          ' Double check that you wrote the email address correctly'\
                          ' and/or that you have a FreshDesk contact with that exact'\
                          ' email address.'
                return_error(err_msg)
            except Exception as e:
                return_error(e.message)
        else:
            try:
                filters = {'mobile': args.get('mobile')}
                # Get id field of first result of contacts with that mobile number
                contact_id = list_contacts(filters)[0].get('id')
            # If there is an IndexError, it means no results were returned for the given filter
            except IndexError as e:
                err_msg = 'Couldn\'t find a contact with that mobile number.'\
                          ' Double check that you wrote it correctly and/or that '\
                          'you have a FreshDesk contact with that exact mobile number.'
                return_error(err_msg)
            except Exception as e:
                return_error(e.message)

        endpoint_url = 'contacts/{}'.format(contact_id)
        response = http_request('GET', endpoint_url)
        return response


    def get_contact_command():
        """
        View the details of the contact specified by the ID number.

        demisto parameter: (number) id
            ID of the contact you wish to view the details of

        demisto parameter: (number) mobile
            Mobile number of the contact you wish to view the details of

        demisto parameter: (string) email
            Email address of the contact you wish to view the details of

        returns:
            Contact Object
        """
        # Get command arguments from user
        args = demisto.args()
        # Make request and get raw response
        contact = get_contact(args)

        context = format_contact_context(contact)
        title = 'Viewing Contact #{}'.format(contact.get('id'))
        human_readable = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contact,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Contact(val.ID && val.ID === obj.ID)': context
            }
        })


    '''<------ CANNED RESPONSES ------>'''


    def list_canned_response_folders():
        endpoint_url = 'canned_response_folders'
        response = http_request('GET', endpoint_url)
        return response


    def list_canned_response_folders_command():
        """
        List all Canned Response Folders (Only users with Admin Privileges).

        returns:
            Folder Objects
        """
        # Make request and get raw response
        cr_folders = list_canned_response_folders()
        # Parse response into context
        contexts = []
        for folder in cr_folders:
            # Parse individual contact response in context
            context = {string_to_context_key(key): val for key, val in folder.iteritems() if val}
            context = reformat_canned_response_context(context)
            contexts.append(context)
        title = 'All Canned Response Folders'
        human_readable = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': cr_folders,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.CRFolder(val.ID && val.ID === obj.ID)': contexts
            }
        })


    def get_canned_response_folder(id):
        endpoint_url = 'canned_response_folders/{}/responses'.format(id)
        response = http_request('GET', endpoint_url)
        return response


    def get_canned_response_folder_command():
        """
        View the details of all the Canned Responses in a Folder.

        demisto parameter: (number) id
            ID of the Folder containing the Canned Responses you wish to view the details of

        returns:
            Canned Response Objects with more details, aka all of a Canned Response Object's attributes
        """
        # Get id of the containing canned response folder as cmd argument
        cr_folder_id = demisto.args().get('id')
        # Make request and get raw response
        canned_responses = get_canned_response_folder(cr_folder_id)
        # Parse the responses into context
        contexts = []
        readable_contexts = []
        for cr in canned_responses:
            context = {string_to_context_key(key): val for key, val in cr.iteritems() if val}
            context = reformat_canned_response_context(context)
            context, context_readable = attachments_into_context(cr, context)
            contexts.append(context)
            readable_contexts.append(context_readable)
        title = 'Details of Canned Responses in CR Folder #{}'.format(cr_folder_id)
        human_readable = tableToMarkdown(title, readable_contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': canned_responses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.CRFolder(val.ID && val.ID === obj.ID).CR(val.ID && val.ID === obj.ID)': contexts
            }
        })


    '''<------ GROUPS ------>'''


    def list_groups():
        endpoint_url = 'groups'
        response = http_request('GET', endpoint_url)
        return response


    def list_groups_command():
        """
        List all groups.

        returns:
            Group Objects
        """
        # Make request and get raw response
        groups = list_groups()
        # Parse response into context
        contexts = []
        for group in groups:
            # Parse individual group response in context
            context = {}
            for key, val in group.iteritems():
                if val:
                    if key == 'agent_ids':
                        key = 'agent_id'
                    new_key = string_to_context_key(key)
                    if 'Id' in new_key:
                        new_key = new_key.replace('Id', 'ID')
                    context[new_key] = val
            contexts.append(context)
        title = 'All Groups'
        human_readable = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': groups,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Group(val.ID && val.ID === obj.ID)': contexts
            }
        })


    '''<------ AGENTS ------>'''


    def list_agents(filters={}):
        endpoint_url = 'agents'
        response = http_request('GET', endpoint_url, params=filters)
        return response


    def list_agents_command():
        """
        List agents that match the criteria of the filters entered as command arguments.

        demisto parameter: (number) mobile
            Mobile phone number to filter agents by

        demisto parameter: (number) phone
            Telephone number to filter agents by

        demisto parameter: (string) state
            Filter agents by whether they are 'fulltime' or 'occasional'

        returns:
            Agent Objects
        """
        # Get filter as cmd arg
        args = demisto.args()
        # Make request and get raw response
        agents = list_agents(args)
        # Parse response into context
        contexts = []
        for agent in agents:
            # Parse the individual agent into context
            context = {}
            for key, val in agent.iteritems():
                if val:
                    if key == 'group_ids':
                        key = 'group_id'
                    elif key == 'role_ids':
                        key = 'role_id'
                    new_key = string_to_context_key(key)
                    if 'Id' in new_key:
                        new_key = new_key.replace('Id', 'ID')
                    context[new_key] = val
            context['Contact'] = {string_to_context_key(key): val for key, val in agent.get('contact').iteritems() if val}
            contexts.append(context)
        title = 'All Agents'
        human_readable = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': agents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {
                'Freshdesk.Agent(val.ID && val.ID === obj.ID)': contexts
            }
        })


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    # Commands Switch Panel
    commands = {
        'fd-create-ticket': create_ticket_command,
        'fd-update-ticket': update_ticket_command,
        'fd-get-ticket': get_ticket_command,
        'fd-get-contact': get_contact_command,
        'fd-list-contacts': list_contacts_command,
        'fd-list-canned-response-folders': list_canned_response_folders_command,
        'fd-get-canned-response-folder': get_canned_response_folder_command,
        'fd-list-groups': list_groups_command,
        'fd-ticket-reply': ticket_reply_command,
        'fd-create-ticket-note': create_ticket_note_command,
        'fd-get-ticket-conversations': get_ticket_conversations_command,
        'fd-list-agents': list_agents_command,
        'fd-delete-ticket': delete_ticket_command,
        'fd-search-tickets': search_tickets_command,
    }

    LOG('Command being called is %s' % (demisto.command()))

    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() in commands.keys():
            # Execute that command
            commands[demisto.command()]()

    # Log exceptions
    except Exception as e:
        LOG(e)
        return_error(e.message)
  subtype: python2
  type: python
system: true
