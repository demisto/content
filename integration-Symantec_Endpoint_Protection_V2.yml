category: Endpoint
commonfields:
  id: Symantec Endpoint Protection V2
  version: -1
configuration:
- defaultvalue: ""
  display: Server (e.g., https://1.2.3.4:8446)
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: Authentication
  name: authentication
  required: true
  type: 9
- defaultvalue: ""
  display: SEPM domain for the user
  name: domain
  required: false
  type: 0
- defaultvalue: "false"
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- defaultvalue: "false"
  display: Use proxy system settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Local time zone (e.g., +02:30,-06:00)
  name: timeZone
  required: false
  type: 0
description: Query the Symantec Endpoint Protection Manager using the official REST
  API.
detaileddescription: |
  Integration with Symantec Endpoint Protection Manager using the SEPM REST API.
display: Symantec Endpoint Protection V2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADhVJREFUeAHtmguUVdV5gP97586T4eEjBhAfIFUD0WAtGoMgoGLSltAYrGmiWTU1PmJrWtOllayumrbG4gNjErKqqSa1JjWgwSjYmFBRYCAIKdFWGiEmiC+CCvKY98y9/b7DPdPLMIMaxKym51987H322Xufvf/X2ffeicgk00CmgUwDmQYyDWQayDSQaSDTQKaBTAOZBjINZBrINJBp4M1roLQmrmxZEd968yOynm+XBvJv10T7mOf0yZfmTyjk4yv76JPdOkAaOGAGbmiI4Y31ue+x7o///oTiC51dMe4A7SGbdn80UCpFfsPDUUuabdiyJBpLy2Og5Utcl56OGu/3mr+W69oRQwv3fenqml8c2hiTS/8dRzeviJN69csu3wEN5Pp7xpIlUZjcEbWtg2JcdVVM6i7GSaViHF6MqMeirflcvABroxhLX9sZT757WrTlctHNfFfBxoa63OUzz84t/tai4lGM/Ux/z8naD6wG+jRwaUnUdTfEmVjrSox6Rm0NEcw6iliXiA0MGXms7OD2Dgybj8dr8nHbpTfGijvmx3iaL4T/hNFwK6wHp8jkHdbAHun1uusi37omjmyrj7ndpXiAg9G0Yokobo9og/bOiK7uKFl6bTtWq6suxDmbt8WCn2+Khax/HrwC0+EmeAYy46KEX4fsEcFtK4i4fNxRUx1TNKBCtJZqCtGCwVu6OqOZIG7DK+roM4B7DZ3dUb+jOfJfvDOioyvijvuTMd04wmKi/Tym2JlMlP33a9FAIX3qzqXxLsJsbi3GbW3bnYYxbFtXMTa1d8VD+VIs5iT8bGd1tDTmo4HUPLqqOs4iwmcsWR2j7l4YuZHDd6fx007MdY47tvSFufPf0Lg6WAPUQxUY6b7Hda/Wcp0ik/3SAO/cwq7lcVPpx1FqbooSX0qUutfErtamuKdteRy3j8mrrjgvLjx0SK6lvi5KU0+J0qgRUXrs62Ty1fEPzruvsdwbCR7K7oPH4FG4F66Bk2GPVwjX/1elmoUPgUGwR9Z8Rza0symmdqyK5taVUWrFuF2rYkf7j+Kv/Rj0BguYxP1lUGqsj+LnLoy2793K+NVRalsVuzqbwvv9ifeeAqO2GbaA727rtj0ORvdvgkxgE/fAXHhH95Q3ynCpSwqFaPCUXKiOUkd3PLRlU9ycGxujWNCJoOf1Fj3yb+B0b+xqjRdJ18unT+QQ1hFBeh9Anr2E97Cpt7fo0dfCCbANjOCvwj/CfFgLfknSAr8Jcgab+AR4JulLHwdsj4Wt+RjGC/DMDoxSRUIsdsfWYj5mH/GHyTvwz3jyKfANWAAvQyozqLhwZRf80/WXxSOdnfEwn48Pcj7Ks8kKQ7n3op0q5FDqp5avl1BeBr5zFbPGe8AxpnjHm9Y4GSQRTpFI5T0PcjwxDoGtYBYYDO8C5/O+8+HCSaq0XSfbAS+B7ak0UjkYjDRfEZ4HXoXtkIpnBvdgm3M45jCoA/urJ53T9oNgDCgcQ5M1uTazlX0Vn+V4S88gzrsFKtfFZSI+1zldv/O9Dq6vr75RaKyK8blCHMoBKmr5Dqq9LZYOmJB8hmVM/AjOhTkwEm6BzaCCPgupN5qmv1Y/IV5tWRnLOahNN4rJCod17f6KUuVWiotL389uRiOkBtZQT4Ji5vA5A0Cl3QBuShkBnwPXsBC2wSfhYXD8h2EKmGnWg9lBQ9s+CVTyM3AH/AR0omNhIrwfjgTXqaJXAJ8P4gVQjodLYGmZaZRnwTBQ2d8F+4+H8+B0UAbCLHCPX4V18G5Ixx9BXaM/BQvgx8CH0kTc51hw/c7r+nUu+z4Eq2FvI3OoeoT3b3K4Kq7hHdwUn6ZjKm76fFC5Dp4PGvrvoFTmFcqpkEjbyrjceTysJYe2ZfH59F5Fqaf/AJxDw3wdLoCTYRCkooLdqP2MCDeYyp9SsV1laZSLy9du+N9Bz/4ZqDD7/QcsB9ufBcfZvgqMCBXoOrpAo2p0HcXM0Q0PwhBQNJpjN8AiUNE+y7lt3w5ng/2egGaw3bVoNNtOA6PxXvAZjl0Ma8G+vwB1n8p0Kk+D97aW6zqc1667AHtJgbQ8kShLhK8U/bZKY6bi4AfgfXA1zIDXoMeg1O+DlZAIn5df5l3cI2QHlddb3NBcGAGm44tgCujRGiiNDPvdD3qtafF0cJPKhN1FbKJUKc6jvBeegVtgI3wKJsNJ8F9wIzwPl4NKtn0U6ABLoAFWgX10cB3nQ3AOjAGjOY2UY6jrhF8D1+Vcfw6DwKi8Db4At8JvgY7wt9AJ60GjfQScQyN9Bw6Bm2E0XAlmJ9fhvD5/G8wB9zgEPgA6iU64txBxv/TkbMR1PUG5Iv5g715JulpDu6YzlTqZ9U1wAvRIS1PM9BSdRjDXs3tu7lmp5VIPnQc/gzSimqmrxMvBSD8CUk9VAW52IKgg1/ANUOzvtajEAaCo4LR9FnUNqNwIafuHkpbd82oIo8HoUqFfhrTfJ6grH4W0TeMeZCPyPmgH7/0rKK431Z1Okz6/ivoisO92OBF8rtwJtuvgZq3fBvVu24Pg/hXnPhoc06cUiNpFNTVxUXIo4pG5ztAre4uGvB3mgkpPZT4VPbdHiN7RHtYUV8MxZbNFH6Ii5oFR5QZMz+Pgd+A0GA4b4FFYBh+DU8DNjQQNbyR9H3qLa2ouN7ZU3FxHPb1O73tbZSsq1AiaCip2KGjkVHTK3vJTGowqZSfo/Eo6p0aQVIxWRT0en9R2q2o6daNetbl3xecdDTpQqvfl1H2OYt+NVvqTPCfmuzk5d+dYQjdL49+5GzYkE/ce820aVlY0Pkfd1JOmq3h+Hmk0Fx/ha8pwPk7U3bnu5OVfMWyPqgvUGP8CRtcfg2lJ5R8FV4Dz3wUq7kg4Fc4AN6zjLYbekirXdlbSI/2128Eo+Hu4B0yR54HR9ktIxfX2lrI7J82Vz+qrb+VY199YbvA5l4J7/ywYzZvL2M9sksqraeXNlIXG7fFUy8B4jh8MRiUn6eoYN3xz4kkP9ZpApX8TJpXbF1C+VK4nxeBh8UFO0Cc4TwFV8m5/lh8mjNC+RGVUKsHI2ghmBY19DIwA+z0BRvPxYDq1XdGbtya1/fvPbGL2+BMwgn8IGnkjnANG9NstZos0m5gBLgPbFJ26E3TIZ8DoTuWwtPJmyjzL38aXEffzkSb5KZCpG6jP4jR9VB8TmP8/D3PgdnAhibQ+HiNxkms5pNX7k2IyHwewIZOT90vaLS3rqdwAM8GDQqWYGg8uN7xOqRPsgB+U2z5MOaFc/zfKSicpN7/lwuxgKta4ik72KKwHjb8/Urk+nbWjPJnv1NT5B5XbH6OUpaCBn4Ut8FT5miLOhAFWynIyZbrutK2nLJBKS+1r4i7ewR/HQIebXjHOyRjp5tZVcXX9qclxPR3wGhUNWws9qev1pjgmXxWz+WJjHL8uBfP4y9ImTtR3O386uKK8gPqn4aPwSUjfYxp2MgwGZeHuIpnjQeqfgaPLbaYqI/jtEBWvM6VyFpUX4UgwqvdH3H86t/v7FOyEFfBNMCOZhq+H+2AXHAdTYBlcBb7GNLrGPQ1ug5/AcPggLIFZ0AhTwaymY47HFHzLsDDWN0+LWbW5uAuDVJFaq/mqcQYGOnbXypgzIBcLcu9PosjuGjmRrWticH1XnMsvTVdh3OMxrg7j+7erqyOuHTghiYC0e2WpczwHJ8FIUKFmgyrQeYwoHekuSEWF6PHjyg0a94Vy3SLZS/m6sl5d0cf5U6lsb6DxMWgCs8MMUJn20ZF8jq+FdN7+5mH3PYehGuqpzKOi4s1cXwT3ej18uVxeQzkexoD3HKvRnwf1oUP8BfwzqLMLwTOC63NOs4FRbco/HIaCjnNKsuDcdVEsTYv5rZ0xhhP1Nb5DicBqDPXe+kLMaeuKi/m400TzT/niejsn5cEMfE+xPSbS/zi+ux7CAS2vcfnzHv/K48Zt+VjQ2Hf08twk3T5JOQk+AMeAacoFboBHQK90Y6m4iQcgNfD3qauMVPRyFaA4RyprqaTtP08bKVdXtKvIHXARXAyngvIE3A1j4XfBTKM4Tzqn+0jFOe4EFe/8qdxDxbbfgyGwBZzLdH0LuEadajTkYBM8CmYwI1pZB+fDx0CdOY/B1gTfgdfBscvAeV+Ch23oka0/jMENjXEt0fiXdK0yXStcd2HItlwpOkjdRQyZL+WihrReh7GxNa6NYZFOPnbd1JKL2Yf8b8QnN/r5Ty/VA918HjRYJ2hoU0yl+JzZYMpSkXpypcH09AGgqBQ3qfiMhqS2Z7vPFUVH8rmuYSA4RmkD7xlRztEMrstr06HiWu2nOH4wqFefnxqHarI251BTxEpyLx2Xrl09KN53Xp26UpzX57o+59FC9nFd6avQOayrr6o9DExDaOTa+pjJe/iveJeO1sh+w+XBqbcYsX7mTU7M3bG+uytuqKuK71ak895DfpXrmQw6E4bBVNAAt8MVUHZBapn0qYG9DGwvf0LEt4d2FOOCUj7O5w/vxvKHd9V+Beln5Sp8h6j2b7Q6+IO7p3PFuHdXW3z7YD675ab0/BjQ5wN/hcb7GTMdjA699kG4GF6BTN5AA30auDwmxw/+1bwtGlrrYiwdxxDFE2EcCWgtBl5GfV17e6wbcli05Mb2pMQ3eORbvu276Y9gOywC302VqY/LTPrTwL4MnIzBiDl+/yi8zHtyWFXU7GqJmsaG6Hi5OzrImZ18wdhFqu4jgff3yLfcnr6nfT/7zvLddiCf95YXmA3INJBpINNApoFMA5kGMg1kGsg0kGkg00CmgUwDmQYyDWQayDSQaSDTQKaBTAP/nzXwP8GiXu6mDzpYAAAAAElFTkSuQmCC
name: Symantec Endpoint Protection V2
script:
  commands:
  - arguments:
    - description: A CSV list of the displayed columns.
      name: columns
    - description: Filters by the host name of the computer. A wild card search can
        be done using '*' at the end of the query.
      name: computerName
    - defaultValue: "0"
      description: Indicates when a computer's status was last updated. The default
        is "0", which returns all results.
      name: lastUpdate
    - auto: PREDEFINED
      description: The operating system by which to filter.
      name: os
      predefined:
      - CentOs
      - Debian
      - Fedora
      - MacOSX
      - Oracle
      - OSX
      - RedHat
      - SUSE
      - Ubuntu
      - Win10
      - Win2K
      - Win7
      - Win8
      - WinEmb7
      - WinEmb8
      - WinEmb81
      - WinFundamental
      - WinNT
      - Win2K3
      - Win2K8
      - Win2K8R2
      - WinVista
      - WinXP
      - WinXPEmb
      - WinXPProf64
    - description: The number of results to include on each page. The default is 20.
      name: pageSize
    - description: The name of the group to which the endpoint belongs. A wild card
        search can be done using '*' at the end of the query.
      name: groupName
    description: Returns information about endpoints.
    name: sep-endpoints-info
    outputs:
    - contextPath: SEPM.Endpoint.Hostname
      description: The hostname of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.Domain
      description: The domain of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.IPAddresses
      description: The IP addresses of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.OS
      description: The OS information of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.Description
      description: The description of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.MACAddresses
      description: The MAC address of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.BIOSVersion
      description: The BIOS version of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.DHCPServer
      description: The DHCP server address of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.HardwareKey
      description: The hardware key of the client to be moved.
      type: String
    - contextPath: SEPM.Endpoint.LastScanTime
      description: The last scan time of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.RunningVersion
      description: The running version of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.TargetVersion
      description: The target version of the endpoint.
      type: String
    - contextPath: IP.Address
      description: The IP address of the endpoint.
      type: String
    - contextPath: IP.Host
      description: The IP host of the endpoint.
      type: String
    - contextPath: Endpoint.Hostname
      description: The hostname of the endpoint.
      type: Unknown
    - contextPath: Endpoint.MACAddress
      description: The MAC address of the endpoint.
      type: Unknown
    - contextPath: Endpoint.Domain
      description: The domain of the endpoint.
      type: Unknown
    - contextPath: Endpoint.IPAddress
      description: The IP address of the endpoint.
      type: Unknown
    - contextPath: Endpoint.DHCPServer
      description: The DHCP server of the endpoint.
      type: Unknown
    - contextPath: Endpoint.OS
      description: The OS of the endpoint.
      type: String
    - contextPath: Endpoint.OSVersion
      description: The OS version of the endpoint.
      type: String
    - contextPath: Endpoint.BIOSVersion
      description: The BIOS version of the endpoint.
      type: String
    - contextPath: Endpoint.Memory
      description: The memory of the endpoint.
      type: String
    - contextPath: Endpoint.Processors
      description: The processors that the endpoint uses.
      type: String
    - contextPath: IP.Hostname
      description: The hostname that is mapped to this IP address.
      type: String
    - contextPath: SEPM.Endpoint.Group
      description: The group of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.PatternIdx
      description: The PatternIdx of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.OnlineStatus
      description: The online status of the endpoint.
      type: String
    - contextPath: SEPM.Endpoint.UpdateTime
      description: The update time of the endpoint.
      type: String
  - arguments:
    - description: The column by which the results are sorted.
      name: columns
    description: Returns information about groups.
    name: sep-groups-info
    outputs:
    - contextPath: SEPM.Groups
      description: The list of groups.
      type: Unknown
    - contextPath: SEPM.Groups.created
      description: The time of creation time (in Epoch).
      type: number
    - contextPath: SEPM.Groups.fullPathName
      description: The name of the group.
      type: string
    - contextPath: SEPM.Groups.id
      description: The ID of the group.
      type: string
    - contextPath: SEPM.Groups.numberOfPhysicalComputers
      description: The number of physical computers in the group.
      type: number
    - contextPath: SEPM.Groups.numberOfRegisteredUsers
      description: The number of registered users in the group.
      type: number
    - contextPath: SEPM.Groups.policyDate
      description: The date of the policy (in Epoch).
      type: number
    - contextPath: SEPM.Groups.policySerialNumber
      description: The serial number of the policy.
      type: number
  - arguments: []
    description: Returns information about the system, such as version or AV definition.
    name: sep-system-info
    outputs:
    - contextPath: SEPM.ServerAVDefVersion
      description: The version of the AV definition.
      type: string
  - arguments:
    - description: The ID of the command.
      name: commandId
      required: true
    description: Retrieves the status of a command.
    name: sep-command-status
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: The details of the command.
      type: string
    - contextPath: SEPM.LastCommand.CommandId
      description: The ID of the command.
      type: string
  - arguments: []
    description: Retrieves the content of the client.
    name: sep-client-content
    outputs:
    - contextPath: SEPM.ClientContentVersions
      description: Displays the versions for each client.
      type: string
    - contextPath: SEPM.LastUpdated
      description: The last update of a date.
      type: string
  - arguments: []
    description: Retrieves a list of existing policies.
    name: sep-list-policies
    outputs:
    - contextPath: SEPM.PoliciesList.PolicyName
      description: The name of the policy.
      type: string
    - contextPath: SEPM.PoliciesList.Type
      description: The type of the policy.
      type: string
    - contextPath: SEPM.PoliciesList.ID
      description: The ID of the policy.
      type: string
    - contextPath: SEPM.PoliciesList.Description
      description: The description of the policy.
      type: string
    - contextPath: SEPM.PoliciesList.Enabled
      description: Whether the list of polices is enabled. Enabled if "True".
      type: boolean
    - contextPath: SEPM.PoliciesList.AssignedLocations.GroupID
      description: The ID of the group of the locations assigned to this policy.
      type: string
    - contextPath: SEPM.PoliciesList.AssignedLocations.Locations
      description: The list of location IDs assigned to this policy.
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.GroupID
      description: The ID of the cloud group of the locations assigned to this policy.
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.Locations
      description: The list of location IDs belonging to a cloud group assigned to
        this policy.
      type: string
  - arguments:
    - description: The ID of the group to which the endpoint belongs.
      name: groupID
      required: true
    - description: The ID of the location of the endpoint.
      name: locationID
      required: true
    - description: The type of policy to be assigned.
      name: policyType
      required: true
    - description: The ID of the policy to be assigned.
      name: policyID
      required: true
    description: Assigns an existing policy to a specified location.
    name: sep-assign-policy
  - arguments:
    - description: The group ID for which to list locations.
      name: groupID
      required: true
    description: Retrieves a list of location IDs for a specified group.
    name: sep-list-locations
    outputs:
    - contextPath: SEPM.Locations.ID
      description: The ID of the location.
      type: Unknown
  - arguments:
    - description: The IP or hostname of the endpoint.
      name: endpoint
      required: true
    - auto: PREDEFINED
      description: Adds or removes an endpoint from quarantine.
      name: actionType
      predefined:
      - Add
      - Remove
      required: true
    description: Quarantines an endpoint according to its policy.
    name: sep-endpoint-quarantine
    outputs:
    - contextPath: SEPM.Quarantine.CommandID
      description: The ID of the command that was run.
      type: string
    - contextPath: SEPM.Quarantine.Action
      description: The type of the action type. Can be "Add" or "Remove".
      type: string
    - contextPath: SEPM.Quarantine.Endpoint
      description: The IP or hostname of the identifier of the endpoint.
      type: string
  - arguments:
    - description: The IP address or hostname of the endpoint.
      name: endpoint
      required: true
    - auto: PREDEFINED
      description: The scan type of the endpoint. Can be "ScanNow_Quick", "ScanNow_Full",
        or "ScanNow_Custom".
      name: scanType
      predefined:
      - ScanNow_Quick
      - ScanNow_Full
      - ScanNow_Custom
      required: true
    description: Scans an endpoint.
    name: sep-scan-endpoint
    outputs:
    - contextPath: SEPM.Scan.CommandID
      description: The ID of the command that was run.
      type: string
    - contextPath: SEPM.Scan.Type
      description: The type of the scan. Can be "ScanNow_Quick", "ScanNow_Full", or
        "ScanNow_Custom".
      type: string
    - contextPath: SEPM.Scan.Endpoint
      description: The IP or hostname of the identifier of the endpoint.
      type: Unknown
  - arguments:
    - description: The IP address or hostname of the endpoint.
      name: endpoint
      required: true
    description: Updates the content of a specified client.
    name: sep-update-endpoint-content
    outputs:
    - contextPath: SEPM.Update.Endpoint
      description: The endpoint that is being updated.
      type: String
    - contextPath: SEPM.Update.CommandID
      description: The ID of the command for which to check the status.
      type: String
  - arguments:
    - description: The ID of the group to which to move the client.
      name: groupID
      required: true
    - description: The hardware key of the client to be moved.
      name: hardwareKey
      required: true
    description: Moves a client to a group.
    name: sep-move-client-to-group
  - arguments:
    - description: Sets which columns will be displayed.
      name: columns
    - description: Filters by the host name of the computer. A wild card search can
        be done using '*' at the end of the query.
      name: computerName
    - description: Indicates when a computer's status was last updated. The default
        is "0", which returns all results.
      name: lastUpdate
    - description: The operating system by which to filter.
      name: os
    - description: The number of results to include on each page. The default is 20.
      name: pageSize
    - description: The name of the group to which the endpoint belongs. A wild card
        search can be done using '*'at the end of the query.
      name: groupName
    - description: desiredVersion
      name: desiredVersion
    description: Get endpoints for a running version that is different than the target
      version or the desired version (if specified).
    name: sep-identify-old-clients
  runonce: false
  script: |2-


    import requests
    import json
    import re

    requests.packages.urllib3.disable_warnings()
    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']
    ENDPOINTS_INFO_DEFAULT_COLUMNS = [
        'computerName',
        'ipAddresses',
        'operatingSystem',
        'osBitness',
        'cidsDefsetVersion',
        'lastScanTime',
        'description',
        'quarantineDesc',
        'domainOrWorkgroup',
        'macAddresses',
        'group',
        'dhcpServer',
        'biosVersion',
        'virtualizationPlatform',
        'computerTimeStamp',
        'creationTime',
        'agentTimestamp',
        'hardwareKey'
    ]
    GROUPS_INFO_DEFAULT_COLUMNS = [
        'fullPathName',
        'numberOfPhysicalComputers',
        'numberOfRegisteredUsers',
        'policySerialNumber',
        'policyDate',
        'description',
        'created',
        'id'
    ]

    '''LITERALS'''

    EPOCH_MINUTE = 60 * 1000
    EPOCH_HOUR = 60 * EPOCH_MINUTE


    '''HELPER FUNCTIONS'''


    def fix_url(base):
        return base if base.endswith('/') else (base + '/')


    def endpoint_ip_extract(raw_json):
        ips_array = []
        for content in raw_json:
            ip = {'Address': content.get('ipAddresses', [''])[0],
                  'Mac': content.get('computerName')
                  }
            ip = createContext(ip, removeNull=True)
            if ip:
                ips_array.append(ip)
        return ips_array


    def endpoint_endpoint_extract(raw_json):
        endpoints_arr = []
        for content in raw_json:
            endpoint = {'Hostname': content.get('computerName'),
                        'MACAddress': content.get('macAddresses', [''])[0],
                        'Domain': content.get('domainOrWorkgroup'),
                        'IPAddress': content.get('ipAddresses', [''])[0],
                        'DHCPServer': content.get('dhcpServer'),
                        'OS': content.get('operatingSystem'),
                        'OSVersion': content.get('osVersion'),
                        'BIOSVersion': content.get('biosVersion'),
                        'Memory': content.get('memory'),
                        'Processors': content.get('processorType')
                        }
            endpoint = createContext(endpoint, removeNull=True)
            if endpoint:
                endpoints_arr.append(endpoint)
        return endpoints_arr


    def build_query_params(params):
        list_params = map(lambda key: key + '=' + str(params[key]), params.keys())
        query_params = '&'.join(list_params)
        return '?' + query_params if query_params else ''


    def do_auth(server, crads, insecure):
        url = fix_url(str(server)) + 'sepm/api/v1/identity/authenticate'
        body = {
            'username': crads.get('identifier') if crads.get('identifier') else '',
            'password': crads.get('password') if crads.get('password') else '',
            'domain': crads.get('domain') if crads.get('domain') else ''
        }
        res = requests.post(url, headers={"Content-Type": "application/json"}, data=json.dumps(body), verify=not insecure)
        return parse_response(res)


    def do_get(token, raw, suffix):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.get(url, headers={'Authorization': 'Bearer ' + token}, verify=not insecure)
        if (raw):
            return res
        else:
            return parse_response(res)


    def do_post(token, is_xml, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.post(url, headers={'Authorization': 'Bearer ' + token}, data=body, verify=not insecure)
        if is_xml:
            if res.content:
                parsed_response = xml2json(res.content)
            else:
                return_error('Unable to parse the following response: {}'.format(res))
        else:
            parsed_response = parse_response(res)
        return parsed_response


    def do_put(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.put(url, headers={'Authorization': 'Bearer ' + token,
                                         'Content-Type': 'application/json'}, data=json.dumps(body), verify=not insecure)
        parsed_response = parse_response(res)
        return parsed_response


    def do_patch(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.patch(url, headers={'Authorization': 'Bearer ' + token,
                                           'Content-Type': 'application/json'}, data=json.dumps(body), verify=not insecure)
        parsed_response = parse_response(res)
        return parsed_response


    def parse_response(resp):
        if resp.status_code == 200 or resp.status_code == 207:
            if resp.text == '':
                return resp
            try:
                return resp.json()
            except Exception, ex:
                return_error('Unable to parse response: {}'.format(ex))
        else:
            try:
                message = resp.json().get('errorMessage')
                return_error('Error: {}'.format(message))
            except Exception:
                return_error('Error: {}'.format(resp))


    def get_token_from_response(resp):
        if resp.get('token'):
            return resp.get('token')
        else:
            return_error('No token: {}'.format(resp))


    def choose_columns(column_arg, default_list):
        if not column_arg:
            columns_list = default_list
            columns_list.sort()
        elif column_arg == 'all' or column_arg == '*':
            columns_list = []
        else:
            columns_list = argToList(column_arg)
        return columns_list


    def build_command_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"' \
               ' xmlns:com="http://command.client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def build_client_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" ' \
               'xmlns:cli="http://client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def get_command_status_details(token, command_id):
        xml = build_command_xml(
            '<com:getCommandStatusDetails><commandID>{0}</commandID></com:getCommandStatusDetails>'.format(command_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        return res_json


    def build_command_response_output(title, command_id, message, response):
        cmd_status_details = response.get('cmdStatusDetail')
        cmd_status_details.pop('hardwareKey', None)
        md = tableToMarkdown(title, cmd_status_details) + '\n'
        md += '### Command ID: {0}\n'.format(command_id)
        md += '### ' + message
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_details,
                'commandId': command_id
            },
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_details, 'CommandId': command_id},
                                                  removeNull=True)
            }
        })


    def get_computer_id_by_ip(token, ip):
        xml = build_client_xml('<cli:getComputersByIP><ipAddresses>{0}</ipAddresses></cli:getComputersByIP>'.format(ip))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)
        return demisto.get(json.loads(res_json),
                           'Envelope.Body.getComputersByIPResponse.ComputerResult.computers.computerId')


    def get_computer_id_by_hostname(token, hostname):
        xml = build_client_xml(
            '<cli:getComputersByHostName><computerHostNames>{0}</computerHostNames>'
            '</cli:getComputersByHostName>'.format(hostname))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)
        return demisto.get(json.loads(res_json),
                           'Envelope.Body.getComputersByHostNameResponse.ComputerResult.computers.computerId')


    def get_computer_id(token, endpoint_ip, endpoint_host_name):
        if endpoint_ip:
            try:
                computer_id = get_computer_id_by_ip(token, endpoint_ip)
            except Exception:
                return_error('Failed to locate the endpoint by its IP address.')
        elif endpoint_host_name:
            try:
                computer_id = get_computer_id_by_hostname(token, endpoint_host_name)
            except Exception:
                return_error('Failed to locat the endpoint by its hostname.')
        else:
            return_error('Please provide the IP address or the hostname of endpoint.')
        return computer_id


    def update_content(token, computer_id):
        xml = build_command_xml(
            '<com:runClientCommandUpdateContent><computerGUIDList>{0}</computerGUIDList>'
            '</com:runClientCommandUpdateContent>'.format(computer_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(
            res_json), 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(
                res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(
                res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server:'
                             ' {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def scan(token, computer_id, scan_type):
        xml = build_command_xml(
            '<com:runClientCommandScan><computerGUIDList>{0}</computerGUIDList>'
            '<scanType>{1}</scanType></com:runClientCommandScan>'.format(computer_id, scan_type))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.'
                                                       'CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(json.loads(
                res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(json.loads(
                res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message,
                                                                                                     error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def quarantine(token, computer_id, action_type):
        xml = build_command_xml(
            '<com:runClientCommandQuarantine><command><commandType>{0}</commandType><targetObjectIds>{1}'
            '</targetObjectIds><targetObjectType>COMPUTER</targetObjectType></command>'
            '</com:runClientCommandQuarantine>'.format(action_type, computer_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(
            res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(json.loads(
                res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(json.loads(
                res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message,
                                                                                                     error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def validate_time_zone(time_zone):
        pattern = re.compile("^[+-][0-9][0-9]:[0-9][0-9]")
        return bool(pattern.match(time_zone))


    def parse_epoch_to_local(epoch, time_zone):
        if not validate_time_zone(time_zone):
            return_error('timeZone param should be in the format of [+/-][h][h]:[m][m]. For exmaple +04:30')
        operator = time_zone[0]
        hour = int(time_zone[1:3])
        minutes = int(time_zone[4:6])
        time_zone_epoch = hour * EPOCH_HOUR + minutes * EPOCH_MINUTE
        local = int(epoch) + time_zone_epoch if operator == '+' else int(epoch) - time_zone_epoch
        return local


    def change_assigined(policy):
        new_format = {
            'Policy Name': policy.get('PolicyName'),
            'Type': policy.get('Type'),
            'ID': policy.get('ID'),
            'Assigned': True if (policy.get('AssignedLocations') or policy.get('AssignedCloudGroups')) else False,
            'Discription': policy.get('Discription'),
            'Enabled': policy.get('Enabled')
        }
        return new_format


    def sanitize_policies_list_for_md(policies_list):
        return map(change_assigined, policies_list)


    def sanitize_policies_list(policies_list):
        return map(lambda policy: {
            'PolicyName': policy['name'],
            'Type': policy['policytype'],
            'ID': policy['id'],
            'Description': policy['desc'],
            'Enabled': policy['enabled'],
            'AssignedLocations': map(lambda location: {
                'GroupID': location.get('groupId'),
                'Locations': location.get('locationIds')
            }, policy.get('assignedtolocations') if policy.get('assignedtolocations') else []),
            'AssignedCloudGroups': map(lambda location: {
                'GroupID': location.get('groupId'),
                'Locations': location.get('locationIds')
            }, policy.get('assignedtocloudgroups') if policy.get('assignedtocloudgroups') else []),
        }, policies_list)


    def validate_ip(ip):
        pattern = re.compile('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
        return bool(pattern.match(ip))


    def get_client_content(token, time_zone):
        client_content_json = do_get(token, False, 'sepm/api/v1/stats/client/content')
        epoch_time = client_content_json.get('lastUpdated')
        if time_zone:
            epoch_time = parse_epoch_to_local(epoch_time, time_zone)
        last_update_date = timestamp_to_datestring(epoch_time, '%a %b %d %y %H:%M:%S %z')
        client_version = client_content_json.get('clientDefStatusList')
        return client_content_json, client_version, last_update_date


    def get_endpoints_info(token, computer_name, last_update, os, page_size, columns, group_name=None):
        params = {
            'computerName': computer_name,
            'lastUpdate': last_update,
            'os': os,
            'pageSize': page_size,
            'columns': columns
        }
        params = createContext(params, removeNull=True)
        json_response = do_get(token, False, 'sepm/api/v1/computers' + build_query_params(params))
        filtered_json_response = json_response.get('content')
        final_json = []
        entry_context = []
        for content in filtered_json_response:
            group = content.get('group', {'name': ''})
            bool_start = group.get('name').startswith(group_name[:-1]) if group_name and group_name[-1] == '*' else False
            if (not group_name) or group.get('name') == group_name or bool_start:  # No group name filter
                # used `set` on the mac address list as it sometimes contained duplicated values
                content['macAddresses'] = list(set(content.get('macAddresses')))
                entry_context.append({
                    'Hostname': content.get('computerName'),
                    'Domain': content.get('domainOrWorkgroup'),
                    'IPAddresses': content.get('ipAddresses'),
                    'OS': content.get('operatingSystem', '') + ' | ' + content.get('osBitness', ''),
                    'Description': content.get('content.description'),
                    'MACAddresses': content.get('macAddresses'),
                    'BIOSVesrsion': content.get('biosVersion'),
                    'DHCPServer': content.get('dhcpServer'),
                    'HardwareKey': content.get('hardwareKey'),
                    'LastScanTime': epochToTimestamp(content.get('lastScanTime')),
                    'RunningVersion': content.get('deploymentRunningVersion'),
                    'TargetVersion': content.get('deploymentTargetVersion'),
                    'Group': group.get('name'),
                    'PatternIdx': content.get('patternIdx'),
                    'OnlineStatus': content.get('onlineStatus'),
                    'UpdateTime': epochToTimestamp(content.get('lastUpdateTime')),
                })
                final_json.append(content)

        return final_json, entry_context


    def create_endpints_filter_string(computer_name, last_update, os, page_size, group_name=None):
        md = '## Endpoints Information'
        if last_update != '0':
            md += ', filtered for last updated status: {}'.format(last_update) if last_update else ''
        md += ', filtered for hostname: {}'.format(computer_name) if computer_name else ''
        md += ', filtered for os: {}'.format(os) if os else ''
        md += ', filtered for group name: {}'.format(group_name) if group_name else ''
        md += ', page size: {}'.format(page_size) if page_size else ''
        md += '\n'
        return md


    def get_groups_info(token, columns):
        json_res = do_get(token, False, 'sepm/api/v1/groups' + build_query_params({'columns': columns}))
        sepm_groups = []
        filtered_json_response = json_res.get('content')
        for entry in filtered_json_response:
            group = {}
            for header in GROUPS_INFO_DEFAULT_COLUMNS:
                group[header] = entry[header]
                sepm_groups.append(group)
        return filtered_json_response, json_res, sepm_groups


    def get_command_status(token, command_id):
        command_status_json = get_command_status_details(token, command_id)
        cmd_status_detail = demisto.get(json.loads(command_status_json),
                                        'Envelope.Body.getCommandStatusDetailsResponse.'
                                        'CommandStatusDetailResult.cmdStatusDetail')
        cmd_status_detail.pop('hardwareKey', None)
        state_id = cmd_status_detail.get('stateId')
        is_done = False
        if state_id == '2' or state_id == '3':
            is_done = True
        message = 'Command is done.' if is_done else 'Command is in progress. Run !sep-command-status to check again.'
        return cmd_status_detail, message


    def get_list_of_policies(token):
        policies_list = do_get(token, False, 'sepm/api/v1/policies/summary').get('content')
        fixed_policy_list = sanitize_policies_list(policies_list)
        md_list = sanitize_policies_list_for_md(fixed_policy_list)
        return md_list, policies_list, fixed_policy_list


    def endpoint_quarantine(token, endpoint, action):
        action_type = 'Quarantine' if action == 'Add' else 'Undo'
        computer_id = get_id_by_endpoint(token, endpoint)
        command_id = quarantine(token, computer_id, action_type)
        return command_id


    def get_location_list(token, group_id):
        url = 'sepm/api/v1/groups/{}/locations'.format(group_id)
        url_resp = do_get(token, False, url)
        location_ids = map(lambda location_string: {'ID': location_string.split('/')[-1]}, url_resp)
        return url_resp, location_ids


    def get_id_by_endpoint(token, endpoint):
        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)
        return computer_id


    def scan_endpoint(token, endpoint, scan_type):
        computer_id = get_id_by_endpoint(token, endpoint)
        command_id = scan(token, computer_id, scan_type)
        return command_id


    def update_endpoint_content(token, endpoint):
        computer_id = get_id_by_endpoint(token, endpoint)
        command_id = update_content(token, computer_id)
        return command_id


    def filter_only_old_clients(filtered_json_response, desired_version):
        filtered = []
        for content in filtered_json_response:
            RunningVersion = content.get('deploymentRunningVersion')
            TargetVersion = content.get('deploymentTargetVersion')

            if (desired_version and RunningVersion != desired_version) or \
                    (not desired_version and RunningVersion != TargetVersion):
                filtered.append(content)
        return filtered


    '''COMMANDS'''


    def system_info_command(token):
        version_json = do_get(token, False, 'sepm/api/v1/version')
        avdef_json = do_get(token, False, 'sepm/api/v1/content/avdef/latest')
        system_info_json = {
            'version': version_json,
            'avdef': avdef_json
        }
        md = '## System Information\n'
        md += tableToMarkdown('Version', version_json)
        md += tableToMarkdown('AV Definitions', avdef_json)
        context = avdef_json.get('publishedBySymantec')
        if type(context) is dict:
            context = createContext(context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': system_info_json,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.ServerAVDefVersion': context
            }
        })


    def old_clients_command(token):
        computer_name = demisto.getArg('computerName')
        last_update = demisto.getArg('lastUpdate')
        os = demisto.getArg('os')
        page_size = demisto.getArg('pageSize')
        columns = demisto.getArg('columns')
        group_name = demisto.getArg('groupName')
        desired_version = demisto.getArg('desiredVersion')
        filtered_json_response, entry_context = get_endpoints_info(token, computer_name, last_update, os, page_size,
                                                                   columns, group_name)
        columns_list = choose_columns(columns, ENDPOINTS_INFO_DEFAULT_COLUMNS)
        filtered_json_response = filter_only_old_clients(filtered_json_response, desired_version)
        md = create_endpints_filter_string(computer_name, last_update, os, page_size, group_name)
        md += tableToMarkdown('Old Endpoints', filtered_json_response, columns_list)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': filtered_json_response,
            'HumanReadable': md
        })


    def client_content_command(token):
        time_zone = demisto.getParam('timeZone')
        client_content_json, client_version, last_update_date = get_client_content(token, time_zone)
        md = '## Client Content, last updated on {0}\n'.format(last_update_date)
        md += tableToMarkdown('Client Content Versions', client_version)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': client_content_json,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.ClientContentVersions': client_version,
                'SEPM.LastUpdated': last_update_date
            }
        })


    def endpoints_info_command(token):
        computer_name = demisto.getArg('computerName')
        last_update = demisto.getArg('lastUpdate')
        os = demisto.getArg('os')
        page_size = demisto.getArg('pageSize')
        columns = demisto.getArg('columns')
        group_name = demisto.getArg('groupName')
        filtered_json_response, entry_context = get_endpoints_info(token, computer_name, last_update, os, page_size,
                                                                   columns, group_name)
        columns_list = choose_columns(columns, ENDPOINTS_INFO_DEFAULT_COLUMNS)
        md = create_endpints_filter_string(computer_name, last_update, os, page_size, group_name)
        md += tableToMarkdown('Endpoints', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': filtered_json_response,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Endpoint(val.Hostname == obj.Hostname)': createContext(entry_context, removeNull=True),
                'IP(val.Address === obj.Address)': endpoint_ip_extract(filtered_json_response),
                'Endpoint(val.Hostname == obj.Hostname)': endpoint_endpoint_extract(filtered_json_response)
            }
        })


    def groups_info_command(token):
        columns = demisto.getArg('columns')
        filtered_json_response, json_res, sepm_groups = get_groups_info(token, columns)
        columns_list = choose_columns(columns, GROUPS_INFO_DEFAULT_COLUMNS)
        md = tableToMarkdown('Groups Information', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': json_res,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext':
                {
                    'SEPM.Groups': sepm_groups
            }
        })


    def command_status(token):
        command_id = demisto.getArg('commandId')
        cmd_status_detail, message = get_command_status(token, command_id)
        md = '### Command ID: {0}\n'.format(command_id)
        md += '### State ID: {0}\n'.format(cmd_status_detail.get('stateId'))
        md += '### ' + message
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_detail,
                'commandId': command_id
            },
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_detail, 'CommandID': command_id},
                                                  removeNull=True)
            }
        })


    def list_policies_command(token):
        md_list, policies_list, fixed_policy_list = get_list_of_policies(token)
        md = tableToMarkdown('List of existing policies', md_list, [
                             'Policy Name', 'Type', 'ID', 'Enabled', 'Assigned', 'Description'])
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': policies_list,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.PoliciesList': createContext(fixed_policy_list, removeNull=True)
            }
        })


    def assign_policie_command(token):
        group_id = demisto.getArg('groupID')
        locatoion_id = demisto.getArg('locationID')
        policy_type = demisto.getArg('policyType').lower()
        policy_id = demisto.getArg('policyID')
        do_put(token, 'sepm/api/v1/groups/{0}/locations/{1}/policies/{2}'.format(group_id,
                                                                                 locatoion_id, policy_type),
                      {'id': policy_id})
        md = '### Policy: {0}, of type: {1}, was assigned to location: {2}, in group: {3}'.format(
            policy_id, policy_type, locatoion_id, group_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': '',
            'HumanReadable': md,
            'EntryContext': {}
        })


    def list_locations_command(token):
        group_id = demisto.getArg('groupID')
        url_resp, location_ids = get_location_list(token, group_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': url_resp,
            'HumanReadable': tableToMarkdown('Locations', map(lambda location: {'Location ID': location.get('ID')},
                                                              location_ids)),
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Locations': location_ids
            }
        })


    def endpoint_quarantine_command(token):
        endpoint = demisto.getArg('endpoint')
        action = demisto.getArg('actionType')
        command_id = endpoint_quarantine(token, endpoint, action)
        message = '### Initiated quarantine for endpoint {0}.' \
                  ' Command ID: {1}.'.format(endpoint, command_id) \
            if action == 'Add' else '### Removing endpoint: {0} from quarantine. Command ID: {1}.'.format(endpoint,
                                                                                                          command_id)
        context = {
            'CommandID': command_id,
            'Action': action,
            'Endpoint': endpoint
        }
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Quarantine': context
            }
        })


    def scan_endpoint_command(token):
        endpoint = demisto.getArg('endpoint')
        scan_type = demisto.getArg('scanType')
        command_id = scan_endpoint(token, endpoint, scan_type)
        message = '### Initiated scan on endpoint: {0} with type: {1}. Command ID: {2}.'.format(endpoint,
                                                                                                scan_type, command_id)
        context = {
            'CommandID': command_id,
            'Type': scan_type,
            'Endpoint': endpoint
        }
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Scan': context
            }
        })


    def update_endpoint_content_command(token):
        endpoint = demisto.getArg('endpoint')
        command_id = update_endpoint_content(token, endpoint)
        message = '### Updating endpoint: {0}. Command ID: {1}.'.format(endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Endpoint': endpoint
        }
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Update': context
            }
        })


    def move_client_to_group(token, group_id, hardware_key):
        body = [{
            'group': {
                'id': group_id
            },
            'hardwareKey': hardware_key
        }]
        response = do_patch(token, 'sepm/api/v1/computers', body)
        message = '### Moved client to requested group successfully' \
            if response[0].get('responseCode') == '200' \
            else '### Error moving client'
        return response, message


    def move_client_to_group_command(token):
        group_id = demisto.getArg('groupID')
        hardware_key = demisto.getArg('hardwareKey')
        response, message = move_client_to_group(token, group_id, hardware_key)
        demisto.results(
            {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['text'],
                'Contents': response,
                'HumanReadable': message,
                'IgnoreAutoExtract': True,
            })


    '''COMMANDS SWITCH'''

    current_command = demisto.command()
    try:
        '''
        Before EVERY command the following tow lines are performed (do_auth and get_token_from_response)
        '''
        resp = do_auth(server=demisto.getParam('server'), crads=demisto.getParam(
            'authentication'), insecure=demisto.getParam('insecure'))
        token = get_token_from_response(resp)
        if current_command == 'test-module':
            # This is the call made when pressing the integration test button.
            if token:
                demisto.results('ok')
        if current_command == 'sep-system-info':
            system_info_command(token)
        if current_command == 'sep-client-content':
            client_content_command(token)
        if current_command == 'sep-endpoints-info':
            endpoints_info_command(token)
        if current_command == 'sep-groups-info':
            groups_info_command(token)
        if current_command == 'sep-command-status':
            command_status(token)
        if current_command == 'sep-list-policies':
            list_policies_command(token)
        if current_command == 'sep-assign-policy':
            assign_policie_command(token)
        if current_command == 'sep-list-locations':
            list_locations_command(token)
        if current_command == 'sep-endpoint-quarantine':
            endpoint_quarantine_command(token)
        if current_command == 'sep-scan-endpoint':
            scan_endpoint_command(token)
        if current_command == 'sep-update-endpoint-content':
            update_endpoint_content_command(token)
        if current_command == 'sep-move-client-to-group':
            move_client_to_group_command(token)
        if current_command == 'sep-identify-old-clients':
            old_clients_command(token)
    except Exception, ex:
        demisto.results('Cannot perform the command: {}. Error: {}'.format(current_command, ex))
  subtype: python2
  type: python
system: true
