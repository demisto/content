category: Forensics & Malware Analysis
commonfields:
  id: WildFire-v2
  version: -1
configuration:
- defaultvalue: https://wildfire.paloaltonetworks.com/publicapi
  display: Server URL (e.g. https://192.168.0.1)
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: API Key
  name: token
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Return warning entry for unsupported file types
  name: suppress_file_type_error
  required: false
  type: 8
description: Perform malware dynamic analysis
detaileddescription: |
  Don't have a WildFire API key?
  Go to your WildFire account,
  Login to: https://wildfire.paloaltonetworks.com/wildfire/account
  Select the "Account" tab
  Copy your API Key
display: Palo Alto Networks WildFire v2
image: data:image/png;base64,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
name: WildFire-v2
script:
  commands:
  - arguments:
    - default: true
      description: File hash to check.
      isArray: true
      name: file
    - description: MD5 hash to check.
      isArray: true
      name: md5
    - description: SHA256 hash to check.
      isArray: true
      name: sha256
    description: Retrieve results for a file hash using WildFire
    name: file
    outputs:
    - contextPath: File.Name
      description: Name of the file.
      type: string
    - contextPath: File.Type
      description: 'File type, for example: "PE"'
      type: string
    - contextPath: File.Size
      description: Size of the file.
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submission.
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 hash of the submission.
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the report file.
      type: Unknown
    - contextPath: InfoFile.Extension
      description: Extension of the report file.
      type: string
    - contextPath: InfoFile.Name
      description: Name of the report file.
      type: string
    - contextPath: InfoFile.Info
      description: Details of the report file.
      type: string
    - contextPath: InfoFile.Size
      description: Size of the report file.
      type: number
    - contextPath: InfoFile.Type
      description: The report file type.
      type: string
  - arguments:
    - description: ID of the entry containing the file to upload
      isArray: true
      name: upload
      required: true
    description: Uploads a file to WildFire for analysis.
    name: wildfire-upload
    outputs:
    - contextPath: WildFire.Report.MD5
      description: MD5 hash of the submission.
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 hash of the submission.
      type: string
    - contextPath: WildFire.Report.FileType
      description: The submission type.
      type: string
    - contextPath: WildFire.Report.Size
      description: The size of the submission.
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submission.
      type: string
  - arguments:
    - description: URL of the remote file to upload.
      name: upload
      required: true
    description: Uploads the URL of a remote file to WildFire for analysis.
    name: wildfire-upload-file-url
    outputs:
    - contextPath: WildFire.Report.MD5
      description: MD5 hash of the submission.
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 hash of the submission.
      type: string
    - contextPath: WildFire.Report.Status
      description: The status of the submission.
      type: string
    - contextPath: WildFire.Report.URL
      description: URL of the submission.
      type: string
  - arguments:
    - description: MD5 hash to check.
      isArray: true
      name: md5
    - description: SHA256 hash to check
      isArray: true
      name: sha256
    - description: Deprecated - Use the sha256 argument instead.
      isArray: true
      name: hash
    - auto: PREDEFINED
      defaultValue: pdf
      description: Request a structured report (XML PDF).
      name: format
      predefined:
      - xml
      - pdf
    - auto: PREDEFINED
      defaultValue: "false"
      description: Receive extended information from WildFire.
      name: verbose
      predefined:
      - "true"
      - "false"
    description: Retrieves results for a file hash using WildFire.
    name: wildfire-report
    outputs:
    - contextPath: File.Name
      description: Name of the file.
      type: string
    - contextPath: File.Type
      description: 'File type, for example: "PE"'
      type: string
    - contextPath: File.Size
      description: Size of the file.
      type: number
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submissiom.
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 hash of the submission.
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the report file.
      type: string
    - contextPath: InfoFile.Extension
      description: The extension of the report file.
      type: string
    - contextPath: InfoFile.Name
      description: The name of the report file.
      type: string
    - contextPath: InfoFile.Info
      description: Details of the report file.
      type: string
    - contextPath: InfoFile.Size
      description: The size of the report file.
      type: number
    - contextPath: InfoFile.Type
      description: The report file type.
      type: string
    - contextPath: WildFire.Report.Network.UDP.IP
      description: Submission related IPs, in UDP protocol.
      type: string
    - contextPath: WildFire.Report.Network.UDP.Port
      description: Submission related ports, in UDP protocol.
      type: string
    - contextPath: WildFire.Report.Network.TCP.IP
      description: Submission related IPs, in TCP protocol.
      type: string
    - contextPath: WildFire.Report.Network.TCP.Port
      description: Submission related ports, in TCP protocol.
      type: string
    - contextPath: WildFire.Report.Network.DNS.Query
      description: Submission DNS queries.
      type: string
    - contextPath: WildFire.Report.Network.DNS.Response
      description: Submission DNS responses.
      type: string
    - contextPath: WildFire.Report.Evidence.md5
      description: Submission evidence MD5 hash.
      type: string
    - contextPath: WildFire.Report.Evidence.Text
      description: Submission evidence text.
      type: string
  - arguments:
    - description: Hash to get the verdict for.
      isArray: true
      name: hash
      required: true
    description: Returns a verdict for a hash.
    name: wildfire-get-verdict
    outputs:
    - contextPath: WildFire.Verdicts.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: WildFire.Verdicts.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: WildFire.Verdicts.Verdict
      description: Verdict of the file.
      type: number
    - contextPath: WildFire.Verdicts.VerdictDescription
      description: Description of the file verdict.
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
  - arguments:
    - description: EntryID of the text file that contains multiple hashes. Limit is
        500 hashes.
      isArray: true
      name: EntryID
    - description: A list of hashes to get verdicts for.
      isArray: true
      name: hash_list
    description: Returns a verdict regarding multiple hashes, stored in a TXT file
      or given as list.
    name: wildfire-get-verdicts
    outputs:
    - contextPath: WildFire.Verdicts.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: WildFire.Verdicts.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: WildFire.Verdicts.Verdict
      description: Verdict of the file.
      type: number
    - contextPath: WildFire.Verdicts.VerdictDescription
      description: Description of the file verdict.
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
  - arguments:
    - description: URL to submit to WildFire.
      isArray: true
      name: upload
      required: true
    description: Uploads a URL of a webpage to WildFire for analysis.
    name: wildfire-upload-url
    outputs:
    - contextPath: WildFire.Report.MD5
      description: MD5 of the submission.
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 of the submission.
      type: string
    - contextPath: WildFire.Report.Status
      description: The status of the submission.
      type: string
    - contextPath: WildFire.Report.URL
      description: URL of the submission.
      type: string
  - arguments:
    - description: MD5 hash of the sample.
      isArray: true
      name: md5
    - description: SHA256 hash of the sample.
      name: sha256
    description: Retrieves a sample.
    name: wildfire-get-sample
  dockerimage: demisto/python3:3.7.3.221
  runonce: false
  script: |2-




    ''' IMPORTS '''
    import json
    import requests
    import shutil

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''
    URL = demisto.getParam('server')
    TOKEN = demisto.getParam('token')
    USE_SSL = not demisto.params().get('insecure', False)
    FILE_TYPE_SUPPRESS_ERROR = demisto.getParam('suppress_file_type_error')
    DEFAULT_HEADERS = {'Content-Type': 'application/x-www-form-urlencoded'}
    MULTIPART_HEADERS = {'Content-Type': "multipart/form-data; boundary=upload_boundry"}

    URL_DICT = {
        'verdict': '/get/verdict',
        'verdicts': '/get/verdicts',
        'upload_file': '/submit/file',
        'upload_url': '/submit/link',
        'upload_file_url': '/submit/url',
        'report': '/get/report',
        'sample': '/get/sample'
    }

    ERROR_DICT = {
        '401': 'Unauthorized, API key invalid',
        '404': 'Not Found, The report was not found',
        '405': 'Method Not Allowed, Method other than POST used',
        '413': 'Request Entity Too Large, Sample file size over max limit',
        '415': 'Unsupported Media Type',
        '418': 'Unsupported File Type Sample, file type is not supported',
        '419': 'Request quota exceeded',
        '420': 'Insufficient arguments',
        '421': 'Invalid arguments',
        '500': 'Internal error',
        '502': 'Bad Gateway',
        '513': 'File upload failed'
    }

    VERDICTS_DICT = {
        '0': 'benign',
        '1': 'malware',
        '2': 'grayware',
        '4': 'phishing',
        '-100': 'pending, the sample exists, but there is currently no verdict',
        '-101': 'error',
        '-102': 'unknown, cannot find sample record in the database',
        '-103': 'invalid hash value'
    }

    VERDICTS_TO_DBOTSCORE = {
        '0': 1,
        '1': 3,
        '2': 2,
        '4': 3,
        '-100': 0,
        '-101': 0,
        '-102': 0,
        '-103': 0
    }

    ''' HELPER FUNCTIONS '''


    def http_request(url, method, headers=None, body=None, params=None, files=None):
        LOG('running request with url=%s' % url)
        result = requests.request(
            method,
            url,
            headers=headers,
            data=body,
            verify=USE_SSL,
            params=params,
            files=files
        )

        if str(result.reason) == 'Not Found':
            # sample not found
            if url.find(URL_DICT["sample"]) != -1:
                demisto.results(
                    'Sample was not found. '
                    'Please note that grayware and benign samples are available for 14 days only. '
                    'For more info contact your wildfire representative.')
                sys.exit(0)
            # report not found
            if url.find(URL_DICT["report"]) != -1:
                demisto.results('Report not found.')
                sys.exit(0)

        if result.status_code < 200 or result.status_code >= 300:
            if str(result.status_code) in ERROR_DICT:
                if result.status_code == 418 and FILE_TYPE_SUPPRESS_ERROR:
                    demisto.results({
                        'Type': 11,
                        'Contents': f'Request Failed with status: {result.status_code}'
                                    f' Reason is: {ERROR_DICT[str(result.status_code)]}',
                        'ContentsFormat': formats['text']
                    })
                    sys.exit(0)
                else:
                    return_error(f'Request Failed with status: {result.status_code}'
                                 f' Reason is: {ERROR_DICT[str(result.status_code)]}')
            else:
                return_error(f'Request Failed with status: {result.status_code} Reason is: {result.reason}')
        if result.text.find("Forbidden. (403)") != -1:
            return_error('Request Forbidden - 403, check SERVER URL and API Key')

        if result.headers['Content-Type'] == 'application/octet-stream':
            return result
        else:
            try:
                json_res = json.loads(xml2json(result.text))
                return json_res
            except Exception:
                return_error(f'Failed to parse response to json. response: {result.text}')


    def prettify_upload(upload_body):
        pretty_upload = {
            'MD5': upload_body["md5"],
            'SHA256': upload_body["sha256"],
            'Status': 'Pending'
        }
        if 'filetype' in upload_body:
            pretty_upload["FileType"] = upload_body["filetype"]
        if 'size' in upload_body:
            pretty_upload["Size"] = upload_body["size"]
        if 'url' in upload_body:
            pretty_upload["URL"] = upload_body["url"]

        return pretty_upload


    def prettify_report_entry(file_info):
        pretty_report = {
            'MD5': file_info["md5"],
            'SHA256': file_info["sha256"],
            'Status': 'Completed'
        }
        if 'filetype' in file_info:
            pretty_report["FileType"] = file_info["filetype"]
        if 'size' in file_info:
            pretty_report["Size"] = file_info["size"]
        if 'url' in file_info:
            pretty_report["URL"] = file_info["url"]

        return pretty_report


    def prettify_verdict(verdict_data):
        pretty_verdict = {}

        if 'md5' in verdict_data:
            pretty_verdict["MD5"] = verdict_data["md5"]
        if 'sha256' in verdict_data:
            pretty_verdict["SHA256"] = verdict_data["sha256"]

        pretty_verdict["Verdict"] = verdict_data["verdict"]
        pretty_verdict["VerdictDescription"] = VERDICTS_DICT[verdict_data["verdict"]]

        return pretty_verdict


    def create_dbot_score_from_verdict(pretty_verdict):
        if 'SHA256' not in pretty_verdict and 'MD5' not in pretty_verdict:
            return_error('Hash is missing in WildFire verdict.')
        if pretty_verdict["Verdict"] not in VERDICTS_TO_DBOTSCORE:
            return_error('This hash verdict is not mapped to a DBotScore. Contact Demisto support for more information.')
        dbot_score = {
            'Indicator': pretty_verdict["SHA256"] if 'SHA256' in pretty_verdict else pretty_verdict["MD5"],
            'Type': 'hash',
            'Vendor': 'WildFire',
            'Score': VERDICTS_TO_DBOTSCORE[pretty_verdict["Verdict"]]
        }
        return dbot_score


    def prettify_verdicts(verdicts_data):
        pretty_verdicts_arr = []

        for verdict_data in verdicts_data:
            pretty_verdict = {}
            if 'md5' in verdict_data:
                pretty_verdict["MD5"] = verdict_data["md5"]
            if 'sha256' in verdict_data:
                pretty_verdict["SHA256"] = verdict_data["sha256"]

            pretty_verdict["Verdict"] = verdict_data["verdict"]
            pretty_verdict["VerdictDescription"] = VERDICTS_DICT[verdict_data["verdict"]]

            pretty_verdicts_arr.append(pretty_verdict)

        return pretty_verdicts_arr


    def create_dbot_score_from_verdicts(pretty_verdicts):
        dbot_score_arr = []

        for pretty_verdict in pretty_verdicts:

            if 'SHA256' not in pretty_verdict and 'MD5' not in pretty_verdict:
                return_error('Hash is missing in WildFire verdict.')
            if pretty_verdict["Verdict"] not in VERDICTS_TO_DBOTSCORE:
                return_error(
                    'This hash verdict is not mapped to a DBotScore. Contact Demisto support for more information.')

            dbot_score = {
                'Indicator': pretty_verdict["SHA256"] if "SHA256" in pretty_verdict else pretty_verdict["MD5"],
                'Type': 'hash',
                'Vendor': 'WildFire',
                'Score': VERDICTS_TO_DBOTSCORE[pretty_verdict["Verdict"]]
            }
            dbot_score_arr.append(dbot_score)

        return dbot_score_arr


    def create_upload_entry(upload_body, title, result):
        pretty_upload_body = prettify_upload(upload_body)
        md = tableToMarkdown(title, pretty_upload_body, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': result,
            'ContentsFormat': formats['json'],
            'HumanReadable': md,
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {
                "WildFire.Report(val.SHA256 == obj.SHA256 || val.MD5 == obj.MD5)": pretty_upload_body
            }
        })


    def hash_args_handler(sha256=None, md5=None):
        # hash argument used in wildfire-report, wildfire-verdict commands
        inputs = argToList(sha256) if sha256 else argToList(md5)
        for element in inputs:
            if sha256Regex.match(element) or md5Regex.match(element):
                continue
            else:
                return_error('Invalid hash. Only SHA256 and MD5 are supported.')

        return inputs


    def file_args_handler(file=None, sha256=None, md5=None):
        # file/md5/sha256 are used in file command
        if (file and not md5 and not sha256) or (not file and md5 and not sha256) or (not file and md5 and not sha256):
            if file:
                inputs = argToList(file)
            elif md5:
                inputs = argToList(md5)
            else:
                inputs = argToList(sha256)

            for element in inputs:
                if sha256Regex.match(element) or md5Regex.match(element) or sha1Regex.match(element):
                    continue
                else:
                    return_error('Invalid hash. Only SHA256 and MD5 are supported.')

            return inputs

        else:
            return_error('Specify exactly 1 of the following arguments: file, sha256, md5.')


    def hash_list_to_file(hash_list):
        file_path = demisto.uniqueFile()
        with open(file_path, 'w') as f:
            f.write("\n".join(hash_list))

        return [file_path]


    ''' COMMANDS '''


    def test_module():
        if wildfire_upload_url('https://www.demisto.com')[1]:
            demisto.results('ok')


    @logger
    def wildfire_upload_file(upload):
        upload_file_uri = URL + URL_DICT["upload_file"]
        body = {'apikey': TOKEN}

        file_path = demisto.getFilePath(upload)['path']
        file_name = demisto.getFilePath(upload)['name']

        try:
            shutil.copy(file_path, file_name)
        except Exception:
            return_error('Failed to prepare file for upload.')

        try:
            with open(file_name, 'rb') as f:
                result = http_request(
                    upload_file_uri,
                    'POST',
                    body=body,
                    files={'file': f}
                )
        finally:
            shutil.rmtree(file_name, ignore_errors=True)

        upload_file_data = result["wildfire"]["upload-file-info"]

        return result, upload_file_data


    def wildfire_upload_file_command():
        uploads = argToList(demisto.args().get('upload'))
        for upload in uploads:
            result, upload_file_data = wildfire_upload_file(upload)
            create_upload_entry(upload_file_data, 'WildFire Upload File', result)


    @logger
    def wildfire_upload_file_url(upload):
        upload_file_url_uri = URL + URL_DICT["upload_file_url"]
        body = f'''--upload_boundry
    Content-Disposition: form-data; name="apikey"

    {TOKEN}
    --upload_boundry
    Content-Disposition: form-data; name="url"

    {upload}
    --upload_boundry--'''

        result = http_request(
            upload_file_url_uri,
            'POST',
            headers=MULTIPART_HEADERS,
            body=body
        )

        upload_file_url_data = result["wildfire"]["upload-file-info"]

        return result, upload_file_url_data


    def wildfire_upload_file_url_command():
        uploads = argToList(demisto.args().get('upload'))
        for upload in uploads:
            result, upload_file_url_data = wildfire_upload_file_url(upload)
            create_upload_entry(upload_file_url_data, 'WildFire Upload File URL', result)


    @logger
    def wildfire_upload_url(upload):
        upload_url_uri = URL + URL_DICT["upload_url"]
        body = '''--upload_boundry
    Content-Disposition: form-data; name="apikey"

    {apikey}
    --upload_boundry
    Content-Disposition: form-data; name="link"

    {link}
    --upload_boundry--'''.format(apikey=TOKEN, link=upload)

        result = http_request(
            upload_url_uri,
            'POST',
            headers=MULTIPART_HEADERS,
            body=body
        )

        upload_url_data = result["wildfire"]["submit-link-info"]

        return result, upload_url_data


    def wildfire_upload_url_command():
        uploads = argToList(demisto.args().get('upload'))
        for upload in uploads:
            result, upload_url_data = wildfire_upload_url(upload)
            create_upload_entry(upload_url_data, 'WildFire Upload URL', result)


    @logger
    def wildfire_get_verdict(file_hash):
        get_verdict_uri = URL + URL_DICT["verdict"]
        body = 'apikey=' + TOKEN + '&hash=' + file_hash

        result = http_request(get_verdict_uri, 'POST', headers=DEFAULT_HEADERS, body=body)
        verdict_data = result["wildfire"]["get-verdict-info"]

        return result, verdict_data


    def wildfire_get_verdict_command():
        inputs = hash_args_handler(demisto.args().get('hash'))
        for element in inputs:
            result, verdict_data = wildfire_get_verdict(element)

            pretty_verdict = prettify_verdict(verdict_data)
            md = tableToMarkdown('WildFire Verdict', pretty_verdict, removeNull=True)

            dbot_score = create_dbot_score_from_verdict(pretty_verdict)
            ec = {
                "WildFire.Verdicts(val.SHA256 == obj.SHA256 || val.MD5 == obj.MD5)": pretty_verdict,
                "DBotScore(val.Indicator == obj.Indicator)": dbot_score
            }

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': result,
                'ContentsFormat': formats['json'],
                'HumanReadable': md,
                'ReadableContentsFormat': formats['markdown'],
                'EntryContext': ec
            })


    @logger
    def wildfire_get_verdicts(file_path):
        get_verdicts_uri = URL + URL_DICT["verdicts"]
        body = {'apikey': TOKEN}

        try:
            with open(file_path, 'rb') as f:
                result = http_request(
                    get_verdicts_uri,
                    'POST',
                    body=body,
                    files={'file': f}
                )
        finally:
            shutil.rmtree(file_path, ignore_errors=True)

        verdicts_data = result["wildfire"]["get-verdict-info"]

        return result, verdicts_data


    def wildfire_get_verdicts_command():
        if ('EntryID' in demisto.args() and 'hash_list' in demisto.args()) or (
                'EntryID' not in demisto.args() and 'hash_list' not in demisto.args()):
            return_error('Specify exactly 1 of the following arguments: EntryID, hash_list.')

        if 'EntryID' in demisto.args():
            inputs = argToList(demisto.args().get('EntryID'))
            paths = [demisto.getFilePath(element)['path'] for element in inputs]

        else:
            paths = hash_list_to_file(argToList(demisto.args().get('hash_list')))

        for file_path in paths:
            result, verdicts_data = wildfire_get_verdicts(file_path)

            pretty_verdicts = prettify_verdicts(verdicts_data)
            md = tableToMarkdown('WildFire Verdicts', pretty_verdicts, removeNull=True)

            dbot_score = create_dbot_score_from_verdicts(pretty_verdicts)
            ec = {
                "WildFire.Verdicts(val.SHA256 == obj.SHA256 || val.MD5 == obj.MD5)": pretty_verdicts,
                "DBotScore(val.Indicator == obj.Indicator)": dbot_score
            }

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': result,
                'ContentsFormat': formats['json'],
                'HumanReadable': md,
                'ReadableContentsFormat': formats['markdown'],
                'EntryContext': ec
            })


    def create_report(file_hash, reports, file_info, format_='xml', verbose=False):
        udp_ip = []
        udp_port = []
        tcp_ip = []
        tcp_port = []
        dns_query = []
        dns_response = []
        evidence_md5 = []
        evidence_text = []

        # When only one report is in response, it's returned as a single json object and not a list.
        if not isinstance(reports, list):
            reports = [reports]

        for report in reports:
            if 'network' in report and report["network"]:
                if 'UDP' in report["network"]:
                    if '-ip' in report["network"]["UDP"]:
                        udp_ip.append(report["network"]["UDP"]["-ip"])
                    if '-port' in report["network"]["UDP"]:
                        udp_port.append(report["network"]["UDP"]["-port"])
                if 'TCP' in report["network"]:
                    if '-ip' in report["network"]["TCP"]:
                        tcp_ip.append(report["network"]["TCP"]["-ip"])
                    if '-port' in report["network"]["TCP"]:
                        tcp_port.append(report["network"]["TCP"]['-port'])
                if 'dns' in report["network"]:
                    for dns_obj in report["network"]["dns"]:
                        if '-query' in dns_obj:
                            dns_query.append(dns_obj['-query'])
                        if '-response' in dns_obj:
                            dns_response.append(dns_obj['-response'])

            if 'evidence' in report and report["evidence"]:
                if 'file' in report["evidence"]:
                    if isinstance(report["evidence"]["file"], dict) and 'entry' in report["evidence"]["file"]:
                        if '-md5' in report["evidence"]["file"]["entry"]:
                            evidence_md5.append(report["evidence"]["file"]["entry"]["-md5"])
                        if '-text' in report["evidence"]["file"]["entry"]:
                            evidence_text.append(report["evidence"]["file"]["entry"]["-text"])

        outputs = {
            'Status': 'Success',
            'SHA256': file_info["sha256"]
        }

        if len(udp_ip) > 0 or len(udp_port) > 0 or len(tcp_ip) > 0 or len(tcp_port) > 0 or dns_query or dns_response:

            outputs["Network"] = {}

            if len(udp_ip) > 0 or len(udp_port) > 0:
                outputs["Network"]["UDP"] = {}
                if len(udp_ip) > 0:
                    outputs["Network"]["UDP"]["IP"] = udp_ip
                if len(udp_port) > 0:
                    outputs["Network"]["UDP"]["Port"] = udp_port

            if len(tcp_ip) > 0 or len(tcp_port) > 0:
                outputs["Network"]["TCP"] = {}
                if len(tcp_ip) > 0:
                    outputs["Network"]["TCP."]["IP"] = tcp_ip
                if len(tcp_port) > 0:
                    outputs["Network"]["TCP"]["Port"] = tcp_port

            if len(dns_query) > 0 or len(dns_response) > 0:
                outputs["Network"]["DNS"] = {}
                if len(dns_query) > 0:
                    outputs["Network"]["DNS"]["Query"] = dns_query
                if len(dns_response) > 0:
                    outputs["Network"]["DNS"]["Response"] = dns_response

        if len(evidence_md5) > 0 or len(evidence_text) > 0:
            outputs["Evidence"] = {}
            if len(evidence_md5) > 0:
                outputs["Evidence"]["md5"] = evidence_md5
            if len(evidence_text) > 0:
                outputs["Evidence"]["Text"] = evidence_text

        ec = {}
        ec["DBotScore"] = {
            'Indicator': file_hash,
            'Type': 'hash',
            'Vendor': 'WildFire',
            'Score': 0
        }
        ec["WildFire.Report(val.SHA256 === obj.SHA256)"] = outputs

        if file_info:
            if file_info["malware"] == 'yes':
                ec["DBotScore"]["Score"] = 3
                ec[outputPaths['file']] = {
                    'Type': file_info["filetype"],
                    'MD5': file_info["md5"],
                    'SHA1': file_info["sha1"],
                    'SHA256': file_info["sha256"],
                    'Size': file_info["size"],
                    'Name': file_info["filename"] if 'filename' in file_info else None,
                    'Malicious': {'Vendor': 'WildFire'}
                }
            else:
                ec["DBotScore"]["Score"] = 1
        if format_ == 'pdf':
            get_report_uri = URL + URL_DICT["report"]
            params = {
                'apikey': TOKEN,
                'format': 'pdf',
                'hash': file_hash
            }

            res_pdf = http_request(get_report_uri, 'POST', headers=DEFAULT_HEADERS, params=params)

            file_name = 'wildfire_report_' + file_hash + '.pdf'
            file_type = entryTypes['entryInfoFile']
            result = fileResult(file_name, res_pdf.content,
                                file_type)  # will be saved under 'InfoFile' in the context.
            result['EntryContext'] = ec

            demisto.results(result)

        else:
            md = tableToMarkdown('WildFire Report', prettify_report_entry(file_info))
            if verbose:
                for report in reports:
                    if isinstance(report, dict):
                        md += tableToMarkdown('Report ', report, list(report), removeNull=True)

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': reports,
                'ContentsFormat': formats['json'],
                'HumanReadable': md,
                'ReadableContentsFormat': formats['markdown'],
                'EntryContext': ec
            })


    @logger
    def wildfire_get_report(file_hash):
        get_report_uri = URL + URL_DICT["report"]
        params = {
            'apikey': TOKEN,
            'format': 'xml',
            'hash': file_hash
        }

        json_res = http_request(get_report_uri, 'POST', headers=DEFAULT_HEADERS, params=params)

        if not json_res:
            demisto.results('Report not found')
            sys.exit(0)

        task_info = json_res["wildfire"].get('task_info', None)
        reports = task_info.get('report', None) if task_info else None
        file_info = json_res["wildfire"].get('file_info', None)

        if not reports or not file_info:
            demisto.results('The sample is still being analyzed. Please wait to download the report')
            sys.exit(0)
        return file_hash, reports, file_info


    def wildfire_get_report_command():
        if 'sha256' in demisto.args():
            sha256 = demisto.args().get('sha256', None)
        elif 'hash' in demisto.args():
            sha256 = demisto.args().get('hash', None)
        else:
            sha256 = None
        md5 = demisto.args().get('md5', None)
        inputs = hash_args_handler(sha256, md5)

        verbose = demisto.args().get('verbose', 'false').lower() == 'true'
        format_ = demisto.args().get('format', 'xml')
        for element in inputs:
            file_hash, report, file_info = wildfire_get_report(element)
            create_report(file_hash, report, file_info, format_, verbose)


    def wildfire_file_command():
        inputs = file_args_handler(demisto.args().get('file'), demisto.args().get('md5'), demisto.args().get('sha256'))
        for element in inputs:
            if sha1Regex.match(element):
                demisto.results({
                    'Type': 11,
                    'Contents': 'WildFire file hash reputation supports only MD5, SHA256 hashes',
                    'ContentsFormat': formats['text']
                })
            else:
                file_hash, report, file_info = wildfire_get_report(element)
                create_report(file_hash, report, file_info, 'xml', False)


    def wildfire_get_sample(file_hash):
        get_report_uri = URL + URL_DICT["sample"]
        params = {
            'apikey': TOKEN,
            'hash': file_hash
        }

        result = http_request(get_report_uri, 'POST', headers=DEFAULT_HEADERS, params=params)
        return result


    def wildfire_get_sample_command():
        if 'sha256' or 'hash' in demisto.args():
            sha256 = demisto.args().get('sha256', None)
        else:
            sha256 = None
        md5 = demisto.args().get('md5', None)
        inputs = hash_args_handler(sha256, md5)

        for element in inputs:
            result = wildfire_get_sample(element)

            headers_string = str(result.headers)
            file_name = headers_string.split("filename=", 1)[1]

            # will be saved under 'File' in the context, can be farther investigated.
            file_entry = fileResult(file_name, result.content)

            demisto.results(file_entry)


    ''' EXECUTION '''


    def main():
        LOG('command is %s' % (demisto.command(),))

        try:
            # Remove proxy if not set to true in params
            handle_proxy()

            if demisto.command() == 'test-module':
                test_module()

            elif demisto.command() == 'wildfire-upload':
                wildfire_upload_file_command()

            elif demisto.command() in ['wildfire-upload-file-remote', 'wildfire-upload-file-url']:
                wildfire_upload_file_url_command()

            elif demisto.command() == 'wildfire-upload-url':
                wildfire_upload_url_command()

            elif demisto.command() == 'wildfire-report':
                wildfire_get_report_command()

            elif demisto.command() == 'file':
                wildfire_file_command()

            elif demisto.command() == 'wildfire-get-sample':
                wildfire_get_sample_command()

            elif demisto.command() == 'wildfire-get-verdict':
                wildfire_get_verdict_command()

            elif demisto.command() == 'wildfire-get-verdicts':
                wildfire_get_verdicts_command()

        except Exception as ex:
            return_error(str(ex))

        finally:
            LOG.print_log()


    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  subtype: python3
  type: python
system: true
