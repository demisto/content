category: Network Security
commonfields:
  id: Google Key Management Service
  version: -1
configuration:
- defaultvalue: ""
  display: User's Service Account JSON
  name: service_account
  required: true
  type: 4
- defaultvalue: ""
  display: Project in Google Cloud KMS
  name: project
  required: true
  type: 0
- defaultvalue: global
  display: Default Location
  name: location
  options:
  - global
  - asia-east1
  - asia-east2
  - asia-northeast1
  - asia-northeast2
  - asia-south1
  - asia-southeast1
  - australia-southeast1
  - europe-north1
  - europe-west1
  - europe-west2
  - europe-west3
  - europe-west4
  - europe-west6
  - northamerica-northeast1
  - us-central1
  - us-east1
  - us-east4
  - us-west1
  - us-west2
  - southamerica-east1
  - eur4
  - nam4
  - asia
  - europe
  - us
  required: true
  type: 15
- defaultvalue: ""
  display: Default Key Ring
  name: key_ring
  required: false
  type: 0
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Use the Google Key Management Service API for CryptoKey management and
  encrypt/decrypt functionality.
detaileddescription: "**Google Key Management Service**\n\nThis integration allows
  you to:\n\n* Get CryptoKey information.\n* Create a new CryptoKey.\n* Encrypt and
  Decrypt using Google KMS keys from plain text and base64 text.\n* Update an existing
  CryptoKey.\n* Destroy/Restore/Enable/Disable a CryptoKeyVersion of your choice.
  \n\nGet a Service Account and select a Role:\n1) Go to: https://console.developers.google.com.\n2)
  Select your project.\n3) From the side-menu go to **IAM & admin** > **Service accounts**
  > **CREATE SERVICE ACCOUNT**.\n5) Type an account name and description and click
  **CREATE**.\n6) From  the drop down list Select a role from one of the following
  to in the integration:\n    - **Project-Owner** and **Project-Editor** - Grants
  you total access to the Project and allows you to use all the commands in the integration.\n
  \   - **Cloud KMS Admin** - Grants you the option to create and edit CryptoKeys
  and CryptoKeyVersions.\n    - **Cloud KMS Encrypter/Decrypter** - Lets you use the
  encrypt and decrypt commands.\n    - **Cloud KMS Encrypter** - lets you use only
  the encrypt command.\n    - **Cloud KMS Decrypter** - lets you use only the decrypt
  command.\n7) Click **CONTINUE** and then click **CREATE KEY**.\n8) Select **JSON**
  and click **CREATE**.\n The .json file downloads.\n9) Enter the file contents to
  the Service Account box in the integration.\n"
display: Google Key Management Service
image: data:image/png;base64,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
name: Google Key Management Service
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the created crypto-key. It must be unique within a KeyRing
        and match the regular expression [a-zA-Z0-9_-]{1,63}.
      name: crypto_key
      required: true
    - description: Labels with user-defined metadata.
      isArray: true
      name: labels
    - description: "Date of the next scheduled rotation time. The Key Management Service
        automatically creates a new version of this CryptoKey and \nmarks the new
        version as primary at the next rotation time.\nKey rotations performed manually
        through cryptoKeyVersions.create and cryptoKeys.updatePrimaryVersion do not
        affect nextRotationTime.\n\nKeys with purpose ENCRYPT_DECRYPT support automatic
        rotation. For other keys, this field must be omitted.\n\nA timestamp or a
        date in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds. For example,
        \"2014-10-02T15:01:23.045123456Z\".\n\nIf left empty, it is set in 90 days."
      name: next_rotation_time
    - description: The statement that was generated and signed by the HSM at the key
        creation time. Use this statement to verify attributes of the key as stored
        on the HSM, independently of Google. Only provided for key versions with protectionLevel
        HSM.
      isArray: true
      name: attestation
    - auto: PREDEFINED
      defaultValue: ENABLED
      description: 'The state of a CryptoKeyVersion, indicating if it can be used.
        Can be: "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED, "PENDING_GENERATION", "ENABLED",
        "DISABLED", "DESTROYED",  "DESTROY_SCHEDULED" , "PENDING_IMPORT", " IMPORT_FAILED".'
      name: state
      predefined:
      - CRYPTO_KEY_VERSION_STATE_UNSPECIFIED
      - PENDING_GENERATION
      - ENABLED
      - DISABLED
      - DESTROYED
      - DESTROY_SCHEDULED
      - PENDING_IMPORT
      - IMPORT_FAILED
    - auto: PREDEFINED
      defaultValue: ENCRYPT_DECRYPT
      description: 'The cryptographic capabilities of a CryptoKey. A given key can
        only be used for the operations allowed by its purpose. Can be: "CRYPTO_KEY_PURPOSE_UNSPECIFIED",
        "ENCRYPT_DECRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_DECRYPT".'
      name: purpose
      predefined:
      - CRYPTO_KEY_PURPOSE_UNSPECIFIED
      - ENCRYPT_DECRYPT
      - ASYMMETRIC_SIGN
      - ASYMMETRIC_DECRYPT
      required: true
    - defaultValue: "7776000"
      description: The time between when new key versions are generated automatically.
        Must be between 24 hours and 876,000 hours. Keys with ENCRYPT_DECRYPT purpose
        support automatic rotation. For other keys, this field must be omitted. A
        duration in seconds.
      name: rotation_period
      required: true
    - auto: PREDEFINED
      defaultValue: GOOGLE_SYMMETRIC_ENCRYPTION
      description: Algorithm to use when creating a CryptoKeyVersion based on this
        template.
      name: algorithm
      predefined:
      - CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED
      - GOOGLE_SYMMETRIC_ENCRYPTION
      - RSA_SIGN_PSS_2048_SHA256
      - RSA_SIGN_PSS_3072_SHA256
      - RSA_SIGN_PSS_4096_SHA256
      - RSA_SIGN_PSS_4096_SHA512
      - RSA_SIGN_PKCS1_2048_SHA256
      - RSA_SIGN_PKCS1_3072_SHA256
      - RSA_SIGN_PKCS1_4096_SHA256
      - RSA_SIGN_PKCS1_4096_SHA512
      - RSA_DECRYPT_OAEP_2048_SHA256
      - RSA_DECRYPT_OAEP_3072_SHA256
      - RSA_DECRYPT_OAEP_4096_SHA256
      - RSA_DECRYPT_OAEP_4096_SHA512
      - EC_SIGN_P256_SHA256
      - EC_SIGN_P384_SHA384
    - auto: PREDEFINED
      defaultValue: SOFTWARE
      description: 'Protections levels for cryptographic operations when creating
        a CryptoKeyVersion. Can be: Can be: "PROECTECTION_LEVEL_UNSPECIFIED", "SOFTWARE",
        "HSM". Default is "SOFTWARE".'
      name: protection_level
      predefined:
      - PROTECTION_LEVEL_UNSPECIFIED
      - SOFTWARE
      - HSM
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to create a CryptoKey without any CryptoKeyVersions. You
        have to create the CryptoKeyVersion to use this key.
      name: skip_initial_version_creation
      predefined:
      - "true"
      - "false"
    description: Creates a new CryptoKey within a KeyRing.
    name: google-kms-create-key
    outputs:
    - contextPath: GoogleKMS.CryptoKey.Name
      description: The resource name for this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Purpose
      description: The immutable purpose of this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.CreationTime
      description: The time when this CryptoKey was created.
      type: String
    - contextPath: GoogleKMS.CryptoKey.NextRotationTime
      description: "The date when the next scheduled rotation is due to run. At nextRotationTime,
        the Key Management Service automatically \ncreates a new version of this CryptoKey
        and marks the new version as primary."
      type: Date
    - contextPath: GoogleKMS.CryptoKey.RotationPeriod
      description: The period for which the nextRotationTime is advanced, when the
        service automatically rotates a key.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Labels
      description: Labels with user-defined metadata.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.ProtectionLevel
      description: The protection level describing how cryptographic operations are
        performed with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.Algorithm
      description: The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Name
      description: The resource name for this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.State
      description: The current state of the CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.CreationTime
      description: The time when this CryptoKeyVersion was created.
      type: Date
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.ProtectionLevel
      description: The ProtectionLevel describing how cryptographic operations are
        performed with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Algorithm
      description: The algorithm in use in the primary CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.GenerateTime
      description: The time this CryptoKeyVersion's key material was generated.
      type: Date
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical region where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to use.
      name: crypto_key
      required: true
    - description: The ciphertext to decrypt to simple plain text.
      name: simple_ciphertext
    - description: "A base64-encoded string passed to Cloud KMS as part of an encrypt
        or decrypt request. \nThe optional data that must match the data originally
        supplied in the EncryptRequest.additional_authenticated_data.        "
      name: additional_authenticated_data
    - description: The ciphertext to decrypt to base64 plain text.
      name: base64_ciphertext
    - description: The entry ID for the file to decrypt.
      name: entry_id
    description: Decrypts data that was protected by Encrypt.
    name: google-kms-symmetric-decrypt
    outputs:
    - contextPath: GoogleKMS.SymmetricDecrypt.CryptoKey
      description: The CryptoKey in use.
      type: String
    - contextPath: GoogleKMS.SymmetricDecrypt.IsBase64
      description: Whether the original plain text is in base64.
      type: Boolean
    - contextPath: GoogleKMS.SymmetricDecrypt.Plaintext
      description: The decrypted plaintext.
      type: String
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For example, https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: "A grouping of keys for organizational purposes. \nKeyword 'default'
        uses the default KeyRing."
      name: key_ring
      required: true
    - description: The ID for the crypto-key to use.
      name: crypto_key
      required: true
    - description: Simple plain text to encrypt. Must be no larger than 64KiB.
      name: simple_plaintext
    - description: "A base64-encoded string passed to Cloud KMS as part of an encrypt
        or decrypt request. Must also be provided during decryption through DecryptRequest.additional_authenticated_data.\nThe
        maximum size depends on the key version's protection level. \nFor SOFTWARE
        keys, the AAD must be no larger than 64KiB. For HSM keys, the combined length
        of the plain text and additionalAuthenticatedData fields must be no larger
        than 8KiB.        "
      name: additional_authenticated_data
    - description: The Base64 plain text to encrypt.
      name: base64_plaintext
    - description: The entry ID for the file to encrypt.
      name: entry_id
    description: Encrypts data, so it can only be recovered by a call to Decrypt.
    name: google-kms-symmetric-encrypt
    outputs:
    - contextPath: GoogleKMS.SymmetricEncrypt.CryptoKey
      description: The CryptoKey used.
      type: String
    - contextPath: GoogleKMS.SymmetricEncrypt.IsBase64
      description: Whether the original plain text is in base 64.
      type: Boolean
    - contextPath: GoogleKMS.SymmetricEncrypt.Ciphertext
      description: The encrypted ciphertext.
      type: String
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For example, https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' sets the location to the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the fetched crypto-key.
      name: crypto_key
      required: true
    description: Returns metadata for a given CryptoKey, and its primary CryptoKeyVersion.
    name: google-kms-get-key
    outputs:
    - contextPath: GoogleKMS.CryptoKey.Name
      description: The resource name for this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Purpose
      description: The immutable purpose of this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.CreationTime
      description: The time at which this CryptoKey was created.
      type: Date
    - contextPath: GoogleKMS.CryptoKey.NextRotationTime
      description: "The date when the next scheduled rotation is due to run. At nextRotationTime,
        the Key Management Service automatically \ncreates a new version of this CryptoKey
        and marks the new version as primary."
      type: Date
    - contextPath: GoogleKMS.CryptoKey.RotationPeriod
      description: The period for which the nextRotationTime is advanced, when the
        service automatically rotates a key. hours.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Labels
      description: Labels with user-defined metadata.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.ProtectionLevel
      description: The ProtectionLevel describing how cryptographic operations are
        performed with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.Algorithm
      description: The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Name
      description: The resource name for this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.State
      description: The current state of the CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.CreationTime
      description: The time at which this CryptoKeyVersion was created.
      type: Date
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.ProtectionLevel
      description: The ProtectionLevel describing how cryptographic operations are
        performed with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Algorithm
      description: The algorithm used in the primary CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.GenerateTime
      description: The time this CryptoKeyVersion's key material was generated.
      type: Date
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: |-
        The geographical regions where requests to Cloud KMS for a given resource are handled,
        and where the corresponding cryptographic keys are stored. For more information, see https://cloud.google.com/kms/docs/locations.
        Keyword 'default' uses the default location.
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the updated crypto-key.
      name: crypto_key
      required: true
    - description: "The date when the next scheduled rotation is due to run. At nextRotationTime,
        the Key Management Service automatically \ncreates a new version of this CryptoKey
        and marks the new version as primary.\nKey rotations performed manually via
        cryptoKeyVersions.create and cryptoKeys.updatePrimaryVersion do not affect
        nextRotationTime.\n\nKeys with purpose ENCRYPT_DECRYPT, support automatic
        rotation. For other keys, this field must be omitted.\n\nA timestamp or a
        date in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds. For example,
        \"2014-10-02T15:01:23.045123456Z\"."
      name: next_rotation_time
    - description: Statement that was generated and signed by the HSM at key creation
        time. Use this statement to verify attributes of the key as stored on the
        HSM, independently of Google. Only provided for key versions with protectionLevel
        HSM.
      isArray: true
      name: attestation
    - auto: PREDEFINED
      description: 'The state of a CryptoKeyVersion, indicating if it can be used.
        Can be: "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED, "PENDING_GENERATION", "ENABLED",
        "DISABLED", "DESTROYED",  "DESTROY_SCHEDULED" , "PENDING_IMPORT", " IMPORT_FAILED".'
      name: state
      predefined:
      - CRYPTO_KEY_VERSION_STATE_UNSPECIFIED
      - PENDING_GENERATION
      - ENABLED
      - DISABLED
      - DESTROYED
      - DESTROY_SCHEDULED
      - PENDING_IMPORT
      - IMPORT_FAILED
    - auto: PREDEFINED
      description: 'CryptoKeyPurpose describes the cryptographic capabilities of a
        CryptoKey. A given key can only be used for the operations allowed by its
        purpose. Can be: "CRYPTO_KEY_PURPOSE_UNSPECIFIED", "ENCRYPT_DECRYPT", "ASYMMETRIC_SIGN",
        "ASYMMETRIC_DECRYPT".'
      name: purpose
      predefined:
      - CRYPTO_KEY_PURPOSE_UNSPECIFIED
      - ENCRYPT_DECRYPT
      - ASYMMETRIC_SIGN
      - ASYMMETRIC_DECRYPT
    - description: Time between when new key versions are generated automatically.
        Must between 24 hours and 876,000 hours. If rotation_period is set, next_rotation_time
        must also be set.  Keys with purpose ENCRYPT_DECRYPT support automatic rotation.
        For other keys, this field must be omitted. A duration in seconds.
      name: rotation_period
    - auto: PREDEFINED
      description: Algorithm to use when creating a CryptoKeyVersion based on this
        template.
      name: algorithm
      predefined:
      - CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED
      - GOOGLE_SYMMETRIC_ENCRYPTION
      - RSA_SIGN_PSS_2048_SHA256
      - RSA_SIGN_PSS_3072_SHA256
      - RSA_SIGN_PSS_4096_SHA256
      - RSA_SIGN_PSS_4096_SHA512
      - RSA_SIGN_PKCS1_2048_SHA256
      - RSA_SIGN_PKCS1_3072_SHA256
      - RSA_SIGN_PKCS1_4096_SHA256
      - RSA_SIGN_PKCS1_4096_SHA512
      - RSA_DECRYPT_OAEP_2048_SHA256
      - RSA_DECRYPT_OAEP_3072_SHA256
      - RSA_DECRYPT_OAEP_4096_SHA256
      - RSA_DECRYPT_OAEP_4096_SHA512
      - EC_SIGN_P256_SHA256
      - EC_SIGN_P384_SHA384
    - auto: PREDEFINED
      description: 'The protection_level to use when creating a CryptoKeyVersion based
        on this template. Can be: "PROTECTION_LEVEL_UNSPECIFIED", "SOFTWARE", "HSM".'
      name: protection_level
      predefined:
      - PROTECTION_LEVEL_UNSPECIFIED
      - SOFTWARE
      - HSM
    - description: Labels with user-defined metadata.
      name: labels
    description: Updates a CryptoKey.
    name: google-kms-update-key
    outputs:
    - contextPath: GoogleKMS.CryptoKey.Name
      description: The resource name for this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Purpose
      description: The immutable purpose of this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.CreationTime
      description: The time at which this CryptoKey was created.
      type: String
    - contextPath: GoogleKMS.CryptoKey.NextRotationTime
      description: "The date when the next scheduled rotation is due to run. At nextRotationTime,
        the Key Management Service automatically \ncreates a new version of this CryptoKey
        and marks the new version as primary."
      type: Date
    - contextPath: GoogleKMS.CryptoKey.RotationPeriod
      description: The period for which the nextRotationTime is advanced, when the
        service automatically rotates a key.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Labels
      description: Labels with user-defined metadata.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.ProtectionLevel
      description: The ProtectionLevel describing how crypto operations are performed
        with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.Algorithm
      description: The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Name
      description: The resource name for this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.State
      description: The current state of the CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.CreationTime
      description: The time at which this CryptoKeyVersion was created.
      type: Date
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.ProtectionLevel
      description: The ProtectionLevel describing how cryptographic operations are
        performed with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Algorithm
      description: The algorithm in use in the primary CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.GenerateTime
      description: The time this CryptoKeyVersion's key material was generated.
      type: Date
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: |-
        The geographical regions where requests to Cloud KMS for a given resource are handled,
        and where the corresponding cryptographic keys are stored. For example, see https://cloud.google.com/kms/docs/locations.
        Keyword 'default' uses the default location.
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to destroy.
      name: crypto_key
      required: true
    - defaultValue: default
      description: The CryptoKeyVersion ID to destroy. Use keyword 'default' to use
        the primary CryptoKeyVersion of the given CryptoKey.
      name: crypto_key_version
      required: true
    description: Schedules a CryptoKeyVersion for destruction.
    name: google-kms-destroy-key
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: |-
        The geographical regions where requests to Cloud KMS for a given resource are handled,
        and where the corresponding cryptographic keys are stored. For example, see https://cloud.google.com/kms/docs/locations.
        Keyword 'default' uses the default location.
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to restore.
      name: crypto_key
      required: true
    - defaultValue: default
      description: The CryptoKeyVersion ID to restore. Use keyword 'default' to use
        the primary CryptoKeyVersion of the given CryptoKey.
      name: crypto_key_version
      required: true
    description: Restores a CryptoKeyVersion in the DESTROY_SCHEDULED state.
    name: google-kms-restore-key
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: |-
        The geographical regions where requests to Cloud KMS for a given resource are handled,
        and where the corresponding cryptographic keys are stored. For more information, see https://cloud.google.com/kms/docs/locations.
        Keyword 'default' uses the default location.
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to disable.
      name: crypto_key
      required: true
    - defaultValue: default
      description: The CryptoKeyVersion ID to disable. Use keyword 'default' to use
        the primary CryptoKeyVersion of the given CryptoKey.
      name: crypto_key_version
      required: true
    description: Disables a CryptoKeyVersion of a given CryptoKey.
    name: google-kms-disable-key
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to enable
      name: crypto_key
      required: true
    - defaultValue: default
      description: The CryptoKeyVersion ID to enable. Use keyword 'default' to use
        the primary CryptoKeyVersion of the given CryptoKey.
      name: crypto_key_version
      required: true
    description: Enables a CryptoKeyVersion of a given CryptoKey.
    name: google-kms-enable-key
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - auto: PREDEFINED
      description: 'Shows only keys with this primary CryptoKeyVersion state. Leave
        empty to show all. Can be: "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED", "PENDING_GENERATION",
        "ENABLED", "DISABLED", "DESTROYED", "DESTROY_SCHEDULED", "PENDING_IMPORT",
        "IMPORT_FAILED".'
      name: key_state
      predefined:
      - CRYPTO_KEY_VERSION_STATE_UNSPECIFIED
      - PENDING_GENERATION
      - ENABLED
      - DISABLED
      - DESTROYED
      - DESTROY_SCHEDULED
      - PENDING_IMPORT
      - IMPORT_FAILED
    description: Lists all keys in key ring.
    name: google-kms-list-keys
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the location to the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to use.
      name: crypto_key
      required: true
    - description: The CryptoKeyVersion to use.
      name: crypto_key_version
      required: true
    - description: Simple plain text to encrypt. Must be no larger than 64KiB.
      name: simple_plaintext
    - description: Base64 plain text to encrypt.
      name: base64_plaintext
    - description: The entry ID of the file to encrypt.
      name: entry_id
    description: Encrypts data using a asymmetric CryptoKey
    name: google-kms-asymmetric-encrypt
    outputs:
    - contextPath: GoogleKMS.AsymmetricEncrypt.CryptoKey
      description: The CryptoKey used
      type: String
    - contextPath: GoogleKMS.AsymmetricEncrypt.IsBase64
      description: Is the original plaintext in base 64
      type: Boolean
    - contextPath: GoogleKMS.AsymmetricEncrypt.Ciphertext
      description: The encrypted ciphertext
      type: String
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: |-
        The geographical regions where requests to Cloud KMS for a given resource are handled, and where the corresponding cryptographic keys are stored. For more information, see https://cloud.google.com/kms/docs/locations
        Keyword 'default' uses the default location.
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to use.
      name: crypto_key
      required: true
    - description: The CryptoKeyVersion to use.
      name: crypto_key_version
      required: true
    - description: Ciphertext to decrypt to simple plain text.
      name: simple_ciphertext
    - description: Ciphertext to decrypt to base64 plain text.
      name: base64_ciphertext
    - description: The entry ID of the file to decrypt.
      name: entry_id
    description: Decrypts data using an asymmetric CryptoKey.
    name: google-kms-asymmetric-decrypt
    outputs:
    - contextPath: GoogleKMS.AsymmetricDecrypt.CryptoKey
      description: The CryptoKey in use.
      type: String
    - contextPath: GoogleKMS.AsymmetricDecrypt.IsBase64
      description: Whether the original plain text is in base64.
      type: Boolean
    - contextPath: GoogleKMS.AsymmetricDecrypt.Plaintext
      description: The decrypted plain text.
      type: String
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - auto: PREDEFINED
      defaultValue: "no"
      description: Returns all KeyRings from all locations. Default is no.
      name: all
      predefined:
      - "yes"
      - "no"
    description: Lists all KeyRings in a given location.
    name: google-kms-list-key-rings
    outputs:
    - contextPath: GoogleKMS.KeyRing.Name
      description: The name of the KeyRing.
      type: String
    - contextPath: GoogleKMS.KeyRing.CreateTime
      description: The creation time of the KeyRing.
      type: Date
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - auto: PREDEFINED
      defaultValue: "no"
      description: Whether to return all CryptoKeys from all KeyRings across all locations.
      name: all
      predefined:
      - "yes"
      - "no"
    - auto: PREDEFINED
      description: Shows only keys with this primary CryptoKeyVersion state. Leave
        empty to show all.
      name: key_state
      predefined:
      - CRYPTO_KEY_VERSION_STATE_UNSPECIFIED
      - PENDING_GENERATION
      - ENABLED
      - DISABLED
      - DESTROYED
      - DESTROY_SCHEDULED
      - PENDING_IMPORT
      - IMPORT_FAILED
    description: Lists all CryptoKeys across all KeyRings in a given location.
    name: google-kms-list-all-keys
    outputs:
    - contextPath: GoogleKMS.CryptoKey.Name
      description: The resource name for this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Purpose
      description: The immutable purpose of this CryptoKey.
      type: String
    - contextPath: GoogleKMS.CryptoKey.CreationTime
      description: The time at which this CryptoKey was created.
      type: Date
    - contextPath: GoogleKMS.CryptoKey.NextRotationTime
      description: |-
        The date when the next scheduled rotation is due to run. At nextRotationTime, the Key Management Service automatically
        creates a new version of this CryptoKey and
        marks the new version as primary.
      type: Date
    - contextPath: GoogleKMS.CryptoKey.RotationPeriod
      description: The period for which the nextRotationTime is advanced, when the
        service automatically rotates a key.
      type: String
    - contextPath: GoogleKMS.CryptoKey.Labels
      description: Labels with user-defined metadata.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.ProtectionLevel
      description: The ProtectionLevel describing how crypto operations are performed
        with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.VersionTemplate.Algorithm
      description: The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Name
      description: The resource name for this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.State
      description: The current state of the CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.CreationTime
      description: The time at which this CryptoKeyVersion was created.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.ProtectionLevel
      description: The ProtectionLevel describing how crypto operations are performed
        with this CryptoKeyVersion.
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.Algorithm
      description: The algorithm in use in the primary CryptoKeyVersion
      type: String
    - contextPath: GoogleKMS.CryptoKey.PrimaryCryptoKeyVersion.GenerateTime
      description: The time this CryptoKeyVersion's key material was generated.
      type: Date
  - arguments:
    - auto: PREDEFINED
      defaultValue: default
      description: "The geographical regions where requests to Cloud KMS for a given
        resource are handled, \nand where the corresponding cryptographic keys are
        stored. For more information, see https://cloud.google.com/kms/docs/locations.\nKeyword
        'default' uses the default location."
      name: location
      predefined:
      - default
      - global
      - asia-east1
      - asia-east2
      - asia-northeast1
      - asia-northeast2
      - asia-south1
      - asia-southeast1
      - australia-southeast1
      - europe-north1
      - europe-west1
      - europe-west2
      - europe-west3
      - europe-west4
      - europe-west6
      - northamerica-northeast1
      - us-central1
      - us-east1
      - us-east4
      - us-west1
      - us-west2
      - southamerica-east1
      - eur4
      - nam4
      - asia
      - europe
      - us
      required: true
    - defaultValue: default
      description: |-
        A grouping of keys for organizational purposes.
        Keyword 'default' uses the default KeyRing.
      name: key_ring
      required: true
    - description: The ID for the crypto-key to use.
      name: crypto_key
      required: true
    - description: The CryptoKeyVersion to use.
      name: crypto_key_version
      required: true
    description: Returns the public key from a given CryptoKey.
    name: google-kms-get-public-key
    outputs:
    - contextPath: GoogleKMS.PublicKey.CryptoKey
      description: The CryptoKey to which the public key is connected.
      type: String
    - contextPath: GoogleKMS.PublicKey.PEM
      description: The PEM of the public key.
      type: String
    - contextPath: GoogleKMS.PublicKey.Algorithm
      description: The algorithm used in the CryptoKey
      type: String
  dockerimage: demisto/google-kms:1.0.0.2689
  runonce: false
  script: |2-




    '''IMPORTS'''
    from google.cloud import kms_v1
    from google.cloud.kms_v1 import enums
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from json import JSONDecodeError
    import base64
    from typing import Any, Dict, Tuple, List

    """
    For further information about the API used in the integration see:

    1) Google KMS API Client libraries information:
        https://cloud.google.com/kms/docs/reference/libraries

    2) Git resource with some API use examples:
        https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/kms/api-client

    """

    INTEGRATION_NAME = 'Google Key Management System'
    # lowercase with `-` dividers
    INTEGRATION_COMMAND_NAME = 'google-kms'
    # No dividers
    INTEGRATION_CONTEXT_NAME = 'GoogleKMS'

    DEMISTO_DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S'
    RFC3339_DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'


    class Client:
        def __init__(self, params: Dict[str, Any]):
            self.project = params.get('project')
            self.location = params.get('location')
            self.key_ring = params.get('key_ring')
            self.service_account = params.get('service_account')

            handle_proxy()
            # Creates an API client for the KMS API.
            try:
                self.kms_client = self._init_kms_client()

            except JSONDecodeError:
                raise Exception("Service Account json has missing details. You need to re-create the json file.")

        def _init_kms_client(self):
            """Creates the Python API client for Google Cloud KMS using service account credentials."""
            dictionary_test = json.loads(str(self.service_account))
            if not isinstance(dictionary_test, dict):
                raise Exception("Service Account json is not formatted well. You need to change the json file.")

            credentials_file_name = demisto.uniqueFile() + '.json'
            credentials_file_path = os.path.join(os.getcwd(), credentials_file_name)

            with open(credentials_file_path, 'w') as creds_file:
                json_object = json.loads(str(self.service_account))
                json.dump(json_object, creds_file)

            return kms_v1.KeyManagementServiceClient.from_service_account_json(credentials_file_path)


    """HELPER FUNCTIONS"""


    def arg_dict_creator(string: Any):
        """Creates a Dict from a CSV string.

        Args:
            string(str): CSV string - formatted as 'field1:value1,field2:value2'.

        Returns:
            Dict from string representation.
        """
        if not string:
            return None

        split_string = string.split(',')
        arg_dict = {}
        for section in split_string:
            section_key, section_value = section.split(':', 1)
            arg_dict[section_key] = section_value

        return arg_dict


    def clear_label_commas(labels: Any):
        """When extracted from the response - the labels return with an added commas and spaces
        This function removes these commas.

        Args:
            labels(Dict): a dictionary of labels as returned from the response.

        Returns:
            the label dictionary without the commas and spaces.
        """
        if not labels:
            return None

        cleared_labels = {}  # type:Dict
        for label in labels.keys():
            # A label key can come in the form of: 'info' or _'info' (with an extra space)
            # The following check is whether to drop the first 2 characters or just one
            if str(label).startswith(' '):
                cleared_label_key = label[2:-1]

            else:
                cleared_label_key = label[1:-1]

            if str(labels[label]).startswith(' '):
                cleared_label_value = labels[label][2:-1]

            else:
                cleared_label_value = labels[label][1:-1]

            cleared_labels[cleared_label_key] = cleared_label_value

        return cleared_labels


    def key_context_creation(res: Any, project_id: str, location_id: str, key_ring_id: str) -> Dict:
        """Creates GoogleKMS.CryptoKey context.

        Args:
            res(Any): `~google.cloud.kms_v1.types.CryptoKey` instance.
            project_id(str): the project id
            location_id(str): the location id
            key_ring_id(str): the KeyRing id

        Returns:
            Dict representing GoogleKMS.CryptoKey context.
        """
        # remove the CryptoKey path and leave only the name
        pre_name = f"projects/{project_id}/locations/{location_id}/keyRings/{key_ring_id}/cryptoKeys/"
        name = str(res.name).replace(pre_name, '')

        # prepare the labels
        labels = str(res.labels)

        if labels != '{}':
            labels = arg_dict_creator(str(labels)[1:-1])
            labels = clear_label_commas(labels)

        else:
            labels = ''

        key_context = {
            'Name': name,
            'Project': project_id,
            'Location': location_id,
            'KeyRing': key_ring_id,
            'Purpose': enums.CryptoKey.CryptoKeyPurpose(res.purpose).name,
            'CreationTime': datetime.fromtimestamp(int(res.create_time.seconds)).strftime(DEMISTO_DATETIME_FORMAT),
            'NextRotationTime': datetime.fromtimestamp(int(res.next_rotation_time.seconds)).strftime(DEMISTO_DATETIME_FORMAT),
            'RotationPeriod': f'{str(res.rotation_period.seconds)}s',
            'Labels': labels,
            'VersionTemplate': {
                'ProtectionLevel': enums.ProtectionLevel(res.version_template.protection_level).name,
                'Algorithm': enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm(res.version_template.algorithm).name,
            }
        }
        # if primary CryptoKeyVersion exists and is returned create context for it.
        # Note: As part of the API - Asymmetric keys do not return primary CryptoKeyVersion info.
        if res.primary and res.primary.name and len(res.primary.name) > 0:
            key_context['PrimaryCryptoKeyVersion'] = {
                'Name': res.primary.name,
                'State': enums.CryptoKeyVersion.CryptoKeyVersionState(res.primary.state).name,
                'CreationTime': datetime.fromtimestamp(int(res.primary.create_time.seconds)).strftime(DEMISTO_DATETIME_FORMAT),
                'ProtectionLevel': enums.ProtectionLevel(res.primary.protection_level).name,
                'Algorithm': enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm(res.primary.algorithm).name,
                'GenerateTime': datetime.fromtimestamp(int(res.primary.generate_time.seconds)).strftime(DEMISTO_DATETIME_FORMAT)
            }

        return key_context


    def crypto_key_to_json(crypto_key: Any) -> Dict:
        """Creates a json dict from `~google.cloud.kms_v1.types.CryptoKey` instance to use as raw response.

        Args:
            crypto_key(Any): `~google.cloud.kms_v1.types.CryptoKey` instance.

        Returns:
            A json Dict containing the raw response.
        """
        # handle labels
        labels = str(crypto_key.labels)
        if labels != '{}':
            labels = arg_dict_creator(str(labels)[1:-1])
            labels = clear_label_commas(labels)

        else:
            labels = ''

        key_json = {
            'name': crypto_key.name,
            'purpose': enums.CryptoKey.CryptoKeyPurpose(crypto_key.purpose).name,
            'create_time': {
                'seconds': crypto_key.create_time.seconds,
                'nanos': crypto_key.create_time.nanos

            },
            'next_rotation_time': {
                'seconds': crypto_key.next_rotation_time.seconds,
                'nanos': crypto_key.next_rotation_time.nanos
            },
            'rotation_period': {
                'seconds': crypto_key.rotation_period.seconds
            },
            'labels': labels,
            'version_template': {
                'protection_level': enums.ProtectionLevel(crypto_key.version_template.protection_level).name,
                'algorithm': enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm(crypto_key.version_template.algorithm).name,
            }
        }

        if crypto_key.primary:
            key_json['primary'] = {
                'name': crypto_key.primary.name,
                'state': enums.CryptoKeyVersion.CryptoKeyVersionState(crypto_key.primary.state).name,
                'create_time': {
                    'seconds': crypto_key.primary.create_time.seconds,
                    'nanos': crypto_key.primary.create_time.nanos
                },
                'protection_level': enums.ProtectionLevel(crypto_key.primary.protection_level).name,
                'algorithm': enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm(crypto_key.primary.algorithm).name,
                'generate_time': {
                    'seconds': crypto_key.primary.generate_time.seconds,
                    'nanos': crypto_key.primary.generate_time.nanos
                }
            }

        return key_json


    def demisto_args_extract(client: Client, args: Dict[str, Any]) -> Tuple[str, str, str, str]:
        """Extracts IDs to use for KMS functions.

        Args:
            args(dict): Demisto arguments.
            client(Client): User Client.

        Returns:
            A tuple containing strings representing the required IDs.
        """
        project_id = client.project

        location_id = args.get('location')
        if location_id == 'default':
            location_id = client.location

        key_ring_id = args.get('key_ring')
        if key_ring_id == 'default':
            key_ring_id = client.key_ring

        crypto_key_id = args.get('crypto_key')
        return str(project_id), str(location_id), str(key_ring_id), str(crypto_key_id)


    def get_update_mask(args: Dict[str, Any]) -> Dict:
        """ Creates the 'updateMask' parameter for the command
        which is a comma separated list of fields to update.

        Args:
            args(dict): Demisto args indicating which field to update.

        Returns:
            A Dict to use as the params for update command.
        """
        update_mask = []
        if args.get('labels') is not None:
            update_mask.append('labels')

        if args.get('next_rotation_time') is not None:
            update_mask.append('next_rotation_time')

        if args.get('purpose') is not None:
            update_mask.append('purpose')

        if args.get('rotation_period') is not None:
            update_mask.append('rotation_period')

        if args.get('attestation') is not None:
            update_mask.append('primary.attestation')

        if args.get('state') is not None:
            update_mask.append('primary.state')

        if args.get('algorithm') is not None:
            update_mask.append('version_template.algorithm')

        if args.get('protection_level') is not None:
            update_mask.append('version_template.protection_level')

        return {
            'paths': update_mask
        }


    def get_update_command_body(args: Dict[str, Any], update_mask: List) -> Dict:
        """Creates update command request body, in accordance with the updateMask.

        Args:
            args(Dict): Demisto arguments containing the updated values.
            update_mask(List): List of fields to update.

        Returns:
            Dict to be used as body for update command
        """
        body = {}  # type:Dict[str,Any]
        if 'labels' in update_mask:
            # Add label dictionary to body
            body['labels'] = arg_dict_creator(args.get('labels'))

        if 'next_rotation_time' in update_mask:
            if str(args.get('next_rotation_time')).isdigit():
                # If next_rotation_time given is a timestamp enter it as is
                body['next_rotation_time'] = {'seconds': int(str(args.get('next_rotation_time')))}

            else:
                # If next_rotation_time is date string, convert it to timestamp
                body['next_rotation_time'] = {'seconds': int(datetime.strptime(str(args.get('next_rotation_time')),
                                                                               RFC3339_DATETIME_FORMAT).timestamp())}

        if 'purpose' in update_mask:
            # Add purpose enum to body
            body['purpose'] = enums.CryptoKey.CryptoKeyPurpose[args.get('purpose')].value

        if 'rotation_period' in update_mask:
            # Add rotation_period to body
            body['rotation_period'] = {'seconds': int(str(args.get('rotation_period')))}

        if 'primary.attestation' in update_mask or 'primary.state' in update_mask:
            # Init the 'primary' sub-dictionary
            body['primary'] = {}

            if 'primary.attestation' in update_mask:
                # Add attestation dict to 'primary' sub-dictionary
                body['primary']['attestation'] = arg_dict_creator(args.get('attestation'))

            if 'primary.state' in update_mask:
                # Add state enum to 'primary' sub-dictionary
                body['primary']['state'] = enums.CryptoKeyVersion.CryptoKeyVersionState[args.get('state')].value

        if 'version_template.algorithm' in update_mask or 'version_template.protection_level' in update_mask:
            # Init the 'version_template' sun-dictionary
            body['version_template'] = {}

            if 'version_template.algorithm' in update_mask:
                # Add algorithm enum to 'version_template' sun-dictionary
                val = enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm[args.get('algorithm')].value
                body['version_template']['algorithm'] = val

            if 'version_template.protection_level' in update_mask:
                # Add protection_level to 'version_template' sun-dictionary
                val = enums.ProtectionLevel[args.get('protection_level')].value
                body['version_template']['protection_level'] = val

        return body


    def get_primary_key_version(project_id: str, location_id: str, key_ring_id: str, crypto_key_id: str,
                                client: Client) -> str:
        """ Return primary CryptoKeyVersion of a given CryptoKey.

        Args:
            project_id(str): Project of the CryptoKey.
            location_id(str): Location the CryptoKey is assigned to.
            key_ring_id(str): Key Ring in which the CryptoKey exists.
            crypto_key_id(str): The CryptoKey id.
            client(Client): User's Client.

        Returns:
            A string with the full path to the primary CryptoKeyVersion
        """
        # The resource name of the CryptoKey.
        crypto_key_name = client.kms_client.crypto_key_path(project_id, location_id, key_ring_id, crypto_key_id)

        # Get the CryptoKey and extract it's primary version path.
        crypto_key = client.kms_client.get_crypto_key(crypto_key_name)
        if crypto_key.primary.name is None:
            raise Exception(f"CryptoKey {crypto_key_name} has no primary CryptoKeyVersion")

        return str(crypto_key.primary.name)


    def key_ring_context_and_json_creation(key_ring: Any) -> Tuple[Dict, Dict]:
        key_ring_context = {
            'Name': key_ring.name,
            'CreateTime': datetime.fromtimestamp(int(key_ring.create_time.seconds)).strftime(DEMISTO_DATETIME_FORMAT)
        }

        key_ring_json = {
            'name': key_ring.name,
            'create_time': {
                'seconds': key_ring.create_time.seconds,
                'nanos': key_ring.create_time.nanos
            }
        }

        return key_ring_context, key_ring_json


    """GENERAL FUNCTIONS"""


    def create_crypto_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Dict, Dict]:
        """Create a new CryptoKey.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)

        # The resource name of the KeyRing associated with the CryptoKey.
        key_ring_name = client.kms_client.key_ring_path(project_id, location_id, key_ring_id)

        if args.get('next_rotation_time'):
            # change next_rotation time from date to timestamp if needed.
            if not str(args.get('next_rotation_time')).isdigit():
                next_rotation_time = {
                    'seconds': int(datetime.strptime(str(args.get('next_rotation_time')), RFC3339_DATETIME_FORMAT).timestamp())
                }

            else:
                next_rotation_time = {
                    'seconds': int(str(args.get('next_rotation_time')))
                }

        else:
            # if not next rotation time given - set it to 90 days from now (default by Google)
            next_rotation_time = {
                'seconds': int((datetime.now() + timedelta(days=90)).timestamp())
            }

        # Create the CryptoKey object template
        crypto_key = {
            'purpose': enums.CryptoKey.CryptoKeyPurpose[args.get('purpose')].value,
            'next_rotation_time': next_rotation_time,
            'labels': arg_dict_creator(args.get('labels')),
            'rotation_period': {
                'seconds': int(str(args.get('rotation_period')))
            },
        }

        # Additional info in case CryptoKeyVersion is created
        if not args.get('skip_initial_version_creation') == 'true':
            crypto_key['primary'] = {
                'state': enums.CryptoKeyVersion.CryptoKeyVersionState[args.get('state')].value,
                'attestation': arg_dict_creator(args.get('attestation'))
            }
            crypto_key['version_template'] = {
                'algorithm': enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm[args.get('algorithm')].value,
                'protection_level': enums.ProtectionLevel[args.get('protection_level')].value
            }

        # Create a CryptoKey for the given KeyRing.
        response = client.kms_client.create_crypto_key(key_ring_name, crypto_key_id, crypto_key,
                                                       args.get('skip_initial_version_creation') == 'true')

        context = key_context_creation(response, project_id, location_id, key_ring_id)

        headers = ['CreationTime', 'Name', 'Project', 'Location', 'KeyRing', 'Labels', 'NextRotationTime',
                   'Purpose', 'RotationPeriod', 'PrimaryCryptoKeyVersion', 'VersionTemplate']

        return (
            tableToMarkdown("Google KMS CryptoKey info:", context, removeNull=True, headers=headers),
            {
                f'{INTEGRATION_CONTEXT_NAME}.CryptoKey(val.Name == obj.Name)': context,
            },
            crypto_key_to_json(response)
        )


    def symmetric_encrypt_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Encrypt plaintext to ciphertext using a symmetric key.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.

        Returns:
            The encrypted ciphertext.
        """
        # handle given plaintext - revert it to base 64.
        if args.get('simple_plaintext'):
            plaintext = base64.b64encode(bytes(str(args.get('simple_plaintext')), 'utf-8'))

        elif args.get('base64_plaintext'):
            plaintext = base64.b64decode(str(args.get('base64_plaintext')))

        elif args.get('entry_id'):
            file = demisto.getFilePath(args.get('entry_id'))
            file_path = file['path']
            with open(file_path, 'rb') as fp:
                plaintext = base64.b64encode(fp.read())

        else:
            raise ValueError("No object to encrypt.")

        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)

        additional_authenticated_data = None
        if args.get('additional_authenticated_data'):
            additional_authenticated_data = base64.b64decode(str(args.get('additional_authenticated_data')))

        # The resource name of the CryptoKey.
        crypto_key_name = client.kms_client.crypto_key_path_path(project_id, location_id, key_ring_id, crypto_key_id)

        # Use the KMS API to encrypt the data.
        response = client.kms_client.encrypt(crypto_key_name, plaintext,
                                             additional_authenticated_data=additional_authenticated_data)

        # return the created ciphertext cleaned from additional characters.
        ciphertext = str(base64.b64encode(response.ciphertext))[2:-1]

        symmetric_encrypt_context = {
            'CryptoKey': crypto_key_id,
            'IsBase64': args.get('base64_plaintext') is not None,
            'Ciphertext': ciphertext
        }

        if args.get('entry_id'):
            file_name = demisto.getFilePath(args.get('entry_id'))['name'] + '_encrypted.txt'
            demisto.results(fileResult(file_name, ciphertext))

        return (f"The text has been encrypted.\nCiphertext: {ciphertext}",
                {
                    f'{INTEGRATION_CONTEXT_NAME}.SymmetricEncrypt(val.CryptoKey == obj.CryptoKey '
                    f'&& val.IsBase64 == obj.IsBase64 && val.Ciphertext == obj.Ciphertext)': symmetric_encrypt_context,
                }, symmetric_encrypt_context)


    def symmetric_decrypt_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Decrypt ciphertext to plaintext using a symmetric key.

        Args:
            client(Client): User Client.
            args(Dict): Demisto agruments.

        Returns:
            The decrypted text.
        """
        if args.get('simple_ciphertext'):
            ciphertext = base64.b64decode(str(args.get('simple_ciphertext')))

        elif args.get('base64_ciphertext'):
            ciphertext = base64.b64decode(str(args.get('base64_ciphertext')))

        elif args.get('entry_id'):
            file = demisto.getFilePath(args.get('entry_id'))
            file_path = file['path']
            with open(file_path, 'rb') as fp:
                ciphertext = base64.b64decode(fp.read())

        else:
            raise ValueError("No object to decrypt.")

        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)

        additional_authenticated_data = None
        if args.get('additional_authenticated_data'):
            additional_authenticated_data = base64.b64decode(str(args.get('additional_authenticated_data')))

        # The resource name of the CryptoKey.
        crypto_key_name = client.kms_client.crypto_key_path_path(project_id, location_id, key_ring_id, crypto_key_id)

        # Use the KMS API to decrypt the data.
        response = client.kms_client.decrypt(crypto_key_name, ciphertext,
                                             additional_authenticated_data=additional_authenticated_data)

        # handle the resulting plain text if it supposed to be in base64 and clean added characters.
        if args.get('base64_ciphertext'):
            plaintext = str(base64.b64encode(response.plaintext))[2:-1].replace('\\n', '\n')

        elif args.get('simple_ciphertext') or args.get('entry_id'):
            plaintext = str(base64.b64decode(response.plaintext))[2:-1].replace('\\n', '\n')

        if args.get('entry_id'):
            file_name = demisto.getFilePath(args.get('entry_id'))['name'] + '_decrypted.txt'
            demisto.results(fileResult(file_name, plaintext))

        symmetric_decrypt_context = {
            'CryptoKey': crypto_key_id,
            'IsBase64': args.get('base64_ciphertext') is not None,
            'Plaintext': plaintext
        }

        return (f"The text has been decrypted.\nPlaintext: {plaintext}",
                {
                    f'{INTEGRATION_CONTEXT_NAME}.SymmetricDecrypt(val.CryptoKey == obj.CryptoKey '
                    f'&& val.IsBase64 == obj.IsBase64 && val.Plaintext == obj.Plaintext)': symmetric_decrypt_context,
                }, symmetric_decrypt_context)


    def get_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Dict, Dict]:
        """Gets a CryptoKey.

        Args:
            client(Client): User Client.
            args(Dict): Demisto Arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)

        # The resource name of the CryptoKey.
        crypto_key_name = client.kms_client.crypto_key_path(project_id, location_id, key_ring_id, crypto_key_id)

        # Get CryptoKey info.
        response = client.kms_client.get_crypto_key(crypto_key_name)

        context = key_context_creation(response, project_id, location_id, key_ring_id)

        headers = ['CreationTime', 'Name', 'Project', 'Location', 'KeyRing', 'Labels', 'NextRotationTime',
                   'Purpose', 'RotationPeriod', 'PrimaryCryptoKeyVersion', 'VersionTemplate']

        return (
            tableToMarkdown("Google KMS CryptoKey info:", context, removeNull=True, headers=headers),
            {
                f'{INTEGRATION_CONTEXT_NAME}.CryptoKey(val.Name == obj.Name)': context,
            },
            crypto_key_to_json(response)
        )


    def disable_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Disable a given CryptoKeyVersion.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        if crypto_key_version == 'default':
            # if no CryptoKeyVersion given extract the primary CryptoKeyVersion.
            crypto_key_version_name = get_primary_key_version(project_id, location_id, key_ring_id, crypto_key_id, client)

        else:
            # Construct the resource name of the CryptoKeyVersion.
            crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                                crypto_key_id, crypto_key_version)

        # if not CryptoKeyVersion is given nor was is extracted from the CryptoKey - raise error to the user.
        if crypto_key_version_name is None or len(crypto_key_version_name) == 0:
            raise Exception("Please insert primary CryptoKeyVersion ID")

        # Use the KMS API to disable the CryptoKeyVersion.
        new_state = enums.CryptoKeyVersion.CryptoKeyVersionState.DISABLED
        version = {'name': crypto_key_version_name, 'state': new_state}
        update_mask = {'paths': ["state"]}

        # Print results
        response = client.kms_client.update_crypto_key_version(version, update_mask)
        return (f'CryptoKeyVersion {crypto_key_version_name}\'s state has been set to '
                f'{enums.CryptoKeyVersion.CryptoKeyVersionState(response.state).name}.', None, None)


    def enable_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Enable a CryptoKeyVersion.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        if crypto_key_version == 'default':
            # if no CryptoKeyVersion given extract the primary CryptoKeyVersion.
            crypto_key_version_name = get_primary_key_version(project_id, location_id, key_ring_id, crypto_key_id, client)

        else:
            # Construct the resource name of the CryptoKeyVersion.
            crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                                crypto_key_id, crypto_key_version)

        # if not CryptoKeyVersion is given nor was is extracted from the CryptoKey - raise error to the user.
        if crypto_key_version_name is None or len(crypto_key_version_name) == 0:
            raise Exception("Please insert primary CryptoKeyVersion ID")

        # Use the KMS API to enable the CryptoKeyVersion.
        new_state = enums.CryptoKeyVersion.CryptoKeyVersionState.ENABLED
        version = {'name': crypto_key_version_name, 'state': new_state}
        update_mask = {'paths': ["state"]}

        # Print results
        response = client.kms_client.update_crypto_key_version(version, update_mask)
        return(f'CryptoKeyVersion {crypto_key_version_name}\'s state has been set to '
               f'{enums.CryptoKeyVersion.CryptoKeyVersionState(response.state).name}.', None, None)


    def destroy_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Schedule the destruction of a given CryptoKeyVersion.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        if crypto_key_version == 'default':
            # if no CryptoKeyVersion given extract the primary CryptoKeyVersion.
            crypto_key_version_name = get_primary_key_version(project_id, location_id, key_ring_id, crypto_key_id, client)

        else:
            # Construct the resource name of the CryptoKeyVersion.
            crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                                crypto_key_id, crypto_key_version)

        # if not CryptoKeyVersion is given nor was is extracted from the CryptoKey - raise error to the user.
        if crypto_key_version_name is None or len(crypto_key_version_name) == 0:
            raise Exception("Please insert primary CryptoKeyVersion ID")

        # Use the KMS API to mark the CryptoKeyVersion for destruction.
        response = client.kms_client.destroy_crypto_key_version(crypto_key_version_name)

        # Print results
        return (f'CryptoKeyVersion {crypto_key_version_name}\'s state has been set to '
                f'{enums.CryptoKeyVersion.CryptoKeyVersionState(response.state).name}, it will be destroyed in 24h.',
                None, None)


    def restore_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Restores a CryptoKeyVersion scheduled for destruction.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        if crypto_key_version == 'default':
            # if no CryptoKeyVersion given extract the primary CryptoKeyVersion.
            crypto_key_version_name = get_primary_key_version(project_id, location_id, key_ring_id, crypto_key_id, client)

        else:
            # Construct the resource name of the CryptoKeyVersion.
            crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                                crypto_key_id, crypto_key_version)

        # if not CryptoKeyVersion is given nor was is extracted from the CryptoKey - raise error to the user.
        if crypto_key_version_name is None or len(crypto_key_version_name) == 0:
            raise Exception("Please insert primary CryptoKeyVersion ID")

        # Use the KMS API to restore the CryptoKeyVersion.
        response = client.kms_client.restore_crypto_key_version(crypto_key_version_name)

        # Print results
        return (f'CryptoKeyVersion {crypto_key_version_name}\'s state has been set to '
                f'{enums.CryptoKeyVersion.CryptoKeyVersionState(response.state).name}.', None, None)


    def update_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Dict, Dict]:
        """Update a given CryptoKey.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)

        # The resource name of the CryptoKey.
        crypto_key_name = client.kms_client.crypto_key_path(project_id, location_id, key_ring_id, crypto_key_id)

        # create a list of fields to be updated using the command - the field is called update mask in the API.
        update_mask = get_update_mask(args)

        # create the body of the update request.
        crypto_key = get_update_command_body(args=args, update_mask=update_mask['paths'])
        crypto_key['name'] = crypto_key_name

        # update command using the KMS API.
        response = client.kms_client.update_crypto_key(crypto_key=crypto_key, update_mask=update_mask)

        context = key_context_creation(response, project_id, location_id, key_ring_id)

        headers = ['CreationTime', 'Name', 'Project', 'Location', 'KeyRing', 'Labels', 'NextRotationTime',
                   'Purpose', 'RotationPeriod', 'PrimaryCryptoKeyVersion', 'VersionTemplate']

        return (
            tableToMarkdown("Google KMS CryptoKey info:", context, removeNull=True, headers=headers),
            {
                f'{INTEGRATION_CONTEXT_NAME}.CryptoKey(val.Name == obj.Name)': context,
            },
            crypto_key_to_json(response)
        )


    def list_keys_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Dict, List]:
        """List All keys in a KeyRing.

        Args:
            client(Client): User Client.
            args(Dict): Demisto arguments.

        """
        project_id, location_id, key_ring_id, _ = demisto_args_extract(client, args)

        # Get the full path to the KeyRing in which to list the keys.
        key_ring_name = client.kms_client.key_ring_path(project_id, location_id, key_ring_id)

        # if needed add state filter.
        filter_state = args.get('key_state', None)

        response = client.kms_client.list_crypto_keys(key_ring_name, filter_=filter_state)

        overall_context = []  # type: List
        overall_raw = []  # type: List
        for crypto_key in response:
            overall_context.append(key_context_creation(crypto_key, project_id, location_id, key_ring_id))
            overall_raw.append(crypto_key_to_json(crypto_key))

        headers = ['CreationTime', 'Name', 'Project', 'Location', 'KeyRing', 'Labels', 'NextRotationTime',
                   'Purpose', 'RotationPeriod', 'PrimaryCryptoKeyVersion', 'VersionTemplate']

        return (
            tableToMarkdown(name="CryptoKeys:", t=overall_context, removeNull=True, headers=headers),
            {
                f'{INTEGRATION_CONTEXT_NAME}.CryptoKey(val.Name == obj.Name)': overall_context,
            },
            overall_raw
        )


    def asymmetric_encrypt_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Encrypt plainttext using an asymmetric key.

        Args:
            client(Client): User's client.
            args(dict): Demisto arguments.

        Returns:
            The encrypted ciphertext.
        """
        # handle the plaintext - convert to base64
        if args.get('simple_plaintext'):
            plaintext = base64.b64encode(bytes(str(args.get('simple_plaintext')), 'utf-8'))

        elif args.get('base64_plaintext'):
            plaintext = base64.b64decode(str(args.get('base64_plaintext')))

        elif args.get('entry_id'):
            file = demisto.getFilePath(args.get('entry_id'))
            file_path = file['path']
            with open(file_path, 'rb') as fp:
                plaintext = base64.b64encode(fp.read())

        else:
            raise ValueError("No object to encrypt.")

        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        # Construct the resource name of the CryptoKeyVersion.
        crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                            crypto_key_id, crypto_key_version)
        # get the CryptoKeyVersion info and check it's algorithm.
        crypto_key_version_info = client.kms_client.get_crypto_key_version(crypto_key_version_name)
        key_algo = enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm(crypto_key_version_info.algorithm).name

        # Algorithm must be a "DECRYPT" type asymmetric algorithm - if not, raise an error to the user.
        if 'DECRYPT' not in key_algo:
            raise ValueError(f"{crypto_key_version_name} is not a valid asymmetric CryptoKeyVersion")

        # get public key of the asymmetric encryption.
        public_key_response = client.kms_client.get_public_key(crypto_key_version_name)
        key_txt = public_key_response.pem.encode('ascii')
        public_key = serialization.load_pem_public_key(key_txt, default_backend())

        # using the CryptoKeyVersion algorithm - create the necessary padding for the encryption.
        if 'SHA256' in key_algo:
            # create padding with SHA256
            pad = padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                               algorithm=hashes.SHA256(),
                               label=None)
        else:
            # create padding with SHA512
            pad = padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA512()),
                               algorithm=hashes.SHA512(),
                               label=None)

        # encrypt plaintext and return the cipertext without added characters.
        ciphertext = str(base64.b64encode(public_key.encrypt(plaintext, pad)))[2:-1]

        asymmetric_encrypt_context = {
            'CryptoKey': crypto_key_id,
            'IsBase64': args.get('base64_plaintext') is not None,
            'Ciphertext': ciphertext
        }

        if args.get('entry_id'):
            file_name = demisto.getFilePath(args.get('entry_id'))['name'] + '_encrypted.txt'
            demisto.results(fileResult(file_name, ciphertext))

        return (f"The text has been encrypted.\nCiphertext: {ciphertext}",
                {
                    f'{INTEGRATION_CONTEXT_NAME}.AsymmetricEncrypt(val.CryptoKey == obj.CryptoKey '
                    f'&& val.IsBase64 == obj.IsBase64 && val.Ciphertext == obj.Ciphertext)': asymmetric_encrypt_context,
                }, asymmetric_encrypt_context)


    def asymmetric_decrypt_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """Decrypt chipertext to plaintext using asymmetric key.

        Args:
            client(Client): User's Client.
            args(dict): Demisto arguments.

        Returns:
            The decrypted plaintext.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        # Construct the resource name of the CryptoKeyVersion.
        crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                            crypto_key_id, crypto_key_version)

        if args.get('simple_ciphertext'):
            ciphertext = base64.b64decode(str(args.get('simple_ciphertext')))

        elif args.get('base64_ciphertext'):
            ciphertext = base64.b64decode(str(args.get('base64_ciphertext')))

        elif args.get('entry_id'):
            file = demisto.getFilePath(args.get('entry_id'))
            file_path = file['path']
            with open(file_path, 'rb') as fp:
                ciphertext = base64.b64decode(fp.read())

        else:
            raise ValueError("No object to decrypt.")

        response = client.kms_client.asymmetric_decrypt(crypto_key_version_name, ciphertext)

        # handle the created plaintext back to base64 if needed and clear added characters.
        if args.get('base64_ciphertext'):
            plaintext = str(base64.b64encode(response.plaintext))[2:-1].replace('\\n', '\n')

        elif args.get('simple_ciphertext') or args.get('entry_id'):
            plaintext = str(base64.b64decode(response.plaintext))[2:-1].replace('\\n', '\n')

        if args.get('entry_id'):
            file_name = demisto.getFilePath(args.get('entry_id'))['name'] + '_decrypted.txt'
            demisto.results(fileResult(file_name, plaintext))

        asymmetric_decrypt_context = {
            'CryptoKey': crypto_key_id,
            'IsBase64': args.get('base64_ciphertext') is not None,
            'Plaintext': plaintext
        }

        return (f"The text has been decrypted.\nPlaintext: {plaintext}",
                {
                    f'{INTEGRATION_CONTEXT_NAME}.AsymmetricDecrypt(val.CryptoKey == obj.CryptoKey '
                    f'&& val.IsBase64 == obj.IsBase64 && val.Plaintext == obj.Plaintext)': asymmetric_decrypt_context,
                }, asymmetric_decrypt_context)


    def list_key_rings_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """List all KeyRings in a given location

        Args:
            client(Client): User's client.
            args(dict): Demisto args.
        """
        # listing the KeyRings in order to check responses from the API.
        locations = []
        if args.get('location') == 'default':
            locations.append(client.location)

        else:
            locations.append(args.get('location'))

        # paramater 'all' checks all possible locations
        if args.get('all') == 'yes':
            locations = ['global', 'asia-east1', 'asia-east2', 'asia-northeast1',
                         'asia-northeast2', 'asia-south1', 'asia-southeast1', 'australia-southeast1',
                         'europe-north1', 'europe-west1', 'europe-west2', 'europe-west3', 'europe-west4',
                         'europe-west6', 'northamerica-northeast1', 'us-central1', 'us-east1', 'us-east4',
                         'us-west1', 'us-west2', 'southamerica-east1', 'eur4', 'nam4', 'asia', 'europe', 'us']

        key_rings_context = []
        key_rings_json = []

        for location in locations:
            location_path = client.kms_client.location_path(client.project, location)
            # the response is a iterable containing the KeyRings info.
            response = client.kms_client.list_key_rings(location_path)

            for key_ring in list(response):
                single_context, single_json = key_ring_context_and_json_creation(key_ring)
                key_rings_context.append(single_context)
                key_rings_json.append(single_json)

        return (tableToMarkdown(name="KeyRings:", t=key_rings_context, removeNull=True),
                {
                    f'{INTEGRATION_CONTEXT_NAME}.KeyRing(val.Name == obj.Name)': key_rings_context}, key_rings_json)


    def list_all_keys_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Any, Any]:
        """List all CryptokKeys across all KeyRings in a given location.

        Args:
            client(Client): User's client.
            args(dict): Demisto args.
        """
        locations = []
        if args.get('location') == 'default':
            locations.append(client.location)

        else:
            locations.append(args.get('location'))

        # paramater 'all' checks all possible locations
        if args.get('all') == 'yes':
            locations = ['global', 'asia-east1', 'asia-east2', 'asia-northeast1',
                         'asia-northeast2', 'asia-south1', 'asia-southeast1', 'australia-southeast1',
                         'europe-north1', 'europe-west1', 'europe-west2', 'europe-west3', 'europe-west4',
                         'europe-west6', 'northamerica-northeast1', 'us-central1', 'us-east1', 'us-east4',
                         'us-west1', 'us-west2', 'southamerica-east1', 'eur4', 'nam4', 'asia', 'europe', 'us']

        keys_context = []
        keys_json = []
        filter_state = args.get('key_state')
        for location in locations:
            location_path = client.kms_client.location_path(client.project, location)
            # the response is a iterable containing the KeyRings info.
            response = client.kms_client.list_key_rings(location_path)

            for key_ring in list(response):
                key_ring_name = key_ring.name
                pre_name = f"projects/{client.project}/locations/{location}/keyRings/"
                key_ring_id = str(key_ring_name).replace(pre_name, '')
                crypto_key_response = client.kms_client.list_crypto_keys(key_ring_name, filter_=filter_state)

                for crypto_key in crypto_key_response:
                    keys_context.append(key_context_creation(crypto_key, str(client.project),
                                                             str(location), str(key_ring_id)))
                    keys_json.append(crypto_key_to_json(crypto_key))

        headers = ['CreationTime', 'Name', 'Project', 'Location', 'KeyRing', 'Labels', 'NextRotationTime',
                   'Purpose', 'RotationPeriod', 'PrimaryCryptoKeyVersion', 'VersionTemplate']

        return (
            tableToMarkdown(name="CryptoKeys:", t=keys_context, removeNull=True, headers=headers),
            {
                f'{INTEGRATION_CONTEXT_NAME}.CryptoKey(val.Name == obj.Name && val.Location == obj.Location'
                f'&& val.KeyRing == obj. KeyRing)': keys_context,
            },
            keys_json
        )


    def get_public_key_command(client: Client, args: Dict[str, Any]) -> Tuple[str, Dict, Dict]:
        """Get the public key from an asymmetric CryptoKey

        Args:
            client(Client): User's client.
            args(dict): Demisto args.
        """
        project_id, location_id, key_ring_id, crypto_key_id = demisto_args_extract(client, args)
        crypto_key_version = args.get('crypto_key_version')

        # Construct the resource name of the CryptoKeyVersion.
        crypto_key_version_name = client.kms_client.crypto_key_version_path(project_id, location_id, key_ring_id,
                                                                            crypto_key_id, crypto_key_version)

        public_key_response = client.kms_client.get_public_key(crypto_key_version_name)

        public_key_context = {
            'CryptoKey': crypto_key_id,
            'PEM': str(public_key_response.pem),
            'Algorithm': enums.CryptoKeyVersion.CryptoKeyVersionAlgorithm(public_key_response.algorithm).name
        }

        return (
            f"The Public Key for CryptoKey {crypto_key_id} is:\n{public_key_context.get('PEM')}",
            {
                f'{INTEGRATION_CONTEXT_NAME}.PublicKey(val.CryptoKey == obj.CryptoKey '
                f'&& val.PEM == obj.PEM': public_key_context
            },
            public_key_context
        )


    def test_function(client: Client) -> None:
        """Test's user's input this checks if the given service account has any of the required permissions
        to use the integration

        In client creation we check that the entered service account is a valid json and has all the required
        fields to create the client.

        In this function we try and get a response from Google KMS just to make sure we can connect to it.

        This test does NOT check if the service account has the required permissions to get a VALID response from KMS.

        Args:
            client(Client): User Client.
        """
        # creating a valid resource name
        if client.key_ring:
            key_ring = client.key_ring

        else:
            key_ring = "random"

        key_ring_name = client.kms_client.key_ring_path(client.project, client.location, key_ring)
        client.kms_client.list_crypto_keys(key_ring_name)


    def main():
        COMMANDS = {
            f'{INTEGRATION_COMMAND_NAME}-create-key': create_crypto_key_command,

            f'{INTEGRATION_COMMAND_NAME}-symmetric-decrypt': symmetric_decrypt_key_command,

            f'{INTEGRATION_COMMAND_NAME}-symmetric-encrypt': symmetric_encrypt_key_command,

            f'{INTEGRATION_COMMAND_NAME}-get-key': get_key_command,

            f'{INTEGRATION_COMMAND_NAME}-update-key': update_key_command,

            f'{INTEGRATION_COMMAND_NAME}-destroy-key': destroy_key_command,

            f'{INTEGRATION_COMMAND_NAME}-restore-key': restore_key_command,

            f'{INTEGRATION_COMMAND_NAME}-disable-key': disable_key_command,

            f'{INTEGRATION_COMMAND_NAME}-enable-key': enable_key_command,

            f'{INTEGRATION_COMMAND_NAME}-list-keys': list_keys_command,

            f'{INTEGRATION_COMMAND_NAME}-asymmetric-encrypt': asymmetric_encrypt_command,

            f'{INTEGRATION_COMMAND_NAME}-asymmetric-decrypt': asymmetric_decrypt_command,

            f'{INTEGRATION_COMMAND_NAME}-list-key-rings': list_key_rings_command,

            f'{INTEGRATION_COMMAND_NAME}-list-all-keys': list_all_keys_command,

            f'{INTEGRATION_COMMAND_NAME}-get-public-key': get_public_key_command
        }

        command = demisto.command()
        LOG(f'{INTEGRATION_NAME}: command is {command}')
        try:
            client = Client(demisto.params())

            if command == 'test-module':
                test_function(client)
                demisto.results('ok')

            if command not in COMMANDS:
                raise NotImplementedError(f'Command "{command}" is not implemented.')

            cmd_func = COMMANDS.get(command)  # type: ignore

            results = cmd_func(client, demisto.args())  # type: ignore
            return_outputs(*results)

        except Exception as e:
            return_error(f'{INTEGRATION_NAME}: {str(e)}', e)


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
