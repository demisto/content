category: Endpoint
commonfields:
  id: CarbonBlackProtectionV2
  version: -1
configuration:
- defaultvalue: https://192.168.0.1
  display: Server URL (e.g. https://192.168.0.1)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: API Token
  name: token
  required: true
  type: 4
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: "15"
  display: Max incidents per fetch
  name: incidents_per_fetch
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch query
  name: fetch_query
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents query
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy
  name: proxy
  required: false
  type: 8
description: Carbon Black Enterprise Protection is a next-generation endpoint threat
  prevention solution to deliver a portfolio of protection policies, real-time visibility
  across environments, and comprehensive compliance rule sets in a single platform.
detaileddescription: |
  To find a API key corresponding with a particular Carbon Black user account, log into the console as that user, then click the username in the upper right -> Profile info.
  Then, click the "API Token" button on the left hand side to reveal the API token for the logged-in user. If there is no API token displayed, click the "Reset" button to create a new one.
display: Carbon Black Enterprise Protection V2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADoRJREFUeAHtmXl8VNUVx9+9772ZzIQksoigKMimYiNaWlyqiNoq1aq1ftDaulRUrCyWEDKTZGINQpYhEYKIsrQqYK1L/dRqa921H1HcEDf6KRVBEBShUQKG2d7S328yb5yZZBKK9J/2nc/nm7ud+5Zz7jn3vomiuOJawLWAawHXAq4FXAu4FnAt4FrAtYBrAdcCrgVcC7gWcC3gWsC1gGsB1wKuBVwLuBZwLeBawLXA/6kFRJ73/nZOP/UMsAfsABHQlRyHzlGgFbwEDkjKy0ODda+4Wiii1rIsWwql8ssvW1cuWbJk5wFd8D+YVFZZOdyrqKW2lLqwlA8bG+esy51eUVExYt8+7YvFixv4nkkpLy8f7PH4BxmKIfHMQkpp6kJsqq+v/4wKFRU1wzRNDHDGVU2L7t5lbFi2LNzWcQVFqa2t1WKx2Mm2LQfZthKFydeFw+GtHJ84caJn8ODBI5uamtYLIWxnzpQpU3oVFxf3a2xs/NjpyyxlZiOj/ibq5C2wNlW+g/LvgC98Bzga5MqV6PgDuD13IKN9JOp6RjurGqwKzfR4tVeFLc4xTaUFb3KvIuS0Pn37v11ZWTMhS/kgNmBcGaisvtUj1RCc01valldI87pAZWh5IBAocm41derUvqqmP1ZUJOudPpa6XlAjhHoVjD8W88dKSzvDsuSSqqrQNRwX0mpWNHlZetxWz+vTR3uwPBgcx3EsmmHRaOIBRdH4jlJo8jCheesDgaoZHB80cuShml7wCuxTw7YjRUW9T7SlNttp55Zabkeq7TiekfousIAXHAWOSfFjlBcBOt6RfagQRnqunICOJjAYnAq+BFkSDIaqpRCzLNO+Ihye87QzOHny5JK+/QaEpSofnTnzltPmz5/DZ+pW+jzZWuz1yt5KNKIUioE7Np4vYt1NiEbjkxAXQ30e/Vo4m+9LWRUM1swXUv856kvY0atX8XWWKZYLqYwLBoOliLD32W/ZipqIRVbcfnt4NduUSmQD01ZXoLqCUdceaV9+R3PzB8lB/JlVfcuVmqLxfqujUaPFtu1lyBhPOOO/qK1dOcBUH6qqqtloxLW3bDXxnlTE6cFg9c/C4XoshpSYiuMvpydd5nOwo7AZlTMA0zPT9KHgalAHGInN4DxgAspdgDfuypil6D8XMGUhMLMFjhutCKtWsc2fhMNz086l1rJly9pghCkwwgm6LsLo+iHodA3qOuL1WpO0At8cW9pKxNzJ+65xxrookY3lJUZCVIfDaecm1Xw+LRCJRArZKCsr62ML9cydn2+7dODAga2WUG9C9xSOCaHY0qMXT58+3cu21+vVDClPUW1lPdsUr+YtLSsLIvtLW9PkIXjX04Rt/a69PX6CUD3KvHBd2rnUv6+2NlpdXX2nacqrdT2+1rREm6oqNyVM8WAgENo0b17da9SzBRJ6Hsnr+Qx9R4cX4R5Ipz6SGj8Z5eGpOgtG5WbwKRs5wsimcDF02sN13ZqKPffthoaGPye1cv7AwRZWeIOQ9jnYz4bmDHdqqkJ4sBH2Ija80kkhowPXVqGvq8Xq5xndySrGDERpcp/UvL5rYMv3ioqKPHDSC3DrGETpkI45tqKr6rUF/uK5vqKiOUjZC6Upyi0juSCpInVVjvN4tAtVVb0Yz3U5tqERtq3uU1TvAFz3Xx3Xyf4bj8c/U4RdZJrY0rET1NXVfYJ8WoYMsgDOH2hKK5E9I7vVUwRna3/d4j7MtOUBvq+7FR7ORoIvwDOA44y2AnAqoPgB57aDOHgSRkwgOseh/iDIK4YRXaNqXiwOayyUPsqrmBzAqraRafMv7vR0OjFYGdqjRu1j0bkjPYAKto3TsbDO8fs9DXjGy6Um3vf3KpprmsLSVDWK8nqoYV8Uipmwf1Po059PzZeRSGIa9vFpaJcBKxGPLsUhKb2llZVVDvd41aWqImYhBQyCDrNkVjRiHy5Fx2e25YsLLS5w2FIRuW9UVFTiHKTerRjWHYoGl+eRA3XwmNT1mG6JI5NRuREwLX0L9AJ0WgFwpA8qv001+DKHjRo1qm3duncPSVhW5rUc/XSJyPliXzSxQ0p1RLozT4UpMz0ED6XreSqqtJdallIVCoU+SkYJ9KZOreqL64SEkAsjEeMa1F+rr5uTPPTwMtOnVx3qL5SPTy4vb6FfDMOwamvruZ0lBXv0s4rQ5rCB1aZaqpp1uPR6lUEWwtjnVddHo9ZGHCKrCwq0MBcc55SXVx2LzHKjacRmCJHQhKWnM1FTU+PvA4GaITiN4yBqv039rqQnB9MwjDJHeqMyCVye6uBpeW+qzsJJF9yDuRqZlgOAjmY6vxjwAAaD8DMgmaq/QmliCe7DAWsA6nkFL24FgtXt+IwozlJ62FbHDMVBY+3adPdn2CAlwteCabG/amOWvvW1cceMUdaOwVYhsPWmBJ8zzyJa/Ti5N8DQ23C1OE5Ow5FZHyooUJ/BCXelZSWSznLmLFrUsCtQXfN4sdc/wbbMrdhanW0oqWJZvl1SGnvx3Brmf6qp+mSc1C/loBSqDxbqhQgMYDw+C6Kq3upIzODJe7slpV+Y1kDLtGYz6mfODB2p6/Y2594s582b2xisDo1Eemc27FLohK7EWfE0/mpAQ3gBI+cosAGEwb0gUxahwZTEFfVdkDYg6teD5YAPOQxkLhykwppVeOHRmz7acNIjjzzCfbqT4HPlGHwqrDUNc2E4XBdyFAa92NoiNM/3bSOeem6h7InE+kbajf64pl1S7N1coGtYdB3DAh/ZViLRtP2s3iucazglTux6YZ8+g3UkYMuKbmtubm6HA2RbW5t3wYIFnc4OmCdw+CrYtq0Ez7zezH12jPlKSkpira2tuqZphfF4gUgk4sLvN42Wlpbdzn2dkp9hhYWF/S2PJ9pL07ZwUXMMSUjcfPPNnkWLFjF4soQHu676qaRlaXZuMPImdO5WeBjZ2kV/d13cjylcVNyHsxwshNGCz5HXhw4fWYuxW0CW4DvxRBxTFiNdSts2d2UNCjFS+guPt+MdGQyfJIqAr81YFEdb5EBVH6H6Cmik5DThRfDsbj086xqpBk7szEIbM8dSRu7KuVSz8zg+eYmMMTqmk3OSShl/Fi9e3IomyRJ+ZqGjy/n5nMsL9OTgLdC5AfClaT0eBJhmLwHPgdvAreAbC36JWYsfFaZhmS+qDNWckrDs+1XT3ook21/X9XOxjHHYMeYbRnyIospNmTcUlvWOve+rEjuR6PAgBoWZOMLj9wyhU20jgXGrPT1o2QKfMB9nXgN1ZqgLQeZ5gSpckNxOmP953+MAsxON/QTISsto58rZ6KDduKD/BHIXylD0UecYwCDgOeR18DIwQD/AIONzvAiYASlHgPGAPpSA/vgEZElPDmaKfjZrBj7a0a4D1YCRxvHV4BvLvMa6JRUVVe9rujbDI5RbLYlPF6Htxi76cixiXODxqP3hpBJdtXmKT8snZ/fjs2TJkS/umlXcu7jJjseEGYtP23p231eyFDo3itC1HBzSeSjZwy+DC8BYsBDQwSNAdw4ehvHHAK9N4Tfz3clax58ZKH4NeLbJlRfQcS3oD1alBhlYdPBZYBkYDrgIQqAVdBJ6vjvhqnFSa6beXWjwsMTxH2UOfNN6U1PDKw31cyZ+tbftuL17tOPwa9Tohvq5UxYsaNyIzDsFN3zTOeV2dy8Ebsc5mmHLnN2zUJORSnkAXJ5iMkoaj6f/y4Cjw5JzupNZGHScSz22nQV0IeoLAJ37FDgXjAXlgIHFqL4HMAid+9CZN4G/ADr3XXAGmAf2gU7CyQcivBhfkKdZvvhBl9S+kt5z+LMg3pIGTp5CD/oNsy/YF01GH4W/YtFOFngTlID9keOhdBWgc1pS9aEorwfN4FpAYVq9AuxmA8J76OCngNvGEYD3ZjCGwShA4SJkRmhjI58cqIO50mgEyucdxX7/VaG5PxGVviD/YyJV/T7Tsp/2+3Su3v0QRK3ErSQ+lnDm2o8JmSrnoUEyxUTDB3rKes6cICpcHLvA4+AkMB4wLa8AhwHKP4Hj3GQH/nBBrARcHNwGeE++g+NcVJUBgAuhW+npYXmDeMYV/KifD+4CdBRfmg+/P+K8BCP+yP2ZQB18Gg0qOaTv4zgO+20zfoPz2dDTfLi3HT8t7bQtYye+JTPfoaepHJ8PaExSCv4K+L5V4FBAoW2YybqS76CT2YZC/RfBeEBhRDKKN7ABoQOdYEl24M88wPT7N8D5tDOFB6nbAO99NvgjyJ2Lrq+lpwgeDFVGDFMEV+9RgA/kyGxUmFL2R/jA3EM8YDG4GzDdPQZ4cqSI8ePHq6WlpX78WH8U/r96MX4RmGLZ5j8sI/YDfPDv6FDr+a/tjdyT2J14WPoK7c8/3txtGuviakPQ971UP0/Vg1L1dpSJVJ32qAZ7Um0WHFsCGL1Mr8xu9wM6hJwF6PypoAZcCWhTBsmdYCc4E/wS0E7Pgi3A8RP37CdBBDSA08Gj4FLQCjqJ6NTT0cGHySd8Sf6QwQd6OEeJTuPDfQBGAy4MR3gvPuCvnI5UyQihvhKoqrkIP8g344cMfn8X4LeoTfg1afGaNatXvfTSSwZ1/ovSD9dmuuyd5x7b0T8JHAsW5tFh93SwKDVORzMaHRmLymvAsQUXPcf7g0xxMuMN6BwK3kgNXoKSAUGZDX6drCnKKyi5Z29LtdOFszLSHakKV0Sm8IF4U6bZrWAz6GoRcPU+B77sYpz6M8FTgCv4aLAKbAFJiZnxDR61oAmH3u2xmLlx/vy6DzHQ1X1SMw5qwUi8CjDycmUvOuiMnYDvTmd39VzcCvg5NRHQXs+DTKGjJoAi8BV4GlDnLHAB4L0ZtVwEDCIK70N/0AevA0duReVVwGDQARdoJwejzxXXAq4FXAu4FnAt4FrAtYBrAdcCrgVcC7gWcC3gWsC1gGsB1wKuBVwLuBZwLeBawLWAawHXAq4FXAu4FvgftMC/AcHP09B6zNZ1AAAAAElFTkSuQmCC
name: CarbonBlackProtectionV2
script:
  commands:
  - arguments:
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field. Example: group=osShortName'
      name: group
    - description: '(Int) Is maximum number of results to retrieve. If not specified:
        First 1000 results will be returned. If set to -1: Only result count will
        be returned, without actual results. Offset parameter is ignored in this case.
        If set to 0: All results will be returned. Offset parameter is ignored in
        this case. Note that some result sets could be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.'
      name: limit
    - description: (Int) Offset in data set
      name: offset
    - description: 'A condition contains three parts: name, operator, and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        See more: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: 'Sorting is optional and can be defined with a single attribute:
        &sort=xyz [ASC|DESC]. There can be only one sorting field. Default sort order
        (if omitted) is ASC. xyz is field name from the result set.'
      name: sort
    - description: Name of the file under which this unique hash was first seen
      name: fileName
    - description: Type of the file
      name: fileType
    - description: Id of computer where this file was first seen. You can get this
        by executing cbp-computer-search command
      name: computerId
    - auto: PREDEFINED
      description: |-
        Threat of this file. Can be one of:
        -1=Unknown
        0=Clean
        50=Potential risk
        100=Malicious
      name: threat
      predefined:
      - Unknown
      - Clean
      - Potential risk
      - Malicious
    - auto: PREDEFINED
      description: |-
        File state of this hash. Can be one of:
        1=Unapproved
        2=Approved
        3=Banned
        4=Approved by Policy
        5=Banned by Policy
      name: fileState
      predefined:
      - Unapproved
      - Approved
      - Banned
      - Approved by Policy
      - Banned by Polic
    - description: Hash of the file
      name: hash
    description: 'Search for file catalogs. See more: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filecatalog'
    name: cbp-fileCatalog-search
    outputs:
    - contextPath: File.Size
      description: Size of the file.
      type: Unknown
    - contextPath: File.Path
      description: Path on the found hostname.
      type: String
    - contextPath: File.Name
      description: Name of the file.
      type: String
    - contextPath: File.Type
      description: File type.
      type: String
    - contextPath: File.ProductName
      description: The name of the product to which this file belongs.
      type: String
    - contextPath: File.ID
      description: Unique fileCatalog ID.
      type: String
    - contextPath: File.Publisher
      description: The publisher of the file.
      type: String
    - contextPath: File.Company
      description: The company for the product.
      type: String
    - contextPath: File.Extension
      description: Extension of the file.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator, and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with an operator and depends on field
        type. See more: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Offset in data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute:
        &sort=xyz [ASC|DESC]. There can be only one sorting field. Default sort order
        (if omitted) is ascending (ASC). xyz is field name from the result set.'
      name: sort
    - description: Maximum number of results to retrieve (Int). If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the Offset parameter is ignored.
        If set to "0", all results will be returned, and the Offset parameter is ignored.
        Some result sets might be very large, resulting in query timeout. Therefore,
        unless you know that query will not return more than 1000 results, it is recommended
        to retrieve data in chunks using offset and limit.
      name: limit
    - description: Computer name
      name: name
    - description: Last known IP address of this computer
      name: ipAddress
    - description: MAC address of adapter used to connect to the CB Protection Server
      name: macAddress
    description: 'Search for computers. For more information, see the Carbon Black
      documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#computer'
    name: cbp-computer-search
    outputs:
    - contextPath: Endpoint.OS
      description: The short OS name running on the endpoint.
      type: String
    - contextPath: Memory
      description: Amount of memory for the endpoint.
      type: Number
  - arguments:
    - default: true
      description: (Int) Unique computer ID.
      name: id
      required: true
    - description: (String) Computer name can be changed only if computer is a template
      name: name
    - description: (String) Custom computer tag.
      name: computerTag
    - description: (String) Description of this computer.
      name: description
    - description: (Int) New ID of the policy for this computer. PolicyId is ignored
        if either automaticPolicy is "True" or localApproval is "True".
      name: policyId
    - auto: PREDEFINED
      description: (Boolean) "True" if this policy is assigned automatically through
        AD. If localApproval is "True", this argument must be "False".
      name: automaticPolicy
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: (Boolean) "True" if this computer is currently in local approval
        mode. If automaticPolicy is "True", this argument must be "False".
      name: localApproval
      predefined:
      - "True"
      - "False"
    - description: '(Int) Change refresh flags for this agent. Can be a combination
        of: 0x01=Complete resynch of agent NAB and installer table is requested 0x02=Rescan
        of programs installed on the computer is requested 0x20=Tell agent to refresh
        config list 0x40=Force this agent to reregister with new cookie 0x200=Trigger
        agent Reboot. 0x1000=Tell agent to refresh config list from the file 0x4000
        Boost the priority of this agent over all others permanently (until it is
        de-prioritized).'
      name: refreshFlags
    - auto: PREDEFINED
      description: (Boolean) Set to "True" to prioritize this computer.
      name: prioritized
      predefined:
      - "True"
      - "False"
    - description: (Int) Current debug level of the agent. Range is from 0 (none)
        to 8 (verbose). This value can be changed only if the "changeDiagnostics"
        request parameter is set to "True".
      name: debugLevel
    - description: (Int) Current kernel debug level of the agent. Range is from 0
        (none) to 5 (verbose). This value can be changed only if the "changeDiagnostics"
        request parameter is set to "True".
      name: kernelDebugLevel
    - description: '(Int) Debug flags. Can be 0 or combination of: 0x01 = Upload debug
        files now 0x10 = Enable full memory dumps 0x20 = Copy agent cache 0x40 = Delete
        debug files 0x80 = Upload agent cache 0x200 = Save verbose debug info + counters
        to the cache when copied/uploaded 0x400 = Generate and upload an analysis.bt9
        file that contains various constraint violation analysis information 0x800
        = Run a health check and send results to server. This value can be changed
        only if the "changeDiagnostics" request parameter is set to "True".'
      name: debugFlags
    - description: (Int) Debug duration in minutes. This value can be changed only
        if the "changeDiagnostics" request parameter is set to "True".
      name: debugDuration
    - description: '(Int) Cache consistency check level set for the agent. Can be
        one of: 0 = None 1 = Quick verification 2 = Rescan known files Full scan for
        new files. This value can be changed only if the "changeDiagnostics" request
        parameter is set to "True".'
      name: cCLevel
    - description: '(Int) Cache consistency check flags set for agent. Can be 0 or
        combination of: 0x0001 = Whether this is just a test run or not 0x0002 = Should
        the state of invalid files be preserved 0x0004 = Should new files found be
        locally approved or not 0x0008 = Should we re-evaluate whether a file’s certificate
        information is still valid or not 0x0010 = Whether the check was scheduled
        or not 0x0020 = Whether the agent should run constraint checks to test for
        invalid results 0x0040 = Whether we are only searching for new script types
        as a result of a change to what ‘IsScript’ means 0x0080 = Whether we are doing
        a level 3 check for initialization 0x0100 = This cache check is to remediate
        CR# 18041 0x0200 = Force the re-evaluation of the IsCrawlable state and archive
        type.'
      name: cCFlags
    - auto: PREDEFINED
      description: (Boolean) Set to "True" to force an upgrade for this computer.
      name: forceUpgrade
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: (Boolean) "True" if the computer is a VDI template. This value
        can be changed only if the "changeTemplate" request parameter is set to "True".
      name: template
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: |-
        (Int) Mode of template cleanup. Can be one of:
        1=Manual (from console)
        2=Automatic, by time (specified by templateCloneCleanupTime and templateCloneCleanupTimeScale)
        3=Automatic, when new computer with the same name comes online
        4=Automatic, as soon as computer goes offline
        This value can be changed only if the "changeTemplate" request parameter is set to "True".
      name: templateCloneCleanupMode
      predefined:
      - "1"
      - "2"
      - "3"
      - "4"
    - description: (Int) If the templateCloneCleanupMode value is "2", this is the
        time before clone is cleaned up. Time unit is specified in templateCloneCleanupTimeScale.
        This value can be changed only if the "changeTemplate" request parameter is
        set to "True".
      name: templateCloneCleanupTime
    - auto: PREDEFINED
      description: |-
        (Int) Time unit of the template cleanup. Can be one of:
        1=Hours
        2=Days
        3=Weeks
        This value can be changed only if the "changeTemplate" request parameter is set to "True".
      name: templateCloneCleanupTimeScale
      predefined:
      - "1"
      - "2"
      - "3"
    - auto: PREDEFINED
      description: (Boolean) If "True", clones of this template will track only new
        and modified files. This value can be changed only if the "changeTemplate"
        request parameter is set to "True".
      name: templateTrackModsOnly
      predefined:
      - "True"
      - "False"
    - description: (Boolean) If "True", debug and CC properties of the computer will
        be updated from the object sent in the body the request. This action requires
        "Change advanced options" permission. Default is "False".
      name: changeDiagnostics
    - description: (Boolean) If set to true, template settings will be updated from
        the object sent in the body the request. This action requires "Change advanced
        options" permission. Default is "False".
      name: changeTemplate
    - auto: PREDEFINED
      description: (Boolean) Deletes a computer entry. Default is "False".
      name: delete
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: (Boolean) Reset the CLI password for this computer. This action
        requires "Change advanced options" permission.
      name: resetCLIPassword
      predefined:
      - "True"
      - "False"
    description: 'Updates computer objects. Note that some computer properties can
      be changed only if specific boolean parameters are set. For more information,
      see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#computer'
    name: cbp-computer-update
    outputs:
    - contextPath: Endpoint.Processors
      description: The number of processors.
      type: Number
    - contextPath: Endpoint.OS
      description: The short OS name running on the endpoint.
      type: String
    - contextPath: Endpoint.MACAddress
      description: MAC address of the endpoint.
      type: String
    - contextPath: Endpoint.Model
      description: The machine model, if available.
      type: String
    - contextPath: Endpoint.IPAddress
      description: IP address of the endpoint.
      type: String
    - contextPath: Endpoint.Processor
      description: Model of the processor.
      type: String
    - contextPath: Endpoint.Hostname
      description: Hostname of the endpoint.
      type: String
    - contextPath: Endpoint.OSVersion
      description: The full OS name running on the endpoint.
      type: String
    - contextPath: Endpoint.ID
      description: The unique ID within the tool retreiving the endpoint.
      type: String
  - arguments:
    - default: true
      description: (Int) Unique computer ID.
      name: id
      required: true
    description: 'Returns information for a computer. For more information, see the
      Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#computer'
    name: cbp-computer-get
    outputs:
    - contextPath: Endpoint.Processors
      description: The number of processors.
      type: Number
    - contextPath: Endpoint.OS
      description: The short OS name running on the endpoint.
      type: String
    - contextPath: Endpoint.MACAddress
      description: MAC address of the endpoint.
      type: String
    - contextPath: Endpoint.Model
      description: The machine model, if available.
      type: String
    - contextPath: Endpoint.IPAddress
      description: IP address of the endpoint.
      type: String
    - contextPath: Endpoint.Processor
      description: Model of the processor.
      type: String
    - contextPath: Endpoint.Hostname
      description: Hostname of the endpoint.
      type: String
    - contextPath: Endpoint.OSVersion
      description: The full OS name running on the endpoint.
      type: String
    - contextPath: Endpoint.ID
      description: The unique ID within the tool retreiving the endpoint.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified the
        first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the "offset" parameter is
        ignored. Note that some result sets might be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute,
        where xyz is the field name from the result set: &sort=xyz [ASC|DESC]. There
        can be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    - description: Id of computer associated with this fileInstance
      name: computerId
    - description: Name of the file on the agent
      name: fileName
    description: 'Search for file instances. For more information, see the Carbon
      Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#fileinstance'
    name: cbp-fileInstance-search
    outputs:
    - contextPath: CBP.FileInstance.CatalogID
      description: The file ID in the file catalog.
      type: String
    - contextPath: CBP.FileInstance.ComputerID
      description: The computer ID on which the file was found.
      type: String
    - contextPath: CBP.FileInstance.ID
      description: CBP internal ID of the file instance.
      type: String
    - contextPath: CBP.FileInstance.Name
      description: Name of the file.
      type: String
    - contextPath: CBP.FileInstance.Path
      description: Path on the found hostname.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the "offset" parameter is
        ignored. Note that some result sets might be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute,
        where xyz is field name from the result set: &sort=xyz [ASC|DESC]. There can
        be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    - auto: PREDEFINED
      description: |-
        Event type. Can be one of:
        0 = Server Management
        1 = Session Management
        2 = Computer Management
        3 = Policy Management
        4 = Policy Enforcement
        5 = Discovery
        6 = General Management
        8 = Internal Events
      name: type
      predefined:
      - Server Management
      - Session Management
      - Computer Management
      - Policy Management
      - Policy Enforcement
      - Discovery
      - General Management
      - Internal Events
    - description: Id of computer associated with this event. You can get this by
        executing cbp-computer-search command
      name: computerId
    - description: IP address associated with this event
      name: ipAddress
    - description: Name of the file associated with this event
      name: fileName
    - auto: PREDEFINED
      description: |-
        Event severity. Can be one of:
        2 = Critical
        3 = Error
        4 = Warning
        5 = Notice
        6 = Info
        7 = Debug
      name: severity
      predefined:
      - Critical
      - Error
      - Warning
      - Notice
      - Info
      - Debug
    - description: User name associated with this event
      name: userName
    - description: Id of fileCatalog entry associated with this fileRule. Can be null
        if file hasn’t been seen on any endpoints yet. You can get this by executing
        cbp-fileCatalog-search
      name: fileCatalogId
    description: 'Search for events. For more information, see the Carbon Black documentation:
      https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#event'
    name: cbp-event-search
    outputs:
    - contextPath: CBP.Event.FilePath
      description: File path of the event.
      type: String
    - contextPath: CBP.Event.Param1
      description: First event parameter.
      type: String
    - contextPath: CBP.Event.Param2
      description: Second event parameter.
      type: String
    - contextPath: CBP.Event.Param3
      description: Third event parameter.
      type: String
    - contextPath: CBP.Event.SubTypeName
      description: Name of the subtype.
      type: String
    - contextPath: CBP.Event.ComputerName
      description: Name of the computer related to the event.
      type: String
    - contextPath: CBP.Event.FileName
      description: Name of the file related to the event.
      type: String
    - contextPath: CBP.Event.RuleName
      description: Name of the rule related to the event.
      type: String
    - contextPath: CBP.Event.ProcessFileCatalogID
      description: ID of the process file catalog ID.
      type: String
    - contextPath: CBP.Event.StringID
      description: ID of the event string.
      type: String
    - contextPath: CBP.Event.IPAddress
      description: IP address of the event.
      type: String
    - contextPath: CBP.Event.PolicyID
      description: Policy ID of the event.
      type: String
    - contextPath: CBP.Event.Timestamp
      description: Timestamp of the event.
      type: Date
    - contextPath: CBP.Event.Username
      description: Username related to the event.
      type: String
    - contextPath: CBP.Event.ComputerID
      description: ID of the event computer.
      type: String
    - contextPath: CBP.Event.ProcessFileName
      description: File name of the process.
      type: String
    - contextPath: CBP.Event.FileCatalogID
      description: ID of the file catalog.
      type: String
    - contextPath: CBP.Event.ProcessFileName
      description: File name of the process.
      type: String
    - contextPath: CBP.Event.IndicatorName
      description: Indicator name of the event.
      type: String
    - contextPath: CBP.Event.SubType
      description: ID of the subtype.
      type: Number
    - contextPath: CBP.Event.Type
      description: Type of the event.
      type: Number
    - contextPath: CBP.Event.ID
      description: ID of the event.
      type: Number
    - contextPath: CBP.Event.Description
      description: Description of the event.
      type: String
    - contextPath: CBP.Event.Severity
      description: Severity of the event.
      type: String
    - contextPath: CBP.Event.CommandLine
      description: Command line executed in the event.
      type: String
    - contextPath: CBP.Event.ProcessPathName
      description: Path name of the process.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the "offset" parameter is
        ignored. Note that some result sets might be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field. Example: group=osShortName'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute,
        where xyz is field name from the result set: &sort=xyz [ASC|DESC]. There can
        be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    description: 'Search for approval requests. For more information, see the Carbon
      Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#approvalrequest'
    name: cbp-approvalRequest-search
    outputs:
    - contextPath: CBP.ApprovalRequest.ID
      description: ID of the approval request.
      type: Number
    - contextPath: CBP.ApprovalRequest.ResolutionComments
      description: Comments added by the request resolver.
      type: String
    - contextPath: CBP.ApprovalRequest.Resolution
      description: 'Resolution of the request. Can be one of: 0=Not Resolved, 1=Rejected,
        2=Resolved - Approved, 3=Resolved - Rule Change, 4=Resolved - Installer, 5=Resolved
        - Updater, 6=Resolved - Publisher, 7=Resolved - Other.'
      type: Number
    - contextPath: CBP.ApprovalRequest.Status
      description: 'Request status. Can be one of: 1=New, 2=Open, 3=Closed, 4=Escalated.'
      type: Number
    - contextPath: CBP.ApprovalRequest.FileCatalogID
      description: ID of the fileCatalog entry associated with file for this event.
      type: Number
    - contextPath: CBP.ApprovalRequest.ComputerID
      description: ID of the computer entry associated with this analysis.
      type: Number
    - contextPath: CBP.ApprovalRequest.ComputerName
      description: Name of the computer associated with this event.
      type: String
    - contextPath: CBP.ApprovalRequest.DateCreated
      description: Date/time when the notifier was created (UTC).
      type: Date
    - contextPath: CBP.ApprovalRequest.CreatedBy
      description: User that created this notifier.
      type: String
    - contextPath: CBP.ApprovalRequest.EnforcementLevel
      description: 'Enforcement level of the agent at the time of the request. Can
        be one of: 20=High (Block Unapproved), 30=Medium (Prompt Unapproved), 40=Low
        (Monitor Unapproved), 60=None (Visibility), 80=None (Disabled).'
      type: Number
    - contextPath: CBP.ApprovalRequest.RequestorEmail
      description: Email address of the user that created this request.
      type: String
    - contextPath: CBP.ApprovalRequest.Priority
      description: 'Priority of this request. Can be one of: 0=High, 1=Medium, 2=Low.'
      type: Number
    - contextPath: CBP.ApprovalRequest.FileName
      description: Name of the file on the agent.
      type: String
    - contextPath: CBP.ApprovalRequest.PathName
      description: Path of the file on the agent.
      type: String
    - contextPath: CBP.ApprovalRequest.Process
      description: Process that attempted to execute the file on the agent (the full
        process path).
      type: String
    - contextPath: CBP.ApprovalRequest.Platform
      description: Platform of this approval request.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the offset parameter is ignored.
        Note that some result sets might be very large, resulting in query timeout.
        Therefore, unless you know that query will not return more than 1000 results,
        it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute
        where xyz is field name from the result set: &sort=xyz [ASC|DESC]. There can
        be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    - description: Id of fileCatalog entry associated with this fileRule. Can be null
        if file hasn’t been seen on any endpoints yet. You can get this by executing
        cbp-fileCatalog-search
      name: fileCatalogId
    - description: Name of this rule
      name: name
    - auto: PREDEFINED
      description: |-
        File state for this rule. Can be one of:
        1=Unapproved
        2=Approved
        3=Banned
      name: fileState
      predefined:
      - Unapproved
      - Approved
      - Banned
    - auto: PREDEFINED
      description: "Mechanism that created this rule. Can be one of: \n1 = Manual\n2
        = Trusted Directory\n3 = Reputation\n4 = Imported\n5 = External (API)\n6 =
        Event Rule\n7 = Application Template\n8 = Unified Management"
      name: sourceType
      predefined:
      - Manual
      - Trusted Directory
      - Reputation
      - Imported
      - External (API)
      - Event Rule
      - Application Template
      - Unified Management
    - description: Hash associated with this rule. Note that hash will be available
        only if rule was created through md5 or sha-1 hash. If rule was created through
        fileCatalogId or sha-256 hash that exists in the catalog, this field will
        be empty
      name: hash
    - description: File name associated with this rule. Note that file name will be
        available only if rule was created through file name. If rule was created
        through fileCatalogId or hash, this field will be empty
      name: fileName
    description: 'Search for file rules. For more information, see the Carbon Black
      documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filerule'
    name: cbp-fileRule-search
    outputs:
    - contextPath: CBP.FileRule.CatalogID
      description: The file catalog ID for the rule.
      type: String
    - contextPath: CBP.FileRule.Description
      description: Description of the rule.
      type: String
    - contextPath: CBP.FileRule.FileState
      description: The file state for the rule.
      type: String
    - contextPath: CBP.FileRule.Hash
      description: Hash for the rule.
      type: String
    - contextPath: CBP.FileRule.ID
      description: ID of the rule.
      type: String
    - contextPath: CBP.FileRule.Name
      description: Name of the rule.
      type: String
    - contextPath: CBP.FileRule.PolicyIDs
      description: Policies of which this rule is a part.
      type: String
    - contextPath: CBP.FileRule.ReportOnly
      description: Whether this rule is "reporting only, or also "enforcing".
      type: String
  - arguments:
    - default: true
      description: (Int) Unique ID of the file rule.
      name: id
      required: true
    description: 'Gets the file rule. For more information, see the Carbon Black documentation:
      https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filerule'
    name: cbp-fileRule-get
    outputs:
    - contextPath: CBP.FileRule.CatalogID
      description: The file catalog ID for the rule.
      type: String
    - contextPath: CBP.FileRule.Description
      description: Description of the rule.
      type: String
    - contextPath: CBP.FileRule.FileState
      description: The file state for the rule.
      type: String
    - contextPath: CBP.FileRule.Hash
      description: Hash for the rule.
      type: String
    - contextPath: CBP.FileRule.ID
      description: ID of the rule.
      type: String
    - contextPath: CBP.FileRule.Name
      description: Name of the rule.
      type: String
    - contextPath: CBP.FileRule.PolicyIDs
      description: Policies of which this rule is a part.
      type: String
    - contextPath: CBP.FileRule.ReportOnly
      description: Whether this rule is "reporting only, or also "enforcing".
      type: String
  - arguments:
    - default: true
      description: (Int) Unique id of this fileRule
      name: id
      required: true
    description: 'Deletes the file rule. For more information, see the Carbon Black
      documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filerule'
    name: cbp-fileRule-delete
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the "offset" parameter is
        ignored. Note that some result sets might be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute
        where xyz is field name from the result set: &sort=xyz [ASC|DESC]. There can
        be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    - auto: PREDEFINED
      description: |-
        Target enforcement level. Can be one of:
        20=High (Block Unapproved)
        30=Medium (Prompt Unapproved)
        40=Low (Monitor Unapproved)
        60=None (Visibility)
        80=None (Disabled)
      name: enforcementLevel
      predefined:
      - High (Block Unapproved)
      - Medium (Prompt Unapproved)
      - Low (Monitor Unapproved)
      - None (Visibility)
      - None (Disabled)
    - auto: PREDEFINED
      description: |-
        Target enforcement level for disconnected computers. Can be one of:
        20=High (Block Unapproved)
        30=Medium (Prompt Unapproved)
        40=Low (Monitor Unapproved)
        60=None (Visibility)
        80=None (Disabled)
      name: disconnectedEnforcementLevel
      predefined:
      - High (Block Unapproved)
      - Medium (Prompt Unapproved)
      - Low (Monitor Unapproved)
      - None (Visibility)
      - None (Disabled)
    description: 'Search for policies. For more information, see the Carbon Black
      documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#policy'
    name: cbp-policy-search
    outputs:
    - contextPath: CBP.Policy.ReadOnly
      description: Whether the policy "read-only".
      type: Boolean
    - contextPath: CBP.Policy.EnforcementLevel
      description: The level of enforcement of the policy.
      type: String
    - contextPath: CBP.Policy.ReputationEnabled
      description: Whether the reputation for the policy is enabled.
      type: Boolean
    - contextPath: CBP.Policy.AtEnforcementComputers
      description: Number of enforced computers.
      type: Number
    - contextPath: CBP.Policy.Automatic
      description: Whether the policy is automatic.
      type: Boolean
    - contextPath: CBP.Policy.Name
      description: Name of the policy.
      type: String
    - contextPath: CBP.Policy.FileTrackingEnabled
      description: Whether file tracking enabled for the policy.
      type: Boolean
    - contextPath: CBP.Policy.ConnectedComputers
      description: Number of connected computers associated with the policy.
      type: Number
    - contextPath: CBP.Policy.PackageName
      description: Package name of the policy.
      type: String
    - contextPath: CBP.Policy.AllowAgentUpgrades
      description: Whether the policy allows agent upgrades.
      type: Boolean
    - contextPath: CBP.Policy.TotalComputers
      description: Number of computers associated with the policy.
      type: Number
    - contextPath: CBP.Policy.LoadAgentInSafeMode
      description: Whether the agent should load in safe mode.
      type: Boolean
    - contextPath: CBP.Policy.AutomaticApprovalsOnTransition
      description: Approve on transition.
      type: String
    - contextPath: CBP.Policy.ID
      description: CBP internal ID of the policy.
      type: String
    - contextPath: CBP.Policy.Description
      description: Description of the policy.
      type: String
    - contextPath: CBP.Policy.DisconnectedEnforcementLevel
      description: The level of enforcement of the policy when disconnected.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching.'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the "offset" parameter is
        ignored. Note that some result sets might be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute
        where xyz is field name from the result set: &sort=xyz [ASC|DESC]. There can
        be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    description: 'Search in server configurations. For more information, see the Carbon
      Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#serverconfig.'
    name: cbp-serverConfig-search
    outputs:
    - contextPath: CBP.ServerConfig.ID
      description: CBP internal ID of the server configuration.
      type: String
    - contextPath: CBP.ServerConfig.Name
      description: Name of the server configuration.
      type: String
    - contextPath: CBP.ServerConfig.Value
      description: Value of the server configuration.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching.'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the "offset" parameter is ignored.
        If set to "0", all results will be returned, and the "offset" parameter is
        ignored. Note that some result sets might be very large, resulting in query
        timeout. Therefore, unless you know that query will not return more than 1000
        results, it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute
        where xyz is field name from the result set: &sort=xyz [ASC|DESC]. There can
        be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    - description: Subject name of leaf certificate for this publisher
      name: name
    - auto: PREDEFINED
      description: |-
        Reputation of this publisher. Can be one of:
        0=Not trusted (Unknown)
        1=Low
        2=Medium
        3=High
      name: publisherReputation
      predefined:
      - Not trusted (Unknown)
      - Low
      - Medium
      - High
    - auto: PREDEFINED
      description: |-
        State for this publisher. Can be one of:
        1=Unapproved
        2=Approved
        3=Banned
        4=Approved By Policy
        5=Banned By Policy
      name: publisherState
      predefined:
      - Unapproved
      - Approved
      - Banned
      - Approved By Policy
      - Banned By Policy
    description: 'Search for publishers. For more information, see the Carbon Black
      documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#publisher.'
    name: cbp-publisher-search
    outputs:
    - contextPath: CBP.Publisher.Description
      description: Description of the publisher.
      type: String
    - contextPath: CBP.Publisher.ID
      description: CBP internal ID of the publisher.
      type: String
    - contextPath: CBP.Publisher.Name
      description: Name of the publisher.
      type: String
    - contextPath: CBP.Publisher.Reputation
      description: Reputation of the publisher.
      type: String
    - contextPath: CBP.Publisher.SignedCertificatesCount
      description: Number of certificates from the publisher.
      type: Number
    - contextPath: CBP.Publisher.SignedFilesCount
      description: Number of signed files from publisher.
      type: Number
    - contextPath: CBP.Publisher.State
      description: The state of the publisher.
      type: String
  - arguments:
    - default: true
      description: (Int) Unique fileAnalysis ID.
      name: id
      required: true
    description: Returns the object instance of this class.
    name: cbp-fileAnalysis-get
    outputs:
    - contextPath: CBP.FileAnalysis.Priority
      description: File analysis priority.  Valid range is [-2, 2], where 2 is highest
        priority. Default priority is "0".
      type: Number
    - contextPath: CBP.FileAnalysis.PathName
      description: Path of the file on the endpoint.
      type: String
    - contextPath: CBP.FileAnalysis.ComputerId
      description: ID of the computer entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.DateModified
      description: Date/time when the fileAnalysis request was last modified (UTC).
      type: Date
    - contextPath: CBP.FileAnalysis.ID
      description: Unique fileAnalysis ID.
      type: String
    - contextPath: CBP.FileAnalysis.FileCatalogId
      description: ID of the fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.DateCreated
      description: Date/time when the fileAnalysis request was created (UTC).
      type: Date
    - contextPath: CBP.FileAnalysis.CreatedBy
      description: User that requested the analysis.
      type: String
    - contextPath: File.FileCatalogId
      description: ID ofthe fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.FileName
      description: Name of the file on the endpoint.
      type: String
    - contextPath: File.Malicious
      description: Vendor and description of the malicious file.
      type: String
    - contextPath: File.PathName
      description: Path of the file on the endpoint.
      type: Unknown
    - contextPath: File.Name
      description: ' Full file name, for example: "data.xls". '
      type: String
    - contextPath: File.SHA1
      description: SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: String
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor.
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
  - arguments:
    - description: (Int) ID of the fileCatalog entry for which analysis is requested.
        This value can be fetched via cbp-fileCatalog-search command.
      name: fileCatalogId
      required: true
    - description: (Int) ID of the target connector for the analysis. This value can
        be fetched via cbp-connector-search command.
      name: connectorId
      required: true
    - defaultValue: "0"
      description: (Int) ID of the computer from which to upload the file. If "0",
        the system will identify the best computer from which to get the file. This
        value can be fetched via cbp-computer-search command.
      name: computerId
    - defaultValue: "0"
      description: '(Int) The analysis priority (valid range: -2, 2), where "2" is
        highest priority. Default priority is "0".'
      name: priority
      predefined:
      - "-2"
      - "-1"
      - "0"
      - "1"
      - "2"
    - description: (Int) Status of the analysis. The status of an analysis that is
        in progress can be changed to "5" (Cancelled).
      name: analysisStatus
    - description: (String) Target of the analysis. It has to be one of possible analysisTarget
        options defined for the given connector object, or empty for connectors without
        defined analysisTargets.
      name: analysisTarget
    - description: If specified, will try to update the file analysis with this ID.
      name: id
    description: Creates or updates a file analysis request.
    name: cbp-fileAnalysis-createOrUpdate
    outputs:
    - contextPath: CBP.FileAnalysis.Priority
      description: 'File analysis priority in range (valid range: -2, 2), where "2"
        is highest priority. Default priority is "0".'
      type: Number
    - contextPath: CBP.FileAnalysis.PathName
      description: Path of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileAnalysis.ComputerID
      description: ID of the computer entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.DateModified
      description: Date/time when the fileAnalysis request was last modified (UTC).
      type: Date
    - contextPath: CBP.FileAnalysis.FileCatalogId
      description: ID of the fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.DateCreated
      description: Date/time when the fileAnalysis request was created (UTC).
      type: Date
    - contextPath: CBP.FileAnalysis.ID
      description: Unique fileAnalysis ID.
      type: String
    - contextPath: CBP.FileAnalysis.CreatedBy
      description: User that requested the analysis.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more informatoin, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the offset parameter is ignored.
        If set to "0", all results will be returned, and the offset parameter is ignored.
        Note that some result sets might be very large, resulting in query timeout.
        Therefore, unless you know that query will not return more than 1000 results,
        it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute:
        &sort=xyz [ASC|DESC], where xyz is the field name from the result set. There
        can be only one sorting field. Default sort order is ascending (ASC). '
      name: sort
    - description: Id of fileCatalog entry associated with this analysis. You can
        get this by executing cbp-fileCatalog-search
      name: fileCatalogId
    - description: Id of connector associated with this analysis. You can get this
        by executing cbp-connector-search
      name: connectorId
    - description: |
        Name of the file where file exists on the endpoint
      name: fileName
    - auto: PREDEFINED
      description: |-
        Status of analysis. Can be one of:
        0 = scheduled
        1 = submitted (file is sent for analysis)
        2 = processed (file is processed but results are not available yet)
        3 = analyzed (file is processed and results are available)
        4 = error
        5 = cancelled
      name: analysisStatus
      predefined:
      - scheduled
      - submitted (file is sent for analysis)
      - processed (file is processed but results are not available yet)
      - analyzed (file is processed and results are available)
      - error
      - cancelled
    - auto: PREDEFINED
      description: |-
        Result of the analysis. Can be one of:
        0 = Not yet available
        1 = File is clean
        2 = File is a potential threat
        3 = File is malicious
      name: analysisResult
      predefined:
      - Not yet available
      - File is clean
      - File is a potential threat
      - File is malicious
    description: Returns objects that match the specified criteria.
    name: cbp-fileAnalysis-search
    outputs:
    - contextPath: CBP.FileAnalysis.Priority
      description: 'File analysis priority in range (valid range: -2, 2), where "2"
        is highest priority. Default priority is "0".'
      type: Number
    - contextPath: CBP.FileAnalysis.PathName
      description: Path of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileAnalysis.ComputerID
      description: ID of the computer entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.DateModified
      description: Date/time when the fileAnalysis request was last modified (UTC).
      type: Date
    - contextPath: CBP.FileAnalysis.FileCatalogId
      description: ID of the fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileAnalysis.DateCreated
      description: Date/time when the fileAnalysis request was created (UTC).
      type: Date
    - contextPath: CBP.FileAnalysis.ID
      description: Unique fileAnalysis ID.
      type: String
    - contextPath: CBP.FileAnalysis.CreatedBy
      description: User that requested this analysis.
      type: String
  - arguments:
    - default: true
      description: (Int) Unique ID of this fileUpload.
      name: id
      required: true
    description: Returns the object instance of this class.
    name: cbp-fileUpload-get
    outputs:
    - contextPath: CBP.FileUpload.Priority
      description: 'File analysis priority in range (valid range: -2, 2), where "2"
        is highest priority. Default priority is "0".'
      type: Number
    - contextPath: CBP.FileUpload.FileName
      description: Name of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileUpload.UploadPath
      description: Local upload path for the file on the server (can be a shared network
        path). Note that the file is compressed in a ZIP archive.
      type: String
    - contextPath: CBP.FileUpload.ComputerId
      description: ID of the computer entry associated with this analysis.
      type: String
    - contextPath: CBP.FileUpload.DateModified
      description: Date/time when the fileAnalysis request was last modified (UTC).
      type: Date
    - contextPath: CBP.FileUpload.ID
      description: Unique fileAnalysis ID.
      type: String
    - contextPath: CBP.FileUpload.FileCatalogId
      description: ID of the fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileUpload.DateCreated
      description: Date/time when the fileAnalysis request was created (UTC).
      type: Date
    - contextPath: CBP.FileUpload.PathName
      description: Path of the file where there file exists on the endpoint.
      type: String
    - contextPath: CBP.FileUpload.UploadStatus
      description: 'Status of the upload (valid range: 0-6).'
      type: Number
    - contextPath: CBP.FileUpload.UploadedFileSize
      description: Size of the uploaded file. The file size will be 0 unless the uploadStatus
        is "3" (Completed).
      type: String
    - contextPath: CBP.FileUpload.CreatedBy
      description: User that requested the analysis.
      type: String
  - arguments:
    - default: true
      description: (Int) Unique ID of the fileUpload.
      name: id
      required: true
    description: Returns the bject instance of this class.
    name: cbp-fileUpload-download
  - arguments:
    - description: (Int) ID of the fileCatalog entry for file to upload. This value
        can be fetched via cbp-fileCatalog-search command.
      name: fileCatalogId
      required: true
    - defaultValue: "0"
      description: (Int) ID of the computer entry associated with this analysis. This
        value can be fetched via cbp-computer-search command.
      name: computerId
    - auto: PREDEFINED
      description: 'File analysis priority in range (valid range: -2, 2), where "2"
        is highest priority. Default priority is "0".'
      name: priority
      predefined:
      - "-2"
      - "-1"
      - "0"
      - "1"
      - "2"
    - description: (Int)Status of upload. The status of "upload in progress" can be
        changed to "5" (Cancelled). Any upload can be changed to "6" (Deleted).
      name: uploadStatus
    - description: ID of the file upload to update. If omitted, will create a new
        file upload.
      name: id
    description: Creates or updates a file upload request.
    name: cbp-fileUpload-createOrUpdate
    outputs:
    - contextPath: CBP.FileUpload.Priority
      description: 'File analysis priority in range (valid range: -2, 2), where "2"
        is highest priority. Default priority is "0".'
      type: Number
    - contextPath: CBP.FileUpload.CreatedByUserId
      description: ID of the user that requested the analysis.
      type: String
    - contextPath: CBP.FileUpload.UploadPath
      description: Local upload path for this file on the server (can be a shared
        network path). Note that the file is compressed in a ZIP archive.
      type: String
    - contextPath: CBP.FileUpload.FileName
      description: Name of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileUpload.PathName
      description: Path of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileUpload.UploadStatus
      description: 'Status of the upload (valid range: 0-6).'
      type: Number
    - contextPath: CBP.FileUpload.ComputerID
      description: ID of the computer entry associated with this analysis.
      type: String
    - contextPath: CBP.FileUpload.DateModified
      description: Date/time when the fileAnalysis request was last modified (UTC).
      type: Date
    - contextPath: CBP.FileUpload.FileCatalogId
      description: ID of the fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileUpload.DateCreated
      description: Date/time when the fileAnalysis request was created (UTC).
      type: Date
    - contextPath: CBP.FileUpload.ID
      description: Unique fileAnalysis ID.
      type: String
    - contextPath: CBP.FileUpload.UploadedFileSize
      description: Size of uploaded file. The file size will be 0 unless the uploadStatus
        is "3" (Completed).
      type: Number
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the offset parameter is ignored.
        If set to "0", all results will be returned, and the offset parameter is ignored.
        Note that some result sets might be very large, resulting in query timeout.
        Therefore, unless you know that query will not return more than 1000 results,
        it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute:
        &sort=xyz [ASC|DESC], where xyz is the field name from the result set. There
        can be only one sorting field. Default sort order is ascending (ASC).'
      name: sort
    - description: Id of computer entry associated with this analysis. This can be
        fetched via cbp-computer-search
      name: computerId
    - description: Id of fileCatalog entry associated with this upload. This can be
        fetched via cbp-fileCatalog-search
      name: fileCatalogId
    - description: Name of the file where file exists on the endpoint
      name: fileName
    - auto: PREDEFINED
      description: |-
        Status of upload. Can be one of:
        0 = Queued
        1 = Initiated
        2 = Uploading
        3 = Completed
        4 = Error
        5 = Cancelled
        6 = Deleted
      name: uploadStatus
      predefined:
      - Queued
      - Initiated
      - Uploading
      - Completed
      - Error
      - Cancelled
      - Deleted
    description: Returns objects that match the specified criteria.
    name: cbp-fileUpload-search
    outputs:
    - contextPath: CBP.FileUpload.Priority
      description: 'File analysis priority in range (valid range: -2, 2), where "2"
        is highest priority. Default priority is "0".'
      type: Number
    - contextPath: CBP.FileUpload.CreatedByUserId
      description: ID of the user that requested the analysis.
      type: String
    - contextPath: CBP.FileUpload.UploadPath
      description: Local upload path for this file on the server (can be a shared
        network path). Note that the file is compressed in a ZIP archive.
      type: String
    - contextPath: CBP.FileUpload.FileName
      description: Name of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileUpload.PathName
      description: Path of the file where the file exists on the endpoint.
      type: String
    - contextPath: CBP.FileUpload.UploadStatus
      description: 'Status of upload (valid range: 0-6).'
      type: Number
    - contextPath: CBP.FileUpload.ComputerID
      description: ID of the computer entry associated with this analysis.
      type: String
    - contextPath: CBP.FileUpload.DateModified
      description: Date/time when the fileAnalysis request was last modified (UTC).
      type: Date
    - contextPath: CBP.FileUpload.FileCatalogId
      description: ID of the fileCatalog entry associated with this analysis.
      type: String
    - contextPath: CBP.FileUpload.DateCreated
      description: Date/time when the fileAnalysis request was created (UTC).
      type: Date
    - contextPath: CBP.FileUpload.ID
      description: Unique fileAnalysis ID.
      type: String
    - contextPath: CBP.FileUpload.UploadedFileSize
      description: Size of the uploaded file. The file size will be 0 unless the uploadStatus
        is "3" (Completed).
      type: Number
  - arguments:
    - default: true
      description: (Int) Unique connector ID.
      name: id
      required: true
    description: Returns the object instance of this class.
    name: cbp-connector-get
    outputs:
    - contextPath: CBP.Connector.AnalysisEnabled
      description: '"True" if the analysis component of this connector is enabled.
        "False" if the analysis component of this connector is disabled.'
      type: Boolean
    - contextPath: CBP.Connector.AnalysisName
      description: Name for the analysis component of the connector (can be same as
        the name field).
      type: String
    - contextPath: CBP.Connector.AnalysisTargets
      description: Array of possible analysis targets. Analysis targets are required
        when creating a new fileAnalysis. They usualy represent different OS and configurations
        and are available only for some internal connectors.
      type: String
    - contextPath: CBP.Connector.CanAnalyze
      description: '"True" if this connector can analyze files. "False" if this connector
        cannot analyze files.'
      type: Boolean
    - contextPath: CBP.Connector.ConnectorVersion
      description: Version of this connector.
      type: String
    - contextPath: CBP.Connector.Enabled
      description: '"True" if the connector is enabled. "False" if the connector is
        disabled.'
      type: Boolean
    - contextPath: CBP.Connector.ID
      description: Unique fileAnalysis ID.
      type: String
  - arguments:
    - description: 'A condition contains three parts: name, operator and value. Name
        is any valid field in the object that is being queried. Operator (: LIKE,
        ! NOT LIKE, < Less than, > Greater than, + logical AND, - logical OR, | separating
        values) is any of valid operators (see below). All operators consist of a
        single character. Value is compared with operator and depends on field type.
        For more information, see the Carbon Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#searching.'
      name: query
    - description: (Int) Maximum number of results to retrieve. If not specified,
        the first 1000 results will be returned. If set to "-1", only the result count
        will be returned, without actual results, and the offset parameter is ignored.
        If set to "0", all results will be returned, and the offset parameter is ignored.
        Note that some result sets might be very large, resulting in query timeout.
        Therefore, unless you know that query will not return more than 1000 results,
        it is recommended to retrieve data in chunks using offset and limit.
      name: limit
    - description: (Int) Offset in the data set.
      name: offset
    - description: 'Grouping is optional and can be defined with a single attribute:
        &group=xyz. There can be only one grouping field, for example: group=osShortName.'
      name: group
    - description: 'Sorting is optional and can be defined with a single attribute
        where xyz is the field name from the result set: &sort=xyz [ASC|DESC]. There
        can be only one sorting field. Default sort order is ascending (ASC).'
      name: sort
    description: Returns objects that match the specified criteria.
    name: cbp-connector-search
    outputs:
    - contextPath: CBP.Connector.AnalysisEnabled
      description: '"True" if the analysis component of this connector is enabled.
        "False" if the analysis component of this connector is disabled.'
      type: Boolean
    - contextPath: CBP.Connector.AnalysisName
      description: Name for the analysis component of the connector (can be same as
        the name field).
      type: String
    - contextPath: CBP.Connector.AnalysisTargets
      description: Array of possible analysis targets. Analysis targets are required
        when creating a new fileAnalysis. They usualy represent different OS and configurations
        and are available only for some internal connectors.
      type: String
    - contextPath: CBP.Connector.CanAnalyze
      description: '"True" if this connector can analyze files. "False" if this connector
        cannot analyze files.'
      type: Boolean
    - contextPath: CBP.Connector.ConnectorVersion
      description: Version of this connector.
      type: String
    - contextPath: CBP.Connector.Enabled
      description: '"True" if the connector is enabled. "False" if the connector is
        disabled.'
      type: Boolean
    - contextPath: CBP.Connector.ID
      description: Unique fileAnalysis ID.
      type: String
  - arguments:
    - default: true
      description: ID of the approval request to update
      name: id
      required: true
    - auto: PREDEFINED
      description: |-
        Resolution of the request. Resolution can be changed for open requests or
        closed requests only. It can be one of:
        0=Not Resolved
        1=Rejected
        2=Resolved - Approved
        3=Resolved - Rule Change4=Resolved - Installer
        5=Resolved - Updater
        6=Resolved - Publisher
        7=Resolved - Other
      name: resolution
      predefined:
      - Rejected
      - Resolved - Approved
      - Resolved - Rule Change4=Resolved - Installer
      - Resolved - Updater
      - Resolved - Publisher
      - Resolved - Other
      required: true
    - description: Email address of the user that created this request.
      name: requestorEmail
    - description: Comments added by the user that resolved the request.
      name: resolutionComments
    - auto: PREDEFINED
      description: 'Request status. Can be one of: 1=New, 2=Open, 3=Closed, 4=Escalated.
        Prohibited transitions are from any status back to 0 or 1.'
      name: status
      predefined:
      - New
      - Open
      - Closed
      - Escalated
    description: Resolves a file approval request.
    name: cbp-approvalRequest-resolve
    outputs:
    - contextPath: CBP.ApprovalRequest.ID
      description: ID of the approval request.
      type: Number
    - contextPath: CBP.ApprovalRequest.ResolutionComments
      description: Comments added by the user that resolved the request.
      type: String
    - contextPath: CBP.ApprovalRequest.Resolution
      description: 'Resolution of request. Can be one of: 0=Not Resolved, 1=Rejected,
        2=Resolved - Approved, 3=Resolved - Rule Change, 4=Resolved - Installer, 5=Resolved
        - Updater, 6=Resolved - Publisher, 7=Resolved - Other'
      type: Number
    - contextPath: CBP.ApprovalRequest.Status
      description: 'Request status. Can be one of: 1=New, 2=Open, 3=Closed, 4=Escalated'
      type: Number
  - arguments:
    - description: (String) Hash associated with this rule. This parameter is not
        required if fileCatalogId is supplied.
      name: hash
    - auto: PREDEFINED
      description: '(Int) File state for this rule. Can be one of: 1=Unapproved 2=Approved
        3=Banned'
      name: fileState
      predefined:
      - "1"
      - "2"
      - "3"
      required: true
    - description: (Int) Unique id of this fileRule
      name: id
    - description: (Int) ID of the fileCatalog entry associated with this fileRule.
        Can be "0" if creating or modifying the rule based on the hash or file name.
      name: fileCatalogId
    - description: (String) Name of this rule.
      name: name
    - description: (String) Description of this rule.
      name: description
    - auto: PREDEFINED
      description: '(Boolean) If "true", creates a report-only ban. Note: fileState
        has to be set to "1" (unapproved) before this flag can be set.'
      name: reportOnly
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: (Boolean) "True" if reputation approvals are enabled for this file.
        "False" if reputation approvals are disabled for this file.
      name: 'reputationApprovalsEnabled '
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: (Boolean) "True" if this file is forced to act as installer, even
        if the product detected it as ‘not installer’.
      name: forceInstaller
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: (Boolean) "True" if this file is forced to act as ‘not installer’,
        even if the product detected it as installer.
      name: forceNotInstaller
      predefined:
      - "true"
      - "false"
    - description: (String) List of IDs of policies to which this rule applies. Set
        to "0" if this is a global rule.
      name: policyIds
    - description: '(Int) Set of platform flags where this file rule will be valid.
        Combination of: 1 = Windows 2 = Mac 4 = Linux.'
      name: platformFlags
    - description: Headers to present of the returned table.
      name: headers
    deprecated: true
    description: 'Creates or updates file rule. See more: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filerule'
    name: cbp-fileRule-update
    outputs:
    - contextPath: CBP.FileRule.CatalogID
      description: The file catalog ID for the rule.
      type: String
    - contextPath: CBP.FileRule.Description
      description: The rule description.
      type: String
    - contextPath: CBP.FileRule.FileState
      description: The file state for the rule.
      type: String
    - contextPath: CBP.FileRule.Hash
      description: The hash for the rule.
      type: String
    - contextPath: CBP.FileRule.ID
      description: The rule ID.
      type: String
    - contextPath: CBP.FileRule.Name
      description: The rule name.
      type: String
    - contextPath: CBP.FileRule.PolicyIDs
      description: The policies this rule belongs to.
      type: String
    - contextPath: CBP.FileRule.ReportOnly
      description: Whether this rule "reporting only" or is also "enforcing".
      type: String
  - arguments:
    - description: (String) Hash associated with this rule. This parameter is not
        required if the fileCatalogId is supplied.
      name: hash
    - auto: PREDEFINED
      description: '(Int) File state for this rule. Can be one of: 1=Unapproved 2=Approved
        3=Banned.'
      name: fileState
      predefined:
      - "1"
      - "2"
      - "3"
      required: true
    - description: (Int) Unique ID of this fileRule.
      name: id
    - description: (Int) ID of the fileCatalog entry associated with this fileRule.
        Can be "0" if creating or modifying the rule based on the hash or file name.
        This value can be fetched via cbp-fileCatalog-search command.
      name: fileCatalogId
    - description: (String) Name of this rule.
      name: name
    - description: (String) Description of this rule.
      name: description
    - auto: PREDEFINED
      description: '(Boolean) Set to "true" to create a report-only ban. Note: fileState
        has to be set to "1" (unapproved) before this flag can be set.'
      name: reportOnly
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: (Boolean) "True" if reputation approvals are enabled for this file.
        "False" if reputation approvals are disabled for this file.
      name: 'reputationApprovalsEnabled '
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: (Boolean) "True" if this file is forced to act as installer, even
        if the product detected it as ‘not installer’.
      name: forceInstaller
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: (Boolean) "True" if this file is forced to act as ‘not installer’,
        even if the product detected it as installer.
      name: forceNotInstaller
      predefined:
      - "true"
      - "false"
    - description: (String) List of IDs of policies to which this rule applies. Set
        to "0" if this is a global rule.
      name: policyIds
    - description: '(Int) Set of platform flags where this file rule will be valid.
        combination of: 1 = Windows 2 = Mac 4 = Linux.'
      name: platformFlags
    - description: Headers to present of the returned table.
      name: headers
    description: 'Creates or updates a file rule. For more information, see the Carbon
      Black documentation: https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filerule'
    name: cbp-fileRule-createOrUpdate
    outputs:
    - contextPath: CBP.FileRule.CatalogID
      description: The file catalog ID for the rule.
      type: String
    - contextPath: CBP.FileRule.Description
      description: The rule description.
      type: String
    - contextPath: CBP.FileRule.FileState
      description: The file state for the rule.
      type: String
    - contextPath: CBP.FileRule.Hash
      description: The hash for the rule.
      type: String
    - contextPath: CBP.FileRule.ID
      description: The rule ID.
      type: String
    - contextPath: CBP.FileRule.Name
      description: The rule name.
      type: String
    - contextPath: CBP.FileRule.PolicyIDs
      description: The policies this rule belongs to.
      type: String
    - contextPath: CBP.FileRule.ReportOnly
      description: Is this rule "reporting only" or is it also "enforcing".
      type: String
  dockerimage: demisto/python3:3.7.3.221
  isfetch: true
  runonce: false
  script: |2-



    ''' IMPORTS '''

    import json
    import requests

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    TOKEN = demisto.params().get('token')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params().get('url') and demisto.params()['url'].endswith('/')) \
        else demisto.params().get('url')
    BASE_URL = f'{SERVER}/api/bit9platform/v1'
    # Should we use SSL
    USE_SSL = not demisto.params().get('insecure', False)
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    CB_TIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'
    CB_NO_MS_TIME_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    INCIDENTS_PER_FETCH = int(demisto.params().get('max_incidents_per_fetch', 15))
    # Headers to be sent in requests
    HEADERS = {
        'X-Auth-Token': TOKEN,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }


    ''' HUMAN READABLE HEADERS '''


    APPROVAL_REQUEST_HEADERS = [
        'ID',
        'FileName',
        'Status',
        'DateCreated',
        'Platform'
    ]


    COMPUTER_HEADERS = [
        'ID',
        'Hostname',
        'IPAddress',
        'MACAddress',
        'OSVersion',
        'Processor',
        'Processors',
        'Model'
    ]


    CONNECTOR_HEADERS = [
        'ID',
        'AnalysisName',
        'Enabled',
        'AnalysisEnabled',
        'AnalysisTargets',
        'CanAnalyze',
        'ConnectorVersion'
    ]


    EVENT_HEADERS = [
        'ID',
        'Type',
        'SubType',
        'Severity',
        'Description'
    ]


    FILE_ANALYSIS_HEADERS = [
        'ID',
        'PathName',
        'Priority',
        'FileCatalogId',
        'ComputerID',
        'DateCreated',
        'DateModified',
        'CreatedBy'
    ]


    FILE_CATALOG_HEADERS = [
        'ID',
        'Name',
        'Type',
        'Extension',
        'Path',
        'Size'
        'ProductName',
        'Publisher',
        'Company'
    ]


    FILE_INSTANCE_HEADERS = [
        'ID',
        'Name',
        'Path',
        'ComputerID',
        'CatalogID'
    ]


    FILE_RULE_HEADERS = [
        'ID',
        'Name',
        'Description',
        'PolicyIDs',
        'FileState',
        'CatalogID',
        'Hash',
        'ReportOnly'
    ]


    FILE_UPLOAD_HEADERS = [
        'ID',
        'PathName',
        'UploadPath',
        'UploadStatus',
        'DateCreated',
        'DateModified',
        'UploadedFileSize',
        'ComputerId',
        'Priority',
        'CreatedBy'
    ]

    POLICY_HEADERS = [
        'ID',
        'Name',
        'PackageName',
        'Description',
        'EnforcementLevel'
    ]

    PUBLISHER_HEADERS = [
        'ID',
        'Name',
        'Description',
        'Reputation',
        'State',
        'SignedCertificatesCount',
        'SignedFilesCount'
    ]

    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, params=None, data=None, headers=HEADERS, safe=False, parse_json=True):
        """
            A wrapper for requests lib to send our requests and handle requests and responses better.

            :type method: ``str``
            :param method: HTTP method for the request.

            :type url_suffix: ``str``
            :param url_suffix: The suffix of the URL (endpoint)

            :type params: ``dict``
            :param params: The URL params to be passed.

            :type data: ``dict``
            :param data: The body data of the request.

            :type headers: ``dict``
            :param headers: Request headers

            :type safe: ``bool``
            :param safe: If set to true will return None in case of error

            :return: Returns the http request response json
            :rtype: ``dict`` or ``str``
        """
        url = BASE_URL + url_suffix
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                json=data,
                headers=headers,
            )
        except requests.exceptions.RequestException as e:
            LOG(str(e))
            return_error('Error in connection to the server. Please make sure you entered the URL correctly.')
        # Handle error responses gracefully
        if res.status_code not in {200, 201}:
            if safe:
                return None
            elif res.status_code == 401:
                reason = 'Unauthorized. Please check your API token'
            else:
                try:
                    reason = res.json()
                except ValueError:
                    reason = res.reason
            return_error(f'Error in API call status code: {res.status_code}, reason: {reason}')
        if parse_json:
            return res.json()
        return res.content


    def remove_prefix(prefix, full_str):
        """
        Removes prefix from beginning of full_str if found
        :param prefix: Prefix to remove from full_str
        :param full_str: String to have its prefix removed
        :return: full_str without the provided prefix
        """
        if full_str.startswith(prefix):
            return full_str[len(prefix):]
        return full_str


    def event_severity_to_dbot_score(severity):
        """
            Converts an severity int to DBot score representation
            Event severity. Can be one of:
            2 = Critical    -> 3
            3 = Error       -> 0
            4 = Warning     -> 2
            5 = Notice      -> 2
            6 = Info        -> 0
            7 = Debug       -> 0

            :type severity: ``int``
            :param severity: Int representation of a severity

            :return: DBot score representation of the severity
            :rtype ``int``
        """
        severity = int(severity)
        if severity == 2:
            return 3
        elif severity in (4, 5):
            return 2
        return 0


    def cbp_date_to_timestamp(date):
        """
        Converts a date in carbon black's format to timestamp
        :param date: Date string in cbp date format
        :return: Timestamp of the given date
        """
        try:
            ts = date_to_timestamp(date, date_format=CB_TIME_FORMAT)
        except ValueError:
            ts = date_to_timestamp(date, date_format=CB_NO_MS_TIME_FORMAT)
        return ts


    def event_to_incident(event):
        """
            Creates an incident of a detection.

            :type event: ``dict``
            :param event: Single event object

            :return: Incident representation of an event
            :rtype ``dict``
        """
        incident = {
            'name': event.get('description'),
            'occurred': str(event.get('timestamp')),
            'rawJSON': json.dumps(event),
            'severity': event_severity_to_dbot_score(event.get('severity'))
        }
        return incident


    def remove_keys_with_empty_value(dict_with_params):
        """
        Removes from dict keys with empty values
        :param dict_with_params: dict to remove empty keys from
        :return: dict without any empty fields
        """
        return {k: v for k, v in dict_with_params.items() if v}


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Performs basic get request to get item samples
        """
        http_request('GET', '/computer?limit=-1')


    def search_file_catalog_command():
        """
        Searches for file catalog
        :return: EntryObject of the file catalog
        """
        args = demisto.args()
        raw_catalogs = search_file_catalog(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                           args.get('group'), args.get('fileName'), args.get('fileType'),
                                           args.get('computerId'), args.get('threat'), args.get('fileState'),
                                           args.get('hash'))
        headers = args.get('headers', FILE_CATALOG_HEADERS)
        catalogs = []
        for catalog in raw_catalogs:
            catalogs.append({
                'Size': catalog.get('fileSize'),
                'Path': catalog.get('pathName'),
                'SHA1': catalog.get('sha1'),
                'SHA256': catalog.get('sha256'),
                'MD5': catalog.get('md5'),
                'Name': catalog.get('fileName'),
                'Type': catalog.get('fileType'),
                'ProductName': catalog.get('productName'),
                'ID': catalog.get('id'),
                'Publisher': catalog.get('publisher'),
                'Company': catalog.get('company'),
                'Extension': catalog.get('fileExtension')
            })
        hr_title = "CarbonBlack Protect File Catalog Search"
        hr = tableToMarkdown(hr_title, catalogs, headers, removeNull=True, headerTransform=pascalToSpace)
        catalogs = {'File(val.SHA1 === obj.SHA1)': catalogs} if catalogs else None
        return_outputs(hr, catalogs, raw_catalogs)


    @logger
    def search_file_catalog(q=None, limit=None, offset=None, sort=None, group=None, file_name=None, file_type=None,
                            computer_id=None, threat=None, file_state=None, hash_value=None):
        """
        Sends the request for file catalog, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the catalogs to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param file_name: Name of the file under which this unique hash was first seen
        :param file_type: Type of the file
        :param computer_id: Id of computer where this file was first seen
        :param threat: Threat of this file
        :param file_state: File state of this hash
        :param hash_value: Hash of the file
        :return: File catalog response json
        """

        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if file_name:
            url_params['q'].append(f'fileName:{file_name}')
        if file_type:
            url_params['q'].append(f'fileType:{file_type}')
        if computer_id:
            url_params['q'].append(f'computerId:{computer_id}')
        if threat:
            url_params['q'].append(f'threat:{file_catalog_threat_to_int(threat)}')
        if file_state:
            url_params['q'].append(f'fileState:{file_catalog_file_state_to_int(file_state)}')
        if hash_value:
            hash_type = get_hash_type(hash_value)
            if hash_type != 'Unknown':
                url_params['q'].append(f'{hash_type}:{hash_value}')

        return http_request('GET', '/fileCatalog', params=url_params)


    @logger
    def file_catalog_threat_to_int(threat):
        """
        Threat of this file. Can be one of:
        -1=Unknown
        0=Clean
        50=Potential risk
        100=Malicious
        :param threat:
        :return:
        """
        threat_dict = {
            'Unknown': -1,
            'Clean': 0,
            'Potential risk': 50,
            'Malicious': 100
        }
        return threat_dict.get(threat, threat)


    @logger
    def file_catalog_file_state_to_int(file_state):
        """
        File state of this hash. Can be one of:
        1=Unapproved
        2=Approved
        3=Banned
        4=Approved by Policy
        5=Banned by Policy
        :param file_state: String value of file state
        :return:
        """
        file_state_dict = {
            'Unapproved': 1,
            'Approved': 2,
            'Banned': 3,
            'Approved by Policy': 4,
            'Banned by Policy': 5
        }
        return file_state_dict.get(file_state, file_state)


    def search_computer_command():
        """
        Searches for file catalog
        :return: EntryObject of the computer
        """
        args = demisto.args()
        raw_computers = search_computer(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                        args.get('group'), args.get('name'), args.get('ipAddress'), args.get('macAddress'))
        headers = args.get('headers', COMPUTER_HEADERS)
        computers = []
        for computer in raw_computers:
            computers.append({
                'Memory': computer.get('memorySize'),
                'Processors': computer.get('processorCount'),
                'Processor': computer.get('processorModel'),
                'OS': computer.get('osShortName'),
                'OSVersion': computer.get('osName'),
                'MACAddress': computer.get('macAddress'),
                'Model': computer.get('machineModel'),
                'IPAddress': computer.get('ipAddress'),
                'Hostname': computer.get('name'),
                'ID': computer.get('id')
            })
        hr_title = "CarbonBlack Protect Computer Search"
        hr = tableToMarkdown(hr_title, computers, headers, removeNull=True, headerTransform=pascalToSpace)
        computers = {'Endpoint(val.ID === obj.ID)': computers} if computers else None
        return_outputs(hr, computers, raw_computers)


    @logger
    def search_computer(q=None, limit=None, offset=None, sort=None, group=None, name=None, ip_address=None, mac=None):
        """
        Sends the request for file catalog, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the computers to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param name: Computer name
        :param ip_address: Last known IP address of this computer
        :param mac: MAC address of adapter used to connect to the CB Protection Server
        :return: Computer response json
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if name:
            url_params['q'].append(f'name:{name}')
        if ip_address:
            url_params['q'].append(f'ipAddress:{ip_address}')
        if mac:
            url_params['q'].append(f'macAddress:{mac}')

        return http_request('GET', '/Computer', params=url_params)


    def update_computer_command():
        """
        Updates computer
        :return: EntryObject of the computer
        """
        args = demisto.args()
        raw_computers = update_computer(
            args.get('id'),
            args.get('name'),
            args.get('computerTag'),
            args.get('description'),
            args.get('policyId'),
            args.get('automaticPolicy'),
            args.get('localApproval'),
            args.get('refreshFlags'),
            args.get('prioritized'),
            args.get('debugLevel'),
            args.get('kernelDebugLevel'),
            args.get('debugFlags'),
            args.get('debugDuration'),
            args.get('cCLevel'),
            args.get('cCFlags'),
            args.get('forceUpgrade'),
            args.get('template'),
        )
        computers = {
            'Memory': raw_computers.get('memorySize'),
            'Processors': raw_computers.get('processorCount'),
            'Processor': raw_computers.get('processorModel'),
            'OS': raw_computers.get('osShortName'),
            'OSVersion': raw_computers.get('osName'),
            'MACAddress': raw_computers.get('macAddress'),
            'Model': raw_computers.get('machineModel'),
            'IPAddress': raw_computers.get('ipAddress'),
            'Hostname': raw_computers.get('name'),
            'ID': raw_computers.get('id')
        }
        hr = tableToMarkdown('CarbonBlack Protect computer updated successfully', computers, COMPUTER_HEADERS)
        return_outputs(hr, {'Endpoint(val.ID === obj.ID)': computers}, raw_computers)


    @logger
    def update_computer(id, name, computer_tag, description, policy_id, automatic_policy, local_approval, refresh_flags,
                        prioritized, debug_level, kernel_debug_level, debug_flags, debug_duration, cclevel, ccflags,
                        force_upgrade, template):
        """
        Update computer

        :param id: id of computer
        :param name: name of computer
        :param computer_tag: computer tag of computer
        :param description: description of computer
        :param policy_id: policy id of the computer
        :param automatic_policy: automatic policy flag
        :param local_approval: local approval flag
        :param refresh_flags: refresh flags
        :param prioritized: Is prioritized
        :param debug_level: debug level of computer
        :param kernel_debug_level: kernel debug level of computer
        :param debug_flags: debug flags
        :param debug_duration: debug duration of computer
        :param cclevel: cache consistency check level set for agent
        :param ccflags: cache consistency check flags set for agent
        :param force_upgrade: True if upgrade is forced for this computer
        :param template: True if computer is a template
        :return: Result json of the request
        """
        body_params = {
            'id': id,
            'name': name,
            'computerTag': computer_tag,
            'description': description,
            'policyId': policy_id,
            'automaticPolicy': automatic_policy,
            'localApproval': local_approval,
            'refreshFlags': refresh_flags,
            'prioritized': prioritized,
            'debugLevel': debug_level,
            'kernelDebugLevel': kernel_debug_level,
            'debugFlags': debug_flags,
            'debugDuration': debug_duration,
            'cCLevel': cclevel,
            'cCFlags': ccflags,
            'forceUpgrade': force_upgrade,
            'template': template,
        }
        body_params = remove_keys_with_empty_value(body_params)

        return http_request('POST', '/computer', data=body_params)


    def get_computer_command():
        """
        Gets the requested computer
        :return: EntryObject of the file catalog
        """
        args = demisto.args()
        id = args.get('id')
        raw_computer = get_computer(id)
        computer = {
            'Memory': raw_computer.get('memorySize'),
            'Processors': raw_computer.get('processorCount'),
            'Processor': raw_computer.get('processorModel'),
            'OS': raw_computer.get('osShortName'),
            'OSVersion': raw_computer.get('osName'),
            'MACAddress': raw_computer.get('macAddress'),
            'Model': raw_computer.get('machineModel'),
            'IPAddress': raw_computer.get('ipAddress'),
            'Hostname': raw_computer.get('name'),
            'ID': raw_computer.get('id')
        }
        headers = args.get('headers', COMPUTER_HEADERS)
        hr_title = f'CarbonBlack Protect Computer Get for {id}'
        hr = tableToMarkdown(hr_title, computer, headers, removeNull=True, headerTransform=pascalToSpace)
        entry_context_computer = {'Endpoint(val.ID === obj.ID)': computer} if computer else None
        return_outputs(hr, entry_context_computer, raw_computer)


    @logger
    def get_computer(id):
        """
        Sends get computer request
        :param id: Computer ID
        :return: Result json of the request
        """
        url = f'/Computer/{id}'
        return http_request('GET', url)


    def search_file_instance_command():
        """
        Searches for file instance
        :return: EntryObject of the file instance
        """
        args = demisto.args()
        raw_files = search_file_instance(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                         args.get('group'), args.get('computerId'), args.get('fileName'))
        headers = args.get('headers', FILE_INSTANCE_HEADERS)
        files = []
        if raw_files:
            for file in raw_files:
                files.append({
                    'CatalogID': file.get('fileCatalogId'),
                    'ComputerID': file.get('computerId'),
                    'ID': file.get('id'),
                    'Name': file.get('fileName'),
                    'Path': file.get('pathName')
                })
        hr_title = "CarbonBlack Protect File Instance Search"
        hr = tableToMarkdown(hr_title, files, headers, removeNull=True, headerTransform=pascalToSpace)
        files = {'CBP.FileInstance(val.ID === obj.ID)': files} if files else None
        return_outputs(hr, files, raw_files)


    @logger
    def search_file_instance(q=None, limit=None, offset=None, sort=None, group=None, computer_id=None, file_name=None):
        """
        Sends the request for file instance, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param computer_id: Id of computer associated with this fileInstance
        :param file_name: Name of the file on the agent
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if computer_id:
            url_params['q'].append(f'computerId:{computer_id}')
        if file_name:
            url_params['q'].append(f'fileName:{file_name}')

        return http_request('GET', '/fileInstance', params=url_params)


    def search_event_command():
        """
        Searches for file instance
        :return: EntryObject of the file instance
        """
        args = demisto.args()
        raw_events = search_event(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                  args.get('group'), args.get('type'), args.get('computerId'), args.get('ipAddress'),
                                  args.get('fileName'), args.get('severity'), args.get('userName'),
                                  args.get('fileCatalogId'))
        hr_events = []
        events = []
        if raw_events:
            for event in raw_events:
                event_json = {
                    'FilePath': event.get('pathName'),
                    'Param1': event.get('param1'),
                    'Param2': event.get('param2'),
                    'Param3': event.get('param3'),
                    'SubTypeName': event.get('subtypeName'),
                    'ComputerName': event.get('computerName'),
                    'FileName': event.get('fileName'),
                    'RuleName': event.get('ruleName'),
                    'ProcessFileCatalogID': event.get('processFileCatalogId'),
                    'StringID': event.get('stringId'),
                    'IPAddress': event.get('ipAddress'),
                    'PolicyID': event.get('policyId'),
                    'Timestamp': event.get('timestamp'),
                    'Username': event.get('userName'),
                    'ComputerID': event.get('computerId'),
                    'ProcessFileName': event.get('processFileName'),
                    'IndicatorName': event.get('indicatorName'),
                    'SubType': event.get('subtype'),
                    'Type': event.get('type'),
                    'ID': event.get('id'),
                    'Description': event.get('description'),
                    'Severity': event.get('severity'),
                    'CommandLine': event.get('commandLine'),
                    'ProcessPathName': event.get('processPathName')
                }
                events.append(event_json)
                hr_event_json = dict(event_json)
                hr_event_json['Type'] = event_type_to_string(hr_event_json['Type'])
                hr_event_json['Severity'] = event_severity_to_string(hr_event_json['Severity'])
                hr_events.append(hr_event_json)
        headers = args.get('headers', EVENT_HEADERS)
        hr_title = "CarbonBlack Protect Event Search"
        hr = tableToMarkdown(hr_title, hr_events, headers, removeNull=True, headerTransform=pascalToSpace)
        events = {'CBP.Event(val.ID === obj.ID)': events} if events else None
        return_outputs(hr, events, raw_events)


    @logger
    def search_event(q=None, limit=None, offset=None, sort=None, group=None, e_type=None, computer_id=None, ip_address=None,
                     file_name=None, severity=None, user_name=None, file_catalog_id=None):
        """
        Sends the request for file instance, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param e_type: Event type
        :param computer_id: Id of computer associated with this event
        :param ip_address: IP address associated with this event
        :param file_name: Name of the file associated with this event
        :param severity: Event severity
        :param user_name: User name associated with this event
        :param file_catalog_id: Id of fileCatalog entry associated with this fileRule
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if e_type:
            url_params['q'].append(f'type:{event_type_to_int(e_type)}')
        if computer_id:
            url_params['q'].append(f'computerId:{computer_id}')
        if ip_address:
            url_params['q'].append(f'ipAddress:{ip_address}')
        if file_name:
            url_params['q'].append(f'fileName:{file_name}')
        if severity:
            url_params['q'].append(f'severity:{event_severity_to_int(severity)}')
        if user_name:
            url_params['q'].append(f'userName:{user_name}')
        if file_catalog_id:
            url_params['q'].append(f'fileCatalogId:{file_catalog_id}')

        return http_request('GET', '/event', params=url_params)


    @logger
    def event_type_to_int(e_type):
        """
        Returns type of the event in int format
        :param e_type: event type in string or int format
        :return: type of the event in int format
        """
        type_dict = {
            'Server Management': 0,
            'Session Management': 1,
            'Computer Management': 2,
            'Policy Management': 3,
            'Policy Enforcement': 4,
            'Discovery': 5,
            'General Management': 6,
            'Internal Events': 8
        }
        return type_dict.get(e_type, e_type)


    @logger
    def event_severity_to_int(severity):
        """
        Return severity value in int
        :param severity: severity in string or int
        :return: severity value in int
        """
        severity_dict = {
            'Critical': 2,
            'Error': 3,
            'Warning': 4,
            'Notice': 5,
            'Info': 6,
            'Debug': 7
        }
        return severity_dict.get(severity, severity)


    @logger
    def event_type_to_string(e_type):
        """
        Returns event type as string
        :param e_type: Event type in int
        :return: event type as string
        """
        type_dict = {
            0: 'Server Management',
            1: 'Session Management',
            2: 'Computer Management',
            3: 'Policy Management',
            4: 'Policy Enforcement',
            5: 'Discovery',
            6: 'General Management',
            8: 'Internal Events'
        }
        return type_dict.get(e_type, e_type)


    @logger
    def event_severity_to_string(severity):
        """
        Returns event severity as string
        :param severity: Severity of the event
        :return: event severity as string
        """
        severity_dict = {
            2: 'Critical',
            3: 'Error',
            4: 'Warning',
            5: 'Notice',
            6: 'Info',
            7: 'Debug'
        }
        return severity_dict.get(severity, severity)


    def search_approval_request_command():
        """
        Searches for approval requests
        :return: EntryObject of the approval requests
        """
        args = demisto.args()
        raw_approval_requests = search_approval(args.get('query'), args.get('limit'), args.get('offset'),
                                                args.get('sort'), args.get('group'))
        hr_approval_requests = []
        approval_requests = []
        if raw_approval_requests:
            for approval_request in raw_approval_requests:
                approval_request_output = {
                    'ID': approval_request.get('id'),
                    'Resolution': approval_request.get('resolution'),
                    'Status': approval_request.get('status'),
                    'ResolutionComments': approval_request.get('resolutionComments'),
                    'FileCatalogID': approval_request.get('fileCatalogId'),
                    'ComputerID': approval_request.get('computerId'),
                    'ComputerName': approval_request.get('computerName'),
                    'DateCreated': approval_request.get('dateCreated'),
                    'CreatedBy': approval_request.get('createdBy'),
                    'EnforcementLevel': approval_request.get('enforcementLevel'),
                    'RequestorEmail': approval_request.get('requestorEmail'),
                    'Priority': approval_request.get('priority'),
                    'FileName': approval_request.get('fileName'),
                    'PathName': approval_request.get('pathName'),
                    'Process': approval_request.get('process'),
                    'Platform': approval_request.get('platform')
                }
                approval_requests.append(approval_request_output)
                # handle human readable output
                hr_approval_request = dict(approval_request_output)
                hr_approval_request['Resolution'] = approval_request_resolution_to_string(hr_approval_request['Resolution'])
                hr_approval_request['Status'] = approval_request_status_to_string(hr_approval_request['Status'])
                hr_approval_requests.append(hr_approval_request)
        headers = args.get('headers', APPROVAL_REQUEST_HEADERS)
        hr_title = "CarbonBlack Protect Approval Request Search"
        hr = tableToMarkdown(hr_title, hr_approval_requests, headers, removeNull=True, headerTransform=pascalToSpace)
        approval_requests = {'CBP.ApprovalRequest(val.ID === obj.ID)': approval_requests} if approval_requests else None
        return_outputs(hr, approval_requests, raw_approval_requests)


    @logger
    def search_approval(q=None, limit=None, offset=None, sort=None, group=None):
        """
        Sends the request for approval request, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group
        }
        if q:
            # handle multi condition queries in the following formats: a&b
            q = q.split('&')
            url_params['q'] = q

        return http_request('GET', '/approvalRequest', params=url_params)


    @logger
    def approval_request_resolution_to_string(resolution):
        """
        Converts resolution as integer to string
        Based on https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#approvalrequest
        :param resolution: int that describes resolution [0-7]
        :return: string representation of the resolution (fallback: returns resolution)
        """
        resolution_dict = {
            0: 'Not Resolved',
            1: 'Rejected',
            2: 'Resolved - Approved',
            3: 'Resolved - Rule Change',
            4: 'Resolved - Installer',
            5: 'Resolved - Updated',
            6: 'Resolved - Publisher',
            7: 'Resolved - Other'
        }
        return resolution_dict.get(resolution, resolution)


    @logger
    def approval_request_status_to_string(status):
        """
        Converts status as integer to string
        Based on https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#approvalrequest
        :param status: int that describes status [1-4]
        :return: string representation of the status (fallback: returns status)
        """
        status_dict = {
            1: 'New',
            2: 'Open',
            3: 'Closed',
            4: 'Escalated'
        }
        return status_dict.get(status, status)


    def search_file_rule_command():
        """
        Searches for file rules
        :return: EntryObject of the file rules
        """
        args = demisto.args()
        raw_file_rules = search_file_rule(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                          args.get('group'), args.get('fileCatalogId'), args.get('name'),
                                          args.get('fileState'), args.get('sourceType'), args.get('hash'),
                                          args.get('fileName'))
        hr_file_rules = []
        file_rules = []
        if raw_file_rules:
            for file_rule in raw_file_rules:
                file_rule_output = {
                    'ID': file_rule.get('id'),
                    'CatalogID': file_rule.get('fileCatalogId'),
                    'Description': file_rule.get('description'),
                    'FileState': file_rule.get('fileState'),
                    'Hash': file_rule.get('hash'),
                    'Name': file_rule.get('name'),
                    'PolicyIDs': file_rule.get('policyIds'),
                    'ReportOnly': file_rule.get('reportOnly')
                }
                file_rules.append(file_rule_output)
                hr_file_rule_output = dict(file_rule_output)
                hr_file_rule_output['FileState'] = file_rule_file_state_to_string(hr_file_rule_output['FileState'])
                hr_file_rules.append(hr_file_rule_output)
        headers = args.get('headers', FILE_RULE_HEADERS)
        hr_title = "CarbonBlack Protect File Rule Search"
        hr = tableToMarkdown(hr_title, hr_file_rules, headers, removeNull=True, headerTransform=pascalToSpace)
        file_rules = {'CBP.FileRule(val.ID === obj.ID)': file_rules} if file_rules else None
        return_outputs(hr, file_rules, raw_file_rules)


    @logger
    def search_file_rule(q=None, limit=None, offset=None, sort=None, group=None, file_catalog_id=None, name=None,
                         file_state=None, source_type=None, hash_value=None, file_name=None):
        """
        Sends the request for file rule, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param file_catalog_id: Id of fileCatalog entry associated with this fileRule
        :param name: Name of this rule
        :param file_state: File state for this
        :param source_type: Mechanism that created this rule
        :param hash_value: Hash associated with this rule
        :param file_name: File name associated with this rule
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if file_catalog_id:
            url_params['q'].append(f'fileCatalogId:{file_catalog_id}')
        if name:
            url_params['q'].append(f'name:{name}')
        if file_state:
            url_params['q'].append(f'fileState:{file_rule_file_state_to_int(file_state)}')
        if source_type:
            url_params['q'].append(f'sourceType:{file_rule_source_type_to_int(source_type)}')
        if hash_value:
            url_params['q'].append(f'hash:{hash_value}')
        if file_name:
            url_params['q'].append(f'fileName:{file_name}')

        return http_request('GET', '/fileRule', params=url_params)


    @logger
    def file_rule_file_state_to_int(file_state):
        """
        Returns file rule file state in int format
        :param file_state: File state of a file rule
        :return: file rule file state in int format
        """
        state_dict = {
            'Unapproved': 1,
            'Approved': 2,
            'Banned': 3
        }
        return state_dict.get(file_state, file_state)


    @logger
    def file_rule_source_type_to_int(e_type):
        """
        Returns type of the event in int format
        :param e_type: event type in string or int format
        :return: type of the event in int format
        """
        type_dict = {
            'Manual': 1,
            'Trusted Directory': 2,
            'Reputation': 3,
            'Imported': 4,
            'External (API)': 5,
            'Event Rule': 6,
            'Application Template': 7,
            'Unified Management': 8
        }
        return type_dict.get(e_type, e_type)


    @logger
    def file_rule_file_state_to_string(state):
        """
        Converts state as integer to string
        Based on https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#filerule
        :param state: int that describes state [1-3]
        :return: string representation of the state (fallback: returns state)
        """
        file_state_dict = {
            1: 'Unapproved',
            2: 'Approved',
            3: 'Banned'
        }
        return file_state_dict.get(state, state)


    def get_file_rule_command():
        """
        Gets the requested file rule
        :return: EntryObject of the file catalog
        """
        args = demisto.args()
        id = args.get('id')
        raw_file_rule = get_file_rule(id)
        file_rule = {
            'ID': raw_file_rule.get('id'),
            'CatalogID': raw_file_rule.get('fileCatalogId'),
            'Description': raw_file_rule.get('description'),
            'FileState': raw_file_rule.get('fileState'),
            'Hash': raw_file_rule.get('hash'),
            'Name': raw_file_rule.get('name'),
            'PolicyIDs': raw_file_rule.get('policyIds'),
            'ReportOnly': raw_file_rule.get('reportOnly')
        }
        hr_file_rule = dict(file_rule)
        hr_file_rule['FileState'] = file_rule_file_state_to_string(hr_file_rule['FileState'])
        headers = args.get('headers', FILE_RULE_HEADERS)
        hr_title = f'CarbonBlack Protect File Rule Get for {id}'
        hr = tableToMarkdown(hr_title, hr_file_rule, headers, removeNull=True, headerTransform=pascalToSpace)
        entry_context_file_rule = {'CBP.FileRule(val.ID === obj.ID)': file_rule} if file_rule else None
        return_outputs(hr, entry_context_file_rule, raw_file_rule)


    @logger
    def get_file_rule(id):
        """
        Sends get file rule request
        :param id: File rule ID
        :return: Result json of the request
        """
        url = f'/fileRule/{id}'
        return http_request('GET', url)


    def delete_file_rule_command():
        """
        Deletes the requested file rule
        :return: EntryObject of the file catalog
        """
        args = demisto.args()
        id = args.get('id')
        delete_file_rule(id)
        hr = f"File Result {id} deleted successfully"
        demisto.results(hr)


    @logger
    def delete_file_rule(id):
        """
        Sends delete file rule request
        :param id: File rule ID
        :return: Result of the request
        """
        url = BASE_URL + f'/fileRule/{id}'
        res = requests.request(
            'DELETE',
            url,
            verify=USE_SSL,
            headers=HEADERS
        )
        return res


    def update_file_rule_command():
        """
        Creates or update a file rule
        :return: Entry object of the created file analysis
        """
        args = demisto.args()
        raw_file_rule = update_file_rule(
            args.get('hash'),
            args.get('fileState'),
            args.get('id'),
            args.get('fileCatalogId'),
            args.get('name'),
            args.get('description'),
            args.get('reportOnly'),
            args.get('reputationApprovalsEnabled'),
            args.get('forceInstaller'),
            args.get('forceNotInstaller'),
            args.get('policyIds'),
            args.get('platformFlags'),
        )
        file_rule = {
            'ID': raw_file_rule.get('id'),
            'CatalogID': raw_file_rule.get('fileCatalogId'),
            'Description': raw_file_rule.get('description'),
            'FileState': raw_file_rule.get('fileState'),
            'Hash': raw_file_rule.get('hash'),
            'Name': raw_file_rule.get('name'),
            'PolicyIDs': raw_file_rule.get('policyIds'),
            'ReportOnly': raw_file_rule.get('reportOnly')
        }
        hr_file_rule = dict(file_rule)
        hr_file_rule['FileState'] = file_rule_file_state_to_string(hr_file_rule['FileState'])
        hr = tableToMarkdown('CarbonBlack Protect File Rule Updated successfully', hr_file_rule, FILE_RULE_HEADERS,
                             removeNull=True, headerTransform=pascalToSpace)
        return_outputs(hr, {'CBP.FileRule(val.ID === obj.ID)': file_rule}, raw_file_rule)


    @logger
    def update_file_rule(hash, file_state, id, file_catalog_id, name, description, report_only,
                         reputation_approvals_enabled, force_installer, force_not_installer, policy_ids, platform_flags):
        """
        Update file rule
        :param hash: hash of file rule
        :param file_state: File state of this hash
        :param id: id of the file rule
        :param file_catalog_id: file catlog id
        :param name: name of the file rule
        :param description: description
        :param report_only: True if this has a report-only ban
        :param reputation_approvals_enabled: True if reputation approvals are enabled for this file
        :param force_installer: True if this file is forced to act as installer
        :param force_not_installer: True if this file is forced to act as ‘not installer'
        :param policy_ids: List of IDs of policies where this rule applies.
        :param platform_flags: Set of platform flags where this file rule will be valid
        :return: Result json of the request
        """
        body_params = {
            'hash': hash,
            'fileState': file_state,
            'id': id,
            'fileCatalogId': file_catalog_id,
            'name': name,
            'description': description,
            'reportOnly': report_only,
            'reputationApprovalsEnabled': reputation_approvals_enabled,
            'forceInstaller': force_installer,
            'forceNotInstaller': force_not_installer,
            'policyIds': policy_ids,
            'platformFlags': platform_flags
        }
        body_params = remove_keys_with_empty_value(body_params)

        return http_request('POST', '/fileRule', data=body_params)


    def search_policy_command():
        """
        Searches for policy
        :return: EntryObject of the policies
        """
        args = demisto.args()
        raw_policy = search_policy(args.get('query'), args.get('limit'), args.get('offset'),
                                   args.get('sort'), args.get('group'),
                                   args.get('enforcementLevel'), args.get('disconnectedEnforcementLevel'))
        hr_policies = []
        policies = []
        if raw_policy:
            for policy in raw_policy:
                policy_ec = {
                    'ReadOnly': policy.get('readOnly'),
                    'EnforcementLevel': policy.get('enforcementLevel'),
                    'ReputationEnabled': policy.get('reputationEnabled'),
                    'AtEnforcementComputers': policy.get('atEnforcementComputers'),
                    'Automatic': policy.get('automatic'),
                    'Name': policy.get('name'),
                    'FileTrackingEnabled': policy.get('fileTrackingEnabled'),
                    'ConnectedComputers': policy.get('connectedComputers'),
                    'PackageName': policy.get('packageName'),
                    'AllowAgentUpgrades': policy.get('allowAgentUpgrades'),
                    'TotalComputers': policy.get('totalComputers'),
                    'LoadAgentInSafeMode': policy.get('loadAgentInSafeMode'),
                    'AutomaticApprovalsOnTransition': policy.get('automaticApprovalsOnTransition'),
                    'ID': policy.get('id'),
                    'Description': policy.get('description'),
                    'DisconnectedEnforcementLevel': policy.get('disconnectedEnforcementLevel')
                }
                policies.append(policy_ec)
                hr_policy = dict(policy_ec)
                hr_policy['EnforcementLevel'] = policy_enforcement_lvl_to_string(hr_policy['EnforcementLevel'])
                hr_policies.append(hr_policy)
        headers = args.get('headers', POLICY_HEADERS)
        hr_title = "CarbonBlack Protect Policy Search"
        hr = tableToMarkdown(hr_title, hr_policies, headers, removeNull=True, headerTransform=pascalToSpace)
        policies = {'CBP.Policy(val.ID === obj.ID)': policies} if policies else None
        return_outputs(hr, policies, raw_policy)


    @logger
    def search_policy(q=None, limit=None, offset=None, sort=None, group=None, enf_lvl=None, dc_enf_lvl=None):
        """
        Sends the request for search policy, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param enf_lvl: Target enforcement level
        :param dc_enf_lvl: Target enforcement level for disconnected computers
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if enf_lvl:
            url_params['q'].append(f'enforcementLevel:{policy_enforcement_lvl_to_int(enf_lvl)}')
        if dc_enf_lvl:
            url_params['q'].append(f'disconnectedEnforcementLevel:{policy_enforcement_lvl_to_int(dc_enf_lvl)}')

        demisto.info(url_params)

        return http_request('GET', '/policy', params=url_params)


    @logger
    def policy_enforcement_lvl_to_int(enf_lvl):
        """
        Returns enforcement level in int
        :param enf_lvl: enforcement level string
        :return: enforcement level in int
        """
        enf_dict = {
            'High (Block Unapproved)': 20,
            'Medium (Prompt Unapproved)': 30,
            'Low (Monitor Unapproved)': 40,
            'None (Visibility)': 60,
            'None (Disabled)': 80
        }
        return enf_dict.get(enf_lvl, enf_lvl)


    @logger
    def policy_enforcement_lvl_to_string(enf_lvl):
        """
        Returns enforcement level in string
        :param enf_lvl: enforcement level int
        :return: enforcement level string
        """
        enf_dict = {
            20: 'High (Block Unapproved)',
            30: 'Medium (Prompt Unapproved)',
            40: 'Low (Monitor Unapproved)',
            60: 'None (Visibility)',
            80: 'None (Disabled)'
        }

        return enf_dict.get(enf_lvl, enf_lvl)


    def search_server_config_command():
        """
        Searches for server config
        :return: EntryObject of the server configurations
        """
        args = demisto.args()
        raw_server_configs = search_server_config(args.get('query'), args.get('limit'), args.get('offset'),
                                                  args.get('sort'), args.get('group'))
        server_configs = []
        if raw_server_configs:
            for server_config in raw_server_configs:
                server_configs.append({
                    'ID': server_config.get('id'),
                    'Value': server_config.get('value'),
                    'Name': server_config.get('name')
                })
        headers = args.get('headers')
        hr_title = "CarbonBlack Protect Server Config Search"
        hr = tableToMarkdown(hr_title, server_configs, headers, removeNull=True, headerTransform=pascalToSpace)
        server_configs = {'CBP.ServerConfig(val.ID === obj.ID)': server_configs} if server_configs else None
        return_outputs(hr, server_configs, raw_server_configs)


    @logger
    def search_server_config(q=None, limit=None, offset=None, sort=None, group=None):
        """
        Sends the request for file rule, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group
        }
        if q:
            # handle multi condition queries in the following formats: a&b
            q = q.split('&')
            url_params['q'] = q

        return http_request('GET', '/serverConfig', params=url_params)


    @logger
    def publisher_state_to_string(state):
        """
        Converts state as integer to string
        Based on https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#publisher
        :param state: int that describes state [1-5]
        :return: string representation of the state (fallback: returns state)
        """
        publisher_state_dict = {
            1: 'Unapproved',
            2: 'Approved',
            3: 'Banned',
            4: 'Approved By Policy',
            5: 'Banned By Policy'
        }
        return publisher_state_dict.get(state, state)


    @logger
    def publisher_reputation_to_string(reputation):
        """
        Converts reputation as integer to string
        Based on https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#publisher
        :param reputation: int that describes reputation [0-3]
        :return: string representation of the reputation (fallback: returns reputation)
        """
        publisher_reputation_dict = {
            0: 'Not trusted (Unknown)',
            1: 'Low',
            2: 'Medium',
            3: 'High'
        }
        return publisher_reputation_dict.get(reputation, reputation)


    def search_publisher_command():
        """
        Searches for publisher
        :return: EntryObject of the publishers
        """
        args = demisto.args()
        raw_publishers = search_publisher(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                          args.get('group'), args.get('name'), args.get('publisherReputation'),
                                          args.get('publisherState'))
        hr_publishers = []
        publishers = []
        if raw_publishers:
            for publisher in raw_publishers:
                publisher_output = {
                    'Description': publisher.get('description'),
                    'ID': publisher.get('id'),
                    'Name': publisher.get('name'),
                    'Reputation': publisher.get('publisherReputation'),
                    'SignedCertificatesCount': publisher.get('signedCertificateCount'),
                    'SignedFilesCount': publisher.get('signedFilesCount'),
                    'State': publisher.get('publisherState')
                }
                publishers.append(publisher_output)
                hr_publisher_output = dict(publisher_output)
                hr_publisher_output['State'] = publisher_state_to_string(hr_publisher_output['State'])
                hr_publisher_output['Reputation'] = publisher_reputation_to_string(hr_publisher_output['Reputation'])
                hr_publishers.append(hr_publisher_output)
        headers = args.get('headers', PUBLISHER_HEADERS)
        hr_title = "CarbonBlack Protect Publisher Search"
        hr = tableToMarkdown(hr_title, hr_publishers, headers, removeNull=True, headerTransform=pascalToSpace)
        publishers = {'CBP.Publisher(val.ID === obj.ID)': publishers} if publishers else None
        return_outputs(hr, publishers, raw_publishers)


    @logger
    def search_publisher(q=None, limit=None, offset=None, sort=None, group=None, name=None, reputation=None, state=None):
        """
        Sends the request for publisher, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file instances to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param name: Subject name of leaf certificate for this publisher
        :param reputation: Reputation of this publisher
        :param state: State for this publisher
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if name:
            url_params['q'].append(f'name:{name}')
        if reputation:
            url_params['q'].append(f'publisherReputation:{publisher_reputation_to_int(reputation)}')
        if state:
            url_params['q'].append(f'publisherState:{publisher_state_to_int(state)}')

        return http_request('GET', '/publisher', params=url_params)


    @logger
    def publisher_reputation_to_int(reputation):
        """
        Returns the publisher reputation as an int
        :param reputation: reputation of the publisher
        :return: publisher reputation as a string
        """
        reputation_dict = {
            'Not trusted (Unknown)': 0,
            'Low': 1,
            'Medium': 2,
            'High': 3
        }
        return reputation_dict.get(reputation, reputation)


    @logger
    def publisher_state_to_int(state):
        state_dict = {
            'Unapproved': 1,
            'Approved': 2,
            'Banned': 3,
            'Approved By Policy': 4,
            'Banned By Policy': 5
        }
        return state_dict.get(state, state)


    def get_file_analysis_command():
        """
        Gets the requested file analysis
        :return: EntryObject of the file analysis
        """
        args = demisto.args()
        id = args.get('id')
        raw_file_analysis = get_file_analysis(id)
        # if got here, then get_file_analysis returned a result, so we can assume it'll have a valid fileCatalogId
        raw_file_rule = search_file_catalog(q=f"id:{raw_file_analysis.get('fileCatalogId')}")[0]
        cbp_ec_key = 'CBP.FileAnalysis(val.ID === obj.ID)'
        ec = create_file_analysis_result(raw_file_analysis, raw_file_rule, cbp_ec_key)
        hr_title = f'CarbonBlack Protect Get File Analysis for {id}'
        hr = tableToMarkdown(hr_title, ec[cbp_ec_key], FILE_ANALYSIS_HEADERS,
                             removeNull=True, headerTransform=pascalToSpace)
        return_outputs(hr, ec, raw_file_analysis)


    @logger
    def get_file_analysis(id):
        """
        Sends get file analysis
        :param id: File analysis ID
        :return: Result json of the request
        """
        url = f'/fileAnalysis/{id}'
        return http_request('GET', url)


    @logger
    def create_file_analysis_result(raw_file_analysis, raw_file_rule, cbp_ec_key):
        result = {
            cbp_ec_key: {
                'Priority': raw_file_analysis.get('priority'),
                'FileName': raw_file_analysis.get('fileName'),
                'PathName': raw_file_analysis.get('pathName'),
                'ComputerId': raw_file_analysis.get('computerId'),
                'DateModified': raw_file_analysis.get('dateModified'),
                'ID': raw_file_analysis.get('id'),
                'FileCatalogId': raw_file_analysis.get('fileCatalogId'),
                'DateCreated': raw_file_analysis.get('dateCreated'),
                'CreatedBy': raw_file_analysis.get('createdBy')
            },
            outputPaths['file']: {
                'FileCatalogId': raw_file_analysis.get('fileCatalogId'),
                'Name': raw_file_analysis.get('fileName'),
                'PathName': raw_file_analysis.get('pathName'),
                'SHA1': raw_file_rule.get('sha1'),
                'SHA256': raw_file_rule.get('sha256'),
                'MD5': raw_file_rule.get('md5')
            },
            'DBotScore': [
                {
                    'Indicator': raw_file_rule.get('md5'),
                    'Type': 'hash',
                    'Vendor': 'Carbon Black Protection',
                    'Score': raw_file_analysis.get('analysisResult', 0)  # cb scoring as the same as dbot scoring
                },
                {
                    'Indicator': raw_file_rule.get('sha1'),
                    'Type': 'hash',
                    'Vendor': 'Carbon Black Protection',
                    'Score': raw_file_analysis.get('analysisResult', 0)  # cb scoring as the same as dbot scoring
                },
                {
                    'Indicator': raw_file_rule.get('sha256'),
                    'Type': 'hash',
                    'Vendor': 'Carbon Black Protection',
                    'Score': raw_file_analysis.get('analysisResult', 0)  # cb scoring as the same as dbot scoring
                }
            ]
        }
        # analysisResult == 3 -> Malicious
        if int(raw_file_analysis.get('analysisResult', 0)) == 3:
            result[outputPaths['file']].update({  # type: ignore
                'Malicious': {
                    'Vendor': 'Carbon Black Protection',
                    'Description': 'Carbon Black Protection found this file to be malicious.'
                }
            })
        return result


    def update_file_analysis_command():
        """
        Creates or update a file analysis
        :return: Entry object of the created file analysis
        """
        args = demisto.args()
        raw_file_analysis = update_file_analysis(
            args.get('fileCatalogId'),
            args.get('connectorId'),
            args.get('computerId'),
            args.get('priority'),
            args.get('analysisStatus'),
            args.get('analysisTarget'),
            args.get('id')
        )
        file_analysis = {
            'Priority': raw_file_analysis.get('priority'),
            'FileName': raw_file_analysis.get('fileName'),
            'PathName': raw_file_analysis.get('pathName'),
            'ComputerId': raw_file_analysis.get('computerId'),
            'DateModified': raw_file_analysis.get('dateModified'),
            'ID': raw_file_analysis.get('id'),
            'FileCatalogId': raw_file_analysis.get('fileCatalogId'),
            'DateCreated': raw_file_analysis.get('dateCreated'),
            'CreatedBy': raw_file_analysis.get('createdBy')
        }
        hr = tableToMarkdown('CarbonBlack Protect File Analysis Created successfully', file_analysis, FILE_ANALYSIS_HEADERS)
        return_outputs(hr, {'CBP.FileAnalysis(val.ID === obj.ID)': file_analysis}, raw_file_analysis)


    @logger
    def update_file_analysis(file_catalog_id, connector_id, computer_id, priority, analysis_status, analysis_target, id):
        """
        Update file analysis
        :param file_catalog_id: catalog id
        :param connector_id: connector id
        :param computer_id: computer id
        :param priority: priority of the file analysis
        :param analysis_status: status of the analysis
        :param analysis_target: target of the analysis
        :param id: id of the file analysis
        :return: Result json of the request
        """
        body_params = {
            'fileCatalogId': file_catalog_id,
            'connectorId': connector_id,
            'computerId': computer_id,
            'priority': priority,
            'analysisStatus': analysis_status,
            'analysisTarget': analysis_target,
            'id': id
        }
        body_params = remove_keys_with_empty_value(body_params)

        return http_request('POST', '/fileAnalysis', data=body_params)


    def update_file_upload_command():
        """
        Creates or update a file upload
        :return: Entry object of the created file upload
        """
        args = demisto.args()
        raw_file_upload = update_file_upload(
            args.get('fileCatalogId'),
            args.get('computerId'),
            args.get('priority'),
            args.get('uploadStatus'),
            args.get('id')
        )
        file_upload = {
            'Priority': raw_file_upload.get('priority'),
            'FileName': raw_file_upload.get('fileName'),
            'UploadPath': raw_file_upload.get('uploadPath'),
            'ComputerId': raw_file_upload.get('computerId'),
            'DateModified': raw_file_upload.get('dateModified'),
            'ID': raw_file_upload.get('id'),
            'FileCatalogId': raw_file_upload.get('fileCatalogId'),
            'DateCreated': raw_file_upload.get('dateCreated'),
            'CreatedBy': raw_file_upload.get('createdBy'),
            'PathName': raw_file_upload.get('pathName'),
            'UploadStatus': raw_file_upload.get('uploadStatus'),
            'UploadedFileSize': raw_file_upload.get('uploadedFileSize'),
        }
        hr_file_upload = dict(file_upload)
        hr_file_upload['UploadStatus'] = file_upload_status_to_string(hr_file_upload['UploadStatus'])
        hr = tableToMarkdown('CarbonBlack Protect File Upload Created successfully', hr_file_upload, FILE_UPLOAD_HEADERS)
        return_outputs(hr, {'CBP.FileUpload(val.ID === obj.ID)': file_upload}, raw_file_upload)


    @logger
    def update_file_upload(file_catalog_id, computer_id, priority, analysis_status, id):
        """
        Update file upload
        :param file_catalog_id: catalog id
        :param computer_id: computer id
        :param priority: priority of file upload
        :param analysis_status: analysis status
        :param id: id of file upload
        :return: Result json of the request
        """
        body_params = {
            'fileCatalogId': file_catalog_id,
            'computerId': computer_id,
            'priority': priority,
            'uploadStatus': analysis_status,
            'id': id
        }
        body_params = remove_keys_with_empty_value(body_params)

        return http_request('POST', '/fileUpload', data=body_params)


    @logger
    def file_upload_status_to_string(status):
        """
        Converts status as integer to string
        Based on https://developer.carbonblack.com/reference/enterprise-protection/8.0/rest-api/#fileupload
        :param status: int that describes state [0-6]
        :return: string representation of the status (fallback: returns status)
        """
        file_status_dict = {
            0: 'Queued',
            1: 'Initiated',
            2: 'Uploading',
            3: 'Completed',
            4: 'Error',
            5: 'Cancelled',
            6: 'Deleted'
        }
        return file_status_dict.get(status, status)


    def download_file_upload_command():
        """
        Downloads file upload
        :return: File result of file upload
        """
        id = demisto.args().get('id')
        file_upload = get_file_upload(id)
        raw_res = download_file_upload(id)
        demisto.results(fileResult(file_upload.get('fileName', 'cb_uploaded_file'), raw_res))


    @logger
    def download_file_upload(id):
        """
        Downloads file upload from server
        :param id: ID of the requested file upload
        :return: File upload binary file
        """
        url = f'/fileUpload/{id}'
        params = {
            'downloadFile': 'true'
        }
        return http_request('GET', url, params=params, parse_json=False)


    def search_file_upload_command():
        """
        Searches for file upload
        :return: EntryObject of the file upload
        """
        args = demisto.args()
        raw_file_uploads = search_file_upload(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                              args.get('group'), args.get('computerId'), args.get('fileCatalogId'),
                                              args.get('fileName'), args.get('uploadStatus'))
        hr_file_uploads = []
        file_uploads = []
        if raw_file_uploads:
            for file_upload in raw_file_uploads:
                file_upload_output = {
                    'Priority': file_upload.get('priority'),
                    'FileName': file_upload.get('fileName'),
                    'UploadPath': file_upload.get('uploadPath'),
                    'ComputerId': file_upload.get('computerId'),
                    'DateModified': file_upload.get('dateModified'),
                    'ID': file_upload.get('id'),
                    'FileCatalogId': file_upload.get('fileCatalogId'),
                    'DateCreated': file_upload.get('dateCreated'),
                    'CreatedBy': file_upload.get('createdBy'),
                    'PathName': file_upload.get('pathName'),
                    'UploadStatus': file_upload.get('uploadStatus'),
                    'UploadedFileSize': file_upload.get('uploadedFileSize'),
                }
                file_uploads.append(file_upload_output)
                hr_file_upload = dict(file_upload_output)
                hr_file_upload['UploadStatus'] = file_upload_status_to_string(hr_file_upload['UploadStatus'])
                hr_file_uploads.append(hr_file_upload)
        headers = args.get('headers', FILE_UPLOAD_HEADERS)
        hr_title = "CarbonBlack Protect File Upload Search"
        hr = tableToMarkdown(hr_title, hr_file_uploads, headers, removeNull=True, headerTransform=pascalToSpace)
        file_uploads = {'CBP.FileUpload(val.ID === obj.ID)': file_uploads} if file_uploads else None
        return_outputs(hr, file_uploads, raw_file_uploads)


    @logger
    def search_file_upload(q=None, limit=None, offset=None, sort=None, group=None, computer_id=None, file_catalog_id=None,
                           file_name=None, upload_status=None):
        """
        Sends the request for file upload, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file uploads to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param computer_id: Id of computer entry associated with this analysis
        :param file_catalog_id: Id of fileCatalog entry associated with this upload
        :param file_name: Name of the file where file exists on the endpoint
        :param upload_status: Status of upload
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if computer_id:
            url_params['q'].append(f'computerId:{computer_id}')
        if file_catalog_id:
            url_params['q'].append(f'fileCatalogId:{file_catalog_id}')
        if file_name:
            url_params['q'].append(f'fileName:{file_name}')
        if upload_status:
            url_params['q'].append(f'uploadStatus:{file_upload_status_to_int(upload_status)}')

        return http_request('GET', '/fileUpload', params=url_params)


    @logger
    def file_upload_status_to_int(upload_status):
        """
        Returns the upload status in int
        :param upload_status: Upload status string
        """
        status_dict = {
            'Queued': 0,
            'Initiated': 1,
            'Uploading': 2,
            'Completed': 3,
            'Error': 4,
            'Cancelled': 5,
            'Deleted': 6
        }

        return status_dict.get(upload_status, upload_status)


    def search_file_analysis_command():
        """
        Searches for file analysis
        :return: EntryObject of the file analysis
        """
        args = demisto.args()
        raw_file_analysis = search_file_analysis(args.get('query'), args.get('limit'), args.get('offset'), args.get('sort'),
                                                 args.get('group'), args.get('fileCatalogId'), args.get('connectorId'),
                                                 args.get('fileName'), args.get('analysisStatus'),
                                                 args.get('analysisResult'))
        file_analysis = []
        if raw_file_analysis:
            for analysis in raw_file_analysis:
                file_analysis.append({
                    'Priority': analysis.get('priority'),
                    'FileName': analysis.get('fileName'),
                    'PathName': analysis.get('pathName'),
                    'ComputerId': analysis.get('computerId'),
                    'DateModified': analysis.get('dateModified'),
                    'ID': analysis.get('id'),
                    'FileCatalogId': analysis.get('fileCatalogId'),
                    'DateCreated': analysis.get('dateCreated'),
                    'CreatedBy': analysis.get('createdBy')
                })
        headers = args.get('headers', FILE_ANALYSIS_HEADERS)
        hr_title = "CarbonBlack Protect File Analysis Search"
        hr = tableToMarkdown(hr_title, file_analysis, headers, removeNull=True, headerTransform=pascalToSpace)
        file_analysis = {'CBP.FileAnalysis(val.ID === obj.ID)': file_analysis} if file_analysis else None
        return_outputs(hr, file_analysis, raw_file_analysis)


    @logger
    def search_file_analysis(q=None, limit=None, offset=None, sort=None, group=None, file_catalog_id=None,
                             connector_id=None, file_name=None, status=None, result=None):
        """
        Sends the request for file analysis, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file analysis to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        :param file_catalog_id: Id of fileCatalog entry associated with this analysis
        :param connector_id: Id of connector associated with this analysis
        :param file_name: Name of the file where file exists on the endpoint
        :param status: Status of analysis
        :param result: Result of the analysis
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group,
            "q": q.split('&') if q else []  # handle multi condition queries in the following formats: a&b
        }
        if file_catalog_id:
            url_params['q'].append(f'fileCatalogId:{file_catalog_id}')
        if connector_id:
            url_params['q'].append(f'connectorId:{connector_id}')
        if file_name:
            url_params['q'].append(f'fileName:{file_name}')
        if status:
            url_params['q'].append(f'analysisStatus:{file_analysis_status_to_int(status)}')
        if result:
            url_params['q'].append(f'analysisResult:{file_analysis_result_to_int(result)}')

        return http_request('GET', '/fileAnalysis', params=url_params)


    @logger
    def file_analysis_status_to_int(status):
        status_dict = {
            'scheduled': 0,
            'submitted (file is sent for analysis)': 1,
            'processed (file is processed but results are not available yet)': 2,
            'analyzed (file is processed and results are available)': 3,
            'error': 4,
            'cancelled': 5
        }
        return status_dict.get(status, status)


    @logger
    def file_analysis_result_to_int(result):
        result_dict = {
            'Not yet available': 0,
            'File is clean': 1,
            'File is a potential threat': 2,
            'File is malicious': 3
        }
        return result_dict.get(result, result)


    def get_file_upload_command():
        """
        Gets the requested file upload
        :return: EntryObject of the file upload
        """
        args = demisto.args()
        id = args.get('id')
        raw_file_upload = get_file_upload(id)
        file_upload = {
            'Priority': raw_file_upload.get('priority'),
            'FileName': raw_file_upload.get('fileName'),
            'UploadPath': raw_file_upload.get('uploadPath'),
            'ComputerId': raw_file_upload.get('computerId'),
            'DateModified': raw_file_upload.get('dateModified'),
            'ID': raw_file_upload.get('id'),
            'FileCatalogId': raw_file_upload.get('fileCatalogId'),
            'DateCreated': raw_file_upload.get('dateCreated'),
            'CreatedBy': raw_file_upload.get('createdBy'),
            'PathName': raw_file_upload.get('pathName'),
            'UploadStatus': raw_file_upload.get('uploadStatus'),
            'UploadedFileSize': raw_file_upload.get('uploadedFileSize'),
        }
        headers = args.get('headers', FILE_UPLOAD_HEADERS)
        hr_file_upload = dict(file_upload)
        hr_file_upload['UploadStatus'] = file_upload_status_to_string(hr_file_upload['UploadStatus'])
        hr_title = f'CarbonBlack Protect File Upload Get for {id}'
        hr = tableToMarkdown(hr_title, hr_file_upload, headers, removeNull=True, headerTransform=pascalToSpace)
        entry_context_file_upload = {'CBP.FileUpload(val.ID === obj.ID)': file_upload} if file_upload else None
        return_outputs(hr, entry_context_file_upload, raw_file_upload)


    @logger
    def get_file_upload(id):
        """
        Sends get file upload request
        :param id: File upload ID
        :return: Result json of the request
        """
        url = f'/fileUpload/{id}'
        return http_request('GET', url)


    def get_connector_command():
        """
        Gets the requested connector
        :return: EntryObject of the connector
        """
        args = demisto.args()
        id = args.get('id')
        raw_connector = get_connector(id)
        connector = {
            'AnalysisEnabled': raw_connector.get('analysisEnabled'),
            'AnalysisName': raw_connector.get('analysisName'),
            'AnalysisTargets': raw_connector.get('analysisTargets'),
            'CanAnalyze': raw_connector.get('canAnalyze'),
            'ConnectorVersion': raw_connector.get('connectorVersion'),
            'Enabled': raw_connector.get('enabled'),
            'ID': raw_connector.get('id')
        }
        headers = args.get('headers', CONNECTOR_HEADERS)
        hr_title = f'CarbonBlack Protect Connector Get for {id}'
        hr = tableToMarkdown(hr_title, connector, headers, removeNull=True, headerTransform=pascalToSpace)
        entry_context_connector = {'CBP.Connector(val.ID === obj.ID)': connector} if connector else None
        return_outputs(hr, entry_context_connector, raw_connector)


    @logger
    def get_connector(id):
        """
        Sends get connector request
        :param id: Connector ID
        :return: Result json of the request
        """
        url = f'/connector/{id}'
        return http_request('GET', url)


    def search_connector_command():
        """
        Searches for connectors
        :return: EntryObject of the connectors
        """
        args = demisto.args()
        raw_connectors = search_connector(args.get('query'), args.get('limit'), args.get('offset'),
                                          args.get('sort'), args.get('group'))
        connectors = []
        if raw_connectors:
            for connector in raw_connectors:
                connectors.append({
                    'AnalysisEnabled': connector.get('analysisEnabled'),
                    'AnalysisName': connector.get('analysisName'),
                    'AnalysisTargets': connector.get('analysisTargets'),
                    'CanAnalyze': connector.get('canAnalyze'),
                    'ConnectorVersion': connector.get('connectorVersion'),
                    'Enabled': connector.get('enabled'),
                    'ID': connector.get('id')
                })
        headers = args.get('headers', CONNECTOR_HEADERS)
        hr_title = "CarbonBlack Protect Connector Search"
        hr = tableToMarkdown(hr_title, connectors, headers, removeNull=True, headerTransform=pascalToSpace)
        connectors = {'CBP.Connector(val.ID === obj.ID)': connectors} if connectors else None
        return_outputs(hr, connectors, raw_connectors)


    @logger
    def search_connector(q=None, limit=None, offset=None, sort=None, group=None):
        """
        Sends the request for file analysis, and returns the result json
        :param q: Query to be executed
        :param limit: Limit on the amount of results to be fetched
        :param offset: Offset of the file analysis to be fetched
        :param sort: Sort argument for request
        :param group: Group argument for request
        """
        url_params = {
            "limit": limit,
            "offset": offset,
            "sort": sort,
            "group": group
        }
        if q:
            # handle multi condition queries in the following formats: a&b
            q = q.split('&')
            url_params['q'] = q

        return http_request('GET', '/connector', params=url_params)


    def resolve_approval_request_command():
        """
        Updates an existing approval request
        :return: EntryObject of the approval request
        """
        args = demisto.args()
        raw_res = resolve_approval_request(
            args.get('id'),
            args.get('resolution'),
            args.get('requestorEmail'),
            args.get('resolutionComments'),
            args.get('status')
        )
        approval_request = {
            'ID': raw_res.get('id'),
            'Resolution': raw_res.get('resolution'),
            'Status': raw_res.get('status'),
            'ResolutionComments': raw_res.get('resolutionComments')
        }
        hr_approval_request = dict(approval_request)
        hr_approval_request['Status'] = approval_request_status_to_string(hr_approval_request['Status'])
        hr_approval_request['Resolution'] = approval_request_resolution_to_string(hr_approval_request['Resolution'])
        hr = tableToMarkdown('CarbonBlack Protect Approval Request Updated successfully', hr_approval_request)
        return_outputs(hr, {'CBP.ApprovalRequest(val.ID === obj.ID)': approval_request}, raw_res)


    @logger
    def resolve_approval_request(id, resolution, requestor_email=None, res_comments=None, status=None):
        """
        Update file analysis
        :param id: apporval request id
        :param resolution: apporval request resolution
        :param requestor_email: apporval request requestor email
        :param res_comments: apporval request resolution comments
        :param status: apporval request status
        :return: Result json of the request
        """
        body_params = {
            'id': id,
            'resolution': resolution,
            'requestorEmail': requestor_email,
            'resolutionComments': res_comments,
            'status': status
        }
        body_params = remove_keys_with_empty_value(body_params)
        return http_request('POST', '/approvalRequest', data=body_params)


    def fetch_incidents():
        """
            Fetches incident using the events API
            :return: Fetched events in incident format
        """
        last_run = demisto.getLastRun()
        # Get the last fetch time, if exists
        last_fetch = last_run.get('first_event_time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format=CB_TIME_FORMAT)
        last_fetch_timestamp = cbp_date_to_timestamp(last_fetch)
        query = f"timestamp>{last_fetch}"
        user_query = demisto.params().get('fetch_query')
        if user_query:
            # Add user's query to default query
            query = f'{query}&{user_query}'
        events = search_event(q=query, limit=INCIDENTS_PER_FETCH)
        incidents = []
        if events:
            for event in events:
                incident = event_to_incident(event)
                incident_date = incident['occurred']
                incident_date_timestamp = cbp_date_to_timestamp(incident_date)
                # Update last run and add incident if the incident is newer than last fetch
                if incident_date_timestamp > last_fetch_timestamp:
                    last_fetch = incident_date
                incidents.append(incident)
            demisto.setLastRun({'first_event_time': last_fetch})
        return incidents


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    # main added for unit tests
    def main():
        handle_proxy()
        command = demisto.command()
        LOG(f'Command being called is {command}')
        # should raise error in case of issue
        if command == 'fetch-incidents':
            demisto.incidents(fetch_incidents())
        else:
            try:
                if command == 'test-module':
                    # This is the call made when pressing the integration test button.
                    test_module()
                    demisto.results('ok')
                elif command == 'cbp-fileCatalog-search':
                    search_file_catalog_command()
                elif command == 'cbp-computer-search':
                    search_computer_command()
                elif command == 'cbp-computer-update':
                    update_computer_command()
                elif command == 'cbp-fileInstance-search':
                    search_file_instance_command()
                elif command == 'cbp-event-search':
                    search_event_command()
                elif command == 'cbp-approvalRequest-search':
                    search_approval_request_command()
                elif command == 'cbp-fileRule-search':
                    search_file_rule_command()
                elif command == 'cbp-fileRule-get':
                    get_file_rule_command()
                elif command == 'cbp-fileRule-delete':
                    delete_file_rule_command()
                elif command in ('cbp-fileRule-update', 'cbp-fileRule-createOrUpdate'):
                    update_file_rule_command()
                elif command == 'cbp-policy-search':
                    search_policy_command()
                elif command == 'cbp-serverConfig-search':
                    search_server_config_command()
                elif command == 'cbp-publisher-search':
                    search_publisher_command()
                elif command == 'cbp-fileAnalysis-search':
                    search_file_analysis_command()
                elif command == 'cbp-fileAnalysis-get':
                    get_file_analysis_command()
                elif command == 'cbp-fileAnalysis-createOrUpdate':
                    update_file_analysis_command()
                elif command == 'cbp-fileUpload-createOrUpdate':
                    update_file_upload_command()
                elif command == 'cbp-fileUpload-download':
                    download_file_upload_command()
                elif command == 'cbp-fileUpload-search':
                    search_file_upload_command()
                elif command == 'cbp-fileUpload-get':
                    get_file_upload_command()
                elif command == 'cbp-computer-get':
                    get_computer_command()
                elif command == 'cbp-connector-get':
                    get_connector_command()
                elif command == 'cbp-connector-search':
                    search_connector_command()
                elif command == 'cbp-approvalRequest-resolve':
                    resolve_approval_request_command()
                else:
                    return_error(f"Command {command} is not supported.")
            # Log exceptions
            except Exception as e:
                return_error(str(e))


    # python2 uses __builtin__ python3 uses builtins
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  subtype: python3
  type: python
system: true
