category: Authentication
commonfields:
  id: Gmail
  version: -1
configuration:
- defaultvalue: ""
  display: Email of user with admin privileges (the Password refers to the Service
    Account private key)
  name: adminEmail
  required: true
  type: 9
- defaultvalue: ""
  display: Immutable Google Apps Id
  name: gappsID
  required: false
  type: 0
- defaultvalue: ""
  display: Events query (e.g. "from:example@demisto.com")
  name: query
  required: false
  type: 0
- defaultvalue: ""
  display: Events user key (e.g. example@demisto.com)
  name: queryUserKey
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: 1 days
  display: First fetch timestamp, in days.
  name: fetch_time
  required: false
  type: 0
description: Gmail API and user management (This integration replaces the Gmail functionality
  in the GoogleApps API and G Suite integration).
detaileddescription: "This API enables the usage of Google Admin API. In order to
  enable it, you will need to create an account service private key JSON file and
  copy its content to **Password** parameter.\n\nFollow the steps here to create such
  a private key and authorize the API for usage: [https://developers.google.com/admin-sdk/directory/v1/guides/delegation](https://developers.google.com/admin-sdk/directory/v1/guides/delegation)\n\nIt
  is necessary to authorize the next APIs for that service account:\n[https://www.googleapis.com/auth/admin.directory.user.readonly](https://www.googleapis.com/auth/admin.directory.user.readonly)\n\nIn
  order to fetch user roles, authorize this API: [https://www.googleapis.com/auth/admin.directory.rolemanagement.readonly](https://www.googleapis.com/auth/admin.directory.rolemanagement.readonly)\n\nIn
  order to revoke user roles, authorize this API: [https://www.googleapis.com/auth/admin.directory.rolemanagement](https://www.googleapis.com/auth/admin.directory.rolemanagement)\n\nIn
  order to search user mailboxes, authorize this API: [https://www.googleapis.com/auth/gmail.readonly](https://www.googleapis.com/auth/gmail.readonly)\n\nIn
  order to delete emails from user mailbox, authorize this API: \n[https://mail.google.com](https://mail.google.com),
  \n[https://www.googleapis.com/auth/gmail.modify](https://www.googleapis.com/auth/gmail.modify)\n\nIn
  order to fetch user security tokens, authorize this API: [https://www.googleapis.com/auth/admin.directory.user.security](https://www.googleapis.com/auth/admin.directory.user.security)\n\nIn
  order to fetch mobile info, authorize this API: [https://www.googleapis.com/auth/admin.directory.device.mobile.readonly](https://www.googleapis.com/auth/admin.directory.device.mobile.readonly)\n\nIn
  order to preform actions on mobile devices, authorize this API: [https://www.googleapis.com/auth/admin.directory.device.mobile.action](https://www.googleapis.com/auth/admin.directory.device.mobile.action)\n\nIn
  order to preform actions on chorme devices, authorize this API:[https://www.googleapis.com/auth/admin.directory.device.chromeos](https://www.googleapis.com/auth/admin.directory.device.chromeos)\n\nIn
  order to block email addresses, authorize this API:\n[https://www.googleapis.com/auth/gmail.settings.basic](https://www.googleapis.com/auth/gmail.settings.basic)\n\nIn
  order to get auto-replay messages from a user, authorize this API: \n[https://mail.google.com](https://mail.google.com),\n[https://www.googleapis.com/auth/gmail.modify](https://www.googleapis.com/auth/gmail.modify),\n[https://www.googleapis.com/auth/gmail.readonly](https://www.googleapis.com/auth/gmail.readonly)\nand
  [https://www.googleapis.com/auth/gmail.settings.basic](https://www.googleapis.com/auth/gmail.settings.basic)\n\nIn
  order to set auto-replay messages, authorize this API: [https://www.googleapis.com/auth/gmail.settings.basic](https://www.googleapis.com/auth/gmail.settings.basic)\n\nIn
  order to hide users from the global directory, authorize this API: [https://www.googleapis.com/auth/admin.directory.user](https://www.googleapis.com/auth/admin.directory.user)\n\nIn
  order to delegate a user to a mailbox or remove a delegated mail from a mailbox,
  please authorize this api too: [https://www.googleapis.com/auth/gmail.settings.sharing](https://www.googleapis.com/auth/gmail.settings.sharing)\n\nIn
  order to set a user's password, authorize this API: [https://www.googleapis.com/auth/admin.directory.user](https://www.googleapis.com/auth/admin.directory.user)\n\nIn
  order to send mails, authorize this API:\n[https://www.googleapis.com/auth/gmail.compose](https://www.googleapis.com/auth/gmail.compose)
  and [https://www.googleapis.com/auth/gmail.send](https://www.googleapis.com/auth/gmail.send)\n\nFor
  the email user param, please choose a user with admin permissions and make sure
  that you follow the steps to perform Google Apps Domain-Wide Delegation of Authority.\n\nIn
  order to revoke/fetch user role, you will need the Immutable Google Apps ID param.\nTo
  get an Immutable Google Apps ID (or customerId):\n1. Go to [https://admin.google.com](https://admin.google.com)\n2.
  Security -> Set up single sign-on (SSO)\n\nYou will see there URLs in the format:\n[https://accounts.google.com/o/saml2/idp?idpid=Cxxxxxxxx](https://accounts.google.com/o/saml2/idp?idpid=Cxxxxxxxx)\nCxxxxxxxx
  is your Immutable Google Apps ID (customerId).\n \n"
display: Gmail
image: data:image/png;base64,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
name: Gmail
script:
  commands:
  - arguments:
    - default: true
      description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    description: Deletes a Gmail user.
    name: gmail-delete-user
  - arguments:
    - default: true
      description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    description: Lists all tokens associated with a specified user. applications.
    name: gmail-get-tokens-for-user
  - arguments:
    - default: true
      description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    - auto: PREDEFINED
      defaultValue: basic
      description: 'The subset of fields to fetch for the user. Can be: "basic": Do
        not include any custom fields for the user (default), "custom": Includes custom
        fields from schemas requested in custom-field-mask, "full": Includes all fields
        associated with the user.'
      name: projection
      predefined:
      - basic
      - custom
      - full
    - auto: PREDEFINED
      defaultValue: admin_view
      description: Whether to fetch the administrator or public view of the user.
        Can be admin_view (default), which includes both administrator and domain-public
        fields; or "domain_public", which includes user fields that are publicly visible
        to other users in the domain.
      name: view-type-public-domain
      predefined:
      - admin_view
      - domain_public
    - description: A comma separated list of schema names. All fields from these schemas
        are fetched. This should only be set when projection=custom.
      name: custom-field-mask
    description: Gets information for a specified user.
    name: gmail-get-user
    outputs:
    - contextPath: Account.Type
      description: The account type. For example, "AD", "LocalOS", "Google", "AppleID",
        and so on.
      type: String
    - contextPath: Account.ID
      description: The unique ID for the account (integration specific). For AD accounts
        this is the Distinguished Name (DN).
      type: String
    - contextPath: Account.DisplayName
      description: The display name.
      type: string
    - contextPath: Account.Gmail.Address
      description: Email assigned with the current account.
      type: string
    - contextPath: Account.Email.Address
      description: The email address of the account.
      type: String
    - contextPath: Account.Groups
      description: Groups to which the account belongs (integration specific). For
        example, for AD, these are the groups in which the account is a member.
      type: String
    - contextPath: Account.Domain
      description: The domain of the account.
      type: String
    - contextPath: Account.Username
      description: The account username in the relevant system.
      type: String
    - contextPath: Account.OrganizationUnit
      description: The Organization Unit (OU) of the account.
      type: String
  - arguments:
    - default: true
      description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    description: Retrieves a list of all Google roles for a specified user.
    name: gmail-get-user-roles
    outputs:
    - contextPath: GoogleApps.Role.RoleAssignmentId
      description: The unique ID of the role assignment.
      type: string
    - contextPath: GoogleApps.Role.ScopeType
      description: The scope type of the role.
      type: string
    - contextPath: GoogleApps.Role.Kind
      description: The kind of the Role.
      type: string
    - contextPath: GoogleApps.Role.OrgUnitId
      description: Organization in which user was assigned.
      type: string
    - contextPath: GoogleApps.Role.ID
      description: The inner role ID.
      type: string
    - contextPath: GoogleApps.Role.AssignedTo
      description: User ID who was assigned to the role.
      type: string
  - arguments:
    - description: The ID of the message to retrieve.
      name: message-id
      required: true
    - description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    description: Retrieves attachments from a sent Gmail message.
    name: gmail-get-attachments
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the message to retrieve.
      name: message-id
      required: true
    - auto: PREDEFINED
      defaultValue: full
      description: 'The format in which to return the message. Can be: "full": Returns
        the full email message data with body content parsed in the payload field;
        the raw field is not used. (default) / "metadata": Returns only the email
        message ID, labels, and email headers / "minimal": Returns only the email
        message ID and labels; does not return the email headers, body, or payload
        / "raw": Returns the full email message data with body content in the raw
        field as a base64url encoded string; the payload field is not used.'
      name: format
      predefined:
      - full
      - metadata
      - minimal
      - raw
    description: Retrieves the Gmail message sent to a specified user.
    name: gmail-get-mail
    outputs:
    - contextPath: Gmail.ID
      description: Inner ID of the Gmail message.
      type: String
    - contextPath: Gmail.ThreadId
      description: The thread ID.
      type: string
    - contextPath: Gmail.Format
      description: MIME type of email.
      type: string
    - contextPath: Gmail.Labels
      description: Labels of the specific email.
      type: string
    - contextPath: Gmail.To
      description: Email Address of the receiver.
      type: String
    - contextPath: Gmail.From
      description: Email Address of the sender.
      type: String
    - contextPath: Gmail.Cc
      description: Additional recipient email address (CC).
      type: string
    - contextPath: Gmail.Bcc
      description: Additional recipient email address (BCC).
      type: string
    - contextPath: Gmail.Subject
      description: Subject of the email.
      type: string
    - contextPath: Gmail.Body
      description: The content of the email.
      type: string
    - contextPath: Gmail.Attachments
      description: The attachments of the email. Attachments ID's are separated by
        ','.
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of the specific email (list).
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The email mailbox.
      type: string
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.CC
      description: Additional recipient email address (CC).
      type: String
    - contextPath: Email.BCC
      description: Additional recipient email address (BCC).
      type: String
    - contextPath: Email.Format
      description: The format of the email.
      type: String
    - contextPath: Email.Body/HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.Body/Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Headers
      description: The headers of the email.
      type: String
    - contextPath: Email.Attachments.entryID
      description: Attachments ids separated by ','.
      type: Unknown
    - contextPath: Email.Date
      description: The date the email was received.
      type: String
  - arguments:
    - default: true
      description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    - description: 'Returns messages matching the specified query. Supports the same
        query format as the Gmail search box. For example, "from:someuser@example.com
        rfc822msgid: is:unread". For more syntax information see "https://support.google.com/mail/answer/7190?hl=en"'
      name: query
    - defaultValue: "100"
      description: Maximum number of results to return. Default is 100. Maximum is
        500. Can be 1 to 500, inclusive.
      name: max-results
    - description: Enables partial responses to be retrieved, separated by commas.
        For more information, see https://developers.google.com/gdata/docs/2.0/basics#PartialResponse.
      name: fields
    - description: Only returns messages with labels that match all of the specified
        label IDs in a comma separated list.
      name: labels-ids
    - description: Page token to retrieve a specific page of results in the list.
      name: page-token
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'Include messages from SPAM and TRASH in the results. (Default:
        false)'
      name: include-spam-trash
      predefined:
      - "False"
      - "True"
    - description: Specify the sender. For example, "john"
      name: from
    - description: Specify the receiver. For example, "john"
      name: to
    - description: Words in the subject line. For example, "alert"
      name: subject
    - description: Attachments with a certain name or file type. For example, "pdf"
        or "report.pdf"
      name: filename
    - description: 'Messages in any folder, including Spam and Trash. For example:
        shopping'
      name: in
    - description: 'Search for messages sent after a certain time period. For example:
        2018/05/06'
      name: after
    - description: 'Search for messages sent before a certain time period. for example:
        2018/05/09'
      name: before
    - auto: PREDEFINED
      description: Whether to search for messages sent with attachments (boolean value).
      name: has-attachments
      predefined:
      - "True"
      - "False"
    description: Searches for Gmail records of a specified Google user.
    name: gmail-search
    outputs:
    - contextPath: Gmail.ID
      description: Inner ID of the Gmail message.
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID.
      type: string
    - contextPath: Gmail.Format
      description: MIME type of email.
      type: string
    - contextPath: Gmail.Labels
      description: Labels of the specific email.
      type: string
    - contextPath: Gmail.To
      description: Email Address of the receiver.
      type: string
    - contextPath: Gmail.From
      description: Email Address of the sender.
      type: string
    - contextPath: Gmail.Cc
      description: Additional recipient email address (CC).
      type: string
    - contextPath: Gmail.Bcc
      description: Additional recipient email address (BCC).
      type: string
    - contextPath: Gmail.Subject
      description: Subject of the specific email.
      type: string
    - contextPath: Gmail.Body
      description: The content of the email.
      type: string
    - contextPath: Gmail.Attachments
      description: Attachment details. Attachments IDs are separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of a specific email (list).
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The email mailbox.
      type: string
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.CC
      description: Additional recipient email address (CC).
      type: String
    - contextPath: Email.BCC
      description: Additional recipient email address (BCC).
      type: String
    - contextPath: Email.Format
      description: The format of the email.
      type: String
    - contextPath: Email.Body/HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.Body/Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Headers
      description: The headers of the email.
      type: String
    - contextPath: Email.Attachments.entryID
      description: Email Attachment IDs. Separated by ','
      type: Unknown
    - contextPath: Email.Date
      description: The date the email was received.
      type: String
  - arguments:
    - description: 'Returns messages matching the specified query. Supports the same
        query format as the Gmail search box. For example, "from:someuser@example.com
        rfc822msgid: is:unread". For more syntax information,see "https://support.google.com/mail/answer/7190?hl=en"'
      name: query
    - defaultValue: "100"
      description: Maximum number of results to return. Default is 100. Maximum is
        500. Acceptable values are 1 to 500, inclusive.
      name: max-results
    - description: Enables partial responses to be retrieved in a comma separated
        list. For more information, see https://developers.google.com/gdata/docs/2.0/basics#PartialResponse.
      name: fields
    - description: Only returns messages with labels that match all of the specified
        label IDs in a comma separated list.
      name: labels-ids
    - description: Page token to retrieve a specific page of results in the list.
      name: page-token
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'Includes messages from SPAM and TRASH in the results. (Default:
        false)'
      name: include-spam-trash
      predefined:
      - "False"
      - "True"
    - description: Specifies the sender. For example, "john"
      name: from
    - description: Specifies the receiver. For example, "john"
      name: to
    - description: Words in the subject line. For example, "alert"
      name: subject
    - description: Attachments with a certain name or file type. For example, "pdf"
        or "report.pdf"
      name: filename
    - description: Messages in any folder, including Spam and Trash. For example,
        shopping
      name: in
    - description: Search for messages sent after a certain time period. For example,
        2018/05/06
      name: after
    - description: Search for messages sent before a certain time period. For example,
        2018/05/09
      name: before
    - auto: PREDEFINED
      description: Whether to search for messages sent with attachments.
      name: has-attachments
      predefined:
      - "False"
      - "True"
    description: Searches the Gmail records for all Google users.
    name: gmail-search-all-mailboxes
    outputs:
    - contextPath: Gmail.ID
      description: Inner ID of the Gmail message.
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID.
      type: string
    - contextPath: Gmail.Format
      description: MIME type of the email.
      type: string
    - contextPath: Gmail.Labels
      description: Labels of a specific email.
      type: string
    - contextPath: Gmail.To
      description: Email Address of the receiver.
      type: string
    - contextPath: Gmail.From
      description: Email Address of the sender.
      type: string
    - contextPath: Gmail.Cc
      description: Additional recipient email address (CC).
      type: string
    - contextPath: Gmail.Bcc
      description: Additional recipient email address (BCC).
      type: string
    - contextPath: Gmail.Subject
      description: Subject of the specific email.
      type: string
    - contextPath: Gmail.Body
      description: The content of the email.
      type: string
    - contextPath: Gmail.Attachments
      description: The attachments of the email. IDs are separated by ','.
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list).
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The Gmail Mailbox.
      type: string
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.CC
      description: Additional recipient email address (CC).
      type: String
    - contextPath: Email.BCC
      description: Additional recipient email address (BCC).
      type: String
    - contextPath: Email.Format
      description: The format of the email.
      type: String
    - contextPath: Email.Body/HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.Body/Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Headers
      description: The headers of the email.
      type: String
    - contextPath: Email.Attachments.entryID
      description: Email Attachments. IDs are separated by ','.
      type: Unknown
    - contextPath: Email.Date
      description: The date the email was received.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: 'The subset of fields to fetch for the user. Can be "basic": Do
        not include any custom fields for the user. (default), "custom": Include custom
        fields from schemas requested in customFieldMask, "full": Include all fields
        associated with this user.'
      name: projection
      predefined:
      - basic
      - custom
      - full
    - default: true
      description: The domain name. Use this field to get fields from only one domain.
        To return all domains for a customer account, use the customer query parameter.
      name: domain
    - description: The unique ID for the customers Google account. Default is the
        value specified in the integration configuration. For a multi-domain account,
        to fetch all groups for a customer, use this field instead of domain.
      name: customer
    - auto: PREDEFINED
      description: The event on which subscription intended (if subscribing). Can
        be add/delete/makeAdmin/undelete/update
      name: event
      predefined:
      - add
      - delete
      - makeAdmin
      - undelete
      - update
    - description: Maximum number of results to return. Default is 100. Maximum is
        500. Can be 1 to 500, inclusive.
      name: max-results
    - description: A comma-separated list of schema names. All fields from these schemas
        are fetched. Must be set when projection=custom.
      name: custom-field-mask
    - description: Query string search. Should be of the form "". Complete documentation
        is at https://developers.google.com/admin-sdk/directory/v1/guides/search-users
      name: query
    - auto: PREDEFINED
      description: If true, retrieves the list of deleted users. Default is false.
      name: show-deleted
      predefined:
      - "False"
      - "True"
    - auto: PREDEFINED
      description: How to sort out results. Can be ASCENDING/DESCENDING
      name: sort-order
      predefined:
      - ASCENDING
      - DESCENDING
    - description: Token to authorize and authenticate the action.
      name: token
    - auto: PREDEFINED
      defaultValue: admin_view
      description: Whether to fetch either the administrator or public view of the
        user. Can be admin_view (default), which includes both administrator and domain-public
        fields or "domain_public"(includes fields for the user that are publicly visible
        to other users in the domain).
      name: view-type-public-domain
      predefined:
      - admin_view
      - domain_public
    - description: Token to specify next page in the list
      name: page-token
    description: Lists all Google users in a domain.
    name: gmail-list-users
    outputs:
    - contextPath: Account.Type
      description: The account type. For example, "AD", "LocalOS", "Google", "AppleID",
        and so on.
      type: String
    - contextPath: Account.ID
      description: The unique ID for the account (integration specific). For AD accounts
        this is the Distinguished Name (DN).
      type: String
    - contextPath: Account.DisplayName
      description: The display name.
      type: String
    - contextPath: Account.Gmail.Address
      description: Email assigned with the current account.
      type: string
    - contextPath: Account.Email.Adderss
      description: The email address of the account.
      type: String
    - contextPath: Account.Groups
      description: Groups to which the account belongs (integration specific). For
        example, for AD these are the groups in which the account is member.
      type: String
    - contextPath: Account.Domain
      description: The domain of the account.
      type: String
    - contextPath: Account.Username
      description: The username of the account.
      type: String
    - contextPath: Account.OrganizationUnit
      description: The Organization Unit (OU) of the account.
      type: String
  - arguments:
    - description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
    - description: The immutable ID of the role assignment.
      name: role-assignment-id
      required: true
    description: Revokes a role for a specified Google user.
    name: gmail-revoke-user-role
  - arguments:
    - default: true
      description: The user's primary email address. The primary email address must
        be unique and cannot be an alias of another user.
      name: email
      required: true
    - description: The user's first name.
      name: first-name
      required: true
    - description: The user's last name.
      name: family-name
      required: true
    - description: Stores the password for the user account. A password can contain
        any combination of ASCII characters. A minimum of 8 characters is required.
        The maximum length is 100 characters.
      name: password
      required: true
    description: Creates a new Gmail user.
    name: gmail-create-user
    outputs:
    - contextPath: Account.Type
      description: The account type. For example, "AD", "LocalOS", "Google", "AppleID",
        and so on.
      type: String
    - contextPath: Account.ID
      description: The unique ID for the account (integration specific). For AD accounts
        this is the Distinguished Name (DN).
      type: String
    - contextPath: Account.DisplayName
      description: The display name.
      type: string
    - contextPath: Account.Gmail.Address
      description: Email assigned with the current account.
      type: string
    - contextPath: Account.Email.Address
      description: The email address of the account.
      type: String
    - contextPath: Account.Username
      description: The username of the account.
      type: String
    - contextPath: Account.Groups
      description: Groups to which the account belongs (integration specific). For
        example, for AD these are groups in which the account is a member.
      type: String
    - contextPath: Account.Domain
      description: The domain of the account.
      type: String
    - contextPath: Account.OrganizationUnit
      description: The Organization Unit (OU) of the account.
      type: String
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the message to delete.
      name: message-id
      required: true
    - auto: PREDEFINED
      description: Whether to delete the email permanently or move it to trash (default).
      name: permanent
      predefined:
      - "False"
      - "True"
    description: Deletes an email in the user's mailbox.
    name: gmail-delete-mail
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the thread to retrieve.
      name: thread-id
      required: true
    - auto: PREDEFINED
      defaultValue: full
      description: 'The format in which to return the message. Can be: "full": Returns
        the full email message data with body content parsed in the payload field;
        the raw field is not used. (default) / "metadata": Returns only email message
        ID, labels, and email headers / "minimal": Returns only email message ID and
        labels; does not return the email headers, body, or payload / "raw": Returns
        the full email message data with body content in the raw field as a base64url
        encoded string; the payload field is not used'
      name: format
      predefined:
      - full
      - metadata
      - minimal
      - raw
    description: Returns all messages in a thread.
    name: gmail-get-thread
    outputs:
    - contextPath: Gmail.ID
      description: Inner ID of the Gmail message.
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID.
      type: string
    - contextPath: Gmail.Format
      description: MIME type of email.
      type: string
    - contextPath: Gmail.Labels
      description: Labels of the specific email.
      type: string
    - contextPath: Gmail.To
      description: Email Address of the receiver.
      type: string
    - contextPath: Gmail.From
      description: Email Address of the sender.
      type: string
    - contextPath: Gmail.Cc
      description: Additional recipient email address (CC).
      type: string
    - contextPath: Gmail.Bcc
      description: Additional recipient email address (BCC).
      type: string
    - contextPath: Gmail.Subject
      description: Subject of a specific email.
      type: string
    - contextPath: Gmail.Body
      description: The content of the email.
      type: string
    - contextPath: Gmail.Attachments
      description: The attachments of the email. IDs are separated by ','.
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of the specific email (list).
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The Gmail Mailbox.
      type: string
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.CC
      description: Additional recipient email address (CC).
      type: String
    - contextPath: Email.BCC
      description: Additional recipient email address (BCC).
      type: String
    - contextPath: Email.Format
      description: The format of the email.
      type: String
    - contextPath: Email.Body/HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.Body/Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Headers
      description: The headers of the email.
      type: String
    - contextPath: Email.Attachments.entryID
      description: Email Attachments. IDs are separated by ','.
      type: Unknown
    - contextPath: Email.Date
      description: The date the email was received.
      type: String
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the message to retrieve.
      name: message-id
      required: true
    - description: Comma-separated list of labels to add to the email.
      isArray: true
      name: add-labels
    - description: Comma separated list of labels to remove from the email.
      isArray: true
      name: remove-labels
    description: Moves an email to a different folder.
    name: gmail-move-mail
    outputs:
    - contextPath: Gmail.ID
      description: Inner ID of the Gmail message.
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID.
      type: string
    - contextPath: Gmail.Format
      description: MIME type of email.
      type: string
    - contextPath: Gmail.Labels
      description: Labels of the specific email.
      type: string
    - contextPath: Gmail.To
      description: Gmail address of the receiver.
      type: string
    - contextPath: Gmail.From
      description: Gmail address of the sender.
      type: string
    - contextPath: Gmail.Cc
      description: Additional recipient email address (CC).
      type: string
    - contextPath: Gmail.Bcc
      description: Additional recipient email address (BCC).
      type: string
    - contextPath: Gmail.Subject
      description: Subject of the specific email.
      type: string
    - contextPath: Gmail.Body
      description: The content of the email.
      type: string
    - contextPath: Gmail.Attachments
      description: The attachments of the email. IDs are separated by ','.
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of the specific email (list).
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The Gmail mailbox.
      type: string
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.CC
      description: Additional recipient email address (CC).
      type: Unknown
    - contextPath: Email.BCC
      description: Additional recipient email address (BCC).
      type: Unknown
    - contextPath: Email.Format
      description: The format of the email.
      type: String
    - contextPath: Email.Body/HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.Body/Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Headers
      description: The headers of the email.
      type: String
    - contextPath: Email.Attachments.entryID
      description: Email attachments. IDs are separated by ','.
      type: Unknown
    - contextPath: Email.Date
      description: The date the email was received.
      type: String
  - arguments:
    - default: true
      description: The source user's email address. The special value me can be used
        to indicate the authenticated user.
      name: src-user-id
      required: true
    - description: The ID of the message to retrieve.
      name: message-id
      required: true
    - description: The destination user's email address. The me special value can
        be used to indicate the authenticated user.
      name: dst-user-id
      required: true
    description: Moves an email to a different mailbox.
    name: gmail-move-mail-to-mailbox
    outputs:
    - contextPath: Gmail.ID
      description: Inner ID of the Gmail message.
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID.
      type: string
    - contextPath: Gmail.Format
      description: MIME type of email.
      type: string
    - contextPath: Gmail.Labels
      description: Labels of the specific email.
      type: string
    - contextPath: Gmail.To
      description: Gmail address of the receiver.
      type: string
    - contextPath: Gmail.From
      description: Gmail address of the sender.
      type: string
    - contextPath: Gmail.Cc
      description: Additional recipient email address (CC).
      type: string
    - contextPath: Gmail.Bcc
      description: Additional recipient email address (BCC).
      type: string
    - contextPath: Gmail.Subject
      description: Subject of the specific email.
      type: string
    - contextPath: Gmail.Body
      description: The content of the email.
      type: string
    - contextPath: Gmail.Attachments
      description: The attachments of the email. IDs are separated by ','.
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific the email (list).
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The Gmail mailbox.
      type: string
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.CC
      description: Additional recipient email address (CC).
      type: String
    - contextPath: Email.BCC
      description: Additional recipient email address (BCC).
      type: String
    - contextPath: Email.Format
      description: The format of the email.
      type: String
    - contextPath: Email.Body/HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.Body/Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Headers
      description: The headers of the email.
      type: String
    - contextPath: Email.Attachments.entryID
      description: Emails attachments. IDs are separated by ','.
      type: Unknown
    - contextPath: Email.Date
      description: The date the email was received.
      type: String
  - arguments:
    - default: true
      description: The user's email address. The me special value can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: Email address in which to block messages.
      name: email-address
      required: true
    description: Adds a rule for email deletion by address.
    name: gmail-add-delete-filter
  - arguments:
    - default: true
      description: The user's email address. The me special value can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The sender's display name or email address.
      name: from
    - description: The recipient's display name or email address. Includes recipients
        in the "to", "cc", and "bcc" header fields. You can use the local part of
        the email address. For example, "example" and "example@" both match "example@gmail.com".
        This field is case-insensitive.
      name: to
    - description: The email subject.
      name: subject
    - description: Returns messages matching the specified query. Supports the same
        query format as the Gmail search box. For example, "from:someuser@example.com
        is:unread".
      name: query
    - description: Whether the message has any attachments.
      name: has-attachments
    - description: The size of the entire RFC822 message in bytes, including all headers
        and attachments.
      name: size
    - description: Comma-separated list of labels to add to the message.
      name: add-labels
    - description: Comma-separated list of labels to remove from the message.
      name: remove-labels
    - description: Email address that the message is to be forwarded. The email needs
        to be configured as a forwarding address, see https://support.google.com/mail/answer/10957?hl=en#null.
      name: forward
    - auto: PREDEFINED
      description: The message size in bytes compared to the size field.
      name: size-comparison
      predefined:
      - larger
      - smaller
    description: Add a new filter.
    name: gmail-add-filter
    outputs:
    - contextPath: GmailFilter.ID
      description: Filter ID.
      type: string
    - contextPath: GmailFilter.Mailbox
      description: Mailbox containing the filter.
      type: string
    - contextPath: GmailFilter.Criteria
      description: Filter Criteria.
      type: Unknown
    - contextPath: GmailFilter.Action
      description: Filter Action.
      type: Unknown
  - arguments:
    - description: User's email address. The "me" special value can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: Limit of the results list. Default is 100.
      name: limit
    - description: List filters associated with the email address.
      name: address
    description: List all filters in a user's mailbox.
    name: gmail-list-filters
    outputs:
    - contextPath: GmailFilter.ID
      description: Filter ID.
      type: string
    - contextPath: GmailFilter.Mailbox
      description: Mailbox containing the filter.
      type: string
    - contextPath: GmailFilter.Criteria
      description: Filter Criteria.
      type: Unknown
    - contextPath: GmailFilter.Action
      description: Filter Action.
      type: Unknown
  - arguments:
    - description: User's email address. The "me" special value can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: Comma separated list of filter IDs (can be retrieve using `gmail-list-filters`
        command)
      isArray: true
      name: filter_ids
      required: true
    description: Removes a Filter.
    name: gmail-remove-filter
  - arguments:
    - description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether to hide the user's visibility in the Global Directory.
        Can be False to hide the user, True to show the user in the directory (default).
      name: visible-globally
      predefined:
      - "true"
      - "false"
    description: Hide a user's contact information, such as email address, profile
      information in the Global Directory.
    name: gmail-hide-user-in-directory
    outputs:
    - contextPath: Account.Type
      description: The account type. For example, "AD", "LocalOS", "Google", "AppleID",
        and so on.
      type: String
    - contextPath: Account.ID
      description: The unique ID for the account (integration specific). For AD accounts
        this is the Distinguished Name (DN).
      type: String
    - contextPath: Account.DisplayName
      description: The display name.
      type: String
    - contextPath: Account.Email.Address
      description: The email address of the account.
      type: String
    - contextPath: Account.Gmail.Address
      description: Email assigned with current account.
      type: Unknown
    - contextPath: Account.Domain
      description: The domain of the account.
      type: String
    - contextPath: Account.Username
      description: The username of the account.
      type: String
    - contextPath: Account.OrganizationUnit
      description: The Organization Unit (OU) of the account.
      type: String
    - contextPath: Account.VisibleInDirectory
      description: Is the Account visible in the Global Directory.
      type: Boolean
    - contextPath: Account.Groups
      description: Groups in which the account belongs (integration specific). For
        example, for AD these are groups of which the account is memberOf.
      type: String
  - arguments:
    - description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: String formatted password for the user. Depends on the Password
        Policy of the Organization
      name: password
      required: true
    description: Sets the password for the user.
    name: gmail-set-password
  - arguments:
    - description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    description: Returns the auto-reply message set for the user-account.
    name: gmail-get-autoreply
    outputs:
    - contextPath: Account.Gmail.AutoReply.EnableAutoReply
      description: Flag that controls whether Gmail automatically replies to messages.
      type: Boolean
    - contextPath: Account.Gmail.AutoReply.ResponseBody
      description: Response body in plain text format.
      type: String
    - contextPath: Account.Gmail.AutoReply.ResponseSubject
      description: Optional text to add to the subject line in vacation responses.
        To enable auto-replies, the response subject or the response body must not
        be empty.
      type: String
    - contextPath: Account.Gmail.AutoReply.RestrictToContact
      description: Flag that determines whether responses are sent to recipients who
        are not in the user's list of contacts.
      type: String
    - contextPath: Account.Gmail.AutoReply.RestrcitToDomain
      description: Flag that determines whether responses are sent to recipients who
        are outside of the user's domain. This feature is only available for G Suite
        users.
      type: String
    - contextPath: Account.Gmail.Address
      description: Email assigned with the current account.
      type: String
  - arguments:
    - description: The user's email address. The "me" special value me can be used
        to indicate the authenticated user.
      name: user-id
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether Gmail automatically replies to messages. Boolean. Set to
        true to automatically reply (default).
      name: enable-autoReply
      predefined:
      - "true"
      - "false"
    - description: Optional text to add to the subject line in vacation responses.
        To enable auto-replies, either the response subject or the response body must
        not be empty.
      name: response-subject
    - description: Response body in plain text format.
      name: response-body
    description: 'Set auto-reply for the user. Note: if the body is not set, the current
      body will be deleted'
    name: gmail-set-autoreply
    outputs:
    - contextPath: Account.Gmail.AutoReply.EnableAutoReply
      description: Flag that controls whether Gmail automatically replies to messages.
      type: Boolean
    - contextPath: Account.Gmail.AutoReply.ResponseBody
      description: Response body in plain text format.
      type: String
    - contextPath: Account.Gmail.AutoReply.ResponseSubject
      description: Optional text to add to the subject line in vacation responses.
        To enable auto-replies, either the response subject or the response body must
        not be empty.
      type: String
    - contextPath: Account.Gmail.AutoReply.RestrictToContact
      description: Determines whether responses are sent to recipients who are not
        in the user's list of contacts.
      type: String
    - contextPath: Account.Gmail.AutoReply.RestrcitToDomain
      description: Determines whether responses are sent to recipients who are outside
        of the user's domain. This feature is only available for G Suite users.
      type: String
    - contextPath: Account.Gmail.Address
      description: Email assigned with the current account.
      type: String
  - arguments:
    - description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    - description: The email address of the delegate.
      name: delegate-email
      required: true
    description: Adds a delegate to the mailbox, without sending any verification
      email. The delegate user must be a member of the same G Suite organization as
      the delegator user and must be added using their primary email address, and
      not an email alias.
    name: gmail-delegate-user-mailbox
  - arguments:
    - description: Email addresses of the receiver.
      isArray: true
      name: to
      required: true
    - description: Email address of the sender.
      name: from
    - description: The contents (body) of the email to be sent in plain text.
      name: body
    - description: Subject for the email to be sent.
      name: subject
      required: true
    - description: A comma-separated list of IDs of War Room entries that contain
        the files that need be attached to the email.
      isArray: true
      name: attachIDs
    - description: Additional recipient email address (CC).
      isArray: true
      name: cc
    - description: Additional recipient email address (BCC).
      isArray: true
      name: bcc
    - description: The contents (body) of the email to be sent in HTML format.
      name: htmlBody
    - description: Address that needs to be used to reply to the message.
      name: replyTo
    - description: |-
        A comma-separated list of new names to rename attachments corresponding to the order that they were attached to the email.
                Examples - To rename first and third file attachNames=new_fileName1,,new_fileName3
                To rename second and fifth files attachNames=,new_fileName2,,,new_fileName5
      isArray: true
      name: attachNames
    - description: A comma-separated list of CID images to embed attachments inside
        the email.
      isArray: true
      name: attachCIDs
    - description: |-
        Textual name for an attached file. Multiple files are supported as a
                comma-separated list. For example, transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test
                2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
      name: transientFile
    - description: |-
        Content for the attached file. Multiple files are supported as a comma-separated
                list. For example, transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test
                2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
      name: transientFileContent
    - description: |-
        CID image for an attached file to include within the email body. Multiple files are
                supported as comma-separated list. (e.g. transientFile="t1.txt,temp.txt,t3.txt"
                transientFileContent="test 2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
      name: transientFileCID
    - description: 'A CSV list of additional headers in the format: headerName=headerValue.
        For example: "headerName1=headerValue1,headerName2=headerValue2".'
      isArray: true
      name: additionalHeader
    - description: |-
        'Replaces {varname} variables with values from this parameter. Expected
               values are in the form of a JSON document. For example, {"varname" :{"value" "some
               value", "key": "context key"}}. Each var name can either be provided with
               the value or a context key to retrieve the value.'
      name: templateParams
    description: Sends mail using Gmail.
    name: send-mail
    outputs:
    - contextPath: Gmail.SentMail.ID
      description: The immutable ID of the message.
      type: String
    - contextPath: Gmail.SentMail.Labels
      description: List of IDs of labels applied to this message.
      type: String
    - contextPath: Gmail.SentMail.ThreadId
      description: The ID of the thread in which the message belongs.
      type: String
    - contextPath: Gmail.SentMail.To
      description: The recipient of the email.
      type: String
    - contextPath: Gmail.SentMail.From
      description: The sender of the email.
      type: Unknown
    - contextPath: Gmail.SentMail.Cc
      description: Additional recipient email address (CC).
      type: String
    - contextPath: Gmail.SentMail.Bcc
      description: Additional recipient email address (BCC).
      type: String
    - contextPath: Gmail.SentMail.Subject
      description: The subject of the email.
      type: String
    - contextPath: Gmail.SentMail.Body
      description: The plain-text version of the email.
      type: Unknown
    - contextPath: Gmail.SentMail.MailBox
      description: The mailbox from which the mail was sent.
      type: String
  - arguments:
    - description: The user's email address. The "me" special value can be used to
        indicate the authenticated user.
      name: user-id
      required: true
    - description: The email address to remove from delegation.
      name: removed-mail
      required: true
    description: Removes a delegate from the mailbox, without sending any verification
      email. The delegate user must be a member of the same G Suite organization as
      the delegator user using their primary email address, and not an email alias.
    name: gmail-remove-delegated-mailbox
  dockerimage: demisto/google-api:1.0
  isfetch: true
  runonce: false
  script: |2-



    ''' IMPORTS '''
    import re
    import json
    import base64
    from datetime import datetime, timedelta
    import httplib2
    import urlparse
    from distutils.util import strtobool
    import sys
    from HTMLParser import HTMLParser, HTMLParseError
    from htmlentitydefs import name2codepoint
    from email.mime.audio import MIMEAudio
    from email.mime.base import MIMEBase
    from email.mime.image import MIMEImage
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email.header import Header
    import mimetypes
    import random
    import string
    from apiclient import discovery
    from oauth2client import service_account
    import itertools as it


    ''' GLOBAL VARS '''
    ADMIN_EMAIL = None
    PRIVATE_KEY_CONTENT = None
    GAPPS_ID = None
    SCOPES = ['https://www.googleapis.com/auth/admin.directory.user.readonly']
    PROXY = demisto.params().get('proxy')
    DISABLE_SSL = demisto.params().get('insecure', False)
    FETCH_TIME = demisto.params().get('fetch_time', '1 days')

    ''' HELPER FUNCTIONS '''


    class TextExtractHtmlParser(HTMLParser):
        def __init__(self):
            HTMLParser.__init__(self)
            self._texts = []  # type: list
            self._ignore = False

        def handle_starttag(self, tag, attrs):
            if tag in ('p', 'br') and not self._ignore:
                self._texts.append('\n')
            elif tag in ('script', 'style'):
                self._ignore = True

        def handle_startendtag(self, tag, attrs):
            if tag in ('br', 'tr') and not self._ignore:
                self._texts.append('\n')

        def handle_endtag(self, tag):
            if tag in ('p', 'tr'):
                self._texts.append('\n')
            elif tag in ('script', 'style'):
                self._ignore = False

        def handle_data(self, data):
            if data and not self._ignore:
                stripped = data.strip()
                if stripped:
                    self._texts.append(re.sub(r'\s+', ' ', stripped))

        def handle_entityref(self, name):
            if not self._ignore and name in name2codepoint:
                self._texts.append(unichr(name2codepoint[name]))

        def handle_charref(self, name):
            if not self._ignore:
                if name.startswith('x'):
                    c = unichr(int(name[1:], 16))
                else:
                    c = unichr(int(name))
                self._texts.append(c)

        def get_text(self):
            return "".join(self._texts)


    def html_to_text(html):
        parser = TextExtractHtmlParser()
        try:
            parser.feed(html)
            parser.close()
        except HTMLParseError:
            pass
        return parser.get_text()


    def get_http_client_with_proxy():
        proxies = handle_proxy()
        if not proxies or not proxies['https']:
            raise Exception('https proxy value is empty. Check Demisto server configuration')
        https_proxy = proxies['https']
        if not https_proxy.startswith('https') and not https_proxy.startswith('http'):
            https_proxy = 'https://' + https_proxy
        parsed_proxy = urlparse.urlparse(https_proxy)
        proxy_info = httplib2.ProxyInfo(
            proxy_type=httplib2.socks.PROXY_TYPE_HTTP,  # disable-secrets-detection
            proxy_host=parsed_proxy.hostname,
            proxy_port=parsed_proxy.port,
            proxy_user=parsed_proxy.username,
            proxy_pass=parsed_proxy.password)
        return httplib2.Http(proxy_info=proxy_info, disable_ssl_certificate_validation=DISABLE_SSL)


    def get_credentials(additional_scopes=None, delegated_user=None):
        """Gets valid user credentials from storage.

        If nothing has been stored, or if the stored credentials are invalid,
        the OAuth2 flow is completed to obtain the new credentials.

        Returns:
            Credentials, the obtained credential.
        """
        if not delegated_user or delegated_user == 'me':
            delegated_user = ADMIN_EMAIL
        scopes = SCOPES
        if additional_scopes is not None:
            scopes += additional_scopes

        cred = service_account.ServiceAccountCredentials.from_json_keyfile_dict(json.loads(PRIVATE_KEY_CONTENT),  # type: ignore
                                                                                scopes=scopes)

        return cred.create_delegated(delegated_user)


    def get_service(serviceName, version, additional_scopes=None, delegated_user=None):
        credentials = get_credentials(additional_scopes=additional_scopes, delegated_user=delegated_user)
        if PROXY or DISABLE_SSL:
            http_client = credentials.authorize(get_http_client_with_proxy())
            return discovery.build(serviceName, version, http=http_client)
        return discovery.build(serviceName, version, credentials=credentials)


    def parse_mail_parts(parts):
        body = u''
        html = u''
        attachments = []  # type: list
        for part in parts:
            if 'multipart' in part['mimeType']:
                part_body, part_html, part_attachments = parse_mail_parts(
                    part['parts'])
                body += part_body
                html += part_html
                attachments.extend(part_attachments)
            elif len(part['filename']) == 0:
                text = unicode(base64.urlsafe_b64decode(
                    part['body'].get('data', '').encode('ascii')), 'utf-8')
                if 'text/html' in part['mimeType']:
                    html += text
                else:
                    body += text

            else:
                if part['body'].get('attachmentId') is not None:
                    attachments.append({
                        'ID': part['body']['attachmentId'],
                        'Name': part['filename']
                    })

        return body, html, attachments


    def localization_extract(time_from_mail):
        if time_from_mail is None or len(time_from_mail) < 5:
            return '-0000', 0

        utc = time_from_mail[-5:]
        if utc[0] != '-' and utc[0] != '+':
            return '-0000', 0

        for ch in utc[1:]:
            if not ch.isdigit():
                return '-0000', 0

        delta_in_seconds = int(utc[0] + utc[1:3]) * 3600 + int(utc[0] + utc[3:]) * 60
        return utc, delta_in_seconds


    def create_base_time(internal_date_timestamp, header_date):
        """
        Args:
            internal_date_timestamp: The timestamp from the Gmail API response.
            header_date: The date string from the email payload.

        Returns: A date string in the senders local time in the format of "Mon, 26 Aug 2019 14:40:04 +0300"

        """
        # intenalDate timestamp has 13 digits, but epoch-timestamp counts the seconds since Jan 1st 1970
        # (which is currently less than 13 digits) thus a need to cut the timestamp down to size.
        timestamp_len = len(str(int(time.time())))
        if len(str(internal_date_timestamp)) > timestamp_len:
            internal_date_timestamp = int(str(internal_date_timestamp)[:timestamp_len])

        utc, delta_in_seconds = localization_extract(header_date)
        base_time = datetime.utcfromtimestamp(internal_date_timestamp) + \
            timedelta(seconds=delta_in_seconds)
        base_time = str(base_time.strftime('%a, %d %b %Y %H:%M:%S')) + " " + utc
        return base_time


    def get_email_context(email_data, mailbox):
        context_headers = email_data.get('payload', {}).get('headers', [])
        context_headers = [{'Name': v['name'], 'Value':v['value']}
                           for v in context_headers]
        headers = dict([(h['Name'].lower(), h['Value']) for h in context_headers])
        body = demisto.get(email_data, 'payload.body.data')
        body = body.encode('ascii') if body is not None else ''
        parsed_body = base64.urlsafe_b64decode(body)
        if email_data.get('internalDate') is not None:
            base_time = create_base_time(email_data.get('internalDate'), str(headers.get('date', '')))

        else:
            # in case no internalDate field exists will revert to extracting the date from the email payload itself
            # Note: this should not happen in any command other than other than gmail-move-mail which doesn't return the
            # email payload nor internalDate
            demisto.info("No InternalDate timestamp found - getting Date from mail payload - msg ID:" + str(email_data['id']))
            base_time = str(headers.get('date', ''))

        context_gmail = {
            'Type': 'Gmail',
            'Mailbox': ADMIN_EMAIL if mailbox == 'me' else mailbox,
            'ID': email_data.get('id'),
            'ThreadId': email_data.get('threadId'),
            'Labels': ', '.join(email_data.get('labelIds', [])),
            'Headers': context_headers,
            'Attachments': email_data.get('payload', {}).get('filename', ''),
            # only for format 'raw'
            'RawData': email_data.get('raw'),
            # only for format 'full' and 'metadata'
            'Format': headers.get('content-type', '').split(';')[0],
            'Subject': headers.get('subject'),
            'From': headers.get('from'),
            'To': headers.get('to'),
            # only for format 'full'
            'Body': unicode(parsed_body, 'utf-8'),

            # only for incident
            'Cc': headers.get('cc', []),
            'Bcc': headers.get('bcc', []),
            'Date': base_time,
            'Html': None,
        }

        context_email = {
            'ID': email_data.get('id'),
            'Headers': context_headers,
            'Attachments': {'entryID': email_data.get('payload', {}).get('filename', '')},
            # only for format 'raw'
            'RawData': email_data.get('raw'),
            # only for format 'full' and 'metadata'
            'Format': headers.get('content-type', '').split(';')[0],
            'Subject': headers.get('subject'),
            'From': headers.get('from'),
            'To': headers.get('to'),
            # only for format 'full'
            'Body/Text': unicode(parsed_body, 'utf-8'),

            'CC': headers.get('cc', []),
            'BCC': headers.get('bcc', []),
            'Date': base_time,
            'Body/HTML': None,
        }

        if 'text/html' in context_gmail['Format']:  # type: ignore
            context_gmail['Html'] = context_gmail['Body']
            context_gmail['Body'] = html_to_text(context_gmail['Body'])
            context_email['Body/HTML'] = context_gmail['Html']
            context_email['Body/Text'] = context_gmail['Body']

        if 'multipart' in context_gmail['Format']:  # type: ignore
            context_gmail['Body'], context_gmail['Html'], context_gmail['Attachments'] = parse_mail_parts(
                email_data.get('payload', {}).get('parts', []))
            context_gmail['Attachment Names'] = ', '.join(
                [attachment['Name'] for attachment in context_gmail['Attachments']])  # type: ignore
            context_email['Body/Text'], context_email['Body/HTML'], context_email['Attachments'] = parse_mail_parts(
                email_data.get('payload', {}).get('parts', []))
            context_email['Attachment Names'] = ', '.join(
                [attachment['Name'] for attachment in context_email['Attachments']])  # type: ignore

        return context_gmail, headers, context_email


    TIME_REGEX = re.compile(r'^([\w,\d: ]*) (([+-]{1})(\d{2}):?(\d{2}))?[\s\w\(\)]*$')


    def move_to_gmt(t):
        # there is only one time refernce is the string
        base_time, _, sign, hours, minutes = TIME_REGEX.findall(t)[0]
        if all([sign, hours, minutes]):
            seconds = -1 * (int(sign + hours) * 3600 + int(sign + minutes) * 60)
            parsed_time = datetime.strptime(
                base_time, '%a, %d %b %Y %H:%M:%S') + timedelta(seconds=seconds)
            return parsed_time.isoformat() + 'Z'
        else:
            return datetime.strptime(base_time, '%a, %d %b %Y %H:%M:%S').isoformat() + 'Z'


    def create_incident_labels(parsed_msg, headers):
        labels = [
            {'type': 'Email/ID', 'value': parsed_msg['ID']},
            {'type': 'Email/subject', 'value': parsed_msg['Subject']},
            {'type': 'Email/text', 'value': parsed_msg['Body']},
            {'type': 'Email/from', 'value': parsed_msg['From']},
            {'type': 'Email/html', 'value': parsed_msg['Html']},
        ]
        labels.extend([{'type': 'Email/to', 'value': to}
                       for to in headers.get('To', '').split(',')])
        labels.extend([{'type': 'Email/cc', 'value': cc}
                       for cc in headers.get('Cc', '').split(',')])
        labels.extend([{'type': 'Email/bcc', 'value': bcc}
                       for bcc in headers.get('Bcc', '').split(',')])
        for key, val in headers.items():
            labels.append({'type': 'Email/Header/' + key, 'value': val})

        return labels


    def emails_to_entry(title, raw_emails, format_data, mailbox):
        gmail_emails = []
        emails = []
        for email_data in raw_emails:
            context_gmail, _, context_email = get_email_context(email_data, mailbox)
            gmail_emails.append(context_gmail)
            emails.append(context_email)

        headers = {
            'minimal': ['Mailbox', 'ID', 'Labels', 'Attachment Names', ],
            'raw': ['MailBox', 'ID', 'Labels', 'Attachment Names', 'RawData'],
            'metadata': ['MailBox', 'ID', 'Subject', 'From', 'To', 'Labels', 'Attachment Names', 'Format'],
            'full': ['Mailbox', 'ID', 'Subject', 'From', 'To', 'Labels', 'Attachment Names', 'Format', 'Body'],
        }

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': raw_emails,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, gmail_emails, headers[format_data], removeNull=True),
            'EntryContext': {
                'Gmail(val.ID && val.ID == obj.ID)': gmail_emails,
                'Email(val.ID && val.ID == obj.ID)': emails
            }
        }


    def mail_to_incident(msg, service, user_key):
        parsed_msg, headers, _ = get_email_context(msg, user_key)

        file_names = []
        command_args = {
            'messageId': parsed_msg['ID'],
            'userId': user_key,
        }

        for attachment in parsed_msg['Attachments']:
            command_args['id'] = attachment['ID']
            result = service.users().messages().attachments().get(**command_args).execute()
            file_data = base64.urlsafe_b64decode(result['data'].encode('ascii'))

            # save the attachment
            file_result = fileResult(attachment['Name'], file_data)

            # check for error
            if file_result['Type'] == entryTypes['error']:
                demisto.error(file_result['Contents'])
                raise Exception(file_result['Contents'])

            file_names.append({
                'path': file_result['FileID'],
                'name': attachment['Name'],
            })
        # date in the incident itself is set to GMT time, the correction to local time is done in Demisto
        gmt_time = move_to_gmt(parsed_msg['Date'])

        incident = {
            'type': 'Gmail',
            'name': parsed_msg['Subject'],
            'details': parsed_msg['Body'],
            'labels': create_incident_labels(parsed_msg, headers),
            'occurred': gmt_time,
            'attachment': file_names,
            'rawJSON': json.dumps(parsed_msg),
        }
        return incident


    def organization_format(org_list):
        if org_list:
            return ','.join(str(org.get('name')) for org in org_list if org.get('name'))
        else:
            return None


    def users_to_entry(title, response, next_page_token=None):
        context = []

        for user_data in response:
            username = user_data.get('name').get('givenName') if user_data.get('name') \
                and 'givenName' in user_data.get('name') else None

            display = user_data.get('name').get('fullName') if user_data.get('name') \
                and 'fullName' in user_data.get('name') else None

            context.append({
                'Type': 'Google',
                'ID': user_data.get('id'),
                'UserName': username,
                'Username': username,  # adding to fit the new context standard
                'DisplayName': display,
                'Email': {'Address': user_data.get('primaryEmail')},
                'Gmail': {'Address': user_data.get('primaryEmail')},
                'Group': user_data.get('kind'),
                'Groups': user_data.get('kind'),  # adding to fit the new context standard
                'CustomerId': user_data.get('customerId'),
                'Domain': user_data.get('primaryEmail').split('@')[1],
                'VisibleInDirectory': user_data.get('includeInGlobalAddressList'),

            })
        headers = ['Type', 'ID', 'Username',
                   'DisplayName', 'Groups', 'CustomerId', 'Domain', 'OrganizationUnit', 'Email', 'VisibleInDirectory']

        human_readable = tableToMarkdown(title, context, headers, removeNull=True)

        if next_page_token:
            human_readable += "\nTo get further results, rerun the command with this page-token:\n" + next_page_token

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': human_readable,
            'EntryContext': {'Account(val.ID && val.Type && val.ID == obj.ID && val.Type == obj.Type)': context}
        }


    def autoreply_to_entry(title, response, user_id):
        autoreply_context = []
        for autoreply_data in response:
            autoreply_context.append({
                'EnableAutoReply': autoreply_data.get('enableAutoReply'),
                'ResponseBody': autoreply_data.get('responseBodyPlainText'),
                'ResponseSubject': autoreply_data.get('responseSubject'),
                'RestrictToContact': autoreply_data.get('restrictToContacts'),
                'RestrictToDomain': autoreply_data.get('restrictToDomain'),

            })
        headers = ['EnableAutoReply', 'ResponseBody',
                   'ResponseSubject', 'RestrictToContact', 'RestrictToDomain']

        account_context = {
            "Address": user_id,
            "AutoReply": autoreply_context
        }

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': autoreply_context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, autoreply_context, headers, removeNull=True),
            'EntryContext': {
                'Account.Gmail(val.Address == obj.Address)': account_context
            }
        }


    def sent_mail_to_entry(title, response, to, emailfrom, cc, bcc, bodyHtml, body, subject):
        gmail_context = []
        for mail_results_data in response:
            gmail_context.append({
                'Type': "Gmail",
                'ID': mail_results_data.get('id'),
                'Labels': mail_results_data.get('labelIds', []),
                'ThreadId': mail_results_data.get('threadId'),
                'To': ','.join(to),
                'From': emailfrom,
                'Cc': ','.join(cc) if len(cc) > 0 else None,
                'Bcc': ','.join(bcc) if len(bcc) > 0 else None,
                'Subject': subject,
                'Body': body,
                'Mailbox': ','.join(to)
            })

        headers = ['Type', 'ID', 'To', 'From', 'Cc', 'Bcc', 'Subject', 'Body', 'Labels',
                   'ThreadId']

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, gmail_context, headers, removeNull=True),
            'EntryContext': {'Gmail.SentMail(val.ID && val.Type && val.ID == obj.ID && val.Type == obj.Type)': gmail_context}
        }


    def roles_to_entry(title, response):
        context = []
        for role_data in response:
            context.append({
                'ID': role_data['roleId'],
                'AssignedTo': role_data['assignedTo'],
                'RoleAssignmentId': role_data['roleAssignmentId'],
                'ScopeType': role_data['scopeType'],
                'Kind': role_data['kind'],
                'OrgUnitId': role_data.get('orgUnitId', ''),
            })
        headers = ['ID', 'AssignedTo', 'RoleAssignmentId',
                   'ScopeType', 'Kind', 'OrgUnitId']

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers, removeNull=True),
            'EntryContext': {'Gmail.Role(val.ID && val.ID == obj.ID)': context}
        }


    def tokens_to_entry(title, response):
        context = []
        for token_data in response:
            context.append({
                'DisplayText': token_data.get('displayText'),
                'ClientId': token_data.get('clientId'),
                'Kind': token_data.get('kind'),
                'Scopes': token_data.get('scopes', []),
                'UserKey': token_data.get('userKey'),
            })

        headers = ['DisplayText', 'ClientId', 'Kind', 'Scopes', 'UserKey']

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers, removeNull=True),
            'EntryContext': {'Tokens(val.ClientId && val.ClientId == obj.ClientId)': context}
        }


    def filters_to_entry(title, mailbox, response):
        context = []
        for filter_data in response:
            context.append({
                'ID': filter_data.get('id'),
                'Mailbox': mailbox,
                'Criteria': filter_data.get('criteria'),
                'Action': filter_data.get('action'),
            })

        headers = ['ID', 'Criteria', 'Action', ]

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers, removeNull=True),
            'EntryContext': {'GmailFilter(val.ID && val.ID == obj.ID)': context}
        }


    ''' FUNCTIONS '''


    def list_users_command():
        args = demisto.args()
        domain = args.get('domain', ADMIN_EMAIL.split('@')[1])  # type: ignore
        customer = args.get('customer')
        event = args.get('event')
        view_type = args.get('view-type-public-domain', 'admin_view')
        query = args.get('query')
        sort_order = args.get('sort-order')
        max_results = args.get('max-results', 100)
        show_deleted = bool(strtobool(args.get('show-deleted', 'false')))
        projection = args.get('projection', 'basic')
        custom_field_mask = args.get(
            'custom_field_mask') if projection == 'custom' else None
        page_token = args.get('page-token')

        users, next_page_token = list_users(domain, customer, event, query, sort_order, view_type,
                                            show_deleted, max_results, projection, custom_field_mask, page_token)
        return users_to_entry('Users:', users, next_page_token)


    def list_users(domain, customer=None, event=None, query=None, sort_order=None, view_type='admin_view',
                   show_deleted=False, max_results=100, projection='basic', custom_field_mask=None, page_token=None):
        command_args = {
            'domain': domain,
            'customer': customer,
            'event': event,
            'viewType': view_type,
            'query': query,
            'sortOrder': sort_order,
            'projection': projection,
            'showDeleted': show_deleted,
            'maxResults': max_results,
            'pageToken': page_token
        }
        if projection == 'custom':
            command_args['customFieldMask'] = custom_field_mask

        service = get_service('admin', 'directory_v1')
        result = service.users().list(**command_args).execute()

        return result['users'], result.get('nextPageToken')


    def get_user_command():
        args = demisto.args()
        user_key = args.get('user-id')
        view_type = args.get('view-type-public-domain')
        projection = args.get('projection')
        customer_field_mask = args.get('customer-field-mask')

        result = get_user(user_key, view_type, projection, customer_field_mask)
        return users_to_entry('User {}:'.format(user_key), [result])


    def get_user(user_key, view_type, projection, customer_field_mask=None):
        command_args = {
            'userKey': user_key if user_key != 'me' else ADMIN_EMAIL,
            'projection': projection,
            'viewType': view_type,
        }
        if projection == 'custom':
            command_args['customFieldMask'] = customer_field_mask

        service = get_service('admin', 'directory_v1')
        result = service.users().get(**command_args).execute()

        return result


    def hide_user_command():
        args = demisto.args()
        user_key = args.get('user-id')
        hide_value = args.get('visible-globally')
        result = hide_user(user_key, hide_value)

        return users_to_entry('User {}:'.format(user_key,), [result])


    def hide_user(user_key, hide_value):
        command_args = {
            'userKey': user_key if user_key != 'me' else ADMIN_EMAIL,
            'body': {
                'includeInGlobalAddressList': hide_value,
            }}

        service = get_service('admin', 'directory_v1',
                              additional_scopes=['https://www.googleapis.com/auth/admin.directory.user'])
        result = service.users().update(**command_args).execute()

        return result


    def set_user_password_command():
        args = demisto.args()
        user_key = args.get('user-id')
        password = args.get('password')
        result = set_user_password(user_key, password)
        return result


    def set_user_password(user_key, password):
        command_args = {
            'userKey': user_key if user_key != 'me' else ADMIN_EMAIL,
            'body': {
                'password': password,
            }}

        service = get_service('admin', 'directory_v1',
                              additional_scopes=['https://www.googleapis.com/auth/admin.directory.user'])
        service.users().update(**command_args).execute()

        return 'User {} password has been set.'.format(command_args['userKey'])


    def get_autoreply_command():
        args = demisto.args()
        user_id = args.get('user-id', ADMIN_EMAIL)

        autoreply_message = get_autoreply(user_id)

        return autoreply_to_entry('User {}:'.format(user_id), [autoreply_message], user_id)


    def get_autoreply(user_id):
        command_args = {
            'userId': user_id
        }

        service = get_service('gmail', 'v1',
                              additional_scopes=['https://mail.google.com', 'https://www.googleapis.com/auth/gmail.modify',
                                                 'https://www.googleapis.com/auth/gmail.readonly',
                                                 'https://www.googleapis.com/auth/gmail.settings.basic'],
                              delegated_user=user_id)
        result = service.users().settings().getVacation(**command_args).execute()

        return result


    def set_autoreply_command():
        args = demisto.args()

        user_id = args.get('user-id')
        enable_autoreply = args.get('enable-autoReply')
        response_subject = args.get('response-subject')
        response_body_plain_text = args.get('response-body')

        autoreply_message = set_autoreply(user_id, enable_autoreply, response_subject, response_body_plain_text)

        return autoreply_to_entry('User {}:'.format(user_id), [autoreply_message], user_id)


    def set_autoreply(user_id, enable_autoreply, response_subject, response_body_plain_text):
        command_args = {
            'userId': user_id if user_id != 'me' else ADMIN_EMAIL,
            'body': {
                'enableAutoReply': enable_autoreply,
                'responseSubject': response_subject,
                'responseBodyPlainText': response_body_plain_text,
            }}

        service = get_service('gmail', 'v1', additional_scopes=['https://www.googleapis.com/auth/gmail.settings.basic'])
        result = service.users().settings().updateVacation(**command_args).execute()
        return result


    def remove_delegate_user_mailbox_command():
        args = demisto.args()
        user_id = args.get('user-id')
        delegate_email = args.get('removed-mail')
        return delegate_user_mailbox(user_id, delegate_email, False)


    def delegate_user_mailbox_command():
        args = demisto.args()
        user_id = args.get('user-id')
        delegate_email = args.get('delegate-email')
        return delegate_user_mailbox(user_id, delegate_email, True)


    def delegate_user_mailbox(user_id, delegate_email, delegate_token):
        service = get_service('gmail', 'v1', additional_scopes=['https://www.googleapis.com/auth/gmail.settings.sharing'])
        if delegate_token:  # guardrails-disable-line
            command_args = {
                'userId': user_id if user_id != 'me' else ADMIN_EMAIL,
                'body': {
                    'delegateEmail': delegate_email,
                }
            }

            service.users().settings().delegates().create(**command_args).execute()
            return 'Email {} has been delegated'.format(delegate_email)

        else:
            command_args = {
                'userId': user_id if user_id != 'me' else ADMIN_EMAIL,
                'delegateEmail': delegate_email
            }

            service.users().settings().delegates().delete(**command_args).execute()
            return 'Email {} has been removed from delegation'.format(delegate_email)


    def create_user_command():
        args = demisto.args()
        primary_email = args['email']
        first_name = args['first-name']
        family_name = args['family-name']
        password = args.get('password', '')

        if len(password) > 100 or len(password) < 8:
            raise ValueError('password must be over between 8 and 100 characters')

        result = create_user(primary_email, first_name, family_name, password)
        return users_to_entry('New User:', [result])


    def create_user(primary_email, first_name, family_name, password):
        command_args = {
            'primaryEmail': primary_email,
            'name': {
                'givenName': first_name,
                'familyName': family_name,
                'fullName': '%s %s' % (first_name, family_name, ),
            },
            'password': password
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.user'])
        result = service.users().insert(body=command_args).execute()

        return result


    def delete_user_command():
        args = demisto.args()
        user_key = args.get('user-id')

        return delete_user(user_key)


    def delete_user(user_key):
        command_args = {
            'userKey': user_key,
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.user'])
        service.users().delete(**command_args).execute()

        return 'User {} have been deleted.'.format(command_args['userKey'])


    def get_user_role_command():
        args = demisto.args()
        user_key = args['user-id']
        user_key = ADMIN_EMAIL if user_key == 'me' else user_key

        if GAPPS_ID is None:
            raise ValueError('Must provide Immutable GoogleApps Id')

        roles = get_user_role(user_key, GAPPS_ID)
        return roles_to_entry('User Roles of %s:' % (user_key, ), roles)


    def get_user_role(user_key, customer):
        command_args = {
            'customer': customer,
            'maxResults': 100,
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.rolemanagement.readonly',
             'https://www.googleapis.com/auth/admin.directory.rolemanagement'])
        result = service.roleAssignments().list(**command_args).execute()

        user_data = service.users().get(userKey=user_key).execute()

        return [role for role in result['items'] if role['assignedTo'] == user_data['id']]


    def revoke_user_roles_command():
        args = demisto.args()

        user_key = args.get('user-id')
        role_assignment_id = args['role-assignment-id']

        revoke_user_roles(user_key, role_assignment_id)
        return 'Role has been deleted.'


    def revoke_user_roles(user_id, role_assignment_id):
        command_args = {
            'customer': GAPPS_ID,
            'roleAssignmentId': role_assignment_id,
        }

        if GAPPS_ID is None:
            raise ValueError('Must provide Immutable GoogleApps Id')

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.rolemanagement'])
        return service.roleAssignments().delete(**command_args).execute()


    def get_user_tokens_command():
        args = demisto.args()
        user_id = args.get('user-id')
        user_id = ADMIN_EMAIL if user_id == 'me' else user_id

        tokens = get_user_tokens(user_id)

        return tokens_to_entry('Tokens:', tokens)


    def get_user_tokens(user_id):
        command_args = {
            'userKey': user_id,
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.user.security'])
        result = service.tokens().list(**command_args).execute()

        return result.get('items', [])


    def search_all_mailboxes():
        next_page_token = None
        service = get_service('admin', 'directory_v1')
        while True:
            command_args = {
                'maxResults': 100,
                'domain': ADMIN_EMAIL.split('@')[1],  # type: ignore
                'pageToken': next_page_token
            }

            result = service.users().list(**command_args).execute()
            next_page_token = result.get('nextPageToken')

            entries = [search_command(user['primaryEmail']) for user in result['users']]

            # if these are the final result push - return them
            if next_page_token is None:
                entries.append("Search completed")
                return entries

            # return midway results
            demisto.results(entries)


    def search_command(mailbox=None):
        args = demisto.args()

        user_id = args.get('user-id') if mailbox is None else mailbox
        mailbox = ADMIN_EMAIL if user_id == 'me' else user_id
        subject = args.get('subject', '')
        _from = args.get('from', '')
        to = args.get('to', '')
        before = args.get('before', '')
        after = args.get('after', '')
        filename = args.get('filename', '')
        _in = args.get('in', '')

        query = args.get('query', '')
        fields = args.get('fields')  # TODO
        label_ids = [lbl for lbl in args.get('labels-ids', '').split(',') if lbl != '']
        max_results = int(args.get('max-results', 100))
        page_token = args.get('page-token')
        include_spam_trash = args.get('include-spam-trash', False)
        has_attachments = args.get('has-attachments')
        has_attachments = None if has_attachments is None else bool(
            strtobool(has_attachments))

        if max_results > 500:
            raise ValueError(
                'maxResults must be lower than 500, got %s' % (max_results, ))

        mails, q = search(user_id, subject, _from, to, before, after, filename, _in, query,
                          fields, label_ids, max_results, page_token, include_spam_trash, has_attachments)

        res = emails_to_entry('Search in {}:\nquery: "{}"'.format(mailbox, q), mails, 'full', mailbox)
        return res


    def search(user_id, subject='', _from='', to='', before='', after='', filename='', _in='', query='',
               fields=None, label_ids=None, max_results=100, page_token=None, include_spam_trash=False,
               has_attachments=None):
        query_values = {
            'subject': subject,
            'from': _from,
            'to': to,
            'before': before,
            'after': after,
            'filename': filename,
            'in': _in,
            'has': 'attachment' if has_attachments else ''
        }
        q = ' '.join('%s:%s ' % (name, value, )
                     for name, value in query_values.iteritems() if value != '')
        q = ('%s %s' % (q, query, )).strip()

        command_args = {
            'userId': user_id,
            'q': q,
            'maxResults': max_results,
            'fields': fields,
            'labelIds': label_ids,
            'pageToken': page_token,
            'includeSpamTrash': include_spam_trash,
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            command_args['userId'])
        result = service.users().messages().list(**command_args).execute()

        return [get_mail(user_id, mail['id'], 'full') for mail in result.get('messages', [])], q


    def get_mail_command():
        args = demisto.args()
        user_id = args.get('user-id', ADMIN_EMAIL)
        _id = args.get('message-id')
        _format = args.get('format')

        mail = get_mail(user_id, _id, _format)
        return emails_to_entry('Email:', [mail], _format, user_id)


    def get_mail(user_id, _id, _format):
        command_args = {
            'userId': user_id,
            'id': _id,
            'format': _format,
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            delegated_user=command_args['userId'])
        result = service.users().messages().get(**command_args).execute()

        return result


    def get_attachments_command():
        args = demisto.args()
        user_id = args.get('user-id')
        _id = args.get('message-id')

        attachments = get_attachments(user_id, _id)

        return [fileResult(name, data) for name, data in attachments]


    def get_attachments(user_id, _id):
        mail_args = {
            'userId': user_id,
            'id': _id,
            'format': 'full',
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            delegated_user=mail_args['userId'])
        result = service.users().messages().get(**mail_args).execute()
        result = get_email_context(result, user_id)[0]

        command_args = {
            'userId': user_id,
            'messageId': _id,
        }
        files = []
        for attachment in result['Attachments']:
            command_args['id'] = attachment['ID']
            result = service.users().messages().attachments().get(**command_args).execute()
            file_data = base64.urlsafe_b64decode(result['data'].encode('ascii'))
            files.append((attachment['Name'], file_data))

        return files


    def move_mail_command():
        args = demisto.args()
        user_id = args.get('user-id')
        _id = args.get('message-id')
        add_labels = [lbl for lbl in args.get('add-labels', '').split(',') if lbl != '']
        remove_labels = [lbl for lbl in args.get(
            'remove-labels', '').split(',') if lbl != '']

        mail = move_mail(user_id, _id, add_labels, remove_labels)
        return emails_to_entry('Email:', [mail], 'full', user_id)


    def move_mail(user_id, _id, add_labels, remove_labels):
        command_args = {
            'userId': user_id,
            'id': _id,
            'body': {
                'addLabelIds': add_labels,
                'removeLabelIds': remove_labels,
            }

        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.modify'],
            delegated_user=user_id)
        result = service.users().messages().modify(**command_args).execute()

        return result


    def move_mail_to_mailbox_command():
        args = demisto.args()
        src_user_id = args.get('src-user-id')
        message_id = args.get('message-id')
        dst_user_id = args.get('dst-user-id')

        new_mail_id = move_mail_to_mailbox(src_user_id, message_id, dst_user_id)

        mail = get_mail(dst_user_id, new_mail_id, 'full')
        return emails_to_entry('Email:', [mail], 'full', dst_user_id)


    def move_mail_to_mailbox(src_mailbox, message_id, dst_mailbox):
        # get the original mail
        mail = get_mail(src_mailbox, message_id, 'raw')

        # import the mail to the destination mailbox
        command_args = {
            'userId': dst_mailbox,
            'body': {
                'raw': mail['raw'],
            }
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.modify'],
            delegated_user=dst_mailbox)
        result = service.users().messages().import_(**command_args).execute()

        # delete the original mail
        delete_mail(src_mailbox, message_id, True)

        return result['id']


    def delete_mail_command():
        args = demisto.args()
        user_id = args['user-id']
        _id = args['message-id']
        permanent = bool(strtobool(args.get('permanent', 'false')))

        return delete_mail(user_id, _id, permanent)


    def delete_mail(user_id, _id, permanent):
        command_args = {
            'userId': user_id,
            'id': _id,
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://mail.google.com',
             'https://www.googleapis.com/auth/gmail.modify'],
            delegated_user=command_args['userId'])
        if permanent:
            service.users().messages().delete(**command_args).execute()
            return 'Email has been successfully deleted.'
        else:
            service.users().messages().trash(**command_args).execute()
            return 'Email has been successfully moved to trash.'


    def get_thread_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        _id = args.get('thread-id')
        _format = args.get('format')

        messages = get_thread(user_id, _id, _format)

        return emails_to_entry('Emails of Thread:', messages, _format, user_id)


    def get_thread(user_id, _id, _format):
        command_args = {
            'userId': user_id,
            'id': _id,
            'format': _format
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            delegated_user=user_id)
        result = service.users().threads().get(**command_args).execute()

        return result['messages']


    def add_delete_filter_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        user_id = user_id if user_id.lower() != 'me' else ADMIN_EMAIL
        _from = args.get('email-address')

        _filter = add_filter(user_id, _from=_from, add_labels=['TRASH', ])

        return filters_to_entry('New filter:', user_id, [_filter])


    def add_filter_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        user_id = user_id if user_id.lower() != 'me' else ADMIN_EMAIL
        _from = args.get('from')
        to = args.get('to')
        subject = args.get('subject')
        query = args.get('query')
        has_attachments = args.get('has-attachments')
        size = args.get('size')
        size_comparison = args.get('size-comparison')
        forward = args.get('forward')
        add_labels = args.get('add-labels', '').split(',')
        add_labels = add_labels if any(add_labels) else None
        remove_labels = args.get('remove-labels', '').split(',')
        remove_labels = remove_labels if any(remove_labels) else None

        _filter = add_filter(user_id,
                             _from=_from,
                             to=to,
                             subject=subject,
                             query=query,
                             has_attachments=has_attachments,
                             size=size,
                             size_comparison=size_comparison,
                             forward=forward,
                             add_labels=add_labels,
                             remove_labels=remove_labels,
                             )

        return filters_to_entry('New filter:', user_id, [_filter])


    def add_filter(user_id, _from=None, to=None, subject=None, query=None, has_attachments=None, size=None,
                   size_comparison=None, forward=None, add_labels=None, remove_labels=None):
        command_args = {
            'userId': user_id,
            'body': {
                'criteria': {},
                'action': {},
            }
        }

        if _from is not None:
            command_args['body']['criteria']['from'] = _from
        if to is not None:
            command_args['body']['criteria']['to'] = to
        if subject is not None:
            command_args['body']['criteria']['subject'] = subject
        if query is not None:
            command_args['body']['criteria']['query'] = query
        if has_attachments is not None:
            command_args['body']['criteria']['hasAttachment'] = has_attachments
        if size is not None:
            command_args['body']['criteria']['size'] = size
        if size_comparison is not None:
            command_args['body']['criteria']['size_comparison'] = size_comparison
        if add_labels is not None:
            command_args['body']['action']['addLabelIds'] = add_labels
        if remove_labels is not None:
            command_args['body']['action']['removeLabelIds'] = remove_labels
        if forward is not None:
            command_args['body']['action']['forward'] = forward

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.settings.basic'],
            delegated_user=user_id)
        result = service.users().settings().filters().create(**command_args).execute()

        return result


    def list_filters_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        user_id = user_id if user_id.lower() != 'me' else ADMIN_EMAIL
        address = args.get('address')
        limit = int(args.get('limit', 100))

        filters = list_filters(
            user_id,
            address=address,
            limit=limit)

        return filters_to_entry('filters:', user_id, filters)


    def list_filters(user_id, address=None, limit=100):
        command_args = {
            'userId': user_id,
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.settings.basic'],
            delegated_user=user_id)
        result = service.users().settings().filters().list(**command_args).execute()
        filters = result.get('filter', [])
        if address is not None:
            filters = [f for f in filters if address in {f['criteria'].get('from'), f['criteria'].get('to')}]

        return filters[:limit]


    def remove_filter_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        ids = args.get('filter_ids', '')
        if isinstance(ids, STRING_TYPES):  # alternativly it could be an array
            ids = ids.split(',')

        for _id in ids:
            remove_filter(user_id, _id)

        return 'filters were removed successfully.'


    def remove_filter(user_id, _id):
        command_args = {
            'userId': user_id,
            'id': _id
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.settings.basic'],
            delegated_user=user_id)
        result = service.users().settings().filters().delete(**command_args).execute()

        return result


    '''MAIL SENDER FUNCTIONS'''


    def randomword(length):
        """
        Generate a random string of given length
        """
        letters = string.ascii_lowercase
        return ''.join(random.choice(letters) for i in range(length))


    def header(s):
        if not s:
            return None

        s_no_newlines = ' '.join(s.splitlines())
        return Header(s_no_newlines, 'utf-8')


    def template_params(paramsStr):
        """
        Translate the template params if they exist from the context
        """
        actualParams = {}
        if paramsStr:
            try:
                params = json.loads(paramsStr)

            except ValueError as e:
                return_error('Unable to parse templateParams: {}'.format(str(e)))
            # Build a simple key/value

            for p in params:
                if params[p].get('value'):
                    actualParams[p] = params[p]['value']

                elif params[p].get('key'):
                    actualParams[p] = demisto.dt(demisto.context(), params[p]['key'])

            return actualParams

        else:
            return None


    def transient_attachments(transientFile, transientFileContent, transientFileCID):
        if transientFile is None or len(transientFile) == 0:
            return []

        if transientFileContent is None:
            transientFileContent = []

        if transientFileCID is None:
            transientFileCID = []

        attachments = []
        for file_name, file_data, file_cid in it.izip_longest(transientFile, transientFileContent, transientFileCID):
            if file_name is None:
                break

            content_type, encoding = mimetypes.guess_type(file_name)
            if content_type is None or encoding is not None:
                content_type = 'application/octet-stream'

            main_type, sub_type = content_type.split('/', 1)

            attachments.append({
                'name': file_name,
                'maintype': main_type,
                'subtype': sub_type,
                'data': file_data,
                'cid': file_cid
            })

        return attachments


    def handle_html(htmlBody):
        """
        Extract all data-url content from within the html and return as separate attachments.
        Due to security implications, we support only images here
        We might not have Beautiful Soup so just do regex search
        """
        attachments = []
        cleanBody = ''
        lastIndex = 0
        for i, m in enumerate(
                re.finditer(r'<img.+?src=\"(data:(image\/.+?);base64,([a-zA-Z0-9+/=\r\n]+?))\"', htmlBody, re.I)):
            maintype, subtype = m.group(2).split('/', 1)
            att = {
                'maintype': maintype,
                'subtype': subtype,
                'data': base64.b64decode(m.group(3)),
                'name': 'image%d.%s' % (i, subtype)
            }
            att['cid'] = '%s@%s.%s' % (att['name'], randomword(8), randomword(8))
            attachments.append(att)
            cleanBody += htmlBody[lastIndex:m.start(1)] + 'cid:' + att['cid']
            lastIndex = m.end() - 1

        cleanBody += htmlBody[lastIndex:]
        return cleanBody, attachments


    def collect_inline_attachments(attach_cids):
        """
        collects all attachments which are inline - only used in html bodied emails
        """
        inline_attachment = []
        if attach_cids is not None and len(attach_cids) > 0:
            for cid in attach_cids:
                file = demisto.getFilePath(cid)
                file_path = file['path']

                content_type, encoding = mimetypes.guess_type(file_path)
                if content_type is None or encoding is not None:
                    content_type = 'application/octet-stream'
                main_type, sub_type = content_type.split('/', 1)

                fp = open(file_path, 'rb')
                data = fp.read()
                fp.close()

                inline_attachment.append({
                    'ID': cid,
                    'name': file['name'],
                    'maintype': main_type,
                    'subtype': sub_type,
                    'data': data,
                    'cid': cid
                })

            return inline_attachment


    def collect_manual_attachments():
        attachments = []
        for attachment in demisto.getArg('manualAttachObj') or []:
            res = demisto.getFilePath(os.path.basename(attachment['RealFileName']))

            path = res['path']
            content_type, encoding = mimetypes.guess_type(path)
            if content_type is None or encoding is not None:
                content_type = 'application/octet-stream'
            maintype, subtype = content_type.split('/', 1)

            if maintype == 'text':
                with open(path) as fp:
                    data = fp.read()
            else:
                with open(path, 'rb') as fp:
                    data = fp.read()
            attachments.append({
                'name': attachment['FileName'],
                'maintype': maintype,
                'subtype': subtype,
                'data': data,
                'cid': None
            })

        return attachments


    def collect_attachments(entry_ids, file_names):
        """
        Creates a dictionary containing all the info about all attachments
        """
        attachments = []
        entry_number = 0
        if entry_ids is not None and len(entry_ids) > 0:
            for entry_id in entry_ids:
                file = demisto.getFilePath(entry_id)
                file_path = file['path']
                if file_names is not None and len(file_names) > entry_number and file_names[entry_number] is not None:
                    file_name = file_names[entry_number]

                else:
                    file_name = file['name']

                content_type, encoding = mimetypes.guess_type(file_path)
                if content_type is None or encoding is not None:
                    content_type = 'application/octet-stream'

                main_type, sub_type = content_type.split('/', 1)

                fp = open(file_path, 'rb')
                data = fp.read()
                fp.close()
                attachments.append({
                    'ID': entry_id,
                    'name': file_name,
                    'maintype': main_type,
                    'subtype': sub_type,
                    'data': data,
                    'cid': None
                })
                entry_number += 1
        return attachments


    def attachment_handler(message, attachments):
        """
        Adds the attachments to the email message
        """
        for att in attachments:
            if att['maintype'] == 'text':
                msg_txt = MIMEText(att['data'], att['subtype'], 'utf-8')
                if att['cid'] is not None:
                    msg_txt.add_header('Content-Disposition', 'inline', filename=att['name'])
                    msg_txt.add_header('Content-ID', '<' + att['name'] + '>')

                else:
                    msg_txt.add_header('Content-Disposition', 'attachment', filename=att['name'])
                message.attach(msg_txt)

            elif att['maintype'] == 'image':
                msg_img = MIMEImage(att['data'], att['subtype'])
                if att['cid'] is not None:
                    msg_img.add_header('Content-Disposition', 'inline', filename=att['name'])
                    msg_img.add_header('Content-ID', '<' + att['name'] + '>')

                else:
                    msg_img.add_header('Content-Disposition', 'attachment', filename=att['name'])
                message.attach(msg_img)

            elif att['maintype'] == 'audio':
                msg_aud = MIMEAudio(att['data'], att['subtype'])
                if att['cid'] is not None:
                    msg_aud.add_header('Content-Disposition', 'inline', filename=att['name'])
                    msg_aud.add_header('Content-ID', '<' + att['name'] + '>')

                else:
                    msg_aud.add_header('Content-Disposition', 'attachment', filename=att['name'])
                message.attach(msg_aud)

            else:
                msg_base = MIMEBase(att['maintype'], att['subtype'])
                msg_base.set_payload(att['data'])
                if att['cid'] is not None:
                    msg_base.add_header('Content-Disposition', 'inline', filename=att['name'])
                    msg_base.add_header('Content-ID', '<' + att['name'] + '>')

                else:
                    msg_base.add_header('Content-Disposition', 'attachment', filename=att['name'])
                message.attach(msg_base)


    def send_mail(emailto, emailfrom, subject, body, entry_ids, cc, bcc, htmlBody, replyTo, file_names, attach_cid,
                  transientFile, transientFileContent, transientFileCID, additional_headers, templateParams):
        message = MIMEMultipart()
        message['to'] = header(','.join(emailto))
        message['cc'] = header(','.join(cc))
        message['bcc'] = header(','.join(bcc))
        message['from'] = header(emailfrom)
        message['subject'] = header(subject)
        message['reply-to'] = header(replyTo)

        templateParams = template_params(templateParams)
        if templateParams is not None:
            if body is not None:
                body = body.format(**templateParams)

            if htmlBody is not None:
                htmlBody = htmlBody.format(**templateParams)

        if additional_headers is not None and len(additional_headers) > 0:
            for h in additional_headers:
                header_name_and_value = h.split('=')
                message[header_name_and_value[0]] = header(header_name_and_value[1])

        msg = MIMEText(body, 'plain', 'utf-8')
        message.attach(msg)
        htmlAttachments = []  # type: list
        inlineAttachments = []  # type: list

        if htmlBody is not None:
            htmlBody, htmlAttachments = handle_html(htmlBody)
            msg = MIMEText(htmlBody, 'html', 'utf-8')
            message.attach(msg)
            if attach_cid is not None and len(attach_cid) > 0:
                inlineAttachments = collect_inline_attachments(attach_cid)

        else:
            # if not html body, cannot attach cids in message
            transientFileCID = None

        attachments = collect_attachments(entry_ids, file_names)
        manual_attachments = collect_manual_attachments()
        transientAttachments = transient_attachments(transientFile, transientFileContent, transientFileCID)

        attachments = attachments + htmlAttachments + transientAttachments + inlineAttachments + manual_attachments
        attachment_handler(message, attachments)

        encoded_message = base64.urlsafe_b64encode(message.as_string())
        command_args = {
            'userId': emailfrom,
            'body': {
                'raw': encoded_message,
            }
        }
        service = get_service('gmail', 'v1', additional_scopes=['https://www.googleapis.com/auth/gmail.compose',
                                                                'https://www.googleapis.com/auth/gmail.send'])
        result = service.users().messages().send(**command_args).execute()
        return result


    def send_mail_command():
        args = demisto.args()
        emailto = argToList(args.get('to'))
        emailfrom = args.get('from')
        body = args.get('body')
        subject = args.get('subject')
        entry_ids = argToList(args.get('attachIDs'))
        cc = argToList(args.get('cc'))
        bcc = argToList(args.get('bcc'))
        htmlBody = args.get('htmlBody')
        replyTo = args.get('replyTo')
        file_names = argToList(args.get('attachNames'))
        attchCID = argToList(args.get('attachCIDs'))
        transientFile = argToList(args.get('transientFile'))
        transientFileContent = argToList(args.get('transientFileContent'))
        transientFileCID = argToList(args.get('transientFileCID'))
        additional_headers = argToList(args.get('additionalHeader'))
        template_param = args.get('templateParams')

        if emailfrom is None:
            emailfrom = ADMIN_EMAIL

        result = send_mail(emailto, emailfrom, subject, body, entry_ids, cc, bcc, htmlBody,
                           replyTo, file_names, attchCID, transientFile, transientFileContent,
                           transientFileCID, additional_headers, template_param)
        return sent_mail_to_entry('Email sent:', [result], emailto, emailfrom, cc, bcc, htmlBody, body, subject)


    '''FETCH INCIDENTS'''


    def fetch_incidents():
        params = demisto.params()
        user_key = params.get('queryUserKey')
        user_key = user_key if user_key else ADMIN_EMAIL
        query = '' if params['query'] is None else params['query']
        last_run = demisto.getLastRun()
        last_fetch = last_run.get('gmt_time')
        # handle first time fetch - gets current GMT time -1 day
        if last_fetch is None:
            last_fetch, _ = parse_date_range(date_range=FETCH_TIME, utc=True, to_timestamp=False)
            last_fetch = str(last_fetch.isoformat()).split('.')[0] + 'Z'

        last_fetch = datetime.strptime(last_fetch, '%Y-%m-%dT%H:%M:%SZ')
        current_fetch = last_fetch
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            user_key)

        query += last_fetch.strftime(' after:%Y/%m/%d')
        LOG('GMAIL: fetch parameters:\nuser: %s\nquery=%s\nfetch time: %s' %
            (user_key, query, last_fetch, ))

        result = service.users().messages().list(
            userId=user_key, maxResults=100, q=query).execute()

        incidents = []
        # so far, so good
        LOG('GMAIL: possible new incidents are %s' % (result, ))
        for msg in result.get('messages', []):
            msg_result = service.users().messages().get(
                id=msg['id'], userId=user_key).execute()
            incident = mail_to_incident(msg_result, service, user_key)
            temp_date = datetime.strptime(
                incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')
            # update last run
            if temp_date > last_fetch:
                last_fetch = temp_date + timedelta(seconds=1)

            # avoid duplication due to weak time query
            if temp_date > current_fetch:
                incidents.append(incident)

        demisto.info('extract {} incidents'.format(len(incidents)))
        demisto.setLastRun({'gmt_time': last_fetch.isoformat().split('.')[0] + 'Z'})
        return incidents


    def main():
        global ADMIN_EMAIL, PRIVATE_KEY_CONTENT, GAPPS_ID
        ADMIN_EMAIL = demisto.params()['adminEmail'].get('identifier', '')
        PRIVATE_KEY_CONTENT = demisto.params()['adminEmail'].get('password', '{}')
        GAPPS_ID = demisto.params().get('gappsID')
        ''' EXECUTION CODE '''
        COMMANDS = {
            'gmail-list-users': list_users_command,
            'gmail-get-user': get_user_command,
            'gmail-create-user': create_user_command,
            'gmail-delete-user': delete_user_command,
            'gmail-get-user-roles': get_user_role_command,
            'gmail-revoke-user-role': revoke_user_roles_command,
            'gmail-get-tokens-for-user': get_user_tokens_command,
            'gmail-search-all-mailboxes': search_all_mailboxes,
            'gmail-search': search_command,
            'gmail-get-mail': get_mail_command,
            'gmail-get-attachments': get_attachments_command,
            'gmail-move-mail': move_mail_command,
            'gmail-move-mail-to-mailbox': move_mail_to_mailbox_command,
            'gmail-delete-mail': delete_mail_command,
            'gmail-get-thread': get_thread_command,
            'gmail-add-filter': add_filter_command,
            'gmail-add-delete-filter': add_delete_filter_command,
            'gmail-list-filters': list_filters_command,
            'gmail-remove-filter': remove_filter_command,
            'gmail-hide-user-in-directory': hide_user_command,
            'gmail-set-password': set_user_password_command,
            'gmail-get-autoreply': get_autoreply_command,
            'gmail-set-autoreply': set_autoreply_command,
            'gmail-delegate-user-mailbox': delegate_user_mailbox_command,
            'gmail-remove-delegated-mailbox': remove_delegate_user_mailbox_command,
            'send-mail': send_mail_command
        }
        command = demisto.command()
        LOG('GMAIL: command is %s' % (command, ))
        try:
            if command == 'test-module':
                list_users(ADMIN_EMAIL.split('@')[1])
                demisto.results('ok')
                sys.exit(0)

            if command == 'fetch-incidents':
                demisto.incidents(fetch_incidents())
                sys.exit(0)

            cmd_func = COMMANDS.get(command)
            if cmd_func is None:
                raise NotImplementedError(
                    'Command "{}" is not implemented.'.format(command))

            else:
                demisto.results(cmd_func())  # type: ignore

        except Exception as e:
            import traceback
            if command == 'fetch-incidents':
                LOG(traceback.format_exc())
                LOG.print_log()
                raise

            else:
                return_error('GMAIL: {}'.format(str(e)), traceback.format_exc())


    # python2 uses __builtin__ python3 uses builtins
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  subtype: python2
  type: python
system: true
