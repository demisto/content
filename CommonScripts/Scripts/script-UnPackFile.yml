commonfields:
  id: UnPackFile
  version: -1
name: UnPackFile
script: >
  register_module_line('UnPackFile', 'start', __line__())

  demisto.debug('pack name = Common Scripts, pack version = 1.19.29')



  import os

  from os.path import isdir, isfile


  from pyunpack import Archive


  filePath = None

  fileEntryID = ''

  if 'fileName' in demisto.args() or 'lastPackedFileInWarroom' in demisto.args():
      entries = demisto.executeCommand('getEntries', {})
      for entry in entries:
          fn = demisto.get(entry, 'File')

          is_text = type(fn) in [unicode, str]
          is_correct_file = demisto.args().get('fileName', '').lower() == fn.lower()

          if is_text:
              if 'fileName' in demisto.args() and is_correct_file:
                  fileEntryID = entry['ID']
                  break
              if 'lastPackedFileInWarroom' in demisto.args() and fn.lower().endswith(demisto.args().get(
                      'lastPackedFileInWarroom', '').lower()):
                  fileEntryID = entry['ID']

      if fileEntryID == '':
          errorMessage = ''
          if 'fileName' in demisto.args():
              demisto.results({
                  'Type': entryTypes['error'],
                  'ContentsFormat': formats['text'],
                  'Contents': '"' + demisto.args().get('fileName') + '" no such file in the war room'
              })
          if 'lastPackedFileInWarroom' in demisto.args():
              demisto.results({
                  'Type': entryTypes['error'],
                  'ContentsFormat': formats['text'],
                  'Contents': 'Could not find "' + demisto.args().get('lastPackedFileInWarroom',
                                                                      '') + '" file in war room'
              })

          sys.exit(0)

  if 'entryID' in demisto.args():
      fileEntryID = demisto.args().get('entryID')

  if not fileEntryID:
      demisto.results({
          'Type': entryTypes['error'],
          'ContentsFormat': formats['text'],
          'Contents': 'You must set entryID or fileName or lastPackedFileInWarroom=i.e.(zip) when executing Unpack script'
      })
      sys.exit(0)

  res = demisto.executeCommand('getFilePath', {'id': fileEntryID})

  if res[0]['Type'] == entryTypes['error']:
      demisto.results({
          'Type': entryTypes['error'],
          'ContentsFormat': formats['text'],
          'Contents': 'Failed to get the file path for entry: ' + fileEntryID
      })
      sys.exit(0)

  filePath = res[0]['Contents']['path']


  filenames = []

  # remembering which files and dirs we currently have so we add them later as newly extracted files.

  excludedFiles = [f for f in os.listdir('.') if isfile(f)]

  excludedDirs = [d for d in os.listdir('.') if isdir(d)]


  # extracting the archive file

  Archive(filePath).extractall_patool('.', None)

  # recursing over the file system top down

  for root, directories, files in os.walk('.'):
      # removing the previously existing dirs from the search
      directories[:] = [d for d in directories if d not in excludedDirs]
      for f in files:
          # skipping previously existing files and verifying that the current file is a file and then adding it
          # to the extracted files list
          if f not in excludedFiles and isfile(os.path.join(root, f)):
              filenames.append(os.path.join(root, f))
  if len(filenames) == 0:
      demisto.results({
          'Type': entryTypes['error'],
          'ContentsFormat': formats['text'],
          'Contents': 'Could not find files in archive'
      })
  else:
      results = []
      # extracted files can be in sub directories so we save the base names of the files and also the full path of
      # the file
      files_base_names = [os.path.basename(file_path) for file_path in filenames]
      files_dic = {file_path: os.path.basename(file_path) for file_path in filenames}
      for file_path, file_name in files_dic.items():
          demisto.results(file_result_existing_file(file_path, file_name))
      results.append(
          {
              'Type': entryTypes['note'],
              'ContentsFormat': formats['json'],
              'Contents': {'extractedFiles': files_base_names},
              'EntryContext': {'ExtractedFiles': files_base_names,
                               'File(val.EntryID=="' + fileEntryID + '").Unpacked': True},
              'ReadableContentsFormat': formats['markdown'],
              'HumanReadable': tableToMarkdown('Extracted Files',
                                               [{'name': file_name, 'path': file_path} for file_path, file_name in
                                                files_dic.items()])
          })
      demisto.results(results)

  register_module_line('UnPackFile', 'end', __line__())
type: python
subtype: python2
tags:
- Utility
- file
comment: "Deprecated. Use the UnzipFile script instead. UnPack a file using fileName or entryID to specify a file. Files unpacked will be pushed to the war room and names will be pushed to the context.\nsupported types are:\n7z (.7z), ACE (.ace), ALZIP (.alz), AR (.a), ARC (.arc), ARJ (.arj), BZIP2 (.bz2), CAB (.cab), compress (.Z), CPIO (.cpio), DEB (.deb), DMS (.dms), GZIP (.gz), LRZIP (.lrz), LZH (.lha, .lzh), LZIP (.lz), LZMA (.lzma), LZOP (.lzo), RPM (.rpm), RAR (.rar), RZIP (.rz), TAR (.tar), XZ (.xz), ZIP (.zip, .jar) and ZOO (.zoo)"
enabled: true
args:
- name: fileName
  default: true
  description: Name of the file to unpack.
- name: entryID
  description: The entry id of the attached packed file in the warroom.
- name: lastPackedFileInWarroom
  description: Set to package file extension to look for the last of its kind in the war room.
outputs:
- contextPath: ExtractedFiles
  description: List of file names which extracted from package.
scripttarget: 0
dockerimage: demisto/unrar:1.4
fromversion: 5.0.0
deprecated: true
tests:
- No tests (auto formatted)
