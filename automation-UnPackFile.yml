args:
- default: true
  description: Name of the file to unpack
  name: fileName
- description: entry id of the attached packed file in the warroom
  name: entryID
- description: Set to package file extension to look for the last of its kind in the
    war room
  name: lastPackedFileInWarroom
comment: |-
  UnPack a file using fileName or entryID to specify a file. Files unpacked will be pushed to the war room and names will be pushed to the context.
  supported types are:
  7z (.7z), ACE (.ace), ALZIP (.alz), AR (.a), ARC (.arc), ARJ (.arj), BZIP2 (.bz2), CAB (.cab), compress (.Z), CPIO (.cpio), DEB (.deb), DMS (.dms), GZIP (.gz), LRZIP (.lrz), LZH (.lha, .lzh), LZIP (.lz), LZMA (.lzma), LZOP (.lzo), RPM (.rpm), RAR (.rar), RZIP (.rz), TAR (.tar), XZ (.xz), ZIP (.zip, .jar) and ZOO (.zoo)
commonfields:
  id: UnPackFile
  version: -1
dockerimage: demisto/unrar:1.4
enabled: true
name: UnPackFile
outputs:
- contextPath: ExtractedFiles
  description: list of file names which extracted from package
runonce: false
script: |-
  from pyunpack import Archive
  import os
  from os.path import isfile
  from os.path import isdir

  filePath = None
  fileEntryID = ''
  if demisto.args().has_key('fileName') or demisto.args().has_key('lastPackedFileInWarroom'):
      entries = demisto.executeCommand('getEntries', {})
      for entry in entries:
          fn = demisto.get(entry, 'File')

          is_text = type(fn) in [unicode, str]
          is_correct_file = demisto.args().get('fileName', '').lower() == fn.lower()

          if is_text:
              if demisto.args().has_key('fileName') and is_correct_file:
                  fileEntryID = entry['ID']
                  break
              if demisto.args().has_key('lastPackedFileInWarroom') and fn.lower().endswith(demisto.args().get('lastPackedFileInWarroom', '').lower()):
                  fileEntryID = entry['ID']

      if fileEntryID == '':
          errorMessage = ''
          if demisto.args().has_key('fileName'):
              demisto.results({
                  'Type': entryTypes['error'],
                  'ContentsFormat': formats['text'],
                  'Contents': '"' + demisto.args().get('fileName') + '" no such file in the war room'
              })
          if demisto.args().has_key('lastPackedFileInWarroom'):
              demisto.results({
                  'Type': entryTypes['error'],
                  'ContentsFormat': formats['text'],
                  'Contents': 'Could not find "' + demisto.args().get('lastPackedFileInWarroom', '') + '" file in war room'
              })

          sys.exit(0)

  if demisto.args().has_key('entryID'):
      fileEntryID = demisto.args().get('entryID')

  if not fileEntryID:
      demisto.results({
          'Type': entryTypes['error'],
          'ContentsFormat': formats['text'],
          'Contents': 'You must set entryID or fileName or lastPackedFileInWarroom=i.e.(zip) when executing Unpack script'
      })
      sys.exit(0)

  res = demisto.executeCommand('getFilePath', {'id': fileEntryID})
  if res[0]['Type'] == entryTypes['error']:
      demisto.results({
          'Type': entryTypes['error'],
          'ContentsFormat': formats['text'],
          'Contents': 'Failed to get the file path for entry: ' + fileEntryID
      })
      sys.exit(0)

  filePath = res[0]['Contents']['path']

  filenames = []
  # remembering which files and dirs we currently have so we add them later as newly extracted files.
  excludedFiles = [f for f in os.listdir('.') if isfile(f)]
  excludedDirs = [d for d in os.listdir('.') if isdir(d)]

  # extracting the archive file
  Archive(filePath).extractall_patool('.', None)
  # recursing over the file system top down
  for root, directories, files in os.walk('.'):
      # removing the previously existing dirs from the search
      directories[:] = [d for d in directories if d not in excludedDirs]
      for f in files:
          # skipping previously existing files and verifying that the current file is a file and then adding it to the extracted files list
          if f not in excludedFiles and isfile(os.path.join(root, f)):
              filenames.append(os.path.join(root,f))
  if len(filenames) == 0:
      demisto.results({
          'Type': entryTypes['error'],
          'ContentsFormat': formats['text'],
          'Contents': 'Could not find files in archive'
      })
  else:
      results = []
      # extracted files can be in sub directories so we save the base names of the files and also the full path of the file
      files_base_names = [os.path.basename(file_path) for file_path in filenames]
      files_dic = {file_path: os.path.basename(file_path) for file_path in filenames}
      for file_path, file_name in files_dic.items():
          demisto.results(file_result_existing_file(file_path, file_name))
      results.append(
          {
              'Type': entryTypes['note'],
              'ContentsFormat': formats['json'],
              'Contents': { 'extractedFiles': files_base_names },
              'EntryContext': { 'ExtractedFiles': files_base_names, 'File(val.EntryID=="' + fileEntryID + '").Unpacked': True },
              'ReadableContentsFormat' : formats['markdown'],
              'HumanReadable': tableToMarkdown('Extracted Files', [ { 'name': file_name , 'path': file_path } for file_path, file_name in files_dic.items()])
          })
      demisto.results(results)
scripttarget: 0
system: true
tags:
- Utility
- file
type: python
