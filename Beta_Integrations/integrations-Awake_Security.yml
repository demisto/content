commonfields:
  id: Awake Security
  version: -1
name: Awake Security
display: Awake Security
category: Network Security
image: data:image/png;base64,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
description: Network Traffic Analysis
detaileddescription: 'All commands expect timestamps in the following format: "2000-01-01T00:00:00Z"'
configuration:
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: false
- display: Awake Security server address
  name: address
  defaultvalue: ""
  type: 0
  required: false
- display: Verify server certificate
  name: verify
  defaultvalue: "True"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Comma-separated threat behaviors to generate incidents for
  name: threat_behaviors
  defaultvalue: ""
  type: 0
  required: false
- display: Period (in minutes) between incident reports
  name: period
  defaultvalue: "60"
  type: 0
  required: false
- display: Minimum Threshold
  name: min_threshold
  defaultvalue: "33"
  type: 0
  required: false
- display: Maximum Threshold
  name: max_threshold
  defaultvalue: "66"
  type: 0
  required: false
script:
  script: |
    import base64
    import datetime
    import re
    import requests


    params = demisto.params()
    address = params["address"]
    prefix = address + "/awakeapi/v1"
    verify = params["verify"]
    credentials = params["credentials"]
    identifier = credentials["identifier"]
    password = credentials["password"]
    authTokenRequest = {
      "loginUsername": identifier,
      "loginPassword": password
    }
    authTokenResponse = requests.post(prefix + "/authtoken", json=authTokenRequest, verify=verify)
    authToken = authTokenResponse.json()["token"]["value"]
    headers = {
        "Authentication": ("access " + authToken)
    }

    command = demisto.command()
    args = demisto.args()
    request = {}

    # Convenient utility to marshal command arguments into the request body
    def slurp(fields):
        for field in fields:
            if field in args:
                request[field] = args[field]

    # Render a subset of the fields of the Contents as a markdown table
    def displayTable(contents, fields):
        # We don't use a set() because we want to preserve field order
        #
        # The fields are ordered to put the most relevant information first
        presentFields = []
        # Omit table columns that are all empty
        for content in contents:
            for field in fields:
                if field in content and content[field] and field not in presentFields:
                    presentFields.append(field)
        line0 = "| "
        line1 = "| "
        for field in presentFields:
            # Translate camel-case field names to title-case space-separated words
            tokens = re.findall("[a-zA-Z][A-Z]*[^A-Z]*", field)
            name = " ".join(map(lambda token: token.title(), tokens))
            line0 += name + " | "
            line1 += "--- | "
        line0 += "\n"
        line1 += "\n"
        body = ""
        for content in contents:
            body += "| "
            for field in presentFields:
                if field in content:
                    value = json.dumps(content[field])
                else:
                    value = ""
                body += value + " | "
            body += "\n"
        if presentFields:
            return (line0 + line1 + body)
        else:
            return "Empty results"

    def returnResults(contents, humanReadable, dbotScore):
        machineReadable = {
            "AwakeSecurity": contents,
        }
        if dbotScore is not None:
            machineReadable["DBotScore"] = dbotScore
        results = {
            "Type": 1,
            "ContentsFormat": "json",
            "Contents": json.dumps(machineReadable),
            "HumanReadable": humanReadable,
            "ReadableContentsFormat": "markdown",
        }
        demisto.results(results)

    def toDBotScore(indicator_type, percentile, lookup_key):
        # Demisto's score - 0:unknown, 1:ok, 2:suspicous, 3:bad
        #
        # Our scores range from 0 to 100, where higher
        # scores mean more unusual behavior
        #
        # Our product does not yet assign meaning
        # to these scores since unusual behavior is
        # not necessarily malicious, but empirically
        # partioning the scores by quartile appears to
        # map closely enough to Demisto's classification
        # scheme for now.
        if percentile <= args['min_threshold']:
            # People doing something out of the ordinary
            # compared to others (i.e. performing weird
            # searches, learning something exotic, making
            # an unusual purchase)
            score = 1
        elif percentile <= args['max_threshold']:
            # Something doing multiple things out of the
            # ordinary, worth investigating
            score = 2
        else:
            # Probably bad or at least not compliant with
            # company policy.  You have to make an effort
            # to score this high.
            score = 3
        return {
            "Vendor": "Awake Security",
            "Type": indicator_type,
            "Indicator": lookup_key,
            "Score": score
        }

    def lookup(lookup_type, lookup_key):
        path = "/lookup/" + lookup_type
        request["lookup_key"] = lookup_key
        if "lookback_minutes" in args:
            request["lookback_minutes"] = int(args["lookback_minutes"])
        else:
            request["lookback_minutes"] = 480
        response = requests.post(prefix + path, json=request, headers=headers, verify=verify)
        return response.json()

    def lookupDevice(lookup_key):
        contents = lookup("device", lookup_key)
        humanReadableFields = [
            "deviceScore",
            "deviceName",
            "deviceType",
            "os",
            "osVersion",
            "commonEmail",
            "commonUsername",
            "tags",
            "recentIP",
            "activeIP",
            "nSimilarDevices",
            "ipCount",
            "applicationCount",
            "protocols",
            "firstSeen",
            "lastSeen",
        ]
        if "deviceScore" in contents:
            dbotScore = toDBotScore("device", contents["deviceScore"], lookup_key)
        else:
            dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'device',
                "Indicator": lookup_key,
                "Score": 0
            }
        humanReadable = displayTable([contents], humanReadableFields)
        returnResults(contents, humanReadable, dbotScore)

    def lookupDomain(lookup_key):
        contents = lookup("domain", lookup_key)
        humanReadableFields = [
            "notability",
            "isAlexaTopOneMillion",
            "isDGA",
            "intelSources",
            "numAssociatedDevices",
            "numAssociatedActivities",
            "approxBytesTransferred",
            "protocols",
            "firstSeen",
            "lastSeen",
        ]
        if "notability" in contents:
            dbotScore = toDBotScore("domain", contents["notability"], lookup_key)
        else:
            dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'domain',
                "Indicator": lookup_key,
                "Score": 0
            }
        humanReadable = displayTable([contents], humanReadableFields)
        returnResults(contents, humanReadable, dbotScore)

    def lookupEmail(lookup_key):
        contents = lookup("email", lookup_key)
        humanReadableFields = [
            "notabilityPercentile",
            "deviceName",
            "os",
            "deviceType",
            "application",
            "numberSimilarDevices",
            "numberSessions",
            "firstSeen",
            "lastSeen",
            "duration",
            "deviceId",
        ]
        if "notabilityPercentile" in contents:
            dbotScore = toDBotScore("email", contents["notabilityPercentile"], lookup_key)
        else:
            dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'email',
                "Indicator": lookup_key,
                "Score": 0
            }
        humanReadable = displayTable(contents, humanReadableFields)
        returnResults(contents, humanReadable, dbotScore)

    def lookupIp(lookup_key):
        contents = lookup("ip", lookup_key)
        humanReadableFields = [
            "deviceCount",
            "activityCount",
            "ipFirstSeen",
            "ipLastSeen",
        ]
        dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'ip',
                "Indicator": lookup_key,
                "Score": 0
            }
        # Note: No DBotScore for IP addresses as we do not score them.
        # Our product scores devices rather than IP addresses.
        humanReadable = displayTable([contents], humanReadableFields)
        returnResults(contents, humanReadable, dbotScore)

    def query(lookup_type):
        # Default to an empty query if unset
        request["queryExpression"] = ""
        slurp(["queryExpression", "startTime", "endTime"])
        nameMappings = [
            ("ipAddress","device.ip == {}"),
            ("deviceName","device.name like r/{}/"),
            ("domainName", "domain.name like r/{}/"),
            ("protocol", "activity.protocol == \"{}\""),
            ("tags","\"{}\" in device.tags"),
        ]
        for (name, mapping) in nameMappings:
            if name in args:
                if "queryExpression" in request and request["queryExpression"]:
                    request["queryExpression"] = request["queryExpression"] + " && " + mapping.format(args[name])
                else:
                    request["queryExpression"] = mapping.format(args[name])
        path = "/query/" + lookup_type
        response = requests.post(prefix + path, json=request, headers=headers, verify=verify)
        contents = response.json()
        return contents

    def queryActivities():
        contents = query("activities")
        humanReadableFields = [
            "sourceIP",
            "sourceHost",
            "sourcePort",
            "destIP",
            "destHost",
            "destPort",
            "activityDeviceName",
            "activityStart",
            "activityEnd",
            "protocols",
        ]
        humanReadable = displayTable(contents, humanReadableFields)
        returnResults(contents, humanReadable, None)

    def queryDevices():
        contents = query("devices")
        humanReadableFields = [
            "notabilityPercentile",
            "deviceName",
            "os",
            "deviceType",
            "application",
            "numberSimilarDevices",
            "numberSessions",
            "firstSeen",
            "lastSeen",
            "duration",
            "deviceId",
        ]
        humanReadable = displayTable(contents, humanReadableFields)
        returnResults(contents, humanReadable, None)

    def queryDomains():
        contents = query("domains")
        humanReadableFields = [
            "name",
            "notability",
            "created",
            "lastUpdated",
            "expiration",
            "registrantOrg",
            "registrantCountry",
            "registrarName",
            "nameservers",
            "deviceCount",
            "intelCount",
            "lastSeen",
        ]
        humanReadable = displayTable(contents, humanReadableFields)
        returnResults(contents, humanReadable, None)

    def pcapDownload():
        slurp(["monitoringPointID"])
        session = {}
        for field in [ "hostA", "hostB", "startTimeRFC3339Nano", "endTimeRFC3339Nano" ]:
            if field in args:
                session[field] = args[field]
        if "startTimeRFC3339Nano" in args:
            session["startTimeRFC3339Nano"] = args["startTime"]
        if "endTimeRFC3339Nano" in args:
            session["endTimeRFC3339Nano"] = args["endTime"]
        for field in [ "protocol", "portA", "portB" ]:
            if field in args:
                session[field] = int(args[field])
        request["sessions"] = [ session ]
        path = "/pcap/download"
        response = requests.post(prefix + path, json=request, headers=headers, verify=verify)
        b64 = response.json()["pcap"]
        bytes = base64.b64decode(b64)
        demisto.results(fileResult("download.pcap", bytes))

    def fetchIncidents():
        threatBehaviorsString = params.get("threat_behaviors") or ""
        threatBehaviors = [ threatBehavior.strip() for threatBehavior in threatBehaviorsString.split(",")]
        if threatBehaviors == [""]:
            threatBehaviors = []
        lastRun = demisto.getLastRun();
        formatString = "%Y-%m-%d %H:%M:%S+0000"
        earlyTimeString = "1970-01-01 00:00:00+0000"
        startTimeString = lastRun.get("time") or earlyTimeString
        startTime = datetime.datetime.strptime(startTimeString, formatString)
        endTime = datetime.datetime.utcnow()
        endTimeString = datetime.datetime.strftime(endTime, formatString)
        if datetime.timedelta(minutes=int(params['period'])) <= endTime - startTime:
            jsonRequest = {
                "startTime": startTimeString,
                "endTime": endTimeString,
                "threatBehaviors": threatBehaviors
            }
            response = requests.post(prefix + "/threat-behavior/matches", json=jsonRequest, headers=headers, verify=verify)
            jsonResponse = response.json()
            matchingThreatBehaviors = jsonResponse.get("matchingThreatBehaviors", [])
            def toIncident(matchingThreatBehavior):
                # Currently the threat behavior API doesn't allow us to retrieve metadata for
                # the behaviors that matched, which is why this incident record is mostly empty
                #
                # However, we can provide the original query that the threat behavior corresponded
                # to plus the date range so that a playbook can feed them back into
                # `awake-query-{devices,activities}` to retrieving the matching devices or
                # activities that triggered the match to the threat behavior.
                return {
                    "Name": matchingThreatBehavior["name"],
                    "Query": matchingThreatBehavior["query"],
                    "StartTime": startTimeString,
                    "EndTime": endTimeString,
                }
            demisto.incidents(map(toIncident, matchingThreatBehaviors))
            # Don't increase the low-water-mark until we actually find incidents
            #
            # This is a precaution because incidents sometimes appear in an old time
            # bucket after a delay
            if 0 < len(matchingThreatBehaviors):
                lastRun = { "time": endTimeString }
        else:
            demisto.incidents([])
        demisto.setLastRun(lastRun)

    ''' EXECUTION '''
    LOG('command is %s' % (command))

    try:
        if command == "test-module":
            # If we got this far we already successfully authenticated against the server
            demisto.results('ok')

        elif command == "fetch-incidents":
            fetchIncidents()

        elif command == "awake-query-devices":
            queryDevices()

        elif command == "awake-query-activities":
            queryActivities()

        elif command == "awake-query-domains":
            queryDomains()

        elif command == "awake-pcap-download":
            pcapDownload()

        elif command == "domain":
            lookupDomain(args["domain"])

        elif command == "email":
            lookupDomain(args["email"])

        elif command == "ip":
            lookupIp(args["ip"])

        elif command == "device":
            lookupDevice(args["device"])

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
  type: python
  commands:
  - name: awake-query-devices
    arguments:
    - name: queryExpression
      description: A query expression in the Awake Query Language
    - name: startTime
      required: true
      description: Beginning of the time range to query
    - name: endTime
      required: true
      description: End of the time range to query
    - name: ipAddress
      description: IP address (Exact match)
    - name: deviceName
      description: Name of the device (Regular expression)
    - name: domainName
      description: Name of the domain (Regular expression)
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: tag
      description: Tag to match (Regular expression)
    description: Query devices
  - name: awake-query-activities
    arguments:
    - name: queryExpression
      description: A query expression in the Awake Query Language
    - name: startTime
      required: true
      description: Beginning of the time range to query
    - name: endTime
      required: true
      description: End of the time range to query
    - name: ipAddress
      description: IP address (Exact match)
    - name: deviceName
      description: Name of the device (Regular expression)
    - name: domainName
      description: Name of the domain (Regular expression)
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: tag
      description: Tag to match (Regular expression)
    description: Query activities
  - name: awake-query-domains
    arguments:
    - name: queryExpression
      description: A query expression in the Awake Query Language
    - name: startTime
      required: true
      description: Beginning of the time range to query
    - name: endTime
      required: true
      description: End of the time range to query
    - name: ipAddress
      description: IP address (Exact match)
    - name: deviceName
      description: Name of the device (Regular expression)
    - name: domainName
      description: Name of the domain (Regular expression)
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: tag
      description: Tag to match (Regular expression)
    description: Query domains
  - name: awake-pcap-download
    arguments:
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: hostA
      description: First host's address
    - name: hostB
      description: Second host's address
    - name: portA
      description: First host's port
    - name: portB
      description: Second host's port
    - name: startTime
      description: Beginning of the time range to query
    - name: endTime
      description: End of the time range to query
    description: Download a PAP
  - name: domain
    arguments:
    - name: domain
      required: true
      description: The domain name
    - name: lookback_minutes
      description: How many minutes of history to query
    description: Lookup a domain
  - name: ip
    arguments:
    - name: ip
      required: true
      description: The IP address
    - name: lookback_minutes
      description: How many minutes of history to query
    description: Lookup an IP address
  - name: email
    arguments:
    - name: email
      description: The email address
    - name: lookback_minutes
      description: How many minutes of history to query
    description: Lookup an email address
  - name: device
    arguments:
    - name: device
      required: true
      description: The device ID
    - name: lookback_minutes
      description: How many minutes of history to query
    description: Lookup a device
  isfetch: true
  runonce: false
releaseNotes: "-"
