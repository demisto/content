commonfields:
  id: ThreatQ_Beta
  version: -1
name: ThreatQ_Beta
display: ThreatQ
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: ThreatQ Integration
detaileddescription: "You must have a ThreatQ user account to retrieve an api token.
  The api token is required for all api requests. \nThreatQ provides indicator scoring
  weighting for indicators and their contextual information, such as sources, attributes,
  and indicator types, as they are added to ThreatQ.\nFor detailed information on
  ThreatQ scoring please refer to https://helpcenter.threatq.com/\n

  Note: This is a beta Integration, which lets you implement and test pre-release software. Since the integration is beta, it might contain bugs. Updates to the integration during the beta phase might include non-backward compatible features. We appreciate your feedback on the quality and usability of the integration to help us identify issues, fix them, and continually improve."
configuration:
- display: TQ API URL E.g. https://192.168.1.136/api
  name: apiUrl
  defaultvalue: ""
  type: 0
  required: true
- display: TQ Client ID
  name: client_id
  defaultvalue: ""
  type: 0
  required: true
- display: Email
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Insecure
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import os
    import datetime
    import requests
    import json

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''

    API_URL = demisto.params()['apiUrl']
    API_TOKEN_URL = API_URL + "/token"
    CLIENT_ID = demisto.params()['client_id']
    EMAIL = demisto.getParam('credentials').get('identifier')
    PASSWORD = demisto.getParam('credentials').get('password')
    USE_SSL = not demisto.params().get('insecure', False)


    ''' HELPER FUNCTIONS '''

    def load_proxy():
        # Load the system configured proxy if enabled in configuration
        proxy = {}
        if 'proxy' in demisto.params():
            proxy["http"] = os.environ["http_proxy"]
            proxy["https"] = os.environ["https_proxy"]
        return proxy

    PROXY = load_proxy()

    def get_errors_string_from_bad_request(bad_request_results):
        errors_list = bad_request_results.json().get("errors", [])
        errors_string = ""
        error_num = 1
        if errors_list:
            errors_string = "Errors from server: \n"
            for error in errors_list:
                errors_string += "Error #{0}: {1}\n".format(error_num, error)
                error_num += 1
        return errors_string

    # ThreatQ auth based on OAuth 2.0 credential grand method
    def tq_access():
        data = {'grant_type': 'password','email': EMAIL, 'password': PASSWORD, 'client_id': CLIENT_ID}
        access_token_response = requests.post(API_TOKEN_URL, data=data, verify=False, allow_redirects=False)

        tokens = json.loads(access_token_response.text)
        if int(access_token_response.status_code) >= 400:
            errors_string = get_errors_string_from_bad_request(access_token_response)
            error_message = "Authentication failed, unable to retrieve an access token.\n {}".format(errors_string)
            return_error(error_message)

        new_integration_context = {
            "access_token": tokens['access_token'],
            "access_token_creation_time": int(time.time()) -1, # decrementing one second to be on the safe side
            "access_token_expires_in": tokens['expires_in']
        }
        demisto.setIntegrationContext(new_integration_context)
        token = tokens['access_token']
        return token


    def access_token_not_expired():
            epoch_time_now = time.time()
            epoch_time_when_token_granted = demisto.getIntegrationContext().get("access_token_creation_time")
            token_time_until_expiration = demisto.getIntegrationContext().get("access_token_expires_in")
            return int(epoch_time_now) - int(epoch_time_when_token_granted) < int(token_time_until_expiration)


    def get_access_token():
        existing_access_token = demisto.getIntegrationContext().get("access_token")
        if existing_access_token and access_token_not_expired():
            return existing_access_token
        else:
            new_access_token = tq_access()
            return new_access_token


    # remove html tags from ThreatQ description field
    def cleanhtml(raw_html):
      cleanr = re.compile('<.*?>')
      cleantext = re.sub(cleanr, '', raw_html)
      return cleantext


    ''' Catch-all function for all command '''
    def query_tq(keyword):
        '''
        This function handles all the querying of threatq
        '''
        tq_url = API_URL + "/search?query=" + keyword
        access_token = get_access_token()
        api_call_headers = {'Authorization': 'Bearer ' + access_token}
        api_call_response = requests.get(tq_url, headers=api_call_headers, verify=False)

        response = json.loads(api_call_response.text)

        # Find ThreatQ object type and object id based on keyword search results

        try:
            object_type = str(response['data'][0]['object'])
            object_id = str(response['data'][0]['id']) # get the object id from the query results
        except Exception, e:
            results = {'ContentsFormat': formats['markdown'], 'Type': entryTypes['note'], 'Contents': "No results from ThreatQ"}
            return results
        results = describe_by_id(object_type,object_id)
        return results


    ''' FUNCTIONS '''

    ''' Get ThreatQ object details '''
    def describe_by_id(tq_obj_type,tq_obj_id):
        md = ''

        # build the ThreatQ query url
        if tq_obj_type == "indicator":
            tq_url = API_URL + "/indicators" + "/" + tq_obj_id
        elif tq_obj_type == "adversary":
            tq_url = API_URL + "/adversaries" + "/" + tq_obj_id
        elif tq_obj_type == "event":
            tq_url = API_URL + "/events" + "/" + tq_obj_id
        else:
            tq_url = API_URL + "/" + tq_obj_type + "/" + tq_obj_id

        # get ThreatQ response
        access_token = get_access_token()
        api_call_headers = {'Authorization': 'Bearer ' + access_token}
        api_call_response = requests.get(tq_url, headers=api_call_headers, verify=False)
        response = json.loads(api_call_response.text)

        if not response or len(response['data']) == 0:
            return "Found in ThreatQ, but no context"

        description = response['data']['description']
        name = response['data']['value']

        tq_attributes = None
        dbot_score = None

        if tq_obj_type == "indicator":
            result = tq_indicator(name)
            tq_attributes = result['attributes']
            dbot_score = result['dbotscore']


        # Description in clear text will be sent to War Room
        if description:
            clean_desc = cleanhtml(description)
        else:
            clean_desc = "No description found in ThreatQ"

        last_update = str(response['data']['updated_at'])

        tq_desc = {
            'name': name,
            'last_update' : last_update,
            'description' : clean_desc,
            'is_indicator': str(tq_obj_type == "indicator")
        }


        md += "## TQ Object: " + tq_obj_type + " ID: " + tq_obj_id + "\n"
        # Build a ThreatQ Response table
        md += tableToMarkdown('ThreatQ Response',tq_desc)

        if tq_obj_type == "indicator":
            if not tq_attributes or len(tq_attributes) == 0:
                md += "Found no attributs"
            else:
                md += tableToMarkdown("Attributes", tq_attributes)
                tq_desc.update(tq_attributes)

        entry2 = {
            'Type': entryTypes['note'],
            'Contents': tq_desc,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {'ThreatQ(val.name && val.name == obj.name)': createContext(tq_desc, removeNull=True)},
            }

        if dbot_score:
            entry2['EntryContext']['DBotScore(val.Vendor && val.Indicator && val.Vendor == obj.Vendor && val.Indicator == obj.Indicator)'] = createContext(dbot_score, removeNull=True)

        return entry2

    def create_dbot_score(ind_name, ind_score):

        return dbot_score
    ''' Get ThreatQ indicator's score and attributes '''

    def tq_indicator(indicator):
        '''
        This function parse all the attributes of an indicator
        '''
        tq_url = API_URL + "/indicators/?value=" + indicator + "&with=score,attributes,sources"

        # get ThreatQ response on indicators attributes
        access_token = get_access_token()
        api_call_headers = {'Authorization': 'Bearer ' + access_token}
        api_call_response = requests.get(tq_url, headers=api_call_headers, verify=False)
        try:
            response = json.loads(api_call_response.text)
        except requests.exceptions.RequestException as e:
            md += '## TQ cound not FIND this indicator\n'
            exit(1)
        # check if any attributes
        attributes = response["data"][0]["attributes"]
        score = response["data"][0]["score"]
        sources = response["data"][0]["sources"][0]
        gen_score = score["generated_score"]
        manual_score = score["manual_score"]
        source = sources["name"]

        if not manual_score:
            manual_score = 0

        ind_score = max(float(gen_score),float(manual_score))

        ''' TBD - ThreatQ score to dbot_score conversion '''
        if ind_score >= 8 :
            dbot_score = 3
            malicious = {
                'Vendor' : 'ThreatQ',
                'Detections' : 'high risk',
            }
        elif 4 < ind_score < 8:
            dbot_score = 2
            malicious = {
                'Vendor' : 'ThreatQ',
                'Detections' : 'mid risk',
            }
        elif ind_score <= 2:
            dbot_score = 1
            malicious = {
                'Vendor' : 'ThreatQ',
                'Detections' : 'low risk',
            }

        dbot_score = {
                    'Vendor' : 'ThreatQ',
                    'Indicator' : indicator,
                    'Type' : 'ip',
                    'Score' : dbot_score,
                    'Malicious' : malicious,
                }


        md = ''

        try:
            length = len(attributes)
            if length > 0:
                md += "## TQ found " + str(length) + " attributes\n"
            else:
                md += "## TQ found no attributes\n"
            tq_attr = {
                'name' : indicator,
                'score' : ind_score
            }

            for x in range(length):
                name = str(attributes[x]["name"])
                value = str(attributes[x]["value"])
                tq_attr[name] = value
                md += "Attribute " + name + " is " + value + "\n"
            tq_attr_context = dict(tq_attr)
        except:
            md += '## TQ could not EXTRACT attributes\n'
            pass

        entry3 = {
            'Type': entryTypes['note'],
            'Contents': tq_attr_context,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {'ThreatQ(val.name && val.name == obj.name)': createContext(tq_attr_context, removeNull=True),
                        'DBotScore(val.Vendor && val.Indicator && val.Vendor == obj.Vendor && val.Indicator == obj.Indicator)' :
                    createContext(dbot_score, removeNull=True),
            }
        }
        # demisto.results(entry3)
        return {'attributes': tq_attr_context,
                'dbotscore': dbot_score }


    ''' EXECUTION CODE '''
    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-module':
            token = tq_access()
            if token:
                demisto.results('ok')
            else:
                demisto.results('test failed')
        elif demisto.command() == 'tq-search-by-name':
            args = demisto.args()
            keyword = demisto.get(args, 'keyword')
            results = query_tq(keyword)
            demisto.results(results)
        elif demisto.command() == 'ip':
            args = demisto.args()
            ip = demisto.get(args, 'ip')
            results = query_tq(ip)
            demisto.results(results)
        elif demisto.command() == 'url':
            args = demisto.args()
            url = demisto.get(args, 'url')
            results = query_tq(url)
            demisto.results(results)
        elif demisto.command() == 'file':
            args = demisto.args()
            file = demisto.get(args, 'file')
            results = query_tq(file)
            demisto.results(results)

        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()

    except Exception, e:
        raise
        return_error(e)


    # Params are of the type given in the integration page creation.
  type: python
  subtype: python2
  commands:
  - name: tq-search-by-name
    arguments:
    - name: keyword
      required: true
      default: true
      description: keyword
      defaultValue: Naid
    outputs:
    - contextPath: ThreatQ.description
      description: Description
    - {}
    description: Search ThreatQ repository by keywords
  - name: ip
    arguments:
    - name: ip
      required: true
      description: IP address
      defaultValue: 8.8.8.8
    outputs:
    - contextPath: ThreatQ.score
      description: ThreatQ score
    - contextPath: ThreatQ.name
      description: ThreatQ name
    - contextPath: DBotScore.Vendor
      description: DBotScore Vendor
    - contextPath: DBotScore.Malicious
      description: DBotScore Malicious status
    description: 'Run ip check against ThreatQ '
  - name: url
    arguments:
    - name: url
      required: true
      description: URL or FQDN
      defaultValue: www.google.com
    outputs:
    - contextPath: ThreatQ.score
      description: ThreatQ score
    - contextPath: ThreatQ.name
      description: ThreatQ name
    - contextPath: DBotScore.Vendor
      description: DBotScore Vendor
    - contextPath: DBotScore.Malicious
      description: DBotScore Malicious status
    description: Run url check against ThreatQ
  - name: file
    arguments:
    - name: file
      description: File name, MD5 or SHA
      defaultValue: google.exe
    outputs:
    - contextPath: ThreatQ.score
      description: ThreatQ score
    - contextPath: ThreatQ.name
      description: ThreatQ name
    - contextPath: DBotScore.Vendor
      description: DBotScore Vendor
    - contextPath: DBotScore.Malicious
      description: DBotScore Malicious status
    description: Run file check against ThreatQ
  runonce: false
beta: true
tests:
- No test
