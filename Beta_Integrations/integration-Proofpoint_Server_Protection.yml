commonfields:
  id: Proofpoint Server Protection
  version: -1
name: Proofpoint Server Protection
display: Proofpoint Server Protection
category: Email Gateway
image: data:image/png;base64,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
description: Proofpoint email security appliance.
detaileddescription: |
  This integration was integrated and tested with version 8.11.12 of Proofpoint Server Protection.

  Note: This is a beta Integration, which lets you implement and test pre-release software. Since the integration is beta, it might contain bugs. Updates to the integration during the beta phase might include non-backward compatible features. We appreciate your feedback on the quality and usability of the integration to help us identify issues, fix them, and continually improve.
configuration:
- display: Server URL (e.g. https://192.168.0.1:10000)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (not secure)
  name: unsecure
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
script:
  script: |-
    ''' IMPORTS '''

    import requests
    from bs4 import BeautifulSoup
    import urllib
    import urllib2
    import time
    import ssl
    import re

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''

    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    USE_SSL = not demisto.params().get('unsecure', False)

    HEADERS = {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'
    }

    session = requests.Session()

    ''' HELPER FUNCTIONS '''

    def http_request(method, url_suffix, headers=None, data=None, allow_redirects=True):

        LOG('Running Proofpoint Server Protection request with URL=%s' % (SERVER + url_suffix))

        try:
            res = session.request(
                method,
                SERVER + url_suffix,
                headers=headers,
                data=data,
                verify=USE_SSL,
                allow_redirects=allow_redirects
            )
            if res.status_code not in {200, 302}:
                raise Exception('Your request failed with the following error: ' + res.content + str(res.status_code))
        except Exception, e:
            LOG(e)
            raise

        return res.content


    def login():

        cmd_url = '/admin'
        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'
        }
        r = http_request('GET', cmd_url, headers=headers, allow_redirects=False)

        cookies = session.cookies.get_dict()

        data = {
            'locale': 'enus',
            'user': USERNAME,
            'pass': PASSWORD,
            'login': 'Log In',
            'pps_magic': cookies['pps_magic']
        }
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36',
        }
        r = http_request('POST', cmd_url, headers=headers, data=data, allow_redirects=False)

    def logout():
        cmd_url = '/admin?logout=1'
        http_request('GET', cmd_url)

    def translate_timestamp(timestamp):
        timestamp_dict = {
            'Last15Minutes': 'minutesago 15',
            'Last60Minutes': 'minutesago 60',
            'Last3Hours': 'hoursago 3',
            'Last24Hours': 'hoursago 24',
            'Last7Days': 'daysago 7',
            'Last15Days': 'daysago 15',
            'Last30Days': 'daysago 30',
            'Last90Days': 'daysago 90'
        }
        return timestamp_dict[timestamp]

    ''' FUNCTIONS '''

    def download_email_command():

        message_id = demisto.args()['message_id']

        response = download_email(message_id)
        parsed_response = response.replace('<br/>', '\n')
        auth_index = parsed_response.index('Authentication')
        pre_index = parsed_response.index('</PRE>')
        eml_content = parsed_response[auth_index:pre_index]
        file_name = message_id + '.eml'
        demisto.results(fileResult(file_name, eml_content))

    def download_email(message_id):
        cmd_url = '/admin?module=Message&qtype=0&msgid={0}&file=quarantine/show_src.tt'.format(message_id)

        response = http_request('GET', cmd_url)

        return response

    def quarantine_messages_command():

        folder = demisto.args().get('folder', '')
        sender = demisto.args().get('sender', '')
        subject = demisto.args().get('subject', '')
        recipient = demisto.args().get('recipient', '')
        if all(v is None for v in [folder, sender, subject, recipient]):
            return_error('At least one argument is required')

        response = quarantine_messages(folder, sender, subject, recipient)
        soup = BeautifulSoup(response, 'lxml')
        # Get block_on class of type _qlist content
        block_on_class = soup.find('div', {'class': 'block_on', 'id': '_qlist'})
        # Get script tag content
        script_tag_content = block_on_class.findAll('script', type='text/javascript')
        # There are 2 script tags - we need to second one
        raw_messages_list = script_tag_content[1].text
        # Parsing the content (string) to a list that we can work with
        raw_messages_list = raw_messages_list.split('dl(')
        # We don't need the first 2 elements
        raw_messages_list = raw_messages_list[2:]
        # Extracting the data for the raw list
        messages = []

        for raw_message in raw_messages_list:
            parsed_message = raw_message.split(',')
            messages.append({
                'ID': parsed_message[2].replace('"', ''),
                'Sender': parsed_message[9].replace('"', ''),
                'Recipient': parsed_message[10].replace('"', ''),
                'Date': parsed_message[11].replace('"', ''),
                'Subject': parsed_message[12].replace('"', ''),
                'Folder': parsed_message[19].replace('"', '')
            })

        if messages:
            ec = {
                'Proofpoint.Quarantine.Message(val.ID === obj.ID)': messages
            }
            headers = ['ID', 'Sender', 'Recipient', 'Date', 'Subject', 'Folder']
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('Proofpoint Server Protection Quarantine Search Messages Results', messages, headers),
                'EntryContext': ec
            })
        else:
            demisto.results('No results found')

    def quarantine_messages(folder, sender, subject, recipient):

        cmd_url = '/admin'
        data = {
            'module': 'Quarantine',
            'method': 'get',
            'cmd': 'search',
            'search_Folder': folder if folder else '/', # If folder is not given, we will search in all folders
            'search_wSender': 'c', # 'c' stands for Contains
            'search_Sender': sender,
            'search_wRecipients': 'c',
            'search_Recipients': recipient,
            'search_wSubject': 'c',
            'search_Subject': subject,
            'pps_magic': session.cookies.get_dict()['pps_magic']
        }
        raw_search_query = 'wSender=c;wRecipients=c;wSubject=c;'
        if folder:
            raw_search_query += 'Folder={};'.format(folder)
        else:
            raw_search_query += 'Folder=/;'
        if sender:
            raw_search_query += 'Sender={};'.format(sender)
        if subject:
            raw_search_query += 'Subject={};'.format(subject)
        if recipient:
            raw_search_query += 'Recipients={};'.format(recipient)
        search_query = urllib.quote(raw_search_query)
        session.cookies.set('searchquery', search_query)
        response = http_request('POST', cmd_url, data=data)
        return response

    def release_email_command():

        message_id = demisto.args()['message_id']
        folder = demisto.args()['folder']
        response = release_email(message_id, folder)
        if 'message successfully' in response:
            demisto.results('Released message {} successfully'.format(message_id))
        else:
            return_error('Failed to release message')

    def release_email(message_id, folder):

        cmd_url = '/admin'
        data = {
            'module': 'Quarantine',
            'cmd': 'release',
            'folder': folder,
            'message': message_id,
            'pps_magic': session.cookies.get_dict()['pps_magic']
        }
        response = http_request('POST', cmd_url, data=data)
        return response

    def smart_search_command():

        sender = demisto.args().get('sender')
        recipient = demisto.args().get('recipient')
        subject = demisto.args().get('subject')
        process = demisto.args().get('process')
        sender_hostname = demisto.args().get('sender_hostname')
        attachment = demisto.args().get('attachment')
        qid = demisto.args().get('qid')
        time = demisto.args().get('time')
        virus_name = demisto.args().get('virus_name')
        message_id = demisto.args().get('message_id')
        sid = demisto.args().get('sid')
        guid = demisto.args().get('guid')

        data = {
            'suborg': '-99', # Sub-Org: -All-
            'start_date': '',
            'start_time': '',
            'end_date': '',
            'end_time': '',
            'start_date_long': '',
            'start_time_long': '',
            'end_date_long': '',
            'end_time_long': '',
            'start': 0,
            'count': 100
        }
        time = translate_timestamp(time)
        data['time'] = time
        data['max_results'] = process
        if sender:
            data['sender'] = sender
        if recipient:
            data['recipients'] = recipient
        if subject:
            data['subject'] = subject
        if sender_hostname:
            data['sender_host'] = sender_hostname
        if attachment:
            data['attachment_names'] = attachment
        if qid:
            data['qid'] = qid
        if sid:
            data['sid'] = sid
        if message_id:
            data['message_id'] = message_id
        if virus_name:
            data['virus_names'] = virus_name
        if guid:
            data['guid'] = guid

        response = smart_search(data)
        matches = json.loads(response)['result']['match']
        if matches:
            output = []
            for match in matches:
                pretty_match = {key.replace('_', ''): value for key, value in match.items()}
                output.append(pretty_match)
            ec = {
                'Proofpoint.SmartSearch(val.QID === obj.QID)': output
            }
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('Proofpoint smart search results', output),
                'EntryContext': ec
            })
        else:
            demisto.results('No results found')

    def smart_search(data):
        pps_magic = session.cookies.get_dict()['pps_magic']

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36',
            'Content-Type': 'application/json-rpc',
            'X-Requested-With': 'XMLHttpRequest'
        }


        submit_search_data = json.dumps({
            'params': [data],
            'method': 'submitSearch',
            'id': 1
        })
        cmd_url = '/admin?module=RPC&class=SmartSearch&method=get&pps_magic=' + pps_magic
        submit_search_response = http_request('POST', cmd_url, headers=headers, data=submit_search_data)

        if submit_search_response:
            job_id = json.loads(submit_search_response)['result']['job_id']
            get_search_result_data = json.dumps({
                'params': [{
                    'job_id': job_id,
                    'timezone_offset_minutes': -480,
                    'start': 0,
                    'count': 100
                }],
                'method': 'getSearchResult',
                'id': 2
            })
            search_results_response = http_request('POST', cmd_url, headers=headers, data=get_search_result_data)

            return search_results_response
        return_error('Failed to get search results')

    def quarantine_folders_command():
        response = quarantine_folders()
        soup = BeautifulSoup(response, 'lxml')
        # Get block_on class content
        class_block_on = soup.find('div', {'class': 'block_on'})
        # Get script tag content
        script_tag_content = class_block_on.findAll('script', type='text/javascript')
        # There are 2 script tags - we need to second one
        raw_folders_names = script_tag_content[1].text
        # Parsing the content (string) to a list that we can work with
        parsed_folders_names = [row.split(',') for row in raw_folders_names.split('displayFolderEntry(')]
        # Removing first and last element of the list which are empty strings
        parsed_folders_names = parsed_folders_names[1:-1]
        folders = []
        for folder in parsed_folders_names:
            # Getting the first element from each row, which is the folder name
            folders.append({'Name': folder[1].replace('"', '')})
        ec = {
            'Proofpoint.Quarantine.Folder(val.Name === obj.Name)': folders
        }
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': folders,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Proofpoint Email Protection Quarantine Folders', folders),
            'EntryContext': ec
        })

    def quarantine_folders():
        cmd_url = '/admin?module=Folders'
        response = http_request('GET', cmd_url)
        return response

    def add_to_blocked_senders_list_command():

        blocked_sender = demisto.args()['email']

        raw_senders_list = get_senders_list()

        current_blocked_senders_list = re.findall(r'var _blacklist = "([^"]*)";', raw_senders_list)[0]

        blocked_senders_list = ''

        if current_blocked_senders_list:
            blocked_senders_list = '{0},{1}'.format(current_blocked_senders_list, blocked_sender)
        else:
            blocked_senders_list = blocked_sender
        add_to_blocked_senders_list(blocked_senders_list)

        demisto.results('Successfully {} added to the Blocked Senders list'.format(blocked_sender))


    def add_to_blocked_senders_list(blocked_senders_list):

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36'
        }
        pps_magic = session.cookies.get_dict()['pps_magic']
        data = {
            'pps_magic': pps_magic,
            'module': 'EnduserEntry',
            'chapter': '2',
            'subchapter': '0',
            'cmd': 'enduser_modify',
            'extracmd': '',
            'objtype': '1',
            'pass_change_attempt': '0',
            'guid': '257',
            'blacklist': blocked_senders_list
        }
        cmd_url = '/admin'
        response = http_request('POST', cmd_url, headers=headers, data=data)

    def add_to_safe_senders_list_command():

        safe_sender = demisto.args()['email']

        raw_senders_list = get_senders_list()

        current_safe_senders_list = re.findall(r'var _whitelist = "([^"]*)";', raw_senders_list)[0]

        safe_senders_list = ''

        if current_safe_senders_list:
            safe_senders_list = '{0},{1}'.format(current_safe_senders_list, safe_sender)
        else:
            safe_senders_list = safe_sender
        add_to_safe_senders_list(safe_senders_list)

        demisto.results('Successfully {} added to the Safe Senders list'.format(safe_sender))


    def add_to_safe_senders_list(safe_senders_list):

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36'
        }
        pps_magic = session.cookies.get_dict()['pps_magic']
        data = {
            'pps_magic': pps_magic,
            'module': 'EnduserEntry',
            'chapter': '2',
            'subchapter': '0',
            'cmd': 'enduser_modify',
            'extracmd': '',
            'objtype': '1',
            'pass_change_attempt': '0',
            'guid': '257',
            'whitelist': safe_senders_list
        }
        cmd_url = '/admin'
        response = http_request('POST', cmd_url, headers=headers, data=data)

    def remove_from_blocked_senders_list_command():

        unblocked_sender = demisto.args()['email']

        raw_senders_list = get_senders_list()

        current_blocked_senders_list = re.findall(r'var _blacklist = "([^"]*)";', raw_senders_list)[0]

        if unblocked_sender not in current_blocked_senders_list:
            return_error('Email is not in Blocked Senders list')

        blocked_senders_list = current_blocked_senders_list.replace(unblocked_sender, '')

        remove_from_blocked_senders_list(blocked_senders_list, unblocked_sender)

        demisto.results('Successfully {} removed from the Blocked Senders list'.format(unblocked_sender))


    def remove_from_blocked_senders_list(blocked_senders_list, unblocked_sender):

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36'
        }
        pps_magic = session.cookies.get_dict()['pps_magic']
        data = {
            'pps_magic': pps_magic,
            'module': 'EnduserEntry',
            'chapter': '2',
            'subchapter': '0',
            'cmd': 'enduser_modify',
            'extracmd': '',
            'objtype': '1',
            'pass_change_attempt': '0',
            'guid': '257',
            'blacklist': blocked_senders_list,
            'xblacklist': unblocked_sender
        }
        cmd_url = '/admin'
        response = http_request('POST', cmd_url, headers=headers, data=data)


    def remove_from_safe_senders_list_command():

        unsafe_sender = demisto.args()['email']

        raw_senders_list = get_senders_list()

        current_safe_senders_list = re.findall(r'var _whitelist = "([^"]*)";', raw_senders_list)[0]

        if unsafe_sender not in current_safe_senders_list:
            return_error('Email is not in Safe Senders list')

        safe_senders_list = current_safe_senders_list.replace(unsafe_sender, '')

        remove_from_safe_senders_list(safe_senders_list, unsafe_sender)

        demisto.results('Successfully {} removed from the Safe Senders list'.format(unsafe_sender))


    def remove_from_safe_senders_list(safe_senders_list, unsafe_sender):

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36'
        }
        pps_magic = session.cookies.get_dict()['pps_magic']
        data = {
            'pps_magic': pps_magic,
            'module': 'EnduserEntry',
            'chapter': '2',
            'subchapter': '0',
            'cmd': 'enduser_modify',
            'extracmd': '',
            'objtype': '1',
            'pass_change_attempt': '0',
            'guid': '257',
            'whitelist': safe_senders_list,
            'xwhitelist': unsafe_sender
        }
        cmd_url = '/admin'
        response = http_request('POST', cmd_url, headers=headers, data=data)


    def get_senders_list():

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36'
        }
        pps_magic = session.cookies.get_dict()['pps_magic']
        data = {
            'pps_magic': pps_magic,
            'module': 'EnduserEntry',
            'chapter': '2',
            'subchapter': '0',
            'cmd': 'tabs',
            'extracmd': '',
            'objtype': '1',
            'pass_change_attempt': '0',
            'guid': '257',
        }

        cmd_url = '/admin?module=EnduserEntry&load=1&guid=257&pps_magic={}'.format(pps_magic)
        response = http_request('GET', cmd_url, headers=headers)


        cmd_url = '/admin'
        response = http_request('POST', cmd_url, headers=headers, data=data)

        return response

    ''' EXECUTION CODE '''

    login()

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            # Tests successful login
            demisto.results('ok')

        elif demisto.command() == 'proofpoint-download-email':
            download_email_command()

        elif demisto.command() == 'proofpoint-quarantine-messages':
            quarantine_messages_command()

        elif demisto.command() == 'proofpoint-smart-search':
            smart_search_command()

        elif demisto.command() == 'proofpoint-quarantine-folders':
            quarantine_folders_command()

        elif demisto.command() == 'proofpoint-release-email':
            release_email_command()

        elif demisto.command() == 'proofpoint-add-to-blocked-senders-list':
            add_to_blocked_senders_list_command()

        elif demisto.command() == 'proofpoint-add-to-safe-senders-list':
            add_to_safe_senders_list_command()

        elif demisto.command() == 'proofpoint-remove-from-blocked-senders-list':
            remove_from_blocked_senders_list_command()

        elif demisto.command() == 'proofpoint-remove-from-safe-senders-list':
            remove_from_safe_senders_list_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise

    finally:
        logout()
  type: python
  commands:
  - name: proofpoint-download-email
    arguments:
    - name: message_id
      required: true
      default: true
      description: Email message ID to download
    description: Download email message by ID.
  - name: proofpoint-quarantine-messages
    arguments:
    - name: folder
      description: Folder name to quarantine.
    - name: sender
      description: Messages from sender to quarantine.
    - name: subject
      description: Messages subject to quarantine.
    - name: recipient
      description: Messages to recipient to quarantine.
    outputs:
    - contextPath: Proofpoint.Quarantine.Message.ID
      description: Message ID
      type: string
    - contextPath: Proofpoint.Quarantine.Message.Date
      description: Message date
      type: string
    - contextPath: Proofpoint.Quarantine.Message.Recipient
      description: Message recipient
      type: string
    - contextPath: Proofpoint.Quarantine.Message.Sender
      description: Message sender
      type: string
    - contextPath: Proofpoint.Quarantine.Message.Subject
      description: Message subject
      type: string
    - contextPath: Proofpoint.Quarantine.Message.Folder
      description: Message folder
      type: string
    description: Quarantine email message.
  - name: proofpoint-smart-search
    arguments:
    - name: sender
      description: Email sender.
    - name: recipient
      description: Email recipient.
    - name: subject
      description: Email subject.
    - name: process
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      - "3"
      - "4"
      - "5"
      - "100"
      - "200"
      - "500"
      - "1000"
      description: Max results
      defaultValue: "100"
    - name: sender_hostname
      description: Sender hostname/IP address
    - name: attachment
      description: Attachment name
    - name: qid
      description: QID
    - name: time
      auto: PREDEFINED
      predefined:
      - Last15Minutes
      - Last60Minutes
      - Last3Hours
      - Last24Hours
      - Last7Days
      - Last15Days
      - Last30Days
      - Last90Days
      description: Time period in which the email was recieved.
      defaultValue: Last24Hours
    - name: message_id
      description: Email message ID.
    - name: virus_name
      description: Virus name.
    - name: sid
      description: SID
    - name: guid
      description: GUID
    outputs:
    - contextPath: Proofpoint.SmartSearch.SMIMERecipients
      type: string
    - contextPath: Proofpoint.SmartSearch.FID
      type: string
    - contextPath: Proofpoint.SmartSearch.MessageID
      type: string
    - contextPath: Proofpoint.SmartSearch.Proofpoint.SmartSearch.Suborg
      type: string
    - contextPath: Proofpoint.SmartSearch.Agent
      type: string
    - contextPath: Proofpoint.SmartSearch.AttachmentNames
      type: string
    - contextPath: Proofpoint.SmartSearch.MoudleID
      type: string
    - contextPath: Proofpoint.SmartSearch.MessageSize
      type: string
    - contextPath: Proofpoint.SmartSearch.SpamScore
      type: string
    - contextPath: Proofpoint.SmartSearch.GUID
      type: string
    - contextPath: Proofpoint.SmartSearch.QuarantineRule
      type: string
    - contextPath: Proofpoint.SmartSearch.VirusNames
      type: string
    - contextPath: Proofpoint.SmartSearch.Subject
      type: string
    - contextPath: Proofpoint.SmartSearch.QID
      type: string
    - contextPath: Proofpoint.SmartSearch.FinalAction
      type: string
    - contextPath: Proofpoint.SmartSearch.DispositionAction
      type: string
    - contextPath: Proofpoint.SmartSearch.SID
      type: string
    - contextPath: Proofpoint.SmartSearch.SendmailToStat
      type: string
    - contextPath: Proofpoint.SmartSearch.Date
      type: date
    - contextPath: Proofpoint.SmartSearch.PERecipients
      type: string
    - contextPath: Proofpoint.SmartSearch.FQIN
      type: string
    - contextPath: Proofpoint.SmartSearch.FinalRule
      type: string
    - contextPath: Proofpoint.SmartSearch.SendmailStat
      type: string
    - contextPath: Proofpoint.SmartSearch.MessageSplit
      type: string
    - contextPath: Proofpoint.SmartSearch.Duration
      type: string
    - contextPath: Proofpoint.SmartSearch.SendmailAction
      type: string
    - contextPath: Proofpoint.SmartSearch.Sender
      type: string
    - contextPath: Proofpoint.SmartSearch.SendmailIPAddress
      type: string
    - contextPath: Proofpoint.SmartSearch.SendmailTo
      type: string
    - contextPath: Proofpoint.SmartSearch.Recipients
      type: string
    - contextPath: Proofpoint.SmartSearch.SendmailRawLog
      type: string
    - contextPath: Proofpoint.SmartSearch.TLS
      type: string
    - contextPath: Proofpoint.SmartSearch.QuarantineFolder
      type: string
    - contextPath: Proofpoint.SmartSearch.RawLog
      type: string
    - contextPath: Proofpoint.SmartSearch.DispositionSmtpProfile
      type: string
    - contextPath: Proofpoint.SmartSearch.PolicyRoutes
      type: string
    - contextPath: Proofpoint.SmartSearch.MessageEncrypted
      type: string
    - contextPath: Proofpoint.SmartSearch.SenderHost
      type: string
    - contextPath: Proofpoint.SmartSearch.SMIMRecipientsSigned
      type: string
    description: Searches for emails.
  - name: proofpoint-quarantine-folders
    arguments: []
    outputs:
    - contextPath: Proofpoint.Quarantine.Folder.Name
      description: Folder name
      type: string
    description: Returns a list of quarantined folders.
  - name: proofpoint-release-email
    arguments:
    - name: message_id
      required: true
      description: Email message ID to release.
    - name: folder
      required: true
      description: Email folder to release.
    description: Release email with virus scan
  - name: proofpoint-add-to-blocked-senders-list
    arguments:
    - name: email
      required: true
      description: Email to add to blocked senders list
    description: Adds an email address to blocked senders list.
  - name: proofpoint-add-to-safe-senders-list
    arguments:
    - name: email
      required: true
      description: Email to add to safe senders list
    description: Adds an email address to safe senders list.
  - name: proofpoint-remove-from-blocked-senders-list
    arguments:
    - name: email
      required: true
      description: Email to remove from blocked senders list
    description: Removes an email address from blocked senders list.
  - name: proofpoint-remove-from-safe-senders-list
    arguments:
    - name: email
      required: true
      description: Email to remove from safe senders list
    description: Removes an email address from safe senders list.
  dockerimage: demisto/bs4
  runonce: false
  subtype: python2
beta: true
