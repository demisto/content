commonfields:
  id: Tenable SecurityCenter
  version: -1
name: Tenable.sc
display: Tenable.sc
category: Vulnerability Management
image: data:image/png;base64,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
description: Tenable.sc consolidates and evaluates vulnerability data across your
  organization, prioritizing security risks and providing a clear view of your security
  posture.
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |
    import time
    import re
    from requests import Request, Session
    import requests
    import json
    import datetime


    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' CONSTANTS '''

    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    VERIFY_SSL = not demisto.params().get('unsecure', False)
    SESSION = None

    def get_server_url():
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    BASE_URL = get_server_url()
    SERVER_URL = BASE_URL + '/rest'

    def send_request(path, method = 'get', body=None, params=None, headers=None):
        body = body if body is not None else {}
        params = params if params is not None else {}

        url = '{}/{}'.format(SERVER_URL, path)

        headers = headers if headers is not None else get_headers()
        res = SESSION.request(method, url, data=json.dumps(body), params=params, auth=(USERNAME, PASSWORD), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            try:
                error = res.json()
            except:
                raise Exception('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))
            raise Exception('Got an error from TenableSC, code: {}, details: {}'.format(error['error_code'], error['error_msg']))
        return res.json()


    def get_headers():
            headers = {}
            headers['Accept'] = 'application/json'
            headers['Content-Type'] = 'application/json'

            return headers


    def send_login_request(login_body):
        path = 'token'
        url = '{}/{}'.format(SERVER_URL, path)

        headers = get_headers()
        res = SESSION.request('post', url, headers=headers, data=json.dumps(login_body), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            raise Exception('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))

        return res.json()


    def login(user_name, password):
        login_body = { 'username': user_name, 'password': password }
        login_response = send_login_request(login_body)

        if 'response' not in login_response:
            raise Exception('Could not retrieve login token')

        token = login_response['response'].get('token')
        # There might be a case where the API does not return a token because there are too many sessions with the same user.
        # In that case we need to add 'releaseSession = true'
        if not token:
            login_body['releaseSession'] = 'true'
            login_response = send_login_request(login_body)
            if 'response' not in login_response or 'token' not in login_response['response']:
                raise Exception('Could not retrieve login token')
            token = login_response['response']['token']

        return token


    def list_scans_command():
        res = list_scans()
        manageable = demisto.args().get('managable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return 'No scans found'

        scans_dicts = get_elements(res['response'], manageable)

        if len(scans_dicts) == 0:
            return 'No scans found'

        mapped_scans = [{'Name': s['name'], 'ID': s['id'], 'Description': s['description']} for s in scans_dicts]

        headers = [
        'ID',
        'Name',
        'Description'
        ]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scans", mapped_scans, headers, removeNull=True),
            'EntryContext': {
                  'Tenable.Scan(val.ID==obj.ID)': createContext(mapped_scans, removeNull=True)
            }
        }

        return entry

    def list_scans():
        path = 'scan'

        return send_request(path)


    def list_policies_command():
        res = get_policies()

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return 'No policies found'

        policies = get_elements(res['response'], manageable)

        if len(policies) == 0:
            return 'No policies found'

        headers = [
            'ID',
            'Name',
            'Description'
            ]

        mapped_policies = [{'ID': p['id'], 'Name': p['name'], 'Description': p['description']} for p in policies]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Policies", mapped_policies, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanPolicy(val.ID==obj.ID)': createContext(mapped_policies, removeNull=True)
            }
        }

        return entry


    def get_policies():
        path = 'policy'

        return send_request(path)

    def list_repositories_command():
        res = get_repositories()

        if not res or 'response' not in res or not res['response']:
            return 'No repositories found'


        repositories = res['response']

        if len(repositories) == 0:
            return 'No repositories found'

        headers = [
            'ID',
            'Name',
            'Description'
            ]

        mapped_repositories = [{'ID': r['id'], 'Name': r['name'], 'Description': r['description']} for r in repositories]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Repositories", mapped_repositories, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanRepository(val.ID==obj.ID)': createContext(mapped_repositories, removeNull=True)
            }
        }

        return entry


    def get_repositories():
        path = 'repository'

        return send_request(path)


    def list_credentials_command():
        res = get_credentials()

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return 'No credentials found'

        credentials = get_elements(res['response'], manageable)

        if len(credentials) == 0:
            return 'No credentials found'

        headers = [
            'ID',
            'Name',
            'Description',
            'Type'
            ]

        mapped_credentials = [{'ID': c['id'], 'Name': c['name'], 'Description': c['description'], 'Type': c['type']} for c in credentials]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Credentials", mapped_credentials, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Credential(val.ID==obj.ID)': createContext(mapped_credentials, removeNull=True)
            }
        }

        return entry


    def get_credentials():
        path = 'credential'

        return send_request(path)

    def list_assets_command():
        res = list_assets()

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return 'No assets found'

        assets = get_elements(res['response'], manageable)

        if len(assets) == 0:
            return 'No assets found'

        headers = [
            'ID',
            'Name',
            'Description'
            'IPCount',
            'Type'
            ]

        mapped_assets = [{'ID': a['id'], 'Name': a['name'], 'Description': a['description'], 'Type': a['type'], 'IPCount': a['ipCount']} for a in assets]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Assets", mapped_assets, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Asset(val.ID==obj.ID)': createContext(mapped_assets, removeNull=True)
            }
        }

        return entry

    def list_assets():
        path = 'asset'

        params = {
            'fields': 'id,name,description,ipCount,type'
        }

        return send_request(path, params=params)


    def list_reports_command():
        res = get_reports()

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return 'No reports found'

        reports = get_elements(res['response'], manageable)
        # Remove duplicates, take latest
        reports = [reduce(lambda x, y: x if int(x['modifiedTime']) > int(y['modifiedTime']) else y, filter(lambda e: e['name'] == n, reports)) for n in {r['name'] for r in reports}]

        if len(reports) == 0:
            return 'No reports found'

        headers = [
            'ID',
            'Name',
            'Description'
            ]

        mapped_reports = [{'ID': r['id'], 'Name': r['name'], 'Description': r['description']} for r in reports]

        hr = tableToMarkdown("Tenable.sc Report Definitions", mapped_reports, headers, removeNull=True)
        for r in mapped_reports:
            del r['Description']


        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'TenableSC.Report(val.ID==obj.ID)': createContext(mapped_reports, removeNull=True)
            }
        }

        return entry


    def get_reports():
        path = 'reportDefinition'

        params = {
            'fields': 'id,name,description,modifiedTime'
        }

        return send_request(path, params=params)


    def list_zones_command():
        res = get_zones()

        if not res or 'response' not in res or not res['response']:
            return 'No zones found'

        zones = res['response']

        if len(zones) == 0:
            return 'No repositories found'

        headers = [
            'ID',
            'Name',
            'Description',
            'IPList',
            'ActiveScanners'
            ]

        mapped_zones = [{'ID': z['id'], 'Name': z['name'], 'Description': z['description'], 'IPList': z['ipList'], 'ActiveScanners': z['activeScanners']} for z in zones]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Zones", mapped_zones, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanZone(val.ID==obj.ID)': createContext(mapped_zones, removeNull=True)
            }
        }

        return entry


    def get_repositories():
        path = 'repository'

        return send_request(path)

    def get_elements(elements, manageable):
        arrays = elements.get('manageable')
        dicts = []

        if manageable == 'false':
            arrays += elements.get('usable')
            no_dups = list(set([tuple(s.items()) for s in arrays]))
            dicts = [dict(s) for s in no_dups]
        else:
            dicts = arrays

        return dicts


    def create_scan_command():
        name = demisto.args()['name']
        repo_id = demisto.args()['repositoryID']
        policy_id = demisto.args().get('policyID')
        plugin_id = demisto.args().get('pluginID')
        description = demisto.args().get('description')
        zone_id = demisto.args().get('zoneID')
        schedule = demisto.args().get('schedule')
        asset_ids = argToList(demisto.args().get('assetIDs'))
        ips = argToList(demisto.args().get('ipList'))
        scan_virtual_hosts = demisto.args().get('scanVirtualHosts')
        report_ids = argToList(demisto.args().get('reportIDs'))
        credentials = demisto.args().get('credentials')
        timeout_action = demisto.args().get('timeoutAction')
        max_scan_time = demisto.args().get('maxScanTime')
        dhcp_track = demisto.args().get('dhcpTracking')
        rollover_type = demisto.args().get('rolloverType')
        schedule_start = demisto.args().get('scheduleStart')
        repeat_rule = demisto.args().get('repeatRule')
        dependent = demisto.args().get('dependentID')

        if not policy_id and not plugin_id:
            raise ValueError('Policy and/or Plugin ID must be provided')

        if not asset_ids and not ip_list:
            raise ValueError('Assets and/or IPs must be provided')

        if schedule == 'dependent' and not dependent:
            raise ValueError('Dependent schedule must include a dependent scan ID')

        res = create_scan(name, repo_id, policy_id, plugin_id, description, zone_id, schedule, asset_ids,
                         ips, scan_virtual_hosts, report_ids, credentials, timeout_action, max_scan_time, dhcp_track, rollover_type, schedule_start, repeat_rule, dependent)

        if not res or 'response' not in res:
            return 'Could not retrieve scan'

        scan = res['response']

        headers = [
            'ID',
            'CreatorID',
            'Name',
            'Type',
            'CreationTime',
            'OwnerName',
            'Reports'
        ]

        mapped_scan = {
            'ID': scan['id'],
            'CreatorID': scan['creator'].get('id'),
            'Name': scan['name'],
            'Type': scan['type'],
            'CreationTime': datetime.datetime.utcfromtimestamp(int(scan['createdTime'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'OwnerName': scan['owner'].get('name'),
            'Reports': demisto.dt(scan['reports'], 'id')
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan", mapped_scan, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Scan(val.ID==obj.ID)': createContext(mapped_scan, removeNull=True)
            }
        }

        return entry


    def create_scan(name, repo_id, policy_id, plugin_id, description, zone_id, schedule, asset_ids,
                    ips, scan_virtual_hosts, report_ids, credentials, timeout_action, max_scan_time, dhcp_track, rollover_type, schedule_start, repeat_rule, dependent):
        path = 'scan'

        scan_type = 'policy' if policy_id else 'plugin'

        body = {
            'name' : name,
            'type' : scan_type,
            'repository' : {
                'id' : repo_id
            }
        }

        if policy_id:
            body['policy'] = {
                'id': policy_id
            }

        if plugin_id:
            body['pluginID'] = plugin_id

        if description:
            body['description'] = description

        if zone_id:
            body['zone'] = {
                'id' : zone_id
            }

        if dhcp_track:
            body['dhcpTracking'] = dhcp_track

        if schedule:
            body['schedule'] = {
                'type' : schedule
            }

            if dependent:
                body['schedule']['dependentID'] = dependent

            if repeat_rule:
                body['schedule']['repeatRule'] = repeat_rule

        if report_ids:
            body['reports'] = [{'id' : r_id, 'reportSource' : 'individual'} for r_id in report_ids]

        if asset_ids:
            if str(asset_ids).startswith('All'):
                manageable = True if asset_ids == 'AllManageable' else False
                res = get_assets()
                assets = get_elements(res['response'], manageable)
                asset_ids = list(map(lambda a: a['id'], assets))
            body['assets'] = [{'id' : a_id} for a_id in asset_ids]

        if credentials:
            body['credentials'] = [{'id' : c_id} for c_id in credentials]

        if timeout_action:
            body['timeoutAction'] = timeout_action

        if scan_virtual_hosts:
            body['scanningVirtualHosts'] = scan_virtual_hosts

        if rollover_type:
            body['rolloverType'] = rollover_type

        if ips:
            body['ipList'] = ','.join(ips)

        if max_scan_time:
            body['maxScanTime'] = max_scan_time * 3600

        return send_request(path, method='post', body=body)

    def launch_scan_command():
        scan_id = demisto.args()['scanID']
        target_address = demisto.args().get('diagnosticTarget')
        target_password = demisto.args().get('diagnosticPassword')

        if (target_address and not target_password) or (target_password and not target_address):
            raise ValueError('If a target is provided, both IP/Hostname and the password must be provided')

        res = launch_scan(scan_id, {'address': target_address, 'password': target_password})

        if not res or 'response' not in res or not res['response'] or 'scanResult' not in res['response']:
            return 'Could not retrieve the scan'

        scan_result = res['response']['scanResult']

        headers = [
            'Name',
            'ResultID',
            'OwnerID',
            'JobID',
            'Status'
        ]

        mapped_scan = {
            'Name': scan_result['name'],
            'ResultID': scan_result['id'],
            'OwnerID': scan_result['ownerID'],
            'JobID': scan_result['jobID'],
            'Status': scan_result['status']
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan", mapped_scan, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Scan(val.ID==obj.ID)': createContext(mapped_scan, removeNull=True)
            }
        }

        return entry


    def launch_scan(scan_id, scan_target):
        path = 'scan/' + scan_id + '/launch'
        body = None
        if scan_target:
            body = {
                'diagnosticTarget': scan_target['address'],
                'diagnosticPassword': scan_target['password']
            }

        return send_request(path, 'post', body=body)

    def get_scan_status_command():
        scan_results_ids = argToList(demisto.args()['scanResultsID'])

        scans_results = []
        for scan_results_id in scan_results_ids:
            res = get_scan_results(scan_results_id)
            if not res or 'response' not in res or not res['response']:
                return 'Scan results not found'
            scans_results.append(res['response'])

        headers = [
            'Name',
            'Status',
            'Description'
        ]

        mapped_scans_results = [{'ID': scan_result['id'], 'Name': scan_result['name'],'Status': scan_result['status'], 'Description': scan_result['description']} for scan_result in scans_results]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Status", mapped_scans_results, headers, removeNull=True),
            'EntryContext': {
                  'Tenable.Scan(val.ID==obj.ID)': createContext(mapped_scans_results, removeNull=True)
            }
        }

        return entry


    def get_scan_results(scan_results_id):
        path = 'scanResult/' + scan_results_id

        return send_request(path)

    def get_scan_report_command():
        scan_results_id = demisto.args()['scanResultsID']
        vulnerabilities_to_get = argToList(demisto.args().get('vulnerabilitySeverity', []))

        if not isinstance(vulnerabilities_to_get, list):
            vulnerabilities_to_get = [vulnerabilities_to_get]

        res = get_scan_report(scan_results_id)

        if not res or 'response' not in res or not res['response']:
            return 'Scan results not found'

        scan_results = res['response']

        headers = [
            'Name',
            'Status',
            'Description',
            'ScannedIPs',
            'StartTime',
            'EndTime',
            'Checks',
            'ScannerName',
            'OwnerName',
            'RepositoryName'
        ]

        vuln_headers = [
            'ID',
            'Name',
            'Family',
            'Severity',
            'Total'
        ]

        mapped_results = {
            'ID': scan_results['id'],
            'Name': scan_results['name'],
            'Status': scan_results['status'],
            'Description': scan_results['description'],
            'Status': scan_results['status'],
            'Checks': scan_results['completedChecks'],
            'StartTime': datetime.datetime.utcfromtimestamp(int(scan_results['startTime'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'EndTime': datetime.datetime.utcfromtimestamp(int(scan_results['finishTime'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'ScannedIPs': scan_results['scannedIPs'],
            'OwnerName': scan_results['owner'].get('username'),
            'RepositoryName': scan_results['repository'].get('name')
        }

        hr = tableToMarkdown('Tenable.sc Scan ' + mapped_results['ID'] + ' Report', mapped_results, headers, removeNull=True)

        if len(vulnerabilities_to_get) > 0:
            vulns = get_vulnearbilites(scan_results_id)

            if isinstance(vulns, list):
                vulnerabilities = list(filter(lambda v: v['Severity'] in vulnerabilities_to_get, vulns))
                if vulnerabilities and len(vulnerabilities) > 0:
                    hr += tableToMarkdown("Vulnerabilities", vulnerabilities, vuln_headers, removeNull=True)
                    mapped_results['Vulnerability'] = vulnerabilities


        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                'TenableSC.Scan(val.ID==obj.ID)': createContext(mapped_results, removeNull=True)
            }
        }

        return entry

    def get_scan_report(scan_results_id):
        path = 'scanResult/' + scan_results_id

        params = {
            'fields': 'name,description,status,scannedIPs,progress,startTime,finishTime,completedChecks,owner,repository'
        }

        return send_request(path, params=params)


    def get_vulnearbilites(scan_results_id):
        query = get_query(scan_results_id, 'vulnipdetail')

        if not query or 'response' not in query:
            return 'Could not get vulnerabilites query'

        analysis = get_analysis(query['response']['id'], scan_results_id)

        if not analysis or 'response' not in analysis:
            return 'Could not get vulnerabilites analysis'

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return 'No vulnerabilities found'


        mapped_vulns = []

        for vuln in results:
            mapped_vuln =  {
                'ID': vuln['pluginID'],
                'Name': vuln['name'],
                'Description': vuln['pluginDescription'],
                'Family': vuln['family'].get('name'),
                'Severity': vuln['severity'].get('name'),
                'Total': vuln['total']
            }

            mapped_vulns.append(mapped_vuln)

        sv = [
          'Critical',
          'High',
          'Medium',
          'Low',
          'Info'
        ]

        mapped_vulns.sort(key=lambda r: r['Severity'], cmp=lambda a,b: sv.index(a) - sv.index(b))

        return mapped_vulns


    def get_query(scan_id, tool, query_filters=None):
        path = 'query'

        body = {
            'name': 'scan ' + scan_id + ' query',
            'type': 'vuln',
            'tool': tool,
            'scanID': scan_id
        }

        if query_filters:
            body['filters'] = query_filters

        return send_request(path, method='post', body=body)

    def get_analysis(query_id, scan_results_id):
        path = 'analysis'

        body = {
            'type': 'vuln',
            'query': {
                'id': query_id
            },
            'sourceType': 'individual',
            'scanID': scan_results_id,
            'view': 'all'
        }

        return send_request(path, method='post', body=body)

    def get_vulnerability_command():
        vuln_id = demisto.args()['vulnerabilityID']
        scan_results_id = demisto.args()['scanResultsID']

        vuln_filter = [{
            'filterName': 'pluginID',
            'operator': '=',
            'value': vuln_id
        }]

        query = get_query(scan_results_id, 'vulnipdetail', vuln_filter)

        if not query or 'response' not in query:
            return 'Could not get vulnerability query'

        analysis = get_analysis(query['response']['id'], scan_results_id)

        if not analysis or 'response' not in analysis:
            return 'Could not get vulnerabilites analysis'

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return 'Vulnerability not found in the scan'

        vuln_response = get_vulnerability(vuln_id)

        if not vuln_response or 'response' not in vuln_response:
            return 'Vulnerability not found'

        vuln = vuln_response['response']

        vuln['severity'] = results[0]['severity']
        vuln['hosts'] = results[0]['hosts']

        vuln_hosts = vuln['hosts']
        severity = vuln['severity'].get('name')
        hosts = [{'IP': h['ip'], 'MAC': h['macAddress']} for h in demisto.dt(vuln_hosts, 'iplist')]


        cves = None
        cves_output = []
        if vuln.get('xrefs'):
            # Extract CVE
            cve_filter = list(filter(lambda x: x.strip().startswith('CVE'), vuln['xrefs'].split(',')))
            if cve_filter and len(cve_filter) > 0:
                cves = list(map(lambda c: c.replace('CVE:', '').strip(), cve_arr))
                cves_output + map(lambda c: {
                'ID': cve
                }, cves)

        mapped_vuln =  {
            'ID': vuln['id'],
            'Name': vuln['name'],
            'Description': vuln['description'],
            'Type': vuln['type'],
            'Severity': severity,
            'Synopsis': vuln['synopsis'],
            'Solution': vuln['solution'],

        }

        vuln_info = {
            'Published': datetime.datetime.utcfromtimestamp(int(vuln['vulnPubDate'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'CPE': vuln['cpe'],
            'CVE': cves
        }

        exploit_info = {
            'ExploitAvailable': vuln['exploitAvailable'],
            'ExploitEase': vuln['exploitEase']
        }

        risk_info = {
            'RiskFactor': vuln['riskFactor'],
            'CVSSBaseScore': vuln['baseScore'],
            'CVSSTemporalScore': vuln['temporalScore'],
            'CVSSVector': vuln['cvssVector']
        }

        plugin_details = {
            'Family': vuln['family'].get('name'),
            'Published': datetime.datetime.utcfromtimestamp(int(vuln['pluginPubDate'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'Modified': datetime.datetime.utcfromtimestamp(int(vuln['pluginModDate'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'CheckType': vuln['checkType']
        }

        hr = '## Vulnerability: {} ({})\n'.format(mapped_vuln['Name'], mapped_vuln['ID'])
        hr += '### Synopsis\n{}\n### Description\n{}\n### Solution\n{}\n'.format(mapped_vuln['Synopsis'], mapped_vuln['Description'], mapped_vuln['Solution'])
        hr += tableToMarkdown('Hosts', hosts, removeNull=True)
        hr += tableToMarkdown('Risk Information', risk_info, removeNull=True)
        hr += tableToMarkdown('Exploit Information', exploit_info, removeNull=True)
        hr += tableToMarkdown('Plugin Details', plugin_details, removeNull=True)
        hr += tableToMarkdown('Vulnerability Information', vuln_info, removeNull=True)

        mapped_vuln.update(vuln_info)
        mapped_vuln.update(exploit_info)
        mapped_vuln.update(risk_info)
        mapped_vuln['pluginDetails'] = plugin_details

        scan_result = {
            'ID': scan_results_id,
            'Vulnerability': mapped_vuln,
        }

        context = createContext(scan_result, removeNull=True)
        if len(cves_output) > 0:
            context['CVE(val.ID==obj.ID)'] = cves_output

        entry = {
            'Type': entryTypes['note'],
            'Contents': vuln_response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'TenableSC.Scan(val.ID==obj.ID)': context
            }
        }

    def get_vulnerability(vuln_id):
        path = 'plugin/' + vuln_id

        params = {
            'fields': 'name,description,family,type,cpe,riskFactor,solution,synopsis,exploitEase,exploitAvailable,cvssVector,baseScore,pluginPubDate,pluginModDate,vulnPubDate,temporalScore,xrefs,checkType'
        }

        return send_request(path, params=params)


    def stop_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'stop')

        if not res:
            return 'Could not stop the scan'

        return 'Scan sucessfully stopped'

    def pause_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'pause')

        if not res:
            return 'Could not pause the scan'

        return 'Scan sucessfully paused'

    def resume_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'resume')

        if not res:
            return 'Could not resume the scan'

        return 'Scan sucessfully resumed'

    def change_scan_status(scan_results_id, status):
        path = 'scanResult/' + scan_results_id + '/' + status

        return send_request(path, method='post')

    def delete_scan_command():
        scan_id = demisto.args('scanID')

        res = delete_scan(scan_id)

        if not res:
            return 'Could not delete the scan'

        return 'Scan sucessfully deleted'

    def delete_scan(scan_id):
        path = 'scan/' + scan_id

        return send_request(path, method='delete')

    def logout():
        send_request(path='token', method='delete')

    SESSION = Session()
    token = login(USERNAME, PASSWORD)
    SESSION.headers.update({'X-SecurityCenter': str(token)})

    if demisto.command() == 'test-module':
        demisto.results('ok')
    elif demisto.command() == 'tenable-sc-list-scans':
        demisto.results(list_scans_command())
    elif demisto.command() == 'tenable-sc-list-policies':
        demisto.results(list_policies_command())
    elif demisto.command() == 'tenable-sc-list-repositories':
        demisto.results(list_repositories_command())
    elif demisto.command() == 'tenable-sc-list-reports':
        demisto.results(list_reports_command())
    elif demisto.command() == 'tenable-sc-list-assets':
        demisto.results(list_assets_command())
    elif demisto.command() == 'tenable-sc-create-scan':
        demisto.results(create_scan_command())
    elif demisto.command() == 'tenable-sc-launch-scan':
        demisto.results(launch_scan_command())
    elif demisto.command() == 'tenable-sc-get-scan-status':
        demisto.results(get_scan_status_command())
    elif demisto.command() == 'tenable-sc-get-scan-report':
        demisto.results(get_scan_report_command())
    elif demisto.command() == 'tenable-sc-get-vulnerability':
        demisto.results(get_vulnerability_command())
    elif demisto.command() == 'tenable-sc-stop-scan':
        demisto.results(stop_scan_command())
    elif demisto.command() == 'tenable-sc-pause-scan':
        demisto.results(pause_scan_command())
    elif demisto.command() == 'tenable-sc-resume-scan':
        demisto.results(resume_scan_command())

    logout()
  type: python
  commands:
  - name: tenable-sc-list-scans
    arguments:
    - name: manageable
      description: Whether to return only manageable scans. Returns both usable and
        manageable scans by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.ID
      description: Scan ID
      type: number
    - contextPath: TenableSC.Scan.Description
      description: Scan description
    description: Get a list of Tenable.sc existing scans
  - name: tenable-sc-launch-scan
    arguments:
    - name: scanID
      required: true
      description: Scan ID
    - name: diagnosticTarget
      description: Valid IP/Hostname of a specific target to scan. Must be provided
        with diagnosticPassword.
    - name: diagnosticPassword
      description: Non empty string password
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.ResultID
      description: Scan Result ID
      type: string
    - contextPath: TenableSC.Scan.OwnerID
      description: Scan owner ID
      type: string
    - contextPath: TenableSC.JobID
      description: Job ID
      type: string
    - contextPath: TenableSC.Scan.Status
      description: Scan status
      type: string
    description: Launch an existing scan from Tenable.sc
  - name: tenable-sc-get-vulnerability
    arguments:
    - name: vulnerabilityID
      required: true
      description: Vulnerability ID
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: 'Get details about a given vulnerability from a given Tenable.sc
      scan '
  - name: tenable-sc-get-scan-status
    arguments:
    - name: scanResultsID
      required: true
      description: Scan Results ID
      isArray: true
    outputs:
    - contextPath: TenableSC.Scan.Status
      description: Scan status
      type: string
    - contextPath: TenableSC.Scan.Name
      description: Scan Name
      type: string
    - contextPath: TenableSC.Scan.Description
      description: Scan description
    description: Get the status of a specific scan in Tenable.sc
  - name: tenable-sc-get-scan-report
    arguments:
    - name: scanResultsID
      required: true
      description: Scan Results ID
    - name: vulnerabilitySeverity
      description: Comma separated list of severity values of vulnerabilities to retrieve
      isArray: true
      defaultValue: Critical,High,Medium,Low,Info
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.Status
      description: Scan status
      type: string
    - contextPath: TenableSC.Scan.ScannedIPs
      description: Number of scanned IPs
      type: number
    - contextPath: TenableSC.Scan.StartTime
      description: Scan start time
      type: date
    - contextPath: TenableSC.Scan.EndTime
      description: Scan end time
      type: date
    - contextPath: TenableSC.Scan.Checks
      description: Scan completed checks
      type: number
    - contextPath: TenableSC.Scan.ScannerName
      description: Scanner engine name
      type: string
    - contextPath: TenableSC.Scan.OwnerName
      description: Scan owner username
      type: string
    - contextPath: TenableSC.Scan.RepositoryName
      description: Scan repository name
      type: string
    - contextPath: TenableSC.Scan.Description
      description: Scan description
    description: Get a report with a Tenable.sc scan results
  - name: tenable-sc-download-report
    arguments:
    - name: scanID
      required: true
      description: Scan ID
    description: Download a report with a given Tenable.sc scan results
  - name: tenable-sc-stop-scan
    arguments:
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: Stop a scan in Tenable.sc
  - name: tenable-sc-pause-scan
    arguments:
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: Pause a scan in Tenable.sc
  - name: tenable-sc-resume-scan
    arguments:
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: Resume a scan in Tenable.sc
  - name: tenable-sc-list-credentials
    arguments:
    - name: manageable
      description: Whether to return only manageable scan credentials. Returns both
        usable and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Credential.Name
      description: Credential name
      type: string
    - contextPath: TenableSC.Credential.ID
      description: Credential ID
      type: number
    - contextPath: TenableSC.Credential.Description
      description: Credential description
      type: string
    - contextPath: TenableSC.Credential.Type
      description: Credential type
      type: string
    description: Get a list of Tenable.sc credentials
  - name: tenable-sc-list-policies
    arguments:
    - name: manageable
      description: Whether to return only manageable scan policies. Returns both usable
        and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.ScanPolicy.Name
      description: Scan policy name
      type: string
    - contextPath: TenableSC.ScanPolicy.ID
      description: Scan policy ID
      type: number
    - contextPath: TenableSC.ScanPolicy.Description
      description: Scan policy description
      type: string
    description: Get a list of Tenable.sc scan policies
  - name: tenable-sc-list-reports
    arguments:
    - name: manageable
      description: Whether to return only manageable reports. Returns both usable
        and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Report.Name
      description: Scan report name
      type: string
    - contextPath: TenableSC.Report.ID
      description: Scan report ID
      type: number
    - contextPath: TenableSC.Report.Description
      description: Scan report description
      type: string
    description: Get a list of Tenable.sc report definitions
  - name: tenable-sc-list-repositories
    arguments: []
    outputs:
    - contextPath: TenableSC.ScanRepository.Name
      description: Scan Repository name
      type: string
    - contextPath: TenableSC.ScanRepository.ID
      description: Scan Repository ID
      type: number
    - contextPath: TenableSC.ScanRepository.Description
      description: Scan Repository
      type: string
    description: Get a list of Tenable.sc scan repositories
  - name: tenable-sc-list-zones
    arguments: []
    outputs:
    - contextPath: TenableSC.ScanZone.Name
      description: Scan Zone name
      type: string
    - contextPath: TenableSC.ScanZone.ID
      description: Scan Zone ID
      type: number
    - contextPath: TenableSC.ScanZone.Description
      description: Scan Zone description
      type: string
    - contextPath: TenableSC.ScanZone.IPList
      description: Scan Zone IP list
      type: unknown
    - contextPath: TenableSC.ScanZone.ActiveScanners
      description: Scan Zone active scanners
      type: number
    description: Get a list of Tenable.sc scan zones
  - name: tenable-sc-create-scan
    arguments:
    - name: name
      required: true
      description: Scan name
    - name: policyID
      description: Policy ID in case of policy type scan
    - name: description
      description: Scan description
    - name: repositoryID
      required: true
      description: Scan Repository ID
    - name: zoneID
      description: Scan zone ID (default is all zones)
    - name: schedule
      auto: PREDEFINED
      predefined:
      - dependent
      - ical
      - never
      - rollover
      - template
      description: Schedule time for the scan, default is template
    - name: assetIDs
      auto: PREDEFINED
      predefined:
      - All
      - AllManageable
      description: Comma separated asset IDs to scan
      isArray: true
    - name: scanVirtualHosts
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to includes virtual hosts, default false
    - name: ipList
      description: IP list to scan
    - name: pluginID
      description: Plugin ID in case of plugin type scan, or for when the policy is
        of no context
    - name: reportIDs
      description: Comma separated list of report IDs to create post-scan
      isArray: true
    - name: credentials
      description: Comma separated credentials IDs to use
      isArray: true
    - name: timeoutAction
      auto: PREDEFINED
      predefined:
      - discard
      - import
      - rollover
      description: Scan timeout action, default is import
    - name: maxScanTime
      description: Maximum scan run time in hours, default is 1
    - name: dhcpTracking
      description: Track hosts
    - name: rolloverType
      auto: PREDEFINED
      predefined:
      - nextDay
      - template
      description: Scan rollover type, default is 'template'
    - name: startScan
      description: Whether to launch the scan right away
    - name: repeatRule
      description: Schedule repeat rule for ical schedule type in repeat rule format
    - name: dependentID
      description: Dependent scan ID in case of a dependent schedule
    outputs:
    - contextPath: TenableSC.Scan.ID
      description: Scan ID
      type: string
    - contextPath: TenableSC.Scan.CreatorID
      description: Scan's creator ID
      type: string
    - contextPath: TenableSC.Scan.Name
      description: Scan Name
      type: string
    - contextPath: TenableSC.Scan.Type
      description: Scan type
      type: string
    - contextPath: TenableSC.Scan.CreatedTime
      description: Scan creation time
      type: date
    - contextPath: TenableSC.Scan.OwnerName
      description: Scan owner Username
      type: string
    - contextPath: TenableSC.Scan.Reports
      description: Scan report IDs
    description: Create a scan on Tenable.sc
  - name: tenable-sc-delete-scan
    arguments:
    - name: scanID
      required: true
      description: Scan ID
    description: Delete a scan in Tenable.sc
  - name: tenable-sc-list-assets
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable scan credentials. Returns both
        usable and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: string
    - contextPath: TenableSC.Asset.Name
      description: Asset Name
      type: string
    - contextPath: TenableSC.Asset.Description
      description: Asset description
      type: string
    - contextPath: TenableSC.Asset.IPCount
      description: Asset IP count
      type: number
    - contextPath: TenableSC.Asset.Type
      description: Asset type
      type: string
    description: Get a list of Tenable.sc Assets
  - name: tenable-sc-create-asset
    arguments:
    - name: name
      required: true
      description: Asset Name
    - name: description
      description: Asset description
    - name: ownerID
      description: default is the Session User ID
    - name: tags
      description: Tag the Asset
    - name: data
      description: An ip, a list or a range of ip addresses
    outputs:
    - contextPath: TenableSC.Asset.Name
      description: Asset Name
      type: string
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: string
    - contextPath: TenableSC.Asset.owner,ID
      description: Asset's owner ID
      type: string
    - contextPath: TenableSC.Asset.Tag
      description: Asset's related tags
      type: string
    description: Create an Asset in Tenable.sc. The Asset can be a single ip address,
      a list or a range of ip addresses.
  runonce: false
releaseNotes: "-"