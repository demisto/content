commonfields:
  id: QRadar
  version: -1
name: QRadar
display: IBM QRadar
category: Analytics & SIEM
image: data:image/png;base64,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
description: Get incidents and search QRadar
detaileddescription: Get incidents and search QRadar
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: false
- display: Authentication token
  name: token
  defaultvalue: ""
  type: 4
  required: false
- display: Query to fetch offenses
  name: query
  defaultvalue: ""
  type: 0
  required: false
- display: Number of offenses to pull per API call
  name: offensesPerCall
  defaultvalue: "50"
  type: 0
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |-
    import sys, os, requests, traceback, datetime, json
    from requests.exceptions import HTTPError

    ''' GLOBAL VARS '''
    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    USERNAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    TOKEN = demisto.params().get('token')
    USE_SSL = not demisto.params().get('insecure', False)
    CUSTOM_HEADERS = demisto.args().get('headers')
    AUTH_HEADERS = {'SEC': str(TOKEN), 'Content-Type':  'application/json'}
    OFFENSES_PER_CALL = int(demisto.params().get('offensesPerCall', 50))

    OFFENSES_PER_CALL = 50 if OFFENSES_PER_CALL > 50 else OFFENSES_PER_CALL

    if not TOKEN and not PASSWORD:
        raise Exception('Either credentials or auth token should be provided.')

    if CUSTOM_HEADERS:
        CUSTOM_HEADERS = CUSTOM_HEADERS.split(',')

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # Header names transformation maps
    # Format: {'OldName': 'NewName'}

    OFFENSES_NAMES_MAP = {'follow_up': 'Followup', 'id': 'ID', 'description': 'Description', 'source_address': 'SourceAddress', 'destination_address': 'DestinatioAddress', 'start_time': 'StartTime', 'event_count': 'EventCount', 'magnitude': 'Magnitude', 'last_updated_time': 'LastUpdatedTime', 'offense_type': 'OffenseType'}
    SINGLE_OFFENSE_NAMES_MAP = {'credibility': 'Credibility', 'relevance': 'Relevance', 'severity': 'Severity', 'assigned_to': 'AssignedTo', 'destination_networks': 'DestinationHostname', 'status': 'Status', 'closing_user': 'ClosingUser', 'closing_reason_id': 'ClosingReason', 'close_time': 'CloseTime', 'categories': 'Categories', 'follow_up': 'Followup', 'id': 'ID', 'description': 'Description', 'source_address': 'SourceAddress', 'destination_address': 'DestinatioAddress', 'start_time': 'StartTime', 'event_count': 'EventCount', 'flow_count': 'FlowCount', 'offense_source': 'OffenseSource', 'magnitude': 'Magnitude', 'last_updated_time': 'LastUpdatedTime', 'offense_type': 'OffenseType', 'protected': 'Protected'}
    SEARCH_ID_NAMES_MAP = {'search_id': 'ID'}
    ASSET_PROPERTIES_NAMES_MAP = {'Unified Name': 'Name', 'CVSS Collateral Damage Potential': 'AggregatedCVSSScore', 'Weight': 'Weight'}
    ASSET_PROPERTIES_ENDPOINT_NAMES_MAP = {'Primary OS ID': 'OS'}
    FULL_ASSET_PROPERTIES_NAMES_MAP = {'Compliance Notes': 'ComplianceNotes', 'Compliance Plan': 'CompliancePlan', 'CVSS Collateral Damage Potential': 'CollateralDamagePotential', 'Location': 'Location', 'Switch ID': 'SwitchID', 'Switch Port ID': 'SwitchPort', 'Group Name': 'GroupName', 'Vulnerabilities': 'Vulnerabilities'}
    NOTE_NAMES_MAP = {'id': 'ID', 'note_text': 'Text', 'create_time': 'CreateTime', 'username': 'CreatedBy'}
    REFERENCE_NAMES_MAP = {'number_of_elements': 'NumberOfElements', 'name': 'Name', 'creation_time': 'CreationTime', 'element_type': 'ElementType', 'number_of_elements': 'NumberOfElements', 'time_to_live': 'TimeToLive', 'timeout_type': 'TimeoutType'}

    ''' Utility methods '''

    def filter_dict_null(d):
        if isinstance(d, dict):
            return dict((k, filter_dict_null(v)) for k, v in d.items() if filter_dict_null(v) is not None)
        elif isinstance(d, list):
            if len(d) > 0:
                return list(map(filter_dict_null, d))
            return None
        return d

    def filter_dict_nonintersection_key_to_value(d1, d2):
        if isinstance(d1, list):
            return map(lambda x: filter_dict_nonintersection_key_to_value(x, d2), d1)
        elif isinstance(d1, dict) and isinstance(d2, dict):
            d2values = d2.values()
            return dict((k,v) for k,v in d1.items() if k in d2values)
        return d1

    def dict_values_to_comma_seperated_string(dic):
        return ','.join(str(v) for v in dic.itervalues())

    def get_entry_for_object(title, obj, headers=None, contextKey=None):
        if len(obj) == 0:
            return "There is no output result"
        obj = filter_dict_null(obj)
        if headers and isinstance(obj, dict):
            headers = list(set(headers).intersection(set(obj.keys())))
        ec = { contextKey: obj } if contextKey else obj
        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, obj, headers),
            'EntryContext': ec
        }

    def get_entry_for_assets(title, obj, human_readable_obj, headers=None):
        if len(obj) == 0:
            return "There is no output result"
        obj = filter_dict_null(obj)
        human_readable_obj = filter_dict_null(human_readable_obj)
        if headers:
            headers = list(filter(lambda x: x in headers, list_entry) for list_entry in human_readable_obj)
        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, human_readable_obj, headers),
            'EntryContext': obj
        }

    # change the keys of a dictionary according to a conversion map
    # trans_map - { 'OldKey': 'NewKey', ...}
    # camelize - change all keys from snake_case to CamelCase
    def replace_keys(src, trans_map):
        def replace(key, trans_map):
            if key in trans_map:
                return trans_map[key]
            return key

        if isinstance(src, list):
            return map(lambda x: replace_keys(x, trans_map), src)
        if trans_map:
            src = {replace(k, trans_map): v for k,v in src.iteritems()}
        return src

    def epoch_to_ISO(ms_passed_since_epoch):
        return datetime.datetime.utcfromtimestamp(ms_passed_since_epoch/1000.0).strftime(("%Y-%m-%dT%H:%M:%S.%fZ"))

    def find_last_page_pos():
        # Make sure it wasn't a fluke we have exactly OFFENSES_PER_CALL results
        if len(send_get_offenses_request(_range='{0}-{0}'.format(str(OFFENSES_PER_CALL)), _filter=fetchQuery)) == 0:
            return OFFENSES_PER_CALL - 1
        # Search up until we don't have any more results
        pos = OFFENSES_PER_CALL * 2
        while len(send_get_offenses_request(_range='{0}-{0}'.format(str(pos)), _filter=fetchQuery)) == 1:
            pos = pos * 2
        # Binary search the gap from the las step
        high = pos
        low = pos / 2
        while high > low+1:
            pos = (high + low) / 2
            if len(send_get_offenses_request(_range='{0}-{0}'.format(str(pos)), _filter=fetchQuery)) == 1:
                # we still have results, raise the bar
                low = pos
            else:
                # we're too high, lower the bar
                high = pos
        # low holds the last pos of the list
        return low

    def create_incident_from_offense(offense):
        keys = offense.keys()
        occured = epoch_to_ISO(offense['start_time'])
        labels = []
        for i in range(len(keys)):
            labels.append({'type': keys[i], 'value': str(offense[keys[i]])})
        return {
            'name': '{0} {1}'.format(offense['id'], offense['description']),
            'labels': labels,
            'rawJSON': json.dumps(offense),
            'occurred': occured
        }

    def enrich_offense_result(response, full_enrichment=False):
        enrich_offense_res_with_source_and_destination_address(response)
        # Convert epoch to iso and closing_reason_id to closing reason name
        if isinstance(response, list):
            for offense in response:
                enrich_offense_start_and_update_times(offense)
                if full_enrichment:
                    enrich_offense_closing_reason_id(offense)
                if full_enrichment and 'closing_reason_id' in offense:
                    offense['closing_reason_id'] = convert_closing_reason_id_to_name(offense['closing_reason_id'])
        else:
            enrich_offense_start_and_update_times(response)
            if full_enrichment:
                enrich_offense_closing_reason_id(response)

        return response

    def enrich_offense_res_with_source_and_destination_address(response):
        src_adrs, dst_adrs = extract_source_and_destination_addresses_ids(response)
        enrich_source_addresses_dict(src_adrs)
        enrich_destination_addresses_dict(dst_adrs)
        if isinstance(response, list):
            for offense in response:
               enrich_single_offense_res_with_source_and_destination_address(offense, src_adrs, dst_adrs)
        else:
            enrich_single_offense_res_with_source_and_destination_address(response, src_adrs, dst_adrs)
        return response

    def extract_source_and_destination_addresses_ids(response):
        src_ids = {}
        dst_ids = {}
        if isinstance(response, list):
            for offense in response:
                populate_src_and_dst_dicts_with_single_offense(offense, src_ids, dst_ids)
        else:
            populate_src_and_dst_dicts_with_single_offense(response, src_ids, dst_ids)

        return src_ids, dst_ids

    def populate_src_and_dst_dicts_with_single_offense(offense, src_ids, dst_ids):
        if isinstance(offense['source_address_ids'], list):
            for source_id in offense['source_address_ids']:
                src_ids[source_id] = source_id
        if isinstance(offense['local_destination_address_ids'], list):
            for destination_id in offense['local_destination_address_ids']:
                dst_ids[destination_id] = destination_id
        return None

    def enrich_source_addresses_dict(src_adrs):
        src_ids_str = dict_values_to_comma_seperated_string(src_adrs)
        source_url = '{0}/api/siem/source_addresses?filter=id in ({1})'.format(SERVER, src_ids_str)
        src_res = send_request('GET', source_url, AUTH_HEADERS)
        for src_adr in src_res:
            src_adrs[src_adr['id']] = src_adr['source_ip']
        return src_adrs

    def enrich_destination_addresses_dict(dst_adrs):
        dst_ids_str = dict_values_to_comma_seperated_string(dst_adrs)
        destination_url = '{0}/api/siem/local_destination_addresses?filter=id in ({1})'.format(SERVER, dst_ids_str)
        headers = {'Content-Type': 'application/json', "SEC": str(TOKEN)}
        dst_res = send_request('GET', destination_url, AUTH_HEADERS)
        for dst_adr in dst_res:
            dst_adrs[dst_adr['id']] = dst_adr['local_destination_ip']
        return dst_adrs

    def enrich_single_offense_res_with_source_and_destination_address(offense, src_adrs, dst_adrs):
        if isinstance(offense['source_address_ids'], list):
            for i in range(len(offense['source_address_ids'])):
                offense['source_address_ids'][i] = src_adrs[offense['source_address_ids'][i]]
        if isinstance(offense['local_destination_address_ids'], list):
            for i in range(len(offense['local_destination_address_ids'])):
                offense['local_destination_address_ids'][i] = dst_adrs[offense['local_destination_address_ids'][i]]

        return None

    def enrich_offense_closing_reason_id(offense):
        if 'closing_reason_id' in offense:
            offense['closing_reason_id'] = convert_closing_reason_id_to_name(offense['closing_reason_id'])

    def enrich_offense_start_and_update_times(offense):
        if 'start_time' in offense:
            offense['start_time'] = epoch_to_ISO(offense['start_time'])
        if 'last_updated_time' in offense:
            offense['last_updated_time'] = epoch_to_ISO(offense['last_updated_time'])

        return None

    def send_request(method, url, headers=AUTH_HEADERS, params=None):
        try:
            res = requests.request(method, url, headers=headers, params=params, verify=USE_SSL)
            res.raise_for_status()
        except HTTPError, e:
            return_error(res.json())
        return res.json()

    def create_empty_endpoint_dict(full_values):
        endpoint_dict = {}
        endpoint_dict['IPAddress'] = []
        endpoint_dict['OS'] = []
        if full_values:
            endpoint_dict['MACAddress'] = []
            endpoint_dict['Domain'] = []
        return endpoint_dict

    def create_assets_result(assets, full_values=False):
        trans_assets = {}
        human_readable_trans_assets = {}
        endpoint_dict = create_empty_endpoint_dict(full_values)
        for asset in assets:
            asset_key = 'QRadar.Asset(val.ID === {0})'.format(asset['id'])
            human_readable_key = 'Asset(ID:{0})'.format(asset['id'])
            populated_asset = create_asset_result_and_enrich_endpoint_dict(asset, endpoint_dict, full_values)
            trans_assets[asset_key] = populated_asset
            human_readable_trans_assets[human_readable_key] = populated_asset
        # Adding endpoints context items
        trans_assets['Endpoint'] = endpoint_dict
        human_readable_trans_assets['Endpoint'] = endpoint_dict
        return trans_assets, human_readable_trans_assets

    def create_asset_result_and_enrich_endpoint_dict(asset, endpoint_dict, full_values):
        asset_dict = {}
        asset_dict['ID'] = asset['id']
        for interface in asset['interfaces']:
            if full_values:
                endpoint_dict['MACAddress'].append(interface['mac_address'])
            for ip_address in interface['ip_addresses']:
                endpoint_dict['IPAddress'].append(ip_address['value'])
        if full_values:
        # Trying to get Domain name via search in QRadar
            try:
                domain_name = get_domain_name(asset['domain_id'])
                trans_assets['Domain'].append(domain_name)
            except:
                pass
        # Adding values found in properties of the asset
        enrich_dict_using_asset_properties(asset, asset_dict, endpoint_dict, full_values)
        return asset_dict

    def enrich_dict_using_asset_properties(asset, asset_dict, endpoint_dict, full_values):
        for prop in asset['properties']:
            if prop['name'] in ASSET_PROPERTIES_NAMES_MAP:
                asset_dict[ASSET_PROPERTIES_NAMES_MAP[prop['name']]] = {'Value': prop['value'], 'LastUser': prop['last_reported_by']}
            elif prop['name'] in ASSET_PROPERTIES_ENDPOINT_NAMES_MAP:
                endpoint_dict[ASSET_PROPERTIES_ENDPOINT_NAMES_MAP[prop['name']]] = prop['value']
            elif full_values:
                if prop['name'] in FULL_ASSET_PROPERTIES_NAMES_MAP:
                    asset_dict[FULL_ASSET_PROPERTIES_NAMES_MAP[prop['name']]] = {'Value': prop['value'], 'LastUser': prop['last_reported_by']}
        return None

    def get_domain_name(domain_id):
        query_param = {'query_expression': "SELECT DOMAINNAME({0}) AS 'Domain name' FROM events GROUP BY 'Domain name'".format(domain_id)}
        search_id = send_search_request(query_param)['search_id']
        return send_get_search_results_request(search_id)['events'][0]['Domain name']

    def convert_closing_reason_name_to_id(closing_name):
        res = send_get_closing_reasons(include_deleted=True, include_reserved=True)
        for closing_reason in res:
            if closing_reason['text'] == closing_name:
                return closing_reason['id']
        raise ValueError("Error: Given closing reason name doesn't exist. Please use use 'qradar-get-closing-reasons' command to get a valid closing reason.")

    def convert_closing_reason_id_to_name(closing_id):
        res = send_get_closing_reasons(include_deleted=True, include_reserved=True)
        for closing_reason in res:
            if closing_reason['id'] == closing_id:
                return closing_reason['text']
        raise ValueError("Error: Given closing reason id doesn't exist. Please use use 'qradar-get-closing-reasons' command to get a valid closing reason.")


    ''' Request/Response methods '''

    def send_get_offenses_request(_range, _filter='', _fields=''):
        full_url = '{0}/api/siem/offenses'.format(SERVER)
        params = {'filter': _filter} if _filter else {}
        headers = dict(AUTH_HEADERS)
        if _fields:
            params.fileds = _fields
        if _range:
            headers['Range'] = 'items={0}'.format(_range)
        return send_request('GET', full_url, headers, params)

    def send_get_offense_by_id_request(offense_id, _filter='', _fields=''):
        full_url = '{0}/api/siem/offenses/{1}'.format(SERVER, offense_id)
        demisto.info(full_url)
        params = {"filter": _filter} if _filter else {}
        headers = dict(AUTH_HEADERS)
        if _fields:
            params.fileds = _fields
        return send_request('GET', full_url, headers, params)

    def send_update_offense_request(offense_id):
        url = '{0}/api/siem/offenses/{1}'.format(SERVER, offense_id)
        return send_request('POST', url, params=demisto.args())

    def send_search_request(args):
        url = '{0}/api/ariel/searches'.format(SERVER)
        return send_request('POST', url, AUTH_HEADERS, params=args)

    def send_get_search_request(search_id):
        url = '{0}/api/ariel/searches/{1}'.format(SERVER, str(search_id))
        return send_request('GET', url, AUTH_HEADERS)

    def send_get_search_results_request(search_id):
        url = '{0}/api/ariel/searches/{1}/results'.format(SERVER, str(search_id))
        return send_request('GET', url, AUTH_HEADERS)

    def send_get_assets(_range='', _filter='', _fields=''):
        url = '{0}/api/asset_model/assets'.format(SERVER)
        params = {"filter": _filter} if _filter else {}
        headers = dict(AUTH_HEADERS)
        if _fields:
            params.fileds = _fields
        if _range:
            headers['Range'] = 'items={0}'.format(_range)
        return send_request('GET', url, headers, params)

    def send_get_closing_reasons(_range='', _filter='', _fields='', include_deleted=False, include_reserved=False):
        url = '{0}/api/siem/offense_closing_reasons'.format(SERVER)
        params = {}
        if _filter:
            params['filter'] = _filter
        if include_deleted:
            params['include_deleted'] = include_deleted
        if include_reserved:
            params['include_reserved'] = include_reserved
        headers = AUTH_HEADERS
        if _range:
            headers['Range'] = 'items={0}'.format(_range)
        return send_request('GET', url, headers, params)

    def send_get_note(offense_id, note_id, fields):
        url = '{0}/api/siem/offenses/{1}/notes/{2}'.format(SERVER, offense_id, note_id)
        params = {'fields': fields} if fields else {}
        return send_request('GET', url, AUTH_HEADERS, params=params)

    def send_create_notes(offense_id, note_text, fields):
        url = '{0}/api/siem/offenses/{1}/notes'.format(SERVER, offense_id)
        params = {'fields': fields} if fields else {}
        params['note_text'] = note_text
        return send_request('POST', url, AUTH_HEADERS, params=params)

    def send_reference_by_name_request(ref_name, _range='', _filter='', _fields=''):
        url = '{0}/api/reference_data/sets/{1}'.format(SERVER, ref_name)
        params = {'filter': _filter} if _filter else {}
        headers = dict(AUTH_HEADERS)
        if _fields:
            params.fileds = _fields
        if _range:
            headers['Range'] = 'items={0}'.format(_range)
        return send_request('GET', url, headers, params=params)

    ''' Command methods '''

    def test_module():
        if not send_get_offenses_request(_range='0-0'):
            return_error('Encoutered error while trying to fetch offenses from sever.')
        return 'ok'

    def fetch_incidents():
        query = demisto.args().get('query')
        lastRun = demisto.getLastRun()
        offenseId = lastRun['id'] if lastRun and 'id' in lastRun else 0
        fetchQuery = 'id>{0} {1}'.format(offenseId, 'AND ({0})'.format(query) if query else '')
            # qradar returns offenses sorted desc on id and there's no way to change sorting.
            # if we get `offernsesPerCall` offenses it means we (probably) have more than that so we
            # start looking for the end of the list by doubling the page position until we're empty.
            # then start binary search back until you find the end of the list and finally return
            # `offensesPerCall` from the end.
        res = send_get_offenses_request(_range='0-{0}'.format(str(OFFENSES_PER_CALL)), _filter=fetchQuery)
        if len(res) >= OFFENSES_PER_CALL:
            lastOffensePos = find_last_page_pos(fetchQuery)
            res = send_get_offenses_request(_range='{0}-{1}'.format(str(lastOffensePos - OFFENSES_PER_CALL + 1), str(lastOffensePos)))
        incidents = []
        for offense in res:
            offenseId = max(offenseId, offense['id'])
            incidents.append(create_incident_from_offense(offense))
        demisto.setLastRun({'id': offenseId})
        return json.dumps(incidents)

    def get_offenses_command():
        res = send_get_offenses_request(demisto.args().get('range'), demisto.args().get('filter'), demisto.args().get('fields'))
        enrich_offense_result(res)
        res = filter_dict_nonintersection_key_to_value(replace_keys(res, OFFENSES_NAMES_MAP), OFFENSES_NAMES_MAP)
        return get_entry_for_object('QRadar offenses', res, CUSTOM_HEADERS, 'QRadar.Offense(val.ID === obj.ID)')

    def get_offense_by_id_command():
        offense_id = demisto.args().get('offense_id')
        res = send_get_offense_by_id_request(offense_id, demisto.args().get('filter'), demisto.args().get('fields'))
        enrich_offense_result(res, full_enrichment=True)
        res = filter_dict_nonintersection_key_to_value(replace_keys(res, SINGLE_OFFENSE_NAMES_MAP), SINGLE_OFFENSE_NAMES_MAP)
        return get_entry_for_object('QRadar Offenses', res, CUSTOM_HEADERS, 'QRadar.Offense(val.ID === obj.ID)')

    def update_offense_command():
        args = demisto.args()
        if 'closing_reason_name' in args:
            args['closing_reason_id'] = convert_closing_reason_name_to_id(args.get('closing_reason_name'))
        elif 'CLOSED' == args.get('status'):
            raise ValueError('Invalid input - must provide closing reason name (may use "qradar-get-closing-reasons" command to get them) to close offense')
        offense_id = args.get('offense_id')
        res = send_update_offense_request(offense_id)
        enrich_offense_result(res, full_enrichment=True)
        res = filter_dict_nonintersection_key_to_value(replace_keys(res, SINGLE_OFFENSE_NAMES_MAP), SINGLE_OFFENSE_NAMES_MAP)
        return get_entry_for_object('QRadar Offense', res, CUSTOM_HEADERS, 'QRadar.Offense(val.ID === obj.ID)')

    def search_command():
        res = send_search_request(demisto.args())
        res = filter_dict_nonintersection_key_to_value(replace_keys(res, SEARCH_ID_NAMES_MAP), SEARCH_ID_NAMES_MAP)
        return get_entry_for_object('QRadar Search', res, CUSTOM_HEADERS, 'QRadar.Search(val.ID === obj.ID)')

    def get_search_command():
        res = send_get_search_request(demisto.args().get('search_id'))
        res = replace_keys(res, SEARCH_ID_NAMES_MAP)
        return get_entry_for_object('QRadar Search Info', res, CUSTOM_HEADERS, 'QRadar.Search(val.ID === obj.ID)')

    def get_search_results_command():
        search_id = demisto.args().get('search_id')
        res = send_get_search_results_request(search_id)
        return get_entry_for_object('QRadar Search Results', res, CUSTOM_HEADERS, 'QRadar.Search(val.ID === {0}).Result'.format(search_id))

    def get_assets_command():
        res = send_get_assets(demisto.args().get('range'), demisto.args().get('filter'), demisto.args().get('fields'))
        res, human_readable_res = create_assets_result(res)
        return get_entry_for_assets('QRadar Assets', res, human_readable_res, CUSTOM_HEADERS)

    def get_asset_by_id_command():
        _filter = "id=" + demisto.args().get('asset_id')
        res = send_get_assets(_filter=_filter)
        res, human_readable_res = create_assets_result(res, full_values=True)
        return get_entry_for_assets('QRadar Asset', res, human_readable_res, CUSTOM_HEADERS)

    def get_closing_reasons_command():
        args = demisto.args()
        res = send_get_closing_reasons(args.get('range'), args.get('filter'), args.get('fields'), args.get('include_deleted'), args.get('include_reserved'))
        return get_entry_for_object('Offense Closing Reasons', res, contextKey='QRadar.Offense.ClosingReasons')

    def get_note_command():
        res = send_get_note(demisto.args().get('offense_id'), demisto.args().get('note_id'), demisto.args().get('fields'))
        res = replace_keys(res, NOTE_NAMES_MAP)
        res['CreateTime'] = epoch_to_ISO(res['CreateTime'])
        return get_entry_for_object('QRadar Note', res, CUSTOM_HEADERS, 'QRadar.Note(val.ID === {0})'.format(demisto.args().get('note_id')))

    def create_note_command():
        res = send_create_notes(demisto.args().get('offense_id'), demisto.args().get('note_text'), demisto.args().get('fields'))
        res = replace_keys(res, NOTE_NAMES_MAP)
        res['CreateTime'] = epoch_to_ISO(res['CreateTime'])
        return get_entry_for_object('QRadar Note', res, CUSTOM_HEADERS, 'QRadar.Note')

    def get_reference_by_name_command():
        res = send_reference_by_name_request(demisto.args().get('ref_name'))
        res = replace_keys(res, REFERENCE_NAMES_MAP)
        if 'CreationTime' in res:
            res['CreationTime'] = epoch_to_ISO(res['CreationTime'])
        return get_entry_for_object('QRadar References', res, CUSTOM_HEADERS, 'QRadar.Reference')

    # Command selector
    if demisto.command() == 'test-module':
        demisto.results(test_module())
    elif demisto.command() == 'fetch-incidents':
        demisto.results(fetch_incidents())
    elif demisto.command() == 'qradar-offenses':
        demisto.results(get_offenses_command())
    elif demisto.command() == 'qradar-offense-by-id':
        demisto.results(get_offense_by_id_command())
    elif demisto.command() == 'qradar-update-offense':
        demisto.results(update_offense_command())
    elif demisto.command() == 'qradar-searches':
        demisto.results(search_command())
    elif demisto.command() == 'qradar-get-search':
        demisto.results(get_search_command())
    elif demisto.command() == 'qradar-get-search-results':
        demisto.results(get_search_results_command())
    elif demisto.command() == 'qradar-get-assets':
        demisto.results(get_assets_command())
    elif demisto.command() == 'qradar-get-asset-by-id':
        demisto.results(get_asset_by_id_command())
    elif demisto.command() == 'qradar-get-closing-reasons':
        demisto.results(get_closing_reasons_command())
    elif demisto.command() == 'qradar-get-note':
        demisto.results(get_note_command())
    elif demisto.command() == 'qradar-create-note':
        demisto.results(create_note_command())
    elif demisto.command() == 'qradar-get-reference-by-name':
        demisto.results(get_reference_by_name_command())
    # elif demisto.command() == 'qradar-get-events':
        #TODO: Talk with Michal about implementation
  type: python
  commands:
  - name: qradar-offenses
    arguments:
    - name: filter
      description: Query to filter offenses
    - name: fields
      description: 'Fields to filter in '
    - name: range
      description: Number of results in return
    - name: headers
      description: Table headers
    outputs:
    - contextPath: QRadar.Offense.Followup
      description: Offense followup.
    - contextPath: QRadar.Offense.ID
      description: The ID of the offense.
    - contextPath: QRadar.Offense.Description
      description: The description of the offense.
    - contextPath: QRadar.Offense.SourceAddress
      description: The source addresses that are associated with the offense.
    - contextPath: QRadar.Offense.DestinatioAddress
      description: The destination addresses that are associated with the offense.
    - contextPath: QRadar.Offense.StartTime
      description: The time (ISO) when the offense was started.
    - contextPath: QRadar.Offense.EventCount
      description: The number of events that are associated with the offense.
    - contextPath: QRadar.Offense.FlowCount
      description: The number of flows that are associated with the offense.
    - contextPath: QRadar.Offense.OffenseSource
      description: The source of the offense.
    - contextPath: QRadar.Offense.Magnitude
      description: The magnitude of the offense.
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: The time (ISO) when the offense was last updated.
    - contextPath: QRadar.Offense.OffenseType
      description: A number that represents the offense type
    description: Gets offenses from QRadar
  - name: qradar-offense-by-id
    arguments:
    - name: offense_id
      required: true
      default: true
      description: Offense ID
    - name: filter
      description: Query to filter offenses
    - name: fields
      description: 'Fields to filter in '
    - name: range
      description: Number of results in return
    - name: headers
      description: Table headers
    outputs:
    - contextPath: QRadar.Offense.Credibility
      description: The credibility of the offense
    - contextPath: QRadar.Offense.Relevance
      description: The relevance of the offense
    - contextPath: QRadar.Offense.Severity
      description: The severity of the offense
    - contextPath: QRadar.Offense.SourceAddress
      description: The source addresses that are associated with the offense.
    - contextPath: QRadar.Offense.DestinatioAddress
      description: The destination addresses that are associated with the offense.
    - contextPath: QRadar.Offense.AssignedTo
      description: The user the offense is assigned to.
    - contextPath: QRadar.Offense.StartTime
      description: The time (ISO) when the offense was started.
    - contextPath: QRadar.Offense.ID
      description: The ID of the offense.
    - contextPath: QRadar.Offense.DestinationHostname
      description: Destintion hostname
    - contextPath: QRadar.Offense.Description
      description: The description of the offense.
    - contextPath: QRadar.Offense.EventCount
      description: The number of events that are associated with the offense.
    - contextPath: QRadar.Offense.OffenseSource
      description: The source of the offense.
    - contextPath: QRadar.Offense.Status
      description: The status of the offense. One of "OPEN", "HIDDEN", or "CLOSED".
    - contextPath: QRadar.Offense.Magnitude
      description: The magnitude of the offense.
    - contextPath: QRadar.Offense.ClosingUser
      description: The user that closed the offense
    - contextPath: QRadar.Offense.ClosingReason
      description: ID_TO_BE_REVIEWED The offense closing reason.
    - contextPath: QRadar.Offense.CloseTime
      description: CONVERT_TO_ISO The time when the offense was closed.
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: CONVERT_TO_ISO The time (ISO) when the offense was last updated.
    - contextPath: QRadar.Offense.Categories
      description: Event categories that are associated with the offense.
    - contextPath: QRadar.Offense.FlowCount
      description: The number of flows that are associated with the offense.
    - contextPath: QRadar.Offense.FollowUp
      description: Offense followup.
    - contextPath: QRadar.Offense.OffenseType
      description: A number that represents the offense type
    description: Gets offense with matching offense ID from qradar
  - name: qradar-searches
    arguments:
    - name: query_expression
      required: true
      default: true
      description: The query expressions in AQL (for more information about Ariel
        Query Language please review "https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.3.0/com.ibm.qradar.doc/c_aql_intro.html")
    - name: headers
      description: Table headers
    outputs:
    - contextPath: QRadar.Search.ID
      description: Search ID
    description: Searches in QRadar
  - name: qradar-get-search
    arguments:
    - name: search_id
      required: true
      default: true
      description: The search id
    - name: headers
      description: Table headers
    description: Gets a specific search id
  - name: qradar-get-search-results
    arguments:
    - name: search_id
      required: true
      default: true
      description: The search id
    - name: range
      description: Number of results in return
    - name: headers
      description: Table headers
    description: Gets search results
  - name: qradar-update-offense
    arguments:
    - name: offense_id
      required: true
      default: true
      description: The ID of the offense to update
    - name: protected
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Set to true to protect the offense
    - name: follow_up
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Set to true to set the follow up flag on the offense
    - name: status
      auto: PREDEFINED
      predefined:
      - OPEN
      - HIDDEN
      - CLOSED
      description: The new status for the offense
    - name: closing_reason_name
      description: 'The name of a closing reason. You must provide a valid closing_reason_name
        when you close an offense. The default  closing_reasons are: (1) False-Positive,
        Tuned (2) Non-Issues (3) Policy Violation'
    - name: assigned_to
      description: A user to assign the offense to
    - name: headers
      description: Table headers
    - name: fields
      description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. Specify subfields
        in brackets and multiple fields in the same object are separated by commas
    outputs:
    - contextPath: QRadar.Offense.Followup
      description: Offense followup.
    - contextPath: QRadar.Offense.ID
      description: The ID of the offense.
    - contextPath: QRadar.Offense.Description
      description: The description of the offense.
    - contextPath: QRadar.Offense.SourceAddress
      description: The source addresses that are associated with the offense.
    - contextPath: QRadar.Offense.DestinatioAddress
      description: The destination addresses that are associated with the offense.
    - contextPath: QRadar.Offense.StartTime
      description: The time (ISO) when the offense was started.
    - contextPath: QRadar.Offense.EventCount
      description: The number of events that are associated with the offense.
    - contextPath: QRadar.Offense.FlowCount
      description: The number of flows that are associated with the offense.
    - contextPath: QRadar.Offense.OffenseSource
      description: The source of the offense.
    - contextPath: QRadar.Offense.Magnitude
      description: The magnitude of the offense.
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: The time (ISO) when the offense was last updated.
    - contextPath: QRadar.Offense.OffenseType
      description: A number that represents the offense type
    - contextPath: QRadar.Offense.Protected
      description: Is the offense protected
    description: Update an offense
  - name: qradar-get-assets
    arguments:
    - name: range
      description: Number of results in return
    - name: fields
      description: Fields to filter in
    - name: filter
      description: Query to filter offenses
    - name: headers
      description: Table headers
    outputs:
    - contextPath: QRadar.Assets.ID
      description: The ID of the asset
    - contextPath: Endpoint.IPAddress
      description: IP address of the asset
    - contextPath: QRadar.Assets.Name.Value
      description: Name of the asset
    - contextPath: Endpoint.OS
      description: Asset OS
    - contextPath: QRadar.Assets.AggregatedCVSSScore.Value
      description: CVSSScore
    - contextPath: QRadar.Assets.Weight.Value
      description: Asset weight
    - contextPath: QRadar.Assets.Name.LastUser
      description: Last user who updated the name
    - contextPath: QRadar.Assets.AggregatedCVSSScore.LastUser
      description: Last user who updated the Aggregated CVSS Score
    - contextPath: QRadar.Assets.Weight.LastUser
      description: Last user who updated the weight
    description: List all assets found in the model
  - name: qradar-get-asset-by-id
    arguments:
    - name: asset_id
      required: true
      default: true
      description: The ID of the requested asset.
    outputs:
    - contextPath: QRadar.Assets.ID
      description: The ID of the asset.
    - contextPath: Endpoint.MACAddress
      description: Asset MAC address.
    - contextPath: Endpoint.IPAddress
      description: It's in ip_addresses - value
    - contextPath: QRadar.Assets.ComplianceNotes.Value
      description: Compliance notes
    - contextPath: QRadar.Assets.CompliancePlan.Value
      description: Compliance plan
    - contextPath: QRadar.Assets.CollateralDamagePotential.Value
      description: Collateral damage potential
    - contextPath: QRadar.Assets.AggregatedCVSSScore.Value
      description: CVSSScore
    - contextPath: QRadar.Assets.Name.Value
      description: Name of the asset
    - contextPath: QRadar.Assets.GroupName
      description: Name of the asset's group
    - contextPath: Endpoint.Domain
      description: DNS name
    - contextPath: Endpoint.OS
      description: Asset OS
    - contextPath: QRadar.Assets.Weight.Value
      description: Asset weight
    - contextPath: QRadar.Assets.Vulnerabilities.Value
      description: Vulnerabilities
    - contextPath: QRadar.Assets.Location
      description: Location.
    - contextPath: QRadar.Assets.Description
      description: The asset description.
    - contextPath: QRadar.Assets.SwitchID
      description: Switch ID
    - contextPath: QRadar.Assets.SwitchPort
      description: Switch port.
    - contextPath: QRadar.Assets.Name.LastUser
      description: Last user who updated the name
    - contextPath: QRadar.Assets.AggregatedCVSSScore.LastUser
      description: Last user who updated the Aggregated CVSS Score
    - contextPath: QRadar.Assets.Weight.LastUser
      description: Last user who updated the weight
    - contextPath: QRadar.Assets.ComplianceNotes.LastUser
      description: Last user who updated the compliance notes
    - contextPath: QRadar.Assets.CompliancePlan.LastUser
      description: Last user who updated the compliance plan
    - contextPath: QRadar.Assets.CollateralDamagePotential.LastUser
      description: Last user who updated the collateral damage potential
    - contextPath: QRadar.Assets.Vulnerabilities.LastUser
      description: Last user who updated the vulnerabilities
    description: Retrieves the asset by id
  - name: qr-searches
    deprecated: true
    arguments:
    - name: query_expression
      required: true
      default: true
      description: The query expressions in AQL
    - name: headers
      description: Table headers
    description: Searches in QRadar
  - name: qr-get-search
    deprecated: true
    arguments:
    - name: search_id
      required: true
      default: true
      description: The search id
    - name: headers
      description: Table headers
    description: Gets a specific search id
  - name: qr-get-search-results
    deprecated: true
    arguments:
    - name: search_id
      required: true
      default: true
      description: The search id
    - name: range
      description: Number of results in return
    - name: headers
      description: Table headers
    description: Gets search results
  - name: qr-update-offense
    deprecated: true
    arguments:
    - name: offense_id
      required: true
      default: true
      description: The ID of the offense to update
    - name: protected
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Set to true to protect the offense
    - name: follow_up
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Set to true to set the follow up flag on the offense
    - name: status
      auto: PREDEFINED
      predefined:
      - OPEN
      - HIDDEN
      - CLOSED
      description: he new status for the offense
    - name: closing_reason_id
      description: The ID of a closing reason. You must provide a valid closing_reason_id
        when you close an offense
    - name: assigned_to
      description: A user to assign the offense to
    - name: headers
      description: Table headers
    - name: fields
      description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. Specify subfields
        in brackets and multiple fields in the same object are separated by commas
    description: Update an offense
  - name: qr-get-assets
    deprecated: true
    arguments:
    - name: range
      description: Number of results in return
    - name: fields
      description: Fields to filter in
    - name: filter
      description: Query to filter offenses
    - name: headers
      description: Table headers
    description: List all assets found in the model
  - name: qr-offenses
    deprecated: true
    arguments:
    - name: filter
      description: Query to filter offenses
    - name: fields
      description: 'Fields to filter in '
    - name: range
      description: Number of results in return
    - name: headers
      description: Table headers
    description: Gets offenses from qradar
  - name: qradar-get-closing-reasons
    arguments:
    - name: include_reserved
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true, reserved closing reasons are included in the response
      defaultValue: "true"
    - name: include_deleted
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true, deleted closing reasons are included in the response
      defaultValue: "true"
    - name: fields
      description: Use this parameter to specify which fields you would like to get
        back in the response
    - name: filter
      description: This parameter is used to restrict the elements in a list base
        on the contents of various fields
    - name: range
      description: Number of results in return
    description: Get closing reasons
  - name: qradar-create-note
    arguments:
    - name: offense_id
      required: true
      default: true
      description: The offense ID to add the note to
    - name: note_text
      required: true
      description: The note text
    - name: fields
      description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. Specify subfields
        in brackets and multiple fields in the same object are separated by commas
    - name: headers
      description: Table headers
    description: Create a note on an offense
  - name: qradar-get-note
    arguments:
    - name: offense_id
      required: true
      default: true
      description: The offense ID to retrieve the note from
    - name: note_id
      required: true
      description: The note ID
    - name: fields
      description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. Specify subfields
        in brackets and multiple fields in the same object are separated by commas
    - name: headers
      description: Table headers
    outputs:
    - contextPath: QRadar.Note.ID
      description: Note ID
      type: unknown
    - contextPath: QRadar.Note.Text
      description: Note text
    - contextPath: QRadar.Note.CreateTime
      description: The creation time of the note
    - contextPath: QRadar.Note.CreatedBy
      description: The user who created the note
    description: Retrieve a note for an offense
  - name: qradar-get-reference-by-name
    arguments:
    - name: ref_name
      required: true
      default: true
      description: The name of the requestered reference.
    - name: filter
      description: Query to filter offenses
    - name: fields
      description: 'Fields to filter in '
    - name: range
      description: Number of results in return
    - name: headers
      description: Table headers
    outputs:
    - contextPath: QRadar.Reference.Name
      description: The name of the reference.
    - contextPath: QRadar.Reference.CreationTime
      description: The creation time (ISO) of the reference.
    - contextPath: QRadar.Reference.ElementType
      description: Reference element type.
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements
    - contextPath: QRadar.Reference.TimeToLive
      description: Reference time to live.
    - contextPath: QRadar.Reference.TimeoutType
      description: Reference timeout type
    description: Information about the reference set that had data added or updated.
      This returns information set but not the contained data. This feature is supported
      from version 8.1 and upward.
  isfetch: true
  runonce: false
releaseNotes: "-"
