commonfields:
  id: Rapid7 Nexpose
  version: -1
name: Rapid7 Nexpose
display: Rapid7 Nexpose
category: Vulnerability Management
image: data:image/png;base64,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
description: Rapid7â€™s on-premise vulnerability management solution, Nexpose, helps
  you reduce your threat exposure by enabling you to assess and respond to changes
  in your environment real time and prioritizing risk across vulnerabilities, configurations,
  and controls.
configuration:
- display: Server URL (e.g. https://192.168.0.1:8080)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Do not validate server certificate (insecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: 2FA token
  name: token
  defaultvalue: ""
  type: 0
  required: false
script:
  script: |-
    from pprint import pprint
    import time
    import re
    import requests
    import json

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    SITE_COOKIE = "time-zone-offset=-180; _pendo_accountId.77c79869-0135-481b-7c93-53f43e8ae3d8=21c87447-3796-4bea-848b-660358b7e1da; _pendo_visitorId.77c79869-0135-481b-7c93-53f43e8ae3d8=21c87447-3796-4bea-848b-660358b7e1da-1; i18next=en-US; hide-dashboard-tour=shown; _pendo_meta.77c79869-0135-481b-7c93-53f43e8ae3d8=2114032251; nexposeCCSessionID=5D476D9DA8DA829E607FBF8E3B4BC7ED20A29DA4; TIMEOUT=session-alive'"
    SESSION = "5D476D9DA8DA829E607FBF8E3B4BC7ED20A29DA4"
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    VERIFY_SSL = not demisto.params().get('insecure', False)
    TOKEN = demisto.params().get('token', None)



    def get_server_url():
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    def load_proxy():
        proxy = {}
        if "proxy" in demisto.params():
            proxy["http"] = os.environ["http_proxy"]
            proxy["https"] = os.environ["https_proxy"]
        return proxy

    BASE_URL = get_server_url()
    SERVER_URL = BASE_URL + '/api/3'
    PROXY = load_proxy()


    def get_headers():
        headers = {
           'Content-Type': 'application/json'
        }

        if TOKEN is not None:
            headers['Token'] = TOKEN
        return headers


    def get_site_headers():
        headers = get_headers()

        headers['Cookie'] = SITE_COOKIE
        headers['nexposeCCSessionID'] = SESSION

        return headers


    def send_request(path, method = 'get', body = {}, params = {}):
        url = '%s/%s' % (SERVER_URL, path)
        headers = get_headers()
        res = requests.request(method, url, headers=headers, data=json.dumps(body), params=params, auth=(USERNAME, PASSWORD), verify=VERIFY_SSL, proxies = PROXY)
        if res.status_code < 200 or res.status_code >= 300:
            raise Exception('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))
        return res.json()

    def dq(obj, path):
      '''
      return a value in an object path. in case of multiple objects in path, searches them all.
      @param obj - dictionary tree to search in
      @param path (list) - a path of the desired value in the object. for example: ['root', 'key', 'subkey']
      '''
      if len(path) == 0:
          return obj

      if isinstance(obj, dict):
          if path[0] in obj:
              return dq(obj[path[0]], path[1:])
      elif isinstance(obj, list):
          # in case current obj has multiple objects, search them all.
          l = [dq(o, path) for o in obj]
          return [k for k in l if k is not None]

      # in case of error in the path
      return None


    def translate_single_object(obj, map_fields, filter_func=None):
      if filter_func is None:
          filter_func = lambda mf: True

      d = {}
      for f in map_fields:
          if filter_func(f):
              d[f['to']] = dq(obj, f['from'].split('.'))

      return d


    def translate_object(content, map_fields, filter_func=None):
      '''
      Converts object fields according to mapping dictionary
      @param content - original content to copy
      @param mapFields - an object assosiating source and destination object fields
      @filter_func - function to filter out fields
      @returns the mapped object
      '''
      if isinstance(content, (list, tuple)):
          return [translate_single_object(item, map_fields, filter_func) for item in content]
      else:
          return translate_single_object(content, map_fields, filter_func)


    def get_site(asset_id):
        url = BASE_URL + '/data/assets/' + str(asset_id) + '/scans'
        headers = get_site_headers()
        res = requests.post(url, headers=headers, auth=(USERNAME, PASSWORD), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            raise Exception('Got status code ' + str(res.status_code) + ' with body ' + res.content + ' with headers ' + str(res.headers))
        response = res.json()
        if response is None or response['records'] is None or len(response['records']) == 0:
            return ''

        return {
            'id': response['records'][0]['siteID'],
            'name': response['records'][0]['siteName'],
            'ip': response['records'][0]['ipAddress']
        }

    def get_list_response(path, limit=None, sort=None):
        final_result = []
        page_diff = 0
        page_number = 0
        params = {}

        while True:
            page = page_number
            page_number += 1
            params['page'] = page
            if limit is not None:
                params['size'] = limit
            if sort is not None:
                params['sort'] = sort
            response = send_request(path, params=params)
            if not response:
                break
            if response['resources'] is not None:
                final_result = final_result + response['resources']
            if response['page'] is not None:
                page_diff = response['page']['totalPages'] - response['page']['number']
            if page_diff < 1 or limit is not None:
                break

        return final_result


    def get_last_scan(asset):
        if asset['history'] is None:
            return "-"
        sorted_dates = sorted(asset['history'], key=lambda h: time.strptime(h['date'], "%Y-%m-%dT%H:%M:%S.%fZ"), reverse=True)

        return sorted_dates[0]['date'] if sorted_dates[0] is not None else "-"

    def get_asset_command():
        asset = get_asset(demisto.args()['id'])

        if asset is None:
            return "Asset not found"
        asset['LastScan'] = get_last_scan(asset)
        asset['Site'] = get_site(asset['id'])['name']

        assetHeaders = [
        'AssetId',
        'Addresses',
        'Hardware',
        'Aliases',
        'HostType',
        'Site',
        'OperatingSystem',
        'CPE',
        'LastScan',
        'RiskScore',
        ]

        assetOutput = translate_object(asset, [
            {'from': 'id', 'to': 'AssetId'},
            {'from': 'addresses.ip', 'to': 'Addresses'},
            {'from': 'addresses.mac', 'to': 'Hardware'},
            {'from': 'hostNames.name', 'to': 'Aliases'},
            {'from': 'type', 'to': 'HostType'},
            {'from': 'Site', 'to': 'Site'},
            {'from': 'os', 'to': 'OperatingSystem'},
            {'from': 'vulnerabilities.total', 'to': 'Vulnerabilities'},
            {'from': 'cpe.v2.3', 'to': 'CPE'},
            {'from': 'LastScan', 'to': 'LastScan'},
            {'from': 'riskScore', 'to': 'RiskScore'}
        ])

        softwareHeaders = [
            'Software',
            'Version'
            ]

        softwareOutput = translate_object(asset['software'], [
            {'from': 'description', 'to': 'Software'},
            {'from': 'version', 'to': 'Version'}
        ])

        serviceHeaders = [
            'Name',
            'Port',
            'Product',
            'Protocol'
            ]

        servicesOutput = translate_object(asset['services'], [
            {'from': 'name', 'to': 'Name'},
            {'from': 'port', 'to': 'Port'},
            {'from': 'product', 'to': 'Product'},
            {'from': 'protocol', 'to': 'Protocol'}
        ])

        userHeaders = [
            'FullName',
            'Name',
            'UserId'
            ]

        usersOutput = translate_object(asset['users'], [
            {'from': 'name', 'to': 'Name'},
            {'from': 'fullName', 'to': 'FullName'},
            {'from': 'id', 'to': 'UserId'},
        ])

        assetMd = tableToMarkdown('Nexpose asset ' + str(asset['id']), assetOutput, assetHeaders, removeNull=True)
        softwareMd = tableToMarkdown('Software', softwareOutput, softwareHeaders, removeNull=True)
        servicesMd = tableToMarkdown('Services', servicesOutput, serviceHeaders, removeNull=True)
        usersMd = tableToMarkdown('Users', usersOutput, userHeaders, removeNull=True)

        md = assetMd + softwareMd + servicesMd + usersMd

        endpoint =  {
            'IP': assetOutput['Addresses'],
            'MAC': assetOutput['Hardware'],
            'HostName': assetOutput['Aliases'],
            'OS': assetOutput['OperatingSystem']
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': asset,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                  'Nexpose.Asset(val.AssetId==obj.AssetId)': assetOutput,
                  'Endpoint(val.IP==obj.IP)': endpoint
            }
        }

        return entry


    def get_asset(asset_id):
        path = 'assets/' + str(asset_id)
        return send_request(path)

    def get_user(user_id):
        path = 'users/' + str(user_id)
        return send_request(path)

    def get_user_groups(user_id):
        path = 'users/' + str(user_id) + '/asset_groups'
        return get_list_response(path)

    def get_user_sites(user_id):
        path = 'users/' + str(user_id) + '/sites'
        return get_list_response(path)

    def get_assets_command():
        limit = demisto.args().get('limit', None)
        sort = demisto.args().get('sort', None)
        assets = get_assets(limit, sort)

        if(assets is None or len(assets) == 0):
            return 'No assets found'

        for asset in assets:
            asset['LastScan'] = get_last_scan(asset)
            site = get_site(asset['id'])
            asset['Site'] = site['name'] if site != '' else ''

        headers = [
        'AssetId',
        'Address',
        'Name',
        'Site',
        'Exploits',
        'Malware',
        'OperatingSystem',
        'RiskScore',
        'Assessed',
        'LastScan'
        ]

        outputs = translate_object(assets, [
            {'from': 'id', 'to': 'AssetId'},
            {'from': 'ip', 'to': 'Address'},
            {'from': 'hostName', 'to': 'Name'},
            {'from': 'Site', 'to': 'Site'},
            {'from': 'vulnerabilities.exploits', 'to': 'Exploits'},
            {'from': 'vulnerabilities.malwareKits', 'to': 'Malware'},
            {'from': 'os', 'to': 'OperatingSystem'},
            {'from': 'vulnerabilities.total', 'to': 'Vulnerabilities'},
            {'from': 'riskScore', 'to': 'RiskScore'},
            {'from': 'assessedForVulnerabilities', 'to': 'Assessed'},
            {'from': 'LastScan', 'to': 'LastScan'}
        ])

        endpoint = map(lambda o: {
            'IP': o['Address'],
            'HostName': o['Name'],
            'OS': o['OperatingSystem']
        }, outputs)

        entry = {
            'Type': entryTypes['note'],
            'Contents': assets,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Nexpose assets', outputs, headers,removeNull=True),
            'EntryContext': {
                  'Nexpose.Asset(val.AssetId==obj.AssetId)': outputs,
                  'Endpoint(val.IP==obj.IP)': endpoint
            }
        }

        return entry

    def get_assets(limit=None, sort=None):
        return get_list_response('/assets', limit, sort)

    try:
        if demisto.command() == 'test-module':
            get_assets(limit=1)
            demisto.results('ok')
        if demisto.command() == 'nexpose-get-assets':
            demisto.results(get_assets_command())
        if demisto.command() == 'nexpose-get-asset':
            demisto.results(get_asset_command())
    except Exception as e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
  commands:
  - name: nexpose-get-assets
    arguments:
    - name: sort
      description: 'The criteria to sort the records by, in the format: property[,ASC|DESC].
        The default sort order is ascending. Multiple sort criteria can be specified
        using multiple sort query parameters.'
      isArray: true
    - name: limit
      description: integer <int32> The number of records per page to retrieve.
    description: Returns all assets for which you have access.
  - name: nexpose-get-asset
    arguments:
    - name: id
      required: true
      description: integer <int64> The identifier of the asset.
    description: Returns the specified asset.
  - name: nexpose-get-user
    arguments:
    - name: id
      required: true
      description: integer <int32> The identifier of the user.
    description: 'Returns the details for a user. PRIVILEGES: Global Administrator,
      Current User'
  - name: nexpose-get-scan
    arguments:
    - name: id
      required: true
      description: integer <int64> The identifier of the scan.
    description: Returns the specified scan.
  - name: nexpose-get-asset-vulnerability-solution
    arguments:
    - name: id
      required: true
      description: integer <int64> The identifier of the asset.
    - name: vulnerabilityId
      required: true
      description: <string> The identifier of the vulnerability.
    description: Returns the details for solutions that can remediate a given vulnerability.
  runonce: false
