category: Email Gateway
commonfields:
  id: MicrosoftGraphMail
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Server URL
  name: url
  required: true
  type: 0
- display: Tenant ID (received from the admin consent - see Detailed Instructions
    (?) section)
  name: tenant_id
  required: true
  type: 4
- display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: token
  required: true
  type: 4
- display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- display: Use system proxy
  name: proxy
  required: false
  type: 8
description: Integration Template
display: Microsoft Graph Mail
name: MicrosoftGraphMail
script:
  commands:
  - arguments:
    - default: false
      description: User ID to pull mails from. Can be principal ID (email address)
      isArray: true
      name: user_id
      required: true
      secret: false
    - default: false
      description: ID of folder, comma seperated in the struct of (mail_box,child_mail_box,child_mail_box)
      isArray: false
      name: folder_id
      predefined:
      - ''
      required: false
      secret: false
    - default: false
      description: add OData query
      isArray: false
      name: odata
      required: false
      secret: false
    - default: false
      description: Search term
      isArray: false
      name: search
      required: false
      secret: false
    - default: true
      defaultValue: '1'
      description: How many pages of emails to pull. (10 email per page)
      isArray: false
      name: pages_to_pull
      required: false
      secret: false
    deprecated: false
    description: Get items from service.
    execution: false
    name: msgraph-mail-list-emails
    outputs:
    - contextPath: Example.Item.ID
      description: Item ID
      type: number
    - contextPath: Example.Item.Name
      description: Item name
      type: string
    - contextPath: Example.Item.CreatedDate
      description: Item creation date
      type: date
  - arguments:
    - default: false
      description: user id
      isArray: false
      name: user_id
      required: true
      secret: false
    - default: false
      description: '{message_id}'
      isArray: false
      name: message_id
      required: true
      secret: false
    - default: false
      description: '{folder_id}'
      isArray: false
      name: folder_id
      required: false
      secret: false
    - default: false
      description: '{odata}'
      isArray: false
      name: odata
      required: false
      secret: false
    deprecated: false
    description: Gets email properties
    execution: false
    name: msgraph-mail-get-email
  - arguments:
    - default: false
      description: '{user_id}'
      isArray: false
      name: user_id
      required: true
      secret: false
    - default: false
      description: '{message_id}'
      isArray: false
      name: message_id
      required: true
      secret: false
    - default: false
      description: '{folder_id}'
      isArray: false
      name: folder_id
      required: false
      secret: false
    deprecated: false
    execution: false
    name: msgraph-mail-delete-email
  - arguments:
    - default: false
      description: '{user_id}'
      isArray: false
      name: user_id
      required: true
      secret: false
    - default: false
      description: '{message_id}'
      isArray: false
      name: message_id
      required: true
      secret: false
    - default: false
      description: '{folder_id}'
      isArray: false
      name: folder_id
      required: false
      secret: false
    deprecated: false
    description: Lists all of the attachments of given email
    execution: false
    name: msgraph-mail-list-attachments
  - arguments:
    - default: false
      description: '{user_id}'
      isArray: false
      name: user_id
      required: true
      secret: false
    - default: false
      description: '{message_id}'
      isArray: false
      name: message_id
      required: true
      secret: false
    - default: false
      description: '{folder_id}'
      isArray: false
      name: folder_id
      required: false
      secret: false
    - default: false
      description: ID of attachment
      isArray: false
      name: attachment_id
      required: true
      secret: false
    deprecated: false
    description: Gets an attachment from email
    execution: false
    name: msgraph-mail-get-attachment
  dockerimage: demisto/python3:3.7.3.221
  isfetch: false
  runonce: false
  script: "import binascii\n\n\n\n''' IMPORTS '''\nimport requests\nimport base64\n\
    import os\n\n# Disable insecure warnings\nrequests.packages.urllib3.disable_warnings()\n\
    \n\"\"\" GLOBALS/PARAMS \"\"\"\n# Global annotation\nCONTEXT = demisto.getIntegrationContext()\n\
    DEMISTOBOT = 'https://ec2-18-197-54-7.eu-central-1.compute.amazonaws.com/msg-mail-token'\n\
    # Credentials\nTOKEN = demisto.params().get('token')\nTENANT_ID = demisto.params().get('tenant_id')\n\
    # Remove trailing slash to prevent wrong URL path to service\nSERVER = demisto.params().get('url')[:-1]\
    \ if (\n        demisto.params().get('url') and demisto.params().get('url').endswith('/'))\
    \ else demisto.params().get('url')\n# Should we use SSL\nUSE_SSL = not demisto.params().get('unsecure',\
    \ False)\n# Service base URL\nBASE_URL = str(SERVER) + '/v1.0'\n\n# Remove proxy\
    \ if not set to true in params\nif not demisto.params().get('proxy'):\n    os.environ.pop('HTTP_PROXY',\
    \ '')\n    os.environ.pop('HTTPS_PROXY', '')\n    os.environ.pop('http_proxy',\
    \ '')\n    os.environ.pop('https_proxy', '')\n\n''' HELPER FUNCTIONS '''\n\n\n\
    def error_parser(error: requests.Response) -> str:\n    \"\"\"\n\n    Args:\n\
    \        error (requests.Response): response with error\n\n    Returns:\n    \
    \    str: string of error\n\n    \"\"\"\n    try:\n        response = error.json()\n\
    \        error = response.get('error', {})\n        err_str = f\"{error.get('code')}:\
    \ {error.get('message')}\"\n        if err_str:\n            return err_str\n\
    \        # If no error message\n        raise ValueError\n    except ValueError:\n\
    \        return error.text\n\n\ndef http_request(method: str, url_suffix: str\
    \ = '', params: dict = None, data: dict = None, odata: str = None,\n         \
    \        url: str = None) -> dict:\n    \"\"\"\n    A wrapper for requests lib\
    \ to send our requests and handle requests and responses better\n    Headers to\
    \ be sent in requests\n\n    Args:\n        method (str): any restful method\n\
    \        url_suffix (str): suffix to add to BASE_URL\n        params (str): http\
    \ params\n        data (dict): http body\n        odata (str): odata query format\n\
    \        url (str): url to replace if need a new api call\n\n    Returns:\n  \
    \      dict: requests.json()\n    \"\"\"\n    token = get_token()\n    headers\
    \ = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json',\n\
    \        'Accept': 'application/json'\n    }\n\n    if odata:\n        url_suffix\
    \ += odata\n    res = requests.request(\n        method,\n        url if url else\
    \ BASE_URL + url_suffix,\n        verify=USE_SSL,\n        params=params,\n  \
    \      data=data,\n        headers=headers\n    )\n    # Handle error responses\
    \ gracefully\n    if not (199 < res.status_code < 299):\n        error = error_parser(res)\n\
    \        return_error(f'Error in API call to Microsoft Graph Mail Integration\
    \ [{res.status_code}] - {error}')\n    try:\n        return res.json()\n    except\
    \ ValueError:\n        return_error('Could not decode response from API')\n\n\n\
    def epoch_seconds(d: str = None) -> int:\n    \"\"\"\n    Return the number of\
    \ seconds for given date. If no date, return current.\n\n    Args:\n        d\
    \ (str): timestamp\n    Returns:\n         int: timestamp in epoch\n    \"\"\"\
    \n    if not d:\n        d = datetime.utcnow()\n    return int((d - datetime.utcfromtimestamp(0)).total_seconds())\n\
    \n\ndef add_attachments_to_context(message_id: str, attachments: dict or list)\
    \ -> dict:\n    def add_attachment(entry):\n        entry['Attachment'] = attachments\n\
    \        return entry\n\n    existing = demisto.get(demisto.context(), 'MSGraphMail')\n\
    \    if isinstance(existing, list):\n        for email in existing:\n        \
    \    if email.get('ID') == message_id:\n                return add_attachment(email)\n\
    \    elif isinstance(existing, dict):\n        if existing.get('ID') == message_id:\n\
    \            return add_attachment(existing)\n    return {'ID': message_id, 'Attachment':\
    \ attachments}\n\n\ndef get_token() -> str:\n    \"\"\"\n    Check if we have\
    \ a valid token and if not get one from demistobot\n\n    Returns:\n        str:\
    \ token from demistobot\n\n    \"\"\"\n    product = 'MicrosoftGraphMail'\n  \
    \  token = CONTEXT.get('token')\n    stored = CONTEXT.get('stored')\n    if token\
    \ and stored:\n        if epoch_seconds() - stored < 60 * 60 - 30:\n         \
    \   return token\n    headers = {\n        'Authorization': TOKEN,\n        'Accept':\
    \ 'application/json'\n    }\n\n    r = requests.get(\n        DEMISTOBOT,\n  \
    \      headers=headers,\n        params={\n            'tenant': TENANT_ID,\n\
    \            'product': product\n        },\n        verify=USE_SSL\n    )\n \
    \   if r.status_code != requests.codes.ok:\n        return_error(\n          \
    \  f'Error when trying to get token from Demisto Bot: [{r.status_code}] - {r.text}')\n\
    \    data = r.json()\n\n    demisto.setIntegrationContext(\n        {\n      \
    \      'token': data.get('token'),\n            'stored': epoch_seconds()\n  \
    \      }\n    )\n    return data.get('token')\n\n\ndef assert_pages(pages: str\
    \ or int) -> int:\n    \"\"\"\n\n    Args:\n        pages (str or int): pages\
    \ need to pull in int or str\n\n    Returns:\n        int: \n\n    \"\"\"\n  \
    \  if isinstance(pages, str) and pages.isdigit():\n        return int(pages)\n\
    \    elif isinstance(pages, int):\n        return pages\n    return 1\n\n\ndef\
    \ build_folders_path(folder_string: str) -> str or None:\n    \"\"\"\n\n    Args:\n\
    \        folder_string (str): string with `,` delimiter. first one is mailFolders\
    \ all other are child\n\n    Returns:\n        str or None:  string with path\
    \ to the folder and child folders\n\n    >>> build_folders_path('folder,child,child2')\n\
    \    'mailFolders/folder/childFolders/child/child2'\n    \"\"\"\n    if isinstance(folder_string,\
    \ str):\n        path = 'mailFolders/'\n        folders_list = argToList(folder_string,\
    \ ',')\n        first = True\n        for folder in folders_list:\n          \
    \  if first:\n                path += folder\n                first = False\n\
    \            else:\n                path += f'/childFolders/{folder}'\n      \
    \  return path\n    return None\n\n\ndef pages_puller(response: dict, page_count:\
    \ int) -> list:\n    \"\"\"\n\n    Args:\n        response (dict):\n        page_count\
    \ (int):\n\n    Returns:\n\n    \"\"\"\n    responses = [response]\n    i = page_count\n\
    \    while i != 0:\n        next_link = response.get('@odata.nextLink')\n    \
    \    if next_link:\n            responses.append(\n                http_request('GET',\
    \ url=next_link)\n            )\n\n        else:\n            return responses\n\
    \        i -= 1\n    return responses\n\n\ndef build_mail_object(raw_response:\
    \ dict or list, get_body: bool = False) -> dict or list:\n    \"\"\"Building mail\
    \ entry context\n    Getting a list from build_mail_object\n\n    Args:\n    \
    \    get_body (bool): should get body\n        raw_response (dict or list): list\
    \ of pages\n\n    Returns:\n        dict or list: output context\n    \"\"\"\n\
    \n    def build_mail(given_mail: dict) -> dict:\n        \"\"\"\n\n        Args:\n\
    \            given_mail (dict):\n\n        Returns:\n            dict:\n     \
    \   \"\"\"\n        # Dicts\n        mail_properties = {\n            'ID': 'id',\n\
    \            'Created': 'createdDateTime',\n            'LastModifiedTime': 'lastModifiedDateTime',\n\
    \            'ReceivedTime': 'receivedDateTime',\n            'SendTime': 'sentDateTime',\n\
    \            'Categories': 'categories',\n            'HasAttachments': 'hasAttachments',\n\
    \            'Subject': 'subject',\n        }\n\n        contact_properties =\
    \ {\n            'Sender': 'sender',\n            'From': 'from',\n          \
    \  'CCRecipients': 'ccRecipients',\n            'BCCRecipients': 'bccRecipients',\n\
    \            'ReplyTo': 'replyTo'\n        }\n\n        # Create entry properties\n\
    \        entry = {k: given_mail.get(v) for k, v in mail_properties.items()}\n\n\
    \        # Create contacts properties\n        entry.update(\n            {k:\
    \ build_contact(given_mail.get(v)) for k, v in contact_properties.items()}\n \
    \       )\n\n        if get_body:\n            entry['Body'] = given_mail.get('body',\
    \ {}).get('content')\n        return entry\n\n    def build_contact(contacts:\
    \ dict or list or str) -> object:\n        \"\"\"Building contact object\n\n \
    \       Args:\n            contacts (list or dict or str):\n\n        Returns:\n\
    \            dict or list[dict] or str or None: describing contact\n\n       \
    \ >>> build_contact([{'emailAddress':{'name': 'Sample Name','address': 'user@example.com'}}])\n\
    \        [{'Name': 'Sample Name', 'Address': 'user@example.com'}]\n\n        >>>\
    \ build_contact({'emailAddress':{'name': 'Sample Name','address': 'user@example.com'}})\n\
    \        {'Name': 'Sample Name', 'Address': 'user@example.com'}\n\n        >>>\
    \ build_contact({}) is None\n        True\n\n        >>> build_contact([]) is\
    \ None\n        True\n        \"\"\"\n        if contacts:\n            if isinstance(contacts,\
    \ list):\n                return [build_contact(contact) for contact in contacts]\n\
    \            elif isinstance(contacts, dict):\n                email = contacts.get('emailAddress')\n\
    \                if email and isinstance(email, dict):\n                    return\
    \ {\n                        'Name': email.get('name'),\n                    \
    \    'Address': email.get('address')\n                    }\n        return None\n\
    \n    mails_list = list()\n    if isinstance(raw_response, list):\n        for\
    \ page in raw_response:\n            # raw_response can be a list containing multiple\
    \ pages or one response\n            # if value in page, we got\n            value\
    \ = page.get('value')\n            if value:\n                for mail in value:\n\
    \                    mails_list.append(build_mail(mail))\n            else:\n\
    \                mails_list.append(build_mail(page))\n    elif isinstance(raw_response,\
    \ dict):\n        return build_mail(raw_response)\n    return mails_list\n\n\n\
    def file_result_creator(raw_response: dict) -> dict:\n    \"\"\"\n\n    Args:\n\
    \        raw_response (dict):\n\n    Returns:\n        dict:\n\n    \"\"\"\n \
    \   name = raw_response.get('name')\n    data = raw_response.get('contentBytes')\n\
    \    try:\n        data = base64.b64decode(data)\n        return fileResult(name,\
    \ data)\n    except binascii.Error:\n        return_error('Attachment could not\
    \ be decoded')\n\n\n''' COMMANDS + REQUESTS FUNCTIONS '''\n\n\ndef test_module():\n\
    \    \"\"\"\n    Performs basic get request to get item samples\n    \"\"\"\n\
    \    # TODO test_module\n\n\ndef list_mails(user_id: str, folder_id: str = '',\
    \ search: str = None, odata: str = None) -> dict or list:\n    \"\"\"Returning\
    \ all mails from given user\n\n    Args:\n        user_id (str):\n        folder_id\
    \ (str):\n        search (str):\n        odata (str):\n\n    Returns:\n      \
    \  dict or list:\n    \"\"\"\n    no_folder = f'/users/{user_id}/messages/'\n\
    \    with_folder = f'users/{user_id}/{build_folders_path(folder_id)}/messages/'\n\
    \    pages_to_pull = demisto.args().get('pages_to_pull', 1)\n\n    if search:\n\
    \        odata = f'?{odata}$search={search}' if odata else f'?$search={search}'\n\
    \    suffix = with_folder if folder_id else no_folder\n    response = http_request('GET',\
    \ suffix, odata=odata)\n    return pages_puller(response, assert_pages(pages_to_pull))\n\
    \n\ndef list_mails_command():\n    search = demisto.args().get('search')\n   \
    \ user_id = demisto.args().get('user_id')\n    folder_id = demisto.args().get('folder_id')\n\
    \    odata = demisto.args().get('odata')\n\n    raw_response = list_mails(user_id,\
    \ folder_id=folder_id, search=search, odata=odata)\n    mail_context = build_mail_object(raw_response)\n\
    \    entry_context = {'MSGraphMail(var.ID === obj.ID)': mail_context}\n    # TODO\
    \ return subjects, senders, from, sendtime to md\n\n    # human_readable builder\n\
    \    human_readable = tableToMarkdown(\n        f'### Total of {len(mail_context)}\
    \ of mails received',\n        mail_context,\n        headers=['Subject', 'From',\
    \ 'SendTime']\n    )\n    # TODO check if needed to fix commonserverpython\n \
    \   return_outputs(human_readable, entry_context, raw_response)\n\n\ndef delete_mail(user_id:\
    \ str, message_id: str, folder_id: str = None) -> True or False:\n    \"\"\"\n\
    \n    Args:\n        user_id (str):\n        message_id (str):\n        folder_id\
    \ (str):\n\n    Returns:\n\n    \"\"\"\n    with_folder = f'/users/{user_id}/{build_folders_path(folder_id)}/messages/{message_id}'\n\
    \    no_folder = f'/users/{user_id}/messages/{message_id}'\n    suffix = with_folder\
    \ if folder_id else no_folder\n    http_request('DELETE', suffix)\n    return\
    \ True\n\n\ndef delete_mail_command():\n    user_id = demisto.args().get('user_id')\n\
    \    folder_id = demisto.args().get('folder_id')\n    message_id = demisto.args().get('message_id')\n\
    \    delete_mail(user_id, message_id, folder_id)\n\n    human_readable = tableToMarkdown(\n\
    \        'Message has been deleted successfully',\n        {\n            'Message\
    \ ID': message_id,\n            'User ID': user_id,\n            'Folder ID':\
    \ folder_id\n        },\n        headers=['Message ID', 'User ID', 'Folder ID'],\n\
    \        removeNull=True\n    )\n\n    entry_context = {\n        f'MSGraphMail(val.ID\
    \ === {message_id}': None\n    }\n\n    return_outputs(human_readable, entry_context)\n\
    \n\ndef get_attachment(message_id: str, user_id: str, attachment_id: str, folder_id:\
    \ str = None) -> dict:\n    \"\"\"\n\n    Args:\n        message_id (str):\n \
    \       user_id (str_:\n        attachment_id (str):\n        folder_id (str):\n\
    \n    Returns:\n        dict:\n    \"\"\"\n    no_folder = f'/users/{user_id}/messages/{message_id}/attachments/{attachment_id}'\n\
    \    with_folder = f'/users/{user_id}/{build_folders_path(folder_id)}/messages/{message_id}/attachments/{attachment_id}'\n\
    \    suffix = with_folder if folder_id else no_folder\n    response = http_request('GET',\
    \ suffix)\n    return response\n\n\ndef get_attachment_command():\n    message_id\
    \ = demisto.args().get('message_id')\n    user_id = demisto.args().get('user_id')\n\
    \    folder_id = demisto.args().get('folder_id')\n    attachment_id = demisto.args().get('attachment_id')\n\
    \    raw_response = get_attachment(message_id, user_id, folder_id=folder_id, attachment_id=attachment_id)\n\
    \    entry_context = file_result_creator(raw_response)\n    demisto.results(entry_context)\n\
    \n\ndef get_message(user_id: str, message_id: str, folder_id: str = None, odata:\
    \ str = None) -> dict:\n    \"\"\"\n\n    Args:\n        user_id (str): User ID\
    \ to pull message from\n        message_id (str): Message ID to pull\n       \
    \ folder_id: (str) Folder ID to pull from\n        odata (str): OData query\n\n\
    \    Returns\n        dict: request json\n    \"\"\"\n    no_folder = f'/users/{user_id}/messages/{message_id}/'\n\
    \    with_folder = f'/users/{user_id}/{build_folders_path(folder_id)}/messages/{message_id}/'\n\
    \n    suffix = with_folder if folder_id else no_folder\n    response = http_request('GET',\
    \ suffix, odata=odata)\n\n    # Add user ID\n    response['userId'] = user_id\n\
    \    return response\n\n\ndef get_message_command():\n    user_id = demisto.args().get('user_id')\n\
    \    folder_id = demisto.args().get('folder_id')\n    message_id = demisto.args().get('message_id')\n\
    \    odata = demisto.args().get('odata')\n    raw_response = get_message(user_id,\
    \ message_id, folder_id, odata=odata)\n    mail_context = build_mail_object(raw_response)\n\
    \    entry_context = {'MSGraphMail(val.ID === obj.ID)': mail_context}\n    human_readable\
    \ = tableToMarkdown(\n        f'Results for message ID {message_id}',\n      \
    \  mail_context,\n        headers=['ID', 'Subject', 'SendTime', 'Sender', 'From',\
    \ 'HasAttachments']\n    )\n    return_outputs(\n        human_readable,\n   \
    \     entry_context,\n        raw_response=raw_response\n    )\n\n\ndef list_attachments(user_id:\
    \ str, message_id: str, folder_id: str) -> dict:\n    no_folder = f'/users/{user_id}/messages/{message_id}/attachments'\n\
    \    with_folder = f'/users/{user_id}/{build_folders_path(folder_id)}/messages/{message_id}/attachments'\n\
    \    suffix = with_folder if folder_id else no_folder\n    return http_request('GET',\
    \ suffix)\n\n\ndef list_attachments_command():\n    user_id = demisto.args().get('user_id')\n\
    \    message_id = demisto.args().get('message_id')\n    folder_id = demisto.args().get('folder_id')\n\
    \    raw_response = list_attachments(user_id, message_id, folder_id)\n    attachments\
    \ = raw_response.get('value')\n    if attachments:\n        attachment_list =\
    \ [{\n            'ID': attachment.get('id'),\n            'Name': attachment.get('name'),\n\
    \            'Type': attachment.get('contentType')\n        } for attachment in\
    \ attachments]\n        rdy = {'ID': message_id, 'Attachment': attachment_list}\n\
    \        # TODO here\n        entry_context = add_attachments_to_context(message_id,\
    \ attachments)\n        # TODO build context\n        entry_context['User ID']\
    \ = user_id\n        entry_context = {'MSGraphMail(val.ID === obj.ID)': entry_context}\n\
    \        human_readable = f'Total of {len(attachment_list)} attachments found\
    \ for message {message_id} from user {user_id}'\n        return_outputs(human_readable,\
    \ entry_context, raw_response)\n    else:\n        human_readable = f'No attachments\
    \ found in message {message_id}'\n        return_outputs(human_readable, dict(),\
    \ raw_response)\n\n\ndef main():\n    \"\"\" COMMANDS MANAGER / SWITCH PANEL \"\
    \"\"\n    command = demisto.command()\n    LOG(f'Command being called is {command}')\n\
    \n    try:\n        if command == 'test-module':\n            # This is the call\
    \ made when pressing the integration test button.\n            test_module()\n\
    \            demisto.results('ok')\n        elif command in ('msgraph-mail-list-emails',\
    \ 'msgraph-mail-search-email'):\n            list_mails_command()\n        elif\
    \ command == 'msgraph-mail-get-email':\n            get_message_command()\n  \
    \      elif command == 'msgraph-mail-delete-email':\n            delete_mail_command()\n\
    \        elif command == 'msgraph-mail-list-attachments':\n            list_attachments_command()\n\
    \        elif command == 'msgraph-mail-get-attachment':\n            get_attachment_command()\n\
    \    # Log exceptions\n    except Exception as e:\n        LOG(e)\n        LOG.print_log()\n\
    \        raise\n\n\nif __name__ == \"builtins\":\n    main()"
  type: python
