commonfields:
  id: McAfee ESM-v10
  version: -1
name: McAfee ESM-v10
display: McAfee ESM-v10
category: Analytics & SIEM
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAiCAYAAACUcR1DAAAAAXNSR0IArs4c6QAAGA9JREFUaAXtWwmYVNWVPnd5VfWquroBg4ACSdyiGHdHEYGm2eI6LowI0dFE1LjPxLiNJsYsjl/UZDRRictEMkaNW0aNQlTo6m4Q0RjjgkKMEVFxA9mqqqvqvXfvnf+86sLqhgYCMTjfl/t9Ve/VXc4995xzz3ZviQ5fPSCcuXRUmd6krSz/nqZBXlIdkFllZl5FZDcEbl42+aVVVPn46Dyt2FD7purmpr0D3u8MX5xMZDbVd3Pb5xFlTdab6gxpD2AjY99trtCjmzue+7Wn6IvCS+xNoekrPLXGVoLFmYDeOJAo/Gvg/K37ivnZhDPOrnKRvc8Ye2tLSC/+tZNc1JT6olLRaVK4aZGjhdetNBN7g9GW9s5OkDuzHEZfGxvSS73161n/BFEm48vrQimHtRSjMT3bt+b3q0SJFWn5TFbp/Q05KloqCqv3aC6V3tkU3LlNTX3Jlq+RNpoipWoSXQMCZ9e6IBreHNCiTcH4NNtl6Bi86Jv09FmelvPnZrz7OlK6eXMmvbQP7XPpduoWqYLntZDfVkSDQJ/KxsYKayspJfdNJPWcXMY7dWN9a23tCdojnU3Oymh9tuxFM9T6bslzT6LACXUDI97pBPlSZKysfHVTsHJEKRMW7vad/YYVsikALSv4cHHWLfgwoNerv7bdN+jFFBNUBmJWKd+TYrJU1Do3o5/syCaOeZ7I64nepQ00+pJ+6tdOqmc0qbOFkP1CQGE4m1OCuJPYDjt5RnuDuplVZG/jcr46UXsq55GDFYlLFwl7G7Fl9RA85k9cIssrkafOJ/I3Bs1lvMm+UocX0ZtHeFi+dlUqANYNf0szsjE8Ntam6xsdkGQJFOCYJ8QEGNEJnRn9XIdx01doM3O+UAcrj87DmPEafdgIMmO3pBjMJUCQlJDnVBrEfu1B9A2os1dqsJi4oS9/oKS40AEhxiuxefIDJUJQJmTRHa+bLvejP9Z+bq1nJCTPtUeQVuOp0/y2Vt/zKYWYVJtAW2MDoa53JnqqolM7lfNBa8/+n/bv2UQDUtnkwSasFESZFrmUOrwbgxkBAZowo2vi7El5kJJ0UF7R+6TkIIXWCP34s7WF52HNkRDykCihW3Mp+c2WtcGv5maTuxlrbk1JOabiqvhsaq55WT0Km2cSVOO+c6Xsi1GVuST+bK19tFgyDx8B7dkbjAEpfagSbkTVXFV7xapNqDPgy22QwUBbtjs31EBKmSYY+36iM7hqBFGJyl26pm7C9sbkrsqExxorhgP29k6KCknxMmz+b1ryEZRY7wUIpJt8dYQTbgL21c5knSe1fNtZ+2S+aB7B2tby6JV4Dgyjfk7pXWyaRgslvrkegx0EUSmZgHQy0vHHMsutGOiwL2qMZQLwhjKWAoLA8wRbWliYFInPKevuas94R9koHJHUeggzvzpL75BzWcI47wZh7NQEEI+AGA+DfgBa9E8k1VeVTx2tWp85Nl/504YgWS3OSQqpTDxftUcAwVLWjJ/dQMPGF+i1nuOwdpvjSbqKULJ0CJn1hCgHra3S+nJlogvBlSYLpFjn8UCQc1xg7AUdvryXSvbC0UTLa/Bqz/aUHi2V+C8txf5Mcx7r8MLvWNvJTRmxcE4UfWtchZ48gajcZs3zHhhmPT3YCLk67sd9uSQxq5PywdDYKfCs57NksloUWCxKHJaw7mOpQNVrsFXnANMf6ep03OevLhJz8DyssrlAsk5USg2JTQXq2ab1VkC8Psrph31JJxkpZRlIMRTGjxcW4jfD8bQa7Tn7eDvRrj1htSJsk84dxQzlwhqMC0NKaO1rlzg1rqj7Qmg5ZUFD4kF0+YLBuJjojga1p9UDzzR497WldAt3Z9Uv0uoWOJXfYyeM8ePCNGQ8WTtZuN4prU8WDfpRFlZur5U5TcmJSrnHmLm8CZgBvC4ez+8xjaT8ckqph3NpOhYwXUtAC0cG9OroYvREy9rKDd0YzJMCTqmlZO6LClGzDcOjImNmgcEGqlpzZ2PdM5Fxp+RXRgdft8pOx9ZeweO2pDBzYbreDq1dFgsXll1dSFXt8fqhRXoN22Ta+4EvxKHs+TIOwNMC1pxOa28sR+YeZ80qjQYmZFbQzrbB+z7W1w1dFYWnwxRkmKGMD9TezRjXyYxmASFnpuYgSN3WZ91+KeEmwXA38bh4rKAMCH18SojJTrqduX//tPo6nLAzSusmdXkw+Y5OG12G5+2YbY3CHNwODTIconhdbR7MOVAH4R3gf5ZpwoIeRaa9ZOyVZRNdDT68xE4da1k4M76S+rZcir5QG197rqeiMSYmQAtr4wo9DpY+/kxWHwrCTYq0yzWtMrOu+kRTs0TI7iSrgd70E44alZX6I4XBRaEQt4HQLcwMOHgUObfcCscagjXLA7xILnC44mcuSbuAG6eVoa+YMSBz3lr39dEl81DcAV8dCdrbCPcIiLPjGqLbIE3XY3QXJLSDB1bqk5mRvCuQ4FhaSDR8pzEofBk4NPOcYNqQUkYeQ8XwlzW4kKfYz64DFTfxruLdrMAL7N6EcOIS9sjZ3IGZy2F/j2jpDBGYcLGUS9BPyfNmQoPF5kg7d1Kuj3djy+rwRZHWZ4JrQ5j5iCAcsiU/ai6Z/6iO5ZntdzrScoan9CkhKOAL6l8SEg6wvajWh5/rMbi+sfZ+SD56Gu/8+ZsXAX6OqdAb91eiIwdl9HexyItCKRZE8KrHQtW0+Wqq2ACWQnkTU1CAbKd591eM+zEIsI65jOjogF5uVeEU53SyuRyBn92L9eVUqPeBZXAsBRiRVPcdtWbNqlxa3QWnopl7AzyUlJuG513oEtsLmOu3KyZ6wTmxB2xvHEpBE1WsEK+hD6RFvN/fp/21ErtGEL3YBBlaJYU5ti2TQPRULVA4gXVuBYRriIPnnpLCiyJ7FFpZax3D/g6LBoQ9gmA35jKJa+IqfLXHuMBnh1STkAIbELXy6BzZb7fAFuNHXDZAulrT3/eJVZeoGF3W7tOjqkCvjCXKbxQDSchPVAlQsXANE+IR6lx/xNgSPVuvcGo9cticTqkz45iXNYl1RSvVL7g96jQPln26Sis5mFUgoohD2nw6CBgu4PbRneHPsQ3vqGS8P0AL7eVYlSu5rKkQjtobuRJmMjJ257AmYseN/QvkFnZLCH0Fj/+kyNgMsBBwiVnkxJdnEjUCxFC276yboII9COA5Xcpr3XCOuJGhiX+zNw8Ig02KdgB736x1+swwuIZQc4kQAm9GsdYjxYoVxTorO6P1PNhq44a/RTZxOHbpniGIFCtQfMPT/SkcJd61FnTz8YwJnJRCG+GdBosXM5irQUG7fQ/QRdSBzDyMJS9Z31xlQ31N9Z2FwOuq5lAEW29AA5QSnK91vGH8GGDPIlHBmocLr8LAX6eyaarWVL/XAamv/H/xbt1bbDhZwhNaeWVJB1Ng1sv7zs7SduU8sd5bVVsXyCXanDsX+ZO4imEgj57xpJpY6wO1iB1VbY89bGuPh47/7mhCPgClfw+Ko6/7uK5OWvs2NEIMjh290Lg/ws94EjLQjeZgEpQEOlqrInSEYL0OW54HbivhNPZh5iKW7yxJ+Qth2BR/UuAKGCe1EzaKZQTTIMKkjz7psZk2uH7AZ+Udq2qF3YHZE6AlSCTkFXNTpqP+VAxqNF006h4/I4a2W3cFHLCHmQhQtwfD1jdXqVX1nnldzNT6Env5YDIzGt7wdp2+ORFq+ob6Pr29G0o8C9doDTzQpliDO5tWOrp2xFrOR3xS2n1/yJgNHGp0RNF8T+ud2McA95KBFM+OKYS/+mQkUQ4bONkYpEcUu8Os79NNmuIGKWu5jPp+vb87FXQJeu99PoWW5SX6/YC0mw3Pe2IZCCBk2AWBfa4tRbciS/SysNS/qMXpnpAjmG1JSQ+1N8hbqBCeS0KdlYAKZOLFOwThinOyxGgiW1TdtniH5CDJxlkxqD/8hmP39ZkUTkfmaJPmoKVUerc9Je/lQ5zYE9b6S1EUzW337dVSJ5+H19BgpZgEK3zB3Ab9MoT06mKnmVODjX07PbB2CgRYc6ysjL29o0HvYSrRAzKkIiRuf+B2OeAMbEu5G72yveNQ6r57eT2sxteV2OGw9iDOnqyr3MjLRX1pb8j3EXzM8PcucMqMicyF2MUfcTKGnSGh1NCUp69OKvXblKd+wcyN40R4mNaYQIThEznfH4z89nGsdpm5zpiyNdFhZZXaM6GCPY0I131w+DICSmIF72SGA3u5t5+pJjE2Z722bL9XiqLFbCd5vBJymKcTd5soegnG+jnUXw4sGhhP4Px4qkHBklQL+yIRyR8jrsbsKEKkIG2Xi4T3e+HLl5C8+TXWsTcSKNv39dTVYVpNh8aqmfMuKGBw1/C4gpPsmty+sAi5jox+oj1J/7yhQRdnadQlfb17pVALpBRHsnTXCtO59t7bkzvwvJvs2AWgt/4cRgWV6Hio1tcRB4IG7FXGYUX8RAjC8SF7PsuR9TmFD/GRAj4LBxyNTLQEE0+IXAu848PWrl3J6nN8nj6ufVrywWKEL49wP8aX1R3s4hldaLG9BP3iOo7F+bVbaSH6wGp9XBCZ52P8pIRXjShKSUR4pNgkJAEbQlosR9GlKwo98t7F4Nuo/4mGlDEOcbwuSEOQfYbDu5OdtDXGPhlZc/GGLhfwIUg5pVWKJ2N3npmMxfBp0kQgN7Gk6dl2ctOXCjPrRaEOwpWH87CSCUjO4zSpqrp4Vbw6TlyEnMTcSLFwJxC9hTh/RZ4CqXapujkOPYcCLvgE5wJgoScENGg3EzI2oqc7CuHIclqfhYTCcSDzzmCCD88kxA5cVrF2JlTjTS2ItdnhclafhDrcS+CsHLtGdEfPOet/w4m5s2LDk9ETKh1JCynGzybabQzRn9sBArjxB0IUH67VD43fWUjmEY2tZMQZmHMKBOpL6J6RUCno8EEg1RyEOjeNK9kXeg5u4fiuZL/Vjs0mnT0b45Dtou3wQeqe1iIIfhnux52Lyubub0BJ9BzPv0Uum9gd4cFULPRryL0OZTXNTK4VToexL7hImfcWKrkDznDXHThwH+6p8B26aCV20L2RM7f8eOX6yXnuyyWHtJ+XoB3BLM6Zi5Ly8xNKpberret/P0XU1JSgwQU0NeBTlFRsKdNb6/eMYWvp+4OUKTWGOPnMVug9SPW66PgJ3ApJe7RLhbcjCtZlswH9aUOSX4N/FZY4GhcOPGxgpmDK82QlkVnSsnr1as5je9am4nWIMJhXoMXo36u9QnZLDfD9HWRU6getEgQBvTeBCEm2zStxrrpCAxMeFLTVK4bDzm9qJNhXLR3w/F1j8qsiCs9E+msYUyC2X3hyZPgmMvJIfvK+iwdgUXE9+rwDPs2wRt95/ZrykrjxH1+fGQqsY3ANoxw2is4oqDpxNpLph+CQhuMw+ouiCAzWvIN5EHQcYk57mwrs3dcU1j/mqsH7x3PbUmA9BtfQAaO1TtJhSOedC+diwlIctr4AjiN0WAAeT8+vNr+5hYg15z/KZ5gCvTK4HucFWT3ydUGT/ihdW3G1mXlbLwa9fkxv70/5/tAGKh1Y1gkrEbpAgOKUnlPpHNu13sZtST37FwimfohrN6e3EG017Jwvz4MLuhyHGvdtCT7bYgw256bL8OqVEjiDW1+UZ/egSH0TJzRNCNT3gv5/Ds5pRYrSQkDfeiZk5GWyaB9qhpdrogAhojehMU5TbD3uOEXyrBIeleoDw62H+2lC2Kwd/GkgkGv0h4soeCyvzO58CR4mISXTcppHYj/kbBevLka3HoOcLHuO0iAEIjcQaQmk+WRYkNHPGwqkZVqfh0h0O8SHD+Ou9O9a0+pI3Ai5G2HSzEhK3GShV3Ab4n8x7jLEnaNcZJZUyvYW9lw5vi+mvdMSZA6Ao/iKKdnbscvLuYz6GhLHz2tPn4Ro6hUkHO6prb8tmzgOQevqMeUo19qY/EoiCI/FSR0u24nf8vy1fljLQEqro0DcZciYHQt/ZbEphtNj+FinTtM0RWo/nAAt8ovR9Lzv98OypiwvRje/hizZmIz3b8B5EcPEleG9rJLNLSV7Uy7tHeiRPRWxWhQG4X/z7Y32tLefoXAo4IW4jXOkK4RXYJ51G4Wd4W1SENPFmfh++TjSIpnxbkLi5CxmLrIHk3DJ7JcOjrow6lbEmfsgAn4MSYfTcd1oSB/kC6yvH8XNiT4Uhb+HNri9NUXjEOpl0eIB9sc4YFoDOBx2fw4O4yTA+LNU8jzP11fygvO+/k8E1aeFWncI7Z0gMt6PuB65iwtVwnsI14d3RGpsHaG4DRH52U6LY+YkaWfEpQ/YhPcn3Mh4E4cAg+L2ri/n0QAl5e3AfxpuxPwFUdnFEmfd3Ix5bibhxevEZP9SaEjMCDO48SbEdz/X5A1rSdHn0e1afC7j/k57Z8AbOqw9vm5kH4bwLsHFwo+B4yMc+eCweq+UUP8D5n4LuZY1/XqYz23GYEaeS5Aly7sUQfEJOLS/oLkYXV+haBqkdOLT2eQuYOzuzlOPjII0g0kLkQZ6Kwxpd/j2wyInn4ODv0JLuUJ5ycljSuYBo1SxEpo7WwrmQeVCiastkY6CC3FH6TrspBmY54CZfEdAyZNwPWc+1HgBB+9/AOkn51iLcGhvzGPD8+EpzZ0GXeuLKCPREkjpV+A/RHA4P19y9qExZXNnfS9oCwQetlMrffnokr0WQvtDmKFJc4h2xN+EJuHK0/m8TvzzYRpyqEfKQmcK459TgRkJmR6L0Y/B1qfYX4EQDHdRcI9LyROwznJZ6yWRdIvB+u1tNjESOfdiJISVhXDKmGJw+T5IFdTjss0ZjNsY1osoDc9cKhvFtwoTqfQqJnNQrqSwO36C25ZXzkurO3Fw1OiC4H5kqHYAg/iQ50BI+HhPUit2yaw2XKAH0wROUvlolRMySAjKoitXLw84SDd2ikHCNiWsSSHgG0zSw87HEQNFNw4G1Qz0Kgj2aj2R6t/5aI4PEgzx0aIYmtLegraMvrhbHzQATCWKZCfXa2M/BOgEEjw4q8Xpfdc6qTG9Cn4IBAUX7J37HbJm4yCAyO3TvcjILdWu9K9sgnQJ+SGpBkKgcPJgm6WVzUhJ3CoqwRvGmRQSgh+Mog3/12ubMhhEkNFaZHdK9CHW/RGYdgRneyiIxuEarDEhvQU16uPE5GXOklWK4fGccsT9HCyMj1loRnNneP7SfHhJIR/MMllcYMfBEnYLLsPFeWJo7/hUFlMxt6EXjMVtdspD3b+LM+DXWgrh+dAO/x4U7c92gUIBoRXGx+aDx9QXaI0Yznxcyg86w0UjC8EkSMyNGHN+jHdXZ7hgED7RKCk4FFpBQ30ejt/LdEBLEDWswJXWeJ22FI7Hbo1EQMukE3NYYKFmh1lt5gBCGzTAOSKy747GGTQyTAuRTvaSxehKXvM7+fA7OeTiodEg33wZl5fHmUk9cm6Kdqrhvc0YDBHHfTiXLzWQ2BXSLow5H4dipw/y1QLs2u9jgRexM2SU7IPrnGOQ9742ndGtcCp+lg3pVWfCa7DL72/3VccOWe/ZdEqPGJfHuaiQv0snEj/vSMmbORWJLZwHwcFvfNmogh1aAiUs5jgPWbkTcAQ3f15aL0im9aWoxzEzFWCrq/+uqVGp6wndUMKnUMkmPu9nvKfx956nlLVTYZunT+abOV0FRIUmF3kw9izPF89gnsPAxyv5UjzE9gII6xm8TuD3Pazz4hY4RaYzfA0IroJAL+XDDrhR7aBPE9jWymAz+fBXyNvPMw2JBXOx5v5p/dThWepLKlEGTqyWHRxHDWV9l1EJpKarhbm+TQrbwYzvb/9hqfRejTh8GJA19MVKJy1jqW1t8g7A6fQMHPNNDgNaqbN6N6jVWTYI98FF77/wYTlilkG497Ti/TItZTjYSYkvZLxhq0y4ZnCZlq3w/QG1ObCb+viYFxl7qEwi4NDYmKbdMEcFe/cNZgBiwR2Qc14Loq+XxHmigbZPq6Zw5Jo1q+fg76IZQ/0DRR81l2lJPRH5NicU8mxcQhgJ9dxQ7gzfA7wPan16rrNWj/tAAwpZipjBkEgxG+uzpdLHX6mzq/HZQRQ04uLBO0wjrKkBJqcRxvs9hsP5cZ2vrERbbO62GYNri9rYsyPt7Y9D8cdkZK6EM7JcanU0DkJ2gqo+un7RG4OxLdqYwRZ/mBM2se/m/AX108Rxm6nozVkUbi++gDDgRARLpztP3+yUfM7BDn+WmVu/LhVbg/qav//7/wH4JfbRE0Fu5QAAAABJRU5ErkJggg==
description: Run queries and receive alarms from Intel Security ESM
detaileddescription: If timezone parameter should be set according to the timezone
  the McAfee ESM uses. For examples if the alarms in ESM are -0600 then the timezone
  should be set to -6.
configuration:
- display: Port
  name: port
  defaultvalue: "443"
  type: 0
  required: true
- display: ESM IP (e.g. 78.125.0.209)
  name: ip
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: 'Fetch Types: cases, alarms, both (relevant only for fetch incident mode)'
  name: fetchTypes
  defaultvalue: alarms
  type: 0
  required: false
- display: 'Start fetch after Case ID: (relevant only for fetch incident mode)'
  name: startingCaseID
  defaultvalue: "0"
  type: 0
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: 'Version: (one of 10.0, 10.1, 10.2)'
  name: version
  defaultvalue: "10.2"
  type: 0
  required: true
- display: 'McAfee ESM Timezone in hours (e.g if ESM timezone is +0300 => then insert
    3) '
  name: timezone
  defaultvalue: "0"
  type: 0
  required: false
script:
  script: |-
    import base64
    import json
    import re
    import sys
    import requests
    import time
    from datetime import datetime, timedelta
    from distutils.util import strtobool

    # global for ignoring errors in fetch incident
    SHOULD_STOP_ON_ERROR = True
    MAX_CASES_PER_FETCH = 30

    # by default filters only "Closed" cases
    FILTERED_OUT_STATUSES = [2, ]
    VERIFY = demisto.params()['insecure'] == False
    requests.packages.urllib3.disable_warnings()
    VERSION = demisto.params()['version']

    ESM_URL = demisto.params()['ip'] + ":" + demisto.params()['port']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    TIMEZONE = float(demisto.params().get('timezone'))
    ESM_DATE_FORMAT = '%Y/%m/%d %H:%M:%S'

    def throw_error(error_str):
        if SHOULD_STOP_ON_ERROR:
            demisto.results({ 'Type' : entryTypes['error'], 'ContentsFormat' : 'text', 'Contents' : error_str })
            sys.exit(0)
        else:
            demisto.error(error_str)

    def search_result_to_md(res):
        columns = res['columns']
        rows = res['rows']

        md = "### results:\n"

        if(len(rows) == 0):
            return md + "No matching search result were found"

        # headers
        columnNames = list(map(lambda column: column['name'], columns))
        md = md + ' | '.join(columnNames) + '\n'
        md = md + ' | '.join(list(map(lambda column: "---", columns))) + '\n'

        # body
        for row in rows:
            md = md + ' | '.join(r.replace('|', '\\|') for r in row['values']) + '\n'

        return md

    @logger
    def search_results_to_context(res):
        columns = res['columns']
        rows = res['rows']
        fixed_searches = []
        for row in rows:
            values = row['values']
            i = 0
            for column in columns:
                if (len(values[i]) != 0):
                    column_string = column['name'].replace(".", "")
                    column_string = column_string.replace(")", "")
                    column_string = column_string.replace("(", "")
                    fixed_searches.append({
                    column_string : values[i]
                    })
                i += 1
        context = {'SearchResults(val.ID && val.ID == obj.ID)' : fixed_searches}
        return context


    def severity_to_level(severity):
        if severity > 65:
            return 3
        elif severity > 32:
            return 2
        else:
            return 1


    class NitroESM(object):
        def __init__(self, esmhost, user, passwd):
            """ Init instance attributes """
            self.esmhost = esmhost
            self.user = user
            self.passwd = passwd
            self._build_login_urls()
            self._encode_login()
            self._build_params()
            self.is_logged_in = False
            self._case_statuses = None


        def _build_login_urls(self):
            """ Concatenate URLs """
            self.url = 'https://{}/rs/esm/'.format(self.esmhost)
            self.int_url = 'https://{}/ess'.format(self.esmhost)
            self.login_url = '{}{}'.format(self.url, 'login')


        def _encode_login(self):
            self.b64_user = base64.b64encode(self.user.encode('utf-8')).decode()
            self.b64_passwd = base64.b64encode(self.passwd.encode('utf-8')).decode()


        def _build_params(self):
                self.params = {"username": self.b64_user,
                               "password": self.b64_passwd,
                               "locale": "en_US",
                               "os" : "Win32"
                               }
                try:
                    self.params_json = json.dumps(self.params)
                except TypeError as e:
                    throw_error("Invalid parameters: {}".format(self.params))


        def login(self):
            try:
                authString = base64.encodestring('%s:%s' % (self.user, self.passwd)).strip()
                self.v10_login_headers = {'Content-Type': 'application/json'}
                self.login_response = requests.post(self.login_url,
                                                    self.params_json,
                                                    headers=self.v10_login_headers,
                                                    verify=VERIFY)
                self.cookie = self.login_response.headers.get('Set-Cookie')
                try:
                    self.jwttoken = re.search('(^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*)', self.cookie).group(1)
                except TypeError as e:
                    throw_error("Failed login\nurl: {}\n response status: {}\nresponse: {}\n".format(self.login_url,
                                    self.login_response.status_code, self.login_response.text))
                self.xsrf_token = self.login_response.headers.get('Xsrf-Token')
                self.session_headers = {'Cookie' : self.jwttoken,
                                        'X-Xsrf-Token' : self.xsrf_token,
                                        'Content-Type': 'application/json'}
                self.is_logged_in = True
            except KeyError as e:
                throw_error("Failed login\n error: {}".format(e))


        def logout(self):
            if self.is_logged_in:
                try:
                    headers = {'Cookie' : self.cookie}
                    requests.post(self.url + 'userLogout',
                        headers=self.session_headers,
                        # headers=headers,
                        data=json.dumps(''),
                        verify=VERIFY
                        )
                    self.is_logged_in = False
                except Exception as e:
                    demisto.error('McAfee ESM logout failed with the following error: %s' % (str(e), ))


        @logger
        def cmdquery(self, cmd, query=None, no_answer=False, no_validation=False):
            """ Send query to ESM, return JSON result """
            self.cmd = cmd
            self.query = query
            self.url = 'https://{}/rs/esm/'.format(self.esmhost)
            self.result = requests.post(self.url + self.cmd,
                                        headers=self.session_headers,
                                        data=self.query, verify=VERIFY)
            if not no_validation:
                if no_answer:
                    if self.result.status_code != 200:
                        throw_error('Error - ESM replied with:\n - status code: {} \n - body: {}'.format(self.result.status_code, self.result.text))
                else:
                    try:
                        res = self.result.json()
                        if VERSION != '10.0' and not cmd.startswith('v2'):
                            res = res['return']
                        return res
                    except:
                        throw_error('Error - ESM replied with:\n - status code: {} \n - body: {}'.format(self.result.status_code, self.result.text))

        @logger
        def execute_query(self, time_range, custom_start, custom_end, filters, fields, query_type):
            if (time_range == 'CUSTOM' and (not custom_start or not custom_end)):
                throw_error('you must specify customStart and customEnd when timeRange is CUSTOM')

            cmd = '%sqryExecuteDetail?reverse=false&type=%s' % ('v2/' if VERSION=='10.2' else '', query_type, )

            if (time_range == 'CUSTOM'):
               cmd = cmd + '&customStart=' + custom_start + '&customEnd=' + custom_end

            q = {
                'config': {
                    'timeRange': time_range,
                    'filters': filters,
                }
            }
            if fields is not None:
                q['config']['fields'] = [{'name':v} for v in argToList(fields)]
            query = json.dumps(q)

            res = self.cmdquery(cmd, query)
            return res['resultID']

        @logger
        def get_query_result(self, resultID):
            cmd = '%sqryGetStatus' % ('v2/' if VERSION=='10.2' else '', )
            query = json.dumps({ 'resultID': resultID })

            res = self.cmdquery(cmd, query)
            return res['complete']

        def wait_for_results(self, resultID, max_wait):

            # initial back off, sleep 3 sec between each time
            for i in range(5):
                ready = self.get_query_result(resultID)
                if ready:
                    return
                else:
                    time.sleep(3)

            # wait for response - 1 min between each try
            for i in range(max_wait):
                ready = self.get_query_result(resultID)
                if ready:
                    return
                else:
                    time.sleep(60)

            throw_error('Waited more {} min for query results : {}'.format(max_wait, resultID))

        @logger
        def fetch_results(self, resultID):
            cmd = '%sqryGetResults?startPos=0&reverse=false&numRows=10000' % ('v2/' if VERSION=='10.2' else '', )

            query = json.dumps({ 'resultID': resultID })

            res = self.cmdquery(cmd, query)
            return res

        @logger
        def search(self, time_range, custom_start, custom_end, filters, fields, query_type, max_wait):

            # execute command
            resultID = self.execute_query(time_range, custom_start, custom_end, filters, fields, query_type)

            # wait for result to be ready
            self.wait_for_results(resultID, max_wait)

            #fetch result
            res = self.fetch_results(resultID)

            table = search_result_to_md(res)
            context = search_results_to_context(res)

            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': res,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': table,
                'EntryContext': context
            }

        @logger
        def fetchAllFields(self):

            res = self.cmdquery('%sqryGetFilterFields' % ('v2/' if VERSION=='10.2' else '', ))

            # convert to an appropriate table
            for x in res:
                x['types'] = ','.join(x['types'])

            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': res,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tblToMd('Result:' ,res),
            }


        # alarms commands
        @logger
        def fetch_alarms(self, time_range, custom_start, custom_end, assigned_user):
            if (time_range == 'CUSTOM' and (not custom_start or not custom_end)):
                throw_error('you must specify customStart and customEnd when timeRange is CUSTOM')



            cmd = 'alarmGetTriggeredAlarmsPaged?pageSize=500&pageNumber=1&triggeredTimeRange=' + time_range
            if (time_range == 'CUSTOM'):
               cmd = cmd + '&customStart=' + custom_start + '&customEnd=' + custom_end

            query = ''
            if (assigned_user == 'ME'):
                user = self.get_user_obj(self.user)
                query = json.dumps({ 'assignedUser' : user})
            elif assigned_user:
                query = json.dumps({ 'assignedUser' : self.get_user_obj(assigned_user)})

            res = self.cmdquery(cmd, query)

            for alarm in res:
                alarm['ID'] = alarm['id']['value']
                del alarm["id"]

            return res


        @logger
        def update_alarms_status(self, alarm_ids):
            cmd = 'alarm%(action)sTriggeredAlarm' % (action, )
            query = json.dumps({'triggeredIds' : [{'value' : int(i)} for i in alarm_ids]})



            # the command return an error for a list of alarm ids however is execute the update successfully.
            self.cmdquery(cmd, query, no_validation=True)
            return 'Alarms has been %sd.' % (action, )


        @logger
        def acknowledge_alarms(self, alarm_ids):
            return self.update_alarms_status('Acknowledge', alarm_ids)


        @logger
        def unacknowledge_alarms(self, alarm_ids):
            return self.update_alarms_status('Unacknowledge', alarm_ids)


        @logger
        def delete_alarms(self, alarm_ids):
            return self.update_alarms_status('Delete', alarm_ids)


        @logger
        def get_alarm_event_details(self, event_id):
            cmd = ('%sipsGetAlertData' % ('v2/' if VERSION == '10.2' else '', ))
            query = json.dumps({'id' : event_id})


            res = self.cmdquery(cmd, query)

            return res


        @logger
        def list_alarm_events(self, alarm_id):
            cmd = 'notifyGetTriggeredNotificationDetail'
            query = json.dumps({'id' : alarm_id})


            res = self.cmdquery(cmd, query)

            return res


        # case statuses commands
        @logger
        def add_case_status(self, name, should_show_in_case_pane):
            '''add a new type of case status with given parameters'''

            status_details = {
                'name' : name,
                'default' : False,
                'showInCasePane' : should_show_in_case_pane
            }

            cmd = 'caseAddCaseStatus'
            query = json.dumps({'status' : status_details})
            self.cmdquery(cmd, query)
            return 'Added case status : %s' % (name, )


        @logger
        def edit_case_status(self, original_name, new_name, show_in_case_pane):
            '''edit a  case status with given id'''


            status_id = self.case_status_name_to_id(original_name)
            status_details = {
                'id' : status_id,
                'name': new_name
            }

            if show_in_case_pane is not None:
                status_details['showInCasePane'] = show_in_case_pane

            cmd = 'caseEditCaseStatus'
            query = json.dumps({'status' : status_details})
            self.cmdquery(cmd, query, no_answer=True)

            return 'Edit case status with ID: %d' % (status_id, )


        @logger
        def delete_case_status(self, name):
            '''delete a new type of case status with given name'''

            status_id = self.case_status_name_to_id(name)
            status_id = {'value' : status_id}

            cmd = 'caseDeleteCaseStatus'
            query = json.dumps({'statusId' : status_id})
            self.cmdquery(cmd, query, no_answer=True)

            return 'Deleted case status with ID: %d' % (status_id['value'], )


        @logger
        def get_case_statuses(self):
            '''get all case statuses'''

            cmd = 'caseGetCaseStatusList'
            query = json.dumps({"authPW": {"value": self.passwd}})

            return self.cmdquery(cmd, query)


        @logger
        def case_status_id_to_name(self, status_id, use_cache=True):
            '''convert case status id to name'''
            if self._case_statuses is None:
                self._case_statuses = demisto.getIntegrationContext().get('case_statuses', None)

            if self._case_statuses is None or not use_cache or not any([s['id'] == status_id for s in self._case_statuses]):
                self._case_statuses = self.get_case_statuses()
                demisto.setIntegrationContext({
                    'case_statuses': self._case_statuses
                })

            matches = [status['name'] for status in self._case_statuses if status['id'] == status_id]

            return matches[0] if matches else 'Unknown - %d' % (status_id, )


        @logger
        def case_status_name_to_id(self, status_name, use_cache=True):
            '''convert case status name to id'''
            if self._case_statuses is None or not use_cache or not any([s['name'].lower() == status_name.lower() for s in self._case_statuses]):
                self._case_statuses = self.get_case_statuses()

            matches = [status['id'] for status in self._case_statuses if status['name'].lower() == status_name.lower()]

            return matches[0] if matches else 0 # 0 is not a valid value


        # user commands
        @logger
        def get_users(self):
            '''get all user's names'''

            cmd = 'userGetUserList'
            query = json.dumps({"authPW": {"value": self.passwd}})

            return self.cmdquery(cmd, query)


        @logger
        def get_user_obj(self, user_name):
            '''get user object'''
            if user_name.lower() == 'me':
                user_name = self.user

            res = self.get_users()
            matches = [user for user in res if user['username'] == user_name]
            self_matches = [user['id']['value'] for user in res if user['username'] == self.user]

            # the login user must appear in the user list
            return matches[0] if matches else self_matches[0]


        @logger
        def user_name_to_id(self, user_name):
            '''convert user name to id'''
            if user_name is None or user_name.lower() == 'me':
                user_name = self.user
            res = self.get_users()
            matches = [user['id']['value'] for user in res if user['username'] == user_name]
            self_matches = [user['id']['value'] for user in res if user['username'] == self.user]

            # the login user must appear in the user list
            return matches[0] if matches else self_matches[0]


        @logger
        def user_id_to_name(self, user_id):
            '''convert user id to name'''
            res = self.get_users()
            matches = [user['username'] for user in res if user['id']['value'] == user_id]

            return matches[0] if matches else self.user


        # organization commands
        @logger
        def get_organizations(self):
            '''get all organization names'''

            cmd = 'caseGetOrganizationList'
            return self.cmdquery(cmd, '')


        @logger
        def organization_name_to_id(self, organization_name):
            '''convert organization name to id'''
            if organization_name is None:
                organization_name = ''
            res = self.get_organizations()
            matches = [org['id'] for org in res if org['name'].lower() == organization_name.lower()]

            return matches[0] if matches else 1


        @logger
        def organization_id_to_name(self, organization_id):
            '''convert organization name to id'''
            res = self.get_organizations()
            matches = [org['name'] for org in res if org['id'] == organization_id]

            return matches[0] if matches else 'None'



        # cases commands
        @logger
        def get_cases(self, since_date_range=None):
            '''get all cases associated with current user'''
            cmd = 'caseGetCaseList'
            res = self.cmdquery(cmd)
            cases = []
            if since_date_range:
                start_time, _ = parse_date_range(since_date_range, ESM_DATE_FORMAT)
                for case in res:
                    if case.get('openTime') > start_time:
                        cases.append(case)

            else:
                cases = res

            return cases

        def get_case_detail(self, case_id):
            cmd = 'caseGetCaseDetail'
            case_id = {'id' : {'value' : case_id}}
            query = json.dumps(case_id)
            res = self.cmdquery(cmd, query)

            return res

        def add_case(self, summary, severity, status, assignee, organization):
            if severity < 1:
                severity = 1
            elif severity > 100:
                severity = 100

            if status is None:
                status = 'Open'

            assignee = self.user_name_to_id(assignee)
            org_id = self.organization_name_to_id(organization)

            cmd = 'caseAddCase'
            case_details = {
                'summary' : summary,
                'assignedTo' : assignee,
                'severity' : severity,
                'orgId' : org_id,
                'statusId' : {'value' : self.case_status_name_to_id(status)},
            }

            query = json.dumps({ 'caseDetail' : case_details})
            res = self.cmdquery(cmd, query)
            return res['value']

        def edit_case(self, case_id, summary, severity, status, assignee, organization):


            case = self.get_case_detail(case_id)

            if summary is not None:
                case['summary'] = summary

            if severity is not None:
                if severity < 1:
                    severity = 1
                elif severity > 100:
                    severity = 100
                case['severity'] = severity

            if status is not None:
                case['statusId'] = self.case_status_name_to_id(status)

            if assignee is not None:
                case['assignedTo'] = self.user_name_to_id(assignee)

            if organization is not None:
                case['orgId'] = self.organization_name_to_id(organization)

            cmd = 'caseEditCase'
            query = json.dumps({'caseDetail' : case})
            self.cmdquery(cmd, query, True)

            return

        def get_case_event_list(self, event_ids):


            event_ids = {'list' : event_ids}

            cmd = 'caseGetCaseEventsDetail'
            query = json.dumps({'eventIds' : event_ids})
            res = self.cmdquery(cmd, query)

            return res


    def alarms_to_entry(alarms):
        if not alarms:
                return "No alarms were found"

        context = { 'Alarm(val.ID && val.ID == obj.ID)': alarms }
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': alarms,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Result:' ,alarms),
            'EntryContext': context
        }

    def alarms_to_incidents(alarms):
        incidents = []
        for alarm in alarms:
            incidents.append({
                'name': alarm['summary'],
                'details': 'Alarm {} , ID : {} , was triggered by condition type: {}'.format(alarm['alarmName'], alarm['ID'], alarm['conditionType']),
                'severity': severity_to_level(alarm['severity']),
                'rawJSON': json.dumps(alarm)
            })
        return incidents

    def cases_to_entry(esm, title, cases):
        if not cases:
            return 'No cases were found'

        headers = ['ID', 'Summary', 'Status', 'Severity', 'OpenTime']
        fixed_cases = []
        context_cases = []

        for case in cases:
            fixed_case = {}
            fixed_case['ID'] = case['id']['value']
            fixed_case['Summary'] = case['summary']
            fixed_case['Status'] = esm.case_status_id_to_name(case['statusId']['value'])
            fixed_case['OpenTime'] = case['openTime']
            fixed_case['Severity'] = case['severity']

            if case.has_key('assignedTo'):
                fixed_case['Assignee'] = esm.user_id_to_name(case['assignedTo'])
                headers.append('Assignee')

            if case.has_key('orgId'):
                fixed_case['Organization'] = esm.organization_id_to_name(case['orgId'])
                headers.append('Organization')

            context_case = fixed_case.copy()
            if case.has_key('eventList'):
                fixed_case['Event List'] = json.dumps(case['eventList']).replace('|', '\|')
                context_case['EventList'] = case['eventList']
                headers.append('Event List')

            if case.has_key('notes'):
                fixed_case['Notes'] = json.dumps(case['notes']).replace('|', '\|')
                context_case['Notes'] = case['notes']
                headers.append('Notes')

            fixed_cases.append(fixed_case)
            context_cases.append(context_case)

        context = { 'Case(val.ID && val.ID == obj.ID)': context_cases }

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': cases,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd(title, fixed_cases, headers),
            'EntryContext': context
        }

    def cases_to_incidents(esm, cases):
        incidents = []
        for case in cases:
            incident = {
                'name' : case['summary'],
                'details' : 'Case %s with ID %s was triggerred' % (case['summary'], case['id']['value']),
                'severity' : severity_to_level(case['severity']),
                # 'status' : esm.case_status_id_to_name(case['statusId']['value']),
                'rawJSON' : json.dumps(case),
            }
            # if case.has_key('assignedTo'):
            #     incident['owner'] = esm.user_id_to_name(case['assignedTo'])
            incidents.append(incident)

        return incidents

    def case_statuses_to_entry(case_statuses):
        if not case_statuses:
            return 'No case statuses were found'

        headers = ['ID', 'Name', 'Is Default', 'Show In Case Pane']
        fixed_statuses = []
        for status in case_statuses:
            fixed_statuses.append({
                'ID' : status['id'],
                'Name' : status['name'],
                'Is Default' : status['default'],
                'Show In Case Pane' : status['showInCasePane']
            })

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_statuses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Result:', fixed_statuses, headers),
            'EntryContext': {}
        }

    def organizations_to_entry(organizations):
        if not organizations:
            return 'No organizations were found'

        headers = ['ID', 'Name']
        fixed_organizations = []
        for organization in organizations:
            fixed_organizations.append({
                'ID' : organization['id'],
                'Name' : organization['name'],
            })

        context = {'Organizations(val.ID && val.ID == obj.ID)' : fixed_organizations}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_organizations,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Organizations:', fixed_organizations, headers),
            'EntryContext': context
       }

    def case_events_to_entry(events):
        if not events:
            return 'No events were found'

        headers = ['ID', 'LastTime', 'Message']
        fixed_events = []
        for event in events:
            fixed_events.append({
                'ID' : event['id']['value'],
                'LastTime' : event['lastTime'],
                'Message' : event['message'],
            })

        context = {'CaseEvents(val.ID && val.ID == obj.ID)' : fixed_events}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_events,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Case Events:', fixed_events, headers),
            'EntryContext': context
       }


    def alarm_events_to_entry(events):
        headers = ['ID', 'SubType', 'Severity', 'Message', 'LastTime', 'SrcIP', 'SrcPort', 'DstIP', 'DstPort', ]
        fixed_events = []
        for raw_event in events:
            # there are two type of event objects representation:
            # 1) the result of esm-list-alarm-events
            # 2) the result of esm-get-alarm-event-details
            # therefore, first try to get the field of the first option and fallback to the second option.
            cases = [{
                'ID' : case['id'],
                'OpenTime' : case['openTime'],
                'Severity' : case['severity'],
                'Summary' : case['summary'],
                'Status' : esm.case_status_id_to_name(case['statusId']['value'])
            } for case in raw_event.get('cases', [])]
            event = {
                'ID' : raw_event.get('eventId', '%s|%s' % (raw_event.get('ipsId', ''), raw_event.get('alertId', ''))),
                'SubType' : raw_event.get('eventSubType', raw_event.get('subtype')),
                'Severity' : raw_event['severity'],
                'Cases' : cases,
                'Message' : raw_event.get('ruleMessage', raw_event.get('ruleName')),
                'NormalizedDescription' : raw_event.get('normDesc'),
                'FirstTime' : raw_event.get('firstTime'),
                'LastTime' : raw_event['lastTime'],

                'SrcMac' : raw_event.get('srcMac'),
                'SrcIP' : raw_event.get('sourceIp', raw_event.get('srcIp')),
                'SrcPort' : raw_event.get('srcPort'),
                'DstMac' : raw_event.get('destMac'),
                'DstIP' : raw_event['destIp'],
                'DstPort' : raw_event.get('destPort'),

                # 'Raw' : raw_event, # temporary for vik
            }

            fixed_events.append(event)

        context = {'EsmAlarmEvent(val.ID && val.ID == obj.ID)' : createContext(fixed_events, removeNull=True)}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_events,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Alarm Events:', fixed_events, headers=headers),
            'EntryContext': context
       }


    def users_to_entry(users):
        # unreachable code - in order to send command, one must be logged in. therefore there is at least one user.
        if not users:
            return 'No users were found'

        headers = ['ID', 'Name', 'Email', 'SMS', 'IsMaster', 'IsAdmin']
        fixed_users = []
        for user in users:
            fixed_users.append({
                'ID' : user['id']['value'],
                'Name' : user['username'],
                'Email' : user['email'],
                'SMS' : user['sms'],
                'IsMaster' : user['master'],
                'IsAdmin' : user['admin'],
            })

        context = {'EsmUser(val.ID && val.ID == obj.ID)' : fixed_users}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_users,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Users:', fixed_users, headers),
            'EntryContext': context
       }


    try:

        esm = NitroESM(ESM_URL, USERNAME, PASSWORD)
        esm.login()
        final_result = 'No result set'

        if demisto.command() == 'fetch-incidents':
            last_run = demisto.getLastRun()
            # for backward compatibility uses
            if last_run.has_key('value') and not last_run.has_key('alarms'):
                last_run['alarms'] = last_run['value']
            configuration_last_case = int(demisto.params()['startingCaseID'])

            start_alarms = last_run.get('alarms', (datetime.now() - timedelta(days=1) + timedelta(hours=TIMEZONE)).isoformat())
            last_case = last_run.get('cases', 0)
            # if last_case < configuration_last_case:
            last_case = max(last_case, configuration_last_case)

            incidents = []
            mode = demisto.params().get('fetchTypes', 'alarms').lower()  # alarms is default for backward compatability

            next_run = None
            if mode in ('alarms', 'both'):
                end = (datetime.now() + timedelta(hours=TIMEZONE)).isoformat()

                alarms = esm.fetch_alarms(
                    'CUSTOM',
                    start_alarms,
                    end,
                    ''
                )

                incidents = []
                for alarm in alarms:
                    triggered_date = alarm['triggeredDate']
                    if next_run is None or next_run < triggered_date:
                        next_run = triggered_date

                    incidents.append({
                        'name': alarm['summary'],
                        'details': 'Alarm {} , ID : {} , was triggered by condition type: {}'.format(alarm['alarmName'],
                                                                                                     alarm['ID'], alarm[
                                                                                                         'conditionType']),
                        'severity': severity_to_level(alarm['severity']),
                        'rawJSON': json.dumps(alarm)
                    })

            if mode in ('cases', 'both'):
                # esm.login()

                # get new cases
                cases = [case for case in esm.get_cases() if case['id']['value'] > last_case]
                cases.sort(cmp=lambda case1, case2: case1['id']['value'].__cmp__(case2['id']['value']))
                cases = cases[:MAX_CASES_PER_FETCH]

                if cases:
                    last_case = cases[-1]['id']['value']

                # update last run info
                last_run['cases'] = last_case

                demisto.info('adding %d more cases, last id is: %d' % (len(cases), last_run['cases'],))
                if cases:
                    incidents.extend(cases_to_incidents(esm, cases))


            if next_run is not None:
                next_run_datetime = datetime.strptime(next_run, '%Y/%m/%d %H:%M:%S')
                next_run = (next_run_datetime + timedelta(seconds=1)).isoformat()
            else:
                next_run = start_alarms

            last_run['value'] = next_run
            last_run['alarms'] = next_run
            demisto.setLastRun(last_run)
            demisto.incidents(incidents)
            sys.exit(0)


        elif demisto.command() == 'test-module':
            if VERSION not in ['10.0', '10.1', '10.2']:
                final_result = 'version must be one of 10.x, got %s' % (VERSION,)
            else:
                esm.fetchAllFields()
                final_result = 'ok'

        elif demisto.command() == 'esm-fetch-fields':
            res = esm.fetchAllFields()
            final_result = res

        elif demisto.command() == 'esm-search':
            args = demisto.args()
            res = esm.search(
                demisto.get(args, 'timeRange'),
                demisto.get(args, 'customStart'),
                demisto.get(args, 'customEnd'),
                json.loads(args.get('filters')),
                args.get('fields'),
                demisto.get(args, 'queryType') or 'EVENT',
                demisto.get(args, 'maxWait') or 30
            )
            final_result = res

        elif demisto.command() == 'esm-get-case-list':
            since_date_range = demisto.args().get('since')
            res = esm.get_cases(since_date_range)
            final_result = cases_to_entry(esm, 'All cases:', res)

        elif demisto.command() == 'esm-get-case-detail':
            args = demisto.args()
            case_id = int(demisto.get(args, 'id'))
            res = esm.get_case_detail(case_id)
            final_result = cases_to_entry(esm, 'Case %d:' % (case_id,), [res])

        elif demisto.command() == 'esm-add-case':
            args = demisto.args()
            res = esm.add_case(
                demisto.get(args, 'summary'),
                int(demisto.get(args, 'severity')),
                demisto.get(args, 'status'),
                demisto.get(args, 'assignee'),
                demisto.get(args, 'organization'),
            )
            case = esm.get_case_detail(res)
            final_result = cases_to_entry(esm, 'New Case:', [case])

        elif demisto.command() == 'esm-edit-case':
            args = demisto.args()
            case_id = int(demisto.get(args, 'id'))
            sevirity = demisto.get(args, 'severity')
            esm.edit_case(
                case_id,
                demisto.get(args, 'summary'),
                int(sevirity) if sevirity else None,
                demisto.get(args, 'status'),
                demisto.get(args, 'assignee'),
                demisto.get(args, 'organization'),
            )
            case = esm.get_case_detail(case_id)
            final_result = cases_to_entry(esm, 'Edited Case:', [case])

        elif demisto.command() == 'esm-get-case-statuses':
            res = esm.get_case_statuses()
            final_result = case_statuses_to_entry(res)

        elif demisto.command() == 'esm-add-case-status':
            args = demisto.args()
            res = esm.add_case_status(
                demisto.get(args, 'name'),
                bool(strtobool(demisto.get(args, 'show_in_case_pane'))),
            )
            final_result = res

        elif demisto.command() == 'esm-edit-case-status':
            args = demisto.args()
            should_show = demisto.get(args, 'show_in_case_pane')
            res = esm.edit_case_status(
                demisto.get(args, 'original_name'),
                demisto.get(args, 'new_name'),
                bool(strtobool(should_show)) if should_show else None,
            )
            final_result = res

        elif demisto.command() == 'esm-delete-case-status':
            args = demisto.args()
            res = esm.delete_case_status(
                demisto.get(args, 'name')
            )
            final_result = res

        elif demisto.command() == 'esm-get-case-event-list':
            args = demisto.args()
            event_ids = demisto.get(args, 'ids').split(',')
            res = esm.get_case_event_list(event_ids)
            final_result = case_events_to_entry(res)

        elif demisto.command() == 'esm-get-organization-list':
            res = esm.get_organizations()
            final_result = organizations_to_entry(res)

        elif demisto.command() == 'esm-get-user-list':
            res = esm.get_users()
            final_result = users_to_entry(res)

        elif demisto.command() == 'esm-fetch-alarms':
            args = demisto.args()
            res = esm.fetch_alarms(
                demisto.get(args, 'timeRange'),
                demisto.get(args, 'customStart'),
                demisto.get(args, 'customEnd'),
                demisto.get(args, 'assignedUser')
            )
            final_result = alarms_to_entry(res)

        elif demisto.command() == 'esm-acknowledge-alarms':
            args = demisto.args()
            res = esm.acknowledge_alarms(argToList(demisto.get(args, 'alarmIds')))
            final_result = res

        elif demisto.command() == 'esm-unacknowledge-alarms':
            args = demisto.args()
            res = esm.unacknowledge_alarms(argToList(demisto.get(args, 'alarmIds')))
            final_result = res

        elif demisto.command() == 'esm-delete-alarms':
            args = demisto.args()
            res = esm.delete_alarms(argToList(demisto.get(args, 'alarmIds')))
            final_result = res

        elif demisto.command() == 'esm-get-alarm-event-details':
            args = demisto.args()
            res = esm.get_alarm_event_details(demisto.get(args, 'eventId'))
            final_result = alarm_events_to_entry([res])

        elif demisto.command() == 'esm-list-alarm-events':
            args = demisto.args()
            res = esm.list_alarm_events(demisto.get(args, 'alarmId'))
            final_result = alarm_events_to_entry(res['events'])

    except Exception as ex:
        LOG(ex.message)
        return_error(ex.message)
    finally:
        esm.logout()
        demisto.results(final_result)
  type: python
  commands:
  - name: esm-fetch-fields
    arguments: []
    description: Get all fields that can be used in query filters, with type information
      for each field
  - name: esm-search
    arguments:
    - name: timeRange
      required: true
      auto: PREDEFINED
      predefined:
      - LAST_3_DAYS
      - LAST_2_DAYS
      - LAST_24_HOURS
      - PREVIOUS_DAY
      - CURRENT_DAY
      - LAST_HOUR
      - LAST_30_MINUTES
      - LAST_10_MINUTES
      - LAST_MINUTE
      - CUSTOM
      - PREVIOUS_YEAR
      - CURRENT_YEAR
      - PREVIOUS_QUARTER
      - CURRENT_QUARTER
      - PREVIOUS_MONTH
      - CURRENT_MONTH
      - PREVIOUS_WEEK
      - CURRENT_WEEK
      description: The time period for the search
    - name: filters
      required: true
      description: Filter on the query results, should be a json string, of the format
        EsmFilter (read more on that here - https://<esm-ip>:<esm-port>/rs/esm/help/types/EsmFilter)
    - name: queryType
      auto: PREDEFINED
      predefined:
      - EVENT
      - FLOW
      - ASSETS
      description: 'Query type to preform, by default EVENT (other possible values
        are : FLOW/ASSET)'
    - name: maxWait
      description: Maximum time to wait (in minutes), default is 30
    - name: customStart
      description: if timeRange is CUSTOM, start time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: customEnd
      description: if timeRange is CUSTOM, end time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: fields
      description: The fields that will be selected when this query is executed.
    description: Perform a query against Mcafee ESM SIEM
  - name: esm-fetch-alarms
    arguments:
    - name: timeRange
      required: true
      auto: PREDEFINED
      predefined:
      - LAST_3_DAYS
      - LAST_2_DAYS
      - LAST_24_HOURS
      - PREVIOUS_DAY
      - CURRENT_DAY
      - LAST_HOUR
      - LAST_30_MINUTES
      - LAST_10_MINUTES
      - LAST_MINUTE
      - CUSTOM
      - PREVIOUS_YEAR
      - CURRENT_YEAR
      - PREVIOUS_QUARTER
      - CURRENT_QUARTER
      - PREVIOUS_MONTH
      - CURRENT_MONTH
      - PREVIOUS_WEEK
      - CURRENT_WEEK
      description: The time period for the fetch
    - name: customStart
      description: if timeRange is CUSTOM, start time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: customEnd
      description: if timeRange is CUSTOM, end time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: assignedUser
      auto: PREDEFINED
      predefined:
      - ME
      - ""
      description: 'user assigned to handle this triggered alarm (use ''ME'' option
        to use instance user, or use format EsmUser (read more on that here - https://<esm-ip>:<esm-port>/rs/esm/help/types/EsmUser) '
    outputs:
    - contextPath: Alarm.ID
      description: Alarm ID
    - contextPath: Alarm.summary
      description: Alarm summary
    - contextPath: Alarm.assignee
      description: Alarm assignee
    - contextPath: Alarm.severity
      description: Alarm severity
    - contextPath: Alarm.triggeredDate
      description: Alarm triggered date
    - contextPath: Alarm.acknowledgedDate
      description: Alarm acknowledged date
    - contextPath: Alarm.acknowledgedUsername
      description: Alarm acknowledged username
    - contextPath: Alarm.alarmName
      description: Alarm name
    - contextPath: Alarm.conditionType
      description: Alarm condition type
    description: Retrieves a list of alarms that have been triggered
  - name: esm-get-case-list
    arguments:
    - name: since
      description: Filter for a case opened before this date. Given in format "<number>         <time
        unit>",e.g. 1 day,30 minutes,2 weeks,6 months,1 year
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Get a list of cases from the system
  - name: esm-add-case
    arguments:
    - name: summary
      required: true
      default: true
      description: the name of the case
    - name: status
      description: the status of the case (use `esm-get-case-statuses` to view all
        statuses)
      defaultValue: Open
    - name: assignee
      description: who the case is assigned to
      defaultValue: me
    - name: severity
      description: the severity of the case (1 - 100)
      defaultValue: "1"
    - name: organization
      description: the organization assigned to the case  (use `esm-get-organization-list`
        to view all ogranizations)
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Add a case to the system
  - name: esm-edit-case
    arguments:
    - name: id
      required: true
      default: true
      description: the id of the case
    - name: summary
      description: the name of the case
    - name: severity
      description: the new severity of the case (1 - 100)
    - name: assignee
      description: who the case should be assigned to
    - name: status
      description: the new status of the case (use `esm-get-case-statuses` to view
        all statuses)
    - name: organization
      description: the organization assigned to the case  (use `esm-get-organization-list`
        to view all ogranizations)
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Edit an existing case
  - name: esm-get-case-statuses
    arguments: []
    description: Get a list of valid case statuses from the system
  - name: esm-edit-case-status
    arguments:
    - name: original_name
      required: true
      default: true
      description: the name of the case status to edit
    - name: new_name
      required: true
      description: the new name for the case status
    - name: show_in_case_pane
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: whether the status be shown in case pane
    description: Edit a case status
  - name: esm-get-case-detail
    arguments:
    - name: id
      required: true
      default: true
      description: the ID of the case
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Get detail on an existing case
  - name: esm-get-case-event-list
    arguments:
    - name: ids
      required: true
      description: Comma separated  list of event IDs
    outputs:
    - contextPath: CaseEvents.ID
      description: The ID of the event
    - contextPath: CaseEvents.LastTime
      description: The last updated time of the event
    - contextPath: CaseEvents.Message
      description: The massage of the event
    description: Get case events details
  - name: esm-add-case-status
    arguments:
    - name: name
      required: true
      default: true
      description: the name of the case status
    - name: show_in_case_pane
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: whether the status be shown in case pane
      defaultValue: "True"
    description: Add a case status
  - name: esm-delete-case-status
    arguments:
    - name: name
      required: true
      default: true
      description: the name of the case status to delete
    description: Delete a case status
  - name: esm-get-organization-list
    arguments: []
    description: Get case organization
  - name: esm-get-user-list
    arguments: []
    outputs:
    - contextPath: EsmUser.ID
      description: the ID of the user
    - contextPath: EsmUser.Name
      description: the esm user name
    - contextPath: EsmUser.Email
      description: the e-mail of the user
    - contextPath: EsmUser.SMS
      description: the SMS details of the user
    - contextPath: EsmUser.IsMaster
      description: whether the user is a master user
    - contextPath: EsmUser.IsAdmin
      description: whether the user is an admin
    description: Get a list of all users.
  - name: esm-acknowledge-alarms
    arguments:
    - name: alarmIds
      required: true
      default: true
      description: list of triggered alarm ids to be marked acknowledged separated
        with commas
      isArray: true
    description: Mark triggered alarms as acknowledged
  - name: esm-unacknowledge-alarms
    arguments:
    - name: alarmIds
      required: true
      default: true
      description: list of triggered alarm ids to be marked unacknowledged separated
        with commas
      isArray: true
    description: Mark triggered alarms as unacknowledged
  - name: esm-delete-alarms
    arguments:
    - name: alarmIds
      required: true
      default: true
      description: list of triggered alarm ids to be deleted separated with commas
      isArray: true
    description: Delete triggered alarms
  - name: esm-get-alarm-event-details
    arguments:
    - name: eventId
      required: true
      default: true
      description: The event to get the details for. the ID can be taken from esm-get-alarm-event.
    outputs:
    - contextPath: EsmAlarmEvent.ID
      description: Event ID
      type: string
    - contextPath: EsmAlarmEvent.SubType
      description: Event Type
      type: string
    - contextPath: EsmAlarmEvent.Severity
      description: Event Severity
      type: number
    - contextPath: EsmAlarmEvent.Message
      description: Event Message
      type: string
    - contextPath: EsmAlarmEvent.LastTime
      description: Event Time
      type: date
    - contextPath: EsmAlarmEvent.SrcIP
      description: Source IP of the event
      type: string
    - contextPath: EsmAlarmEvent.DstIP
      description: Destination IP of the event
      type: string
    - contextPath: EsmAlarmEvent.Cases
      description: A list of related cases to the event
    - contextPath: EsmAlarmEvent.Cases.ID
      description: Case ID
      type: string
    - contextPath: EsmAlarmEvent.Cases.OpenTime
      description: Case creation time
      type: date
    - contextPath: EsmAlarmEvent.Cases.Severity
      description: Case severity
      type: number
    - contextPath: EsmAlarmEvent.Cases.Status
      description: Case status
      type: string
    - contextPath: EsmAlarmEvent.Cases.Summary
      description: Case summary
      type: string
    - contextPath: EsmAlarmEvent.DstMac
      description: Destination MAC of the event
      type: string
    - contextPath: EsmAlarmEvent.SrcMac
      description: Source MAC of the event
      type: string
    - contextPath: EsmAlarmEvent.DstPort
      description: Destination port of the event
      type: string
    - contextPath: EsmAlarmEvent.SrcPort
      description: Source port of the event
      type: string
    - contextPath: EsmAlarmEvent.FirstTime
      description: The first time for the event
      type: date
    - contextPath: EsmAlarmEvent.NormalizedDescription
      description: Normalized description of the event
      type: string
    description: Gets the details for the triggered alarm
  - name: esm-list-alarm-events
    arguments:
    - name: alarmId
      required: true
      default: true
      description: The alarm to get the details for. the ID can be taken from the
        esm-fetch-alarms
    outputs:
    - contextPath: EsmAlarmEvent.ID
      description: Event ID
      type: string
    - contextPath: EsmAlarmEvent.SubType
      description: Event Type
      type: string
    - contextPath: EsmAlarmEvent.Severity
      description: Event Severity
      type: number
    - contextPath: EsmAlarmEvent.Message
      description: Event Message
      type: string
    - contextPath: EsmAlarmEvent.LastTime
      description: Event Time
      type: date
    - contextPath: EsmAlarmEvent.SrcIP
      description: Source IP of the event
      type: string
    - contextPath: EsmAlarmEvent.DstIP
      description: Destination IP of the event
      type: string
    - contextPath: EsmAlarmEvent.Cases
      description: A list of related cases to the event
    - contextPath: EsmAlarmEvent.Cases.ID
      description: Case ID
      type: string
    - contextPath: EsmAlarmEvent.Cases.OpenTime
      description: Case creation time
      type: date
    - contextPath: EsmAlarmEvent.Cases.Severity
      description: Case severity
      type: number
    - contextPath: EsmAlarmEvent.Cases.Status
      description: Case status
      type: string
    - contextPath: EsmAlarmEvent.Cases.Summary
      description: Case summary
      type: string
    description: Gets an event list related to the alarm
  isfetch: true
  runonce: false
releaseNotes: "Fetch incidents fixed. ESM Timezone now supported. esm-get-cases-list now support filtering by time range"