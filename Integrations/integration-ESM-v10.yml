commonfields:
  id: McAfee ESM-v10
  version: -1
name: McAfee ESM-v10
display: McAfee ESM-v10
category: Analytics & SIEM
image: data:image/png;base64,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
description: Run queries and receive alarms from Intel Security ESM
configuration:
- display: Port
  name: port
  defaultvalue: "443"
  type: 0
  required: true
- display: ESM IP (e.g. 78.125.0.209)
  name: ip
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: 'Fetch Types: cases, alarms, both (relevant only for fetch incident mode)'
  name: fetchTypes
  defaultvalue: alarms
  type: 0
  required: false
- display: 'Start fetch after Case ID: (relevant only for fetch incident mode)'
  name: startingCaseID
  defaultvalue: "0"
  type: 0
  required: false
- display: Do not validate server certificate (insecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: 'Version: (one of 10.0, 10.1, 10.2)'
  name: version
  defaultvalue: "10.2"
  type: 0
  required: true
script:
  script: |-
    import base64
    import json
    import re
    import sys
    import requests
    import time
    import datetime
    from distutils.util import strtobool

    # global for ignoring errors in fetch incident
    should_stop_on_error = True
    max_cases_per_fetch = 30

    # by default filters only "Closed" cases
    filtered_out_statuses = [2, ]
    verify =  demisto.params()['insecure'] == False
    requests.packages.urllib3.disable_warnings()
    VERSION = demisto.params()['version']


    def throw_error(error_str):
        if should_stop_on_error:
            demisto.results({ 'Type' : entryTypes['error'], 'ContentsFormat' : 'text', 'Contents' : error_str })
            sys.exit(0)
        else:
            demisto.error(error_str)

    def search_result_to_md(res):
        columns = res['columns']
        rows = res['rows']

        md = "### results:\n"

        if(len(rows) == 0):
            return md + "No matching search result were found"

        # headers
        columnNames = list(map(lambda column: column['name'], columns))
        md = md + ' | '.join(columnNames) + '\n'
        md = md + ' | '.join(list(map(lambda column: "---", columns))) + '\n'

        # body
        for row in rows:
            md = md + ' | '.join(r.replace('|', '\\|') for r in row['values']) + '\n'

        return md
    def search_results_to_context(res):
        columns = res['columns']
        rows = res['rows']
        fixed_searches = []
        for row in rows:
            values = row['values']
            i = 0
            for column in columns:
                if (len(values[i]) != 0):
                    column_string = column['name'].replace(".", "")
                    column_string = column_string.replace(")", "")
                    column_string = column_string.replace("(", "")
                    fixed_searches.append({
                    column_string : values[i]
                    })
                i += 1
        context = {'SearchResults(val.ID && val.ID == obj.ID)' : fixed_searches}
        return context

    def severity_to_level(severity):
        if severity > 65:
            return 3
        elif severity > 32:
            return 2
        else:
            return 1

    class NitroESM(object):

        def __init__(self, esmhost, user, passwd):
            """ Init instance attributes """
            self.esmhost = esmhost
            self.user = user
            self.passwd = passwd
            self._build_login_urls()
            self._encode_login()
            self._build_params()
            self.is_logged_in = False

        def _build_login_urls(self):
            """ Concatenate URLs """
            self.url = 'https://{}/rs/esm/'.format(self.esmhost)
            self.int_url = 'https://{}/ess'.format(self.esmhost)
            self.login_url = '{}{}'.format(self.url, 'login')

        def _encode_login(self):
            self.b64_user = base64.b64encode(self.user.encode('utf-8')).decode()
            self.b64_passwd = base64.b64encode(self.passwd.encode('utf-8')).decode()

        def _build_params(self):
                self.params = {"username": self.b64_user,
                               "password": self.b64_passwd,
                               "locale": "en_US",
                               "os" : "Win32"
                               }
                try:
                    self.params_json = json.dumps(self.params)
                except TypeError as e:
                    throw_error("Invalid parameters: {}".format(self.params))

        def login(self):
            try:
                authString = base64.encodestring('%s:%s' % (self.user, self.passwd)).strip()
                self.v10_login_headers = {'Content-Type': 'application/json'}
                self.login_response = requests.post(self.login_url,
                                                     self.params_json,
                                                     headers=self.v10_login_headers,
                                                     verify=verify)
                self.cookie = self.login_response.headers.get('Set-Cookie')
                try:
                    self.jwttoken = re.search('(^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*)', self.cookie).group(1)
                except TypeError as e:
                    throw_error("Failed login\nurl: {}\n response status: {}\nresponse: {}\n".format(self.login_url,
                                    self.login_response.status_code, self.login_response.text))
                self.xsrf_token = self.login_response.headers.get('Xsrf-Token')
                self.session_headers = {'Cookie' : self.jwttoken,
                                        'X-Xsrf-Token' : self.xsrf_token,
                                        'Content-Type': 'application/json'}
                self.is_logged_in = True
            except KeyError as e:
                throw_error("Failed login\n error: {}".format(e))

        def logout(self):
            if self.is_logged_in:
                try:
                    headers = {'Cookie' : self.cookie}
                    requests.post(self.url + 'userLogout',
                        headers=self.session_headers,
                        # headers=headers,
                        data=json.dumps(''),
                        verify=verify
                        )
                    self.is_logged_in = False
                except Exception as e:
                    demisto.error('McAfee ESM logout failed with the following error: %s' % (str(e), ))

        def cmdquery(self, cmd, query=None, no_answer=False, no_validation=False):
            """ Send query to ESM, return JSON result """
            self.cmd = cmd
            self.query = query
            self.url = 'https://{}/rs/esm/'.format(self.esmhost)
            self.result = requests.post(self.url + self.cmd,
                                        headers=self.session_headers,
                                        data=self.query, verify=verify)
            if not no_validation:
                if no_answer:
                    if self.result.status_code != 200:
                        throw_error('Error - ESM replied with:\n - status code: {} \n - body: {}'.format(self.result.status_code, self.result.text))
                else:
                    try:
                        res = self.result.json()
                        if VERSION != '10.0' and not cmd.startswith('v2'):
                            res = res['return']
                        return res
                    except:
                        throw_error('Error - ESM replied with:\n - status code: {} \n - body: {}'.format(self.result.status_code, self.result.text))

        def execute_query(self, time_range, custom_start, custom_end, filters, fields, query_type):
            if (time_range == 'CUSTOM' and (not custom_start or not custom_end)):
                throw_error('you must specify customStart and customEnd when timeRange is CUSTOM')

            cmd = '%sqryExecuteDetail?reverse=false&type=%s' % ('v2/' if VERSION=='10.2' else '', query_type, )

            if (time_range == 'CUSTOM'):
               cmd = cmd + '&customStart=' + custom_start + '&customEnd=' + custom_end

            q = {
                'config': {
                    'timeRange': time_range,
                    'filters': filters,
                }
            }
            if fields is not None:
                q['config']['fields'] = [{'name':v} for v in argToList(fields)]
            query = json.dumps(q)

            res = self.cmdquery(cmd, query)
            return res['resultID']

        def get_query_result(self, resultID):
            cmd = '%sqryGetStatus' % ('v2/' if VERSION=='10.2' else '', )
            query = json.dumps({ 'resultID': resultID })

            res = self.cmdquery(cmd, query)
            return res['complete']

        def wait_for_results(self, resultID, max_wait):

            # initial back off, sleep 3 sec between each time
            for i in range(5):
                ready = self.get_query_result(resultID)
                if ready:
                    return
                else:
                    time.sleep(3)

            # wait for response - 1 min between each try
            for i in range(max_wait):
                ready = self.get_query_result(resultID)
                if ready:
                    return
                else:
                    time.sleep(60)

            throw_error('Waited more {} min for query results : {}'.format(max_wait, resultID))

        def fetch_results(self, resultID):
            cmd = '%sqryGetResults?startPos=0&reverse=false&numRows=10000' % ('v2/' if VERSION=='10.2' else '', )

            query = json.dumps({ 'resultID': resultID })

            res = self.cmdquery(cmd, query)
            return res

        def search(self, time_range, custom_start, custom_end, filters, fields, query_type, max_wait):
            self.login()
            # execute command
            resultID = self.execute_query(time_range, custom_start, custom_end, filters, fields, query_type)

            # wait for result to be ready
            self.wait_for_results(resultID, max_wait)

            #fetch result
            res = self.fetch_results(resultID)

            table = search_result_to_md(res)
            context = search_results_to_context(res)

            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': res,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': table,
                'EntryContext': context
            }

        def fetchAllFields(self):
            self.login()
            res = self.cmdquery('%sqryGetFilterFields' % ('v2/' if VERSION=='10.2' else '', ))

            # convert to an appropriate table
            for x in res:
                x['types'] = ','.join(x['types'])

            return {
                'ContentsFormat': formats['json'],
                'Type': entryTypes['note'],
                'Contents': res,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tblToMd('Result:' ,res),
            }

        # alarms commands
        def fetch_alarms(self, time_range, custom_start, custom_end, assigned_user):
            if (time_range == 'CUSTOM' and (not custom_start or not custom_end)):
                throw_error('you must specify customStart and customEnd when timeRange is CUSTOM')

            self.login()

            cmd = 'alarmGetTriggeredAlarmsPaged?pageSize=500&pageNumber=1&triggeredTimeRange=' + time_range
            if (time_range == 'CUSTOM'):
               cmd = cmd + '&customStart=' + custom_start + '&customEnd=' + custom_end

            query = ''
            if (assigned_user == 'ME'):
                user = self.get_user_obj(self.user)
                query = json.dumps({ 'assignedUser' : user})
            elif assigned_user:
                query = json.dumps({ 'assignedUser' : self.get_user_obj(assigned_user)})

            res = self.cmdquery(cmd, query)

            for alarm in res:
                alarm['ID'] = alarm['id']['value']
                del alarm["id"]

            return res
        def update_alarms_status(self, alarm_ids):
            cmd = 'alarm%(action)sTriggeredAlarm' % (action, )
            query = json.dumps({'triggeredIds' : [{'value' : int(i)} for i in alarm_ids]})

            self.login()

            # the command return an error for a list of alarm ids however is execute the update successfully.
            self.cmdquery(cmd, query, no_validation=True)
            return 'Alarms has been %sd.' % (action, )

        def acknowledge_alarms(self, alarm_ids):
            return self.update_alarms_status('Acknowledge', alarm_ids)

        def unacknowledge_alarms(self, alarm_ids):
            return self.update_alarms_status('Unacknowledge', alarm_ids)

        def delete_alarms(self, alarm_ids):
            return self.update_alarms_status('Delete', alarm_ids)

        # case statuses commands
        def add_case_status(self, name, should_show_in_case_pane):
            '''add a new type of case status with given parameters'''
            self.login()
            status_details = {
                'name' : name,
                'default' : False,
                'showInCasePane' : should_show_in_case_pane
            }

            cmd = 'caseAddCaseStatus'
            query = json.dumps({'status' : status_details})
            self.cmdquery(cmd, query)
            return 'Added case status : %s' % (name, )

        def edit_case_status(self, original_name, new_name, show_in_case_pane):
            '''edit a  case status with given id'''
            self.login()

            status_id = self.case_status_name_to_id(original_name)
            status_details = {
                'id' : status_id,
                'name': new_name
            }

            if show_in_case_pane is not None:
                status_details['showInCasePane'] = show_in_case_pane

            cmd = 'caseEditCaseStatus'
            query = json.dumps({'status' : status_details})
            self.cmdquery(cmd, query, no_answer=True)

            return 'Edit case status with ID: %d' % (status_id, )

        def delete_case_status(self, name):
            '''delete a new type of case status with given name'''
            self.login()
            status_id = self.case_status_name_to_id(name)
            status_id = {'value' : status_id}

            cmd = 'caseDeleteCaseStatus'
            query = json.dumps({'statusId' : status_id})
            self.cmdquery(cmd, query, no_answer=True)

            return 'Deleted case status with ID: %d' % (status_id['value'], )

        def get_case_statuses(self, should_login = False):
            '''get all case statuses'''
            if should_login:
                self.login()

            cmd = 'caseGetCaseStatusList'
            query = json.dumps({"authPW": {"value": self.passwd}})
            return self.cmdquery(cmd, query)

        def case_status_id_to_name(self, status_id):
            '''convert case status id to name'''
            res = self.get_case_statuses()
            matches = [status['name'] for status in res if status['id'] == status_id]
            return matches[0] if matches else 'Unknown - %d' % (status_id, )

        def case_status_name_to_id(self, status_name):
            '''convert case status name to id'''
            res = self.get_case_statuses()
            matches = [status['id'] for status in res if status['name'].lower() == status_name.lower()]
            return matches[0] if matches else 0 # 0 is not a valid value

        # user commands
        def get_users(self, should_login = False):
            '''get all user's names'''
            if should_login:
                self.login()

            cmd = 'userGetUserList'
            query = json.dumps({"authPW": {"value": self.passwd}})
            return self.cmdquery(cmd, query)

        def get_user_obj(self, user_name):
            '''get user object'''
            if user_name.lower() == 'me':
                user_name = self.user
            res = self.get_users()
            matches = [user for user in res if user['username'] == user_name]
            self_matches = [user['id']['value'] for user in res if user['username'] == self.user]

            # the login user must appear in the user list
            return matches[0] if matches else self_matches[0]

        def user_name_to_id(self, user_name):
            '''convert user name to id'''
            if user_name is None or user_name.lower() == 'me':
                user_name = self.user
            res = self.get_users()
            matches = [user['id']['value'] for user in res if user['username'] == user_name]
            self_matches = [user['id']['value'] for user in res if user['username'] == self.user]

            # the login user must appear in the user list
            return matches[0] if matches else self_matches[0]

        def user_id_to_name(self, user_id):
            '''convert user id to name'''
            res = self.get_users()
            matches = [user['username'] for user in res if user['id']['value'] == user_id]

            return matches[0] if matches else self.user

        # organization commands
        def get_organizations(self, should_login = False):
            '''get all organization names'''
            if should_login:
                self.login()

            cmd = 'caseGetOrganizationList'
            return self.cmdquery(cmd, '')

        def organization_name_to_id(self, organization_name):
            '''convert organization name to id'''
            if organization_name is None:
                organization_name = ''
            res = self.get_organizations()
            matches = [org['id'] for org in res if org['name'].lower() == organization_name.lower()]

            return matches[0] if matches else 1

        def organization_id_to_name(self, organization_id):
            '''convert organization name to id'''
            res = self.get_organizations()
            matches = [org['name'] for org in res if org['id'] == organization_id]

            return matches[0] if matches else 'None'

        # cases commands
        def get_cases(self):
            '''get all cases associated with current user'''
            self.login()
            cmd = 'caseGetCaseList'
            res = self.cmdquery(cmd)

            return res

        def get_case_detail(self, case_id, should_login=False):
            if should_login:
                self.login()

            cmd = 'caseGetCaseDetail'
            case_id = {'id' : {'value' : case_id}}
            query = json.dumps(case_id)
            res = self.cmdquery(cmd, query)

            return res

        def add_case(self, summary, severity, status, assignee, organization):
            self.login()

            if severity < 1:
                severity = 1
            elif severity > 100:
                severity = 100

            if status is None:
                status = 'Open'

            assignee = self.user_name_to_id(assignee)
            org_id = self.organization_name_to_id(organization)

            cmd = 'caseAddCase'
            case_details = {
                'summary' : summary,
                'assignedTo' : assignee,
                'severity' : severity,
                'orgId' : org_id,
                'statusId' : {'value' : self.case_status_name_to_id(status)},
            }

            query = json.dumps({ 'caseDetail' : case_details})
            res = self.cmdquery(cmd, query)
            return res['value']

        def edit_case(self, case_id, summary, severity, status, assignee, organization):
            self.login()

            case = self.get_case_detail(case_id)

            if summary is not None:
                case['summary'] = summary

            if severity is not None:
                if severity < 1:
                    severity = 1
                elif severity > 100:
                    severity = 100
                case['severity'] = severity

            if status is not None:
                case['statusId'] = self.case_status_name_to_id(status)

            if assignee is not None:
                case['assignedTo'] = self.user_name_to_id(assignee)

            if organization is not None:
                case['orgId'] = self.organization_name_to_id(organization)

            cmd = 'caseEditCase'
            query = json.dumps({'caseDetail' : case})
            self.cmdquery(cmd, query, True)

            return

        def get_case_event_list(self, event_ids):
            self.login()

            event_ids = {'list' : event_ids}

            cmd = 'caseGetCaseEventsDetail'
            query = json.dumps({'eventIds' : event_ids})
            res = self.cmdquery(cmd, query)

            return res


    def alarms_to_entry(alarms):
        if not alarms:
                return "No alarms were found"

        context = { 'Alarm(val.ID && val.ID == obj.ID)': alarms }
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': alarms,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Result:' ,alarms),
            'EntryContext': context
        }

    def alarms_to_incidents(alarms):
        incidents = []
        for alarm in alarms:
            incidents.append({
                'name': alarm['summary'],
                'details': 'Alarm {} , ID : {} , was triggered by condition type: {}'.format(alarm['alarmName'], alarm['ID'], alarm['conditionType']),
                'severity': severity_to_level(alarm['severity']),
                'rawJSON': json.dumps(alarm)
            })
        return incidents

    def cases_to_entry(esm, title, cases):
        if not cases:
            return 'No cases were found'

        headers = ['ID', 'Summary', 'Status', 'Severity', 'Open Time']
        fixed_cases = []
        context_cases = []
        for case in cases:
            fixed_case = {}
            fixed_case['ID'] = case['id']['value']
            fixed_case['Summary'] = case['summary']
            fixed_case['Status'] = esm.case_status_id_to_name(case['statusId']['value'])
            fixed_case['OpenTime'] = case['openTime']
            fixed_case['Severity'] = case['severity']

            if case.has_key('assignedTo'):
                fixed_case['Assignee'] = esm.user_id_to_name(case['assignedTo'])
                headers.append('Assignee')

            if case.has_key('orgId'):
                fixed_case['Organization'] = esm.organization_id_to_name(case['orgId'])
                headers.append('Organization')

            context_case = fixed_case.copy()
            if case.has_key('eventList'):
                fixed_case['Event List'] = json.dumps(case['eventList']).replace('|', '\|')
                context_case['EventList'] = case['eventList']
                headers.append('Event List')

            if case.has_key('notes'):
                fixed_case['Notes'] = json.dumps(case['notes']).replace('|', '\|')
                context_case['Notes'] = case['notes']
                headers.append('Notes')

            fixed_cases.append(fixed_case)
            context_cases.append(context_case)

        context = { 'Case(val.ID && val.ID == obj.ID)': context_cases }
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': cases,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd(title, fixed_cases, headers),
            'EntryContext': context
        }

    def cases_to_incidents(esm, cases):
        incidents = []
        for case in cases:
            incident = {
                'name' : case['summary'],
                'details' : 'Case %s with ID %s was triggerred' % (case['summary'], case['id']['value']),
                'severity' : severity_to_level(case['severity']),
                # 'status' : esm.case_status_id_to_name(case['statusId']['value']),
                'rawJSON' : json.dumps(case),
            }
            # if case.has_key('assignedTo'):
            #     incident['owner'] = esm.user_id_to_name(case['assignedTo'])
            incidents.append(incident)

        return incidents

    def case_statuses_to_entry(case_statuses):
        if not case_statuses:
            return 'No case statuses were found'

        headers = ['ID', 'Name', 'Is Default', 'Show In Case Pane']
        fixed_statuses = []
        for status in case_statuses:
            fixed_statuses.append({
                'ID' : status['id'],
                'Name' : status['name'],
                'Is Default' : status['default'],
                'Show In Case Pane' : status['showInCasePane']
            })

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_statuses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Result:', fixed_statuses, headers),
            'EntryContext': {}
        }

    def organizations_to_entry(organizations):
        if not organizations:
            return 'No organizations were found'

        headers = ['ID', 'Name']
        fixed_organizations = []
        for organization in organizations:
            fixed_organizations.append({
                'ID' : organization['id'],
                'Name' : organization['name'],
            })

        context = {'Organizations(val.ID && val.ID == obj.ID)' : fixed_organizations}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_organizations,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Organizations:', fixed_organizations, headers),
            'EntryContext': context
       }

    def events_to_entry(events):
        if not events:
            return 'No events were found'

        headers = ['ID', 'LastTime', 'Message']
        fixed_events = []
        for event in events:
            fixed_events.append({
                'ID' : event['id']['value'].replace('|', '\|'),
                'LastTime' : event['lastTime'],
                'Message' : event['message'],
            })

        context = {'CaseEvents(val.ID && val.ID == obj.ID)' : fixed_events}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_events,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Case Events:', fixed_events, headers),
            'EntryContext': context
       }

    def users_to_entry(users):
        # unreachable code - in order to send command, one must be logged in. therefore there is at least one user.
        if not users:
            return 'No users were found'

        headers = ['ID', 'Name', 'Email', 'SMS', 'IsMaster', 'IsAdmin']
        fixed_users = []
        for user in users:
            fixed_users.append({
                'ID' : user['id']['value'],
                'Name' : user['username'],
                'Email' : user['email'],
                'SMS' : user['sms'],
                'IsMaster' : user['master'],
                'IsAdmin' : user['admin'],
            })

        context = {'EsmUser(val.ID && val.ID == obj.ID)' : fixed_users}
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': fixed_users,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tblToMd('Users:', fixed_users, headers),
            'EntryContext': context
       }

    esm = NitroESM(demisto.params()['ip'] + ':' + demisto.params()['port'], demisto.params()['credentials']['identifier'],
        demisto.params()['credentials']['password'])
    final_result = 'No result set'

    if demisto.command() == 'fetch-incidents':
        last_run = demisto.getLastRun()
        # for backward compatibility uses
        if last_run.has_key('value') and not last_run.has_key('alarms'):
            last_run['alarms'] = last_run['value']
        configuration_last_case = int(demisto.params()['startingCaseID'])

        start_alarms = last_run.get('alarms', (datetime.datetime.now() - datetime.timedelta(minutes=1)).isoformat())
        last_case = last_run.get('cases', 0)
        # if last_case < configuration_last_case:
        last_case = max(last_case, configuration_last_case)

        incidents = []
        mode = demisto.params().get('fetchTypes', 'alarms').lower() # alarms is default for backward compatability

        if mode in ('alarms', 'both'):
            end = datetime.datetime.now().isoformat()
            last_run['value'] = end
            last_run['alarms'] = end

            res = esm.fetch_alarms(
                'CUSTOM',
                start_alarms,
                end,
                ''
            )
            esm.logout()
            incidents.extend(alarms_to_incidents(res))

        if mode in ('cases', 'both'):
            esm.login()

            # get new cases
            cases = [case for case in esm.get_cases() if case['id']['value'] > last_case]
            cases.sort(cmp=lambda case1,case2: case1['id']['value'].__cmp__(case2['id']['value']))
            cases = cases[:max_cases_per_fetch]

            if cases:
                last_case = cases[-1]['id']['value']

            esm.logout()
            # update last run info
            last_run['cases'] = last_case

            demisto.info('adding %d more cases, last id is: %d' % (len(cases), last_run['cases'], ))
            if cases:
                incidents.extend(cases_to_incidents(esm, cases))

        demisto.setLastRun(last_run)
        demisto.incidents(incidents)
        sys.exit(0)


    elif demisto.command() == 'test-module':
        if VERSION not in ['10.0', '10.1', '10.2']:
            final_result = 'version must be one of 10.x, got %s' % (VERSION, )
        else:
            esm.fetchAllFields()
            final_result = 'ok'

    elif demisto.command() == 'esm-fetch-fields':
        res = esm.fetchAllFields()
        final_result = res

    elif demisto.command() == 'esm-search':
        args = demisto.args()
        res = esm.search(
            demisto.get(args, 'timeRange'),
            demisto.get(args, 'customStart'),
            demisto.get(args, 'customEnd'),
            json.loads(args.get('filters')),
            args.get('fields'),
            demisto.get(args, 'queryType') or 'EVENT',
            demisto.get(args, 'maxWait') or 30
            )
        final_result = res

    elif demisto.command() == 'esm-get-case-list':
        res = esm.get_cases()
        final_result = cases_to_entry(esm, 'All cases:', res)

    elif demisto.command() == 'esm-get-case-detail':
        args = demisto.args()
        case_id = int(demisto.get(args, 'id'))
        res = esm.get_case_detail(case_id, True)
        final_result = cases_to_entry(esm, 'Case %d:' % (case_id, ), [res])

    elif demisto.command() == 'esm-add-case':
        args = demisto.args()
        res = esm.add_case(
            demisto.get(args, 'summary'),
            int(demisto.get(args, 'severity')),
            demisto.get(args, 'status'),
            demisto.get(args, 'assignee'),
            demisto.get(args, 'organization'),
            )
        case = esm.get_case_detail(res)
        final_result = cases_to_entry(esm, 'New Case:', [case])

    elif demisto.command() == 'esm-edit-case':
        args = demisto.args()
        case_id = int(demisto.get(args, 'id'))
        sevirity = demisto.get(args, 'severity')
        esm.edit_case(
            case_id,
            demisto.get(args, 'summary'),
            int(sevirity) if sevirity else None,
            demisto.get(args, 'status'),
            demisto.get(args, 'assignee'),
            demisto.get(args, 'organization'),
            )
        case = esm.get_case_detail(case_id)
        final_result = cases_to_entry(esm, 'Edited Case:', [case])

    elif demisto.command() == 'esm-get-case-statuses':
        res = esm.get_case_statuses(True)
        final_result = case_statuses_to_entry(res)

    elif demisto.command() == 'esm-add-case-status':
        args = demisto.args()
        res = esm.add_case_status(
            demisto.get(args, 'name'),
            bool(strtobool(demisto.get(args, 'show_in_case_pane'))),
            )
        final_result = res

    elif demisto.command() == 'esm-edit-case-status':
        args = demisto.args()
        should_show = demisto.get(args, 'show_in_case_pane')
        res = esm.edit_case_status(
            demisto.get(args, 'original_name'),
            demisto.get(args, 'new_name'),
            bool(strtobool(should_show)) if should_show else None,
            )
        final_result = res

    elif demisto.command() == 'esm-delete-case-status':
        args = demisto.args()
        res = esm.delete_case_status(
            demisto.get(args, 'name')
        )
        final_result = res

    elif demisto.command() == 'esm-get-case-event-list':
        args = demisto.args()
        event_ids = demisto.get(args, 'ids').split(',')
        res = esm.get_case_event_list(event_ids)
        final_result = events_to_entry(res)

    elif demisto.command() == 'esm-get-organization-list':
        res = esm.get_organizations(True)
        final_result = organizations_to_entry(res)

    elif demisto.command() == 'esm-get-user-list':
        res = esm.get_users(True)
        final_result = users_to_entry(res)

    elif demisto.command() == 'esm-fetch-alarms':
        args = demisto.args()
        res = esm.fetch_alarms(
            demisto.get(args, 'timeRange'),
            demisto.get(args, 'customStart'),
            demisto.get(args, 'customEnd'),
            demisto.get(args, 'assignedUser')
        )
        final_result = alarms_to_entry(res)

    elif demisto.command() == 'esm-acknowledge-alarms':
        args = demisto.args()
        res = esm.acknowledge_alarms(argToList(demisto.get(args, 'alarmIds')))
        final_result = res

    elif demisto.command() == 'esm-unacknowledge-alarms':
        args = demisto.args()
        res = esm.unacknowledge_alarms(argToList(demisto.get(args, 'alarmIds')))
        final_result = res

    elif demisto.command() == 'esm-delete-alarms':
        args = demisto.args()
        res = esm.delete_alarms(argToList(demisto.get(args, 'alarmIds')))
        final_result = res


    esm.logout()
    demisto.results(final_result)
    sys.exit(0)
  type: python
  commands:
  - name: esm-fetch-fields
    arguments: []
    description: Get all fields that can be used in query filters, with type information
      for each field
  - name: esm-search
    arguments:
    - name: timeRange
      required: true
      auto: PREDEFINED
      predefined:
      - LAST_3_DAYS
      - LAST_2_DAYS
      - LAST_24_HOURS
      - PREVIOUS_DAY
      - CURRENT_DAY
      - LAST_HOUR
      - LAST_30_MINUTES
      - LAST_10_MINUTES
      - LAST_MINUTE
      - CUSTOM
      - PREVIOUS_YEAR
      - CURRENT_YEAR
      - PREVIOUS_QUARTER
      - CURRENT_QUARTER
      - PREVIOUS_MONTH
      - CURRENT_MONTH
      - PREVIOUS_WEEK
      - CURRENT_WEEK
      description: The time period for the search
    - name: filters
      required: true
      description: Filter on the query results, should be a json string, of the format
        EsmFilter (read more on that here - https://<esm-ip>:<esm-port>/rs/esm/help/types/EsmFilter)
    - name: queryType
      auto: PREDEFINED
      predefined:
      - EVENT
      - FLOW
      - ASSETS
      description: 'Query type to preform, by default EVENT (other possible values
        are : FLOW/ASSET)'
    - name: maxWait
      description: Maximum time to wait (in minutes), default is 30
    - name: customStart
      description: if timeRange is CUSTOM, start time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: customEnd
      description: if timeRange is CUSTOM, end time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: fields
      description: The fields that will be selected when this query is executed.
    description: Perform a query against Mcafee ESM SIEM
  - name: esm-fetch-alarms
    arguments:
    - name: timeRange
      required: true
      auto: PREDEFINED
      predefined:
      - LAST_3_DAYS
      - LAST_2_DAYS
      - LAST_24_HOURS
      - PREVIOUS_DAY
      - CURRENT_DAY
      - LAST_HOUR
      - LAST_30_MINUTES
      - LAST_10_MINUTES
      - LAST_MINUTE
      - CUSTOM
      - PREVIOUS_YEAR
      - CURRENT_YEAR
      - PREVIOUS_QUARTER
      - CURRENT_QUARTER
      - PREVIOUS_MONTH
      - CURRENT_MONTH
      - PREVIOUS_WEEK
      - CURRENT_WEEK
      description: The time period for the fetch
    - name: customStart
      description: if timeRange is CUSTOM, start time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: customEnd
      description: if timeRange is CUSTOM, end time for the time range (e.g. 2017-06-01T12:48:16.734Z)
    - name: assignedUser
      auto: PREDEFINED
      predefined:
      - ME
      - ""
      description: 'user assigned to handle this triggered alarm (use ''ME'' option
        to use instance user, or use format EsmUser (read more on that here - https://<esm-ip>:<esm-port>/rs/esm/help/types/EsmUser) '
    outputs:
    - contextPath: Alarm.ID
      description: Alarm ID
    - contextPath: Alarm.summary
      description: Alarm summary
    - contextPath: Alarm.assignee
      description: Alarm assignee
    - contextPath: Alarm.severity
      description: Alarm severity
    - contextPath: Alarm.triggeredDate
      description: Alarm triggered date
    - contextPath: Alarm.acknowledgedDate
      description: Alarm acknowledged date
    - contextPath: Alarm.acknowledgedUsername
      description: Alarm acknowledged username
    - contextPath: Alarm.alarmName
      description: Alarm name
    - contextPath: Alarm.conditionType
      description: Alarm condition type
    description: Retrieves a list of alarms that have been triggered
  - name: esm-get-case-list
    arguments: []
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Get a list of cases from the system
  - name: esm-add-case
    arguments:
    - name: summary
      required: true
      default: true
      description: the name of the case
    - name: status
      description: the status of the case (use `esm-get-case-statuses` to view all
        statuses)
      defaultValue: Open
    - name: assignee
      description: who the case is assigned to
      defaultValue: me
    - name: severity
      description: the severity of the case (1 - 100)
      defaultValue: "1"
    - name: organization
      description: the organization assigned to the case  (use `esm-get-organization-list`
        to view all ogranizations)
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Add a case to the system
  - name: esm-edit-case
    arguments:
    - name: id
      required: true
      default: true
      description: the id of the case
    - name: summary
      description: the name of the case
    - name: severity
      description: the new severity of the case (1 - 100)
    - name: assignee
      description: who the case should be assigned to
    - name: status
      description: the new status of the case (use `esm-get-case-statuses` to view
        all statuses)
    - name: organization
      description: the organization assigned to the case  (use `esm-get-organization-list`
        to view all ogranizations)
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Edit an existing case
  - name: esm-get-case-statuses
    arguments: []
    description: Get a list of valid case statuses from the system
  - name: esm-edit-case-status
    arguments:
    - name: original_name
      required: true
      default: true
      description: the name of the case status to edit
    - name: new_name
      required: true
      description: the new name for the case status
    - name: show_in_case_pane
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: whether the status be shown in case pane
    description: Edit a case status
  - name: esm-get-case-detail
    arguments:
    - name: id
      required: true
      default: true
      description: the ID of the case
    outputs:
    - contextPath: Case.ID
      description: The ID of the case
    - contextPath: Case.Summary
      description: The summary of the case
    - contextPath: Case.Status
      description: The status of the case
    - contextPath: Case.OpenTime
      description: The open time of the case
    - contextPath: Case.Severity
      description: The severity of the case
    - contextPath: Case.Assignee
      description: The Assignee of the case
    - contextPath: Case.Organization
      description: The organization of the case
    - contextPath: Case.EventList
      description: List of case's events
    - contextPath: Case.Notes
      description: List of case's notes
    description: Get detail on an existing case
  - name: esm-get-case-event-list
    arguments:
    - name: ids
      required: true
      description: Comma separated  list of event IDs
    outputs:
    - contextPath: CaseEvents.ID
      description: The ID of the event
    - contextPath: CaseEvents.LastTime
      description: The last updated time of the event
    - contextPath: CaseEvents.Message
      description: The massage of the event
    description: Get case events details
  - name: esm-add-case-status
    arguments:
    - name: name
      required: true
      default: true
      description: the name of the case status
    - name: show_in_case_pane
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: whether the status be shown in case pane
      defaultValue: "True"
    description: Add a case status
  - name: esm-delete-case-status
    arguments:
    - name: name
      required: true
      default: true
      description: the name of the case status to delete
    description: Delete a case status
  - name: esm-get-organization-list
    arguments: []
    description: Get case organization
  - name: esm-get-user-list
    arguments: []
    outputs:
    - contextPath: EsmUser.ID
      description: the ID of the user
    - contextPath: EsmUser.Name
      description: the esm user name
    - contextPath: EsmUser.Email
      description: the e-mail of the user
    - contextPath: EsmUser.SMS
      description: the SMS details of the user
    - contextPath: EsmUser.IsMaster
      description: whether the user is a master user
    - contextPath: EsmUser.IsAdmin
      description: whether the user is an admin
    description: Get a list of all users.
  - name: esm-acknowledge-alarms
    arguments:
    - name: alarmIds
      required: true
      default: true
      description: list of triggered alarm ids to be marked acknowledged separated
        with commas
      isArray: true
    description: Mark triggered alarms as acknowledged
  - name: esm-unacknowledge-alarms
    arguments:
    - name: alarmIds
      required: true
      default: true
      description: list of triggered alarm ids to be marked unacknowledged separated
        with commas
      isArray: true
    description: Mark triggered alarms as unacknowledged
  - name: esm-delete-alarms
    arguments:
    - name: alarmIds
      required: true
      default: true
      description: list of triggered alarm ids to be deleted separated with commas
      isArray: true
    description: Delete triggered alarms
  isfetch: true
releaseNotes: "Now possible to change organization when editing a case"
