category: Messaging
commonfields:
  id: PagerDuty v2
  version: -1
configuration:
- display: API Key
  name: APIKey
  required: true
  type: 4
- display: Service Key (for triggering events only)
  name: ServiceKey
  required: false
  type: 0
- defaultvalue: 'true'
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: '1'
  display: Initial Fetch Interval(In minutes, used only for first fetch or after Reset
    last run)
  name: FetchInterval
  required: false
  type: 0
description: Alert and notify users using PagerDuty
display: PagerDuty v2
name: PagerDuty v2
script:
  commands:
  - arguments:
    - default: false
      description: Show only the schedules whose name matches the query
      isArray: false
      name: query
      required: false
      secret: false
    - default: false
      description: The limit for the amount of schedules to receive(Default is 25,
        max value is 100)
      isArray: false
      name: limit
      required: false
      secret: false
    description: Receive all schedules from PagerDuty
    execution: false
    name: PagerDuty-get-all-schedules
    outputs:
    - contextPath: PagerDuty.Schedules.id
      description: The ID of the schedule
      type: string
    - contextPath: PagerDuty.Schedules.name
      description: The name of the schedule
      type: string
  - arguments:
    - default: true
      description: (default and mandatory) The unique identifier of the schdule
      isArray: false
      name: scheduleID
      required: true
      secret: false
    - default: false
      description: The start of the date range Using ISO 8601 Representation. E.g.
        !PagerDutyGetUsersOnCall since=2011-05-06T17:00Z
      isArray: false
      name: since
      required: false
      secret: false
    - default: false
      description: The end of the date range
      isArray: false
      name: until
      required: false
      secret: false
    description: Returns the names and details of on call users at a certain time
      or by specific schedule
    execution: false
    name: PagerDuty-get-users-on-call
    outputs:
    - contextPath: PagerDutyUser.id
      description: User's ID
      type: string
    - contextPath: PagerDutyUser.Emails
      description: Email of user
      type: string
    - contextPath: PagerDutyUser.Username
      description: Username of person
      type: string
    - contextPath: PagerDutyUser.DisplayName
      description: Display name of person
      type: string
    - contextPath: PagerDutyUser.Role
      description: Display role of person
      type: string
    - contextPath: PagerDutyUser.TimeZone
      description: The time zone of the user
      type: string
  - arguments:
    - default: false
      description: The limit for the amount of users to receive(Default is 25, max
        value is 100)
      isArray: false
      name: limit
      required: false
      secret: false
    description: Returns the names and details of current on call personnel
    execution: false
    name: PagerDuty-get-users-on-call-now
    outputs:
    - contextPath: PagerDutyUser.ID
      description: User's ID
      type: string
    - contextPath: PagerDutyUser.Email
      description: Email of user
      type: string
    - contextPath: PagerDutyUser.Username
      description: Username of person
      type: string
    - contextPath: PagerDutyUser.DisplayName
      description: Display name of person
      type: string
    - contextPath: PagerDutyUser.Role
      description: Role of person
      type: string
    - contextPath: PagerDutyUser.TimeZone
      description: The time zone of the user
      type: string
  - arguments:
    - auto: PREDEFINED
      default: false
      description: Returns only the incidents currently in the passed status(es).
        Valid status options are triggered,acknowledged, and resolved. (Default values
        are triggered,acknowledged)
      isArray: false
      name: status
      predefined:
      - triggered
      - acknowledged
      - resolved
      required: false
      secret: false
    - default: false
      description: Beginning date and time. Using ISO 8601 Representation. E.g. PagerDutyIncidents
        since=2011-05-06T17:00Z (must be used with until argument)
      isArray: false
      name: since
      required: false
      secret: false
    - default: false
      description: Used to specify both the field you wish to sort the results on,
        as well as the direction (ascending/descending) of the results.See more https://v2.developer.pagerduty.com/v2/page/api-reference#!/Incidents/get_incidents
      isArray: false
      name: sortBy
      required: false
      secret: false
    - default: false
      description: Last date and time.  Using ISO 8601 Representation. E.g. PagerDutyIncidents
        until=2016-05-06T13:00Z
      isArray: false
      name: until
      required: false
      secret: false
    description: Shows incidents in PagerDuty. Default status parameters are triggered,acknowledged
    execution: false
    name: PagerDuty-incidents
    outputs:
    - contextPath: PagerDuty.Incidents.ID
      description: Incident ID
      type: string
    - contextPath: PagerDuty.Incidents.Title
      description: The title of the incident
      type: string
    - contextPath: PagerDuty.Incidents.Status
      description: Incident Status
      type: string
    - contextPath: PagerDuty.Incidents.created_at
      description: Time in which the incident was created
      type: date
    - contextPath: PagerDuty.Incidents.urgency
      description: Incident Urgency
      type: string
    - contextPath: PagerDuty.Incidents.assignee
      description: 'The assignee of the incident '
      type: string
    - contextPath: PagerDuty.Incidents.service_id
      description: The id of the impacted service
      type: string
    - contextPath: PagerDuty.Incidents.service_name
      description: The name of the impacted service
      type: string
    - contextPath: PagerDuty.Incidents.escalation_policy
      description: The escalation policy
      type: string
    - contextPath: PagerDuty.Incidents.last_status_change_at
      description: Time in which the last status change occurred
      type: date
    - contextPath: PagerDuty.Incidents.last_status_change_by
      description: Name of the user who done the last status change
      type: string
    - contextPath: PagerDuty.Incidents.number_of_escalations
      description: Number of escalations that took place
      type: number
    - contextPath: PagerDuty.Incidents.resolved_by
      description: Name of the User who resolved the incident
      type: string
    - contextPath: PagerDuty.Incidents.resolve_reason
      description: The reason for resolving the issue
      type: string
    - contextPath: PagerDuty.Incidents.Description
      description: The Description of the incident
      type: string
    - contextPath: PagerDuty.Incidents.teams.ID
      description: The ID of the team assigned for the incident.
      type: string
    - contextPath: PagerDuty.Incidents.teams.ID
      description: The name of the team assigned for the incident.
      type: string
    - contextPath: PagerDuty.Incidents.assignment.time
      description: The time of the assignment to the incident
      type: date
    - contextPath: PagerDuty.Incidents.assignment.assignee
      description: The name of the assignee to the incident
      type: string
    - contextPath: PagerDuty.Incidents.acknowledgement.time
      description: The time of the acknowledgement to the incident
      type: date
    - contextPath: PagerDuty.Incidents.acknowledgement.acknowledger
      description: The name of the acknowledger to the incident
      type: string
  - arguments:
    - default: false
      description: Specific human-readable unique identifier, such as a hostname,
        for the system having the problem.
      isArray: false
      name: source
      required: true
      secret: false
    - default: false
      description: "\t A high-level, text summary message of the event. Will be used\
        \ to construct an alert's description."
      isArray: false
      name: summary
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: The severity of the event
      isArray: false
      name: severity
      predefined:
      - critical
      - error
      - warning
      - info
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: The action to be executed
      isArray: false
      name: action
      predefined:
      - trigger
      - acknowledge
      - resolve
      required: true
      secret: false
    - default: false
      description: A short description of the problem
      isArray: false
      name: description
      required: false
      secret: false
    - default: false
      description: 'A cluster or grouping of sources. For example, sources “prod-datapipe-02”
        and “prod-datapipe-03” might both be part of “prod-datapipe”. Example: "prod-datapipe"
        "www"'
      isArray: false
      name: group
      required: false
      secret: false
    - default: false
      description: 'The class/type of the event. Example: "High CPU" "Latency"'
      isArray: false
      name: event_class
      required: false
      secret: false
    - default: false
      description: 'The part or component of the affected system that is broken. Example:
        "keepalive" "webping"'
      isArray: false
      name: component
      required: false
      secret: false
    - default: false
      description: Incident key, used to acknowledge/resolve specific event
      isArray: false
      name: incident_key
      required: false
      secret: false
    - default: false
      description: Service key for the integration
      isArray: false
      name: serviceKey
      required: false
      secret: false
    description: Creates a new event/incident in PagerDuty(In order to use this command
      you have to enter the Service Key in the integration settings)
    execution: false
    name: PagerDuty-submit-event
    outputs:
    - contextPath: PagerDuty.Event.Status
      description: Status of the action on the event
      type: string
    - contextPath: PagerDuty.Event.incident_key
      description: Incident key
      type: string
  - arguments:
    - default: false
      description: 'ID of the wanted user '
      isArray: false
      name: UserID
      required: true
      secret: false
    description: Get the contact methods of a given user
    execution: false
    name: PagerDuty-get-contact-methods
    outputs:
    - contextPath: PagerDuty.Contact_methods.phone
      description: The phone number of the user
      type: string
    - contextPath: PagerDuty.Contact_methods.id
      description: ID of the contact method
      type: string
    - contextPath: PagerDuty.Contact_methods.type
      description: The type of the current contact method
      type: string
    - contextPath: PagerDuty.Contact_methods.email
      description: The email of the user
      type: string
  - arguments:
    - default: false
      description: ID of the wanted user
      isArray: false
      name: UserID
      required: true
      secret: false
    description: Get the users notification rules
    execution: false
    name: PagerDuty-get-users-notification
    outputs:
    - contextPath: PagerDuty.Notification_rules.start_delay_in_minutes
      description: The delay time for notifying the user
      type: string
    - contextPath: PagerDuty.Notification_rules.urgency
      description: The urgency of the notification
      type: string
    - contextPath: PagerDuty.Notification_rules.id
      description: The id of the notification rule
      type: string
  - arguments:
    - default: false
      description: Incident key
      isArray: false
      name: incident_key
      required: true
      secret: false
    - default: false
      description: Service key for the integration
      isArray: false
      name: serviceKey
      required: true
      secret: false
    description: Resolves an existing event in PagerDuty
    execution: false
    name: PagerDuty-resolve-event
    outputs:
    - contextPath: PagerDuty.Event.Status
      description: Status of the action on the event
      type: string
    - contextPath: PagerDuty.Event.incident_key
      description: Incident key
      type: string
  - arguments:
    - default: false
      description: Incident key
      isArray: false
      name: incident_key
      required: true
      secret: false
    - default: false
      description: Service key for the integration
      isArray: false
      name: serviceKey
      required: true
      secret: false
    description: Acknowledges an existing event in PagerDuty
    execution: false
    name: PagerDuty-acknowledge-event
    outputs:
    - contextPath: PagerDuty.Event.Status
      description: Status of the action on the event
      type: string
    - contextPath: PagerDuty.Event.incident_key
      description: Incident key
      type: string
  isfetch: true
  runonce: false
  script: |-
    """" IMPORTS """
    import json
    import requests
    from datetime import datetime, timedelta

    ''' GLOBAL VARS '''
    # PagerDuty API works only with secured communication.
    USE_SSL = True

    USE_PROXY = demisto.params().get('proxy', True)
    API_KEY = demisto.params()['APIKey']
    SERVICE_KEY = demisto.params()['ServiceKey']
    FETCH_INTERVAL = demisto.params()['FetchInterval']

    SERVER_URL = 'https://api.pagerduty.com/'
    CREATE_EVENT_URL = 'https://events.pagerduty.com/v2/enqueue'

    DEFAULT_HEADERS = {
        'Authorization': 'Token token=' + API_KEY,
        'Accept': 'application/vnd.pagerduty+json;version=2'
    }

    '''HANDLE PROXY'''
    if not USE_PROXY:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    '''PARAMS'''
    UTC_PARAM = '&time_zone=UTC'
    STATUSES = 'statuses%5B%5D'
    INCLUDED_FIELDS = '&include%5B%5D=first_trigger_log_entries&include%5B%5D=assignments'

    '''SUFFIX ENDPOINTS'''
    GET_SCHEDULES_SUFFIX = 'schedules'
    CREATE_INCIDENT_SUFFIX = 'incidents'
    ON_CALL_BY_SCHEDULE_SUFFIX = 'schedules/{0}/users'
    ON_CALLS_USERS_SUFFIX = 'oncalls?include%5B%5D=users'
    USERS_NOTIFICATION_RULE = 'users/{0}/notification_rules'
    GET_INCIDENTS_SUFFIX = 'incidents?include%5B%5D=assignees'
    USERS_CONTACT_METHODS_SUFFIX = 'users/{0}/contact_methods'

    '''CONTACT_METHOD_TYPES'''
    SMS_CONTACT_TYPE = 'sms_contact_method'
    EMAIL_CONTACT_TYPE = 'email_contact_method'
    PHONE_CONTACT_TYPE = 'phone_contact_method'
    PUSH_CONTACT_TYPE = 'push_notification_contact_method'

    CONTACT_METHODS_TO_HUMAN_READABLE = {
        '': 'Unknown',
        SMS_CONTACT_TYPE: 'SMS',
        PUSH_CONTACT_TYPE: 'Push',
        EMAIL_CONTACT_TYPE: 'Email',
        PHONE_CONTACT_TYPE: 'Phone'
    }

    '''TABLE NAMES'''
    SCHEDULES = 'All Schedules'
    TRIGGER_EVENT = 'Trigger Event'
    RESOLVE_EVENT = 'Resolve Event'
    ACKNOLWEDGE_EVENT = 'Acknowledge Event'
    USERS_ON_CALL = 'Users On Call'
    INCIDETS = 'PagerDuty Incidents'
    CONTACT_METHODS = 'Contact Methods'
    USERS_ON_CALL_NOW = 'Users On Call Now'
    NOTIFICATION_RULES = 'User notification rules'

    '''TABLE HEADERS'''
    CONTACT_METHODS_HEADERS = ['ID', 'Type', 'Details']
    NOTIFICATION_RULES_HEADERS = ['ID', 'Type', 'Urgency', 'Notification timeout(minutes)']
    SCHEDULES_HEADERS = ['ID', 'Name', 'Today', 'Time Zone', 'Escalation Policy', 'Escalation Policy ID']
    USERS_ON_CALL_NOW_HEADERS = ['ID', 'Email', 'Name', 'Role', 'User Url', 'Time Zone']
    INCIDENTS_HEADERS = ['ID', 'Title', 'Description', 'Status', 'Created On', 'Urgency', 'Html Url',
                         'Assigned To User', 'Service ID', 'Service Name', 'Escalation Policy', 'Last Status Change On',
                         'Last Status Change By', 'Number Of Escalations', 'Resolved By User', 'Resolve Reason']


    ''' HELPER FUNCTIONS '''


    def http_request(method, url, params_dict=None, data=None):
        LOG('running %s request with url=%s\nparams=%s' % (method, url, json.dumps(params_dict)))
        try:
            res = requests.request(method,
                                   url,
                                   verify=USE_SSL,
                                   params=params_dict,
                                   headers=DEFAULT_HEADERS,
                                   data=data
                                   )
            res.raise_for_status()

            return res.json()

        except Exception as e:
            LOG(e)
            raise(e)


    def translate_severity(sev):
        if sev == 'high':
            return 3
        elif sev == 'Low':
            return 1
        return 0


    def test_module():
        try:
            get_on_call_now_users_command()
        except Exception as e:
            raise Exception(e.message)

        demisto.results('ok')


    def extract_on_call_user_data(users):
        """Extact data about user from a given schedule."""
        outputs = []
        contexts = []
        for user in users:
            output = {}
            context = {}

            output['ID'] = user.get('id')
            output['Name'] = user.get('name')
            output['Role'] = user.get('role')
            output['Email'] = user.get('email')
            output['Time Zone'] = user.get('time_zone')
            output['User Url'] = user.get('html_url')

            context['ID'] = output['ID']
            context['Role'] = output['Role']
            context['Email'] = output['Email']
            context['Username'] = output['Name']
            context['DisplayName'] = output['Name']
            context['TimeZone'] = output['Time Zone']

            outputs.append(output)
            contexts.append(context)

        return {
            'Type': entryTypes['note'],
            'Contents': users,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(USERS_ON_CALL, outputs, USERS_ON_CALL_NOW_HEADERS),
            'EntryContext': {
                'PagerDutyUser(val.ID==obj.ID)': contexts
            }
        }


    def extract_on_call_now_user_data(users_on_call_now):
        """Extract the user data from the oncalls json."""
        outputs = []
        contexts = []
        oncalls = users_on_call_now.get('oncalls', {})

        for i in xrange(len(oncalls)):
            output = {}
            context = {}

            data = oncalls[i]
            user = data.get('user')

            output['ID'] = user.get('id')
            output['Name'] = user.get('name')
            output['Role'] = user.get('role')
            output['Email'] = user.get('email')
            output['User Url'] = user.get('html_url')
            output['Time Zone'] = user.get('time_zone')

            context['ID'] = output['ID']
            context['Role'] = output['Role']
            context['Email'] = output['Email']
            context['Username'] = output['Name']
            context['DisplayName'] = output['Name']
            context['TimeZone'] = output['Time Zone']

            escal_level = data.get('escalation_level', 1)
            outputs.insert(escal_level - 1, output)
            contexts.insert(escal_level - 1, context)

        return {
            'Type': entryTypes['note'],
            'Contents': users_on_call_now,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(USERS_ON_CALL_NOW, outputs, USERS_ON_CALL_NOW_HEADERS),
            'EntryContext': {
                'PagerDutyUser(val.ID==obj.ID)': contexts
            }
        }


    def parse_incident_data(incidents):
        """Parse incident data to output,context format"""
        outputs = []
        contexts = []
        raw_response = []
        for i, incident in enumerate(incidents):
            output = {}
            context = {}

            context['ID'] = output['ID'] = incident.get('id')
            context['Title'] = output['Title'] = incident.get('summary')
            output['Description'] = incident.get('first_trigger_log_entry', {}).get('channel', {}).get('details', '')
            context['Description'] = output['Description']
            context['Status'] = output['Status'] = incident.get('status')
            context['created_at'] = output['Created On'] = incident.get('created_at')
            context['urgency'] = output['Urgency'] = incident.get('urgency', '')
            output['Html Url'] = incident.get('html_url')

            if len(incident.get('assignments', [])) > 0:
                output['Assigned To User'] = incident['assignments'][0].get('assignee', {}).get('name')
            else:
                output['Assigned To User'] = '-'

            context['assignee'] = output['Assigned To User']

            context['service_id'] = output['Service ID'] = incident.get('service', {}).get('id')
            context['service_name'] = output['Service Name'] = incident.get('service', {}).get('summary')

            output['Escalation Policy'] = incident.get('escalation_policy', {}).get('summary')
            context['escalation_policy'] = output['Escalation Policy']

            context['last_status_change_at'] = output['Last Status Change On'] = incident.get('last_status_change_at')
            output['Last Status Change By'] = incident.get('last_status_change_by', {}).get('summary')
            context['last_status_change_by'] = output['Last Status Change By']

            context['number_of_escalations'] = output['Number Of Escalations'] = incident.get('number_of_escalations')

            if output['Status'] == 'resolved':
                output['Resolved By User'] = output['Last Status Change By']
            else:
                output['Resolved By User'] = '-'

            context['resolved_by'] = output['Assigned To User']
            context['resolve_reason'] = output['Resolve reason'] = incident.get('resolve_reason', '')

            context['teams'] = []
            for team in incident.get('teams', []):
                team_id = team.get('id', '')
                team_name = team.get('summary', '')

                team_data = {
                    "ID": team_id,
                    "Name": team_name
                }

                context['teams'].append(team_data)

            assignment = incident.get('assignments', [{}, ])
            if len(assignment) > 0:
                context['assignment'] = {
                    "time": assignment[0].get('at', ''),
                    "assignee": assignment[0].get('assignee', {}).get('summary', ''),
                }
            else:
                context['assignment'] = {}

            acknowledgements = incident.get('acknowledgements', [{}, ])
            if len(acknowledgements) > 0:
                context['acknowledgement'] = {
                    "time": assignment[0].get('at', ''),
                    "acknowledger": assignment[0].get('acknowledger', {}).get('summary', ''),
                }
            else:
                context['acknowledgement'] = {}

            outputs.append(output)
            contexts.append(context)
            raw_response.append(incident)

        return outputs, contexts, raw_response


    def extract_incidents_data(incidents):
        """Extact data about incidents."""
        outputs, contexts, _ = parse_incident_data(incidents)

        return {
            'Type': entryTypes['note'],
            'Contents': incidents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(INCIDETS, outputs, INCIDENTS_HEADERS),
            'EntryContext': {
                'PagerDuty.Incidents(val.ID==obj.ID)': contexts
            }
        }


    def extract_all_schedules_data(schedules):
        """Extract the data about all the schedules."""
        outputs = []
        contexts = []
        for i in range(len(schedules)):
            output = {}
            context = {}
            data = schedules[i]

            output['ID'] = data.get('id')
            output['Name'] = data.get('name')
            output['Time Zone'] = data.get('time_zone')
            output['Today'] = datetime.today().strftime('%Y-%m-%d')
            escalation_policies = data.get('escalation_policies', [])
            if len(escalation_policies) > 0:
                output['Escalation Policy ID'] = escalation_policies[0].get('id')
                output['Escalation Policy'] = escalation_policies[0].get('summary')

                context['escalation_policies'] = [{}, ]
                context['escalation_policies'][0]['name'] = output['Escalation Policy']
                context['escalation_policies'][0]['id'] = output['Escalation Policy ID']
            else:
                output['Escalation Policy'] = '-'
                output['Escalation Policy ID'] = '-'

            context['id'] = output['ID']
            context['name'] = output['Name']
            context['today'] = output['Today']
            context['time_zone'] = output['Time Zone']

            outputs.append(output)
            contexts.append(context)

        return {
            'Type': entryTypes['note'],
            'Contents': schedules,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(SCHEDULES, outputs, SCHEDULES_HEADERS),
            'EntryContext': {
                'PagerDuty.Schedules(val.id==obj.id)': contexts,
            }
        }


    def create_new_incident(source, summary, severity, action, description='No description', group='',
                            event_class='', component='', incident_key=None, service_key=SERVICE_KEY):
        """Create a new incident in the PagerDuty instance."""
        payload = {
            'routing_key': service_key,
            'event_action': action,
            'dedup_key': incident_key,
            'images': [],
            'links': [],
            'payload': {
                'summary': summary,
                'source': source,
                'severity': severity,
                'group': group,
                'class': event_class,
                'component': component,
                'custom_details': {
                    'description': description
                }
            }
        }

        return http_request('POST', CREATE_EVENT_URL, data=json.dumps(payload))


    def resolve_or_ack_incident(action, incident_key, service_key=SERVICE_KEY):
        """Resolve or Acknowledge an incident in the PagerDuty instance."""
        payload = {
            'routing_key': service_key,
            'event_action': action,
            'dedup_key': incident_key
        }

        return http_request('POST', CREATE_EVENT_URL, data=json.dumps(payload))


    def extract_new_event_data(table_name, response):
        """Extract the data from the response of creating a new command."""
        output = {}
        context = {}

        output['Status'] = response.get('status', '')
        output['Message'] = response.get('message', '')
        output['Incident key'] = response.get('dedup_key', '')

        context['Status'] = output['Status']
        context['Message'] = output['Message']
        context['incident_key'] = output['Incident key']

        return {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(table_name, output),
            'EntryContext': {
                'PagerDuty.Event(val.incident_key==obj.dedup_key)': context,
                'Event.ID(val.ID==obj.dedup_key)': context['incident_key']
            }
        }


    def extract_users_contact_methods(user_contact_methods):
        """Extract all the contact methods of a given user."""
        outputs = []
        contexts = []
        contact_methods = user_contact_methods.get('contact_methods')
        for contact_method in contact_methods:
            output = {}

            output['ID'] = contact_method.get('id')
            output['Type'] = CONTACT_METHODS_TO_HUMAN_READABLE[contact_method.get('type', '')]

            country_code = str(contact_method.get('country_code', ''))
            address = contact_method.get('address', '')
            output['Details'] = country_code + address

            outputs.append(output)

            del contact_method['address']
            if output['Type'] == 'SMS' or output['Type'] == 'Phone':
                del contact_method['country_code']
                contact_method['phone'] = output['Details']
            else:
                contact_method['email'] = output['Details']

            contexts.append(contact_method)

        return {
            'Type': entryTypes['note'],
            'Contents': user_contact_methods,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(CONTACT_METHODS, outputs, CONTACT_METHODS_HEADERS),
            'EntryContext': {
                'PagerDuty.Contact_methods(val.id==obj.id)': contexts,
            }
        }


    def extract_users_notification_role(user_notication_role):
        """Extract the notification role of a given user."""
        outputs = []
        notification_rules = user_notication_role.get('notification_rules')
        for notification_rule in notification_rules:
            output = {}

            output['ID'] = notification_rule.get('id')
            output['Type'] = notification_rule.get('type', '')
            output['Urgency'] = notification_rule.get('urgency')
            output['Notification timeout(minutes)'] = notification_rule.get('start_delay_in_minutes')

            outputs.append(output)

        return {
            'Type': entryTypes['note'],
            'Contents': user_notication_role,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(NOTIFICATION_RULES, outputs, NOTIFICATION_RULES_HEADERS),
            'EntryContext': {
                'PagerDuty.Notification_rules(val.id==obj.id)': notification_rules,
            }
        }


    '''COMMANDS'''


    def fetch_incidents():
        param_dict = {}
        now_time = datetime.utcnow()
        now = datetime.isoformat(now_time)
        lastRunObject = demisto.getLastRun()
        if lastRunObject:
            param_dict['since'] = lastRunObject['time']
        else:
            param_dict['since'] = datetime.isoformat(now_time - timedelta(minutes=int(FETCH_INTERVAL)))

        param_dict['until'] = now

        url = SERVER_URL + GET_INCIDENTS_SUFFIX + configure_status()
        res = http_request('GET', url, param_dict)
        _, parsed_incidents, raw_responses = parse_incident_data(res.get('incidents', []))

        incidents = []
        for incident, raw_response in zip(parsed_incidents, raw_responses):
            incidents.append({
                'name': incident['ID'] + ' - ' + incident['Title'],
                'occurred': incident['created_at'],
                'severity': translate_severity(incident['urgency']),
                'rawJSON': json.dumps(raw_response)
            })

        demisto.incidents(incidents)
        demisto.setLastRun({'time': now})


    def configure_status(status='triggered,acknowledged'):
        statuses = status.split(',')
        statuses_string = "&" + STATUSES + '='
        statuses = statuses_string.join(statuses)
        status_request = '&' + STATUSES + '=' + statuses

        status_request = status_request + INCLUDED_FIELDS + UTC_PARAM
        return status_request


    def get_incidents_command(since=None, until=None, status='triggered,acknowledged', sortBy=None):
        """Get incidents command."""
        param_dict = {}
        if since is not None:
            param_dict['since'] = since
        if until is not None:
            param_dict['until'] = until
        if sortBy is not None:
            param_dict['sortBy'] = sortBy

        url = SERVER_URL + GET_INCIDENTS_SUFFIX + configure_status(status)
        res = http_request('GET', url, param_dict)
        return extract_incidents_data(res.get('incidents', []))


    def submit_event_command(source, summary, severity, action, description='No description', group='',
                             event_class='', component='', incident_key=None, serviceKey=SERVICE_KEY):
        """Create new event."""
        if serviceKey is None:
            raise Exception('You must enter a ServiceKey at the integration '
                            'parmaters or in the command to process this action.')

        res = create_new_incident(source, summary, severity, action, description,
                                  group, event_class, component, incident_key, serviceKey)
        return extract_new_event_data(TRIGGER_EVENT, res)


    def get_all_schedules_command(query=None, limit=None):
        """Get all the schedules."""
        param_dict = {}
        if query is not None:
            param_dict['query'] = query
        if limit is not None:
            param_dict['limit'] = limit

        url = SERVER_URL + GET_SCHEDULES_SUFFIX
        res = http_request('GET', url, param_dict)
        schedules = res.get('schedules', [])
        return extract_all_schedules_data(schedules)


    def get_on_call_users_command(scheduleID, since=None, until=None):
        """Get the list of user on call in a from scheduleID"""
        param_dict = {}
        if since is not None:
            param_dict['since'] = since
        if until is not None:
            param_dict['until'] = until

        url = SERVER_URL + ON_CALL_BY_SCHEDULE_SUFFIX.format(scheduleID)
        users_on_call = http_request('GET', url, param_dict)
        return extract_on_call_user_data(users_on_call.get('users', []))


    def get_on_call_now_users_command(limit=None):
        """Get the list of users that are on call now."""
        param_dict = {}
        if limit is not None:
            param_dict['limit'] = limit

        url = SERVER_URL + ON_CALLS_USERS_SUFFIX
        users_on_call_now = http_request('GET', url, param_dict)
        return extract_on_call_now_user_data(users_on_call_now)


    def get_users_contact_methods_command(UserID):
        """Get the contact methods of a given user."""
        url = SERVER_URL + USERS_CONTACT_METHODS_SUFFIX.format(UserID)
        user_contact_methods = http_request('GET', url, {})
        return extract_users_contact_methods(user_contact_methods)


    def get_users_notification_command(UserID):
        """Get the notification rule of a given user"""
        url = SERVER_URL + USERS_NOTIFICATION_RULE.format(UserID)
        user_notication_role = http_request('GET', url, {})
        return extract_users_notification_role(user_notication_role)


    def resolve_event(incident_key=None, serviceKey=SERVICE_KEY):
        if serviceKey is None:
            raise Exception('You must enter a ServiceKey at the integration '
                            'parmaters or in the command to process this action.')

        action_response = resolve_or_ack_incident('resolve', incident_key, serviceKey)

        res = http_request('GET', SERVER_URL + GET_INCIDENTS_SUFFIX, {'incident_key': incident_key})
        _, contexts, _ = parse_incident_data(res.get('incidents', []))
        if contexts[0]['Status'] != "resolved":
            raise Exception('Could not resolve incident, you may have created it with different Service Key')

        return extract_new_event_data(RESOLVE_EVENT, action_response)


    def acknowledge_event(incident_key=None, serviceKey=SERVICE_KEY):
        if serviceKey is None:
            raise Exception('You must enter a ServiceKey at the integration '
                            'parmaters or in the command to process this action.')

        action_response = resolve_or_ack_incident('acknowledge', incident_key, serviceKey)

        res = http_request('GET', SERVER_URL + GET_INCIDENTS_SUFFIX, {'incident_key': incident_key})
        _, contexts, _ = parse_incident_data(res.get('incidents', []))
        if contexts[0]['Status'] != "acknowledged":
            raise Exception('Could not acknowledge incident, you may have created it with different Service Key')

        return extract_new_event_data(ACKNOLWEDGE_EVENT, action_response)


    ''' EXECUTION CODE '''

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            test_module()
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() == 'PagerDuty-incidents':
            demisto.results(get_incidents_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-submit-event':
            demisto.results(submit_event_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-users-on-call':
            demisto.results(get_on_call_users_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-all-schedules':
            demisto.results(get_all_schedules_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-users-on-call-now':
            demisto.results(get_on_call_now_users_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-contact-methods':
            demisto.results(get_users_contact_methods_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-users-notification':
            demisto.results(get_users_notification_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-resolve-event':
            demisto.results(resolve_event(**demisto.args()))
        elif demisto.command() == 'PagerDuty-acknowledge-event':
            demisto.results(acknowledge_event(**demisto.args()))


    except Exception as e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
releaseNotes: '-'
tests:
- PagerDuty Test
