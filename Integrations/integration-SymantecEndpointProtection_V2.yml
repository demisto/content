category: Endpoint
commonfields:
  id: Symantec Endpoint Protection V2
  version: -1
configuration:
- display: Server (e.g., https://1.2.3.4:8446)
  name: server
  required: true
  type: 0
- display: Authentication
  name: authentication
  required: true
  type: 9
- display: SEPM domain for the user
  name: domain
  required: false
  type: 0
- defaultvalue: 'false'
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- defaultvalue: 'false'
  display: Use proxy system settings
  name: proxy
  required: false
  type: 8
- display: Local time zone (e.g., +02:30,-06:00)
  name: timeZone
  required: false
  type: 0
description: Query the Symantec Endpoint Protection Manager using the official REST
  API.
detaileddescription: Integration with Symantec Endpoint Protection Manager using the
  sepm REST API.
display: Symantec Endpoint Protection V2
name: Symantec Endpoint Protection V2
script:
  commands:
  - arguments:
    - default: false
      description: The columns to display.
      isArray: false
      name: columns
      required: false
      secret: false
    - default: false
      description: Filter by computer host name (for wild cards, use '*')
      isArray: false
      name: computerName
      required: false
      secret: false
    - default: false
      description: Indicates when a computer's status was last updated (default is
        0, which returns all the results)
      isArray: false
      name: lastUpdate
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Operating system to filter by
      isArray: false
      name: os
      predefined:
      - CentOs
      - Debian
      - Fedora
      - MacOSX
      - Oracle
      - OSX
      - RedHat
      - SUSE
      - Ubuntu
      - Win10
      - Win2K
      - Win7
      - Win8
      - WinEmb7
      - WinEmb8
      - WinEmb81
      - WinFundamental
      - WinNT
      - Win2K3
      - Win2K8
      - Win2K8R2
      - WinVista
      - WinXP
      - WinXPEmb
      - WinXPProf64
      required: false
      secret: false
    - default: false
      description: The number of results to include on each page (default is 20)
      isArray: false
      name: pageSize
      required: false
      secret: false
    description: Returns information about endpoints.
    execution: false
    name: sep-endpoints-info
    outputs:
    - contextPath: SEPM.Endpoint.Hostname
      description: Endpoint's hostname
      type: string
    - contextPath: SEPM.Endpoint.Domain
      description: Endpoint's domain
      type: string
    - contextPath: SEPM.Endpoint.IPAddresses
      description: Endpoint's IP addresses
      type: string
    - contextPath: SEPM.Endpoint.OS
      description: Endpoint's OS information
      type: string
    - contextPath: SEPM.Endpoint.Description
      description: Endpoint's description
      type: string
    - contextPath: SEPM.Endpoint.MACAddresses
      description: Endpoint's MAC address
      type: string
    - contextPath: SEPM.Endpoint.BIOSVersion
      description: Endpoint's BIOS version
      type: string
    - contextPath: SEPM.Endpoint.DHCPServer
      description: Endpoint's DHCP server address
      type: string
    - contextPath: SEPM.Endpoint.HardwareKey
      description: ' Hardware-Key of the client to be moved'
      type: String
    - contextPath: SEPM.Endpoint.LastScanTime
      description: Endpoint's last scan time
      type: String
  - arguments:
    - default: false
      description: The columns to display
      isArray: false
      name: columns
      required: false
      secret: false
    description: Returns information about groups.
    execution: false
    name: sep-groups-info
    outputs:
    - contextPath: SEPM.Groups
      description: The list of groups
      type: Unknown
    - contextPath: SEPM.Groups.created
      description: Creation time (in Epoch)
      type: number
    - contextPath: SEPM.Groups.fullPathName
      description: Group name
      type: string
    - contextPath: SEPM.Groups.id
      description: Group ID
      type: string
    - contextPath: SEPM.Groups.numberOfPhysicalComputers
      description: Number of physical computers in the group
      type: number
    - contextPath: SEPM.Groups.numberOfRegisteredUsers
      description: Number of registered users in the group
      type: number
    - contextPath: SEPM.Groups.policyDate
      description: Policy date (in Epoch)
      type: number
    - contextPath: SEPM.Groups.policySerialNumber
      description: Policy serial number
      type: number
  - description: Returns information about the system (version, AV definition)
    execution: false
    name: sep-system-info
    outputs:
    - contextPath: SEPM.ServerAVDefVersion
      description: The serverAV definition version
      type: string
  - arguments:
    - default: false
      description: Command ID
      isArray: false
      name: commandId
      required: true
      secret: false
    description: Retrieves the status of a command.
    execution: false
    name: sep-command-status
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: Details of the command
      type: string
    - contextPath: SEPM.LastCommand.CommandId
      description: Command ID
      type: string
  - description: Retrieves the client content.
    execution: false
    name: sep-client-content
    outputs:
    - contextPath: SEPM.ClientContentVersions
      description: The versions of the clients
      type: string
    - contextPath: SEPM.LastUpdated
      description: The last-updated date
      type: string
  - description: Retrieve a list of existing policies
    execution: false
    name: sep-list-policies
    outputs:
    - contextPath: SEPM.PoliciesList.PolicyName
      description: Policy name
      type: string
    - contextPath: SEPM.PoliciesList.Type
      description: Policy type
      type: string
    - contextPath: SEPM.PoliciesList.ID
      description: Policy ID
      type: string
    - contextPath: SEPM.PoliciesList.Description
      description: Policy description
      type: string
    - contextPath: SEPM.PoliciesList.Enabled
      description: True if enabled
      type: boolean
    - contextPath: SEPM.PoliciesList.AssignedLocations.GroupID
      description: 'Group ID of the locations assigned with this policy '
      type: string
    - contextPath: SEPM.PoliciesList.AssignedLocations.Locations
      description: List of locations IDs assigned with this policy
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.GroupID
      description: 'Cloud Group ID of the locations assigned with this policy '
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.Locations
      description: List of locations IDs belonging to a cloud group assigned with
        this policy
      type: string
  - arguments:
    - default: false
      description: Endpoint's group ID '
      isArray: false
      name: groupID
      required: true
      secret: false
    - default: false
      description: Endpoint's location ID
      isArray: false
      name: locationID
      required: true
      secret: false
    - default: false
      description: Type of policy to be assigned
      isArray: false
      name: policyType
      required: true
      secret: false
    - default: false
      description: 'Policy ID to be assigned '
      isArray: false
      name: policyID
      required: true
      secret: false
    description: Assigns an existing policy to a specified location.
    execution: false
    name: sep-assign-policy
  - arguments:
    - default: false
      description: Group ID to list locations for
      isArray: false
      name: groupID
      required: true
      secret: false
    description: Retrieves a list of location IDs for a specified group.
    execution: false
    name: sep-list-locations
    outputs:
    - contextPath: SEPM.Locations.ID
      description: Location's ID
      type: Unknown
  - arguments:
    - default: false
      description: Endpoint's IP or hostname
      isArray: false
      name: endpoint
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Add or remove an endpoint from quarantine
      isArray: false
      name: actionType
      predefined:
      - Add
      - Remove
      required: true
      secret: false
    description: Quarantines an endpoint according to its policy.
    execution: false
    name: sep-endpoint-quarantine
    outputs:
    - contextPath: SEPM.Quarantine.CommandID
      description: ID of the invoked command
      type: string
    - contextPath: SEPM.Quarantine.Action
      description: Action type ('Add' or 'Remove')
      type: string
    - contextPath: SEPM.Quarantine.Endpoint
      description: Endpoint identifier (IP or Host Name)
      type: string
  - arguments:
    - default: false
      description: Endpoint's IP address or hostname
      isArray: false
      name: endpoint
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Scan type
      isArray: false
      name: scanType
      predefined:
      - ScanNow_Quick
      - ScanNow_Full
      - ScanNow_Custom
      required: true
      secret: false
    description: Scans an endpoint.
    execution: false
    name: sep-scan-endpoint
    outputs:
    - contextPath: SEPM.Scan.CommandID
      description: ID of the invoked command
      type: string
    - contextPath: SEPM.Scan.Type
      description: Scan type (ScanNow_Quick, ScanNow_Full or ScanNow_Custom)
      type: string
    - contextPath: SEPM.Scan.Endpoint
      description: Endpoint identifier (IP or Host Name)
      type: Unknown
  - arguments:
    - default: false
      description: Endpoint's IP address or hostname
      isArray: false
      name: endpoint
      required: true
      secret: false
    description: Updates the content of a specified client.
    execution: false
    name: sep-update-endpoint-content
    outputs:
    - contextPath: SEPM.Update.Endpoint
      description: The endpoint that is being updated
      type: String
    - contextPath: SEPM.Update.CommandID
      description: Command ID to check status of
      type: String
  - arguments:
    - default: false
      description: 'Group ID to move the client to '
      isArray: false
      name: groupID
      required: true
      secret: false
    - default: false
      description: Hardware-key of the client to be moved
      isArray: false
      name: hardwareKey
      required: true
      secret: false
    description: Moves a client to a group.
    execution: false
    name: sep-move-client-to-group
  isfetch: false
  runonce: false
  script: |-
    import requests
    import json
    import re

    requests.packages.urllib3.disable_warnings()
    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']
    ENDPOINTS_INFO_DEFAULT_COLUMNS = [
        'computerName',
        'ipAddresses',
        'operatingSystem',
        'osBitness',
        'cidsDefsetVersion',
        'lastScanTime',
        'description',
        'quarantineDesc',
        'domainOrWorkgroup',
        'macAddresses',
        'group',
        'dhcpServer',
        'biosVersion',
        'virtualizationPlatform',
        'computerTimeStamp',
        'creationTime',
        'agentTimestamp',
        'hardwareKey'
    ]
    GROUPS_INFO_DEFAULT_COLUMNS = [
        'fullPathName',
        'numberOfPhysicalComputers',
        'numberOfRegisteredUsers',
        'policySerialNumber',
        'policyDate',
        'description',
        'created',
        'id'
    ]
    # @@@@@@@@@@@@@@@@@@@@@@@@@@    LITERALS    @@@@@@@@@@@@@@@@@@@@@@@@@@
    EPOCH_MINUTE = 60 * 1000
    EPOCH_HOUR = 60 * EPOCH_MINUTE


    # @@@@@@@@@@@@@@@@@@@@@@@@@@    HELPER FUNCTIONS    @@@@@@@@@@@@@@@@@@@@@@@@@@
    def fix_url(base):
        return base if base.endswith('/') else (base + '/')


    def build_query_params(params):
        list_params = map(lambda key: key + '=' + str(params[key]), params.keys())
        query_params = '&'.join(list_params)
        return '?' + query_params if query_params else ''


    def do_auth(server, crads, insecure):
        url = fix_url(str(server)) + 'sepm/api/v1/identity/authenticate'
        body = {
            'username': crads.get('identifier') if crads.get('identifier') else '',
            'password': crads.get('password') if crads.get('password') else '',
            'domain': crads.get('domain') if crads.get('domain') else ''
        }
        res = requests.post(url, headers={"Content-Type": "application/json"}, data=json.dumps(body), verify=not insecure)
        return parse_response(res)


    def do_get(token, raw, suffix):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.get(url, headers={'Authorization': 'Bearer ' + token}, verify=not insecure)
        if (raw):
            return res
        else:
            return parse_response(res)


    def do_post(token, is_xml, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.post(url, headers={'Authorization': 'Bearer ' + token}, data=body, verify=not insecure)
        if is_xml:
            if res.content:
                parsed_response = xml2json(res.content)
            else:
                return_error('Unable to parse the following response: {}'.format(res))
        else:
            parsed_response = parse_response(res)
        return parsed_response


    def do_put(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.put(url, headers={'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify=not insecure)
        parsed_response = parse_response(res)
        return parsed_response


    def do_patch(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.patch(url, headers={'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify=not insecure)
        parsed_response = parse_response(res)
        return parsed_response


    def parse_response(resp):
        if resp.status_code == 200 or resp.status_code == 207:
            if resp.text == '':
                return resp
            try:
                return resp.json()
            except Exception, ex:
                return_error('Unable to parse response: {}'.format(ex))
        else:
            try:
                message = resp.json().get('errorMessage')
                return_error('Error: {}'.format(message))
            except Exception:
                return_error('Error: {}'.format(resp))


    def get_token_from_response(resp):
        if resp.get('token'):
            return resp.get('token')
        else:
            return_error('No token: {}'.format(resp))


    def choose_columns(column_arg, default_list):
        if not column_arg:
            columns_list = default_list
            columns_list.sort()
        elif column_arg == 'all' or column_arg == '*':
            columns_list = []
        else:
            columns_list = argToList(column_arg)
        return columns_list


    def build_command_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:com="http://command.client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def build_client_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cli="http://client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def get_command_status_details(token, command_id):
        xml = build_command_xml('<com:getCommandStatusDetails><commandID>{0}</commandID></com:getCommandStatusDetails>'.format(command_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        return res_json


    def build_command_response_output(title, command_id, message, response):
        cmd_status_details = response.get('cmdStatusDetail')
        cmd_status_details.pop('hardwareKey', None)
        md = tableToMarkdown(title, cmd_status_details) + '\n'
        md += '### Command ID: {0}\n'.format(command_id)
        md += '### ' + message;
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_details,
                'commandId': command_id
            },
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_details, 'CommandId': command_id}, removeNull=True)
            }
        })


    def get_computer_id_by_ip(token, ip):
        xml = build_client_xml('<cli:getComputersByIP><ipAddresses>{0}</ipAddresses></cli:getComputersByIP>'.format(ip))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)
        return demisto.get(json.loads(res_json), 'Envelope.Body.getComputersByIPResponse.ComputerResult.computers.computerId')


    def get_computer_id_by_hostname(token, hostname):
        xml = build_client_xml('<cli:getComputersByHostName><computerHostNames>{0}</computerHostNames></cli:getComputersByHostName>'.format(hostname))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)
        return demisto.get(json.loads(res_json), 'Envelope.Body.getComputersByHostNameResponse.ComputerResult.computers.computerId')


    def get_computer_id(token, endpoint_ip, endpoint_host_name):
        if endpoint_ip:
            try:
                computer_id = get_computer_id_by_ip(token, endpoint_ip)
            except Exception, ex:
                return_error('Failed to locate the endpoint by its IP address.')
        elif endpoint_host_name:
            try:
                computer_id = get_computer_id_by_hostname(token, endpoint_host_name)
            except Exception, ex:
                return_error('Failed to locat the endpoint by its hostname.')
        else:
            return_error('Please provide the IP address or the hostname of endpoint.')
        return computer_id


    def update_content(token, computer_id):
        xml = build_command_xml('<com:runClientCommandUpdateContent><computerGUIDList>{0}</computerGUIDList></com:runClientCommandUpdateContent>'.format(computer_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def scan(token, computer_id, scan_type):
        xml = build_command_xml('<com:runClientCommandScan><computerGUIDList>{0}</computerGUIDList><scanType>{1}</scanType></com:runClientCommandScan>'.format(computer_id, scan_type))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def quarantine(token, computer_id, action_type):
        xml = build_command_xml(
            '<com:runClientCommandQuarantine><command><commandType>{0}</commandType><targetObjectIds>{1}</targetObjectIds><targetObjectType>COMPUTER</targetObjectType></command></com:runClientCommandQuarantine>'.format(
                action_type, computer_id));
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml);
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def validate_time_zone(time_zone):
        pattern = re.compile("^[+-][0-9][0-9]:[0-9][0-9]")
        return bool(pattern.match(time_zone))


    def parse_epoch_to_local(epoch, time_zone):
        if not validate_time_zone(time_zone):
            return_error('timeZone param should be in the format of [+/-][h][h]:[m][m]. For exmaple +04:30')
        operator = time_zone[0]
        hour = int(time_zone[1:3])
        minutes = int(time_zone[4:6])
        time_zone_epoch = hour * EPOCH_HOUR + minutes * EPOCH_MINUTE
        local = int(epoch) + time_zone_epoch if operator == '+' else int(epoch) - time_zone_epoch
        return local


    def change_assigined(policy):
        new_format = {
            'Policy Name': policy.get('PolicyName'),
            'Type': policy.get('Type'),
            'ID': policy.get('ID'),
            'Assigned': True if (policy.get('AssignedLocations') or policy.get('AssignedCloudGroups')) else False,
            'Discription': policy.get('Discription'),
            'Enabled': policy.get('Enabled')
        }
        return new_format


    def sanitize_policies_list_for_md(policies_list):
        return map(change_assigined, policies_list)


    def sanitize_policies_list(policies_list):
        return map(lambda policy: {
            'PolicyName': policy['name'],
            'Type': policy['policytype'],
            'ID': policy['id'],
            'Description': policy['desc'],
            'Enabled': policy['enabled'],
            'AssignedLocations': map(lambda location: {
                'GroupID': location.get('groupId'),
                'Locations': location.get('locationIds')
            }, policy.get('assignedtolocations') if policy.get('assignedtolocations') else []),
            'AssignedCloudGroups': map(lambda location: {
                'GroupID': location.get('groupId'),
                'Locations': location.get('locationIds')
            }, policy.get('assignedtocloudgroups') if policy.get('assignedtocloudgroups') else []),
        }, policies_list)


    def validate_ip(ip):
        pattern = re.compile('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
        return bool(pattern.match(ip))


    def get_client_content(token, time_zone):
        client_content_json = do_get(token, False, 'sepm/api/v1/stats/client/content')
        epoch_time = client_content_json.get('lastUpdated')
        if time_zone:
            epoch_time = parse_epoch_to_local(epoch_time, time_zone)
        last_update_date = timestamp_to_datestring(epoch_time, '%a %b %d %y %H:%M:%S %z')
        client_version = client_content_json.get('clientDefStatusList')
        return client_content_json, client_version, last_update_date


    def get_endpoints_info(token, computer_name, last_update, os, page_size, columns):
        params = {
            'computerName': computer_name,
            'lastUpdate': last_update,
            'os': os,
            'pageSize': page_size,
            'columns': columns
        }
        params = createContext(params, removeNull=True)
        json_response = do_get(token, False, 'sepm/api/v1/computers' + build_query_params(params))
        filtered_json_response = json_response.get('content')
        entry_context = []
        for content in filtered_json_response:
            content['macAddresses'] = list(set(content.get('macAddresses')))  # used `set` on the mac address list as it sometimes contained duplicated values
            entry_context.append({
                'Hostname': content.get('computerName'),
                'Domain': content.get('domainOrWorkgroup'),
                'IPAddresses': content.get('ipAddresses'),
                'OS': content.get('operatingSystem') + ' | ' + content.get('osBitness'),
                'Description': content.get('content.description'),
                'MACAddresses': content.get('macAddresses'),
                'BIOSVesrsion': content.get('biosVersion'),
                'DHCPServer': content.get('dhcpServer'),
                'HardwareKey': content.get('hardwareKey'),
                'LastScanTime': epochToTimestamp(content.get('lastScanTime'))
            })
        return filtered_json_response, entry_context


    def create_endpints_filter_string(computer_name, last_update, os, page_size):
        md = '## Endpoints Information'
        md += ', filtered for last updated status: {}'.format(last_update) if last_update else ''
        md += ', filtered for hostname: {}'.format(computer_name) if computer_name else ''
        md += ', filtered for os: {}'.format(os) if os else ''
        md += ', page size: {}'.format(page_size) if page_size else ''
        md += '\n'
        return md


    def get_groups_info(token, columns):
        json_res = do_get(token, False, 'sepm/api/v1/groups' + build_query_params({'columns': columns}))
        sepm_groups = []
        filtered_json_response = json_res.get('content')
        for entry in filtered_json_response:
            group = {}
            for header in GROUPS_INFO_DEFAULT_COLUMNS:
                group[header] = entry[header]
                sepm_groups.append(group)
        return filtered_json_response, json_res, sepm_groups


    def get_command_status(token, command_id):
        command_status_json = get_command_status_details(token, command_id)
        cmd_status_detail = demisto.get(json.loads(command_status_json), 'Envelope.Body.getCommandStatusDetailsResponse.CommandStatusDetailResult.cmdStatusDetail')
        cmd_status_detail.pop('hardwareKey', None)
        state_id = cmd_status_detail.get('stateId')
        is_done = False
        if state_id == '2' or state_id == '3':
            is_done = True
        message = 'Command is done.' if is_done else 'Command is in progress. Run !sep-command-status to check again.';
        return cmd_status_detail, message


    def get_list_of_policies(token):
        policies_list = do_get(token, False, 'sepm/api/v1/policies/summary').get('content')
        fixed_policy_list = sanitize_policies_list(policies_list)
        md_list = sanitize_policies_list_for_md(fixed_policy_list)
        return md_list, policies_list, fixed_policy_list


    def endpoint_quarantine(token, endpoint, action):
        action_type = 'Quarantine' if action == 'Add' else 'Undo'
        computer_id = get_id_by_endpoint(token, endpoint)
        command_id = quarantine(token, computer_id, action_type)
        return command_id


    def get_location_list(token, group_id):
        url = 'sepm/api/v1/groups/{}/locations'.format(group_id)
        url_resp = do_get(token, False, url)
        location_ids = map(lambda location_string: {'ID': location_string.split('/')[-1]}, url_resp)
        return url_resp, location_ids


    def get_id_by_endpoint(token, endpoint):
        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)
        return computer_id


    def scan_endpoint(token, endpoint, scan_type):
        computer_id = get_id_by_endpoint(token, endpoint)
        command_id = scan(token, computer_id, scan_type)
        return command_id


    def update_endpoint_content(token, endpoint):
        computer_id = get_id_by_endpoint(token, endpoint)
        command_id = update_content(token, computer_id)
        return command_id


    # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    COMMANDS    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    def system_info_command(token):
        insecure = demisto.getParam('insecure')
        version_json = do_get(token, False, 'sepm/api/v1/version')
        avdef_json = do_get(token, False, 'sepm/api/v1/content/avdef/latest')
        system_info_json = {
            'version': version_json,
            'avdef': avdef_json
        }
        md = '## System Information\n'
        md += tableToMarkdown('Version', version_json)
        md += tableToMarkdown('AV Definitions', avdef_json)
        context = avdef_json.get('publishedBySymantec')
        if type(context) is dict:
            context = createContext(context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': system_info_json,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.ServerAVDefVersion': context
            }
        })


    def client_content_command(token):
        time_zone = demisto.getParam('timeZone')
        client_content_json, client_version, last_update_date = get_client_content(token, time_zone)
        md = '## Client Content, last updated on {0}\n'.format(last_update_date)
        md += tableToMarkdown('Client Content Versions', client_version)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': client_content_json,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.ClientContentVersions': client_version,
                'SEPM.LastUpdated': last_update_date
            }
        })


    def endpoints_info_command(token):
        computer_name = demisto.getArg('computerName')
        last_update = demisto.getArg('lastUpdate')
        os = demisto.getArg('os')
        page_size = demisto.getArg('pageSize')
        columns = demisto.getArg('columns')
        filtered_json_response, entry_context = get_endpoints_info(token, computer_name, last_update, os, page_size, columns)
        columns_list = choose_columns(columns, ENDPOINTS_INFO_DEFAULT_COLUMNS)
        md = create_endpints_filter_string(computer_name, last_update, os, page_size)
        md += tableToMarkdown('Endpoints', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': filtered_json_response,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Endpoint(val.Hostname: == obj.Hostname:)': createContext(entry_context, removeNull=True)
            }
        })


    def groups_info_command(token):
        columns = demisto.getArg('columns')
        filtered_json_response, json_res, sepm_groups = get_groups_info(token, columns)
        columns_list = choose_columns(columns, GROUPS_INFO_DEFAULT_COLUMNS)
        md = tableToMarkdown('Groups Information', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': json_res,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext':
                {
                    'SEPM.Groups': sepm_groups
                }
        })


    def command_status(token):
        command_id = demisto.getArg('commandId')
        cmd_status_detail, message = get_command_status(token, command_id)
        md = '### Command ID: {0}\n'.format(command_id)
        md += '### State ID: {0}\n'.format(cmd_status_detail.get('stateId'))
        md += '### ' + message;
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_detail,
                'commandId': command_id
            },
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_detail, 'CommandID': command_id}, removeNull=True)
            }
        })


    def list_policies_command(token):
        md_list, policies_list, fixed_policy_list = get_list_of_policies(token)
        md = tableToMarkdown('List of existing policies', md_list, ['Policy Name', 'Type', 'ID', 'Enabled', 'Assigned', 'Description'])
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': policies_list,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.PoliciesList': createContext(fixed_policy_list, removeNull=True)
            }
        })


    def assign_policie_command(token):
        group_id = demisto.getArg('groupID')
        locatoion_id = demisto.getArg('locationID')
        policy_type = demisto.getArg('policyType').lower()
        policy_id = demisto.getArg('policyID')
        resp = do_put(token, 'sepm/api/v1/groups/{0}/locations/{1}/policies/{2}'.format(group_id, locatoion_id, policy_type), {'id': policy_id})
        md = '### Policy: {0}, of type: {1}, was assigned to location: {2}, in group: {3}'.format(policy_id, policy_type, locatoion_id, group_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': '',
            'HumanReadable': md,
            'EntryContext': {}
        })


    def list_locations_command(token):
        group_id = demisto.getArg('groupID')
        url_resp, location_ids = get_location_list(token, group_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': url_resp,
            'HumanReadable': tableToMarkdown('Locations', map(lambda location: {'Location ID': location.get('ID')}, location_ids)),
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Locations': location_ids
            }
        })


    def endpoint_quarantine_command(token):
        endpoint = demisto.getArg('endpoint')
        action = demisto.getArg('actionType')
        command_id = endpoint_quarantine(token, endpoint, action)
        message = '### Initiated quarantine for endpoint {0}. Command ID: {1}.'.format(endpoint, command_id) if action == 'Add' else '### Removing endpoint: {0} from quarantine. Command ID: {1}.'.format(
            endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Action': action,
            'Endpoint': endpoint
        }
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Quarantine': context
            }
        })


    def scan_endpoint_command(token):
        endpoint = demisto.getArg('endpoint')
        scan_type = demisto.getArg('scanType')
        command_id = scan_endpoint(token, endpoint, scan_type)
        message = '### Initiated scan on endpoint: {0} with type: {1}. Command ID: {2}.'.format(endpoint, scan_type, command_id)
        context = {
            'CommandID': command_id,
            'Type': scan_type,
            'Endpoint': endpoint
        }
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Scan': context
            }
        })


    def update_endpoint_content_command(token):
        endpoint = demisto.getArg('endpoint')
        command_id = update_endpoint_content(token, endpoint)
        message = '### Updating endpoint: {0}. Command ID: {1}.'.format(endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Endpoint': endpoint
        }
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Update': context
            }
        })


    def move_client_to_group(token, group_id, hardware_key):
        body = [{
            'group': {
                'id': group_id
            },
            'hardwareKey': hardware_key
        }]
        response = do_patch(token, 'sepm/api/v1/computers', body)
        message = '### Moved client to requested group successfully' \
            if response[0].get('responseCode') == '200' \
            else '### Error moving client'
        return response, message


    def move_client_to_group_command(token):
        group_id = demisto.getArg('groupID')
        hardware_key = demisto.getArg('hardwareKey')
        response, message = move_client_to_group(token, group_id, hardware_key)
        demisto.results(
            {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['text'],
                'Contents': response,
                'HumanReadable': message,
                'IgnoreAutoExtract': True,
            })


    # @@@@@@@@@@@@@@@@@@@@@@@@@@    COMMANDS SWITCH    @@@@@@@@@@@@@@@@@@@@@@@@@@
    current_command = demisto.command()
    try:
        '''
        Before EVERY command the following tow lines are performed (do_auth and get_token_from_response)
        '''
        resp = do_auth(server=demisto.getParam('server'), crads=demisto.getParam('authentication'), insecure=demisto.getParam('insecure'))
        token = get_token_from_response(resp)
        if current_command == 'test-module':
            # This is the call made when pressing the integration test button.
            if token:
                demisto.results('ok')
        if current_command == 'sep-system-info':
            system_info_command(token)
        if current_command == 'sep-client-content':
            client_content_command(token)
        if current_command == 'sep-endpoints-info':
            endpoints_info_command(token)
        if current_command == 'sep-groups-info':
            groups_info_command(token)
        if current_command == 'sep-command-status':
            command_status(token)
        if current_command == 'sep-list-policies':
            list_policies_command(token)
        if current_command == 'sep-assign-policy':
            assign_policie_command(token)
        if current_command == 'sep-list-locations':
            list_locations_command(token)
        if current_command == 'sep-endpoint-quarantine':
            endpoint_quarantine_command(token)
        if current_command == 'sep-scan-endpoint':
            scan_endpoint_command(token)
        if current_command == 'sep-update-endpoint-content':
            update_endpoint_content_command(token)
        if current_command == 'sep-move-client-to-group':
            move_client_to_group_command(token)
    except Exception, ex:
        demisto.results('Cannot perform the command: {}. Error: {}'.format(current_command, ex))
  type: python
image: data:image/png;base64,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
tests:
  - SymantecEndpointProtection_Test
