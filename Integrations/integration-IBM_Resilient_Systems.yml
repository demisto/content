commonfields:
  id: IBM Resilient Systems
  version: -1
name: IBM Resilient Systems
display: IBM Resilient Systems
category: Case Management
image: data:image/png;base64,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
description: Case management that enables visibility across your tools for continual
  IR improvement
configuration:
- display: Server URL (e.g. 192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Organization name
  name: org
  defaultvalue: ""
  type: 0
  required: true
- display: Do not validate server certificate (insecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import resilient
    import datetime
    import logging
    import requests
    import time
    import json
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' GLOBAL VARS '''
    SERVER=demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    ORG_NAME=demisto.params()['org']
    USERNAME=demisto.params()['credentials']['identifier']
    PASSWORD=demisto.params()['credentials']['password']
    USE_SSL = not demisto.params().get('insecure', False)

    INCIDENT_TYPE_DICT = {
        'CommunicationError': 17,
        'DenialOfService': 21,
        'ImproperDisposal:DigitalAsset': 6,
        'ImproperDisposal:documents/files': 7,
        'LostDocuments/files/records': 4,
        'LostPC/laptop/tablet': 3,
        'LostPDA/smartphone': 1,
        'LostStorageDevice/media': 8,
        'Malware': 19,
        'NotAnIssue': 23,
        'Other': 18,
        'Phishing': 22,
        'StolenDocuments/files/records': 11,
        'StolenPC/laptop/tablet': 12,
        'StolenPDA/Smartphone': 13,
        'StolenStorageDevice/media': 14,
        'SystemIntrusion': 20,
        'TBD/Unknown': 16,
        'Vendor/3rdPartyError': 15
    }

    NIST_DICT = {
        'Attrition': 2,
        'E-mail': 4,
        'External/RemovableMedia': 1,
        'Impersonation': 5,
        'ImproperUsage': 6,
        'Loss/TheftOfEquipment': 7,
        'Other': 8,
        'Web': 3
    }

    NIST_ID_DICT = {
        2: 'Attrition',
        4: 'E-mail',
        1: 'External/RemovableMedia',
        5: 'Impersonation',
        6: 'ImproperUsage',
        7: 'Loss/TheftOfEquipment',
        8: 'Other',
        3: 'Web'
    }

    SEVERITY_CODE_DICT = {
        50: 'Low',
        51: 'Medium',
        52: 'High'
    }

    RESOLUTION_DICT = {
        53: 'Unresolved',
        54: 'Duplicate',
        55: 'Not an Issue',
        56: 'Resolved'
    }

    EXP_TYPE_ID_DICT = {
        1: 'Unknown',
        2: 'ExternalParty',
        3: 'Individual'
    }

    ''' HELPER FUNCTIONS '''
    def normalize_timestamp(timestamp):
        ''' Converts epoch timestamp to human readable timestamp '''
        return datetime.datetime.fromtimestamp(timestamp/1000.0).strftime('%Y-%m-%dT%H:%M:%SZ')

    def date_to_timestamp(date):
        return int(time.mktime(time.strptime(date, '%Y-%m-%dT%H:%M:%SZ'))*1000)

    def prettify_incidents(incidents):
        users = get_users()
        phases = get_phases()['entities']
        for incident in incidents:
            incident['id'] = str(incident['id'])
            if isinstance(incident['description'], unicode):
                incident['description'] = incident['description'].replace('<div>', '').replace('</div>', '')
            incident['discovered_date'] = normalize_timestamp(incident['discovered_date'])
            incident['created_date'] = normalize_timestamp(incident['create_date'])
            incident.pop('create_date', None)
            incident.pop('inc_training', None)
            incident.pop('plan_status', None)
            for user in users:
                if incident['owner_id'] == user['id']:
                    incident['owner'] = user['fname'] + ' ' + user['lname']
                    incident.pop('owner_id', None)
                    break
            for phase in phases:
                if incident['phase_id'] == phase['id']:
                    incident['phase'] = phase['name']
                    incident.pop('phase_id', None)
                    break
            if incident['severity_code']:
                incident['severity'] = SEVERITY_CODE_DICT[incident['severity_code']]
                incident.pop('severity_code', None)
            start_date = incident.get('start_date')
            if start_date:
                incident['date_occurred'] = normalize_timestamp(start_date)
                incident.pop('start_date', None)
            due_date = incident.get('due_date')
            if due_date:
                incident['due_date'] = normalize_timestamp(due_date)
            negative_pr = incident.get('negative_pr_likely')
            if negative_pr:
                incident['negative_pr'] = negative_pr
                incident.pop('negative_pr_likely', None)
            exposure_type_id = incident.get('exposure_type_id')
            if exposure_type_id:
                incident['exposure_type'] = EXP_TYPE_ID_DICT[exposure_type_id]
                incident.pop('exposure_type_id', None)
            nist_attack_vectors = incident.get('nist_attack_vectors')
            if nist_attack_vectors:
                translated_nist = []
                for vector in nist_attack_vectors:
                    translated_nist.append(NIST_ID_DICT[vector])
                incident['nist_attack_vectors'] = translated_nist
        return incidents


    ''' FUNCTIONS '''
    def search_incidents_command(args):
        incidents = search_incidents(args)
        if incidents:
            pretty_incidents = prettify_incidents(incidents)
            result_incidents = createContext(pretty_incidents, id=None, keyTransform=underscoreToCamelCase, removeNull=True)
            ec = {
                'Resilient.Incidents(val.Id && val.Id === obj.Id)': result_incidents
            }
            title = 'Resilient Systems Incidents'
            entry = {
                'Type': entryTypes['note'],
                'Contents': incidents,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, result_incidents, headers=['Id', 'Name', 'CreatedDate', 'DiscoveredDate', 'Owner', 'Phase'], removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found.'
        return entry

    def search_incidents(args):
        conditions = []
        if 'severity' in args:
            value = []
            severity = args['severity'].split(',')
            if 'Low' in severity:
                value.append(50)
            if 'Medium' in severity:
                value.append(51)
            if 'High' in severity:
                value.append(52)
            if not value:
                raise Exception('Severity should be given in capital case and comma separated, e.g. Low,Medium,High')
            conditions.append({
                'field_name': 'severity_code',
                'method': 'in',
                'value': value
            })
        if 'date-created-before' in args:
            value = date_to_timestamp(args['date-created-before'])
            conditions.append({
                'field_name': 'create_date',
                'method': 'lte',
                'value': value
            })
        elif 'date-created-after' in args:
            value = date_to_timestamp(args['date-created-after'])
            conditions.append({
                'field_name': 'create_date',
                'method': 'gte',
                'value': value
            })
        elif 'date-created-within-the-last' in args:
            if not 'timeframe' in args:
                raise Exception('Timeframe was not given.')
            within_the_last = int(args['date-created-within-the-last'])
            now = int(time.time())
            timeframe = args['timeframe']
            if timeframe == 'days':
                from_time = now - (60 * 60 * 24 * within_the_last)
            elif timeframe == 'hours':
                from_time = now - (60 * 60 * within_the_last)
            elif timeframe == 'minutes':
                from_time = now - (60 * within_the_last)
            conditions.extend(({
                'field_name': 'create_date',
                'method': 'lte',
                'value': now*1000
            },
            {
                'field_name': 'create_date',
                'method': 'gte',
                'value': from_time*1000
            }))
        if 'date-occurred-before' in args:
            value = date_to_timestamp(args['date-occurred-before'])
            conditions.append({
                'field_name': 'start_date',
                'method': 'lte',
                'value': value
            })
        elif 'date-occurred-after' in args:
            value = date_to_timestamp(args['date-occurred-after'])
            conditions.append({
                'field_name': 'start_date',
                'method': 'gte',
                'value': value
            })
        elif 'date-occurred-within-the-last' in args:
            if not 'timeframe' in args:
                raise Exception('Timeframe was not given.')
            within_the_last = int(args['date-occurred-within-the-last'])
            now = int(time.time())
            timeframe = args['timeframe']
            if timeframe == 'days':
                from_time = now - (60 * 60 * 24 * within_the_last)
            elif timeframe == 'hours':
                from_time = now - (60 * 60 * within_the_last)
            elif timeframe == 'minutes':
                from_time = now - (60 * within_the_last)
            conditions.extend(({
                'field_name': 'start_date',
                'method': 'lte',
                'value': now*1000
            },
            {
                'field_name': 'start_date',
                'method': 'gte',
                'value': from_time*1000
            }))
        if 'incident-type' in args:
            type_id = INCIDENT_TYPE_DICT[args['incident-type']]
            conditions.append({
                'field_name': 'incident_type_ids',
                'method': 'contains',
                'value': [type_id]
            })
        if 'nist' in args:
            nist = NIST_DICT[args['nist']]
            conditions.append({
                'field_name': 'nist_attack_vectors',
                'method': 'contains',
                'value': [nist]
            })
        if 'status' in args:
            status = 'A' if args['status'] == 'Active' else 'C'
            conditions.append({
                'field_name': 'plan_status',
                'method': 'in',
                'value': [status]
            })
        if 'due-in' in args:
            if not 'timeframe' in args:
                raise Exception('Timeframe was not given.')
            within_the_last = int(args['due-in'])
            now = int(time.time())
            timeframe = args['timeframe']
            if timeframe == 'days':
                to_time = now + (60 * 60 * 24 * within_the_last)
            elif timeframe == 'hours':
                to_time = now + (60 * 60 * within_the_last)
            elif timeframe == 'minutes':
                to_time = now + (60 * within_the_last)
            conditions.extend(({
                'field_name': 'due_date',
                'method': 'lte',
                'value': to_time*1000
            },
            {
                'field_name': 'due_date',
                'method': 'gte',
                'value': now*1000
            }))
        data = {
            'filters': [{
                'conditions': conditions
            }]
        }
        response = client.post('/incidents/query', data)
        return response

    def update_incident_command(args):
        if len(args.keys()) == 1:
            raise Exception('No fields to update were given')
        incident_id = args['incident-id']
        incident = get_incident(incident_id)
        changes = []
        if 'severity' in args:
            old_value = incident['severity_code']
            severity = args['severity']
            if severity == 'Low':
                new_value = 50
            elif severity == 'Medium':
                new_value = 51
            elif severity == 'High':
                new_value = 52
            changes.append({
                'field': 'severity_code',
                'old_value': {
                    'id': old_value
                },
                'new_value': {
                    'id': new_value
                }
            })
        if 'owner' in args:
            users = get_users()
            old_value = incident['owner_id']
            full_name = args['owner'].split(' ')
            first_name, last_name = full_name[0], full_name[1]
            new_value = -1
            for user in users:
                if first_name == user['fname'] and last_name == user['lname']:
                    new_value = user['id']
                    break
            if new_value == -1:
                raise Exception('User was not found')
            changes.append({
                'field': 'owner_id',
                'old_value': {
                    'id': old_value
                },
                'new_value': {
                    'id': new_value
                }
            })
        if 'incident-type' in args:
            old_value = incident['incident_type_ids']
            type_id = INCIDENT_TYPE_DICT[args['incident-type']]
            new_value = old_value[:]
            new_value.append(type_id)
            changes.append({
                'field': 'incident_type_ids',
                'old_value': {
                    'ids': old_value
                },
                'new_value': {
                    'ids': new_value
                }
            })
        if 'nist' in args:
            old_value = incident['nist_attack_vectors']
            nist_id = nist_to_id(args['nist'])
            new_value = old_value[:]
            new_value.append(nist_id)
            changes.append({
                'field': 'nist_attack_vectors',
                'old_value': {
                    'ids': old_value
                },
                'new_value': {
                    'ids': new_value
                }
            })
        if 'resolution' in args:
            old_value = incident['resolution_id']
            new_value = resolution_to_id(args['resolution'])
            changes.append({
                'field': 'resolution_id',
                'old_value': {
                    'id': old_value
                },
                'new_value': {
                    'id': new_value
                }
            })
        if 'resolution-summary' in args:
            old_summary = incident['resolution_summary']
            new_summary = args['resolution-summary']
            changes.append({
                'field': 'resolution_summary',
                'old_value': {
                    'textarea': {
                        'format': 'html',
                        'content': old_summary
                    }
                },
                'new_value': {
                    'textarea': {
                        'format': 'html',
                        'content': new_summary
                    }
                }
            })
        if 'description' in args:
            old_description = incident['description']
            new_description = args['description']
            changes.append({
                'field': 'description',
                'old_value': {
                    'textarea': {
                        'format': 'html',
                        'content': old_description
                    }
                },
                'new_value': {
                    'textarea': {
                        'format': 'html',
                        'content': new_description
                    }
                }
            })
        if 'name' in args:
            old_name = incident['name']
            new_name = args['name']
            changes.append({
                'field': 'name',
                'old_value': {
                    'text': old_name
                },
                'new_value': {
                    'text': new_name
                }
            })
        data = {
            'changes': changes
        }
        response = update_incident(incident_id, data)
        if response.status_code == 200:
            return 'Incident ' + args['incident-id'] + ' was updated successfully.'

    def update_incident(incident_id, data):
        response = client.patch('/incidents/' + incident_id, data)
        return response

    def get_incident_command(incident_id):
        incident = get_incident(incident_id)
        wanted_keys = ['create_date', 'discovered_date', 'description', 'due_date', 'id', 'name', 'owner_id',
                       'phase_id', 'severity_code', 'confirmed', 'employee_involved', 'negative_pr_likely',
                       'confirmed', 'start_date', 'due_date', 'negative_pr_likely', 'reporter', 'exposure_type_id',
                       'nist_attack_vectors']
        pretty_incident = dict((k, incident[k]) for k in wanted_keys if k in incident)
        if incident['resolution_id']:
            pretty_incident['resolution'] = RESOLUTION_DICT[incident['resolution_id']]
        if incident['resolution_summary']:
            pretty_incident['resolution_summary'] = incident['resolution_summary'].replace('<div>', '').replace('</div>', '')
        pretty_incident = prettify_incidents([pretty_incident])
        result_incident = createContext(pretty_incident, id=None, keyTransform=underscoreToCamelCase, removeNull=True)
        ec = {
            'Resilient.Incidents(val.Id && val.Id === obj.Id)': result_incident
        }
        hr_incident = result_incident[:]
        if hr_incident[0]['NistAttackVectors']:
            nist_vectors_str = ''
            for vector in hr_incident[0]['NistAttackVectors']:
                nist_vectors_str += vector + '\n'
            hr_incident[0]['NistAttackVectors'] = nist_vectors_str
        title = 'IBM Resilient Systems incident ID ' + incident_id
        entry = {
            'Type': entryTypes['note'],
            'Contents': incident,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr_incident, headers = ['Id', 'Name', 'Description', 'NistAttackVectors', 'Phase', 'Resolution', 'ResolutionSummary', 'Owner',
                                                                            'CreatedDate', 'DateOccurred', 'DiscoveredDate', 'DueDate', 'NegativePr', 'Confirmed', 'ExposureType',
                                                                            'Severity', 'Reporter']),
            'EntryContext': ec
        }
        return entry

    def get_incident(incident_id):
        response = client.get('/incidents/' + incident_id)
        return response

    def list_open_incidents():
        response = client.get('/incidents/open')
        return response

    def get_members_command(incident_id):
        response = get_members(incident_id)['members']
        incident = get_incident(incident_id)
        response.append(incident['owner_id'])
        users = get_users()
        members = []
        for user in users:
            if user['id'] in response:
                members.append({
                    'FirstName': user['fname'],
                    'LastName': user['lname'],
                    'ID': user['id'],
                    'Email': user['email']
                })

        ec = {
            'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                'Id': incident_id,
                'Members': members
            }
        }
        title = 'Members of incident ' + incident_id
        entry = {
            'Type': entryTypes['note'],
            'Contents': members,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, members, ['ID', 'LastName', 'FirstName', 'Email']),
            'EntryContext': ec
        }
        return entry

    def get_members(incident_id):
        response = client.get('/incidents/' + incident_id + '/members')
        return response

    def get_users_command():
        response = get_users()
        users = []
        for user in response:
            users.append({
                'FirstName': user['fname'],
                'LastName': user['lname'],
                'ID': user['id'],
                'Email': user['email']
            })

        title = 'IBM Resilient Systems Users'
        entry = {
            'Type': entryTypes['note'],
            'Contents': users,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, users, ['ID', 'LastName', 'FirstName', 'Email'])
        }
        return entry

    def get_users():
        response = client.get('/users')
        return response

    def get_phases():
        response = client.get('/phases')
        return response

    def get_tasks_command(incident_id):
        response = get_tasks(incident_id)
        if response:
            tasks = []
            for task in response:
                task_object = {}
                incident_name = task['inc_name']
                task_object['ID'] = task['id']
                task_object['Name'] = task['name']
                if task['due_date']:
                    task_object['DueDate'] = normalize_timestamp(task['due_date'])
                task_object['Status'] = 'Open' if task['status'] == 'O' else 'Closed'
                task_object['Required'] = task['required']
                if task['form']:
                    task_object['Form'] = task['form']
                if task['user_notes']:
                    task_object['UserNotes'] = task['user_notes']
                task_object['Creator'] = task['creator']['fname'] + ' ' + task['creator']['lname']
                task_object['Category'] = task['cat_name']
                if task['instr_text']:
                    task_object['Instructions'] = task['instr_text']
                tasks.append(task_object)
            ec = {
                'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                    'Id': incident_id,
                    'Name': incident_name,
                    'Tasks': tasks
                }
            }
            title = 'Incident ' + incident_id + ' tasks'
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, tasks, ['ID', 'Name', 'Category', 'Form', 'Status', 'DueDate', 'Instructions', 'UserNotes', 'Required', 'Creator']),
                'EntryContext': ec
            }
        else:
            entry = 'No tasks found for this incident.'
        return entry

    def get_tasks(incident_id):
        response = client.get('/incidents/' + incident_id + '/tasks')
        return response

    def set_member_command(incident_id, members):
        members = [int(x) for x in members.split(',')]
        incident = get_incident(incident_id)
        incident_version = incident['vers']
        data = {
            'vers': incident_version,
            'members': members
        }
        response = set_member(incident_id, data)
        users = get_users()
        response = []
        for user in users:
            if user['id'] in members:
                response.append({
                    'FirstName': user['fname'],
                    'LastName': user['lname'],
                    'ID': user['id'],
                    'Email': user['email']
                })
        ec = {
            'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                'Id': incident_id,
                'Members': response
            }
        }
        title = 'Members of incident ' + incident_id
        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, response),
            'EntryContext': ec
        }
        return entry

    def set_member(incident_id, data):
        response = client.put('/incidents/' + incident_id + '/members', data)
        return response

    def close_incident_command(incident_id):
        incident = get_incident(incident_id)
        if not incident['resolution_id'] or not incident['resolution_summary']:
            return 'Resolution and resolution summary of the incident should be updated before closing an incident.'
        response = close_incident(incident_id, incident)
        if response.status_code == 200:
            return 'Incident ' + incident_id + ' was closed.'

    def close_incident(incident_id, incident):
        old_status = incident['plan_status']
        data = {
            'changes': [{
                'field': 'plan_status',
                'old_value': {
                    'text': old_status
                },
                'new_value': {
                    'text': 'C'
                }
            }]
        }
        return update_incident(incident_id, data)

    def create_incident_command(args):
        incident_name = args['name']
        data = {
            "name": incident_name,
            "discovered_date": 0
        }
        response = create_incident(data)
        hr = {
            'ID': response['id'],
            'Name': incident_name
        }
        ec = {
            'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                'Id': response['id'],
                'Name': incident_name
            }
        }
        title = 'Incident ' + incident_name + ' was created'
        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr),
            'EntryContext': ec
        }
        return entry

    def create_incident(data):
        response = client.post('/incidents', data)
        return response

    def incident_artifacts_command(incident_id):
        response = incident_artifacts(incident_id)
        if response:
            users = get_users()
            ec_artifacts = []
            hr_artifacts = []
            for artifact in response:
                incident_name = artifact['inc_name']
                artifact_object = {
                    'ID': artifact['id'],
                    'Type': get_artifact_type(artifact['type']),
                    'Value': artifact['value'],
                    'CreatedDate': normalize_timestamp(artifact['created']),
                    'Creator': artifact['creator']['fname'] + artifact['creator']['lname']
                }
                if artifact['description']:
                    artifact_object['Description'] = artifact['description']
                hr_artifact = dict(artifact_object)
                if artifact['attachment']:
                    artifact_object['Attachments'] = {}
                    attachment_string = ''
                    artifact_object['Attachments']['ID'] = artifact['attachment']['id']
                    attachment_string += 'ID: ' + str(artifact_object['Attachments']['ID']) + '\n'
                    artifact_object['Attachments']['Name'] = artifact['attachment']['name']
                    attachment_string += 'Name: ' + artifact_object['Attachments']['Name'] + '\n'
                    artifact_object['Attachments']['CreatedDate'] = normalize_timestamp(artifact['attachment']['created'])
                    attachment_string += 'Created Date: ' + artifact_object['Attachments']['CreatedDate'] + '\n'
                    artifact_object['Attachments']['ContentType'] = artifact['attachment']['content_type']
                    attachment_string += 'Content Type : ' + artifact_object['Attachments']['ContentType'] + '\n'
                    artifact_object['Attachments']['Size'] = artifact['attachment']['size']
                    attachment_string += 'Size: ' + str(artifact_object['Attachments']['Size']) + '\n'
                    creator_id = artifact['attachment']['creator_id']
                    for user in users:
                        if creator_id == user['id']:
                            artifact_object['Attachments']['Creator'] = user['fname'] + ' ' + user['lname']
                            attachment_string += 'Creator: ' + artifact_object['Attachments']['Creator']
                            break
                    hr_artifact['Attachments'] = attachment_string
                hr_artifacts.append(hr_artifact)
                ec_artifacts.append(artifact_object)
            ec = {
                'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                    'Id': incident_id,
                    'Name': incident_name,
                    'Artifacts': ec_artifacts
                }
            }
            title = 'Incident ' + incident_id + ' artifacts'
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, hr_artifacts, headers=['ID', 'Value', 'Description', 'CreatedDate', 'Creator']),
                'EntryContext': ec
            }
        else:
            entry = 'No artifacts found.'
        return entry

    def incident_artifacts(incident_id):
        response = client.get('/incidents/' + incident_id + '/artifacts')
        return response

    def get_artifact_type(artifact_id):
        response = client.get('/artifact_types/' + str(artifact_id))
        return response['name']

    def incident_attachments_command(incident_id):
        response = incident_attachments(incident_id)
        if response:
            attachments = []
            users = get_users()
            for attachment in response:
                incident_name = attachment['inc_name']
                attachment_object = {}
                attachment_object['ID'] = attachment['id']
                attachment_object['Name'] = attachment['name']
                attachment_object['CreatedDate'] = normalize_timestamp(attachment['created'])
                attachment_object['Size'] = attachment['size']
                attachment_object['ContentType'] = attachment['content_type']
                attachment_object['Name'] = attachment['name']
                for user in users:
                    if attachment['creator_id'] == user['id']:
                        attachment_object['Creator'] = user['fname'] + ' ' + user['lname']
                    if attachment['inc_owner'] == user['id']:
                        incident_owner = user['fname'] + ' ' + user['lname']
                attachments.append(attachment_object)
            ec = {
                'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                    'Id': incident_id,
                    'Name': incident_name,
                    'Owner': incident_owner,
                    'Attachments': attachments
                }
            }
            title = 'Incident ' + incident_id + ' attachments'
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, attachments),
                'EntryContext': ec
            }
        else:
            entry = 'No attachments found.'
        return entry

    def incident_attachments(incident_id):
        response = client.get('/incidents/' + incident_id + '/attachments')
        return response

    def related_incidents_command(incident_id):
        response = related_incidents(incident_id)['incidents']
        if response:
            ec_incidents = []
            hr_incidents = []
            for incident in response:
                incident_object = {
                    'ID': incident['id'],
                    'Name': incident['name'],
                    'Status': 'Active' if incident['plan_status'] == 'A' else 'Closed',
                    'CreatedDate': normalize_timestamp(incident['create_date']),
                }
                hr_incident = dict(incident_object)
                if incident['artifacts']:
                    hr_incident['Artifacts'] = ''
                    artifacts = []
                    for artifact in incident['artifacts']:
                        artifact_object = {}
                        artifact_string = ''
                        artifact_object['ID'] = artifact['id']
                        artifact_string += 'ID: ' + str(artifact_object['ID']) + '\n'
                        artifact_object['CreatedDate'] = normalize_timestamp(artifact['created'])
                        artifact_string += 'Created Date: ' + artifact_object['CreatedDate'] + '\n'
                        if artifact['description']:
                            artifact_object['Description'] = artifact['description']
                            artifact_string += 'Description: ' + artifact_object['Description'] + '\n'
                        artifact_object['Creator'] = artifact['creator']['fname'] + ' ' + artifact['creator']['lname']
                        artifact_string += 'Creator: ' + artifact_object['Creator'] + '\n'
                        hr_incident['Artifacts'] += artifact_string
                        artifacts.append(artifact_object)
                    incident_object['Artifacts'] = artifacts
                hr_incidents.append(hr_incident)
                ec_incidents.append(incident_object)
            ec = {
                'Resilient.Incidents(val.Id && val.Id === obj.Id)': {
                    'Id': incident_id,
                    'Related': ec_incidents
                }
            }
            title = 'Incident ' + incident_id + ' related incidents'
            entry = {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, hr_incidents),
                'EntryContext': ec
            }
        else:
            entry = 'No related incidents found.'
        return entry

    def related_incidents(incident_id):
        response = client.get('/incidents/' + incident_id + '/related_ex?want_artifacts=true')
        return response

    def fetch_incidents():
        now = int(time.time())
        last_run = demisto.getLastRun() and demisto.getLastRun()['time']
        if not last_run:
            now -= 600 # In the first run, fetch incidents from the last 10 minutes
            last_run = now
        args = {'date-created-after': normalize_timestamp(last_run*1000)}
        resilient_incidents = search_incidents(args)
        incidents = []
        for incident in resilient_incidents:
            artifacts = incident_artifacts(str(incident['id']))
            if artifacts:
                incident['artifacts'] = artifacts
            attachments = incident_attachments(str(incident['id']))
            if attachments:
                incident['attachments'] = attachments
            demisto_incident = {}
            if isinstance(incident['description'], unicode):
                incident['description'] = incident['description'].replace('<div>', '').replace('</div>', '')
            incident['discovered_date'] = normalize_timestamp(incident['discovered_date'])
            incident['create_date'] = normalize_timestamp(incident['create_date'])
            demisto_incident['name'] = 'IBM Resilient Systems incident ID ' + str(incident['id'])
            demisto_incident['occurred'] = incident['create_date']
            demisto_incident['rawJSON'] = json.dumps(incident)
            incidents.append(demisto_incident)

        demisto.incidents(incidents)
        demisto.setLastRun({'time': now})

    ''' EXECUTION CODE '''
    client = resilient.get_client({
        'email': USERNAME,
        'password': PASSWORD,
        'host': SERVER,
        'cafile': 'true' if USE_SSL else 'false',
        'org': ORG_NAME
        })

    # Disable SDK logging warning messages
    logger = logging.getLogger('resilient')
    logger.propagate = False

    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-module':
            # Checks if there is an authenticated session
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() == 'rs-search-incidents':
            demisto.results(search_incidents_command(demisto.args()))
        elif demisto.command() == 'rs-update-incident':
            demisto.results(update_incident_command(demisto.args()))
        elif demisto.command() == 'rs-incidents-get-members':
            demisto.results(get_members_command(demisto.args()['incident-id']))
        elif demisto.command() == 'rs-get-incident':
            demisto.results(get_incident_command(demisto.args()['incident-id']))
        elif demisto.command() == 'rs-incidents-update-member':
            demisto.results(set_member_command(demisto.args()['incident-id'], demisto.args()['members']))
        elif demisto.command() == 'rs-incidents-get-tasks':
            demisto.results(get_tasks_command(demisto.args()['incident-id']))
        elif demisto.command() == 'rs-get-users':
            demisto.results(get_users_command())
        elif demisto.command() == 'rs-close-incident':
            demisto.results(close_incident_command(demisto.args()['incident-id']))
        elif demisto.command() == 'rs-create-incident':
            demisto.results(create_incident_command(demisto.args()))
        elif demisto.command() == 'rs-incident-artifacts':
            demisto.results(incident_artifacts_command(demisto.args()['incident-id']))
        elif demisto.command() == 'rs-incident-attachments':
            demisto.results(incident_attachments_command(demisto.args()['incident-id']))
        elif demisto.command() == 'rs-related-incidents':
            demisto.results(related_incidents_command(demisto.args()['incident-id']))

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
  commands:
  - name: rs-search-incidents
    arguments:
    - name: severity
      description: Incident severity comma separated, e.g. Low,Medium,High
    - name: date-created-before
      description: Created date of the incident before given date in format YYYY-MM-DDTHH:MM:SSZ,
        e.g. 2018-05-07T10:59:07Z
    - name: date-created-after
      description: Created date of the incident after given date in format YYYY-MM-DDTHH:MM:SSZ,
        e.g. 2018-05-07T10:59:07Z
    - name: date-created-within-the-last
      description: Created date of the incident within the last time frame (days/hours/minutes).
        Should be given a number, along with with the timeframe argument.
    - name: timeframe
      auto: PREDEFINED
      predefined:
      - days
      - hours
      - minutes
      description: 'Time frame to search within for incident. Should be given with
        within-the-last/due-in argument. '
    - name: date-occurred-within-the-last
      description: Occurred date of the incident within the last time frame (days/hours/minutes).
        Should be given a number, along with with the timeframe argument.
    - name: date-occurred-before
      description: Occurred date of the incident before given date in format YYYY-MM-DDTHH:MM:SSZ,
        e.g. 2018-05-07T10:59:07Z
    - name: date-occurred-after
      description: Occurred date of the incident after given date in format YYYY-MM-DDTHH:MM:SSZ,
        e.g. 2018-05-07T10:59:07Z
    - name: incident-type
      auto: PREDEFINED
      predefined:
      - CommunicationError
      - DenialOfService
      - ImproperDisposal:DigitalAsset
      - ImproperDisposal:documents/files
      - LostDocuments/files/records
      - LostPC/laptop/tablet
      - LostPDA/smartphone
      - LostStorageDevice/media
      - Malware
      - NotAnIssue
      - Other
      - Phishing
      - StolenDocuments/files/records
      - StolenPC/laptop/tablet
      - StolenPDA/Smartphone
      - StolenStorageDevice/media
      - SystemIntrusion
      - TBD/Unknown
      - Vendor/3rdPartyError
      description: Incident type
    - name: nist
      auto: PREDEFINED
      predefined:
      - Attrition
      - E-mail
      - External/RemovableMedia
      - Impersonation
      - ImproperUsage
      - Loss/TheftOfEquipment
      - Other
      - Web
      description: NIST Attack Vectors
    - name: status
      auto: PREDEFINED
      predefined:
      - Active
      - Closed
      description: Incident status
    - name: due-in
      description: Due date of the incident in given timeframe (days/hours/minutes).
        Should be given a number, along with with the timeframe argument.
    outputs:
    - contextPath: Resilient.Incidents.CreateDate
      description: Created date of the incident
      type: string
    - contextPath: Resilient.Incidents.Name
      description: Incident name
      type: string
    - contextPath: Resilient.Incidents.DiscoveredDate
      description: Discovered date of the incident
      type: string
    - contextPath: Resilient.Incidents.Id
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Phase
      description: Incident Phase
      type: string
    - contextPath: Resilient.Incidents.Severity
      description: Incident severity
      type: string
    - contextPath: Resilient.Incidents.Description
      description: Incident description
      type: string
    description: Query for incidents
  - name: rs-update-incident
    arguments:
    - name: incident-id
      required: true
      description: Incident ID to update
    - name: severity
      auto: PREDEFINED
      predefined:
      - Low
      - Medium
      - High
      description: Severity to update
    - name: owner
      description: User full name to set as incident owner, e.g. Steve Jobs
    - name: incident-type
      auto: PREDEFINED
      predefined:
      - CommunicationError
      - DenialOfService
      - ImproperDisposal:DigitalAsset
      - ImproperDisposal:documents/files
      - LostDocuments/files/records
      - LostPC/laptop/tablet
      - LostPDA/smartphone
      - LostStorageDevice/media
      - Malware
      - NotAnIssue
      - Other
      - Phishing
      - StolenDocuments/files/records
      - StolenPC/laptop/tablet
      - StolenPDA/Smartphone
      - StolenStorageDevice/media
      - SystemIntrusion
      - TBD/Unknown
      - Vendor/3rdPartyError
      description: Incident type (added to the current incident types list)
    - name: resolution
      auto: PREDEFINED
      predefined:
      - Unresolved
      - Duplicate
      - NotAnIssue
      - Resolved
      description: Incident resolution
    - name: resolution-summary
      description: Incident resolution summary
    - name: description
      description: Incident description
    - name: name
      description: Incident name
    - name: nist
      auto: PREDEFINED
      predefined:
      - Attrition
      - E-mail
      - External/RemovableMedia
      - Impersonation
      - ImproperUsage
      - Loss/TheftOfEquipment
      - Other
      - Web
      description: NIST Attack Vectors (added to the current list of NIST attack vectors)
    description: Updates incidents.
  - name: rs-incidents-get-members
    arguments:
    - name: incident-id
      required: true
      description: Incident ID to get members of
    outputs:
    - contextPath: Resilient.Incidents.ID
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Members.FirstName
      description: Member's first name
      type: string
    - contextPath: Resilient.Incidents.Members.LastName
      description: Member's last name
      type: string
    - contextPath: Resilient.Incidents.Members.ID
      description: Member's ID
      type: number
    - contextPath: Resilient.Incidents.Members.Email
      description: Member's email address
      type: string
    description: Gets members of the incident.
  - name: rs-get-incident
    arguments:
    - name: incident-id
      required: true
      description: ID of incident to get
    outputs:
    - contextPath: Resilient.Incidents.CreateDate
      description: Created date of the incident
      type: string
    - contextPath: Resilient.Incidents.Name
      description: Incident name
      type: string
    - contextPath: Resilient.Incidents.Resolution
      description: Incident resolution
      type: string
    - contextPath: Resilient.Incidents.DiscoveredDate
      description: Discovered date of the incident
      type: string
    - contextPath: Resilient.Incidents.ResolutionSummary
      description: Incident resolution summary
      type: string
    - contextPath: Resilient.Incidents.Id
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Phase
      description: Incident Phase
      type: string
    - contextPath: Resilient.Incidents.Severity
      description: Incident severity
      type: string
    - contextPath: Resilient.Incidents.Description
      description: Incident description
      type: string
    - contextPath: Resilient.Incidents.Confirmed
      description: Incident cofirmation
      type: boolean
    - contextPath: Resilient.Incidents.NegativePr
      description: Negative PR likely
      type: boolean
    - contextPath: Resilient.Incidents.DateOccurred
      description: Date occurred of incident
      type: string
    - contextPath: Resilient.Incidents.Reporter
      description: Name of reporting individual
      type: string
    - contextPath: Resilient.Incidents.NistAttackVectors
      description: Incident NIST attack vectors
    description: Gets an individual incident by ID
  - name: rs-incidents-update-member
    arguments:
    - name: incident-id
      required: true
      description: 'Incident ID to set its members '
    - name: members
      required: true
      description: Members IDs to set comma separated, e.g. 1,2,3
    description: Updates the incident's members.
  - name: rs-get-users
    arguments: []
    description: Gets a list of all users in the system.
  - name: rs-close-incident
    arguments:
    - name: incident-id
      required: true
      default: true
      description: ID of incident to close
    description: Closes an incident
  - name: rs-create-incident
    arguments:
    - name: name
      required: true
      description: Incident name
    description: Creates an incident
  - name: rs-incident-artifacts
    arguments:
    - name: incident-id
      required: true
      description: Incident ID to get artifacts of
    outputs:
    - contextPath: Resilient.Incidents.Id
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Name
      description: Incident name
      type: string
    - contextPath: Resilient.Incidents.Artifacts.CreatedDate
      description: Artifact created date
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Creator
      description: Artifact creator
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Description
      description: Artifact description
      type: string
    - contextPath: Resilient.Incidents.Artifacts.ID
      description: Artifact ID
      type: number
    - contextPath: Resilient.Incidents.Artifacts.Type
      description: Artifact type
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Value
      description: Artifact value
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Attachments.ContentType
      description: Attachment content type
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Attachments.CreatedDate
      description: Attachment created date
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Attachments.Creator
      description: Attachment creator
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Attachments.ID
      description: Attachment ID
      type: number
    - contextPath: Resilient.Incidents.Artifacts.Attachments.Name
      description: Attachment name
      type: string
    - contextPath: Resilient.Incidents.Artifacts.Attachments.Size
      description: Attachment size
      type: number
    description: Gets incident artifacts
  - name: rs-incident-attachments
    arguments:
    - name: incident-id
      required: true
      description: Incident ID to get attachments of
    outputs:
    - contextPath: Resilient.Incidents.Id
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Name
      description: Incident name
      type: string
    - contextPath: Resilient.Incidents.Owner
      description: Incident owner
      type: string
    - contextPath: Resilient.Incidents.Attachments.ContentType
      description: Attachment content type
      type: string
    - contextPath: Resilient.Incidents.Attachments.CreatedDate
      description: Attachment created date
      type: string
    - contextPath: Resilient.Incidents.Attachments.Creator
      description: Attachment creator
      type: string
    - contextPath: Resilient.Incidents.Attachments.ID
      description: Attachment ID
      type: number
    - contextPath: Resilient.Incidents.Attachments.Name
      description: Attachment name
      type: string
    - contextPath: Resilient.Incidents.Attachments.Size
      description: Attachment size
      type: number
    description: Gets incident attachments
  - name: rs-related-incidents
    arguments:
    - name: incident-id
      required: true
      description: Incident ID to get related incidents of
    outputs:
    - contextPath: Resilient.Incidents.Id
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Related.CreatedDate
      description: Created date of related incident
      type: string
    - contextPath: Resilient.Incidents.Related.Name
      description: Name of related incident
      type: string
    - contextPath: Resilient.Incidents.Related.ID
      description: ID of related incident
      type: number
    - contextPath: Resilient.Incidents.Related.Status
      description: Status (Active/Closed) of related incident
      type: string
    - contextPath: Resilient.Incidents.Related.Artifacts.CreatedDate
      description: Created date of artifact
      type: string
    - contextPath: Resilient.Incidents.Related.Artifacts.ID
      description: ID of artifact
      type: number
    - contextPath: Resilient.Incidents.Related.Artifacts.Creator
      description: Creator of artifact
      type: string
    description: Gets related incidents
  - name: rs-incidents-get-tasks
    arguments:
    - name: incident-id
      required: true
      description: Incident ID to get tasks of
    outputs:
    - contextPath: Resilient.Incidents.Id
      description: Incident ID
      type: string
    - contextPath: Resilient.Incidents.Name
      description: Incident name
      type: string
    - contextPath: Resilient.Incidents.Tasks.Category
      description: Task category
      type: string
    - contextPath: Resilient.Incidents.Tasks.Creator
      description: Task creator
      type: string
    - contextPath: Resilient.Incidents.Tasks.DueDate
      description: Task due date
      type: string
    - contextPath: Resilient.Incidents.Tasks.Form
      description: Task form
      type: string
    - contextPath: Resilient.Incidents.Tasks.ID
      description: Task ID
      type: string
    - contextPath: Resilient.Incidents.Tasks.Name
      description: Task name
      type: string
    - contextPath: Resilient.Incidents.Tasks.Required
      description: Task required
      type: boolean
    - contextPath: Resilient.Incidents.Tasks.Status
      description: Task status (Open/Closed)
      type: string
    description: Gets tasks of incidents
  dockerimage: demisto/resilient
  isfetch: true
  runonce: false
