commonfields:
  id: PyVirusTotal
  version: -1
name: PyVirusTotal
display: PyVirusTotal
category: Data Enrichment
image: data:image/png;base64,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
description: Analyze suspicious hashes, URLs, domains and IP addresses
detaileddescription: |-
  Don’t have a Virustotal key?
  Register at https://www.virustotal.com
  After signing in click on your user name (top right) and go to “My API Key”
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: Server
  defaultvalue: https://www.virustotal.com/vtapi/v2/
  type: 0
  required: true
- display: API Key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: useproxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Allow self-signed SSL certificates
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    import requests

    API_KEY = demisto.params()['APIKey']
    SERVER_URL = demisto.params()['Server']
    if (SERVER_URL[-1] != '/'):
        SERVER_URL += '/'

    HTTP_CMD = {
        'POST' : requests.post,
        'GET' : requests.get,
    }

    def http_get(url, data):
        return requests.get(url,
            params=data,
            headers={'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json'},
            verify=not demisto.params()['insecure'])

    def doReq(method, path, parameters):
        parameters = parameters if parameters is not None else {}
        parameters['apikey'] = API_KEY;
        url = SERVER_URL + path
        kwargs = {
            'headers' : {'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json'},
            'verify' : not demisto.params()['insecure']
        }

        if method == 'GET':
            kwargs['params'] = parameters
        elif method == 'POST':
            kwargs['data'] = parameters

        if method =='GET':
            result = http_get(url, parameters)
        else:
            result = HTTP_CMD[method](
                url,
                **kwargs
            )
        st = result.status_code

        if st < 200 or st > 299:
            raise Exception('Failed to perform request %s, request status code: %d' % (path, st, ))

        if result.json() == {} and st == 204:
            return {'statusCode': st}

        if result.json() == {}:
            raise Exception('No content received. Maybe you tried a private API?.')

        obj = None
        try:
            obj = result.json()
        except Exception as e:
            raise 'Error parsing reply - ' + result + ' - ' + e.message

        if not isinstance(obj, (list, tuple)) and obj['response_code'] != 1 and obj['response_code'] != 0:
            raise Exception('Response code: %d, message: %s' % (obj['response_code'], obj['verbose_msg'], ))

        return {'body': result.text, 'obj': obj, 'statusCode': st}


    def withRetries(waitForRateLimit, retries, reqCall, *args):
        if waitForRateLimit is not None:
            waitForRateLimit = int(waitForRateLimit)
            if waitForRateLimit == 0:
                waitForRateLimit = 60
        else:
            waitForRateLimit = 60

        if retries:
            retries = max(int(retries), 0)
        else:
            retries = 0;

        res = reqCall(*args)
        tries = 0
        while (res['statusCode'] == 204 and res['body'] and tries < retries and waitForRateLimit > 0):
            sleep(waitForRateLimit);
            tries += 1
            res = reqCall(*args)

        if (res['statusCode'] == 204 and not res['body']):
            raise 'No content received. Possible API rate limit reached.'

        return res

    def calcRecentDownloads(checks):
        badDownloads = 0
        now = datetime.now()
        for c in checks:
            if c is not None:
                for ci in c:
                    date2 = ci.get('date', '')
                    if len(date2) > 0:
                        d = datetime.strptime(date2, '%Y-%m-%d %H:%M:%S')
                        if now - d < timedelta(days=30):
                            badDownloads += 1
        return badDownloads

    def doIP(ip, longFormat, threshold, sampleSize, waitForRateLimit, retries):
        if not is_ip_valid(ip):
            return {'Type': entryTypes.error, 'Contents': 'IP - ' + ip + ' is not valid IP', 'ContentsFormat': formats.text}

        if threshold is None:
            threshold = 10;

        if sampleSize is None:
            sampleSize = 10;

        res = withRetries(waitForRateLimit, retries, doReq, 'GET', 'ip-address/report', {'ip': ip})
        o = res['obj']
        ec = {}
        if o['response_code'] == 0:
            ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res['body'], ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + ip + '\n' + o['verbose_msg']};

        # Calculate score based on recently found downloads
        badDownloads = calcRecentDownloads([o['detected_downloaded_samples'], o['undetected_downloaded_samples']])
        dbotScore = 0
        if badDownloads >= threshold:
            dbotScore = 3
            # addMalicious(ec, outputPaths.ip,{
            #     Address: ip,
            #     ASN: o.asn,
            #     Geo: {Country: o.country},
            #     Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}
            # });
        elif badDownloads >= threshold / 2:
            dbotScore = 2
        else:
            dbotScore = 1

        ec['DBotScore'] = {'Indicator': ip, 'Type': 'ip', 'Vendor': 'VirusTotal', 'Score': dbotScore};
        md = '## VirusTotal IP Reputation for: %s\n' % (ip, )
        md += ('ASN: **%s (%s)**\n' % (o['asn'], o['as_owner'], )) if (o['asn']) else 'ASN: N/A\n'
        md += 'Country: **%s**\n' % (o['country'], )
        md += 'VT Link: [%s](https://www.virustotal.com/en/search?query=%s)\n' % (ip, ip, )

        arrTitle = [
            {'a': o['detected_urls'], 't': 'Detected URL'},
            {'a': o['detected_downloaded_samples'], 't': 'Detected downloaded sample'},
            {'a': o['undetected_downloaded_samples'], 't': 'Undetected downloaded sample'},
            {'a': o['detected_communicating_samples'], 't': 'Detected communicating sample'},
            {'a': o['undetected_communicating_samples'], 't': 'Undetected communicating sample'},
            {'a': o['detected_referrer_samples'], 't': 'Detected referrer sample'},
            {'a': o['undetected_referrer_samples'], 't': 'Undetected referrer sample'},
            {'a': o['resolutions'], 't': 'Resolutions'}
        ]

        for item in arrTitle:
            if item['a']:
                md += '%s count: **%d**\n' % (item['t'], len(item['a']), )

        if longFormat == 'true':
            for item in arrTitle:
                if item['a']:
                    # Print only the first ~10 rows
                    md += tableToMarkdown(item['t'], item['a'][:sampleSize])

        return {'Type': entryTypes['note'], 'Contents': res['body'], 'ContentsFormat': formats['json'], 'HumanReadable': md, 'EntryContext': ec};


    if demisto.command() == 'test-module':
        # doFile('7657fcb7d772448a6d8504e4b20168b8') # Check sample file - it will throw an error if not successful
        demisto.results('ok')
    elif demisto.command() == 'ip':
        args = demisto.args()
        demisto.results(doIP(args['ip'], args['long'], int(args['threshold']), int(args['sampleSize']), int(args['wait']), int(args['retries'])))
    else:
        raise 'Unknown command - ' + command
  type: python
  commands:
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to query. Supports MD5, SHA1 and SHA256. Notice
        that you can pass comma-separated multiple values to efficiently retrieve
        multiple responses.
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with scans
      defaultValue: "false"
    - name: threshold
      description: If number of positives is bigger than the threshold we will consider
        it malicious
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: File.MD5
      description: Bad hash found
    - contextPath: File.SHA1
      description: Bad hash SHA1
    - contextPath: File.SHA256
      description: Bad hash SHA256
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: File.Malicious.Detections
      description: For malicious files. Total detections.
    - contextPath: File.Malicious.TotalEngines
      description: For malicious files. Total engines
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check file reputation of the given hash
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: threshold
      description: If number of positive detected IPs is bigger than the threshold
        we will consider it malicious
      defaultValue: "10"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: IP.Address
      description: Bad IP Address found
    - contextPath: IP.ASN
      description: Bad IP ASN
    - contextPath: IP.Geo.Country
      description: Bad IP Country
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check IP Reputation
  - name: url
    arguments:
    - name: url
      required: true
      description: URL to be checked
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: threshold
      description: If number of positive detected URLs is bigger than the threshold
        we will consider it malicious
    - name: submitWait
      description: Seconds to wait if the URL does not exist and is submitted to be
        scanned
      defaultValue: "0"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check URL Reputation
  - name: domain
    arguments:
    - name: domain
      required: true
      default: true
      description: Domain name to check reputation
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: threshold
      description: If number of positive detected domains is bigger than the threshold
        we will consider it malicious
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: Domain.Name
      description: Bad domain found
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check domain reputation
  - name: file-scan
    arguments:
    - name: entryID
      required: true
      default: true
      description: The file entry ID to submit
    - name: uploadURL
      description: Private API extension. Special upload URL for files bigger than
        32M.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files
    description: Submit a file for scanning
  - name: file-rescan
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to re-scan. Supports MD5, SHA1 and SHA256.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files
    description: Rescan an already submitted file to save time and not upload
  - name: url-scan
    arguments:
    - name: url
      required: true
      default: true
      description: The URL to scan
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted URLs
    description: Scan a given URL
  - name: vt-comments-add
    arguments:
    - name: resource
      required: true
      default: true
      description: The hash (md5/sha1/sha256) or URL you're commenting on
    - name: comment
      required: true
      description: 'The actual review, you can tag it using the "#" twitter-like syntax
        (e.g. #disinfection #zbot) and reference users using the "@" syntax (e.g.
        @VirusTotalTeam).'
    description: Add comments for files and URLs
  - name: vt-file-scan-upload-url
    arguments: []
    outputs:
    - contextPath: vtUploadURL
      description: The special upload URL for large files
    description: Private API. Get a special URL for files above 32M.
  - name: vt-comments-get
    arguments:
    - name: resource
      required: true
      default: true
      description: The hash (md5/sha1/sha256) or URL you're retrieving comments for
    - name: before
      description: Datetime token in format YYYYMMDDHHMISS that can be used for paging
    description: Private API. Retrieve comments for a given resource
