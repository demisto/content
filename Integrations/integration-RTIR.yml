commonfields:
  id: RTIR
  version: -1
name: RTIR
display: RTIR
category: Case Management
image: data:image/png;base64,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
description: "Request Tracker for Incident Response is a ticketing system which provides
  pre-configured queues and workflows designed for incident response teams."
configuration:
  - display: Server URL (e.g. http://192.168.0.1)
    name: server
    defaultvalue: ""
    type: 0
    required: true
  - display: Credentials
    name: credentials
    defaultvalue: ""
    type: 9
    required: true
  - display: Trust any certificate (unsecure)
    name: unsecure
    defaultvalue: "true"
    type: 8
    required: false
  - display: Use system proxy settings
    name: proxy
    defaultvalue: "false"
    type: 8
    required: false
  - display: Fetch incidents
    name: isFetch
    defaultvalue: ""
    type: 8
    required: false
  - display: Incident type
    name: incidentType
    defaultvalue: ""
    type: 13
    required: false
  - display: 'Fetch incidents of the following status:'
    name: fetch_status
    defaultvalue: new,open
    type: 0
    required: false
  - display: 'Fetch incidents with priority greater or equal to:'
    name: fetch_priority
    defaultvalue: "0"
    type: 0
    required: false
  - display: Queue name to fetch incidents from
    name: fetch_queue
    defaultvalue: Incident Reports
    type: 0
    required: false
script:
  script: |-
    ''' IMPORTS '''
    import requests
    import os
    import json
    import io
    import re
    from requests import Request, Session
    import urllib

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    BASE_URL = SERVER + '/REST/1.0/'
    USE_SSL = not demisto.params().get('unsecure', False)
    FETCH_PRIORITY = int(demisto.params()['fetch_priority']) - 1
    FETCH_STATUS = demisto.params()['fetch_status']
    FETCH_QUEUE = demisto.params()['fetch_queue']
    CURLY_BRACKETS_REGEX = r'\{(.*?)\}' # Extracts string in curly brackets, e.g. '{string}' -> 'string'
    apostrophe = "'"
    SESSION = requests.session()


    ''' HELPER FUNCTIONS '''
    def ticket_to_incident(ticket):
        incident = {
            'name': 'RTIR Ticket ' + str(ticket['ID']),
            'rawJSON': json.dumps(ticket),
        }
        attachments, attachments_content = get_ticket_attachments(ticket['ID'])
        if attachments:
            incident_attachments = []
            for i in range(len(attachments)):
                incident_attachments.append({
                    'path': attachments_content[i]['FileID'],
                    'name': attachments[i]['Name']
                })

            incident['attachment'] = incident_attachments
        return incident

    def ticket_string_to_id(ticket_string):
        '''
        Translates 'ticket/1' to the integer 1
        '''
        slash_index = ticket_string.index('/')
        ticket_id = int(ticket_string[slash_index + 1:])
        return ticket_id


    def http_request(method, suffix_url, data=None, files=None, query=None):
        #Returns the http request

        url = BASE_URL + suffix_url
        params = {'user': USERNAME, 'pass': PASSWORD}
        if query:
            params.update(query)

        response = SESSION.request(method, url, data=data, params=params, files=files)

        # handle request failure
        if response.status_code not in {200}:
            message = parse_error_response(response)
            return_error('Error in API call with status code {}\n{}'.format(response.status_code, message))

        return response


    def parse_error_response(response):
        try:
            res = response.json()
            msg = res.get('message')
            if res.get('details') and res.get('details')[0].get('message'):
                msg = msg + "\n"+json.dumps(res.get('details')[0])
        except:
            return response.text
        return msg


    def login():

        data = {
            'user': USERNAME,
            'pass': PASSWORD
        }
        response = SESSION.post(SERVER, data=data)


    def logout():

        suffix_url = 'logout'
        response = http_request('POST', suffix_url)


    def parse_ticket_data(raw_query):

        raw_tickets = search_ticket_request(raw_query)
        headers = ['ID', 'Subject', 'Status', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority']
        search_context = []
        data = raw_tickets.content.split('\n')
        data = data[2:]
        raw_ticket_search = []
        for line in data:
            split_line = line.split(': ')
            search_ticket = get_ticket_request(split_line[0]).content
            search_ticket = search_ticket.split('\n')
            search_ticket = search_ticket[2:]
            id_ticket = search_ticket[0].upper()
            search_ticket[0] = id_ticket

            current_ticket_search = {}
            for entity in search_ticket:
                if ': ' in entity:
                    header, content = entity.split(': ', 1)
                    if 'ID' in header:
                        content = ticket_string_to_id(content)
                    if header in {'ID', 'Subject', 'Status', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority'}:
                        current_ticket_search[header] = content

            for key in search_ticket: # Adding ticket custom fields to outputs
                if key.startswith('CF.'):
                    split_key = key.split(':')
                    if split_key[0]:
                        custom_field_regex = re.findall(CURLY_BRACKETS_REGEX, key)[0].replace(' ', '') # Regex and removing white spaces
                        current_ticket_search[custom_field_regex] = split_key[1]
                        headers.append(custom_field_regex)

            if current_ticket_search:
                search_context.append(current_ticket_search)

        return search_context



    ''' FUNCTIONS '''


    def create_ticket_request(encoded):

        suffix_url = 'ticket/new'
        ticket_id = http_request('POST', suffix_url, data=encoded)

        return ticket_id


    def create_ticket_attachments_request(encoded, files_data):

        suffix_url = 'ticket/new'
        ticket_id = http_request('POST', suffix_url, files=files_data)

        return ticket_id

    def create_ticket():
        ticket_context = []
        queue = demisto.args().get('queue')
        data = 'id: ticket/new\nQueue: {}\n'.format(queue)

        subject = demisto.args().get('subject')
        if subject:
            data += "Subject: {}\n".format(subject)

        requestor = demisto.args().get('requestor')
        if requestor:
            data += "Requestor: {}\n".format(requestor)

        cc = demisto.args().get('cc', '')
        if cc:
            data += "Cc: {}\n".format(cc)

        admin_cc = demisto.args().get('admin-cc', '')
        if admin_cc:
            data += "AdminCc: {}\n".format(admin_cc)

        owner = demisto.args().get('owner')
        if owner:
            data += "Owner: {}\n".format(owner)

        status = demisto.args().get('status')
        if status:
            data += "Status: {}\n".format(status)

        priority = demisto.args().get('priority')
        if priority:
            data += "Priority: {}\n".format(priority)

        initial_priority = demisto.args().get('initial-priority')
        if initial_priority:
            data += "Initial-priority: {}\n".format(initial_priority)

        final_priority = demisto.args().get('final-priority')
        if final_priority:
            data += "FinalPriority: {}\n".format(final_priority)

        text = demisto.args().get('text')
        if text:
            data += "Text: {}\n".format(unicode(text).encode('utf-8'))

        customfields = demisto.args().get('customfields')
        if customfields:
            cf_list = customfields.split(',')
            for cf in cf_list:
                equal_index = cf.index('=')
                key = 'CF-{}: '.format(cf[:equal_index])
                value = cf[equal_index + 1:]
                data = data + key + value + '\n'

        attachments = demisto.args().get('attachment')
        if attachments:
            files_data = {}
            if isinstance(attachments, list): # Given as list
                attachments_list = attachments
            else: # Given as string
                attachments_list = attachments.split(',')
            for i, file_pair in enumerate(attachments_list):
                file = demisto.getFilePath(file_pair)
                file_name = file['name']
                files_data['attachment_{:d}'.format(i + 1)] = (file_name ,open(file['path'], 'rb'))
                data += 'Attachment: {}'.format(file_name)


        encoded = "content=" + urllib.quote_plus(data)
        if attachments:
            files_data.update({'content': (None, data)})
            ticket_id = create_ticket_attachments_request(encoded, files_data)
        else:
            ticket_id = create_ticket_request(encoded)
        ticket_id = re.findall('\d+', ticket_id.content)[-1]
        if ticket_id == -1:
            return_error('Ticket creation failed')

        ticket_context = ({
            'ID': ticket_id,
            'Subject': subject,
            'Creator': requestor,
            'InitialPriority': initial_priority,
            'Priority': priority,
            'FinalPriority': final_priority,
            'Owner': owner
        })
        ec= {
            'RTIR.Ticket(val.ID && val.ID === obj.ID)': ticket_context
        }
        hr = 'Ticket {} was created successfully.'.format(ticket_id)
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': hr,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })

    def get_ticket_request(ticket_id):

        suffix_url = 'ticket/{}/show'.format(ticket_id)
        raw_ticket = http_request('GET', suffix_url)

        return raw_ticket


    def search_ticket():
        raw_query = ''
        ticket_id = demisto.args().get('ticket-id')

        if ticket_id:
            raw_query += 'id={}{}{}+AND+'.format(apostrophe, ticket_id, apostrophe)

        subject = demisto.args().get('subject')
        if subject:
            raw_query += 'Subject={}{}{}+AND+'.format(apostrophe, subject, apostrophe)

        status = demisto.args().get('status')
        if status:
            raw_query += 'Status={}{}{}+AND+'.format(apostrophe, status, apostrophe)

        creator = demisto.args().get('creator')
        if creator:
            raw_query += 'Creator={}{}{}+AND+'.format(apostrophe, creator, apostrophe)

        priority_equal_to = demisto.args().get('priority-equal-to')
        if priority_equal_to:
            raw_query += 'Priority={}{}{}+AND+'.format(apostrophe, priority_equal_to, apostrophe)

        priority_greater_than = demisto.args().get('priority-greater-than')
        if priority_greater_than:
            raw_query += 'Priority>{}{}{}+AND+'.format(apostrophe, priority_greater_than, apostrophe)

        created_after = demisto.args().get('created-after')
        if created_after:
            raw_query += 'Created>{}{}{}+AND+'.format(apostrophe, created_after, apostrophe)

        created_on = demisto.args().get('created-on')
        if created_on:
            raw_query += 'Created={}{}{}+AND+'.format(apostrophe, created_on, apostrophe)

        created_before = demisto.args().get('created-before')
        if created_before:
            raw_query += 'Created<{}{}{}+AND+'.format(apostrophe, created_before, apostrophe)

        owner = demisto.args().get('owner')
        if owner:
            raw_query += 'Created={}{}{}+AND+'.format(apostrophe, owner, apostrophe)

        due = demisto.args().get('due')
        if due:
            raw_query += 'Due={}{}{}+AND+'.format(apostrophe, due, apostrophe)

        queue = demisto.args().get('queue')
        if queue:
            raw_query += 'Queue={}{}{}+AND+'.format(apostrophe, queue, apostrophe)
        raw_tickets = search_ticket_request(raw_query)
        headers = ['ID', 'Subject', 'Status', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority']
        search_context = []
        data = raw_tickets.content.split('\n')
        data = data[2:]
        raw_ticket_search = []
        for line in data:
            split_line = line.split(': ')
            search_ticket = get_ticket_request(split_line[0]).content
            search_ticket = search_ticket.split('\n')
            search_ticket = search_ticket[2:]
            id_ticket = search_ticket[0].upper()
            search_ticket[0] = id_ticket

            current_ticket_search = {}
            for entity in search_ticket:
                if ': ' in entity:
                    header, content = entity.split(': ', 1)
                    if 'ID' in header:
                        content = ticket_string_to_id(content)
                    if header in {'ID', 'Subject', 'Status', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority'}:
                        current_ticket_search[header] = content

            for key in search_ticket: # Adding ticket custom fields to outputs
                if key.startswith('CF.'):
                    split_key = key.split(':')
                    if split_key[0]:
                        custom_field_regex = re.findall(CURLY_BRACKETS_REGEX, key)[0].replace(' ', '') # Regex and removing white spaces
                        current_ticket_search[custom_field_regex] = split_key[1]
                        headers.append(custom_field_regex)

            if current_ticket_search:
                search_context.append(current_ticket_search)
        if search_context:
            ec = {
                'RTIR.Ticket(val.ID && val.ID === obj.ID)': search_context
            }
            title = 'RTIR ticket search results'

            demisto.results({
                'Type': entryTypes['note'],
                'Contents': search_context,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, search_context, headers, removeNull=True),
                'EntryContext': ec
            })
        else:
            demisto.results('No results found.')

    def search_ticket_request(raw_query):
        suffix_url = 'search/ticket'
        raw_tickets = http_request('GET', suffix_url, query={'query': raw_query})

        return raw_tickets


    def close_ticket_request(ticket_id, encoded):

        suffix_url = 'ticket/{}/edit'.format(ticket_id)
        closed_ticket = http_request('POST', suffix_url, data=encoded)

        return closed_ticket


    def close_ticket():
        ticket_id = demisto.args().get('ticket-id')
        content = '\nStatus: resolved'
        encoded = "content=" + urllib.quote_plus(content)
        closed_ticket = close_ticket_request(ticket_id, encoded)
        if '200 Ok' in closed_ticket.content:
            ec= {
                'RTIR.Ticket(val.ID && val.ID === obj.ID)': {
                    'ID': int(ticket_id),
                    'State': 'resolved'
                }
            }
            hr = 'Ticket {} was resolved successfully.'.format(ticket_id)
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': hr,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': hr,
                'EntryContext': ec
            })
        else:
            return_error('Failed to resolve ticket')

    def edit_ticket_request(ticket_id, encoded):

        suffix_url = 'ticket/{}/edit'.format(ticket_id)
        edited_ticket = http_request('POST', suffix_url, data=encoded)

        return edited_ticket


    def edit_ticket():

        arguments_given = False
        ticket_id = demisto.args().get('ticket-id')
        content = 'ID: '+ ticket_id
        ticket_context = []
        ticket = {
            'ID': int(ticket_id)
        }

        kwargs = {}
        subject = demisto.args().get('subject')
        if subject:
            content += '\nSubject: ' + subject
            arguments_given = True
            kwargs['Subject'] = subject

        owner = demisto.args().get('owner')
        if owner:
            content += '\nOwner: ' + owner
            arguments_given = True
            kwargs['Owner'] = owner

        status = demisto.args().get('status')
        if status:
            content += '\nStatus: ' + status
            arguments_given = True
            kwargs['Status'] = status

        priority = demisto.args().get('priority')
        if priority:
            content += '\nPriority: ' + priority
            arguments_given = True
            kwargs['Priority'] = int(priority)

        final_priority = demisto.args().get('final-priority')
        if final_priority:
            content += '\nFinalPriority: ' + final_priority
            arguments_given = True
            kwargs['FinalPriority'] = int(final_priority)

        due = demisto.args().get('due')
        if due:
            content += '\nDue: '+ due
            arguments_given = True
            kwargs['Due'] = due

        customfields = demisto.args().get('customfields')
        if customfields:
            cf_list = customfields.split(',')
            for cf in cf_list:
                equal_index = cf.index('=')
                key = 'CF-{}: '.format(cf[:equal_index])
                value = cf[equal_index + 1:]
                content = content + key + value + '\n'

        if arguments_given:
            encoded = "content=" + urllib.quote_plus(content)
            edited_ticket = edit_ticket_request(ticket_id, encoded)
            if "200 Ok" in edited_ticket.content:
                ticket_context = ({
                    'ID': ticket_id,
                    'Subject': subject,
                    'State': status,
                    'Priority': priority,
                    'FinalPriority': final_priority,
                    'Owner': owner
                })
                ec = {
                    'RTIR.Ticket(val.ID && val.ID === obj.ID)': ticket_context
                }

                hr = 'Ticket {} was edited successfully.'.format(ticket_id)
                demisto.results({
                    'Type': entryTypes['note'],
                    'Contents': hr,
                    'ContentsFormat': formats['json'],
                    'ReadableContentsFormat': formats['markdown'],
                    'HumanReadable': hr,
                    'EntryContext': ec
                })
            else:
                return_error('Failed to edit ticket')
        else:
            return_error('No arguments were given to edit the ticket.')


    def get_ticket_attachments(ticket_id):
        suffix_url = 'ticket/{}/attachments'.format(ticket_id)
        raw_attachments = http_request('GET', suffix_url).content

        attachments = []
        attachments_content = []
        split_raw_attachment = raw_attachments.split('\n')
        for i in xrange(len(split_raw_attachment)):
            if 'Attachments' in split_raw_attachment[i]:
                attachment_lines = split_raw_attachment[i:]
                for line in attachment_lines:
                    if line and 'Unnamed' not in line:
                        split_line = line.split(': ')
                        if 'Attachments' in split_line:
                            starting_index = 1
                        else:
                            starting_index = 0
                        attachment_id = split_line[starting_index]
                        attachment_id = attachment_id.strip()
                        attachment_name = split_line[starting_index + 1]
                        attachment_type = attachment_name.replace('(', '').replace(')', '')
                        split_line_type = attachment_type.split(' ')
                        attachment_name = split_line_type[0]
                        attachment_type = split_line_type[1]
                        attachment_size = split_line_type[3]

                        attachments.append({
                            'ID': attachment_id,
                            'Name': attachment_name,
                            'Type': attachment_type,
                            'Size': attachment_size
                        })

                        suffix_url = 'ticket/{}/attachments/{}'.format(ticket_id, attachment_id)
                        attachment_content = http_request('GET', suffix_url).content
                        attachments_content.append(fileResult(attachment_name, attachment_content))
        return attachments, attachments_content


    def get_ticket_attachments_command():
        ticket_id = demisto.args().get('ticket-id')
        attachments, attachments_content = get_ticket_attachments(ticket_id)
        if attachments:
            ec= {
                'RTIR.Ticket(val.ID && val.ID === obj.ID)': {
                    'ID': int(ticket_id),
                    'Attachment': attachments
                }
            }
            title = 'RTIR ticket {} attachments'.format(ticket_id)
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': attachments,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, attachments, removeNull=True),
                'EntryContext': ec
            })
            demisto.results(attachments_content)
        else:
            demisto.results('No attachments found.')


    def get_ticket_history_by_id(ticket_id, history_id):
        """Accepts ticket ID and history ID as input and returns a dictionary of ticket history entry properties"""

        suffix_url = 'ticket/{}/history/id/{}'.format(ticket_id, history_id)
        raw_history = http_request('GET', suffix_url)

        return raw_history


    def get_ticket_history(ticket_id):

        suffix_url = 'ticket/{}/history'.format(ticket_id)
        raw_history = http_request('GET', suffix_url)
        history_context = []
        headers = ['ID', 'Created', 'Creator', 'Description']
        data = raw_history.text.split('\n')
        data = data[4:]
        raw_ticket_history = []
        for line in data:
            split_line = line.split(': ')
            current_raw_ticket_history = get_ticket_history_by_id(ticket_id, split_line[0]).content
            current_raw_ticket_history = current_raw_ticket_history.split('\n')
            current_raw_ticket_history = current_raw_ticket_history[4:]
            id_ticket = current_raw_ticket_history[0].upper()
            current_raw_ticket_history[0] = id_ticket
            current_history_context = {}
            for entity in current_raw_ticket_history:
                if ': ' in entity:
                    header, content = entity.split(': ', 1)
                    if header in {'ID', 'Content', 'Created', 'Creator', 'Description', 'NewValue'}:
                        current_history_context[header] = content
            if current_history_context:
                history_context.append(current_history_context)
        return history_context, headers


    def get_ticket_history_command():
        ticket_id = demisto.args().get('ticket-id')
        history_context, headers = get_ticket_history(ticket_id)
        if history_context:
            ec = {
                'RTIR.Ticket(val.ID && val.ID === obj.ID)': {
                    'ID': int(ticket_id),
                    'History': history_context
                }
            }
            title = 'RTIR ticket {} history'.format(ticket_id)
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': history_context,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, history_context, headers, removeNull=True),
                'EntryContext': ec
            })
        else:
            demisto.results('No results found.')


    def get_ticket():
        ticket_id = demisto.args().get('ticket-id')
        raw_ticket = get_ticket_request(ticket_id)
        if not raw_ticket:
            return_error('Failed to get ticket, possibly does not exist.')
        ticket_context = []
        data = raw_ticket.content.split('\n')
        data = data[2:]
        current_ticket = {}
        for line in data:
            split_line = line.split(': ')
            if len(split_line) == 2:
                current_ticket[split_line[0]] = split_line[1]
                ticket = {
                    'ID': ticket_string_to_id(current_ticket['id']),
                    'Subject': current_ticket.get('Subject'),
                    'State': current_ticket.get('Status'),
                    'Creator': current_ticket.get('Creator'),
                    'Created': current_ticket.get('Created'),
                    'Priority': current_ticket.get('Priority'),
                    'InitialPriority': current_ticket.get('InitialPriority'),
                    'FinalPriority': current_ticket.get('FinalPriority'),
                    'Queue': current_ticket.get('Queue'),
                    'Owner': current_ticket.get('Owner')
                }

            for key in data: # Adding ticket custom fields to outputs
                if key.startswith('CF.'):
                    split_key = key.split(':')
                    if split_key[0]:
                        custom_field_regex = re.findall(CURLY_BRACKETS_REGEX, key)[0].replace(' ', '') # Regex and removing white spaces
                        ticket[custom_field_regex] = split_key[1]

            if ticket:
                ticket_context.append(ticket)

        suffix_url = 'ticket/{}/links/show'.format(ticket_id)
        raw_links = http_request('GET', suffix_url)
        if raw_links:
            links = []
            for raw_link in raw_links:
                link_id = raw_link.rsplit('/', 3)[-2]
                links.append({
                    'ID': link_id
                })
            ticket['LinkedTo'] = links
        ec = {
            'RTIR.Ticket(val.ID && val.ID === obj.ID)': ticket
        }
        title = 'RTIR ticket {}'.format(ticket_id)
        headers = ['ID', 'Subject', 'Status', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority']
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': ticket_context,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, ticket, headers, removeNull=True),
            'EntryContext': ec
        })


    def add_comment_request(ticket_id, encoded):

        suffix_url = 'ticket/{}/comment'.format(ticket_id)
        added_comment = http_request('POST', suffix_url, data=encoded)

        return added_comment


    def add_comment_attachment(ticket_id, encoded, files_data):

      suffix_url = 'ticket/{}/comment'.format(ticket_id)
      comment = http_request('POST', suffix_url, files=files_data)

      return comment

    def add_comment():
      ticket_id = demisto.args().get('ticket-id')
      text = demisto.args().get('text')
      content = 'Action: comment\n'
      if text:
        content += '\nText: ' + text.encode('utf-8')
      attachments = demisto.args().get('attachment')
      if attachments:
        files_data = {}
        if isinstance(attachments, list):
          attachments_list = attachments
        else: # Given as string
          attachments_list = attachments.split(',')
        for i, file_pair in enumerate(attachments_list):
          file = demisto.getFilePath(file_pair)
          file_name = file['name']
          files_data['attachment_{:d}'.format(i + 1)] = (file_name ,open(file['path'], 'rb'))
          content += 'Attachment: {}\n'.format(file_name)

      encoded = "content=" + urllib.quote_plus(content)
      if attachments:
        files_data.update({'content': (None, content)})
        comment = add_comment_attachment(ticket_id, encoded, files_data)
        demisto.results('Added comment to ticket {} successfully.'.format(ticket_id))
      else:
        added_comment = add_comment_request(ticket_id, encoded)
        if '200' in added_comment.content:
          demisto.results('Added comment to ticket {} successfully.'.format(ticket_id))
        else:
          return_error('Failed to add comment')


    def add_reply_request(ticket_id, encoded):

        suffix_url = 'ticket/{}/comment'.format(ticket_id)
        added_reply = http_request('POST', suffix_url, data=encoded)

        return added_reply


    def add_reply():


        ticket_id = demisto.args().get('ticket-id')
        content = 'Action: comment\n'
        text = demisto.args().get('text')
        if text:
            content += '\nText: ' + text.encode('utf-8')
        cc = demisto.args().get('cc')
        if cc:
            content += '\nCc: ' + cc
        try:
            encoded = "content=" + urllib.quote_plus(content)
            added_reply = add_reply_request(ticket_id, encoded)
            if '200' in added_reply.content:
                demisto.results('Replied successfully to ticket {}.'.format(ticket_id))
            else:
                return_error('Failed to reply')
        except Exception, e:
            demisto.error(str(e))
            return_error('Failed to reply')


    def fetch_incidents():
        last_run = demisto.getLastRun()
        last_ticket_id = demisto.getLastRun()['ticket_id'] if (demisto.getLastRun() and demisto.getLastRun()['ticket_id']) else 0
        raw_query='id>{}+AND+Priority>{}+AND+Queue={}{}{}'.format(last_ticket_id, FETCH_PRIORITY, apostrophe, FETCH_QUEUE, apostrophe)
        if FETCH_STATUS:
            status_list = FETCH_STATUS.split(',')
            status_query = '+AND+('
            for status in status_list:
                status_query += 'Status={}{}{}+OR+'.format(apostrophe, status, apostrophe)
            raw_query += status_query + ')'
        tickets = parse_ticket_data(raw_query)
        incidents = []
        max_ticket_id = last_ticket_id
        for ticket in tickets:
            ticket_id = ticket['ID']
            history_context, _ = get_ticket_history(ticket_id)
            ticket['History'] = history_context
            incidents.append(ticket_to_incident(ticket))
            max_ticket_id = max(max_ticket_id, ticket_id)
        if tickets:
            demisto.setLastRun({'ticket_id': max_ticket_id})
        demisto.incidents(incidents)


    ''' EXECUTION CODE '''


    LOG('command is %s' % (demisto.command(), ))
    try:
        login()
        if demisto.command() == 'test-module':
            demisto.results('ok')

        if demisto.command() in {'fetch-incidents'}:
            fetch_incidents()

        elif demisto.command() == 'rtir-create-ticket':
            create_ticket()

        elif demisto.command() == 'rtir-search-ticket':
            search_ticket()

        elif demisto.command() == 'rtir-resolve-ticket':
            close_ticket()

        elif demisto.command() == 'rtir-edit-ticket':
            edit_ticket()

        elif demisto.command() == 'rtir-ticket-history':
            get_ticket_history_command()

        elif demisto.command() == 'rtir-ticket-attachments':
            get_ticket_attachments_command()

        elif demisto.command() == 'rtir-get-ticket':
            get_ticket()

        elif demisto.command() == 'rtir-add-comment':
            add_comment()

        elif demisto.command() == 'rtir-add-reply':
            add_reply()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
    finally:
        logout()
  type: python
  commands:
  - name: rtir-create-ticket
    arguments:
    - name: queue
      description: Queue where to create the ticket
      defaultValue: General
    - name: subject
      required: true
      description: Subject of the ticket
    - name: requestor
      description: Requestor email address
    - name: cc
      description: Sends a carbon-copy of this update to a comma-delimited list of
        email addresses. These people will receive future updates.
    - name: admin-cc
      description: Sends a carbon-copy of this update to a comma-delimited list of
        administrative email addresses. These people will receive future updates.
    - name: owner
      description: Ticker owner
    - name: status
      description: Ticket status
    - name: priority
      description: Ticket priority, given as number in the range 0-100
    - name: text
      description: The ticket content
    - name: initial-priority
      description: Ticket initial priority, given as number in the range 0-100
    - name: final-priority
      description: Ticket final priority, given as number in the range 0-100
    - name: attachment
      description: Attachment to add to the ticket, given as Entry ID. Comma separated
        values supported, e.g. entryID1,entryID2
      isArray: true
    - name: customfields
      description: 'Ticket custom fields, given in format: field1=value1,field2=value2,
        e.g. IP=8.8.8.8,HowReported=Email. Note: the command does not create custom
        fields, these should be created on RTIR.'
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.InitialPriority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    - contextPath: RTIR.Ticket.Creator
      description: Ticker creator
      type: string
    description: Create new ticket on RTIR
  - name: rtir-search-ticket
    arguments:
    - name: ticket-id
      description: 'Ticket ID '
    - name: subject
      description: Ticket subject
    - name: queue
      required: true
      description: Ticket queue (Comma separated values supported, e.g. General,Incident
        reports,Incidents)
    - name: status
      description: 'Ticket status '
    - name: creator
      description: Ticket creator
    - name: priority-equal-to
      description: Ticket priority (number in range 0-100)
    - name: priority-greater-than
      description: Ticket priority (number in range 0-100)
    - name: created-after
      description: Date after which the ticket was created, in format of YYYY-MM-DD,
        e.g. 2011-02-24
    - name: created-on
      description: Date on which the ticket was created, in format of YYYY-MM-DD,
        e.g. 2011-02-24
    - name: created-before
      description: Date before which the ticket was created, in format of YYYY-MM-DD,
        e.g. 2011-02-24
    - name: owner
      description: Ticker owner
    - name: due
      description: Ticket due date, in format of YYYY-MM-DD, e.g. 2011-02-24
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    - contextPath: RTIR.Ticket.Creator
      description: Ticket creator
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    - contextPath: RTIR.Ticket.Created
      description: Ticket creation date
      type: date
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.InitialPriority
      description: Ticket initial priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Queue
      description: Ticket queue
      type: string
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.IP
      description: Ticket custom field - IP address
      type: string
    - contextPath: RTIR.Ticket.HowReported
      description: Ticket custom field - How ticket was reported
      type: string
    - contextPath: RTIR.Ticket.Customer
      description: Ticket custom field - Customer
      type: string
    description: Search for tickets on RTIR
  - name: rtir-resolve-ticket
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to close
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    description: Sets a ticket as resolved on RTIR
  - name: rtir-edit-ticket
    arguments:
    - name: ticket-id
      required: true
      description: 'Ticket ID'
    - name: subject
      description: Ticket subject
    - name: priority
      description: Ticket priority, number in range 0-100
    - name: final-priority
      description: Ticket final priority, number in range 0-100
    - name: owner
      description: Ticket owner
    - name: status
      description: Ticket status
    - name: due
      description: Ticket due date, in format of YYYY-MM-DD, e.g. 2011-02-24
    - name: customfields
      description: 'Ticket custom fields, given in format: field1=value1,field2=value2,
        e.g. IP=8.8.8.8,HowReported=Email. Note: the command does not create custom
        fields, these should be created on RTIR.'
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    description: Modify a ticket on RTIR
  - name: rtir-ticket-history
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to get history of
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.History.Content
      description: Ticket history content
      type: string
    - contextPath: RTIR.Ticket.History.Created
      description: Ticket history creation date
      type: date
    - contextPath: RTIR.Ticket.History.Creator
      description: Ticket history creator
      type: string
    - contextPath: RTIR.Ticket.History.Description
      description: Ticket history description
      type: string
    - contextPath: RTIR.Ticket.History.NewValue
      description: Value updated in history transaction
      type: string
    description: Gets a list of all the history items for a given ticket.
  - name: rtir-get-ticket
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to get
    outputs:
    - contextPath: RTIR.Ticket.LinkedTo.ID
      description: Linked ticket ID
      type: number
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    - contextPath: RTIR.Ticket.Creator
      description: Ticket creator
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    - contextPath: RTIR.Ticket.Created
      description: Ticket creation date
      type: date
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.InitialPriority
      description: Ticket initial priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Queue
      description: Ticket queue
      type: string
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.IP
      description: Ticket custom field - IP address
      type: string
    - contextPath: RTIR.Ticket.HowReported
      description: Ticket custom field - How ticket was reported
      type: string
    - contextPath: RTIR.Ticket.Customer
      description: Ticket custom field - Customer
      type: string
    description: Gets the data for a single ticket.
  - name: rtir-ticket-attachments
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to get attachments of
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.Attachment.ID
      description: Attachment ID
      type: number
    - contextPath: RTIR.Ticket.Attachment.Name
      description: Attachment file name
      type: string
    - contextPath: RTIR.Ticket.Attachment.Size
      description: Attachment file size
      type: string
    - contextPath: RTIR.Ticket.Attachment.Type
      description: Attachment file type
      type: string
    - contextPath: File.EntryID
      description: Demisto entry ID of attachment
      type: string
    - contextPath: File.Size
      description: File size
      type: number
    - contextPath: File.SHA1
      description: File SHA1
      type: string
    - contextPath: File.SHA256
      description: File SHA256
      type: string
    - contextPath: File.Name
      description: File name
      type: string
    - contextPath: File.SSDeep
      description: File SSDeep
      type: string
    - contextPath: File.Info
      description: File type information
      type: string
    - contextPath: File.Type
      description: File type
      type: string
    - contextPath: File.MD5
      description: File MD5
      type: string
    - contextPath: File.Extension
      description: File extension
      type: string
    description: Gets a list of all attachments details and data content related to
      the ticket.
  - name: rtir-add-comment
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to add comment to
    - name: text
      required: true
      description: Comment text
    - name: attachment
      description: Attachment to add to the ticket, given as Entry ID. Comma separated
        values supported, e.g. entryID1,entryID2
      isArray: true
    description: Add a comment to an existing ticket.
  - name: rtir-add-reply
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to send the reply to the user
    - name: text
      required: true
      description: reply text
    - name: cc
      description: Email of the user to send the reply
      isArray: true
    description: Send a reply from an existing ticket to the user
  isfetch: true
  runonce: false
tests:
  - RTIR Test
