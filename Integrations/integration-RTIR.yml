commonfields:
  id: RTIR
  version: -1
name: RTIR
display: RTIR
category: Case Management
image: data:image/png;base64,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
description: 'Request Tracker for Incident Response is a ticketing system which provides
  pre-configured queues and workflows designed for incident response teams.'
configuration:
- display: Server URL (e.g. http://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: 'Fetch incidents of the following status:'
  name: fetch_status
  defaultvalue: new,open
  type: 0
  required: false
- display: 'Fetch incidents with priority greater or equal to:'
  name: fetch_priority
  defaultvalue: "0"
  type: 0
  required: false
- display: Queue name to fetch incidents from
  name: fetch_queue
  defaultvalue: Incident Reports
  type: 0
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import requests
    import os
    import json
    import nose
    import six
    import rt
    import io
    import re

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    BASE_URL = SERVER + '/REST/1.0/'
    USE_SSL = not demisto.params().get('unsecure', False)
    FETCH_PRIORITY = int(demisto.params()['fetch_priority']) - 1
    FETCH_STATUS = demisto.params()['fetch_status']
    CURLY_BRACKETS_REGEX = r'\{(.*?)\}' # Extracts string in curly brackets, e.g. '{string}' -> 'string'
    apostrophe = "'"

    ''' HELPER FUNCTIONS '''
    def ticket_to_incident(ticket):
        incident = {
            'name': 'RTIR Ticket ' + str(ticket['id']),
            'rawJSON': json.dumps(ticket),
        }
        attachments, attachments_content, _ = get_ticket_attachments(ticket['id'])
        if attachments:
            incident_attachments = []
            for i in range(len(attachments)):
                incident_attachments.append({
                    'path': attachments_content[i]['FileID'],
                    'name': attachments[i]['Name']
                })
            incident['attachment'] = incident_attachments
        return incident

    def ticket_string_to_id(ticket_string):
        '''
        Translates 'ticket/1' to the integer 1
        '''
        slash_index = ticket_string.index('/')
        ticket_id = int(ticket_string[slash_index + 1:])
        return ticket_id

    ''' FUNCTIONS '''
    def create_ticket():
        kwargs = {}
        queue = demisto.args().get('queue')

        subject = demisto.args().get('subject')
        if subject:
            kwargs['Subject'] = unicode(subject).encode('utf-8')

        requestor = demisto.args().get('requestor')
        if requestor:
            kwargs['Requestor'] = requestor

        cc = demisto.args().get('cc', '')
        if cc:
            kwargs['Cc'] = cc

        admin_cc = demisto.args().get('admin-cc', '')
        if admin_cc:
            kwargs['AdminCc'] = admin_cc

        owner = demisto.args().get('owner')
        if owner:
            kwargs['Owner'] = owner

        status = demisto.args().get('status')
        if status:
            kwargs['Status'] = status

        priority = demisto.args().get('priority')
        if priority:
            kwargs['Priority'] = int(priority)

        initial_priority = demisto.args().get('initial-priority')
        if initial_priority:
            kwargs['InitialPriority'] = int(initial_priority)

        final_priority = demisto.args().get('final-priority')
        if final_priority:
            kwargs['FinalPriority'] = int(final_priority)

        text = demisto.args().get('text')
        if text:
            kwargs['Text'] = unicode(text).encode('utf-8')

        customfields = demisto.args().get('customfields')
        if customfields:
            cf_list = customfields.split(',')
            for cf in cf_list:
                equal_index = cf.index('=')
                key = 'CF_{}'.format(cf[:equal_index])
                value = cf[equal_index + 1:]
                kwargs[key] = value

        attachments = demisto.args().get('attachment')
        files = []
        if attachments:
            if isinstance(attachments, list): # Given as list
                attachments_list = attachments
            else: # Given as string
                attachments_list = attachments.split(',')
            for attachment in attachments_list:
                files.append((demisto.getFilePath(attachment)['name'], open(demisto.getFilePath(attachment)['path'], 'rb')))
        ticket_id = tracker.create_ticket(Queue=queue, files=files, **kwargs)

        if ticket_id == -1:
            return_error('Ticket creation failed')

        kwargs['ID'] = ticket_id
        ec= {
            'RTIR.Ticket(val.ID && val.ID == obj.ID)': kwargs
        }
        hr = 'Ticket {} was created successfully.'.format(ticket_id)
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': hr,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })

    def search_ticket():
        raw_query = ''
        ticket_id = demisto.args().get('ticket-id')

        if ticket_id:
            raw_query += 'id={}{}{}+AND+'.format(apostrophe, ticket_id, apostrophe)

        subject = demisto.args().get('subject')
        if subject:
            raw_query += 'Subject={}{}{}+AND+'.format(apostrophe, subject, apostrophe)

        status = demisto.args().get('status')
        if status:
            raw_query += 'Status={}{}{}+AND+'.format(apostrophe, status, apostrophe)

        creator = demisto.args().get('creator')
        if creator:
            raw_query += 'Creator={}{}{}+AND+'.format(apostrophe, creator, apostrophe)

        priority_equal_to = demisto.args().get('priority-equal-to')
        if priority_equal_to:
            raw_query += 'Priority={}{}{}+AND+'.format(apostrophe, priority_equal_to, apostrophe)

        priority_greater_than = demisto.args().get('priority-greater-than')
        if priority_greater_than:
            raw_query += 'Priority>{}{}{}+AND+'.format(apostrophe, priority_greater_than, apostrophe)

        created_after = demisto.args().get('created-after')
        if created_after:
            raw_query += 'Created>{}{}{}+AND+'.format(apostrophe, created_after, apostrophe)

        created_on = demisto.args().get('created-on')
        if created_on:
            raw_query += 'Created={}{}{}+AND+'.format(apostrophe, created_on, apostrophe)

        created_before = demisto.args().get('created-before')
        if created_before:
            raw_query += 'Created<{}{}{}+AND+'.format(apostrophe, created_before, apostrophe)

        owner = demisto.args().get('owner')
        if owner:
            raw_query += 'Created={}{}{}+AND+'.format(apostrophe, owner, apostrophe)

        due = demisto.args().get('due')
        if due:
            raw_query += 'Due={}{}{}+AND+'.format(apostrophe, due, apostrophe)

        queue = demisto.args().get('queue')
        raw_tickets = tracker.search(Queue=queue, raw_query=raw_query)

        tickets = []
        headers = ['ID', 'Subject', 'State', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority']
        for raw_ticket in raw_tickets:
            ticket = {
                'ID': ticket_string_to_id(raw_ticket['id']),
                'State': raw_ticket.get('Status'),
                'Creator': raw_ticket.get('Creator'),
                'Subject': raw_ticket.get('Subject'),
                'Created': raw_ticket.get('Created'),
                'Priority': int(raw_ticket.get('Priority')),
                'InitialPriority': int(raw_ticket.get('InitialPriority')),
                'FinalPriority': int(raw_ticket.get('FinalPriority')),
                'Queue': raw_ticket.get('Queue'),
                'Owner': raw_ticket.get('Owner')
            }
            due = raw_ticket.get('Due')
            if due != 'Not set':
                ticket['Due'] = due
                headers.append('Due')
            for key in raw_ticket: # Adding ticket custom fields to outputs
                if key.startswith('CF'):
                    if raw_ticket[key]:
                        custom_field_regex = re.findall(CURLY_BRACKETS_REGEX, key)[0].replace(' ', '') # Regex and removing white spaces
                        ticket[custom_field_regex] = raw_ticket[key]
                        headers.append(custom_field_regex)
            tickets.append(ticket)
        if tickets:
            ec = {
                'RTIR.Ticket(val.ID && val.ID == obj.ID)': tickets
            }
            title = 'RTIR ticket search results'
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': raw_tickets,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, tickets, headers),
                'EntryContext': ec
            })
        else:
            demisto.results('No results found.')

    def close_ticket():
        ticket_id = demisto.args().get('ticket-id')
        try:
            closed_ticket = tracker.edit_ticket(ticket_id=ticket_id, Status='resolved')
            if closed_ticket is True:
                ec= {
                    'RTIR.Ticket(val.ID && val.ID == obj.ID)': {
                        'ID': int(ticket_id),
                        'State': 'resolved'
                    }
                }
                hr = 'Ticket {} was resolved successfully.'.format(ticket_id)
                demisto.results({
                    'Type': entryTypes['note'],
                    'Contents': hr,
                    'ContentsFormat': formats['json'],
                    'ReadableContentsFormat': formats['markdown'],
                    'HumanReadable': hr,
                    'EntryContext': ec
                })
            else:
                return_error('Failed to resolve ticket')
        except Exception, e:
            demisto.error(str(e))
            return_error('Failed to resolve ticket')

    def edit_ticket():

        arguments_given = False

        ticket_id = demisto.args().get('ticket-id')
        ticket = {
            'ID': int(ticket_id)
        }

        kwargs = {}

        subject = demisto.args().get('subject')
        if subject:
            arguments_given = True
            kwargs['Subject'] = subject

        owner = demisto.args().get('owner')
        if owner:
            arguments_given = True
            kwargs['Owner'] = owner

        status = demisto.args().get('status')
        if status:
            arguments_given = True
            kwargs['Status'] = status

        priority = demisto.args().get('priority')
        if priority:
            arguments_given = True
            kwargs['Priority'] = int(priority)

        final_priority = demisto.args().get('final-priority')
        if final_priority:
            arguments_given = True
            kwargs['FinalPriority'] = int(final_priority)

        due = demisto.args().get('due')
        if due:
            arguments_given = True
            kwargs['Due'] = due

        customfields = demisto.args().get('customfields')
        if customfields:
            arguments_given = True
            cf_list = customfields.split(',')
            for cf in cf_list:
                equal_index = cf.index('=')
                key = 'CF_{}'.format(cf[:equal_index])
                value = cf[equal_index + 1:]
                kwargs[key] = value

        if arguments_given:
            try:
                edited_ticket = tracker.edit_ticket(ticket_id=ticket_id, **kwargs)
                if edited_ticket is True:
                    ec= {
                        'RTIR.Ticket(val.ID && val.ID == obj.ID)': ticket
                    }
                    hr = 'Ticket {} was edited successfully.'.format(ticket_id)
                    demisto.results({
                        'Type': entryTypes['note'],
                        'Contents': hr,
                        'ContentsFormat': formats['json'],
                        'ReadableContentsFormat': formats['markdown'],
                        'HumanReadable': hr,
                        'EntryContext': ec
                    })
                else:
                    return_error('Failed to edit ticket')
            except Exception, e:
                demisto.error(str(e))
                return_error('Failed to edit ticket')
        else:
            return_error('No arguments were given to edit the ticket.')


    def get_ticket_attachments(ticket_id):
        raw_attachments = tracker.get_attachments(ticket_id)
        attachments = []
        attachments_content = []
        for raw_attachment in raw_attachments: # raw_attachment is a 4-tuple
            if 'Unnamed' in raw_attachment[1]: # raw_attachment[1] is attachment file name
                continue # Skip unnamed attachments
            attachments.append({
                'ID':  int(raw_attachment[0]),
                'Name': raw_attachment[1],
                'Type': raw_attachment[2],
                'Size': raw_attachment[3]
            })
            attachment_content = tracker.get_attachment_content(ticket_id=ticket_id, attachment_id=raw_attachment[0])
            attachments_content.append(fileResult(raw_attachment[1], attachment_content))
        return attachments, attachments_content, raw_attachments

    def get_ticket_attachments_command():
        ticket_id = demisto.args().get('ticket-id')
        attachments, attachments_content, raw_attachments = get_ticket_attachments(ticket_id)
        if attachments:
            ec= {
                'RTIR.Ticket(val.ID && val.ID == obj.ID)': {
                    'ID': int(ticket_id),
                    'Attachment': attachments
                }
            }
            title = 'RTIR ticket {} attachments'.format(ticket_id)
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': attachments,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, attachments),
                'EntryContext': ec
            })
            demisto.results(attachments_content)
        else:
            demisto.results('No attachments found.')

    def get_ticket_history(ticket_id):
        raw_history = tracker.get_history(ticket_id=ticket_id)
        output_history = []
        headers = ['Created', 'Creator', 'Description']
        for history in raw_history:
            current_history = {
                'Created': history['Created'],
                'Creator': history['Creator'],
                'Description': history['Description']
            }
            content = history.get('Content')
            if content != 'This transaction appears to have no content':
                current_history['Content'] = content
                if not 'Content' in headers:
                    headers.append('Content')
            new_value = history.get('NewValue')
            if new_value:
                current_history['NewValue'] = new_value
                if not 'NewValue' in headers:
                    headers.append('NewValue')
            output_history.append(current_history)
        return output_history, raw_history, headers


    def get_ticket_history_command():
        ticket_id = demisto.args().get('ticket-id')
        output_history, raw_history, headers = get_ticket_history(ticket_id)
        if output_history:
            ec = {
                'RTIR.Ticket(val.ID && val.ID == obj.ID)': {
                    'ID': int(ticket_id),
                    'History': output_history
                }
            }
            title = 'RTIR ticket {} history'.format(ticket_id)
            demisto.results({
                'Type': entryTypes['note'],
                'Contents': raw_history,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, output_history, headers),
                'EntryContext': ec
            })
        else:
            demisto.results('No results found.')

    def get_ticket():
        ticket_id = demisto.args().get('ticket-id')
        raw_ticket = tracker.get_ticket(ticket_id=ticket_id)
        if not raw_ticket:
            return_error('Failed to get ticket, possibly does not exist.')
        headers = ['ID', 'Subject', 'State', 'Priority', 'Created', 'Queue', 'Creator', 'Owner', 'InitialPriority', 'FinalPriority']
        ticket = {
            'ID': ticket_string_to_id(raw_ticket['id']),
            'State': raw_ticket.get('Status'),
            'Creator': raw_ticket.get('Creator'),
            'Subject': raw_ticket.get('Subject'),
            'Created': raw_ticket.get('Created'),
            'Priority': int(raw_ticket.get('Priority')),
            'InitialPriority': int(raw_ticket.get('InitialPriority')),
            'FinalPriority': int(raw_ticket.get('FinalPriority')),
            'Queue': raw_ticket.get('Queue'),
            'Owner': raw_ticket.get('Owner')
        }
        due = raw_ticket.get('Due')
        if due != 'Not set':
            ticket['Due'] = due
            headers.append('Due')
        for key in raw_ticket: # Adding ticket custom fields to outputs
            if key.startswith('CF'):
                if raw_ticket[key]:
                    custom_field_regex = re.findall(CURLY_BRACKETS_REGEX, key)[0].replace(' ', '') # Regex and removing white spaces
                    ticket[custom_field_regex] = raw_ticket[key]
                    headers.append(custom_field_regex)
        raw_links = tracker.get_links(ticket_id=ticket_id).get('MemberOf')
        if raw_links:
            links = []
            for raw_link in raw_links:
                link_id = int(raw_link.rsplit('/', 1)[-1])
                links.append({
                    'ID': link_id
                })
            ticket['LinkedTo'] = links
        ec = {
            'RTIR.Ticket(val.ID && val.ID == obj.ID)': ticket
        }
        title = 'RTIR ticket {}'.format(ticket_id)
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': raw_ticket,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, ticket, headers),
            'EntryContext': ec
        })

    def add_comment():
        ticket_id = demisto.args().get('ticket-id')
        text = demisto.args().get('text')
        attachments = demisto.args().get('attachment')
        files = []
        if attachments:
            if isinstance(attachments, list): # Given as list
                attachments_list = attachments
            else: # Given as string
                attachments_list = attachments.split(',')
            for attachment in attachments_list:
                files.append((demisto.getFilePath(attachment)['name'], open(demisto.getFilePath(attachment)['path'], 'rb')))
        try:
            added_comment = tracker.comment(ticket_id=ticket_id, text=text, files=files)
            if added_comment is True:
                demisto.results('Added comment to ticket {} successfully.'.format(ticket_id))
            else:
                return_error('Failed to add comment')
        except Exception, e:
            demisto.error(str(e))
            return_error('Failed to add comment')

    def add_reply():
        ticket_id = demisto.args().get('ticket-id')
        text = demisto.args().get('text')
        cc = demisto.args().get('cc')
        try:
            added_reply = tracker.reply(ticket_id=ticket_id, text=text, cc=cc)
            if added_reply is True:
                demisto.results('Replied successfully to ticket {}.'.format(ticket_id))
            else:
                return_error('Failed to reply')
        except Exception, e:
            demisto.error(str(e))
            return_error('Failed to reply')

    def fetch_incidents():
        fetch_queue = demisto.get(demisto.params(), 'fetch_queue')
        last_run = demisto.getLastRun()
        last_ticket_id = demisto.getLastRun()['ticket_id'] if (demisto.getLastRun() and demisto.getLastRun()['ticket_id']) else 0
        raw_query='id>{}+AND+Priority>{}'.format(last_ticket_id, FETCH_PRIORITY)
        if FETCH_STATUS:
            status_list = FETCH_STATUS.split(',')
            status_query = '+AND+('
            for status in status_list:
                status_query += 'Status={}{}{}+OR+'.format(apostrophe, status, apostrophe)
            raw_query += status_query
            raw_query += ')'
        tickets = tracker.search(Queue=fetch_queue, raw_query=raw_query)
        incidents = []
        max_ticket_id = last_ticket_id
        for ticket in tickets:
            ticket_string = ticket['id']
            ticket_id = ticket_string_to_id(ticket_string)
            ticket['id'] = ticket_id
            history, _, _ = get_ticket_history(ticket_id)
            ticket['History'] = history
            incidents.append(ticket_to_incident(ticket))
            max_ticket_id = max(max_ticket_id, ticket_id)
        if tickets:
            demisto.setLastRun({'ticket_id': max_ticket_id})
        demisto.incidents(incidents)

    ''' EXECUTION CODE '''

    tracker = rt.Rt(BASE_URL, USERNAME, PASSWORD)
    login = tracker.login()
    if login is False:
        return_error('Failed to login')

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            demisto.results('ok')

        if demisto.command() == 'fetch-incidents':
            fetch_incidents()

        elif demisto.command() == 'rtir-create-ticket':
            create_ticket()

        elif demisto.command() == 'rtir-search-ticket':
            search_ticket()

        elif demisto.command() == 'rtir-resolve-ticket':
            close_ticket()

        elif demisto.command() == 'rtir-edit-ticket':
            edit_ticket()

        elif demisto.command() == 'rtir-ticket-history':
            get_ticket_history_command()

        elif demisto.command() == 'rtir-ticket-attachments':
            get_ticket_attachments_command()

        elif demisto.command() == 'rtir-get-ticket':
            get_ticket()

        elif demisto.command() == 'rtir-add-comment':
            add_comment()

        elif demisto.command() == 'rtir-add-reply':
            add_reply()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
    finally:
        tracker.logout()
  type: python
  commands:
  - name: rtir-create-ticket
    arguments:
    - name: queue
      description: Queue where to create the ticket
    - name: subject
      required: true
      description: Subject of the ticket
    - name: requestor
      description: Requestor email address
    - name: cc
      description: Sends a carbon-copy of this update to a comma-delimited list of
        email addresses. These people will receive future updates.
    - name: admin-cc
      description: Sends a carbon-copy of this update to a comma-delimited list of
        administrative email addresses. These people will receive future updates.
    - name: owner
      description: Ticker owner
    - name: status
      description: Ticket status
    - name: priority
      description: Ticket priority, given as number in the range 0-100
    - name: text
      description: The ticket content
    - name: initial-priority
      description: Ticket initial priority, given as number in the range 0-100
    - name: final-priority
      description: Ticket final priority, given as number in the range 0-100
    - name: attachment
      description: Attachment to add to the ticket, given as Entry ID. Comma separated
        values supported, e.g. entryID1,entryID2
      isArray: true
    - name: customfields
      description: 'Ticket custom fields, given in format: field1=value1,field2=value2,
        e.g. IP=8.8.8.8,HowReported=Email. Note: the command does not create custom
        fields, these should be created on RTIR.'
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.InitialPriority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    - contextPath: RTIR.Ticket.Creator
      description: Ticker creator
      type: string
    description: Create new ticket on RTIR
  - name: rtir-search-ticket
    arguments:
    - name: ticket-id
      description: 'Ticket ID '
    - name: subject
      description: Ticket subject
    - name: queue
      required: true
      description: Ticket queue (Comma separated values supported, e.g. General,Incident
        reports,Incidents)
    - name: status
      description: 'Ticket status '
    - name: creator
      description: Ticket creator
    - name: priority-equal-to
      description: Ticket priority (number in range 0-100)
    - name: priority-greater-than
      description: Ticket priority (number in range 0-100)
    - name: created-after
      description: Date after which the ticket was created, in format of YYYY-MM-DD,
        e.g. 2011-02-24
    - name: created-on
      description: Date on which the ticket was created, in format of YYYY-MM-DD,
        e.g. 2011-02-24
    - name: created-before
      description: Date before which the ticket was created, in format of YYYY-MM-DD,
        e.g. 2011-02-24
    - name: owner
      description: Ticker owner
    - name: due
      description: Ticket due date, in format of YYYY-MM-DD, e.g. 2011-02-24
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    - contextPath: RTIR.Ticket.Creator
      description: Ticket creator
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    - contextPath: RTIR.Ticket.Created
      description: Ticket creation date
      type: date
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.InitialPriority
      description: Ticket initial priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Queue
      description: Ticket queue
      type: string
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.IP
      description: Ticket custom field - IP address
      type: string
    - contextPath: RTIR.Ticket.HowReported
      description: Ticket custom field - How ticket was reported
      type: string
    - contextPath: RTIR.Ticket.Customer
      description: Ticket custom field - Customer
      type: string
    description: Search for tickets on RTIR
  - name: rtir-resolve-ticket
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to close
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    description: Sets a ticket as resolved on RTIR
  - name: rtir-edit-ticket
    arguments:
    - name: ticket-id
      required: true
      description: 'Ticket ID '
    - name: subject
      description: Ticket subject
    - name: priority
      description: Ticket priority, number in range 0-100
    - name: final-priority
      description: Ticket final priority, number in range 0-100
    - name: owner
      description: Ticket owner
    - name: status
      description: Ticket status
    - name: due
      description: Ticket due date, in format of YYYY-MM-DD, e.g. 2011-02-24
    - name: customfields
      description: 'Ticket custom fields, given in format: field1=value1,field2=value2,
        e.g. IP=8.8.8.8,HowReported=Email. Note: the command does not create custom
        fields, these should be created on RTIR.'
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    description: Modify a ticket on RTIR
  - name: rtir-ticket-history
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to get history of
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.History.Content
      description: Ticket history content
      type: string
    - contextPath: RTIR.Ticket.History.Created
      description: Ticket history creation date
      type: date
    - contextPath: RTIR.Ticket.History.Creator
      description: Ticket history creator
      type: string
    - contextPath: RTIR.Ticket.History.Description
      description: Ticket history description
      type: string
    - contextPath: RTIR.Ticket.History.NewValue
      description: Value updated in history transaction
      type: string
    description: Gets a list of all the history items for a given ticket.
  - name: rtir-get-ticket
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to get
    outputs:
    - contextPath: RTIR.Ticket.LinkedTo.ID
      description: Linked ticket ID
      type: number
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.State
      description: Ticket state
      type: string
    - contextPath: RTIR.Ticket.Creator
      description: Ticket creator
      type: string
    - contextPath: RTIR.Ticket.Subject
      description: Ticket subject
      type: string
    - contextPath: RTIR.Ticket.Created
      description: Ticket creation date
      type: date
    - contextPath: RTIR.Ticket.Priority
      description: Ticket priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.InitialPriority
      description: Ticket initial priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.FinalPriority
      description: Ticket final priority (0-100)
      type: number
    - contextPath: RTIR.Ticket.Queue
      description: Ticket queue
      type: string
    - contextPath: RTIR.Ticket.Owner
      description: Ticket owner
      type: string
    - contextPath: RTIR.Ticket.IP
      description: Ticket custom field - IP address
      type: string
    - contextPath: RTIR.Ticket.HowReported
      description: Ticket custom field - How ticket was reported
      type: string
    - contextPath: RTIR.Ticket.Customer
      description: Ticket custom field - Customer
      type: string
    description: Gets the data for a single ticket.
  - name: rtir-ticket-attachments
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to get attachments of
    outputs:
    - contextPath: RTIR.Ticket.ID
      description: Ticket ID
      type: number
    - contextPath: RTIR.Ticket.Attachment.ID
      description: Attachment ID
      type: number
    - contextPath: RTIR.Ticket.Attachment.Name
      description: Attachment file name
      type: string
    - contextPath: RTIR.Ticket.Attachment.Size
      description: Attachment file size
      type: string
    - contextPath: RTIR.Ticket.Attachment.Type
      description: Attachment file type
      type: string
    - contextPath: File.EntryID
      description: Demisto entry ID of attachment
      type: string
    - contextPath: File.Size
      description: File size
      type: number
    - contextPath: File.SHA1
      description: File SHA1
      type: string
    - contextPath: File.SHA256
      description: File SHA256
      type: string
    - contextPath: File.Name
      description: File name
      type: string
    - contextPath: File.SSDeep
      description: File SSDeep
      type: string
    - contextPath: File.Info
      description: File type information
      type: string
    - contextPath: File.Type
      description: File type
      type: string
    - contextPath: File.MD5
      description: File MD5
      type: string
    - contextPath: File.Extension
      description: File extension
      type: string
    description: Gets a list of all attachments details and data content related to
      the ticket.
  - name: rtir-add-comment
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to add comment to
    - name: text
      required: true
      description: Comment text
    - name: attachment
      description: Attachment to add to the ticket, given as Entry ID. Comma separated
        values supported, e.g. entryID1,entryID2
      isArray: true
    description: Add a comment to an existing ticket.
  - name: rtir-add-reply
    arguments:
    - name: ticket-id
      required: true
      description: Ticket ID to send the reply to the user
    - name: text
      required: true
      description: reply text
    - name: cc
      description: Email of the user to send the reply
      isArray: true
    description: Send a reply from an existing ticket to the user
  dockerimage: demisto/rt-ir
  isfetch: true
  runonce: false
tests:
  - RTIR Test