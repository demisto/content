commonfields:
  id: Packetsled
  version: -1
name: Packetsled
display: Packetsled
category: Network Security
image: data:image/png;base64,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
description: Packetsled Network Security API commands
releaseNotes: "-"
detaileddescription: |
  #Packetsled Demisto Integration

  Provides ability to enumerate sensors, enumerate entities (hosts) that have incidents, and to retrieve metadata, file, and packet capture artifacts from the Packetsled API.

  Examples:

  To enumerate all attached sensors:

  ```
  !packetsled-get-sensors
  ```

  To search for all incidents since the last time they were retrieved:

  ```
  !packetsled-get-incidents
  ```

  To search for metadata for a specific host:

  ```
  !packetsled-get-flows entity=192.168.0.110 limit=10000
  ```

  To deliver a pcap for a given entity to the demisto war room:

  ```
  !packetsled-get-pcaps entity=192.168.0.110
  ```

  ## Commands

  ### packetsled-get-incidents
  Fetches incidents of the form:
  ```json
  {"name": "Source: Packetsled SENSOR: <sensor label>, ENTITY: <ip address>", "rawJSON": {<packetsled incident>}}
  ```
  |argument  | description   |    |
  |:---|:---|:---|
  | start_time      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime | options, will default to 1 hour ago or lastRunTime |
  | stop_time     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime | optional, will default to "now" |
  | envid      | A unique id in packetsled to identify a group of sensors belonging to a single customer | optional, if not provided, all sensors are queried  |
  | probe      | A unique id within an envid used to identify a sensingle sensor | optional, if not provided, all sensors are queried  |

  ### packetsled-get-flows
  Retrieves flow metadata based on provided constraints. The flows are delivered as JSON files into the demisto war room.

  |argument  | description   |    |
  |:---|:---|:---|
  | start_time      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime | options, will default to 1 hour ago or lastRunTime |
  | stop_time     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime | optional, will default to "now" |
  | envid      | A unique id in packetsled to identify a group of sensors belonging to a single customer | optional, if not provided, all sensors are queried  |
  | probe      | A unique id within an envid used to identify a sensingle sensor | optional, if not provided, all sensors are queried  |
  | entity      | an ip address | optional |
  | port      | port | optional |
  | geo      | geo code | optional |
  | family      | A protocol family (enumeration value) | optional |
  | proto      | a protocol (enumeration value) | optional |

  ### packetsled-get-files
  Retrieves file artifacts based on provided constraints. The files are delivered into the demisto war room.

  |argument  | description   |    |
  |:---|:---|:---|
  | start_time      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime | options, will default to 1 hour ago or lastRunTime |
  | stop_time     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime | optional, will default to "now" |
  | envid      | A unique id in packetsled to identify a group of sensors belonging to a single customer | optional, if not provided, all sensors are queried  |
  | probe      | A unique id within an envid used to identify a sensingle sensor | optional, if not provided, all sensors are queried  |
  | entity      | an ip address | optional |
  | port      | port | optional |
  | geo      | geo code | optional |
  | family      | A protocol family (enumeration value) | optional |
  | proto      | a protocol (enumeration value) | optional |

  ### packetsled-get-pcaps
  Retrieves full packet capture files based on provided constraints. The PCAP files are delivered into the demisto war room.

  |argument  | description   |    |
  |:---|:---|:---|
  | start_time      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime | options, will default to 1 hour ago or lastRunTime |
  | stop_time     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime | optional, will default to "now" |
  | envid      | A unique id in packetsled to identify a group of sensors belonging to a single customer | optional, if not provided, all sensors are queried  |
  | probe      | A unique id within an envid used to identify a sensingle sensor | optional, if not provided, all sensors are queried  |
  | entity      | an ip address | optional |
  | port      | port | optional |
  | proto      | a protocol (enumeration value) | optional |
configuration:
- display: The protocol and domain of the packetsled instance.
  name: ApiServer
  defaultvalue: https://www.packetsled.com
  type: 0
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: ""
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
script:
  script: |
    import requests
    import re
    import socket, struct
    import json
    import datetime, time
    import urllib
    from urlparse import urljoin
    requests.packages.urllib3.disable_warnings()

    def humanReadable(title, arr):
        if len(arr) > 0:
          return tableToMarkdown(title, arr, arr[0].keys())
        return arr

    def number_to_ip(n):
        if isinstance(n,str):
            return n
        try:
            return socket.inet_ntoa(struct.pack('!L', long(n)))
        except:
            return n

    def ip_to_number(i):
        try:
            return struct.unpack('!L', socket.inet_aton(i))[0]
        except:
            return i

    proto_map = {"tcp":10001,"udp":10002,"dns":10003,"dhcp":10004,"arp":10005,"finger":10006,"ncp":10007,"rpc":10008,"telnet":10009,"rlogin":10010,"citrix":10011,"dhcpv6":10012,"icmp":20001,"ntp":20003,"snmp":20004,"bgp":20005,"ripv1":20006,"ripv2":20007,"ipmi":20008,"ssh":30001,"ssl":30002,"openvpn":30003,"teredo":40001,"tunnel":40002,"ciscovpn_tcp":40003,"ciscovpn_udp":40004,"syslog":50001,"dce-rpc":60001,"xmpp":60002,"amqp":60003,"emp":60004,"dce-rpc-lsa":60005,"ident":70001,"radius":70002,"socks":70003,"kerberos":70004,"ntlm":70005,"login":80001,"rdp":80002,"vnc":80003,"pcanywhere":80004,"ftp":90001,"netbios":90002,"smb":90003,"ftp-data":90004,"irc-dcc-data":90005,"rsync":90006,"tftp":90007,"dropbox":90008,"bittorrent":100001,"gnutella":100002,"dnp3":110001,"modbus":110002,"gtpv1":120001,"gps":120002,"wiu":120003,"http":130001,"smtp":140001,"imap":140002,"pop3":140004,"mapi":140005,"mysql":150001,"irc":160001,"sip":170001}
    proto_inv_map = {v: k for k, v in proto_map.iteritems()}
    family_map = {'network_services':1,'network_management':2,'encrypted':3,'tunnel':4,'logging':5,'application_service':6,'authentication':7,'remote_access':8,'file_transfer':9,'p2p':10,'scada':11,'mobile':12,'web':13,'mail':14,'database':15,'chat':16,'voice':17}
    family_inv_map = {v: k for k, v in family_map.iteritems()}

    def format_flow(flow):
        if 'src_ip' in flow:
            flow['src_ip'] = number_to_ip(flow['src_ip'])
        if 'dest_ip' in flow:
            flow['dest_ip'] = number_to_ip(flow['dest_ip'])
        if 'time' in flow:
            flow['time'] = isoTime(flow['time'])
        if 'family' in flow:
            flow['family'] = map(lambda x: family_inv_map[x], flow['family'])
        if 'proto' in flow:
            flow['proto'] = map(lambda x: proto_inv_map[x], flow['proto'])
        return flow

    def get_flows(result):
        data = result['data'] or []
        return map(lambda x: format_flow(x), data)

    def validate_response(response):
        result = None
        if response.status_code == 200 :
            result = response.json()
        if result and result["status"] != 1 :
            raise Exception(str(result['message'] or 'an api error occurred'))
        demisto.debug(result)
        return result

    def getTime(t):
        try:
            return time.mktime(time.strptime(t, '%Y-%m-%dT%H:%M:%S.%fZ'))
        except:
            return long(t)

    def isoTime(epochTime):
        return datetime.datetime.fromtimestamp(epochTime).isoformat() + 'Z'

    def coalesceToArray(o):
        if not isinstance(o, list):
            return [o]
        return o

    def make_context(dargs):
        if 'probe' in dargs and 'envid' in dargs:
            sensor = {
              'probe': int(dargs['probe']),
              'envid': int(dargs['envid'])
              }
            return {
              'probes': [sensor],
              'dbs': ['probe_{envid}_{probe}'.format(**sensor)]
              }
        else:
            response = requests.get(urljoin(apiserver, '/admin/probes'),
            params = {
                'filterscount': 1,
                'filtercondition0': 'NOT_EQUAL',
                'filterdatafield0': 'deleted',
                'filtervalue0': 1
            },
            headers = {
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

            result = validate_response(response)
            return {
              'probes': result['rows'],
              'dbs': list(map(lambda x: 'probe_{envid}_{probe}'.format(**x), result['rows']))
              }

    def make_timerange(dargs):
        if 'stop_time' in dargs:
            tnow = getTime(dargs['stop_time'])
        else:
            tnow = long(time.mktime(datetime.datetime.now().timetuple()))

        if 'start_time' in dargs:
            tmin = getTime(dargs['start_time'])
        else:
            lastRun = demisto.getLastRun() and demisto.getLastRun()["time"]
            if len(lastRun) != 0:
                tmin = getTime(lastRun)
            else:
                tmin = tnow - 1*60*60

        return tmin, tnow

    def make_query(dargs):
        tmin, tnow = make_timerange(dargs)

        search = {'time': {'=': {'scalars': [], 'ranges': [{'v1': tmin, 'v2': tnow}]}}}

        if 'entity' in dargs:
            entity = coalesceToArray(dargs['entity'])
            search['ip'] = {
              '=': {
                'scalars': map(lambda x: {'v1': ip_to_number(x)}, entity),
                'ranges': []
                }
              }

        if 'protocol' in dargs:
            protocol = coalesceToArray(dargs['protocol'])
            search['proto'] = {
              '=': {
                'scalars': map(lambda x: {'v1': proto_map[x]}, protocol),
                'ranges': []
                }
              }

        if 'family' in dargs:
            family = coalesceToArray(dargs['family'])
            search['family'] = {
              '=': {
                'scalars': map(lambda x: {'v1': family_map[x]}, family),
                'ranges': []
                }
              }

        if 'geo' in dargs:
            geo = coalesceToArray(dargs['geo'])
            search['geo'] = {
              '=': {
                'scalars': map(lambda x: {'v1': x}, geo),
                'ranges': []
                }
              }

        if 'port' in dargs:
            port = coalesceToArray(dargs['port'])
            search['port'] = {
              '=': {
                'scalars': map(lambda x: {'v1': x}, port),
                'ranges': []
                }
              }

        return search

    apiserver = demisto.params()['ApiServer']
    username = demisto.params()['credentials']['identifier']
    password = demisto.params()['credentials']['password']

    response = requests.post(urljoin(apiserver, '/api/login'),
        data = {
        'email': username,
        'password': password
        },
        headers = {
        'cache-control': 'no-cache'
        },
        verify=False)

    if response.status_code == 200 :
        result = response.json()
        if result["status"] == 1 :
            auth_token = result["token"]

    if not auth_token:
        raise ValueError('Authorization failed')

    if demisto.command() == 'test-module':
        demisto.results('ok')
        sys.exit(0)

    if demisto.command() == 'packetsled-sensors':
        response = requests.get(urljoin(apiserver, '/admin/probes'),
        params = {
            'filterscount': 1,
            'filtercondition0': 'NOT_EQUAL',
            'filterdatafield0': 'deleted',
            'filtervalue0': 1
        },
        headers = {
            'cache-control': 'no-cache',
            'x-api-access-token': auth_token
        },
        verify=False)

        result = response.json()
        demisto.results({
          'HumanReadable': humanReadable('Sensors', result['rows']),
          'Type': entryTypes['note'],
          'ContentsFormat': formats['json'],
          'Contents': {
            'packetsled-sensors': result['rows']},
            'EntryContext': {
              'Packetsled.Sensors': result['rows']
              }
            })


    if demisto.command() == "fetch-incidents" or demisto.command() == 'packetsled-get-incidents':
        now = datetime.datetime.utcnow().isoformat()[:-3] + "Z"
        dargs = demisto.args()
        tmin,tnow = make_timerange(dargs)
        sensorContext = make_context(dargs)

        severity = 5
        if 'severity' in dargs:
            severity = int(dargs['severity'])

        search = {'severity': {'$gte': severity}, 'time': {'$lte': tnow, '$gte': tmin}}

        incidents = []
        for sensor in sensorContext['probes']:
            incidentContext = {'probes': [sensor], 'dbs': ['probe_{envid}_{probe}'.format(**sensor)]}

            ### query for incidents ###
            flows_query = {
                              "limit": 50000,
                              "pivot": {
                                  "attribute": "src_ip",
                                  "fields": ["log"],
                                  "dimensions": ["src_ip", "log"]
                              },
                              "query": {
                                  "time": {
                                      "=": {
                                          "scalars": [],
                                          "ranges": [{
                                              "lhs": "time",
                                              "v1": tmin,
                                              "v2": tnow
                                          }]
                                      }
                                  },
                                  "log": {
                                      "=": {
                                          "scalars": [{
                                              "i": 7,
                                              "t": "a",
                                              "v1": "intel"
                                          }, {
                                              "i": 9,
                                              "t": "a",
                                              "v1": "notice"
                                          }, {
                                              "i": 11,
                                              "t": "a",
                                              "v1": "psfile_analytics"
                                          }],
                                          "ranges": []
                                      }
                                  }
                              },
                              "search_text": "log = [intel notice psfile_analytics ] cluster src_ip on [log]"
                          }

            response = requests.post(urljoin(apiserver, '/flows/flows'),
                data = json.dumps({
                    'context': incidentContext,
                    'search': flows_query
                }),
                headers = {
                    'content-type': 'application/json',
                    'cache-control': 'no-cache',
                    'x-api-access-token': auth_token
                },
                verify=False)

            ### validate the response ###
            result = validate_response(response)
            entitys = map(lambda x: number_to_ip(x['name']), result['data'] or [])

            flows_query = {
                "limit": 50000,
                "pivot": {
                    "attribute": "dest_ip",
                    "fields": ["log"],
                    "dimensions": ["dest_ip", "log"]
                },
                "query": {
                    "time": {
                        "=": {
                            "scalars": [],
                            "ranges": [{
                                "lhs": "time",
                                "v1": tmin,
                                "v2": tnow
                            }]
                        }
                    },
                    "log": {
                        "=": {
                            "scalars": [{
                                "i": 7,
                                "t": "a",
                                "v1": "intel"
                            }, {
                                "i": 9,
                                "t": "a",
                                "v1": "notice"
                            }, {
                                "i": 11,
                                "t": "a",
                                "v1": "psfile_analytics"
                            }],
                            "ranges": []
                        }
                    }
                },
                "search_text": "log = [intel notice psfile_analytics ] cluster dest_ip on [log]"
            }

            response = requests.post(urljoin(apiserver, '/flows/flows'),
                data = json.dumps({
                    'context': incidentContext,
                    'search': flows_query
                }),
                headers = {
                    'content-type': 'application/json',
                    'cache-control': 'no-cache',
                    'x-api-access-token': auth_token
                },
                verify=False)

            ### validate the response ###
            result = validate_response(response)
            entitys += map(lambda x: number_to_ip(x['name']), result['data'] or [])
            entitys = list(set(entitys))

        if demisto.command() == "fetch-incidents":
            incidents += map(lambda x: {
                'id': x + '-' + str(tmin) + '-' + str(tnow),
                'name': 'SOURCE: Packetsled SENSOR: ' + sensor['label'] + ' ENTITY: ' + x,
                'labels': [{
                  'Provider': 'packetsled'
                }, {
                  'Sensor': sensor['label']
                }, {
                  'Entity': x
                }],
                'rawJSON': json.dumps({
                    'id': x + '-' + str(tmin) + '-' + str(tnow),
                    'log': ['intel', 'notice', 'psfile_analytics'],
                    'entity': x,
                    'start_time': tmin,
                    'stop_time': tnow,
                    'envid': sensor['envid'],
                    'probe': sensor['probe']
                })
            }, entitys)
            demisto.incidents(incidents)
        else:
            incidents += map(lambda x: {
              'id': x + '-' + str(tmin) + '-' + str(tnow),
              'log': ['intel', 'notice', 'psfile_analytics'],
              'entity': x,
              'start_time': tmin,
              'stop_time': tnow,
              'envid': sensor['envid'],
              'probe': sensor['probe']
            }, entitys)
            demisto.results({
                'HumanReadable': humanReadable('Incidents', incidents),
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': {
                    'packetsled-incidents': incidents
                },
                'EntryContext': {
                    'Packetsled.Incidents': incidents
                }
            })
        demisto.setLastRun({"time": now})

    if demisto.command() == 'packetsled-get-flows':
        dargs = demisto.args()

        limit = 5000
        if 'limit' in dargs:
            limit = long(dargs['limit'])
        search = make_query(dargs)
        sensorContext = make_context(dargs)

        ### query for flows ###
        response = requests.post(urljoin(apiserver, '/flows/flows'),
            data = json.dumps({
                'context': sensorContext,
                'search': {'query': search, 'limit': limit}
            }),
            headers = {
                'content-type': 'application/json',
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

        ### validate the response ###
        result = validate_response(response)
        flows = get_flows(result)
        demisto.results({
            'HumanReadable': humanReadable('Flows', flows),
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'packetsled-get-flows': flows
            },
            'EntryContext': {
                'Packetsled.Flows': flows
            }
        })
    if demisto.command() == 'packetsled-get-events':
        dargs = demisto.args()
        sensorContext = make_context(dargs)

        ### prepare a time range query on host ###
        uid = dargs['uid']

        ### times are expressed in UNIX epoch seconds ###
        ### search for any times greater than NOW minus 1 hours ###
        search = {'uid': uid}

        ### query for flows ###
        response = requests.post(urljoin(apiserver, '/flows/events'),
            data = json.dumps({
                'context': sensorContext,
                'search': search
            }),
            headers = {
                'content-type': 'application/json',
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

        ### validate the response ###
        result = validate_response(response)
        demisto.results({
            'HumanReadable': humanReadable('Events', result['data']),
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'packetsled-get-events': result['data']
            },
            'EntryContext': {
                'packetsled.events': result['data']
            }
        })
    if demisto.command() == 'packetsled-get-files':
        dargs = demisto.args()

        limit = 5000
        if 'limit' in dargs:
            limit = long(dargs['limit'])

        search = make_query(dargs)
        sensorContext = make_context(dargs)
        search["@attribute"] = {'=': {'scalars': [{'v1': 'extracted'}],'ranges': []}}

        ### query for flows ###
        response = requests.post(urljoin(apiserver, '/flows/flows'),
            data = json.dumps({
                'context': sensorContext,
                'search': {'query': search, 'limit': limit}
            }),
            headers = {
                'content-type': 'application/json',
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

        ### validate the response ###
        result = validate_response(response)
        ### iterate over the returned flows, looking for extracted files ###
        for flow in result["data"]:
            if 'extracted' in flow:
                for file in flow["extracted"]:

                    ### download the extracted file ###
                    response = requests.get(urljoin(apiserver, ('/download/file_extraction/{probe}/'+ file).format(**flow)),
                        headers = {
                            'cache-control': 'no-cache',
                            'x-api-access-token': auth_token
                        },
                        verify=False)

                    ### the download will return 404 if the file has been purged ###
                    if response.status_code == 200:
                        demisto.results(fileResult(file.replace('/','_'),response.content))

    if demisto.command() == 'packetsled-get-pcaps':
        dargs = demisto.args()
        tmin,tnow = make_timerange(dargs)
        sensorContext = make_context(dargs)

        query = "before " + isoTime(tnow) + " and after " + isoTime(tmin)

        if 'entity' in dargs:
            entity = coalesceToArray(dargs['entity'])
            if len(entity)>1:
                query = query + " and (" + " or ".join(map(lambda x: "host " + x, entity)) + ")"
            else:
                query = query + " and host " + entity[0]

        if 'protocol' in dargs:
            protocol = coalesceToArray(dargs['protocol'])
            if len(protocol)>1:
                query = query + " and (" + " or ".join(map(lambda x: x, protocol)) + ")"
            else:
                query = query + " and " + protocol[0]

        if 'port' in dargs:
            port = coalesceToArray(dargs['port'])
            if len(port)>1:
                query = query + " and (" + " or ".join(map(lambda x: "port " + x, port)) + ")"
            else:
                query = query + " and port " + port[0]

        for sensor in sensorContext['probes']:
            route = "?rule=" + urllib.quote(query)
            if 'limitbytes' in dargs:
                route = route + "&limitbytes=" + long(dargs['limitbytes'])

            if 'limitpkts' in dargs:
                route = route + "&limitpkts=" + long(dargs['limitpkts'])

            ### download the extracted file ###
            response = requests.get(urljoin(apiserver, ('/download/ndr/{probe}/'+ route).format(**sensor)),
                headers = {
                    'cache-control': 'no-cache',
                    'x-api-access-token': auth_token
                },
                verify=False)

            ### the download will return 404 if the file has been purged ###
            if response.status_code == 200:
                demisto.results(fileResult(query,response.content))
  type: python
  commands:
  - name: packetsled-get-incidents
    arguments:
    - name: severity
      auto: PREDEFINED
      predefined:
      - "0"
      - "1"
      - "2"
      - "3"
      - "4"
      - "5"
      - "6"
      - "7"
      - "8"
      - "9"
      - "10"
      description: Return incidents with severity greater than or equal to this value.
      defaultValue: "5"
    - name: start_time
      description: Start time to query for incidents.
    - name: stop_time
      description: Stop time to query for incidents.
    - name: probe
      description: The probe number
    - name: envid
      description: The environment id
    outputs:
    - contextPath: Packetsled.Incidents
      description: The list of incidents
    - contextPath: Packetsled.Incidents.id
      description: The id of the incident
    - contextPath: Packetsled.Incidents.entity
      description: The entity of the incident
    - contextPath: Packetsled.Incidents.log
      description: The log types for the incident
    - contextPath: Packetsled.Incidents.start_time
      description: The beginning of the time range containing the incident
    - contextPath: Packetsled.Incidents.stop_time
      description: The end of the time range containing the incident
    - contextPath: Packetsled.Incidents.envid
      description: The environment id of the incident
    - contextPath: Packetsled.Incidents.probe
      description: The probe number of the incident
    description: Query for incidents by time range and severity
  - name: packetsled-sensors
    arguments: []
    outputs:
    - contextPath: Packetsled.Sensors
      description: The list of sensors
    - contextPath: Packetsled.Sensors.label
      description: The label of the sensor
    - contextPath: Packetsled.Sensors.envid
      description: The environment id of the sensor
    - contextPath: Packetsled.Sensors.probe
      description: The probe number of the sensor
    description: List the sensors attached to the packetsled platform.
  - name: packetsled-get-flows
    arguments:
    - name: entity
      description: The ip of the entity to query flows for
    - name: protocol
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - dns
      - dhcp
      - arp
      - finger
      - ncp
      - rpc
      - telnet
      - rlogin
      - citrix
      - dhcpv6
      - icmp
      - ntp
      - snmp
      - bgp
      - ripv1
      - ripv2
      - ipmi
      - ssh
      - ssl
      - openvpn
      - teredo
      - tunnel
      - ciscovpn_tcp
      - ciscovpn_udp
      - syslog
      - dce-rpc
      - xmpp
      - amqp
      - emp
      - dce-rpc-lsa
      - ident
      - radius
      - socks
      - kerberos
      - ntlm
      - login
      - rdp
      - vnc
      - pcanywhere
      - ftp
      - netbios
      - smb
      - ftp-data
      - irc-dcc-data
      - rsync
      - tftp
      - dropbox
      - bittorrent
      - gnutella
      - dnp3
      - modbus
      - gtpv1
      - gps
      - wiu
      - http
      - smtp
      - imap
      - pop3
      - mapi
      - mysql
      - irc
      - sip
      description: The protocol
    - name: family
      auto: PREDEFINED
      predefined:
      - network_services
      - network_management
      - encrypted
      - tunnel
      - logging
      - application_service
      - authentication
      - remote_access
      - file_transfer
      - p2p
      - scada
      - mobile
      - web
      - mail
      - database
      - chat
      - voice
      description: The protocol family
    - name: log
      auto: PREDEFINED
      predefined:
      - app_stats
      - arp
      - bittorrent
      - communication
      - conn
      - credit_card_exposure
      - dce_rpc
      - dce_rpc_lsa
      - dhcp
      - dhcpv6
      - dnp3
      - dns
      - dpd
      - files
      - ftp
      - gnutella
      - http
      - icmp
      - imap
      - intel
      - irc
      - kerberos
      - known_certs
      - known_hosts
      - known_services
      - loaded_scripts
      - mqtt
      - mysql
      - notice
      - ntlm
      - ntp
      - openvpn
      - packet_filter
      - pcr
      - pe
      - pop3
      - ps_long_running_flows
      - psanalytics
      - psfile_analytics
      - rdp
      - reporter
      - rfb
      - sip
      - smb_auth
      - smb_cmd
      - smb_files
      - smb_mapping
      - smtp
      - snmp
      - socks
      - software
      - ssh
      - ssl
      - stats
      - syslog
      - tcp
      - telnet
      - traceroute
      - tunnel
      - udp
      - weird
      - x509
      description: The log name
    - name: geo
      description: The 2-digit geo code,' local', or 'private'
    - name: port
      description: The port number
    - name: start_time
      description: The beginning of the time range to query. Either an ISO time string
        or seconds since the epoch.
    - name: stop_time
      description: The end of the time range to query. Either an ISO time string or
        seconds since the epoch.
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    - name: limit
      description: Limit the number of search results
      defaultValue: "5000"
    outputs:
    - contextPath: Packetsled.Flows
      description: Flow metadata
    - contextPath: Packetsled.Flows._id
      description: The unique id of the flow
    - contextPath: Packetsled.Flows.src_ip
      description: The originator of the flow
    - contextPath: Packetsled.Flows.dest_ip
      description: The respondant of the flow
    description: Query packetsled sensor metadata
  - name: packetsled-get-files
    arguments:
    - name: entity
      description: The ip of the entity to query flows for
    - name: protocol
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - dns
      - dhcp
      - arp
      - finger
      - ncp
      - rpc
      - telnet
      - rlogin
      - citrix
      - dhcpv6
      - icmp
      - ntp
      - snmp
      - bgp
      - ripv1
      - ripv2
      - ipmi
      - ssh
      - ssl
      - openvpn
      - teredo
      - tunnel
      - ciscovpn_tcp
      - ciscovpn_udp
      - syslog
      - dce-rpc
      - xmpp
      - amqp
      - emp
      - dce-rpc-lsa
      - ident
      - radius
      - socks
      - kerberos
      - ntlm
      - login
      - rdp
      - vnc
      - pcanywhere
      - ftp
      - netbios
      - smb
      - ftp-data
      - irc-dcc-data
      - rsync
      - tftp
      - dropbox
      - bittorrent
      - gnutella
      - dnp3
      - modbus
      - gtpv1
      - gps
      - wiu
      - http
      - smtp
      - imap
      - pop3
      - mapi
      - mysql
      - irc
      - sip
      description: The protocol
    - name: family
      auto: PREDEFINED
      predefined:
      - network_services
      - network_management
      - encrypted
      - tunnel
      - logging
      - application_service
      - authentication
      - remote_access
      - file_transfer
      - p2p
      - scada
      - mobile
      - web
      - mail
      - database
      - chat
      - voice
      description: The protocol family
    - name: log
      auto: PREDEFINED
      predefined:
      - app_stats
      - arp
      - bittorrent
      - communication
      - conn
      - credit_card_exposure
      - dce_rpc
      - dce_rpc_lsa
      - dhcp
      - dhcpv6
      - dnp3
      - dns
      - dpd
      - files
      - ftp
      - gnutella
      - http
      - icmp
      - imap
      - intel
      - irc
      - kerberos
      - known_certs
      - known_hosts
      - known_services
      - loaded_scripts
      - mqtt
      - mysql
      - notice
      - ntlm
      - ntp
      - openvpn
      - packet_filter
      - pcr
      - pe
      - pop3
      - ps_long_running_flows
      - psanalytics
      - psfile_analytics
      - rdp
      - reporter
      - rfb
      - sip
      - smb_auth
      - smb_cmd
      - smb_files
      - smb_mapping
      - smtp
      - snmp
      - socks
      - software
      - ssh
      - ssl
      - stats
      - syslog
      - tcp
      - telnet
      - traceroute
      - tunnel
      - udp
      - weird
      - x509
      description: The log name
    - name: geo
      description: The 2-digit geo code,' local', or 'private'
    - name: port
      description: The port number
    - name: start_time
      description: The beginning of the time range to query. Either an ISO time string
        or seconds since the epoch.
    - name: stop_time
      description: The end of the time range to query. Either an ISO time string or
        seconds since the epoch.
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    - name: limit
      description: Limit the number of search results
      defaultValue: "5000"
    description: Query packetsled extracted files
  - name: packetsled-get-pcaps
    arguments:
    - name: entity
      description: The ip of the entity to query flows for
    - name: protocol
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - dns
      - dhcp
      - arp
      - finger
      - ncp
      - rpc
      - telnet
      - rlogin
      - citrix
      - dhcpv6
      - icmp
      - ntp
      - snmp
      - bgp
      - ripv1
      - ripv2
      - ipmi
      - ssh
      - ssl
      - openvpn
      - teredo
      - tunnel
      - ciscovpn_tcp
      - ciscovpn_udp
      - syslog
      - dce-rpc
      - xmpp
      - amqp
      - emp
      - dce-rpc-lsa
      - ident
      - radius
      - socks
      - kerberos
      - ntlm
      - login
      - rdp
      - vnc
      - pcanywhere
      - ftp
      - netbios
      - smb
      - ftp-data
      - irc-dcc-data
      - rsync
      - tftp
      - dropbox
      - bittorrent
      - gnutella
      - dnp3
      - modbus
      - gtpv1
      - gps
      - wiu
      - http
      - smtp
      - imap
      - pop3
      - mapi
      - mysql
      - irc
      - sip
      description: The protocol
    - name: port
      description: The port number
    - name: start_time
      description: The beginning of the time range to query. Either an ISO time string
        or seconds since the epoch.
    - name: stop_time
      description: The end of the time range to query. Either an ISO time string or
        seconds since the epoch.
    - name: limitbytes
      description: The upper bound on the number of bytes to return from the query
    - name: limitpkts
      description: The upper bound on the number of packets to process from the query
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    description: Query packetsled for full packet
  - name: packetsled-get-events
    arguments:
    - name: uid
      required: true
      description: The uid to retrieve logs for. Use the _id attribute from a flow for this parameter value.
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    outputs:
    - contextPath: Packetsled.Events
      description: Retrieve all logs for a single flow
    - contextPath: Packetsled.Events._id
      description: The unique id of the Event
    - contextPath: Packetsled.Events.src_ip
      description: The originator of the Events
    - contextPath: Packetsled.Events.dest_ip
      description: The respondant of the Events
    description: Get all of the events for a given uid
  isfetch: true
