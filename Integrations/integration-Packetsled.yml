commonfields:
  id: Packetsled
  version: -1
name: Packetsled
display: Packetsled
category: Network Security
image: data:image/png;base64,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
description: Packetsled Network Security API commands
detaileddescription: |
  # Packetsled Demisto Integration

  Provides ability to enumerate sensors, enumerate entities (hosts) that have incidents, and to retrieve metadata, file, and packet capture artifacts from the Packetsled API.

  Examples:

  To enumerate all attached sensors:

  ```
  !packetsled-get-sensors
  ```

  To search for all incidents since the last time they were retrieved:

  ```
  !packetsled-get-incidents
  ```

  To search for metadata for a specific host:

  ```
  !packetsled-get-flows entity=192.168.0.110 limit=10000
  ```

  To deliver a pcap for a given entity to the demisto war room:

  ```
  !packetsled-get-pcaps entity=192.168.0.110
  ```

  ## Commands

  ### packetsled-get-incidents
  Fetches incidents of the form:
  ```json
  {"name": "Source: Packetsled SENSOR: <sensor label>, ENTITY: <ip address>", "rawJSON": {<packetsled incident>}}
  ```
  |argument  | description   |
  |---|---|
  | `start_time`      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime - options, will default to 1 hour ago or lastRunTime |
  |  `stop_time`   | The end of the time range to query, can be either epoch seconds or ISO formatted datetime - optional, will default to "now" |
  |  `envid`      | A unique id in packetsled to identify a group of sensors belonging to a single customer - optional, if not provided, all sensors are queried  |
  |  `probe`      | A unique id within an envid used to identify a sensingle sensor - optional, if not provided, all sensors are queried  |

  ### packetsled-get-flows
  Retrieves flow metadata based on provided constraints. The flows are delivered as JSON files into the demisto war room.

  |argument  | description   |
  |---|---|
  | `start_time`  | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime - options, will default to 1 hour ago or lastRunTime |
  | `stop_time`     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime - optional, will default to "now" |
  | `envid`      | A unique id in packetsled to identify a group of sensors belonging to a single customer - optional, if not provided, all sensors are queried  |
  | `probe`      | A unique id within an envid used to identify a sensingle sensor - optional, if not provided, all sensors are queried  |
  |  `entity`      | an ip address - optional |
  |  `port`     | port - optional |
  |  `geo`     | geo code - optional |
  |  `family`     | A protocol family (enumeration value) - optional |
  |  `proto`      | a protocol (enumeration value) - optional |

  ### packetsled-get-files
  Retrieves file artifacts based on provided constraints. The files are delivered into the demisto war room.

  |argument  | description   |
  |:---|:---|
  | `start_time`      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime - options, will default to 1 hour ago or lastRunTime |
  |  `stop_time`     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime - optional, will default to "now" |
  |  `envid`      | A unique id in packetsled to identify a group of sensors belonging to a single customer - optional, if not provided, all sensors are queried  |
  |  `probe`      | A unique id within an envid used to identify a sensingle sensor - optional, if not provided, all sensors are queried  |
  | `entity `     | an ip address - optional |
  |  `port `     | port - optional |
  |  `geo `     | geo code - optional |
  |  `family`      | A protocol family (enumeration value) - optional |
  |  `proto`      | a protocol (enumeration value) - optional |

  ### packetsled-get-pcaps
  Retrieves full packet capture files based on provided constraints. The PCAP files are delivered into the demisto war room.

  |argument  | description   |
  |:---|:---|
  | ` start_time`      | The beginning of the time range to query, can be either epoch seconds or ISO formatted datetime - options, will default to 1 hour ago or lastRunTime |
  | ` stop_time`     | The end of the time range to query, can be either epoch seconds or ISO formatted datetime - optional, will default to "now" |
  |  `envid`      | A unique id in packetsled to identify a group of sensors belonging to a single customer - optional, if not provided, all sensors are queried  |
  |  `probe`     | A unique id within an envid used to identify a sensingle sensor - optional, if not provided, all sensors are queried  |
  |  `entity`      | an ip address | optional |
  |  `port`     | port | optional |
  |  `proto`      | a protocol (enumeration value) - optional |
configuration:
- display: The protocol and domain of the packetsled instance.
  name: ApiServer
  defaultvalue: https://www.packetsled.com
  type: 0
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: ""
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
script:
  script: |
    import requests
    import re
    import socket, struct
    import json
    import datetime, time
    import urllib
    from urlparse import urljoin
    requests.packages.urllib3.disable_warnings()

    def humanReadable(title, arr):
        if len(arr) > 0:
          return tableToMarkdown(title, arr, arr[0].keys())
        return arr

    def number_to_ip(n):
        if isinstance(n,str):
            return n
        try:
            return socket.inet_ntoa(struct.pack('!L', long(n)))
        except:
            return n

    def ip_to_number(i):
        try:
            return struct.unpack('!L', socket.inet_aton(i))[0]
        except:
            return i

    proto_map = {"tcp":10001,"udp":10002,"dns":10003,"dhcp":10004,"arp":10005,"finger":10006,"ncp":10007,"rpc":10008,"telnet":10009,"rlogin":10010,"citrix":10011,"dhcpv6":10012,"icmp":20001,"ntp":20003,"snmp":20004,"bgp":20005,"ripv1":20006,"ripv2":20007,"ipmi":20008,"ssh":30001,"ssl":30002,"openvpn":30003,"teredo":40001,"tunnel":40002,"ciscovpn_tcp":40003,"ciscovpn_udp":40004,"syslog":50001,"dce-rpc":60001,"xmpp":60002,"amqp":60003,"emp":60004,"dce-rpc-lsa":60005,"ident":70001,"radius":70002,"socks":70003,"kerberos":70004,"ntlm":70005,"login":80001,"rdp":80002,"vnc":80003,"pcanywhere":80004,"ftp":90001,"netbios":90002,"smb":90003,"ftp-data":90004,"irc-dcc-data":90005,"rsync":90006,"tftp":90007,"dropbox":90008,"bittorrent":100001,"gnutella":100002,"dnp3":110001,"modbus":110002,"gtpv1":120001,"gps":120002,"wiu":120003,"http":130001,"smtp":140001,"imap":140002,"pop3":140004,"mapi":140005,"mysql":150001,"irc":160001,"sip":170001}
    proto_inv_map = {v: k for k, v in proto_map.iteritems()}
    family_map = {'network_services':1,'network_management':2,'encrypted':3,'tunnel':4,'logging':5,'application_service':6,'authentication':7,'remote_access':8,'file_transfer':9,'p2p':10,'scada':11,'mobile':12,'web':13,'mail':14,'database':15,'chat':16,'voice':17}
    family_inv_map = {v: k for k, v in family_map.iteritems()}

    def format_flow(flow):
        if 'src_ip' in flow:
            flow['src_ip'] = number_to_ip(flow['src_ip'])
        if 'dest_ip' in flow:
            flow['dest_ip'] = number_to_ip(flow['dest_ip'])
        if 'time' in flow:
            flow['time'] = isoTime(flow['time'])
        if 'family' in flow:
            flow['family'] = map(lambda x: family_inv_map[x], flow['family'])
        if 'proto' in flow:
            flow['proto'] = map(lambda x: proto_inv_map[x], flow['proto'])
        return flow

    def get_flows(result):
        data = result['data'] or []
        return map(lambda x: format_flow(x), data)

    def validate_response(response):
        result = None
        if response.status_code == 200 :
            result = response.json()
        if result and result["status"] != 1 :
            raise Exception(str(result['message'] or 'an api error occurred'))
        demisto.debug(result)
        return result

    def getTime(t):
        try:
            return time.mktime(time.strptime(t, '%Y-%m-%dT%H:%M:%S.%fZ'))
        except:
            return long(t)

    def isoTime(epochTime):
        return datetime.datetime.fromtimestamp(epochTime).isoformat() + 'Z'

    def coalesceToArray(o):
        if not isinstance(o, list):
            return [o]
        return o

    def make_context(dargs):
        if 'probe' in dargs and 'envid' in dargs:
            sensor = {
              'probe': int(dargs['probe']),
              'envid': int(dargs['envid'])
              }
            return {
              'probes': [sensor],
              'dbs': ['probe_{envid}_{probe}'.format(**sensor)]
              }
        else:
            response = requests.get(urljoin(apiserver, '/admin/probes'),
            params = {
                'filterscount': 1,
                'filtercondition0': 'NOT_EQUAL',
                'filterdatafield0': 'deleted',
                'filtervalue0': 1
            },
            headers = {
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

            result = validate_response(response)
            return {
              'probes': result['rows'],
              'dbs': list(map(lambda x: 'probe_{envid}_{probe}'.format(**x), result['rows']))
              }

    def make_timerange(dargs):
        if 'stop_time' in dargs:
            tnow = getTime(dargs['stop_time'])
        else:
            tnow = long(time.mktime(datetime.datetime.now().timetuple()))

        if 'start_time' in dargs:
            tmin = getTime(dargs['start_time'])
        else:
            lastRun = demisto.getLastRun() and demisto.getLastRun()["time"]
            if len(lastRun) != 0:
                tmin = getTime(lastRun)
            else:
                tmin = tnow - 1*60*60

        return tmin, tnow

    def make_query(dargs):
        tmin, tnow = make_timerange(dargs)

        search = {'time': {'=': {'scalars': [], 'ranges': [{'v1': tmin, 'v2': tnow}]}}}

        if 'entity' in dargs:
            entity = coalesceToArray(dargs['entity'])
            search['ip'] = {
              '=': {
                'scalars': map(lambda x: {'v1': ip_to_number(x)}, entity),
                'ranges': []
                }
              }

        if 'protocol' in dargs:
            protocol = coalesceToArray(dargs['protocol'])
            search['proto'] = {
              '=': {
                'scalars': map(lambda x: {'v1': proto_map[x]}, protocol),
                'ranges': []
                }
              }

        if 'family' in dargs:
            family = coalesceToArray(dargs['family'])
            search['family'] = {
              '=': {
                'scalars': map(lambda x: {'v1': family_map[x]}, family),
                'ranges': []
                }
              }

        if 'geo' in dargs:
            geo = coalesceToArray(dargs['geo'])
            search['geo'] = {
              '=': {
                'scalars': map(lambda x: {'v1': x}, geo),
                'ranges': []
                }
              }

        if 'port' in dargs:
            port = coalesceToArray(dargs['port'])
            search['port'] = {
              '=': {
                'scalars': map(lambda x: {'v1': x}, port),
                'ranges': []
                }
              }

        return search

    apiserver = demisto.params()['ApiServer']
    username = demisto.params()['credentials']['identifier']
    password = demisto.params()['credentials']['password']

    response = requests.post(urljoin(apiserver, '/api/login'),
        data = {
        'email': username,
        'password': password
        },
        headers = {
        'cache-control': 'no-cache'
        },
        verify=False)

    if response.status_code == 200 :
        result = response.json()
        if result["status"] == 1 :
            auth_token = result["token"]

    if not auth_token:
        raise ValueError('Authorization failed')

    if demisto.command() == 'test-module':
        demisto.results('ok')
        sys.exit(0)

    if demisto.command() == 'packetsled-sensors':
        response = requests.get(urljoin(apiserver, '/admin/probes'),
        params = {
            'filterscount': 1,
            'filtercondition0': 'NOT_EQUAL',
            'filterdatafield0': 'deleted',
            'filtervalue0': 1
        },
        headers = {
            'cache-control': 'no-cache',
            'x-api-access-token': auth_token
        },
        verify=False)

        result = response.json()
        demisto.results({
          'HumanReadable': humanReadable('Sensors', result['rows']),
          'Type': entryTypes['note'],
          'ContentsFormat': formats['json'],
          'Contents': {
            'packetsled-sensors': result['rows']},
            'EntryContext': {
              'Packetsled.Sensors': result['rows']
              }
            })


    if demisto.command() == "fetch-incidents" or demisto.command() == 'packetsled-get-incidents':
        now = datetime.datetime.utcnow().isoformat()[:-3] + "Z"
        dargs = demisto.args()
        tmin,tnow = make_timerange(dargs)
        sensorContext = make_context(dargs)

        severity = 5
        if 'severity' in dargs:
            severity = int(dargs['severity'])

        search = {'severity': {'$gte': severity}, 'time': {'$lte': tnow, '$gte': tmin}}

        incidents = []
        for sensor in sensorContext['probes']:
            incidentContext = {'probes': [sensor], 'dbs': ['probe_{envid}_{probe}'.format(**sensor)]}

            ### query for incidents ###
            flows_query = {
                              "limit": 50000,
                              "pivot": {
                                  "attribute": "src_ip",
                                  "fields": ["log"],
                                  "dimensions": ["src_ip", "log"]
                              },
                              "query": {
                                  "time": {
                                      "=": {
                                          "scalars": [],
                                          "ranges": [{
                                              "lhs": "time",
                                              "v1": tmin,
                                              "v2": tnow
                                          }]
                                      }
                                  },
                                  "log": {
                                      "=": {
                                          "scalars": [{
                                              "i": 7,
                                              "t": "a",
                                              "v1": "intel"
                                          }, {
                                              "i": 9,
                                              "t": "a",
                                              "v1": "notice"
                                          }, {
                                              "i": 11,
                                              "t": "a",
                                              "v1": "psfile_analytics"
                                          }],
                                          "ranges": []
                                      }
                                  }
                              },
                              "search_text": "log = [intel notice psfile_analytics ] cluster src_ip on [log]"
                          }

            response = requests.post(urljoin(apiserver, '/flows/flows'),
                data = json.dumps({
                    'context': incidentContext,
                    'search': flows_query
                }),
                headers = {
                    'content-type': 'application/json',
                    'cache-control': 'no-cache',
                    'x-api-access-token': auth_token
                },
                verify=False)

            ### validate the response ###
            result = validate_response(response)
            entitys = map(lambda x: number_to_ip(x['name']), result['data'] or [])

            flows_query = {
                "limit": 50000,
                "pivot": {
                    "attribute": "dest_ip",
                    "fields": ["log"],
                    "dimensions": ["dest_ip", "log"]
                },
                "query": {
                    "time": {
                        "=": {
                            "scalars": [],
                            "ranges": [{
                                "lhs": "time",
                                "v1": tmin,
                                "v2": tnow
                            }]
                        }
                    },
                    "log": {
                        "=": {
                            "scalars": [{
                                "i": 7,
                                "t": "a",
                                "v1": "intel"
                            }, {
                                "i": 9,
                                "t": "a",
                                "v1": "notice"
                            }, {
                                "i": 11,
                                "t": "a",
                                "v1": "psfile_analytics"
                            }],
                            "ranges": []
                        }
                    }
                },
                "search_text": "log = [intel notice psfile_analytics ] cluster dest_ip on [log]"
            }

            response = requests.post(urljoin(apiserver, '/flows/flows'),
                data = json.dumps({
                    'context': incidentContext,
                    'search': flows_query
                }),
                headers = {
                    'content-type': 'application/json',
                    'cache-control': 'no-cache',
                    'x-api-access-token': auth_token
                },
                verify=False)

            ### validate the response ###
            result = validate_response(response)
            entitys += map(lambda x: number_to_ip(x['name']), result['data'] or [])
            entitys = list(set(entitys))

        if demisto.command() == "fetch-incidents":
            incidents += map(lambda x: {
                'id': x + '-' + str(tmin) + '-' + str(tnow),
                'name': 'SOURCE: Packetsled SENSOR: ' + sensor['label'] + ' ENTITY: ' + x,
                'labels': [{
                  'Provider': 'packetsled'
                }, {
                  'Sensor': sensor['label']
                }, {
                  'Entity': x
                }],
                'rawJSON': json.dumps({
                    'id': x + '-' + str(tmin) + '-' + str(tnow),
                    'log': ['intel', 'notice', 'psfile_analytics'],
                    'entity': x,
                    'start_time': tmin,
                    'stop_time': tnow,
                    'envid': sensor['envid'],
                    'probe': sensor['probe']
                })
            }, entitys)
            demisto.incidents(incidents)
        else:
            incidents += map(lambda x: {
              'id': x + '-' + str(tmin) + '-' + str(tnow),
              'log': ['intel', 'notice', 'psfile_analytics'],
              'entity': x,
              'start_time': tmin,
              'stop_time': tnow,
              'envid': sensor['envid'],
              'probe': sensor['probe']
            }, entitys)
            demisto.results({
                'HumanReadable': humanReadable('Incidents', incidents),
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': {
                    'packetsled-incidents': incidents
                },
                'EntryContext': {
                    'Packetsled.Incidents': incidents
                }
            })
        demisto.setLastRun({"time": now})

    if demisto.command() == 'packetsled-get-flows':
        dargs = demisto.args()

        limit = 5000
        if 'limit' in dargs:
            limit = long(dargs['limit'])
        search = make_query(dargs)
        sensorContext = make_context(dargs)

        ### query for flows ###
        response = requests.post(urljoin(apiserver, '/flows/flows'),
            data = json.dumps({
                'context': sensorContext,
                'search': {'query': search, 'limit': limit}
            }),
            headers = {
                'content-type': 'application/json',
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

        ### validate the response ###
        result = validate_response(response)
        flows = get_flows(result)
        demisto.results({
            'HumanReadable': humanReadable('Flows', flows),
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'packetsled-get-flows': flows
            },
            'EntryContext': {
                'Packetsled.Flows': flows
            }
        })
    if demisto.command() == 'packetsled-get-events':
        dargs = demisto.args()
        sensorContext = make_context(dargs)

        ### prepare a time range query on host ###
        uid = dargs['uid']

        ### times are expressed in UNIX epoch seconds ###
        ### search for any times greater than NOW minus 1 hours ###
        search = {'uid': uid}

        ### query for flows ###
        response = requests.post(urljoin(apiserver, '/flows/events'),
            data = json.dumps({
                'context': sensorContext,
                'search': search
            }),
            headers = {
                'content-type': 'application/json',
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

        ### validate the response ###
        result = validate_response(response)
        demisto.results({
            'HumanReadable': humanReadable('Events', result['data']),
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'packetsled-get-events': result['data']
            },
            'EntryContext': {
                'packetsled.events': result['data']
            }
        })
    if demisto.command() == 'packetsled-get-files':
        dargs = demisto.args()

        limit = 5000
        if 'limit' in dargs:
            limit = long(dargs['limit'])

        search = make_query(dargs)
        sensorContext = make_context(dargs)
        search["@attribute"] = {'=': {'scalars': [{'v1': 'extracted'}],'ranges': []}}

        ### query for flows ###
        response = requests.post(urljoin(apiserver, '/flows/flows'),
            data = json.dumps({
                'context': sensorContext,
                'search': {'query': search, 'limit': limit}
            }),
            headers = {
                'content-type': 'application/json',
                'cache-control': 'no-cache',
                'x-api-access-token': auth_token
            },
            verify=False)

        ### validate the response ###
        result = validate_response(response)
        ### iterate over the returned flows, looking for extracted files ###
        for flow in result["data"]:
            if 'extracted' in flow:
                for file in flow["extracted"]:

                    ### download the extracted file ###
                    response = requests.get(urljoin(apiserver, ('/download/file_extraction/{probe}/'+ file).format(**flow)),
                        headers = {
                            'cache-control': 'no-cache',
                            'x-api-access-token': auth_token
                        },
                        verify=False)

                    ### the download will return 404 if the file has been purged ###
                    if response.status_code == 200:
                        demisto.results(fileResult(file.replace('/','_'),response.content))

    if demisto.command() == 'packetsled-get-pcaps':
        dargs = demisto.args()
        tmin,tnow = make_timerange(dargs)
        sensorContext = make_context(dargs)

        query = "before " + isoTime(tnow) + " and after " + isoTime(tmin)

        if 'entity' in dargs:
            entity = coalesceToArray(dargs['entity'])
            if len(entity)>1:
                query = query + " and (" + " or ".join(map(lambda x: "host " + x, entity)) + ")"
            else:
                query = query + " and host " + entity[0]

        if 'protocol' in dargs:
            protocol = coalesceToArray(dargs['protocol'])
            if len(protocol)>1:
                query = query + " and (" + " or ".join(map(lambda x: x, protocol)) + ")"
            else:
                query = query + " and " + protocol[0]

        if 'port' in dargs:
            port = coalesceToArray(dargs['port'])
            if len(port)>1:
                query = query + " and (" + " or ".join(map(lambda x: "port " + x, port)) + ")"
            else:
                query = query + " and port " + port[0]

        for sensor in sensorContext['probes']:
            route = "?rule=" + urllib.quote(query)
            if 'limitbytes' in dargs:
                route = route + "&limitbytes=" + long(dargs['limitbytes'])

            if 'limitpkts' in dargs:
                route = route + "&limitpkts=" + long(dargs['limitpkts'])

            ### download the extracted file ###
            response = requests.get(urljoin(apiserver, ('/download/ndr/{probe}/'+ route).format(**sensor)),
                headers = {
                    'cache-control': 'no-cache',
                    'x-api-access-token': auth_token
                },
                verify=False)

            ### the download will return 404 if the file has been purged ###
            if response.status_code == 200:
                demisto.results(fileResult(query,response.content))
  type: python
  commands:
  - name: packetsled-get-incidents
    arguments:
    - name: severity
      auto: PREDEFINED
      predefined:
      - "0"
      - "1"
      - "2"
      - "3"
      - "4"
      - "5"
      - "6"
      - "7"
      - "8"
      - "9"
      - "10"
      description: Return incidents with severity greater than or equal to this value.
      defaultValue: "5"
    - name: start_time
      description: Start time to query for incidents.
    - name: stop_time
      description: Stop time to query for incidents.
    - name: probe
      description: The probe number
    - name: envid
      description: The environment id
    outputs:
    - contextPath: Packetsled.Incidents
      description: The list of incidents
    - contextPath: Packetsled.Incidents.id
      description: The id of the incident
    - contextPath: Packetsled.Incidents.entity
      description: The entity of the incident
    - contextPath: Packetsled.Incidents.log
      description: The log types for the incident
    - contextPath: Packetsled.Incidents.start_time
      description: The beginning of the time range containing the incident
    - contextPath: Packetsled.Incidents.stop_time
      description: The end of the time range containing the incident
    - contextPath: Packetsled.Incidents.envid
      description: The environment id of the incident
    - contextPath: Packetsled.Incidents.probe
      description: The probe number of the incident
    description: Query for incidents by time range and severity
  - name: packetsled-sensors
    arguments: []
    outputs:
    - contextPath: Packetsled.Sensors
      description: The list of sensors
    - contextPath: Packetsled.Sensors.label
      description: The label of the sensor
    - contextPath: Packetsled.Sensors.envid
      description: The environment id of the sensor
    - contextPath: Packetsled.Sensors.probe
      description: The probe number of the sensor
    description: List the sensors attached to the packetsled platform.
  - name: packetsled-get-flows
    arguments:
    - name: entity
      description: The ip of the entity to query flows for
    - name: protocol
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - dns
      - dhcp
      - arp
      - finger
      - ncp
      - rpc
      - telnet
      - rlogin
      - citrix
      - dhcpv6
      - icmp
      - ntp
      - snmp
      - bgp
      - ripv1
      - ripv2
      - ipmi
      - ssh
      - ssl
      - openvpn
      - teredo
      - tunnel
      - ciscovpn_tcp
      - ciscovpn_udp
      - syslog
      - dce-rpc
      - xmpp
      - amqp
      - emp
      - dce-rpc-lsa
      - ident
      - radius
      - socks
      - kerberos
      - ntlm
      - login
      - rdp
      - vnc
      - pcanywhere
      - ftp
      - netbios
      - smb
      - ftp-data
      - irc-dcc-data
      - rsync
      - tftp
      - dropbox
      - bittorrent
      - gnutella
      - dnp3
      - modbus
      - gtpv1
      - gps
      - wiu
      - http
      - smtp
      - imap
      - pop3
      - mapi
      - mysql
      - irc
      - sip
      description: The protocol
    - name: family
      auto: PREDEFINED
      predefined:
      - network_services
      - network_management
      - encrypted
      - tunnel
      - logging
      - application_service
      - authentication
      - remote_access
      - file_transfer
      - p2p
      - scada
      - mobile
      - web
      - mail
      - database
      - chat
      - voice
      description: The protocol family
    - name: log
      auto: PREDEFINED
      predefined:
      - app_stats
      - arp
      - bittorrent
      - communication
      - conn
      - credit_card_exposure
      - dce_rpc
      - dce_rpc_lsa
      - dhcp
      - dhcpv6
      - dnp3
      - dns
      - dpd
      - files
      - ftp
      - gnutella
      - http
      - icmp
      - imap
      - intel
      - irc
      - kerberos
      - known_certs
      - known_hosts
      - known_services
      - loaded_scripts
      - mqtt
      - mysql
      - notice
      - ntlm
      - ntp
      - openvpn
      - packet_filter
      - pcr
      - pe
      - pop3
      - ps_long_running_flows
      - psanalytics
      - psfile_analytics
      - rdp
      - reporter
      - rfb
      - sip
      - smb_auth
      - smb_cmd
      - smb_files
      - smb_mapping
      - smtp
      - snmp
      - socks
      - software
      - ssh
      - ssl
      - stats
      - syslog
      - tcp
      - telnet
      - traceroute
      - tunnel
      - udp
      - weird
      - x509
      description: The log name
    - name: geo
      description: The 2-digit geo code,' local', or 'private'
    - name: port
      description: The port number
    - name: start_time
      description: The beginning of the time range to query. Either an ISO time string
        or seconds since the epoch.
    - name: stop_time
      description: The end of the time range to query. Either an ISO time string or
        seconds since the epoch.
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    - name: limit
      description: Limit the number of search results
      defaultValue: "5000"
    outputs:
    - contextPath: Packetsled.Flows
      description: Flow metadata
    - contextPath: Packetsled.Flows._id
      description: The unique id of the flow
    - contextPath: Packetsled.Flows.src_ip
      description: The originator of the flow
    - contextPath: Packetsled.Flows.dest_ip
      description: The respondant of the flow
    description: Query packetsled sensor metadata
  - name: packetsled-get-files
    arguments:
    - name: entity
      description: The ip of the entity to query flows for
    - name: protocol
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - dns
      - dhcp
      - arp
      - finger
      - ncp
      - rpc
      - telnet
      - rlogin
      - citrix
      - dhcpv6
      - icmp
      - ntp
      - snmp
      - bgp
      - ripv1
      - ripv2
      - ipmi
      - ssh
      - ssl
      - openvpn
      - teredo
      - tunnel
      - ciscovpn_tcp
      - ciscovpn_udp
      - syslog
      - dce-rpc
      - xmpp
      - amqp
      - emp
      - dce-rpc-lsa
      - ident
      - radius
      - socks
      - kerberos
      - ntlm
      - login
      - rdp
      - vnc
      - pcanywhere
      - ftp
      - netbios
      - smb
      - ftp-data
      - irc-dcc-data
      - rsync
      - tftp
      - dropbox
      - bittorrent
      - gnutella
      - dnp3
      - modbus
      - gtpv1
      - gps
      - wiu
      - http
      - smtp
      - imap
      - pop3
      - mapi
      - mysql
      - irc
      - sip
      description: The protocol
    - name: family
      auto: PREDEFINED
      predefined:
      - network_services
      - network_management
      - encrypted
      - tunnel
      - logging
      - application_service
      - authentication
      - remote_access
      - file_transfer
      - p2p
      - scada
      - mobile
      - web
      - mail
      - database
      - chat
      - voice
      description: The protocol family
    - name: log
      auto: PREDEFINED
      predefined:
      - app_stats
      - arp
      - bittorrent
      - communication
      - conn
      - credit_card_exposure
      - dce_rpc
      - dce_rpc_lsa
      - dhcp
      - dhcpv6
      - dnp3
      - dns
      - dpd
      - files
      - ftp
      - gnutella
      - http
      - icmp
      - imap
      - intel
      - irc
      - kerberos
      - known_certs
      - known_hosts
      - known_services
      - loaded_scripts
      - mqtt
      - mysql
      - notice
      - ntlm
      - ntp
      - openvpn
      - packet_filter
      - pcr
      - pe
      - pop3
      - ps_long_running_flows
      - psanalytics
      - psfile_analytics
      - rdp
      - reporter
      - rfb
      - sip
      - smb_auth
      - smb_cmd
      - smb_files
      - smb_mapping
      - smtp
      - snmp
      - socks
      - software
      - ssh
      - ssl
      - stats
      - syslog
      - tcp
      - telnet
      - traceroute
      - tunnel
      - udp
      - weird
      - x509
      description: The log name
    - name: geo
      description: The 2-digit geo code,' local', or 'private'
    - name: port
      description: The port number
    - name: start_time
      description: The beginning of the time range to query. Either an ISO time string
        or seconds since the epoch.
    - name: stop_time
      description: The end of the time range to query. Either an ISO time string or
        seconds since the epoch.
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    - name: limit
      description: Limit the number of search results
      defaultValue: "5000"
    description: Query packetsled extracted files
  - name: packetsled-get-pcaps
    arguments:
    - name: entity
      description: The ip of the entity to query flows for
    - name: protocol
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - dns
      - dhcp
      - arp
      - finger
      - ncp
      - rpc
      - telnet
      - rlogin
      - citrix
      - dhcpv6
      - icmp
      - ntp
      - snmp
      - bgp
      - ripv1
      - ripv2
      - ipmi
      - ssh
      - ssl
      - openvpn
      - teredo
      - tunnel
      - ciscovpn_tcp
      - ciscovpn_udp
      - syslog
      - dce-rpc
      - xmpp
      - amqp
      - emp
      - dce-rpc-lsa
      - ident
      - radius
      - socks
      - kerberos
      - ntlm
      - login
      - rdp
      - vnc
      - pcanywhere
      - ftp
      - netbios
      - smb
      - ftp-data
      - irc-dcc-data
      - rsync
      - tftp
      - dropbox
      - bittorrent
      - gnutella
      - dnp3
      - modbus
      - gtpv1
      - gps
      - wiu
      - http
      - smtp
      - imap
      - pop3
      - mapi
      - mysql
      - irc
      - sip
      description: The protocol
    - name: port
      description: The port number
    - name: start_time
      description: The beginning of the time range to query. Either an ISO time string
        or seconds since the epoch.
    - name: stop_time
      description: The end of the time range to query. Either an ISO time string or
        seconds since the epoch.
    - name: limitbytes
      description: The upper bound on the number of bytes to return from the query
    - name: limitpkts
      description: The upper bound on the number of packets to process from the query
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    description: Query packetsled for full packet
  - name: packetsled-get-events
    arguments:
    - name: uid
      required: true
      description: The uid to retrieve logs for. Use the _id attribute from a flow for this parameter value.
    - name: envid
      description: The environment id of the probe to search
    - name: probe
      description: The probe number of the probe to search
    outputs:
    - contextPath: Packetsled.Events
      description: Retrieve all logs for a single flow
    - contextPath: Packetsled.Events._id
      description: The unique id of the Event
    - contextPath: Packetsled.Events.src_ip
      description: The originator of the Events
    - contextPath: Packetsled.Events.dest_ip
      description: The respondant of the Events
    description: Get all of the events for a given uid
  isfetch: true
releaseNotes: "Newly released"
tests:
  - No test
