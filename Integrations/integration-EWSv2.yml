commonfields:
  id: EWS v2
  version: -1
name: EWS v2
display: EWS v2
category: Messaging
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAAyCAYAAAATIfj2AAAACXBIWXMAAAsTAAALEwEAmpwYAAA7oGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMTEgNzkuMTU4MzI1LCAyMDE1LzA5LzEwLTAxOjEwOjIwICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNSAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMi0xNlQyMDozOTo1NCswMjowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTAzLTA4VDE0OjI1OjQxKzAyOjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0wMy0wOFQxNDoyNTo0MSswMjowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDpmZDgyZDE4NC03OWNiLTQ5MDAtOGViNC00YzYyNWIxZjM3MGU8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPnhtcC5kaWQ6ZTBhOGJjMDAtZTZlZS00NGRiLTg4NTYtYzliZWViMjcyYTgxPC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6ZTBhOGJjMDAtZTZlZS00NGRiLTg4NTYtYzliZWViMjcyYTgxPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmUwYThiYzAwLWU2ZWUtNDRkYi04ODU2LWM5YmVlYjI3MmE4MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMi0xNlQyMDozOTo1NCswMjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIwNWQ5NmJmLTY5MmUtNDRiMS1hNTMwLWFjN2VjOGRhYjY3MDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMi0xOFQxMjo1MzoyNiswMjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmZkODJkMTg0LTc5Y2ItNDkwMC04ZWI0LTRjNjI1YjFmMzcwZTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMy0wOFQxNDoyNTo0MSswMjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjUyPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjUwPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAg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
description: Exchange Web Services and Office 365 (mail)
detaileddescription: |-
  For Office 365, use https://outlook.office365.com/EWS/Exchange.asmx (default) as the Server  URL.
  For on-premise exchange server, we recommend to use server IP address

  To fetch emails from a specific folder, folder path needs to be specified. You can also use exchange folder ID (use !ews-find-folders command first to get the folder ID). Inbox is the default folder.

  In case of authentication error, make sure the user has full access permissions to the mailbox. For more information, read "How to config EWS Permissions" in the integration documentation.
configuration:
- display: 'Exchange URL or Server IP address '
  name: ewsServer
  defaultvalue: https://outlook.office365.com/EWS/Exchange.asmx/
  type: 0
  required: true
- display: 'Authentication: Email address (for office365) or DOMAIN\USERNAME (e.g.
    DEMISTO.INT\admin)'
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Default Target Mailbox
  name: defaultTargetMailbox
  defaultvalue: ""
  type: 0
  required: true
- display: Server Version (2007,2010,2010_SP2,2013,2016)
  name: defaultServerVersion
  defaultvalue: "2013"
  type: 0
  required: true
- display: Authentication Type (NTLM or Basic or Digest). Use Basic for Office365.
  name: authType
  defaultvalue: Basic
  type: 0
  required: true
- display: Has impersonation rights.
  name: impersonation
  defaultvalue: "false"
  type: 8
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Folder name to fetch incidents from or Exchange Folder ID. Support also
    sub-folders (e.g. Inbox\Phishing)
  name: folder
  defaultvalue: Inbox
  type: 0
  required: false
- display: HTTP requests to exchange server timeout
  name: requestTimeout
  defaultvalue: "120"
  type: 0
  required: false
script:
  script: |
    import sys, traceback, json, os, hashlib
    from datetime import timedelta
    from cStringIO import StringIO
    import logging, warnings

    # Define utf8 as default encoding
    reload(sys)
    sys.setdefaultencoding('utf8')

    # Ignore warnings print to stdout
    warnings.filterwarnings("ignore")

    # Collect exchange debug log to a stringIO
    log_stream = StringIO()
    logging.basicConfig(stream=log_stream, level=logging.DEBUG)

    from exchangelib.errors import ErrorItemNotFound, ResponseMessageError, TransportError, \
        ErrorFolderNotFound, ErrorToFolderNotFound
    from exchangelib.items import Item, Message
    from exchangelib.services import EWSService, EWSAccountService
    from exchangelib.util import create_element, add_xml_child
    from exchangelib.transport import MNS, TNS
    from exchangelib import IMPERSONATION, DELEGATE, Account, ServiceAccount, \
        EWSDateTime, EWSTimeZone, Configuration, NTLM, DIGEST, BASIC, FileAttachment, ItemAttachment, \
        Version, Folder, HTMLBody, Body
    from exchangelib.version import EXCHANGE_2007, EXCHANGE_2010, EXCHANGE_2010_SP2, EXCHANGE_2013, EXCHANGE_2016
    from exchangelib.protocol import BaseProtocol, NoVerifyHTTPAdapter

    # consts
    VERSIONS = {
        '2007': EXCHANGE_2007,
        '2010': EXCHANGE_2010,
        '2010_SP2': EXCHANGE_2010_SP2,
        '2013': EXCHANGE_2013,
        '2016': EXCHANGE_2016
    }

    ATTACHMENT_ID = "attachmentId"
    ATTACHMENT_ORIGINAL_ITEM_ID = 'originalItemId'
    NEW_ITEM_ID = 'newItemId'
    MESSAGE_ID = "messageId"
    ITEM_ID = "itemId"
    ACTION = "action"
    MAILBOX = "mailbox"
    MAILBOX_ID = "mailboxId"

    MOVED_TO_MAILBOX = "movedToMailbox"
    MOVED_TO_FOLDER = "movedToFolder"

    FILE_ATTACHMENT_TYPE = 'FileAttachment'
    ITEM_ATTACHMENT_TYPE = 'ItemAttachment'
    ATTACHMENT_TYPE = 'attachmentType'

    TOIS_PATH = '/root/Top of Information Store/'

    ENTRY_CONTEXT = "EntryContext"
    CONTEXT_UPDATE_EWS_ITEM = "EWS.Items(val.{0} == obj.{0} || (val.{1} && obj.{1} && val.{1} == obj.{1}))".format(ITEM_ID,
                                                                                                                   MESSAGE_ID)
    CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT = "EWS.Items(val.{0} == obj.{1})".format(ITEM_ID, ATTACHMENT_ORIGINAL_ITEM_ID)
    CONTEXT_UPDATE_ITEM_ATTACHMENT = ".ItemAttachments(val.{0} == obj.{0})".format(ATTACHMENT_ID)
    CONTEXT_UPDATE_FILE_ATTACHMENT = ".FileAttachments(val.{0} == obj.{0})".format(ATTACHMENT_ID)

    LAST_RUN_TIME = "lastRunTime"
    LAST_RUN_IDS = "ids"
    LAST_RUN_FOLDER = "folderName"

    ITEMS_RESULTS_HEADERS = ['sender', 'subject', 'hasAttachments', 'datetimeReceived', 'receivedBy', 'author',
                             'toRecipients', ]

    # Load integratoin params from demisto
    USE_PROXY = demisto.params()['proxy']
    NON_SECURE = demisto.params()['insecure']
    AUTH_METHOD_STR = demisto.params()['authType'].lower()
    VERSION_STR = demisto.params()['defaultServerVersion']
    EWS_SERVER = demisto.params()['ewsServer']
    USERNAME = demisto.params()['credentials']['identifier']
    ACCOUNT_EMAIL = demisto.params().get('defaultTargetMailbox', None)
    if not ACCOUNT_EMAIL:
        if "@" in USERNAME:
            ACCOUNT_EMAIL = USERNAME
        if "\\" in USERNAME:
            user_domain = USERNAME.split("\\")
            if len(user_domain) == 2:
                ACCOUNT_EMAIL = user_domain[1] + "@" + user_domain[0]
    if ACCOUNT_EMAIL is None:
        raise Exception("Provide a valid email address")
    PASSWORD = demisto.params()['credentials']['password']
    FOLDER_NAME = demisto.params().get('folder', 'Inbox')
    ACCESS_TYPE = IMPERSONATION if demisto.params()['impersonation'] else DELEGATE
    FETCH_ALL_HISTORY = demisto.params().get('fetchAllHistory', False)
    IS_TEST_MODULE = False
    BaseProtocol.TIMEOUT = int(demisto.params().get('requestTimeout', 120))

    def str_to_unicode(obj):
        if isinstance(obj, dict):
            obj = {k: str_to_unicode(v) for k,v in obj.iteritems()}
        elif isinstance(obj, list):
            obj = map(str_to_unicode, obj)
        elif isinstance(obj, str):
            obj = unicode(obj, "utf-8")
        return obj

    def filter_dict_null(d):
        if isinstance(d, dict):
            return dict((k, v) for k, v in d.items() if v is not None)
        return d

    def get_attachment_name(attachment_name):
        if attachment_name is None or attachment_name == "":
            return 'demisto_untitled_attachment'
        return attachment_name


    def get_entry_for_object(title, context_key, obj, headers=None):
        if len(obj) == 0:
            return "There is no output results"
        obj = filter_dict_null(obj)
        if isinstance(obj, list):
            obj = map(filter_dict_null, obj)
        if headers and isinstance(obj, dict):
            headers = list(set(headers).intersection(set(obj.keys())))

        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, obj, headers),
            ENTRY_CONTEXT: {
                context_key: obj
            }
        }


    def get_auth_method(auth_method):
        auth_method = auth_method.lower()
        if auth_method == 'ntlm':
            return NTLM
        elif auth_method == 'basic':
            return BASIC
        elif auth_method == 'digest':
            return DIGEST
        raise Exception("%s auth method is not supported. Choose one of %s" % (auth_method, 'ntlm\\basic\\digest'))


    def get_items_from_mailbox(account, item_ids):
        if type(item_ids) is not list:
            item_ids = [item_ids]
        items = map(lambda x: Item(item_id=x), item_ids)
        result = list(account.fetch(ids=items))
        result = [x for x in result if not isinstance(x, ErrorItemNotFound)]
        if len(result) != len(item_ids):
            raise Exception("One or more items did not found. Check the input item ids")
        for item in result:
            item.folder = Folder(account=account)
        return result


    def get_item_from_mailbox(account, item_id):
        result = get_items_from_mailbox(account, [item_id])
        if len(result) == 0:
            raise Exception("ItemId %s not found" % str(item_id))
        return result[0]


    def get_build(version_str):
        if version_str not in VERSIONS:
            raise Exception("%s is unsupported version: %s. Choose one of" % (version_str, "\\".join(VERSIONS.keys())))
        return VERSIONS[version_str]

    def get_version(version_str):
        if version_str not in VERSIONS:
            raise Exception("%s is unsupported version: %s. Choose one of" % (version_str, "\\".join(VERSIONS.keys())))
        return Version(VERSIONS[version_str])


    def get_folder_by_path(account, path):
        # handle exchange folder id
        if len(path) == 120:
            folders_map = account.root._folders_map
            if path in folders_map:
                return account.root._folders_map[path]

        path = path.replace("/", "\\")
        path = path.split('\\')
        folder_result = account.inbox.parent
        for sub_folder_name in path:
            folder_filter_by_name = [x for x in folder_result.children if x.name.lower() == sub_folder_name.lower()]
            if len(folder_filter_by_name) == 0:
                raise Exception("No such folder %s" % path)
            folder_result = folder_filter_by_name[0]

        return folder_result


    def prepare():
        if NON_SECURE:
            BaseProtocol.HTTP_ADAPTER_CLS = NoVerifyHTTPAdapter

        if not USE_PROXY:
            def remove_from_dict(d, key):
                if key in d:
                    del d[key]

            remove_from_dict(os.environ, 'HTTP_PROXY')
            remove_from_dict(os.environ, 'http_proxy')
            remove_from_dict(os.environ, 'HTTPS_PROXY')
            remove_from_dict(os.environ, 'https_proxy')

            os.environ['NO_PROXY'] = EWS_SERVER

        version = get_version(VERSION_STR)
        credentials = ServiceAccount(username=USERNAME, password=PASSWORD, max_wait=0)
        config_args = {
            'credentials': credentials,
            'auth_type': get_auth_method(AUTH_METHOD_STR),
            'version': version
        }
        if 'http' in EWS_SERVER.lower():
            config_args['service_endpoint'] = EWS_SERVER
        else:
            config_args['server'] = EWS_SERVER
        config = Configuration(**config_args)
        return config


    class MarkAsJunk(EWSAccountService):
        SERVICE_NAME = 'MarkAsJunk'

        def call(self, item_id, move_item):
            elements = list(self._get_elements(payload=self.get_payload(item_id=item_id, move_item=move_item)))
            for element in elements:
                if isinstance(element, ResponseMessageError):
                    return element.message
            return "Success"

        def get_payload(self, item_id, move_item):
            junk = create_element('m:%s' % self.SERVICE_NAME,
                                  IsJunk="true",
                                  MoveItem="true" if move_item else "false")

            items_list = create_element('m:ItemIds')
            item_element = create_element("t:ItemId", Id=item_id)
            items_list.append(item_element)
            junk.append(items_list)

            return junk


    class GetSearchableMailboxes(EWSService):
        SERVICE_NAME = 'GetSearchableMailboxes'
        element_container_name = '{%s}SearchableMailboxes' % MNS

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find("{%s}PrimarySmtpAddress" % TNS).text,
                MAILBOX_ID: element.find("{%s}ReferenceId" % TNS).text,
                'displayName': element.find("{%s}DisplayName" % TNS).text,
                'isExternal': element.find("{%s}IsExternalMailbox" % TNS).text,
                'externalEmailAddress': element.find("{%s}ExternalEmailAddress" % TNS).text
            }

        def call(self):
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = self._get_elements(payload=self.get_payload())
            return map(lambda x: self.parse_element(x), elements)

        def get_payload(self):
            element = create_element(
                'm:%s' % self.SERVICE_NAME,
            )
            return element


    class SearchMailboxes(EWSService):
        SERVICE_NAME = 'SearchMailboxes'
        element_container_name = '{%s}SearchMailboxesResult/{%s}Items' % (MNS, TNS)

        @staticmethod
        def parse_element(element):
            to_recipients = element.find('{%s}ToRecipients' % TNS)
            if to_recipients:
                to_recipients = map(lambda x: x.text if x is not None else None, to_recipients)

            result = {
                ITEM_ID: element.find('{%s}Id' % TNS).attrib['Id'] if element.find('{%s}Id' % TNS) is not None else None,
                MAILBOX: element.find('{%s}Mailbox/{%s}PrimarySmtpAddress' % (TNS, TNS)).text if element.find(
                    '{%s}Mailbox/{%s}PrimarySmtpAddress' % (TNS, TNS)) is not None else None,
                'subject': element.find("{%s}Subject" % TNS).text if element.find(
                    "{%s}Subject" % TNS) is not None else None,
                'toRecipients': to_recipients,
                'sender': element.find("{%s}Sender" % TNS).text if element.find("{%s}Sender" % TNS) is not None else None,
                'hasAttachments': element.find("{%s}HasAttachment" % TNS).text if element.find(
                    "{%s}HasAttachment" % TNS) is not None else None,
                'datetimeSent': element.find("{%s}SentTime" % TNS).text if element.find(
                    "{%s}SentTime" % TNS) is not None else None,
                'datetimeReceived': element.find("{%s}ReceivedTime" % TNS).text if element.find(
                    "{%s}ReceivedTime" % TNS) is not None else None
            }

            return result

        def call(self, query, mailboxes):
            query = query.replace(".", "\\.")
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = list(self._get_elements(payload=self.get_payload(query, mailboxes)))
            return map(lambda x: self.parse_element(x), elements)

        def get_payload(self, query, mailboxes):
            def get_mailbox_search_scope(mailbox_id):
                mailbox_search_scope = create_element("t:MailboxSearchScope")
                add_xml_child(mailbox_search_scope, "t:Mailbox", mailbox_id)
                add_xml_child(mailbox_search_scope, "t:SearchScope", "All")
                return mailbox_search_scope

            mailbox_query_element = create_element("t:MailboxQuery")
            add_xml_child(mailbox_query_element, "t:Query", query)
            mailboxes_scopes = []
            for mailbox in mailboxes:
                mailboxes_scopes.append(get_mailbox_search_scope(mailbox))
            add_xml_child(mailbox_query_element, "t:MailboxSearchScopes", mailboxes_scopes)

            element = create_element('m:%s' % self.SERVICE_NAME)
            add_xml_child(element, "m:SearchQueries", mailbox_query_element)
            add_xml_child(element, "m:ResultType", "PreviewOnly")

            return element


    def get_searchable_mailboxes(protocol):
        searchable_mailboxes = GetSearchableMailboxes(protocol=protocol).call()
        return get_entry_for_object("Searchable mailboxes", 'EWS.Mailboxes', searchable_mailboxes)


    def search_mailboxes(protocol, filter, limit=100, mailbox_search_scope=None, email_addresses=None):
        mailbox_ids = []
        limit = int(limit)
        if mailbox_search_scope is not None and email_addresses is not None:
            raise Exception("Use one of the arguments - mailbox-search-scope or email-addresses, not both")
        if email_addresses:
            email_addresses = email_addresses.split(",")
            all_mailboxes = get_searchable_mailboxes(protocol)[ENTRY_CONTEXT]['EWS.Mailboxes']
            for email_address in email_addresses:
                for mailbox in all_mailboxes:
                    if email_address.lower() == mailbox[MAILBOX].lower():
                        mailbox_ids.append(mailbox[MAILBOX_ID])
            if len(mailbox_ids) != len(email_addresses):
                raise Exception("Did not found one or some of the specified email addresses")
        elif mailbox_search_scope:
            mailbox_ids = mailbox_search_scope if type(mailbox_search_scope) is list else [mailbox_search_scope]
        else:
            entry = get_searchable_mailboxes(protocol)
            mailboxes = [x for x in entry[ENTRY_CONTEXT]['EWS.Mailboxes'] if MAILBOX_ID in x.keys()]
            mailbox_ids = map(lambda x: x[MAILBOX_ID], mailboxes)

        try:
            search_results = SearchMailboxes(protocol=protocol).call(filter, mailbox_ids)
            search_results = search_results[:limit]
        except TransportError, e:
            if "ItemCount>0<" in str(e):
                return "No results for search query: " + filter
            else:
                raise e

        return get_entry_for_object("Search mailboxes results",
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    search_results)


    def get_account(account_email, access_type=ACCESS_TYPE):
        return Account(
            primary_smtp_address=account_email, autodiscover=False, config=config, access_type=access_type,
        )


    def get_last_run():
        last_run = demisto.getLastRun()
        if not last_run or last_run.get(LAST_RUN_FOLDER) != FOLDER_NAME:
            last_run = {
                LAST_RUN_TIME: None,
                LAST_RUN_FOLDER: FOLDER_NAME,
                LAST_RUN_IDS: None
            }
        if LAST_RUN_TIME in last_run and last_run[LAST_RUN_TIME] is not None:
            last_run[LAST_RUN_TIME] = EWSDateTime.from_string(last_run[LAST_RUN_TIME])

        return last_run


    def fetch_last_emails(account, folder_name='Inbox', since_datetime=None, exclude_ids=None):
        qs = get_folder_by_path(account, folder_name)
        if since_datetime:
            qs = qs.filter(datetime_received__gte=since_datetime)
        else:
            if not FETCH_ALL_HISTORY:
                last_10_min = EWSDateTime.now(tz=EWSTimeZone.timezone('UTC')) - timedelta(minutes=10)
                qs = qs.filter(datetime_received__gte=last_10_min)
        fields = map(lambda x: x.name, Message.FIELDS)
        if get_build(VERSION_STR) <= EXCHANGE_2010_SP2:
            fields = filter(lambda x: x != 'text_body', fields)
        qs = qs.filter().only(*fields)
        result = qs.all()
        result = [x for x in result if isinstance(x, Message)]
        if exclude_ids and len(exclude_ids) > 0:
            exclude_ids = set(exclude_ids)
            result = [x for x in result if x.message_id not in exclude_ids]
        return result


    def keys_to_camel_case(value):
        def str_to_camel_case(snake_str):
            components = snake_str.split('_')
            return components[0] + "".join(x.title() for x in components[1:])

        if value is None:
            return None
        if isinstance(value, list):
            return map(keys_to_camel_case, value)
        if isinstance(value, dict):
            return dict((keys_to_camel_case(k),
                         keys_to_camel_case(v) if isinstance(v, (list, dict)) else v)
                        for (k, v) in value.items())

        return str_to_camel_case(value)


    def parse_item_as_dict(item, email_address, camel_case=False, compact_fields=False):
        def parse_object_as_dict(object):
            raw_dict = {}
            if object is not None:
                for field in object.FIELDS:
                    raw_dict[field.name] = getattr(object, field.name, None)
            return raw_dict

        def parse_attachment_as_raw_json(attachment):
            raw_dict = parse_object_as_dict(attachment)
            if raw_dict['attachment_id']:
                raw_dict['attachment_id'] = parse_object_as_dict(raw_dict['attachment_id'])
            if raw_dict['last_modified_time']:
                raw_dict['last_modified_time'] = raw_dict['last_modified_time'].ewsformat()
            return raw_dict

        def parse_folder_as_json(folder):
            raw_dict = parse_object_as_dict(folder)
            if 'parent_folder_id' in raw_dict:
                raw_dict['parent_folder_id'] = parse_folder_as_json(raw_dict['parent_folder_id'])
            if 'effective_rights' in raw_dict:
                raw_dict['effective_rights'] = parse_object_as_dict(raw_dict['effective_rights'])
            return raw_dict

        raw_dict = {}
        for field, value in item.__dict__.items():
            if type(value) in [str, unicode, int, float, bool, Body, HTMLBody, None]:
                try:
                    if isinstance(value, basestring):
                        value.encode('utf-8')
                    raw_dict[field] = value
                except:
                    pass

        if getattr(item, 'attachments', None):
            raw_dict['attachments'] = map(lambda x: parse_attachment_as_dict(item.item_id, x), item.attachments)

        for time_field in ['datetime_sent', 'datetime_created', 'datetime_received', 'last_modified_time',
                           'reminder_due_by']:
            value = getattr(item, time_field, None)
            if value:
                raw_dict[time_field] = value.ewsformat()

        for dict_field in ['effective_rights', 'parent_folder_id', 'conversation_id', 'author',
                           'extern_id', 'received_by', 'received_representing', 'reply_to', 'sender', 'folder']:
            value = getattr(item, dict_field, None)
            if value:
                raw_dict[dict_field] = parse_object_as_dict(value)

        for list_dict_field in ['headers', 'cc_recipients', 'to_recipients']:
            value = getattr(item, list_dict_field, None)
            if value:
                raw_dict[list_dict_field] = map(lambda x: parse_object_as_dict(x), value)

        if getattr(item, 'folder', None):
            raw_dict['folder'] = parse_folder_as_json(item.folder)
            folder_path = item.folder.absolute[len(TOIS_PATH):] if item.folder.absolute.startswith(TOIS_PATH) else item.folder.absolute
            raw_dict['folder_path'] = folder_path

        if compact_fields:
            new_dict = {}
            for field in ['datetime_created', 'datetime_received', 'datetime_sent', 'sender',
                          'has_attachments', 'importance', 'item_id', 'message_id', 'last_modified_time',
                          'size', 'subject', 'text_body', 'headers', 'body', 'folder_path']:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field)
            for field in ['received_by', 'author', 'sender']:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field, {}).get('email_address')
            for field in ['to_recipients']:
                if field in raw_dict:
                    new_dict[field] = map(lambda x: x.get('email_address'), raw_dict[field])
            attachments = raw_dict.get('attachments')
            if attachments and len(attachments) > 0:
                file_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == FILE_ATTACHMENT_TYPE]
                if len(file_attachments) > 0:
                    new_dict['FileAttachments'] = file_attachments
                item_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == ITEM_ATTACHMENT_TYPE]
                if len(item_attachments) > 0:
                    new_dict['ItemAttachments'] = item_attachments

            raw_dict = new_dict

        if camel_case:
            raw_dict = keys_to_camel_case(raw_dict)

        if email_address:
            raw_dict[MAILBOX] = email_address
        return raw_dict


    def parse_incident_from_item(item):
        incident = {}
        labels = []

        incident['details'] = item.text_body or item.body
        incident['name'] = item.subject
        labels.append({'type': 'Email/subject', 'value': item.subject})
        incident['occurred'] = item.datetime_created.ewsformat()

        # handle recipients
        if item.to_recipients:
            for recipient in item.to_recipients:
                labels.append({'type': 'Email', 'value': recipient.email_address})

        # handle cc
        if item.cc_recipients:
            for recipient in item.cc_recipients:
                labels.append({'type': 'Email/cc', 'value': recipient.email_address})
        # handle email from
        if item.sender:
            labels.append({'type': 'Email/from', 'value': item.sender.email_address})

        # email format
        email_format = ''
        if item.text_body:
            labels.append({'type': 'Email/text', 'value': item.text_body})
            email_format = 'text'
        if item.body:
            labels.append({'type': 'Email/html', 'value': item.body})
            email_format = 'HTML'
        labels.append({'type': 'Email/format', 'value': email_format})

        # handle attachments
        if item.attachments:
            incident['attachment'] = [];
            for attachment in item.attachments:
                file_result = None
                label_attachment_type = None
                label_attachment_id_type = None
                if isinstance(attachment, FileAttachment):
                    try:
                        if attachment.content:
                            # file attachment
                            label_attachment_type = 'attachments'
                            label_attachment_id_type = 'attachmentId'

                            # save the attachment
                            file_name = get_attachment_name(attachment.name)
                            file_result = fileResult(file_name, attachment.content)

                            # check for error
                            if file_result['Type'] == entryTypes['error']:
                                demisto.error(file_result['Contents'])
                                raise Exception(file_result['Contents'])

                            # save attachment to incident
                            incident['attachment'].append({
                                'path': file_result['FileID'],
                                'name': get_attachment_name(attachment.name)
                            })
                    except TypeError, e:
                        if e.message != "must be string or buffer, not None":
                            raise
                        continue
                else:
                    # other item attachment
                    label_attachment_type = 'attachmentItems'
                    label_attachment_id_type = 'attachmentItemsId'

                    # save the attachment
                    if attachment.item.mime_content:
                        file_result = fileResult(get_attachment_name(attachment.name) + ".eml", attachment.item.mime_content)

                    if file_result:
                        # check for error
                        if file_result['Type'] == entryTypes['error']:
                            demisto.error(file_result['Contents'])
                            raise Exception(file_result['Contents'])

                        # save attachment to incident
                        incident['attachment'].append({
                            'path': file_result['FileID'],
                            'name': get_attachment_name(attachment.name) + ".eml"
                        })


                labels.append({'type': label_attachment_type, 'value': get_attachment_name(attachment.name)})
                labels.append({'type': label_attachment_id_type, 'value': attachment.attachment_id.id})



        # handle headers
        if item.headers:
            for header in item.headers:
                labels.append({'type': 'Email/Header/' + header.name, 'value': header.value})

        # handle item id
        if item.message_id:
            labels.append({'type': 'Email/MessageId', 'value': item.message_id})

        if item.item_id:
            labels.append({'type': 'Email/ID', 'value': item.item_id})
            labels.append({'type': 'Email/itemId', 'value': item.item_id})

        # handle conversion id
        if item.conversation_id:
            labels.append({'type': 'Email/ConversionID', 'value': item.conversation_id.id})

        incident['labels'] = labels
        incident['rawJSON'] = json.dumps(parse_item_as_dict(item, None), ensure_ascii=False)

        return incident


    def fetch_emails_as_incidents(account, folder_name):
        start_time = EWSDateTime.now(tz=EWSTimeZone.timezone('UTC'))
        last_run = get_last_run()
        last_emails = fetch_last_emails(account, folder_name, last_run.get(LAST_RUN_TIME), last_run.get(LAST_RUN_IDS))

        ids = []
        incidents = []
        for item in last_emails:
            if item.message_id:
                ids.append(item.message_id)
                incident = parse_incident_from_item(item)
                incidents.append(incident)

        new_last_run = {
            LAST_RUN_TIME: start_time.ewsformat(),
            LAST_RUN_FOLDER: folder_name,
            LAST_RUN_IDS: ids
        }

        demisto.setLastRun(new_last_run)
        return incidents


    def get_entry_for_file_attachment(item_id, attachment):
        entry = fileResult(get_attachment_name(attachment.name), attachment.content)
        ec = {
            CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_FILE_ATTACHMENT: parse_attachment_as_dict(item_id,
                                                                                                              attachment)
        }
        entry[ENTRY_CONTEXT] = filter_dict_null(ec)
        return entry


    def parse_attachment_as_dict(item_id, attachment):
        try:
            attachment_content = attachment.content if isinstance(attachment, FileAttachment) else attachment.item.mime_content
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                'attachmentName': get_attachment_name(attachment.name),
                'attachmentSHA256': hashlib.sha256(attachment_content).hexdigest() if attachment_content else None,
                'attachmentContentType': attachment.content_type,
                'attachmentContentId': attachment.content_id,
                'attachmentContentLocation': attachment.content_location,
                'attachmentSize': attachment.size,
                'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                'attachmentIsInline': attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE
            }
        except TypeError, e:
            if e.message != "must be string or buffer, not None":
                raise
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                'attachmentName': get_attachment_name(attachment.name),
                'attachmentSHA256': None,
                'attachmentContentType': attachment.content_type,
                'attachmentContentId': attachment.content_id,
                'attachmentContentLocation': attachment.content_location,
                'attachmentSize': attachment.size,
                'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                'attachmentIsInline': attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE
            }


    def get_entry_for_item_attachment(item_id, attachment, target_email):
        item = attachment.item
        dict_result = parse_attachment_as_dict(item_id, attachment)
        dict_result.update(parse_item_as_dict(item, target_email, camel_case=True, compact_fields=True))
        title = 'EWS get attachment got item for "%s", "%s"' % (target_email, get_attachment_name(attachment.name))

        return get_entry_for_object(title, CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                                    dict_result)


    def get_attachments_for_item(item_id, account, attachment_ids=None):
        item = get_item_from_mailbox(account, item_id)
        attachments = []
        if attachment_ids and not isinstance(attachment_ids, list):
            attachment_ids = attachment_ids.split(",")
        if item:
            if item.attachments:
                for attachment in item.attachments:
                    if attachment_ids and attachment.attachment_id.id not in attachment_ids:
                        continue
                    attachments.append(attachment)

        else:
            raise Exception('Message item not found: ' + item_id)

        if attachment_ids and len(attachments) < len(attachment_ids):
            raise Exception('Some attachment id did not found for message:' + str(attachment_ids))

        return attachments


    def delete_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        deleted_file_attachments = []
        deleted_item_attachments = []
        for attachment in attachments:
            attachment_deleted_action = {
                ATTACHMENT_ID: attachment.attachment_id.id,
                ACTION: 'deleted'
            }
            if isinstance(attachment, FileAttachment):
                deleted_file_attachments.append(attachment_deleted_action)
            else:
                deleted_item_attachments.append(attachment_deleted_action)
            attachment.detach()

        entries = []
        if len(deleted_file_attachments) > 0:
            entry = get_entry_for_object("Deleted file attachments",
                                         "EWS.Items" + CONTEXT_UPDATE_FILE_ATTACHMENT,
                                         deleted_file_attachments)
            entries.append(entry)
        if len(deleted_item_attachments) > 0:
            entry = get_entry_for_object("Deleted item attachments",
                                         "EWS.Items" + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                                         deleted_item_attachments)
            entries.append(entry)

        return entries


    def fetch_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        entries = []
        for attachment in attachments:
            if isinstance(attachment, FileAttachment):
                try:
                    if attachment.content:
                        entries.append(get_entry_for_file_attachment(item_id, attachment))
                except TypeError, e:
                    if e.message != "must be string or buffer, not None":
                        raise
            else:
                entries.append(get_entry_for_item_attachment(item_id, attachment, account.primary_smtp_address))
                if attachment.item.mime_content:
                    entries.append(fileResult(get_attachment_name(attachment.name) + ".eml", attachment.item.mime_content))

        return entries

    def move_item_between_mailboxes(item_id, destination_mailbox, destination_folder_path, source_mailbox=None):
        source_account = get_account(source_mailbox or ACCOUNT_EMAIL)
        destination_account = get_account(destination_mailbox or ACCOUNT_EMAIL)
        destination_folder = get_folder_by_path(destination_account, destination_folder_path)
        item = get_item_from_mailbox(source_account, item_id)
        try:
            source_account.bulk_move(ids=[item], to_folder=destination_folder)
        except ErrorToFolderNotFound:
            exported_items = source_account.export([item])
            destination_account.upload([(destination_folder, exported_items[0])])
            source_account.bulk_delete([item])

        move_result = {
            MOVED_TO_MAILBOX: destination_mailbox,
            MOVED_TO_FOLDER: destination_folder_path,
        }

        return {
            'Type': entryTypes['note'],
            'Contents': "Item was moved successfully.",
            'ContentsFormat': formats['text'],
            ENTRY_CONTEXT: {
               "EWS.Items(val.itemId === '%s')" % (item_id,): move_result
            }
        }

    def move_item(item_id, target_folder_path, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        target_folder = get_folder_by_path(account, target_folder_path)
        item = get_item_from_mailbox(account, item_id)
        item.move(target_folder)
        move_result = {
            NEW_ITEM_ID: item.item_id,
            ITEM_ID: item_id,
            MESSAGE_ID: item.message_id,
            ACTION: 'moved'
        }

        return get_entry_for_object('Moved items',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    move_result)


    def delete_items(item_ids, delete_type, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        deleted_items = []
        if type(item_ids) != list:
            item_ids = item_ids.split(",")
        items = get_items_from_mailbox(account, item_ids)
        delete_type = delete_type.lower()

        for item in items:
            item_id = item.item_id
            if delete_type == 'trash':
                item.move_to_trash()
            elif delete_type == 'soft':
                item.soft_delete()
            elif delete_type == 'hard':
                item.delete()
            else:
                raise Exception('invalid delete type: %s. Use "trash" \\ "soft" \\ "hard"' % delete_type)
            deleted_items.append({
                ITEM_ID: item_id,
                MESSAGE_ID: item.message_id,
                ACTION: '%s-deleted' % delete_type
            })

        return get_entry_for_object('Deleted items (%s delete type)' % delete_type,
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    deleted_items)


    def prepare_args(d):
        return dict((k.replace("-", "_"), v) for k, v in d.items())


    def get_limited_number_of_messages_from_qs(qs, limit):
        count = 0
        results = []
        for item in qs:
            if count == limit:
                break
            if isinstance(item, Message):
                count += 1
                results.append(item)
        return results


    def search_items_in_mailbox(query, folder_path=None, limit=100, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        limit = int(limit)
        if folder_path:
            folders = [get_folder_by_path(account, folder_path)]
        else:
            folders = account.inbox.parent.walk()

        items = []
        for folder in folders:
            if Message not in folder.supported_item_models:
                continue
            items_qs = folder.filter(query).only(*map(lambda x: x.name, Message.FIELDS))
            items += get_limited_number_of_messages_from_qs(items_qs, limit)
            if len(items) >= limit:
                break
        items = items[:limit]
        searched_items_result = map(lambda item: parse_item_as_dict(item, account.primary_smtp_address, camel_case=True, compact_fields=True), items)

        return get_entry_for_object('Searched items',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    searched_items_result,
                                    headers=ITEMS_RESULTS_HEADERS)


    def get_out_of_office_state(target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        oof = account.oof_settings
        oof_dict = {
            'state': oof.state,
            'externalAudience': getattr(oof, 'external_audience', None),
            'start': oof.start.ewsformat() if oof.start else None,
            'end': oof.end.ewsformat() if oof.end else None,
            'internalReply': getattr(oof, 'internal_replay', None),
            'externalReply': getattr(oof, 'external_replay', None),
            MAILBOX: account.primary_smtp_address
        }
        return get_entry_for_object("Out of office state for %s" % account.primary_smtp_address,
                                    'Account.Email(val.Address == obj.{0}).OutOfOffice'.format(MAILBOX),
                                    oof_dict)


    def recover_soft_delete_item(message_ids, target_folder_path="Inbox", target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        target_folder = get_folder_by_path(account, target_folder_path)
        recovered_messages = []
        if type(message_ids) != list:
            message_ids = message_ids.split(",")
        items_to_recover = account.recoverable_items_deletions.filter(message_id__in=message_ids).all()
        if len(items_to_recover) != len(message_ids):
            raise Exception("Some message ids are missing in recoverable items directory")
        for item in items_to_recover:
            item.move(target_folder)
            recovered_messages.append({
                ITEM_ID: item.item_id,
                MESSAGE_ID: item.message_id,
                ACTION: 'recovered'
            })
        return get_entry_for_object("Recovered messages",
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    recovered_messages)


    def get_contacts(limit, target_mailbox=None):
        def parse_physical_address(address):
            result = {}
            for attr in ['city', 'country', 'label', 'state', 'street', 'zipcode']:
                result[attr] = getattr(address, attr, None)
            return result

        def parse_phone_number(phone_number):
            result = {}
            for attr in ['label', 'phone_number']:
                result[attr] = getattr(phone_number, attr, None)
            return result

        def parse_contact(contact):
            contact_dict = dict((k, v if not isinstance(v, EWSDateTime) else v.ewsformat())
                                for k, v in contact.__dict__.items()
                                if isinstance(v, basestring) or isinstance(v, EWSDateTime))
            if contact.physical_addresses:
                contact_dict['physical_addresses'] = map(parse_physical_address, contact.physical_addresses)
            if contact.phone_numbers:
                contact_dict['phone_numbers'] = map(parse_phone_number, contact.phone_numbers)
            if contact.email_addresses and len(contact.email_addresses) > 0:
                contact_dict['emailAddresses'] = map(lambda x: x.email, contact.email_addresses)
            contact_dict = keys_to_camel_case(contact_dict)
            contact_dict = dict((k, v) for k, v in contact_dict.items() if v)
            del contact_dict['mimeContent']
            contact_dict['originMailbox'] = target_mailbox
            return contact_dict

        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        contacts = []
        count = 0
        for contact in account.contacts.all():
            if count >= limit:
                break
            contacts.append(parse_contact(contact))
        return get_entry_for_object('Email contacts for %s' % target_mailbox,
                                    'Account.Email(val.Address == obj.originMailbox).EwsContacts',
                                    contacts)


    def create_folder(new_folder_name, folder_path, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        full_path = "%s\\%s" % (folder_path, new_folder_name)
        try:
            if get_folder_by_path(account, full_path):
                return "Folder %s was already exist" % full_path
        except:
            pass
        parent_folder = get_folder_by_path(account, folder_path)
        f = Folder(parent=parent_folder, name=new_folder_name)
        f.save()
        get_folder_by_path(account, full_path)
        return "Folder %s created successfully" % full_path


    def mark_item_as_junk(item_id, move_items, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        move_items = (move_items.lower() == "yes")
        ews_result = MarkAsJunk(account=account).call(item_id=item_id, move_item=move_items)
        mark_as_junk_result = {
            ITEM_ID: item_id,
        }
        if ews_result == "Success":
            mark_as_junk_result[ACTION] = 'marked-as-junk'
        else:
            raise Exception("Failed mark-item-as-junk with error: " + ews_result)

        return get_entry_for_object('Mark item as junk',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    mark_as_junk_result)


    def find_folders(target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        folders = []
        for f in account.root.walk():
            folder = {
                'name': f.name,
                'totalCount': f.total_count,
                'unreadCount': f.unread_count,
                'id': f.folder_id,
                'childrenFolderCount': f.child_folder_count,
                'changeKey': f.changekey
            }
            folders.append(folder)
        folders_tree = account.root.tree()

        return {
            'Type': entryTypes['note'],
            'Contents': folders,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': folders_tree,
            ENTRY_CONTEXT: {
                'EWS.Folders(val.id == obj.id)': folders
            }
        }


    def get_items_from_folder(folder_path, limit=100, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        limit = int(limit)
        folder = get_folder_by_path(account, folder_path)
        qs = folder.filter().order_by('-datetime_created')
        items = get_limited_number_of_messages_from_qs(qs, limit)
        items_result = map(lambda item: parse_item_as_dict(item, account.primary_smtp_address, camel_case=True, compact_fields=True), items)
        hm_headers = ['sender', 'subject', 'hasAttachments', 'datetimeReceived',
                      'receivedBy', 'author', 'toRecipients', ]
        return get_entry_for_object('Items in folder ' + folder_path,
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    items_result,
                                    headers=hm_headers)


    def get_items(item_ids, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        if type(item_ids) != list:
            item_ids = item_ids.split(",")

        items = get_items_from_mailbox(account, item_ids)
        items = [x for x in items if isinstance(x, Message)]
        items_as_incidents = map(lambda x: parse_incident_from_item(x), items)
        items_to_context = map(lambda x: parse_item_as_dict(x, account.primary_smtp_address, True, True), items)

        return {
            'Type': entryTypes['note'],
            'Contents': items_as_incidents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Get items', items_to_context, ITEMS_RESULTS_HEADERS),
            ENTRY_CONTEXT: {
                CONTEXT_UPDATE_EWS_ITEM: items_to_context
            }
        }


    def test_module():
        try:
            global IS_TEST_MODULE
            IS_TEST_MODULE = True
            account = get_account(ACCOUNT_EMAIL)
            if not account.root.effective_rights.read:
                raise Exception("Success to authenticate, but user has no permissions to read from the mailbox. "
                                "Need to delegate the user permissions to the mailbox - "
                                "please read integration documentation and follow the instructions")
            get_folder_by_path(account, FOLDER_NAME).test_access()
        except ErrorFolderNotFound, e:
            if "Top of Information Store" in e.message:
                raise Exception(
                    "Success to authenticate, but user probably has no permissions to read from the specific folder."
                    "Check user permissions. You can try !ews-find-folders command to "
                    "get all the folders structure that the user has permissions to")
        demisto.results('ok')


    def encode_and_submit_results(obj):
        demisto.results(str_to_unicode(obj))

    try:
        config = prepare()
        args = prepare_args(demisto.args())

        if demisto.command() == 'test-module':
            test_module()
        elif demisto.command() == 'fetch-incidents':
            incidents = fetch_emails_as_incidents(get_account(ACCOUNT_EMAIL), FOLDER_NAME)
            demisto.incidents(str_to_unicode(incidents))
        elif demisto.command() == 'ews-get-attachment':
            encode_and_submit_results(fetch_attachments_for_message(**args))
        elif demisto.command() == 'ews-delete-attachment':
            encode_and_submit_results(delete_attachments_for_message(**args))
        elif demisto.command() == 'ews-get-searchable-mailboxes':
            encode_and_submit_results(get_searchable_mailboxes(config.protocol))
        elif demisto.command() == 'ews-search-mailboxes':
            encode_and_submit_results(search_mailboxes(config.protocol, **args))
        elif demisto.command() == 'ews-move-item-between-mailboxes':
            encode_and_submit_results(move_item_between_mailboxes(**args))
        elif demisto.command() == 'ews-move-item':
            encode_and_submit_results(move_item(**args))
        elif demisto.command() == 'ews-delete-items':
            encode_and_submit_results(delete_items(**args))
        elif demisto.command() == 'ews-search-mailbox':
            encode_and_submit_results(search_items_in_mailbox(**args))
        elif demisto.command() == 'ews-get-contacts':
            encode_and_submit_results(get_contacts(**args))
        elif demisto.command() == 'ews-get-out-of-office':
            encode_and_submit_results(get_out_of_office_state(**args))
        elif demisto.command() == 'ews-recover-messages':
            encode_and_submit_results(recover_soft_delete_item(**args))
        elif demisto.command() == 'ews-create-folder':
            encode_and_submit_results(create_folder(**args))
        elif demisto.command() == 'ews-mark-item-as-junk':
            encode_and_submit_results(mark_item_as_junk(**args))
        elif demisto.command() == 'ews-find-folders':
            encode_and_submit_results(find_folders(**args))
        elif demisto.command() == 'ews-get-items-from-folder':
            encode_and_submit_results(get_items_from_folder(**args))
        elif demisto.command() == 'ews-get-items':
            encode_and_submit_results(get_items(**args))


    except Exception, e:
        import time

        time.sleep(2)
        debug_log = log_stream.getvalue()
        error_message_simple = ""
        error_message = ""
        if "Status code: 401" in debug_log:
            error_message_simple = "Got unauthorized from the server. " \
                            "Check credentials are correct and authentication method are supported. "

            error_message_simple += "You can try using 'domain\\username' as username for authentication. " if AUTH_METHOD_STR.lower() == 'ntlm' else ''
        if "Status code: 503" in debug_log:
            error_message_simple = "Got timeout from the server. " \
                            "Probably the server is not reachable with the current settings. " \
                            "Check proxy parameter. If you are using server URL - change to server IP address. "

        if not error_message_simple:
            error_message = error_message_simple = e.message
        else:
            error_message = error_message_simple + "\n" + e.message

        stacktrace = traceback.format_exc()
        if stacktrace:
            error_message += "\nFull stacktrace:\n" + stacktrace

        if debug_log:
            error_message += "\nFull debug log:\n" + debug_log

        if not IS_TEST_MODULE:
            raise Exception(error_message)
        demisto.results(error_message_simple)
        demisto.error("%s: %s" % (e.__class__.__name__, error_message))

  type: python
  commands:
  - name: ews-get-attachment
    arguments:
    - name: item-id
      required: true
      description: The ID of the email message to get the attachments.
    - name: target-mailbox
      description: The mailbox where this attachment was found. Use the default mailbox
        if empty, otherwise user might has to be with impersonation rights to this
        mailbox.
    - name: attachment-ids
      description: The attachments ids to get. If none - all attachments will be retrieve
        from the message. Support multiple attachments with comma-separated value
        or array.
      isArray: true
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The attachment ID. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: The attachment name. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentSHA256
      description: The attached file SHA256.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentLastModifiedTime
      description: The attachment last modified time. Used for file attachments only.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeCreated
      description: The attached email created time.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeReceived
      description: The attached email received time.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeSent
      description: The attached email sent time.
      type: date
    - contextPath: EWS.Items.ItemAttachments.receivedBy
      description: The attached email received by address.
      type: string
    - contextPath: EWS.Items.ItemAttachments.subject
      description: The attached email subject.
      type: string
    - contextPath: EWS.Items.ItemAttachments.textBody
      description: The attached email body (as text).
      type: string
    - contextPath: EWS.Items.ItemAttachments.headers
      description: The attached email headers.
    - contextPath: EWS.Items.ItemAttachments.hasAttachments
      description: Is attached email has attachments?
      type: boolean
    - contextPath: EWS.Items.ItemAttachments.itemId
      description: The attached email item id.
      type: string
    - contextPath: EWS.Items.ItemAttachments.toRecipients
      description: The attached email to recipients addresses (list)
    - contextPath: EWS.Items.ItemAttachments.body
      description: The attached email body (as HTML).
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentSHA256
      description: The attached email SHA256 (as EML file).
      type: string
    - contextPath: EWS.Items.ItemAttachments.FileAttachments.attachmentSHA256
      description: SHA256 of the attached files inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.ItemAttachments.attachmentSHA256
      description: SHA256 of the attached emails inside of the attached email.
      type: string
    description: Get the actual attachments from an item (email message). Usually
      use only item-id argument to get all the attachment of a message.
  - name: ews-delete-attachment
    arguments:
    - name: item-id
      required: true
      description: The ID of the email message to get the attachments.
    - name: target-mailbox
      description: The mailbox where this attachment was found. Use the default mailbox
        if empty, otherwise user might has to be with impersonation rights to this
        mailbox.
    - name: attachment-ids
      description: The attachment id to delete. If none - all attachments will be
        delete from the message. Support multiple attachments with comma-separated
        value or array.
      isArray: true
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The id of the deleted attachment in case of file attachment.
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: The id of the deleted attachment in case of other attachment (like
        "email").
      type: string
    - contextPath: EWS.Items.FileAttachments.action
      description: 'The deletion action in case of file attachment, constant value:
        ''deleted''.'
      type: string
    - contextPath: EWS.Items.ItemAttachments.action
      description: 'The deletion action in case of other attachment (like "email"),
        constant value: ''deleted''.'
      type: string
    description: Delete attachments for an item (email message).
  - name: ews-get-searchable-mailboxes
    arguments: []
    outputs:
    - contextPath: EWS.Mailboxes.mailbox
      description: Searchable mailboxes addresses.
      type: string
    - contextPath: EWS.Mailboxes.mailboxId
      description: Searchable mailboxes ids.
      type: string
    - contextPath: EWS.Mailboxes.displayName
      description: Searchable mailboxes - display name of the email.
      type: string
    - contextPath: EWS.Mailboxes.isExternal
      description: Searchable mailboxes - is mailbox external?
      type: boolean
    - contextPath: EWS.Mailboxes.externalEmailAddress
      description: Searchable mailboxes - external email address.
      type: string
    description: Get searchable mailboxes. Notice that this command requires eDiscovery
      permissions to the exchange - read EWSv2 documentation for more information.
  - name: ews-search-mailboxes
    arguments:
    - name: filter
      required: true
      description: The filter query to search.
    - name: mailbox-search-scope
      description: The mailboxes ids to search for. If empty - search in all searchable
        mailboxes.
      isArray: true
    - name: limit
      description: Maximum number of results.
      defaultValue: "250"
    - name: email_addresses
      description: Email addresses - support comma separated values or array.
      isArray: true
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item id.
      type: string
    - contextPath: EWS.Items.mailbox
      description: The mailbox address where the item has been found.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject.
      type: string
    - contextPath: EWS.Items.toRecipients
      description: Email to recipients addresses (list).
    - contextPath: EWS.Items.sender
      description: Sender email address
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments?
      type: boolean
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time
      type: date
    - contextPath: EWS.Items.datetimeReceived
      description: Email receive time
      type: date
    description: Search over multiple mailboxes or all exchange mailboxes. Use one
      of mailbox-search-scope or email-addresses to search in specific mailboxes.
      Notice that this command requires eDiscovery permissions to the exchange - read
      EWSv2 documentation for more information.
  - name: ews-move-item
    arguments:
    - name: item-id
      required: true
      description: The item id to move.
    - name: target-folder-path
      required: true
      description: The target folder to move the item to. Complex path can be used,
        e.g. Inbox\Phishing.
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Items.newItemID
      description: The new item id after move.
      type: string
    - contextPath: EWS.Items.messageID
      description: The item message id.
      type: string
    - contextPath: EWS.Items.itemId
      description: The original item id.
      type: string
    - contextPath: EWS.Items.action
      description: The action, value will be 'moved'.
      type: string
    description: Move an item to another folder in the mailbox.
  - name: ews-delete-items
    arguments:
    - name: item-ids
      required: true
      description: The item ids to delete.
    - name: delete-type
      required: true
      description: 'Deletion type, choose one of: trash, soft, hard.'
      defaultValue: soft
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The deleted item id.
      type: string
    - contextPath: EWS.Items.messageId
      description: The deleted message id.
      type: string
    - contextPath: EWS.Items.action
      description: 'The deletion action, one of the following: ''trash-deleted'',
        ''soft-deleted'', ''hard-deleted''.'
      type: string
    description: Delete items from mailbox.
  - name: ews-search-mailbox
    arguments:
    - name: query
      required: true
      description: 'The search query string. Syntax here: https://msdn.microsoft.com/en-us/library/ee693615.aspx'
    - name: folder-path
      description: The folder path to search in. If empty - search over all the folders
        in the mailbox.
      defaultValue: Inbox
    - name: limit
      description: Maximum number of results.
      defaultValue: "100"
    - name: target-mailbox
      description: The mailbox to apply the search on.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item id.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Email received time.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
    - contextPath: EWS.Items.sender
      description: Email sender mail address.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject
      type: string
    - contextPath: EWS.Items.textBody
      description: Email body (as text)
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
    - contextPath: EWS.Items.messageId
      description: Email message id.
      type: string
    - contextPath: EWS.Items.body
      description: Email HTML body.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment id for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment id for item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name for item attachment.
      type: unknown
    description: Search items in a specific mailbox. Notice that a proper permissions
      needed for this operation to search in another target mailbox than the default.
  - name: ews-get-contacts
    arguments:
    - name: target-mailbox
      description: The mailbox to get the contacts from.
    - name: limit
      description: Maximum number of results to fetch
      defaultValue: "100"
    outputs:
    - contextPath: Account.Email.EwsContacts.displayName
      description: The contact name.
    - contextPath: Account.Email.EwsContacts.lastModifiedTime
      description: The contact last modified time.
    - contextPath: Account.Email.EwsContacts.emailAddresses
      description: The contact phone numbers.
    - contextPath: Account.Email.EwsContacts.physicalAddresses
      description: The contact physical addresses.
    - contextPath: Account.Email.EwsContacts.phoneNumbers.phoneNumber
      description: The contact email addresses.
    description: Get contacts for mailbox.
  - name: ews-get-out-of-office
    arguments:
    - name: target-mailbox
      required: true
      description: The mailbox to get out-of-office status.
    outputs:
    - contextPath: Account.Email.OutOfOffice.state
      description: 'Out-of-office state. Result can be: Enabled, Scheduled, Disabled.'
    - contextPath: Account.Email.OutOfOffice.externalAudience
      description: 'Out-of-office external audience. Result can be: None, Known, All.'
    - contextPath: Account.Email.OutOfOffice.start
      description: Out-of-office start date.
    - contextPath: Account.Email.OutOfOffice.end
      description: Out-of-office end date.
    - contextPath: Account.Email.OutOfOffice.internalReply
      description: Out-of-office internal replay.
    - contextPath: Account.Email.OutOfOffice.externalReply
      description: Out-of-office external replay.
    - contextPath: Account.Email.OutOfOffice.mailbox
      description: Out-of-office mailbox.
    description: Get out-of-office status for a mailbox.
  - name: ews-recover-messages
    arguments:
    - name: message-ids
      required: true
      description: The messages ids. Comma-separate value. Usually use the output
        of py-ews-delete-items.
    - name: target-folder-path
      required: true
      description: The folder path to recover the messages to.
      defaultValue: Inbox
    - name: target-mailbox
      description: The mailbox where the messages found. Use the default mailbox if
        empty, otherwise user might has to be with impersonation rights to this mailbox.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The recovered item id.
    - contextPath: EWS.Items.messageId
      description: The recovered message id.
    - contextPath: EWS.Items.action
      description: The value will be 'recovered'.
    description: Recover messages that has beed soft-deleted.
  - name: ews-create-folder
    arguments:
    - name: new-folder-name
      required: true
      description: The new folder name.
    - name: folder-path
      required: true
      description: Path to locate the new folder. Exchange folder ID is also supported.
      defaultValue: Inbox
    - name: target-mailbox
      description: The mailbox.
    description: Create a new folder in a mailbox.
  - name: ews-mark-item-as-junk
    arguments:
    - name: item-id
      required: true
      description: The item id to mark as junk.
    - name: move-items
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Move the item from the original folder to junk folder.
      defaultValue: "yes"
    - name: target-mailbox
      description: 'Use the default mailbox if empty, otherwise user might has to
        be with impersonation rights to this mailbox. '
    description: 'Mark an item as junk - usually use to block an email address, as
      described here: https://msdn.microsoft.com/en-us/library/office/dn481311(v=exchg.150).aspx'
  - name: ews-find-folders
    arguments:
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Folders.name
      description: Folder name
      type: string
    - contextPath: EWS.Folders.id
      description: Folder id
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Number of items in folder
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread items in folder
      type: number
    - contextPath: EWS.Folders.changeKey
      description: Folder change key
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders
      type: number
    description: Get folders information for a mailbox. Only folders with read permissions
      will be return as a result. Notice that your visual folders on the mailbox (like
      Inbox, etc) is under the folder "Top of Information Store".
  - name: ews-get-items-from-folder
    arguments:
    - name: folder-path
      required: true
      description: The folder path to get the items from.
    - name: limit
      description: Maximum number of items to fetch.
      defaultValue: "100"
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item id.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Email received time.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
    - contextPath: EWS.Items.sender
      description: Email sender mail address.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject
      type: string
    - contextPath: EWS.Items.textBody
      description: Email body (as text)
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
    - contextPath: EWS.Items.messageId
      description: Email message id.
      type: string
    - contextPath: EWS.Items.body
      description: Email HTML body.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment id for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment id for item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name for item attachment.
      type: unknown
    description: Get items from a specific folder in a mailbox. The items will return
      order by created time, first item is the most recent item.
  - name: ews-get-items
    arguments:
    - name: item-ids
      required: true
      description: The item ids. List or comma-separated value are supported.
      isArray: true
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item id.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Email received time.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
    - contextPath: EWS.Items.sender
      description: Email sender mail address.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject
      type: string
    - contextPath: EWS.Items.textBody
      description: Email body (as text)
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
    - contextPath: EWS.Items.messageId
      description: Email message id.
      type: string
    - contextPath: EWS.Items.body
      description: Email HTML body.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment id for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment id for item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name for item attachment.
      type: unknown
    description: Get items by id.
  - name: ews-move-item-between-mailboxes
    arguments:
    - name: item-id
      required: true
      description: The item id to move.
    - name: destination-folder-path
      required: true
      description: The folder in the destination mailbox to move the item to. Complex
        path can be used, e.g. Inbox\Phishing.
    - name: destination-mailbox
      required: true
      description: The mailbox to move the item to.
    - name: source-mailbox
      description: The mailbox to move the item from (conventionally called "target-mailbox"
        - the target mailbox to apply the command on).
    outputs:
    - contextPath: EWS.Items.movedToMailbox
      description: The mailbox that the item was moved to.
      type: string
    - contextPath: EWS.Items.movedToFolder
      description: The folder that the item was moved to.
      type: string
    - contextPath: EWS.Items.action
      description: The action, value will be 'moved'.
      type: string
    description: Move an item from one mailbox to another.
  dockerimage: demisto/py-ews:2.0
  isfetch: true
releaseNotes: "Handled unnamed attachments."

