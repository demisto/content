commonfields:
  id: EWS v2
  version: -1
name: EWS v2
display: EWS v2
category: Messaging
image: data:image/png;base64,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
description: Exchange Web Services and Office 365 (mail)
detaileddescription: |-
  For Office 365, use https://outlook.office365.com/EWS/Exchange.asmx (default) as the Server  URL.
  For on-premise exchange server, we recommend to use server IP address

  To fetch emails from a specific folder, folder path needs to be specified. You can also use exchange folder ID (use !ews-find-folders command first to get the folder ID). Inbox is the default folder.

  In case of authentication error, make sure the user has full access permissions to the mailbox. For more information, read "How to config EWS Permissions" in the integration documentation.
configuration:
- display: 'Exchange URL or Server IP address '
  name: ewsServer
  defaultvalue: https://outlook.office365.com/EWS/Exchange.asmx/
  type: 0
  required: true
- display: 'Authentication: Email address (for office365) or DOMAIN\USERNAME (e.g.
    DEMISTO.INT\admin)'
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Default Target Mailbox
  name: defaultTargetMailbox
  defaultvalue: ""
  type: 0
  required: true
- display: Server Version (2007,2010,2010_SP2,2013,2016)
  name: defaultServerVersion
  defaultvalue: "2016"
  type: 0
  required: true
- display: Authentication Type (NTLM or Basic or Digest). Use Basic for Office365.
  name: authType
  defaultvalue: Basic
  type: 0
  required: true
- display: Has impersonation rights.
  name: impersonation
  defaultvalue: "false"
  type: 8
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Folder name to fetch incidents from or Exchange Folder ID. Support also
    sub-folders (e.g. Inbox\Phishing)
  name: folder
  defaultvalue: Inbox
  type: 0
  required: false
- display: Public Folder
  name: isPublicFolder
  defaultvalue: "false"
  type: 8
  required: false
- display: HTTP requests to exchange server timeout
  name: requestTimeout
  defaultvalue: "120"
  type: 0
  required: false
script:
  script: |
    import sys, traceback, json, os, hashlib
    from datetime import timedelta
    from cStringIO import StringIO
    import logging, warnings
    import subprocess

    # Define utf8 as default encoding
    reload(sys)
    sys.setdefaultencoding('utf8')

    # Ignore warnings print to stdout
    warnings.filterwarnings("ignore")

    import exchangelib
    from exchangelib.errors import ErrorItemNotFound, ResponseMessageError, TransportError, RateLimitError, ErrorInvalidIdMalformed, \
        ErrorFolderNotFound, ErrorToFolderNotFound, ErrorMailboxStoreUnavailable, ErrorMailboxMoveInProgress, ErrorInvalidPropertyRequest
    from exchangelib.items import Item, Message
    from exchangelib.services import EWSService, EWSAccountService
    from exchangelib.util import create_element, add_xml_child
    from exchangelib import IMPERSONATION, DELEGATE, Account, ServiceAccount, \
        EWSDateTime, EWSTimeZone, Configuration, NTLM, DIGEST, BASIC, FileAttachment, ItemAttachment, \
        Version, Folder, HTMLBody, Body
    from exchangelib.version import EXCHANGE_2007, EXCHANGE_2010, EXCHANGE_2010_SP2, EXCHANGE_2013, EXCHANGE_2016
    from exchangelib.protocol import BaseProtocol, NoVerifyHTTPAdapter

    # Docker BC
    MNS = None
    TNS = None
    if exchangelib.__version__ == "1.12.0":
        MNS, TNS = exchangelib.util.MNS, exchangelib.util.TNS
    else:
        MNS, TNS = exchangelib.transport.MNS, exchangelib.transport.TNS

    # consts
    VERSIONS = {
        '2007': EXCHANGE_2007,
        '2010': EXCHANGE_2010,
        '2010_SP2': EXCHANGE_2010_SP2,
        '2013': EXCHANGE_2013,
        '2016': EXCHANGE_2016
    }

    ATTACHMENT_ID = "attachmentId"
    ATTACHMENT_ORIGINAL_ITEM_ID = 'originalItemId'
    NEW_ITEM_ID = 'newItemId'
    MESSAGE_ID = "messageId"
    ITEM_ID = "itemId"
    ACTION = "action"
    MAILBOX = "mailbox"
    MAILBOX_ID = "mailboxId"
    FOLDER_ID = "id"

    MOVED_TO_MAILBOX = "movedToMailbox"
    MOVED_TO_FOLDER = "movedToFolder"

    FILE_ATTACHMENT_TYPE = 'FileAttachment'
    ITEM_ATTACHMENT_TYPE = 'ItemAttachment'
    ATTACHMENT_TYPE = 'attachmentType'

    TOIS_PATH = '/root/Top of Information Store/'

    ENTRY_CONTEXT = "EntryContext"
    CONTEXT_UPDATE_EWS_ITEM = "EWS.Items(val.{0} == obj.{0} || (val.{1} && obj.{1} && val.{1} == obj.{1}))".format(ITEM_ID,
                                                                                                                   MESSAGE_ID)
    CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT = "EWS.Items(val.{0} == obj.{1})".format(ITEM_ID, ATTACHMENT_ORIGINAL_ITEM_ID)
    CONTEXT_UPDATE_ITEM_ATTACHMENT = ".ItemAttachments(val.{0} == obj.{0})".format(ATTACHMENT_ID)
    CONTEXT_UPDATE_FILE_ATTACHMENT = ".FileAttachments(val.{0} == obj.{0})".format(ATTACHMENT_ID)
    CONTEXT_UPDATE_FOLDER = "EWS.Folders(val.{0} == obj.{0})".format(FOLDER_ID)

    LAST_RUN_TIME = "lastRunTime"
    LAST_RUN_IDS = "ids"
    LAST_RUN_FOLDER = "folderName"
    ERROR_COUNTER = "errorCounter"

    ITEMS_RESULTS_HEADERS = ['sender', 'subject', 'hasAttachments', 'datetimeReceived', 'receivedBy', 'author',
                             'toRecipients', ]

    # Load integratoin params from demisto
    USE_PROXY = demisto.params()['proxy']
    NON_SECURE = demisto.params()['insecure']
    AUTH_METHOD_STR = demisto.params()['authType'].lower()
    VERSION_STR = demisto.params()['defaultServerVersion']
    EWS_SERVER = demisto.params()['ewsServer']
    USERNAME = demisto.params()['credentials']['identifier']
    ACCOUNT_EMAIL = demisto.params().get('defaultTargetMailbox', None)
    if not ACCOUNT_EMAIL:
        if "@" in USERNAME:
            ACCOUNT_EMAIL = USERNAME
        if "\\" in USERNAME:
            user_domain = USERNAME.split("\\")
            if len(user_domain) == 2:
                ACCOUNT_EMAIL = user_domain[1] + "@" + user_domain[0]
    if ACCOUNT_EMAIL is None:
        raise Exception("Provide a valid email address")
    PASSWORD = demisto.params()['credentials']['password']
    FOLDER_NAME = demisto.params().get('folder', 'Inbox')
    IS_PUBLIC_FOLDER = demisto.params().get('isPublicFolder', False)
    ACCESS_TYPE = IMPERSONATION if demisto.params()['impersonation'] else DELEGATE
    FETCH_ALL_HISTORY = demisto.params().get('fetchAllHistory', False)
    IS_TEST_MODULE = False
    BaseProtocol.TIMEOUT = int(demisto.params().get('requestTimeout', 120))


    PUBLIC_FOLDERS_ERROR = 'Please update your docker image to use public folders'
    if IS_PUBLIC_FOLDER and exchangelib.__version__ != "1.12.0":
        if demisto.command() == 'test-module':
            demisto.results(PUBLIC_FOLDERS_ERROR)
            exit(3)
        raise Exception(PUBLIC_FOLDERS_ERROR)


    # Prep Functions
    def get_auth_method(auth_method):
        auth_method = auth_method.lower()
        if auth_method == 'ntlm':
            return NTLM
        elif auth_method == 'basic':
            return BASIC
        elif auth_method == 'digest':
            return DIGEST
        raise Exception("%s auth method is not supported. Choose one of %s" % (auth_method, 'ntlm\\basic\\digest'))


    def get_build(version_str):
        if version_str not in VERSIONS:
            raise Exception("%s is unsupported version: %s. Choose one of" % (version_str, "\\".join(VERSIONS.keys())))
        return VERSIONS[version_str]


    def get_version(version_str):
        if version_str not in VERSIONS:
            raise Exception("%s is unsupported version: %s. Choose one of" % (version_str, "\\".join(VERSIONS.keys())))
        return Version(VERSIONS[version_str])


    def prepare():
        if NON_SECURE:
            BaseProtocol.HTTP_ADAPTER_CLS = NoVerifyHTTPAdapter

        if not USE_PROXY:
            def remove_from_dict(d, key):
                if key in d:
                    del d[key]

            remove_from_dict(os.environ, 'HTTP_PROXY')
            remove_from_dict(os.environ, 'http_proxy')
            remove_from_dict(os.environ, 'HTTPS_PROXY')
            remove_from_dict(os.environ, 'https_proxy')

            os.environ['NO_PROXY'] = EWS_SERVER

        version = get_version(VERSION_STR)
        credentials = ServiceAccount(username=USERNAME, password=PASSWORD, max_wait=0)
        config_args = {
            'credentials': credentials,
            'auth_type': get_auth_method(AUTH_METHOD_STR),
            'version': version
        }
        if 'http' in EWS_SERVER.lower():
            config_args['service_endpoint'] = EWS_SERVER
        else:
            config_args['server'] = EWS_SERVER
        config = Configuration(**config_args)
        return config


    def get_account(account_email, access_type=ACCESS_TYPE):
        return Account(
            primary_smtp_address=account_email, autodiscover=False, config=config, access_type=access_type,
        )


    # LOGGING
    log_stream = None

    def start_logging():
        global log_stream
        if log_stream is None:
            log_stream = StringIO()
            logging.basicConfig(stream=log_stream, level=logging.DEBUG)


    # Exchange 2010 Fixes
    def fix_2010():
        version = get_build(VERSION_STR)
        if 'target-mailbox' in demisto.args():
            version = get_account(demisto.args()['target-mailbox']).protocol.version.build
        if version <= EXCHANGE_2010_SP2:
            for m in (Item, Message, exchangelib.items.CalendarItem, exchangelib.items.Contact, exchangelib.items.DistributionList, exchangelib.items.PostItem, exchangelib.items.Task, exchangelib.items.MeetingRequest, exchangelib.items.MeetingResponse, exchangelib.items.MeetingCancellation):
                for i,f in enumerate(m.FIELDS):
                    if f.name == 'text_body':
                        m.FIELDS.pop(i)
                        break
            for m in (exchangelib.Folder, exchangelib.folders.Inbox):
                for i,f in enumerate(m.FIELDS):
                    if f.name == 'unread_count':
                        m.FIELDS.pop(i)
                        break

            def repr1(self):
                return self.__class__.__name__ + \
                    repr((self.root, self.name, self.total_count, self.child_folder_count, self.folder_class, self.id, self.changekey))

            def repr2(self):
                return self.__class__.__name__ + \
                    repr((self.root, self.name, self.total_count, self.child_folder_count, self.folder_class, self.changekey))

            def repr3(self):
                return self.__class__.__name__ + \
                       repr((self.account, '[self]', self.name, self.total_count, self.child_folder_count, self.folder_class, self.changekey))

            exchangelib.Folder.__repr__ = repr1
            exchangelib.folders.Inbox.__repr__ = repr2
            exchangelib.folders.Root.__repr__ = repr3

        start_logging()

    def str_to_unicode(obj):
        if isinstance(obj, dict):
            obj = {k: str_to_unicode(v) for k,v in obj.iteritems()}
        elif isinstance(obj, list):
            obj = map(str_to_unicode, obj)
        elif isinstance(obj, str):
            obj = unicode(obj, "utf-8")
        return obj

    def filter_dict_null(d):
        if isinstance(d, dict):
            return dict((k, v) for k, v in d.items() if v is not None)
        return d

    def get_attachment_name(attachment_name):
        if attachment_name is None or attachment_name == "":
            return 'demisto_untitled_attachment'
        return attachment_name


    def get_entry_for_object(title, context_key, obj, headers=None):
        if len(obj) == 0:
            return "There is no output results"
        obj = filter_dict_null(obj)
        if isinstance(obj, list):
            obj = map(filter_dict_null, obj)
        if headers and isinstance(obj, dict):
            headers = list(set(headers).intersection(set(obj.keys())))

        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, obj, headers),
            ENTRY_CONTEXT: {
                context_key: obj
            }
        }


    def get_items_from_mailbox(account, item_ids):
        if type(item_ids) is not list:
            item_ids = [item_ids]
        items = map(lambda x: Item(item_id=x), item_ids)
        result = list(account.fetch(ids=items))
        result = [x for x in result if not isinstance(x, ErrorItemNotFound)]
        if len(result) != len(item_ids):
            raise Exception("One or more items were not found. Check the input item ids")
        if exchangelib.__version__ != "1.12.0":   # Docker BC
            for item in result:
                item.folder = Folder(account=account)
        return result


    def get_item_from_mailbox(account, item_id):
        result = get_items_from_mailbox(account, [item_id])
        if len(result) == 0:
            raise Exception("ItemId %s not found" % str(item_id))
        return result[0]


    def is_default_folder(folder_path, is_public):
        if exchangelib.__version__ != "1.12.0":   # Docker BC
            return False

        if is_public is not None:
            return is_public

        if folder_path == FOLDER_NAME:
            return IS_PUBLIC_FOLDER

        return False


    def get_folder_by_path(account, path, is_public=False):
        # handle exchange folder id
        if len(path) == 120:
            folders_map = account.root._folders_map
            if path in folders_map:
                return account.root._folders_map[path]

        if is_public:
            folder_result = account.public_folders_root
        elif path == u'AllItems':
            folder_result = account.root
        else:
            folder_result = account.inbox.parent  # Top of Information Store
        path = path.replace("/", "\\")
        path = path.split('\\')
        for sub_folder_name in path:
            folder_filter_by_name = [x for x in folder_result.children if x.name.lower() == sub_folder_name.lower()]
            if len(folder_filter_by_name) == 0:
                raise Exception("No such folder %s" % path)
            folder_result = folder_filter_by_name[0]

        return folder_result


    class MarkAsJunk(EWSAccountService):
        SERVICE_NAME = 'MarkAsJunk'

        def call(self, item_id, move_item):
            elements = list(self._get_elements(payload=self.get_payload(item_id=item_id, move_item=move_item)))
            for element in elements:
                if isinstance(element, ResponseMessageError):
                    return element.message
            return "Success"

        def get_payload(self, item_id, move_item):
            junk = create_element('m:%s' % self.SERVICE_NAME,
                                  IsJunk="true",
                                  MoveItem="true" if move_item else "false")

            items_list = create_element('m:ItemIds')
            item_element = create_element("t:ItemId", Id=item_id)
            items_list.append(item_element)
            junk.append(items_list)

            return junk


    class GetSearchableMailboxes(EWSService):
        SERVICE_NAME = 'GetSearchableMailboxes'
        element_container_name = '{%s}SearchableMailboxes' % MNS

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find("{%s}PrimarySmtpAddress" % TNS).text if element.find("{%s}PrimarySmtpAddress" % TNS) is not None else None,
                MAILBOX_ID: element.find("{%s}ReferenceId" % TNS).text if element.find("{%s}ReferenceId" % TNS) is not None else None,
                'displayName': element.find("{%s}DisplayName" % TNS).text if element.find("{%s}DisplayName" % TNS) is not None else None,
                'isExternal': element.find("{%s}IsExternalMailbox" % TNS).text if element.find("{%s}IsExternalMailbox" % TNS) is not None else None,
                'externalEmailAddress': element.find("{%s}ExternalEmailAddress" % TNS).text if element.find("{%s}ExternalEmailAddress" % TNS) is not None else None
            }

        def call(self):
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = self._get_elements(payload=self.get_payload())
            return map(lambda x: self.parse_element(x), elements)

        def get_payload(self):
            element = create_element(
                'm:%s' % self.SERVICE_NAME,
            )
            return element


    class SearchMailboxes(EWSService):
        SERVICE_NAME = 'SearchMailboxes'
        element_container_name = '{%s}SearchMailboxesResult/{%s}Items' % (MNS, TNS)

        @staticmethod
        def parse_element(element):
            to_recipients = element.find('{%s}ToRecipients' % TNS)
            if to_recipients:
                to_recipients = map(lambda x: x.text if x is not None else None, to_recipients)

            result = {
                ITEM_ID: element.find('{%s}Id' % TNS).attrib['Id'] if element.find('{%s}Id' % TNS) is not None else None,
                MAILBOX: element.find('{%s}Mailbox/{%s}PrimarySmtpAddress' % (TNS, TNS)).text if element.find(
                    '{%s}Mailbox/{%s}PrimarySmtpAddress' % (TNS, TNS)) is not None else None,
                'subject': element.find("{%s}Subject" % TNS).text if element.find(
                    "{%s}Subject" % TNS) is not None else None,
                'toRecipients': to_recipients,
                'sender': element.find("{%s}Sender" % TNS).text if element.find("{%s}Sender" % TNS) is not None else None,
                'hasAttachments': element.find("{%s}HasAttachment" % TNS).text if element.find(
                    "{%s}HasAttachment" % TNS) is not None else None,
                'datetimeSent': element.find("{%s}SentTime" % TNS).text if element.find(
                    "{%s}SentTime" % TNS) is not None else None,
                'datetimeReceived': element.find("{%s}ReceivedTime" % TNS).text if element.find(
                    "{%s}ReceivedTime" % TNS) is not None else None
            }

            return result

        def call(self, query, mailboxes):
            query = query.replace(".", "\\.")
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = list(self._get_elements(payload=self.get_payload(query, mailboxes)))
            return map(lambda x: self.parse_element(x), elements)

        def get_payload(self, query, mailboxes):
            def get_mailbox_search_scope(mailbox_id):
                mailbox_search_scope = create_element("t:MailboxSearchScope")
                add_xml_child(mailbox_search_scope, "t:Mailbox", mailbox_id)
                add_xml_child(mailbox_search_scope, "t:SearchScope", "All")
                return mailbox_search_scope

            mailbox_query_element = create_element("t:MailboxQuery")
            add_xml_child(mailbox_query_element, "t:Query", query)
            mailboxes_scopes = []
            for mailbox in mailboxes:
                mailboxes_scopes.append(get_mailbox_search_scope(mailbox))
            add_xml_child(mailbox_query_element, "t:MailboxSearchScopes", mailboxes_scopes)

            element = create_element('m:%s' % self.SERVICE_NAME)
            add_xml_child(element, "m:SearchQueries", mailbox_query_element)
            add_xml_child(element, "m:ResultType", "PreviewOnly")

            return element


    def get_searchable_mailboxes(protocol):
        searchable_mailboxes = GetSearchableMailboxes(protocol=protocol).call()
        return get_entry_for_object("Searchable mailboxes", 'EWS.Mailboxes', searchable_mailboxes)


    def search_mailboxes(protocol, filter, limit=100, mailbox_search_scope=None, email_addresses=None):
        mailbox_ids = []
        limit = int(limit)
        if mailbox_search_scope is not None and email_addresses is not None:
            raise Exception("Use one of the arguments - mailbox-search-scope or email-addresses, not both")
        if email_addresses:
            email_addresses = email_addresses.split(",")
            all_mailboxes = get_searchable_mailboxes(protocol)[ENTRY_CONTEXT]['EWS.Mailboxes']
            for email_address in email_addresses:
                for mailbox in all_mailboxes:
                    if email_address.lower() == mailbox[MAILBOX].lower():
                        mailbox_ids.append(mailbox[MAILBOX_ID])
            if len(mailbox_ids) != len(email_addresses):
                raise Exception("Did not found one or some of the specified email addresses")
        elif mailbox_search_scope:
            mailbox_ids = mailbox_search_scope if type(mailbox_search_scope) is list else [mailbox_search_scope]
        else:
            entry = get_searchable_mailboxes(protocol)
            mailboxes = [x for x in entry[ENTRY_CONTEXT]['EWS.Mailboxes'] if MAILBOX_ID in x.keys()]
            mailbox_ids = map(lambda x: x[MAILBOX_ID], mailboxes)

        try:
            search_results = SearchMailboxes(protocol=protocol).call(filter, mailbox_ids)
            search_results = search_results[:limit]
        except TransportError, e:
            if "ItemCount>0<" in str(e):
                return "No results for search query: " + filter
            else:
                raise e

        return get_entry_for_object("Search mailboxes results",
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    search_results)


    def get_last_run():
        last_run = demisto.getLastRun()
        if not last_run or last_run.get(LAST_RUN_FOLDER) != FOLDER_NAME:
            last_run = {
                LAST_RUN_TIME: None,
                LAST_RUN_FOLDER: FOLDER_NAME,
                LAST_RUN_IDS: None
            }
        if LAST_RUN_TIME in last_run and last_run[LAST_RUN_TIME] is not None:
            last_run[LAST_RUN_TIME] = EWSDateTime.from_string(last_run[LAST_RUN_TIME])

        return last_run


    def fetch_last_emails(account, folder_name='Inbox', since_datetime=None, exclude_ids=None):
        qs = get_folder_by_path(account, folder_name, is_public=IS_PUBLIC_FOLDER)
        if since_datetime:
            qs = qs.filter(datetime_received__gte=since_datetime)
        else:
            if not FETCH_ALL_HISTORY:
                last_10_min = EWSDateTime.now(tz=EWSTimeZone.timezone('UTC')) - timedelta(minutes=10)
                qs = qs.filter(datetime_received__gte=last_10_min)
        qs = qs.filter().only(*map(lambda x: x.name, Message.FIELDS))
        result = qs.all()
        result = [x for x in result if isinstance(x, Message)]
        if exclude_ids and len(exclude_ids) > 0:
            exclude_ids = set(exclude_ids)
            result = [x for x in result if x.message_id not in exclude_ids]
        return result


    def keys_to_camel_case(value):
        def str_to_camel_case(snake_str):
            components = snake_str.split('_')
            return components[0] + "".join(x.title() for x in components[1:])

        if value is None:
            return None
        if isinstance(value, list):
            return map(keys_to_camel_case, value)
        if isinstance(value, dict):
            return dict((keys_to_camel_case(k),
                         keys_to_camel_case(v) if isinstance(v, (list, dict)) else v)
                        for (k, v) in value.items())

        return str_to_camel_case(value)


    def parse_item_as_dict(item, email_address, camel_case=False, compact_fields=False):
        def parse_object_as_dict(object):
            raw_dict = {}
            if object is not None:
                for field in object.FIELDS:
                    raw_dict[field.name] = getattr(object, field.name, None)
            return raw_dict

        def parse_attachment_as_raw_json(attachment):
            raw_dict = parse_object_as_dict(attachment)
            if raw_dict['attachment_id']:
                raw_dict['attachment_id'] = parse_object_as_dict(raw_dict['attachment_id'])
            if raw_dict['last_modified_time']:
                raw_dict['last_modified_time'] = raw_dict['last_modified_time'].ewsformat()
            return raw_dict

        def parse_folder_as_json(folder):
            raw_dict = parse_object_as_dict(folder)
            if 'parent_folder_id' in raw_dict:
                raw_dict['parent_folder_id'] = parse_folder_as_json(raw_dict['parent_folder_id'])
            if 'effective_rights' in raw_dict:
                raw_dict['effective_rights'] = parse_object_as_dict(raw_dict['effective_rights'])
            return raw_dict

        raw_dict = {}
        for field, value in item.__dict__.items():
            if type(value) in [str, unicode, int, float, bool, Body, HTMLBody, None]:
                try:
                    if isinstance(value, basestring):
                        value.encode('utf-8')
                    raw_dict[field] = value
                except:
                    pass

        if getattr(item, 'attachments', None):
            raw_dict['attachments'] = map(lambda x: parse_attachment_as_dict(item.item_id, x), item.attachments)

        for time_field in ['datetime_sent', 'datetime_created', 'datetime_received', 'last_modified_time',
                           'reminder_due_by']:
            value = getattr(item, time_field, None)
            if value:
                raw_dict[time_field] = value.ewsformat()

        for dict_field in ['effective_rights', 'parent_folder_id', 'conversation_id', 'author',
                           'extern_id', 'received_by', 'received_representing', 'reply_to', 'sender', 'folder']:
            value = getattr(item, dict_field, None)
            if value:
                raw_dict[dict_field] = parse_object_as_dict(value)

        for list_dict_field in ['headers', 'cc_recipients', 'to_recipients']:
            value = getattr(item, list_dict_field, None)
            if value:
                raw_dict[list_dict_field] = map(lambda x: parse_object_as_dict(x), value)

        if getattr(item, 'folder', None):
            raw_dict['folder'] = parse_folder_as_json(item.folder)
            folder_path = item.folder.absolute[len(TOIS_PATH):] if item.folder.absolute.startswith(TOIS_PATH) else item.folder.absolute
            raw_dict['folder_path'] = folder_path

        if compact_fields:
            new_dict = {}
            fields_list = ['datetime_created', 'datetime_received', 'datetime_sent', 'sender',
                           'has_attachments', 'importance', 'message_id', 'last_modified_time',
                           'size', 'subject', 'text_body', 'headers', 'body', 'folder_path']

            # Docker BC
            if exchangelib.__version__ == "1.12.0":
                if 'id' in raw_dict:
                    new_dict['item_id'] = raw_dict['id']
            else:
                fields_list.append('item_id')

            for field in fields_list:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field)
            for field in ['received_by', 'author', 'sender']:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field, {}).get('email_address')
            for field in ['to_recipients']:
                if field in raw_dict:
                    new_dict[field] = map(lambda x: x.get('email_address'), raw_dict[field])
            attachments = raw_dict.get('attachments')
            if attachments and len(attachments) > 0:
                file_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == FILE_ATTACHMENT_TYPE]
                if len(file_attachments) > 0:
                    new_dict['FileAttachments'] = file_attachments
                item_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == ITEM_ATTACHMENT_TYPE]
                if len(item_attachments) > 0:
                    new_dict['ItemAttachments'] = item_attachments

            raw_dict = new_dict

        if camel_case:
            raw_dict = keys_to_camel_case(raw_dict)

        if email_address:
            raw_dict[MAILBOX] = email_address
        return raw_dict


    def parse_incident_from_item(item):
        incident = {}
        labels = []

        try:
            incident['details'] = item.text_body or item.body
        except AttributeError:
            incident['details'] = item.body
        incident['name'] = item.subject
        labels.append({'type': 'Email/subject', 'value': item.subject})
        incident['occurred'] = item.datetime_created.ewsformat()

        # handle recipients
        if item.to_recipients:
            for recipient in item.to_recipients:
                labels.append({'type': 'Email', 'value': recipient.email_address})

        # handle cc
        if item.cc_recipients:
            for recipient in item.cc_recipients:
                labels.append({'type': 'Email/cc', 'value': recipient.email_address})
        # handle email from
        if item.sender:
            labels.append({'type': 'Email/from', 'value': item.sender.email_address})

        # email format
        email_format = ''
        try:
            if item.text_body:
                labels.append({'type': 'Email/text', 'value': item.text_body})
                email_format = 'text'
        except AttributeError:
            pass
        if item.body:
            labels.append({'type': 'Email/html', 'value': item.body})
            email_format = 'HTML'
        labels.append({'type': 'Email/format', 'value': email_format})

        # handle attachments
        if item.attachments:
            incident['attachment'] = [];
            for attachment in item.attachments:
                file_result = None
                label_attachment_type = None
                label_attachment_id_type = None
                if isinstance(attachment, FileAttachment):
                    try:
                        if attachment.content:
                            # file attachment
                            label_attachment_type = 'attachments'
                            label_attachment_id_type = 'attachmentId'

                            # save the attachment
                            file_name = get_attachment_name(attachment.name)
                            file_result = fileResult(file_name, attachment.content)

                            # check for error
                            if file_result['Type'] == entryTypes['error']:
                                demisto.error(file_result['Contents'])
                                raise Exception(file_result['Contents'])

                            # save attachment to incident
                            incident['attachment'].append({
                                'path': file_result['FileID'],
                                'name': get_attachment_name(attachment.name)
                            })
                    except TypeError, e:
                        if e.message != "must be string or buffer, not None":
                            raise
                        continue
                else:
                    # other item attachment
                    label_attachment_type = 'attachmentItems'
                    label_attachment_id_type = 'attachmentItemsId'

                    # save the attachment
                    if attachment.item.mime_content:
                        file_result = fileResult(get_attachment_name(attachment.name) + ".eml", attachment.item.mime_content)

                    if file_result:
                        # check for error
                        if file_result['Type'] == entryTypes['error']:
                            demisto.error(file_result['Contents'])
                            raise Exception(file_result['Contents'])

                        # save attachment to incident
                        incident['attachment'].append({
                            'path': file_result['FileID'],
                            'name': get_attachment_name(attachment.name) + ".eml"
                        })


                labels.append({'type': label_attachment_type, 'value': get_attachment_name(attachment.name)})
                labels.append({'type': label_attachment_id_type, 'value': attachment.attachment_id.id})



        # handle headers
        if item.headers:
            headers = []
            for header in item.headers:
                labels.append({'type': 'Email/Header/' + header.name, 'value': header.value})
                headers.append(header.name + ": " + header.value)
            labels.append({'type': 'Email/headers', 'value': "\r\n".join(headers)})

        # handle item id
        if item.message_id:
            labels.append({'type': 'Email/MessageId', 'value': item.message_id})

        if item.item_id:
            labels.append({'type': 'Email/ID', 'value': item.item_id})
            labels.append({'type': 'Email/itemId', 'value': item.item_id})

        # handle conversion id
        if item.conversation_id:
            labels.append({'type': 'Email/ConversionID', 'value': item.conversation_id.id})

        incident['labels'] = labels
        incident['rawJSON'] = json.dumps(parse_item_as_dict(item, None), ensure_ascii=False)

        return incident


    def fetch_emails_as_incidents(account_email, folder_name):
        start_time = EWSDateTime.now(tz=EWSTimeZone.timezone('UTC'))
        last_run = get_last_run()

        try:
            account = get_account(account_email)
            last_emails = fetch_last_emails(account, folder_name, last_run.get(LAST_RUN_TIME), last_run.get(LAST_RUN_IDS))

            ids = []
            incidents = []
            for item in last_emails:
                if item.message_id:
                    ids.append(item.message_id)
                    incident = parse_incident_from_item(item)
                    incidents.append(incident)

            new_last_run = {
                LAST_RUN_TIME: start_time.ewsformat(),
                LAST_RUN_FOLDER: folder_name,
                LAST_RUN_IDS: ids,
                ERROR_COUNTER: 0
            }

            demisto.setLastRun(new_last_run)
            return incidents

        except RateLimitError:
            if LAST_RUN_TIME in last_run:
                last_run[LAST_RUN_TIME] = last_run[LAST_RUN_TIME].ewsformat()
            if ERROR_COUNTER not in last_run:
                last_run[ERROR_COUNTER] = 0
            last_run[ERROR_COUNTER] += 1
            demisto.setLastRun(last_run)
            if last_run[ERROR_COUNTER] > 2:
                raise
            return []


    def get_entry_for_file_attachment(item_id, attachment):
        entry = fileResult(get_attachment_name(attachment.name), attachment.content)
        ec = {
            CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_FILE_ATTACHMENT: parse_attachment_as_dict(item_id,
                                                                                                              attachment)
        }
        entry[ENTRY_CONTEXT] = filter_dict_null(ec)
        return entry


    def parse_attachment_as_dict(item_id, attachment):
        try:
            attachment_content = attachment.content if isinstance(attachment, FileAttachment) else attachment.item.mime_content
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                'attachmentName': get_attachment_name(attachment.name),
                'attachmentSHA256': hashlib.sha256(attachment_content).hexdigest() if attachment_content else None,
                'attachmentContentType': attachment.content_type,
                'attachmentContentId': attachment.content_id,
                'attachmentContentLocation': attachment.content_location,
                'attachmentSize': attachment.size,
                'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                'attachmentIsInline': attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE
            }
        except TypeError, e:
            if e.message != "must be string or buffer, not None":
                raise
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                'attachmentName': get_attachment_name(attachment.name),
                'attachmentSHA256': None,
                'attachmentContentType': attachment.content_type,
                'attachmentContentId': attachment.content_id,
                'attachmentContentLocation': attachment.content_location,
                'attachmentSize': attachment.size,
                'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
                'attachmentIsInline': attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE
            }


    def get_entry_for_item_attachment(item_id, attachment, target_email):
        item = attachment.item
        dict_result = parse_attachment_as_dict(item_id, attachment)
        dict_result.update(parse_item_as_dict(item, target_email, camel_case=True, compact_fields=True))
        title = 'EWS get attachment got item for "%s", "%s"' % (target_email, get_attachment_name(attachment.name))

        return get_entry_for_object(title, CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                                    dict_result)


    def get_attachments_for_item(item_id, account, attachment_ids=None):
        item = get_item_from_mailbox(account, item_id)
        attachments = []
        if attachment_ids and not isinstance(attachment_ids, list):
            attachment_ids = attachment_ids.split(",")
        if item:
            if item.attachments:
                for attachment in item.attachments:
                    if attachment_ids and attachment.attachment_id.id not in attachment_ids:
                        continue
                    attachments.append(attachment)

        else:
            raise Exception('Message item not found: ' + item_id)

        if attachment_ids and len(attachments) < len(attachment_ids):
            raise Exception('Some attachment id did not found for message:' + str(attachment_ids))

        return attachments


    def delete_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        deleted_file_attachments = []
        deleted_item_attachments = []
        for attachment in attachments:
            attachment_deleted_action = {
                ATTACHMENT_ID: attachment.attachment_id.id,
                ACTION: 'deleted'
            }
            if isinstance(attachment, FileAttachment):
                deleted_file_attachments.append(attachment_deleted_action)
            else:
                deleted_item_attachments.append(attachment_deleted_action)
            attachment.detach()

        entries = []
        if len(deleted_file_attachments) > 0:
            entry = get_entry_for_object("Deleted file attachments",
                                         "EWS.Items" + CONTEXT_UPDATE_FILE_ATTACHMENT,
                                         deleted_file_attachments)
            entries.append(entry)
        if len(deleted_item_attachments) > 0:
            entry = get_entry_for_object("Deleted item attachments",
                                         "EWS.Items" + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                                         deleted_item_attachments)
            entries.append(entry)

        return entries


    def fetch_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        entries = []
        for attachment in attachments:
            if isinstance(attachment, FileAttachment):
                try:
                    if attachment.content:
                        entries.append(get_entry_for_file_attachment(item_id, attachment))
                except TypeError, e:
                    if e.message != "must be string or buffer, not None":
                        raise
            else:
                entries.append(get_entry_for_item_attachment(item_id, attachment, account.primary_smtp_address))
                if attachment.item.mime_content:
                    entries.append(fileResult(get_attachment_name(attachment.name) + ".eml", attachment.item.mime_content))

        return entries

    def move_item_between_mailboxes(item_id, destination_mailbox, destination_folder_path, source_mailbox=None, is_public=None):
        source_account = get_account(source_mailbox or ACCOUNT_EMAIL)
        destination_account = get_account(destination_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(destination_folder_path, is_public)
        destination_folder = get_folder_by_path(destination_account, destination_folder_path, is_public)
        item = get_item_from_mailbox(source_account, item_id)
        try:
            source_account.bulk_move(ids=[item], to_folder=destination_folder)
        except ErrorToFolderNotFound:
            exported_items = source_account.export([item])
            destination_account.upload([(destination_folder, exported_items[0])])
            source_account.bulk_delete([item])

        move_result = {
            MOVED_TO_MAILBOX: destination_mailbox,
            MOVED_TO_FOLDER: destination_folder_path,
        }

        return {
            'Type': entryTypes['note'],
            'Contents': "Item was moved successfully.",
            'ContentsFormat': formats['text'],
            ENTRY_CONTEXT: {
               "EWS.Items(val.itemId === '%s')" % (item_id,): move_result
            }
        }

    def move_item(item_id, target_folder_path, target_mailbox=None, is_public=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(target_folder_path, is_public)
        target_folder = get_folder_by_path(account, target_folder_path, is_public)
        item = get_item_from_mailbox(account, item_id)
        if isinstance(item, ErrorInvalidIdMalformed):
            raise Exception("Item not found")
        item.move(target_folder)
        move_result = {
            NEW_ITEM_ID: item.item_id,
            ITEM_ID: item_id,
            MESSAGE_ID: item.message_id,
            ACTION: 'moved'
        }

        return get_entry_for_object('Moved items',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    move_result)


    def delete_items(item_ids, delete_type, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        deleted_items = []
        if type(item_ids) != list:
            item_ids = item_ids.split(",")
        items = get_items_from_mailbox(account, item_ids)
        delete_type = delete_type.lower()

        for item in items:
            item_id = item.item_id
            if delete_type == 'trash':
                item.move_to_trash()
            elif delete_type == 'soft':
                item.soft_delete()
            elif delete_type == 'hard':
                item.delete()
            else:
                raise Exception('invalid delete type: %s. Use "trash" \\ "soft" \\ "hard"' % delete_type)
            deleted_items.append({
                ITEM_ID: item_id,
                MESSAGE_ID: item.message_id,
                ACTION: '%s-deleted' % delete_type
            })

        return get_entry_for_object('Deleted items (%s delete type)' % delete_type,
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    deleted_items)


    def prepare_args(d):
        d = dict((k.replace("-", "_"), v) for k, v in d.items())
        if 'is_public' in d:
            if exchangelib.__version__ != "1.12.0":   # Docker BC
                raise Exception(PUBLIC_FOLDERS_ERROR)
            else:
                d['is_public'] = d['is_public'] == 'True'
        return d


    def get_limited_number_of_messages_from_qs(qs, limit):
        count = 0
        results = []
        for item in qs:
            if count == limit:
                break
            if isinstance(item, Message):
                count += 1
                results.append(item)
        return results


    def search_items_in_mailbox(query, folder_path='', limit=100, target_mailbox=None, is_public=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        limit = int(limit)
        if folder_path:
            public_folder = is_default_folder(folder_path, is_public)
            folders = [get_folder_by_path(account, folder_path, is_public)]
        else:
            folders = account.inbox.parent.walk()

        items = []
        for folder in folders:
            if Message not in folder.supported_item_models:
                continue
            items_qs = folder.filter(query).only(*map(lambda x: x.name, Message.FIELDS))
            items += get_limited_number_of_messages_from_qs(items_qs, limit)
            if len(items) >= limit:
                break
        items = items[:limit]
        searched_items_result = map(lambda item: parse_item_as_dict(item, account.primary_smtp_address, camel_case=True, compact_fields=True), items)

        return get_entry_for_object('Searched items',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    searched_items_result,
                                    headers=ITEMS_RESULTS_HEADERS)


    def get_out_of_office_state(target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        oof = account.oof_settings
        oof_dict = {
            'state': oof.state,
            'externalAudience': getattr(oof, 'external_audience', None),
            'start': oof.start.ewsformat() if oof.start else None,
            'end': oof.end.ewsformat() if oof.end else None,
            'internalReply': getattr(oof, 'internal_replay', None),
            'externalReply': getattr(oof, 'external_replay', None),
            MAILBOX: account.primary_smtp_address
        }
        return get_entry_for_object("Out of office state for %s" % account.primary_smtp_address,
                                    'Account.Email(val.Address == obj.{0}).OutOfOffice'.format(MAILBOX),
                                    oof_dict)


    def recover_soft_delete_item(message_ids, target_folder_path="Inbox", target_mailbox=None, is_public=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(target_folder_path, is_public)
        target_folder = get_folder_by_path(account, target_folder_path, is_public)
        recovered_messages = []
        if type(message_ids) != list:
            message_ids = message_ids.split(",")
        items_to_recover = account.recoverable_items_deletions.filter(message_id__in=message_ids).all()
        if len(items_to_recover) != len(message_ids):
            raise Exception("Some message ids are missing in recoverable items directory")
        for item in items_to_recover:
            item.move(target_folder)
            recovered_messages.append({
                ITEM_ID: item.item_id,
                MESSAGE_ID: item.message_id,
                ACTION: 'recovered'
            })
        return get_entry_for_object("Recovered messages",
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    recovered_messages)


    def get_contacts(limit, target_mailbox=None):
        def parse_physical_address(address):
            result = {}
            for attr in ['city', 'country', 'label', 'state', 'street', 'zipcode']:
                result[attr] = getattr(address, attr, None)
            return result

        def parse_phone_number(phone_number):
            result = {}
            for attr in ['label', 'phone_number']:
                result[attr] = getattr(phone_number, attr, None)
            return result

        def parse_contact(contact):
            contact_dict = dict((k, v if not isinstance(v, EWSDateTime) else v.ewsformat())
                                for k, v in contact.__dict__.items()
                                if isinstance(v, basestring) or isinstance(v, EWSDateTime))
            if contact.physical_addresses:
                contact_dict['physical_addresses'] = map(parse_physical_address, contact.physical_addresses)
            if contact.phone_numbers:
                contact_dict['phone_numbers'] = map(parse_phone_number, contact.phone_numbers)
            if contact.email_addresses and len(contact.email_addresses) > 0:
                contact_dict['emailAddresses'] = map(lambda x: x.email, contact.email_addresses)
            contact_dict = keys_to_camel_case(contact_dict)
            contact_dict = dict((k, v) for k, v in contact_dict.items() if v)
            del contact_dict['mimeContent']
            contact_dict['originMailbox'] = target_mailbox
            return contact_dict

        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        contacts = []
        count = 0
        for contact in account.contacts.all():
            if count >= limit:
                break
            contacts.append(parse_contact(contact))
        return get_entry_for_object('Email contacts for %s' % target_mailbox,
                                    'Account.Email(val.Address == obj.originMailbox).EwsContacts',
                                    contacts)


    def create_folder(new_folder_name, folder_path, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        full_path = "%s\\%s" % (folder_path, new_folder_name)
        try:
            if get_folder_by_path(account, full_path):
                return "Folder %s already exists" % full_path
        except:
            pass
        parent_folder = get_folder_by_path(account, folder_path)
        f = Folder(parent=parent_folder, name=new_folder_name)
        f.save()
        get_folder_by_path(account, full_path)
        return "Folder %s created successfully" % full_path


    def mark_item_as_junk(item_id, move_items, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        move_items = (move_items.lower() == "yes")
        ews_result = MarkAsJunk(account=account).call(item_id=item_id, move_item=move_items)
        mark_as_junk_result = {
            ITEM_ID: item_id,
        }
        if ews_result == "Success":
            mark_as_junk_result[ACTION] = 'marked-as-junk'
        else:
            raise Exception("Failed mark-item-as-junk with error: " + ews_result)

        return get_entry_for_object('Mark item as junk',
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    mark_as_junk_result)


    def find_folders(target_mailbox=None, is_public=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        root = account.root
        if exchangelib.__version__ == "1.12.0":   # Docker BC
            if is_public:
                root = account.public_folders_root
        folders = []
        for f in root.walk():
            folder = folder_to_context_entry(f)
            folders.append(folder)
        folders_tree = root.tree()

        return {
            'Type': entryTypes['note'],
            'Contents': folders,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': folders_tree,
            ENTRY_CONTEXT: {
                'EWS.Folders(val.id == obj.id)': folders
            }
        }


    def get_items_from_folder(folder_path, limit=100, target_mailbox=None, is_public=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        limit = int(limit)
        is_public = is_default_folder(folder_path, is_public)
        folder = get_folder_by_path(account, folder_path, is_public)
        qs = folder.filter().order_by('-datetime_created')
        items = get_limited_number_of_messages_from_qs(qs, limit)
        items_result = map(lambda item: parse_item_as_dict(item, account.primary_smtp_address, camel_case=True, compact_fields=True), items)
        hm_headers = ['sender', 'subject', 'hasAttachments', 'datetimeReceived',
                      'receivedBy', 'author', 'toRecipients', ]
        if exchangelib.__version__ == "1.12.0":   # Docker BC
            hm_headers.append('itemId')
        return get_entry_for_object('Items in folder ' + folder_path,
                                    CONTEXT_UPDATE_EWS_ITEM,
                                    items_result,
                                    headers=hm_headers)


    def get_items(item_ids, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        if type(item_ids) != list:
            item_ids = item_ids.split(",")

        items = get_items_from_mailbox(account, item_ids)
        items = [x for x in items if isinstance(x, Message)]
        items_as_incidents = map(lambda x: parse_incident_from_item(x), items)
        items_to_context = map(lambda x: parse_item_as_dict(x, account.primary_smtp_address, True, True), items)

        return {
            'Type': entryTypes['note'],
            'Contents': items_as_incidents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Get items', items_to_context, ITEMS_RESULTS_HEADERS),
            ENTRY_CONTEXT: {
                CONTEXT_UPDATE_EWS_ITEM: items_to_context
            }
        }

    def get_folder(folder_path, target_mailbox=None, is_public=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        is_public = is_default_folder(folder_path, is_public)
        folder = folder_to_context_entry(get_folder_by_path(account, folder_path, is_public))

        return get_entry_for_object("Folder %s" % (folder_path,), CONTEXT_UPDATE_FOLDER, folder)

    def folder_to_context_entry(f):
        f_entry =  {
            'name': f.name,
            'totalCount': f.total_count,
            'id': f.folder_id,
            'childrenFolderCount': f.child_folder_count,
            'changeKey': f.changekey
        }

        if 'unread_count' in map(lambda x: x.name, Folder.FIELDS):
            f_entry['unreadCount'] = f.unread_count
        return f_entry

    def check_cs_prereqs():
        if not 'outlook.office365.com' in EWS_SERVER:
            raise Exception("This command is only supported for Office 365")
        if exchangelib.__version__ != "1.12.0":
            raise Exception("Please update your docker image to use this command")

    def get_cs_error(stderr):
        return {
            "Type": entryTypes["error"],
            "ContentsFormat": formats["text"],
            "Contents" : stderr
        } if stderr else None

    def get_cs_status(search_name, status):
        return {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': 'Search {} status: {}'.format(search_name, status),
            'EntryContext': {
                'EWS.ComplianceSearch(val.Name === obj.Name)': {'Name': search_name, 'Status': status}
            }
        }

    def start_compliance_search(query):
        check_cs_prereqs()
        output = subprocess.Popen(["pwsh","/usr/local/office365startcompliancesearch.ps1", USERNAME, PASSWORD, query], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = output.communicate()

        if stderr:
            return get_cs_error(stderr)

        prefix = '"Action status: '
        pref_ind = stdout.find(prefix)
        sub_start = pref_ind + len(prefix)
        sub_end = sub_start + 45
        search_name = stdout[sub_start:sub_end]
        return {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': 'Search started: {}'.format(search_name),
            'EntryContext': {
                'EWS.ComplianceSearch': {'Name': search_name, 'Status': 'Starting'}
            }
        }

    def get_compliance_search(search_name):
        check_cs_prereqs()
        output = subprocess.Popen(["pwsh","/usr/local/office365getcompliancesearch.ps1", USERNAME, PASSWORD, search_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = output.communicate()

        if stderr:
            return get_cs_error(stderr)

        # Get search status
        stdout = stdout.split('\n', 1)
        results = [get_cs_status(search_name, stdout[0])]

        # Parse search results from script output if the search has completed. Output to warroom as table.
        if stdout[0] == 'Completed':
            res = list(r[:-1].split(', ') if r[-1] == ',' else r.split(', ') for r in stdout[1][2:-3].split(r'\r\n'))
            res = map(lambda x: {k: v for k,v in (s.split(': ') for s in x)}, res)
            results.append(
                {
                    'Type': entryTypes['note'],
                    'ContentsFormat': formats['text'],
                    'Contents': stdout,
                    'ReadableContentsFormat': formats['markdown'],
                    'HumanReadable': tableToMarkdown('Office 365 Compliance search results', res, ['Location', 'Item count', 'Total size'])
                }
            )

        return results


    def purge_compliance_search(search_name):
        check_cs_prereqs()
        output = subprocess.Popen(["pwsh","/usr/local/office365compliancesearchstartpurge.ps1", USERNAME, PASSWORD, search_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = output.communicate()

        if stderr:
            return get_cs_error(stderr)

        return get_cs_status(search_name, 'Purging')


    def check_purge_compliance_search(search_name):
        check_cs_prereqs()
        output = subprocess.Popen(["pwsh","/usr/local/office365compliancesearchcheckpurge.ps1", USERNAME, PASSWORD, search_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = output.communicate()

        if stderr:
            return get_cs_error(stderr)

        return get_cs_status(search_name, 'Purged' if stdout.split('\n')[-2] == 'Completed' else 'Purging')


    def remove_compliance_search(search_name):
        check_cs_prereqs()
        output = subprocess.Popen(["pwsh","/usr/local/office365removecompliancesearch.ps1", USERNAME, PASSWORD, search_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = output.communicate()

        if stderr:
            return get_cs_error(stderr)

        return get_cs_status(search_name, 'Removed')


    def test_module():
        try:
            global IS_TEST_MODULE
            IS_TEST_MODULE = True
            account = get_account(ACCOUNT_EMAIL)
            if not account.root.effective_rights.read:
                raise Exception("Success to authenticate, but user has no permissions to read from the mailbox. "
                                "Need to delegate the user permissions to the mailbox - "
                                "please read integration documentation and follow the instructions")
            get_folder_by_path(account, FOLDER_NAME, IS_PUBLIC_FOLDER).test_access()
        except ErrorFolderNotFound, e:
            if "Top of Information Store" in e.message:
                raise Exception(
                    "Success to authenticate, but user probably has no permissions to read from the specific folder."
                    "Check user permissions. You can try !ews-find-folders command to "
                    "get all the folders structure that the user has permissions to")
        demisto.results('ok')


    def encode_and_submit_results(obj):
        demisto.results(str_to_unicode(obj))


    config = prepare()
    args = prepare_args(demisto.args())
    fix_2010()
    try:
        if demisto.command() == 'test-module':
            test_module()
        elif demisto.command() == 'fetch-incidents':
            incidents = fetch_emails_as_incidents(ACCOUNT_EMAIL, FOLDER_NAME)
            demisto.incidents(str_to_unicode(incidents))
        elif demisto.command() == 'ews-get-attachment':
            encode_and_submit_results(fetch_attachments_for_message(**args))
        elif demisto.command() == 'ews-delete-attachment':
            encode_and_submit_results(delete_attachments_for_message(**args))
        elif demisto.command() == 'ews-get-searchable-mailboxes':
            encode_and_submit_results(get_searchable_mailboxes(config.protocol))
        elif demisto.command() == 'ews-search-mailboxes':
            encode_and_submit_results(search_mailboxes(config.protocol, **args))
        elif demisto.command() == 'ews-move-item-between-mailboxes':
            encode_and_submit_results(move_item_between_mailboxes(**args))
        elif demisto.command() == 'ews-move-item':
            encode_and_submit_results(move_item(**args))
        elif demisto.command() == 'ews-delete-items':
            encode_and_submit_results(delete_items(**args))
        elif demisto.command() == 'ews-search-mailbox':
            encode_and_submit_results(search_items_in_mailbox(**args))
        elif demisto.command() == 'ews-get-contacts':
            encode_and_submit_results(get_contacts(**args))
        elif demisto.command() == 'ews-get-out-of-office':
            encode_and_submit_results(get_out_of_office_state(**args))
        elif demisto.command() == 'ews-recover-messages':
            encode_and_submit_results(recover_soft_delete_item(**args))
        elif demisto.command() == 'ews-create-folder':
            encode_and_submit_results(create_folder(**args))
        elif demisto.command() == 'ews-mark-item-as-junk':
            encode_and_submit_results(mark_item_as_junk(**args))
        elif demisto.command() == 'ews-find-folders':
            encode_and_submit_results(find_folders(**args))
        elif demisto.command() == 'ews-get-items-from-folder':
            encode_and_submit_results(get_items_from_folder(**args))
        elif demisto.command() == 'ews-get-items':
            encode_and_submit_results(get_items(**args))
        elif demisto.command() == 'ews-get-folder':
            encode_and_submit_results(get_folder(**args))
        elif demisto.command() == 'ews-o365-start-compliance-search':
            encode_and_submit_results(start_compliance_search(**args))
        elif demisto.command() == 'ews-o365-get-compliance-search':
            encode_and_submit_results(get_compliance_search(**args))
        elif demisto.command() == 'ews-o365-purge-compliance-search-results':
            encode_and_submit_results(purge_compliance_search(**args))
        elif demisto.command() == 'ews-o365-get-compliance-search-purge-status':
            encode_and_submit_results(check_purge_compliance_search(**args))
        elif demisto.command() == 'ews-o365-remove-compliance-search':
            encode_and_submit_results(remove_compliance_search(**args))


    except Exception, e:
        import time

        time.sleep(2)
        start_logging()
        debug_log = log_stream.getvalue()
        error_message_simple = ""
        error_message = ""

        # Office365 regular maintenance case
        if (isinstance(e, ErrorMailboxStoreUnavailable) or isinstance(e, ErrorMailboxMoveInProgress)) and 'outlook.office365.com' in EWS_SERVER:
            log_message = "Office365 is undergoing load balancing operations. As a result, the service is temporarily unavailable."
            if demisto.command() == 'fetch-incidents':
                demisto.info(log_message)
                demisto.incidents([])
                sys.exit(0)
            if IS_TEST_MODULE:
                demisto.results(log_message + " Please retry the instance configuration test.")
                sys.exit(0)
            error_message_simple = log_message + " Please retry your request."

        # Other exception handling
        if "Status code: 401" in debug_log:
            error_message_simple = "Got unauthorized from the server. " \
                            "Check credentials are correct and authentication method are supported. "

            error_message_simple += "You can try using 'domain\\username' as username for authentication. " if AUTH_METHOD_STR.lower() == 'ntlm' else ''
        if "Status code: 503" in debug_log:
            error_message_simple = "Got timeout from the server. " \
                            "Probably the server is not reachable with the current settings. " \
                            "Check proxy parameter. If you are using server URL - change to server IP address. "

        if not error_message_simple:
            error_message = error_message_simple = e.message
        else:
            error_message = error_message_simple + "\n" + e.message

        stacktrace = traceback.format_exc()
        if stacktrace:
            error_message += "\nFull stacktrace:\n" + stacktrace

        if debug_log:
            error_message += "\nFull debug log:\n" + debug_log

        if demisto.command() == 'fetch-incidents':
            raise
        if IS_TEST_MODULE:
            demisto.results(error_message_simple)
        else:
            demisto.results({ "Type": entryTypes["error"], "ContentsFormat": formats["text"], "Contents": error_message_simple })
        demisto.error("%s: %s" % (e.__class__.__name__, error_message))
  type: python
  commands:
  - name: ews-get-attachment
    arguments:
    - name: item-id
      required: true
      description: The ID of the email message to get the attachments.
    - name: target-mailbox
      description: The mailbox where this attachment was found. Use the default mailbox
        if empty, otherwise user might has to be with impersonation rights to this
        mailbox.
    - name: attachment-ids
      description: The attachments ids to get. If none - all attachments will be retrieve
        from the message. Support multiple attachments with comma-separated value
        or array.
      isArray: true
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The attachment ID. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: The attachment name. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentSHA256
      description: The attached file SHA256.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentLastModifiedTime
      description: The attachment last modified time. Used for file attachments only.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeCreated
      description: The attached email created time.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeReceived
      description: The attached email received time.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeSent
      description: The attached email sent time.
      type: date
    - contextPath: EWS.Items.ItemAttachments.receivedBy
      description: The attached email received by address.
      type: string
    - contextPath: EWS.Items.ItemAttachments.subject
      description: The attached email subject.
      type: string
    - contextPath: EWS.Items.ItemAttachments.textBody
      description: The attached email body (as text).
      type: string
    - contextPath: EWS.Items.ItemAttachments.headers
      description: The attached email headers.
    - contextPath: EWS.Items.ItemAttachments.hasAttachments
      description: Is attached email has attachments?
      type: boolean
    - contextPath: EWS.Items.ItemAttachments.itemId
      description: The attached email item id.
      type: string
    - contextPath: EWS.Items.ItemAttachments.toRecipients
      description: The attached email to recipients addresses (list)
    - contextPath: EWS.Items.ItemAttachments.body
      description: The attached email body (as HTML).
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentSHA256
      description: The attached email SHA256 (as EML file).
      type: string
    - contextPath: EWS.Items.ItemAttachments.FileAttachments.attachmentSHA256
      description: SHA256 of the attached files inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.ItemAttachments.attachmentSHA256
      description: SHA256 of the attached emails inside of the attached email.
      type: string
    description: Get the actual attachments from an item (email message). Usually
      use only item-id argument to get all the attachment of a message.
  - name: ews-delete-attachment
    arguments:
    - name: item-id
      required: true
      description: The ID of the email message to get the attachments.
    - name: target-mailbox
      description: The mailbox where this attachment was found. Use the default mailbox
        if empty, otherwise user might has to be with impersonation rights to this
        mailbox.
    - name: attachment-ids
      description: The attachment id to delete. If none - all attachments will be
        delete from the message. Support multiple attachments with comma-separated
        value or array.
      isArray: true
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The id of the deleted attachment in case of file attachment.
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: The id of the deleted attachment in case of other attachment (like
        "email").
      type: string
    - contextPath: EWS.Items.FileAttachments.action
      description: 'The deletion action in case of file attachment, constant value:
        ''deleted''.'
      type: string
    - contextPath: EWS.Items.ItemAttachments.action
      description: 'The deletion action in case of other attachment (like "email"),
        constant value: ''deleted''.'
      type: string
    description: Delete attachments for an item (email message).
  - name: ews-get-searchable-mailboxes
    arguments: []
    outputs:
    - contextPath: EWS.Mailboxes.mailbox
      description: Searchable mailboxes addresses.
      type: string
    - contextPath: EWS.Mailboxes.mailboxId
      description: Searchable mailboxes ids.
      type: string
    - contextPath: EWS.Mailboxes.displayName
      description: Searchable mailboxes - display name of the email.
      type: string
    - contextPath: EWS.Mailboxes.isExternal
      description: Searchable mailboxes - is mailbox external?
      type: boolean
    - contextPath: EWS.Mailboxes.externalEmailAddress
      description: Searchable mailboxes - external email address.
      type: string
    description: Get searchable mailboxes. Notice that this command requires eDiscovery
      permissions to the exchange - read EWSv2 documentation for more information.
  - name: ews-search-mailboxes
    arguments:
    - name: filter
      required: true
      description: The filter query to search.
    - name: mailbox-search-scope
      description: The mailboxes ids to search for. If empty - search in all searchable
        mailboxes.
      isArray: true
    - name: limit
      description: Maximum number of results.
      defaultValue: "250"
    - name: email_addresses
      description: Email addresses - support comma separated values or array.
      isArray: true
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item id.
      type: string
    - contextPath: EWS.Items.mailbox
      description: The mailbox address where the item has been found.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject.
      type: string
    - contextPath: EWS.Items.toRecipients
      description: Email to recipients addresses (list).
    - contextPath: EWS.Items.sender
      description: Sender email address
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments?
      type: boolean
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time
      type: date
    - contextPath: EWS.Items.datetimeReceived
      description: Email receive time
      type: date
    description: Search over multiple mailboxes or all exchange mailboxes. Use one
      of mailbox-search-scope or email-addresses to search in specific mailboxes.
      Notice that this command requires eDiscovery permissions to the exchange - read
      EWSv2 documentation for more information.
  - name: ews-move-item
    arguments:
    - name: item-id
      required: true
      description: The item id to move.
    - name: target-folder-path
      required: true
      description: The target folder to move the item to. Complex path can be used,
        e.g. Inbox\Phishing.
    - name: target-mailbox
      description: The mailbox to apply the command on.
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Is the target folder a Public Folder?
    outputs:
    - contextPath: EWS.Items.newItemID
      description: The new item id after move.
      type: string
    - contextPath: EWS.Items.messageID
      description: The item message id.
      type: string
    - contextPath: EWS.Items.itemId
      description: The original item id.
      type: string
    - contextPath: EWS.Items.action
      description: The action, value will be 'moved'.
      type: string
    description: Move an item to another folder in the mailbox.
  - name: ews-delete-items
    arguments:
    - name: item-ids
      required: true
      description: The item ids to delete.
    - name: delete-type
      required: true
      description: 'Deletion type, choose one of: trash, soft, hard.'
      defaultValue: soft
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The deleted item id.
      type: string
    - contextPath: EWS.Items.messageId
      description: The deleted message id.
      type: string
    - contextPath: EWS.Items.action
      description: 'The deletion action, one of the following: ''trash-deleted'',
        ''soft-deleted'', ''hard-deleted''.'
      type: string
    description: Delete items from mailbox.
  - name: ews-search-mailbox
    arguments:
    - name: query
      required: true
      description: 'The search query string. Syntax here: https://msdn.microsoft.com/en-us/library/ee693615.aspx'
    - name: folder-path
      description: The folder path to search in. If empty - search over all the folders
        in the mailbox.
      defaultValue: Inbox
    - name: limit
      description: Maximum number of results.
      defaultValue: "100"
    - name: target-mailbox
      description: The mailbox to apply the search on.
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Is the folder a Public Folder?
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item id.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Email received time.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
    - contextPath: EWS.Items.sender
      description: Email sender mail address.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject
      type: string
    - contextPath: EWS.Items.textBody
      description: Email body (as text)
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
    - contextPath: EWS.Items.messageId
      description: Email message id.
      type: string
    - contextPath: EWS.Items.body
      description: Email HTML body.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment id for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment id for item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name for item attachment.
      type: unknown
    description: Search items in a specific mailbox. Notice that a proper permissions
      needed for this operation to search in another target mailbox than the default.
  - name: ews-get-contacts
    arguments:
    - name: target-mailbox
      description: The mailbox to get the contacts from.
    - name: limit
      description: Maximum number of results to fetch
      defaultValue: "100"
    outputs:
    - contextPath: Account.Email.EwsContacts.displayName
      description: The contact name.
    - contextPath: Account.Email.EwsContacts.lastModifiedTime
      description: The contact last modified time.
    - contextPath: Account.Email.EwsContacts.emailAddresses
      description: The contact phone numbers.
    - contextPath: Account.Email.EwsContacts.physicalAddresses
      description: The contact physical addresses.
    - contextPath: Account.Email.EwsContacts.phoneNumbers.phoneNumber
      description: The contact email addresses.
    description: Get contacts for mailbox.
  - name: ews-get-out-of-office
    arguments:
    - name: target-mailbox
      required: true
      description: The mailbox to get out-of-office status.
    outputs:
    - contextPath: Account.Email.OutOfOffice.state
      description: 'Out-of-office state. Result can be: Enabled, Scheduled, Disabled.'
    - contextPath: Account.Email.OutOfOffice.externalAudience
      description: 'Out-of-office external audience. Result can be: None, Known, All.'
    - contextPath: Account.Email.OutOfOffice.start
      description: Out-of-office start date.
    - contextPath: Account.Email.OutOfOffice.end
      description: Out-of-office end date.
    - contextPath: Account.Email.OutOfOffice.internalReply
      description: Out-of-office internal replay.
    - contextPath: Account.Email.OutOfOffice.externalReply
      description: Out-of-office external replay.
    - contextPath: Account.Email.OutOfOffice.mailbox
      description: Out-of-office mailbox.
    description: Get out-of-office status for a mailbox.
  - name: ews-recover-messages
    arguments:
    - name: message-ids
      required: true
      description: The messages ids. Comma-separate value. Usually use the output
        of py-ews-delete-items.
    - name: target-folder-path
      required: true
      description: The folder path to recover the messages to.
      defaultValue: Inbox
    - name: target-mailbox
      description: The mailbox where the messages found. Use the default mailbox if
        empty, otherwise user might has to be with impersonation rights to this mailbox.
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Is the target folder a Public Folder?
    outputs:
    - contextPath: EWS.Items.itemId
      description: The recovered item id.
    - contextPath: EWS.Items.messageId
      description: The recovered message id.
    - contextPath: EWS.Items.action
      description: The value will be 'recovered'.
    description: Recover messages that has beed soft-deleted.
  - name: ews-create-folder
    arguments:
    - name: new-folder-name
      required: true
      description: The new folder name.
    - name: folder-path
      required: true
      description: Path to locate the new folder. Exchange folder ID is also supported.
      defaultValue: Inbox
    - name: target-mailbox
      description: The mailbox.
    description: Create a new folder in a mailbox.
  - name: ews-mark-item-as-junk
    arguments:
    - name: item-id
      required: true
      description: The item id to mark as junk.
    - name: move-items
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Move the item from the original folder to junk folder.
      defaultValue: "yes"
    - name: target-mailbox
      description: 'Use the default mailbox if empty, otherwise user might has to
        be with impersonation rights to this mailbox. '
    description: 'Mark an item as junk - usually use to block an email address, as
      described here: https://msdn.microsoft.com/en-us/library/office/dn481311(v=exchg.150).aspx'
  - name: ews-find-folders
    arguments:
    - name: target-mailbox
      description: The mailbox to apply the command on.
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Find Public Folders
    outputs:
    - contextPath: EWS.Folders.name
      description: Folder name
      type: string
    - contextPath: EWS.Folders.id
      description: Folder id
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Number of items in folder
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread items in folder
      type: number
    - contextPath: EWS.Folders.changeKey
      description: Folder change key
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders
      type: number
    description: Get folders information for a mailbox. Only folders with read permissions
      will be return as a result. Notice that your visual folders on the mailbox (like
      Inbox, etc) is under the folder "Top of Information Store".
  - name: ews-get-items-from-folder
    arguments:
    - name: folder-path
      required: true
      description: The folder path to get the items from.
    - name: limit
      description: Maximum number of items to fetch.
      defaultValue: "100"
    - name: target-mailbox
      description: The mailbox to apply the command on.
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Is the folder a Public Folder?
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item id.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Email received time.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
    - contextPath: EWS.Items.sender
      description: Email sender mail address.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject
      type: string
    - contextPath: EWS.Items.textBody
      description: Email body (as text)
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
    - contextPath: EWS.Items.messageId
      description: Email message id.
      type: string
    - contextPath: EWS.Items.body
      description: Email HTML body.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment id for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment id for item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name for item attachment.
      type: unknown
    description: Get items from a specific folder in a mailbox. The items will return
      order by created time, first item is the most recent item.
  - name: ews-get-items
    arguments:
    - name: item-ids
      required: true
      description: The item ids. List or comma-separated value are supported.
      isArray: true
    - name: target-mailbox
      description: The mailbox to apply the command on.
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item id.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Does email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Email received time.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Email sent time.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
    - contextPath: EWS.Items.sender
      description: Email sender mail address.
      type: string
    - contextPath: EWS.Items.subject
      description: Email subject
      type: string
    - contextPath: EWS.Items.textBody
      description: Email body (as text)
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
    - contextPath: EWS.Items.messageId
      description: Email message id.
      type: string
    - contextPath: EWS.Items.body
      description: Email HTML body.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment id for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment id for item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name for file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name for item attachment.
      type: unknown
    description: Get items by id.
  - name: ews-move-item-between-mailboxes
    arguments:
    - name: item-id
      required: true
      description: The item id to move.
    - name: destination-folder-path
      required: true
      description: The folder in the destination mailbox to move the item to. Complex
        path can be used, e.g. Inbox\Phishing.
    - name: destination-mailbox
      required: true
      description: The mailbox to move the item to.
    - name: source-mailbox
      description: The mailbox to move the item from (conventionally called "target-mailbox"
        - the target mailbox to apply the command on).
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Is the destination folder a Public Folder?
    outputs:
    - contextPath: EWS.Items.movedToMailbox
      description: The mailbox that the item was moved to.
      type: string
    - contextPath: EWS.Items.movedToFolder
      description: The folder that the item was moved to.
      type: string
    - contextPath: EWS.Items.action
      description: The action, value will be 'moved'.
      type: string
    description: Move an item from one mailbox to another.
  - name: ews-get-folder
    arguments:
    - name: target-mailbox
      description: The mailbox to apply the search on.
    - name: folder-path
      default: true
      description: The folder path to get. If empty - will get the folder 'AllItems'.
      defaultValue: AllItems
    - name: is-public
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Is the folder a Public Folder?
    outputs:
    - contextPath: EWS.Folders.id
      description: Folder id.
      type: string
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.changeKey
      description: Folder change key
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Total count of emails in the folder.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
    - contextPath: EWS.Folders.unreadCount
      description: Unread emails in the folder.
      type: number
    description: Get a single specific folder.
  - name: ews-o365-start-compliance-search
    arguments:
    - name: query
      required: true
      default: true
      description: Query to use for finding mails
    outputs:
    - contextPath: EWS.ComplianceSearch.Name
      description: The name of the compliance search
      type: string
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search
      type: string
    description: Start compliance search
  - name: ews-o365-get-compliance-search
    arguments:
    - name: search-name
      required: true
      default: true
      description: Name of the compliance search
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search
    description: Get compliance search status and results
  - name: ews-o365-purge-compliance-search-results
    arguments:
    - name: search-name
      required: true
      default: true
      description: Name of the compliance search
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search
      type: string
    description: Purges the results found by the compliance search
  - name: ews-o365-remove-compliance-search
    arguments:
    - name: search-name
      required: true
      default: true
      description: Name of the compliance search
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search
      type: string
    description: Remove the compliance search
  - name: ews-o365-get-compliance-search-purge-status
    arguments:
    - name: search-name
      required: true
      default: true
      description: Name of the compliance search
    outputs:
    - contextPath: EWS.ComplianceSearch.Status
      description: The status of the compliance search
    description: Check the status of the purge operation on the compliance search.
  dockerimage: demisto/py-ews:2.0
  isfetch: true
  runonce: false
releaseNotes: "-"
tests:
  - pyEWS_Test
