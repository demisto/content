commonfields:
  id: Palo Alto Minemeld
  version: -1
name: Palo Alto Minemeld
display: Palo Alto Minemeld
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: MineMeld streamlines the aggregation, enforcement and sharing of threat
  intelligence.
detaileddescription: |-
  There are 2 list types, each list type holds the names of the miners(lists) that are accounted as threat intel lists (blacklist, whitelist)
  Each list type represents different DbotScore on Demisto.
  Blacklist - if indicator is found in one of the blacklists then the indicator will get DbotScore  3, which is considered malicious in Demisto.
  Whitelist - if indicator is found in one of the whitelists then the indicator will get DbotScore 1 which is considered good in Demisto.
  If indicator is not found in any list, it will get DbotScore of 0 - unknown severity.
configuration:
- display: MineMeld url e.g.(https://192.0.0.1/)
  name: url
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Blacklist names e.g.(BlackListIPv4, BlackListURL,Malicious)
  name: blacklist
  defaultvalue: ""
  type: 0
  required: false
- display: Whitelist names e.g.(wlWhiteListIPv4,wlWhiteListDomain,Unmalicious)
  name: whitelist
  defaultvalue: ""
  type: 0
  required: false
- display: Use system proxy
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |+
    import logging
    import argparse
    import urllib2
    import json
    import base64
    import ssl
    import os.path
    import os
    import sys
    import time
    import re
    from urlparse import urljoin

    # globals and constants
    IPV4_CLASS = 'minemeld.ft.local.YamlIPv4FT'
    IPV6_CLASS = 'minemeld.ft.local.YamlIPv6FT'
    URL_CLASS = 'minemeld.ft.local.YamlURLFT'
    DOMAIN_CLASS = 'minemeld.ft.local.YamlDomainFT'
    LOCALDB_CLASS = 'minemeld.ft.localdb.Miner'
    SUPPORTED_MINER_CLASSES = [IPV4_CLASS,IPV6_CLASS,URL_CLASS,DOMAIN_CLASS,LOCALDB_CLASS]
    SERVER_URL = demisto.params()['url']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    USE_PROXY = demisto.params()['proxy']
    WHITELISTS = []
    BLACKLISTS = []
    WHITELISTS = argToList(demisto.params().get('whitelist'))
    BLACKLISTS = argToList(demisto.params().get('blacklist'))

    if not USE_PROXY:
        os.environ['NO_PROXY'] = SERVER_URL
    if not isinstance(WHITELISTS, (list)) or not isinstance(BLACKLISTS, (list)):
        return_error('Either blacklist or whitelist params were misconfigured - expecting comma seperated list, ex: miner_a,miner_b,miner_c')

    # API class
    class APIClient(object):

        def __init__(self, url, username, password, capath):
            self.url = url
            self.username = username
            self.password = password

            self.cafile = None
            self.capath = None
            self.context = None
            self.data_file_type = None

            if capath is None:
                self.context = ssl.create_default_context()
                self.context.check_hostname = False
                self.context.verify_mode = ssl.CERT_NONE
            else:
                if os.path.isfile(capath):
                    self.cafile = capath
                elif os.path.isdir(capath):
                    self.capath = capath
                else:
                    return_error('CA path should be a file or a directory: {}'.format(capath))


        def _call_api(self, uri, data=None, headers=None, method=None):
            if headers is None:
                headers = {}

            api_url = urljoin(self.url, uri)
            api_request = urllib2.Request(api_url, headers=headers)
            basic_authorization = base64.b64encode('{}:{}'.format(self.username, self.password))
            api_request.add_header(
                'Authorization',
                'Basic {}'.format(basic_authorization)
            )

            if method is not None:
                api_request.get_method = lambda: method

            try:
                result = urllib2.urlopen(
                    api_request,
                    data=data,
                    timeout=30,
                    capath=self.capath,
                    cafile=self.cafile,
                    context=self.context
                )
                content = result.read()
                result.close()

            except urllib2.HTTPError, e:
                demisto.debug(json.dumps(e))
                if e.code != 400:
                    raise
                content = '{ "result":[] }'

            return content


        def get_all_nodes(self):
            content = self._call_api('/status/minemeld')
            minemeld_status = json.loads(content)['result']

            return minemeld_status


        def validate_miner(self, miner):
            content = self._call_api('/status/minemeld')
            minemeld_status = json.loads(content)['result']

            for node in minemeld_status:
                if node['name'] == miner:
                    if not node['class'] in SUPPORTED_MINER_CLASSES:
                        return_error('Unsupported miner class of type: {}'.format(node['class']))
                    self.data_file_type = 'localdb' if node['class'] == LOCALDB_CLASS else 'yaml'
                    return True

            return_error('Miner {} was not found in miners list'.format(miner))
            return False


        def retrieve_miner(self, miner):
            content = self._call_api('/config/data/{}_indicators?t={}'.format(miner, self.data_file_type))
            return json.loads(content)['result']


        def upload(self, miner, data):
            if self.data_file_type == 'localdb':
                ts = time.time()
                self._call_api(
                    '/config/data/{}_indicators/append?_{}&h={}&t={}'.format(miner, ts, miner, self.data_file_type),
                    data = data,
                    headers = { 'Content-Type': 'application/json' },
                    method = 'POST'
                )
                return

            self._call_api(
                '/config/data/{}_indicators?h={}'.format(miner, miner),
                data = data,
                headers = { 'Content-Type': 'application/json' },
                method = 'PUT'
            )

    #system funcs
    def get_miner_list(MineMeldClient, miner, type_=False):
        MineMeldClient.validate_miner(miner)
        miner_list = MineMeldClient.retrieve_miner(miner)
        return miner_list


    def add_indicator_to_miner(MineMeldClient, miner, indicators, type_, comment=''):
        miner_list = get_miner_list(MineMeldClient, miner)
        updated_miner_list = {
            e['indicator']: json.dumps(e, sort_keys=True) for e in miner_list
        }
        request_params = {}

        if not isinstance(indicators, list):
            indicators = indicators.split(',')

        if type_ is False:
            type_ = ''

        for indicator in indicators:
                if MineMeldClient.data_file_type == 'localdb':
                    request_params = {
                        'indicator': indicator,
                        'comment': comment,
                        'type': type_,
                        'ttl': 'disabled'
                    }
                else:
                    request_params = {
                        'indicator': indicator,
                        'comment': comment
                    }
                updated_miner_list[indicator] = json.dumps(request_params)

        MineMeldClient.upload(miner, '[{}]'.format(','.join(updated_miner_list.values())))


    def remove_indicator_from_miner(MineMeldClient, miner, indicators):
        miner_list = get_miner_list(MineMeldClient, miner)
        updated_miner_list = {
            e['indicator']: json.dumps(e, sort_keys=True) for e in miner_list
        }
        request_params = {}

        if not isinstance(indicators, list):
            indicators = indicators.split(',')

        if MineMeldClient.data_file_type == 'localdb':
            # check that all indicators to remove are on localdb miner
            miner_list_indicators = [o['indicator'] for o in miner_list]
            contain_all_indicators =  all(elem in miner_list_indicators for elem in indicators)
            if not contain_all_indicators:
                return_error('Did not find all indicators on miner'.format(miner))

            for indicator in indicators:
                request_params = {
                    'indicator': indicator,
                    'type': json.loads(updated_miner_list[indicator])['type'],
                    'ttl': -1
                }
                updated_miner_list = { indicator: json.dumps(request_params) }
        else:
            # remove indicator from miner, if nothing was removed, indicator not on miner
            for indicator in indicators:
                indicator_from_list = updated_miner_list.pop(indicator, None)
                if not indicator_from_list:
                    return_error('Did not find indicator on miner'.format(indicator, miner))

        MineMeldClient.upload(miner, '[{}]'.format(','.join(updated_miner_list.values())))


    def get_indicators_from_miner(miner_name,indicator_value=False):
        result_indicator = []
        miner_list = get_miner_list(MineMeldClient, miner_name)
        for indicator in miner_list:
            if indicator['indicator'] == indicator_value or indicator_value is False :
                indicator['miner'] = miner_name
                result_indicator.append(indicator)

        return result_indicator


    def get_indicator_type(indicator):
        indicator_type = ''

        if not indicator_type:
            url = re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', indicator) # guardrails-disable-line
            if url:
                indicator_type = 'URL'

        if not indicator_type:
            ipv4 = re.findall('^(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$', indicator)
            if ipv4 and not indicator_type:
                indicator_type = 'IPv4'

        if not indicator_type:
            ipv6 = re.findall('^(?:(?:[0-9A-Fa-f]{1,4}:){6}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::(?:[0-9A-Fa-f]{1,4}:){5}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){4}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){3}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){2}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(?:(?:[0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)$', indicator)
            if ipv6:
                indicator_type = 'IPv6'

        if not indicator_type:
            file = get_hash_type(indicator)
            if file != 'Unknown':
                indicator_type = file

        return indicator_type



    #commands
    def domain():
        domain = demisto.args()['domain']
        #output vars
        result_indicator = []
        miner_name = ''
        dbotscore = 0
        indicator_context_data = {}
        entry_context = {}

        # search for indicator in all miners defined by user
        for blacklist in BLACKLISTS:
            result_indicator = get_indicators_from_miner(blacklist,domain)
            if result_indicator:
                dbotscore = 3
                break
        if dbotscore != 3:
            for whitelist in WHITELISTS:
                result_indicator = get_indicators_from_miner(whitelist,domain)
                if result_indicator:
                    dbotscore = 1
                    break

        # start building output and context
        dbotscore_list = {
            'Indicator': domain,
            'Type': 'domain',
            'Vendor': 'Palo Alto MineMeld',
            'Score': dbotscore
        }

        if result_indicator:
            miner_name = result_indicator[0]['miner']
            # add only malicious to context
            if dbotscore ==3:
                indicator_context_data = {
                    'MineMeld': {
                        'Indicators': result_indicator
                    },
                    'Malicious': {
                        'Vendor': 'Palo Alto MineMeld',
                        'Description': 'Indicator was found in MineMeld\'s blacklist: {}'.format(miner_name)
                    },
                    'Name': domain
                }
            else:
                indicator_context_data = {
                    'MineMeld': {
                        'Miner': { 'name': miner_name } ,
                        'Indicators': result_indicator
                    },
                    'Name': domain
                }

            entry_context = {
                'DBotScore': dbotscore_list,
                outputPaths['domain']:  indicator_context_data,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }
            result_text = 'MineMeld Domain found at miner: {}'.format(miner_name)
        else:
            result_text = 'MineMeld Domain severity - unknown'
            entry_context = {
                'DBotScore': dbotscore_list,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': result_indicator,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(result_text, result_indicator, ['indicator', 'type', 'comment']),
            'EntryContext': entry_context
        })


    def url():
        url = demisto.args()['url']
        #output vars
        result_indicator = []
        miner_name = ''
        dbotscore = 0
        indicator_context_data = {}
        entry_context = {}

        # search for indicator in all miners defined by user
        for blacklist in BLACKLISTS:
            result_indicator = get_indicators_from_miner(blacklist,url)
            if result_indicator:
                dbotscore = 3
                break
        if dbotscore != 3:
            for whitelist in WHITELISTS:
                result_indicator = get_indicators_from_miner(whitelist,url)
                if result_indicator:
                    dbotscore = 1
                    break

        # start building output and context
        dbotscore_list = {
            'Indicator': url,
            'Type': 'url',
            'Vendor': 'Palo Alto MineMeld',
            'Score': dbotscore
        }

        if result_indicator:
            miner_name = result_indicator[0]['miner']
            # add only malicious to context
            if dbotscore ==3:
                indicator_context_data = {
                    'MineMeld': {
                        'Indicators': result_indicator
                    },
                    'Malicious': {
                        'Vendor': 'Palo Alto MineMeld',
                        'Description': 'Indicator was found in MineMeld\'s blacklist: {}'.format(miner_name)
                    },
                    'Data': url
                }
            else:
                indicator_context_data = {
                    'MineMeld': {
                        'Miner': { 'name': miner_name } ,
                        'Indicators': result_indicator
                    },
                    'Data': url
                }

            entry_context = {
                'DBotScore': dbotscore_list,
                outputPaths['url']:  indicator_context_data,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }
            result_text = 'MineMeld URL found at miner: {}'.format(miner_name)
        else:
            result_text = 'MineMeld URL severity - unknown'
            entry_context = {
                'DBotScore': dbotscore_list,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': result_indicator,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(result_text, result_indicator, ['indicator', 'type', 'comment']),
            'EntryContext': entry_context
        })


    def file():
        file = demisto.args()['file']
        #output vars
        result_indicator = []
        miner_name = ''
        dbotscore = 0
        indicator_context_data = {}
        entry_context = {}

        # search for indicator in all miners defined by user
        for blacklist in BLACKLISTS:
            result_indicator = get_indicators_from_miner(blacklist,file)
            if result_indicator:
                dbotscore = 3
                break
        if dbotscore != 3:
            for whitelist in WHITELISTS:
                result_indicator = get_indicators_from_miner(whitelist,file)
                if result_indicator:
                    dbotscore = 1
                    break

        # start building output and context
        dbotscore_list = {
            'Indicator': file,
            'Type': 'hash',
            'Vendor': 'Palo Alto MineMeld',
            'Score': dbotscore
        }

        if result_indicator:
            miner_name = result_indicator[0]['miner']
            # add only malicious to context
            if dbotscore ==3:
                indicator_context_data = {
                    'MineMeld': {
                        'Indicators': result_indicator
                    },
                    'Malicious': {
                        'Vendor': 'Palo Alto MineMeld',
                        'Description': 'Indicator was found in MineMeld\'s blacklist: {}'.format(miner_name)
                    },
                    get_hash_type(file): file
                }
            else:
                indicator_context_data = {
                    'MineMeld': {
                        'Miner': { 'name': miner_name } ,
                        'Indicators': result_indicator
                    },
                    get_hash_type(file): file
                }

            entry_context = {
                'DBotScore': dbotscore_list,
                outputPaths['file']:  indicator_context_data,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }
            result_text = 'MineMeld File found at miner: {}'.format(miner_name)
        else:
            result_text = 'MineMeld File severity - unknown'
            entry_context = {
                'DBotScore': dbotscore_list,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': result_indicator,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(result_text, result_indicator, ['indicator', 'type', 'comment']),
            'EntryContext': entry_context
        })


    def ip():
        ip = demisto.args()['ip']
        #output vars
        result_indicator = []
        miner_name = ''
        dbotscore = 0
        indicator_context_data = {}
        entry_context = {}

        # search for indicator in all miners defined by user
        for blacklist in BLACKLISTS:
            result_indicator = get_indicators_from_miner(blacklist,ip)
            if result_indicator:
                dbotscore = 3
                break
        if dbotscore != 3:
            for whitelist in WHITELISTS:
                result_indicator = get_indicators_from_miner(whitelist,ip)
                if result_indicator:
                    dbotscore = 1
                    break

        # start building output and context
        dbotscore_list = {
            'Indicator': ip,
            'Type': 'ip',
            'Vendor': 'Palo Alto MineMeld',
            'Score': dbotscore
        }

        if result_indicator:
            miner_name = result_indicator[0]['miner']
            # add only malicious to context
            if dbotscore ==3:
                indicator_context_data = {
                    'MineMeld': {
                        'Indicators': result_indicator
                    },
                    'Malicious': {
                        'Vendor': 'Palo Alto MineMeld',
                        'Description': 'Indicator was found in MineMeld\'s blacklist: {}'.format(miner_name)
                    },
                    'Address': ip
                }
            else:
                indicator_context_data = {
                    'MineMeld': {
                        'Miner': { 'name': miner_name } ,
                        'Indicators': result_indicator
                    },
                    'Address': ip
                }

            entry_context = {
                'DBotScore': dbotscore_list,
                outputPaths['ip']: indicator_context_data,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }
            result_text = 'MineMeld IP found at miner: {}'.format(miner_name)
        else:
            result_text = 'MineMeld IP severity - unknown'
            entry_context = {
                'DBotScore': dbotscore_list,
                'MineMeld.Indicators(val.indicator == obj.indicator)': result_indicator,
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': result_indicator,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(result_text, result_indicator, ['indicator', 'type', 'comment']),
            'EntryContext': entry_context
        })


    def get_all_miner_names():
        miners_list = MineMeldClient.get_all_nodes()
        supported_miners = []

        for miner in miners_list:
            if miner['class'] in SUPPORTED_MINER_CLASSES:
                supported_miners.append({
                    'name': miner['name'],
                    'indicators': miner['length'],
                    'class': miner['class']
                })

        if supported_miners:
            result_text = 'Miners found: '
        else:
            result_text = 'No miners found'

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': supported_miners,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(result_text, supported_miners, ['name','indicators','class']),
            'EntryContext': {
                'MineMeld.Miner(val.name == obj.name)': supported_miners
            }
        })

    def get_indicator_from_miner():
        miner_name = demisto.args()['miner']
        indicator = demisto.args()['indicator']
        supported_miners = []

        supported_miners = get_indicators_from_miner(miner_name, indicator)

        if supported_miners:
            result_text = 'Items found at miner: {}'.format(miner_name)
        else:
            result_text = 'No items found at miner'

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': supported_miners,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(result_text, supported_miners, ['indicator', 'type', 'comment']),
            'EntryContext': {
                'MineMeld.Miner(val.name == obj.name)': { 'name': miner_name },
                'MineMeld.Indicators(val.miner == obj.miner && val.indicator == obj.indicator)': supported_miners
            }
        })


    def retrieve_miner_indicators():
        miner_name = demisto.args()['miner']
        result_list = []
        markdown_headers = ['indicator', 'comment', 'type']
        miners_context = []

        if miner_name == 'all':
            markdown_headers.insert(0, 'miner')
            miner_name = 'all miners'
            miners_list = MineMeldClient.get_all_nodes()

            for miner in miners_list:
                if miner['class'] in SUPPORTED_MINER_CLASSES:
                    miners_context.append(
                        {
                            'name': miner['name'],
                            'class': miner['class']
                        }
                    )
                    miner_list =  get_indicators_from_miner(miner['name'])
                    result_list.extend(miner_list)

        else:
            result_list = get_indicators_from_miner(miner_name)
            miners_context = { 'name': miner_name }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': result_list,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Minemeld indicators {}'.format(miner_name), result_list, markdown_headers),
            'EntryContext': {
                'MineMeld.Miner(val.name == obj.name)': miners_context,
                'MineMeld.Indicators(val.miner == obj.miner && val.indicator == obj.indicator)': result_list
            }
        })


    def update_miner():
        miner = demisto.args()['miner']
        indicator = demisto.args()['indicator']
        type_ = demisto.args().get('type',get_indicator_type(indicator))
        comment = demisto.args().get('comment','')

        if ' ' in indicator:
            return_error("Don't use space in indicator")

        if demisto.command() == 'minemeld-add-to-miner':
            add_indicator_to_miner(MineMeldClient, miner, indicator, type_, comment)
        elif demisto.command() == 'minemeld-remove-from-miner':
            remove_indicator_from_miner(MineMeldClient, miner, indicator)

        demisto.results('Performed action successfully')


    def test():
        if MineMeldClient.get_all_nodes():
            demisto.results('ok')

    #code starts here

    MineMeldClient = APIClient(
        url=SERVER_URL,
        username=USERNAME,
        password=PASSWORD,
        capath=None
    )

    if demisto.command() == 'test-module':
        test()
    elif demisto.command() == 'minemeld-add-to-miner' or demisto.command() == 'minemeld-remove-from-miner':
        update_miner()
    elif demisto.command() == 'minemeld-retrieve-miner':
        retrieve_miner_indicators()
    elif demisto.command() == 'minemeld-get-indicator-from-miner':
        get_indicator_from_miner()
    elif demisto.command() == 'minemeld-get-all-miners-names':
        get_all_miner_names()
    elif demisto.command() == 'domain':
        domain()
    elif demisto.command() == 'url':
        url()
    elif demisto.command() == 'file':
        file()
    elif demisto.command() == 'ip':
        ip()

  type: python
  commands:
  - name: minemeld-add-to-miner
    arguments:
    - name: miner
      required: true
      description: Miner name - you can get it under Nodes page on Minemeld UI (nodes
        of type "miner").
    - name: indicator
      required: true
      description: The indicator's value to add. Support list \ comma-separated values.
      isArray: true
    - name: comment
      description: Comment for the indicator.
    description: Add indicator to a miner.
  - name: minemeld-remove-from-miner
    arguments:
    - name: miner
      required: true
      description: Miner name - you can get it under Nodes page on Minemeld UI (nodes
        of type "miner").
    - name: indicator
      required: true
      description: The value of the indicator  to remove.
    description: Remove an indicator from a miner.
  - name: minemeld-retrieve-miner
    arguments:
    - name: miner
      required: true
      description: Miner name, value 'all' for all miners indicators
    outputs:
    - contextPath: MineMeld.Miner
      description: Entire miner object
      type: unknown
    - contextPath: MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: MineMeld.Miner.class
      description: Miner class
      type: string
    - contextPath: MineMeld.Indicators
      description: Entire indicator object
    - contextPath: MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    description: Get miner's indicators list.
  - name: minemeld-get-indicator-from-miner
    arguments:
    - name: miner
      required: true
      description: Miner name
    - name: indicator
      required: true
      description: Indicator details
    outputs:
    - contextPath: MineMeld.Miner
      description: Entire miner object
    - contextPath: MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: MineMeld.Indicators
      description: Entire indicator object
      type: unknown
    - contextPath: MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    description: Get indicator from a miner's list
  - name: ip
    arguments:
    - name: ip
      required: true
      description: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.MineMeld.Indicators
      description: Entire indicator object
    - contextPath: IP.MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: IP.MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: IP.MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: IP.MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: IP.MineMeld.Miner
      description: Entire miner object
      type: unknown
    - contextPath: IP.MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: MineMeld.Indicators
      description: Entire indicator object
    - contextPath: MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: MineMeld.Miner
      description: Entire miner object
    - contextPath: MineMeld.Miner.name
      description: Miner name
      type: string
    description: Search for ip on miners
  - name: file
    arguments:
    - name: file
      required: true
      description: file
    outputs:
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
      type: string
    - contextPath: File.MineMeld.Indicators
      description: Entire indicator object
    - contextPath: File.MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: File.MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: File.MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: File.MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: File.MineMeld.Miner
      description: Entire miner object
      type: unknown
    - contextPath: File.MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: MineMeld.Indicators
      description: Entire indicator object
    - contextPath: MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: MineMeld.Miner
      description: Entire miner object
    - contextPath: MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    description: Search for file on lists
  - name: domain
    arguments:
    - name: domain
      required: true
      description: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: Domain.Malicious.Vendor
      description: For malicious Domains, the vendor that made the decision
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious Domains, the reason for the vendor to make the decision
      type: string
    - contextPath: Domain.Name
      description: Domain's name (value)
      type: string
    - contextPath: Domain.MineMeld.Indicators
      description: Entire indicator object
    - contextPath: Domain.MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: Domain.MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: Domain.MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: Domain.MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: Domain.MineMeld.Miner
      description: Entire miner object
      type: unknown
    - contextPath: Domain.MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: MineMeld.Indicators
      description: Entire indicator object
    - contextPath: MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: MineMeld.Miner
      description: Entire miner object
    - contextPath: MineMeld.Miner.name
      description: Miner name
      type: string
    description: Search for domain on lists
  - name: url
    arguments:
    - name: url
      required: true
      description: url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
      type: string
    - contextPath: URL.Data
      description: URL's data (value)
      type: string
    - contextPath: URL.MineMeld.Indicators
      description: Entire indicator object
    - contextPath: URL.MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: URL.MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: URL.MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: URL.MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: URL.MineMeld.Miner
      description: Entire miner object
      type: unknown
    - contextPath: URL.MineMeld.Miner.name
      description: Miner name
      type: string
    - contextPath: MineMeld.Indicators
      description: Entire indicator object
    - contextPath: MineMeld.Indicators.indicator
      description: Indicator's value
      type: string
    - contextPath: MineMeld.Indicators.miner
      description: Indicator's miner
      type: string
    - contextPath: MineMeld.Indicators.type
      description: Indicator type
      type: string
    - contextPath: MineMeld.Indicators.comment
      description: Indicator's comment
      type: string
    - contextPath: MineMeld.Miner
      description: Entire miner object
    - contextPath: MineMeld.Miner.name
      description: Miner name
      type: string
    description: Search for url on lists
  - name: minemeld-get-all-miners-names
    arguments: []
    outputs:
    - contextPath: MineMeld.Miner
      description: Entire miner object
      type: unknown
    - contextPath: MineMeld.Miner.name
      description: Miner's name
      type: string
    - contextPath: MineMeld.Miner.class
      description: Miner's class
      type: string
    - contextPath: MineMeld.Miner.indicators
      description: Amount of miner's indicators
      type: string
    description: Returns all miners names (with supported classes of custom indicators
      lists)
  runonce: false
releaseNotes: "Added validation of deleting indictors from miners of type localDB"
tests:
  - minemeld_test