commonfields:
  id: Attivo Botsink
  version: -1
name: Attivo Botsink
display: Attivo Botsink
category: Deception
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKIAAABLCAMAAADEZ6xjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjkzREQ4NEM1MzkxMTFFNkFBNUJBNjYwQjczNjgyMzIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjkzREQ4NEQ1MzkxMTFFNkFBNUJBNjYwQjczNjgyMzIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyOTNERDg0QTUzOTExMUU2QUE1QkE2NjBCNzM2ODIzMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyOTNERDg0QjUzOTExMUU2QUE1QkE2NjBCNzM2ODIzMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj0B2NAAAAMAUExURf6WU11dYf/r3jY8RJGRlXl5fMzNztzd3m1yd/7StXFxdf/59bGytf1tEUxRWB4lLf68ks7P0PDw8GtrbiMpMv18Kf/t4oKGiv6iZ5WVl9DR0o2Qlf6RTP/l1crLzaKipP/x6dLU1URKUf16Jf6teIqKjZqbnf/8+p6foa+vsf/28r6+wPr6+3+DiPLy84KChf/dyP6ygv7AmcXHyYqOktXV1oWIjf1yGKurrbm5uurq6qSnq97f4MHBw7a2uP6rdS40PP6aWv2GOpqdof61hv/gzpGUmGRkaP66jpSXmpycnv1xFqCgom5ucru7vNra23V1eHl9gv6dYGNobv7VulZbYdjY2WBgZDxCSXR4fZ+ipejo6P6nbsPDxP/o2RYdJVpaXsnJy/7WvGNjZu7v7/7OrX19gOvr7GpudObm55aanbe5vP2ORuDg4f/cxv2IPVhYXLCwshohKqioquzs7UFGTeTk5f6wftrb3P1sDs7Q0mZmanB0epiYmmZrcOHh4v7Yv/2KQP7GorO2uP/1715iaFpfZf2BMf7En/64i/6jaXN3fP2MQ/2DNYyMjzE3PxEYISsxOf1rDVZWWoiLkMPFx7W1t1tgZoCAg/z8/MrKy/10G/T09VdXW/f39xIZIv39/f/+/bq8v/X19eHi4xMaI//9/KGkp+np6uvs7fj4+Ofn6Pb29qSkpv/7+P7+/uPk5Wxsb/n6+hgfKNjZ2mJnbbS3ufj4+fj5+f7Mq62tr8vMzsHDxv13IU9UWtna2//j0fn5+YWFiOTl5tPT1LW3uiwyOnd7gMDCxbi6vVJXXqeqrcTExY2NkBgeJ3d3ev2ENhQbJFNYX6+xtP/w5ktQV/1uE9fX2MjIyf6ka/11HvT09LK0tvb29ycuNtvc3fv7+/2ALsbIyv7Qsry8vuLj5PHx8VBVW6msrxsiK/62iO/w8Ozt7u3u7v/z7N/g4f/k0lhdY2dna+Xm5/7DnIiIi+Pj48DBxB8mLv7Tt/7KqHZ2ebm7vv6gY6utsf///0JJPWAAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAJZUlEQVR42uyZe1wUxx3AeYixiAoBY44oSFNRgkCIQYWA4gsURSGJQnye0agxqTYmKjYgMYnm0SRu7qdXL4KgKCLg+y3GB9GYxDSJjVLzrPZBmzZNW5o22tZOZ36ztzuzd3t615IPn0+YP3Z/85vd2e/NzO8xc36kzRe/dsR2xHbE/x3x6q2sLG3LiCtsWE6YNL9xVK5XnhUqA84M/G3rI/bihLapblv7Zy1aIynCFl/RK/9RFCVic6sj/kBFHHSHm8ajgYoiIs4urlAExMAKytijtRH7vq4i2r52bRxICUTEX0bQuoD4OWv/SWsj/prR9WSX4a6NPzUgrlVkxAdYPb61Ef0Y3YJB7Hqn14j1nSIyJ7e2uZzvQtnGVt/LEG/1GvFbcTqjcZ7JYXZrerZNIj7H2EJJ57H83gYRF6At30LINXa/3BYRX2RkC6nwILI+1dqIGwaMSMjP77G1Y/8bReyMlvwClapvZ9IwoW1+ZmbmIkSiQuZ+kkiv6AcrWD1zH3tmP5PmMymfSYsrDf0fx0fDnNVvVu5V1NJtXsyNIT6NYxegBZku5/W2NYpYupJmqa7gF7pqo/w2Ktca+u/BlG+q4EVd5R6Wz70RxEcZ16MonkDaP/iK6MAB7mToP5MpB3L57F7FUD5vuD7idMR6mleGM7l7tY+IJAHXxCGp/wH4ZDrKIzSwwsIrqrho7XURlzKqsWr6EIq839Maa2JiYhChmAox6cRBr1tZ/QtWj9lgQCzCjz4j9d+JqS6geIBDRdxdymoxZ2bwFVl0HURuItfUWu9lrObnlUULiOT7TF4pvl3bjanuYeJcPnDvbHO27QtExeJLnhGvyo4Go/WyAF8RJzN5RrPw9oc45mVMLEagVQ698UvOONkz4jBcfRudVQyCtqW+Iiaih9oqvP1XppjHpDSc19VVYt/p+PybDk+IXzUxpGTdSa5n9df7+ohIlnOz0sq2c5ofGoMjdlr+PrfHTZ4QQ3WnyMtUVBz2FfEt9OtvaI1o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
configuration:
- display: Botsink name or address
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: BOTsink API credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Do not verify server SSL
  name: insecure
  defaultvalue: "False"
  type: 8
  required: false
- display: Minimum severity when fetching events (Very High, High, Medium)
  name: fetch_severity
  defaultvalue: High
  type: 0
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |-
    import requests
    import base64
    import socket
    import json
    import datetime
    import time
    import os

    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    server = demisto.params()['server']
    api_user = demisto.params()['credentials']['identifier']
    api_pass = demisto.params()['credentials']['password']
    verify_ssl =  not demisto.params()['insecure']

    class BSAPI:
        BS_DEFAULT_PORT = 8443
        TIMEOUT = 20

        def __init__(self, bs_host, bs_port = BS_DEFAULT_PORT, verify_ssl = False, timeout = TIMEOUT):
            self.bs_host = bs_host
            self.bs_port = bs_port
            self.timeout = timeout
            self.session_key = None
            self.base_url = "https://{host}:{port}/api".format(host=self.bs_host,port=self.bs_port)
            self.verify_ssl = verify_ssl

        def do_request(self, url, data=None, headers=None, files=None, method=None, content_type='application/json', json_dump=True):
            #Guess the method if not provided
            if not method:
                if data: method='post'
                else: method='get'

            headers={}
            if self.session_key: headers = {'sessionKey': self.session_key}
            if content_type: headers['content-type']=content_type

            url = self.base_url + url
            #Convert data dictionary to a string
            if data and json_dump: data = json.dumps(data)

            request_func = getattr(requests, method)
            r = None

            try:
                r = request_func(url,headers=headers,data=data,files=files,verify=self.verify_ssl)
            except requests.exceptions.SSLError as e:
                demisto.error("SSL verification failed")
                demisto.results("SSL verification to {url} failed".format(url=url))
            except requests.exceptions.ConnectionError as e:
                demisto.error("Could not connect to: {server}".format(server=server))
                demisto.error("Exception: {}".format(e))
                demisto.results("Could not connect to {server} ({exception})".format(server=server, exception=e))
            except Exception, e:
                demisto.error("Generic Exception: {exception}".format(exception=e))
                demisto.error("Type is: {type}".format(type=e.__class__.__name__))

            if r is not None and r.content:
               return r.json()
            else:
               return None

        def login(self, bs_user, bs_pass):
            url="/auth/login"
            login_data = {'userName': base64.b64encode(bs_user), 'password':base64.b64encode(bs_pass)}

            login_status = self.do_request(url,data=login_data)
            if login_status and 'sessionKey' in login_status:
                self.session_key = login_status['sessionKey']

            return (login_status)

        def logout(self):
            url = "/auth/logout"
            logout_status = self.do_request(url)
            return (logout_status)

        def deploy_decoys(self,target_ip,vlan=None,decoy_number=1):
            url = "/autodeploy/config"
            if vlan:
               data = {"config": [{"ipAddress":target_ip,"vlanID": vlan, "numberOfIPsToAcquire": decoy_number}]}
            else:
               data = {"config": [{"ipAddress":target_ip,"numberOfIPsToAcquire": decoy_number}]}

            deploy_status = self.do_request(url,data=data,content_type=None)
            return (deploy_status)

        def get_threatdirect_rules(self):
            url="/nwinterfaces/get"
            td_decoys = self.do_request(url)
            return (td_decoys)

        def get_bs_health(self):
            url="/device/health"
            health = self.do_request(url)
            return health

        def get_monitoring_rules(self):
           url = "/interfaces/get"
           monitoring_rules = self.do_request(url,data='{}',method='post',json_dump=None)
           return (monitoring_rules)

        def get_deceptive_objects(self,object_type,object_id):
            if object_type == 'USERS':
                if object_id == 'ALL':
                    url="/obj_group_cfg/summary/user"
                else:
                    url="/obj_group_cfg/user/{object_id}".format(object_id=object_id)
            else:
                response="Unknown option: {object_type}".format(object_type=object_type)
                return (response)

            deceptive_objects = self.do_request(url)
            return (deceptive_objects)

        def get_playbooks(self):
           url='/pb/getAll'
           return self.do_request(url)

        def run_playbook(self,playbook_id,attacker_ip):
           'This simulates an internal playbook execution based on the attacker IP'
           url='/pb/runplaybook'
           data= {'attacker_ip': attacker_ip, 'playbook_id': playbook_id}
           return self.do_request(url,data=data)

        def get_events(self,severity_start=None,severity_end=None,timestampStart=None,timestampEnd=None,
                        offset=None,acknowledged='unacknowledged',attackerIP=[],category=[],
                        device=[],service=[],targetOs=[],targetHost=[],targetIP=[],
                        targetVLAN=[],keywords=[],description=[],comments=[]):

            url="/eventsquery/alerts"

            if attackerIP and attackerIP[0] == None: attackerIP=[]
            if targetIP and targetIP[0] == None: targetIP=[]
            if targetVLAN and targetVLAN[0] == None: targetVLAN=[]

            query_data = {'severity_start':severity_start,'severity_end':severity_end,'timestampStart':timestampStart,
                          'timestampEnd':timestampEnd,'offset':offset,'acknowledged':acknowledged,'attackerIp':attackerIP,
                          'category':category,'device':device,'service':service,'targetOs':targetOs,'targetHost':targetHost,
                          'targetIP':targetIP,'targetVLAN':targetVLAN,'keywords':keywords,'description':description,
                          'comments':comments}

            event_data = self.do_request(url,data=query_data)
            return (event_data)

        def convert_severity_string(self, severity_string):
            conversion = {
                          'VeryHigh': 14,
                          'Very High': 14,
                          'High': 11,
                          'Medium': 7,
                          'Low': 4,
                          'VeryLow': 3,
                          'Very Low': 3,
                          'SystemActivity': 0,
                          'System Activity': 0
                         }
            if severity_string in conversion:
                return conversion[severity_string]
            else:
                return None

        def convert_to_demisto_severity(self,attivo_severity):
            if attivo_severity >= 14:   # Very High
                demisto_severity = 3
            elif attivo_severity >= 11: # High
                demisto_severity = 3
            elif attivo_severity >= 7: # Medium
                demisto_severity = 2
            else:                      # Low
                demisto_severity = 1

            return demisto_severity


    def valid_ip(host):
        try:
            socket.inet_aton(host)
            return True
        except:
            return False

    if demisto.command() == 'attivo-get-events':
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)
        attacker_ip = demisto.args()['attacker_ip']
        hours_back = demisto.args()['hours_back']
        severity_string = demisto.args()['severity']

        timestampEnd = str(int(time.time()) * 1000)
        severity_end = "15"
        severity_start = attivo_api.convert_severity_string(severity_string)
        seconds_back = int(hours_back) * 60 * 60
        timestampStart = str((int(time.time()) - seconds_back) * 1000)
        attacker_ips = []
        attacker_ips.append(attacker_ip)

        events = attivo_api.get_events(severity_start=severity_start, severity_end=severity_end, timestampStart=timestampStart, timestampEnd=timestampEnd, attackerIP=attacker_ips)
        attivo_api.logout()

        if events is None or len(events['eventdata']) == 0:
            demisto.results("There were no matching events retrieved")
        else:
            demisto.results("There were {event_count} events retrieved".format(event_count=len(events['eventdata'])))
            demisto.info("There were {event_count} events retrieved".format(event_count=len(events['eventdata'])))
            brief_events = []
            context = []
            for event in events['eventdata']:
                attack_name = event['attackName']
                severity = event['details']['Severity']
                target_ip = event['details']['Target IP']
                target_os = event['details']['Target OS']
                timestamp = event['details']['Timestamp']
                brief_event = {'Attack Name': attack_name, 'Target IP': target_ip, 'Target OS': target_os, 'timestamp': timestamp}
                brief_events.append(brief_event)
                context.append(event['details'])

            entry = {
                'Type': entryTypes['note'],
                'Contents': brief_events,
                'ContentsFormat': formats['table'],
                'HumanReadable': brief_events,
                'ReadableContentsFormat': formats['table'],
                'EntryContext': {'Attivo.Events.Count': len(events['eventdata']),
                                 'Attivo.Events.List': context}

            }

            demisto.results(entry)

    if demisto.command() == 'fetch-incidents':
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)
        date_pattern = "%Y-%m-%dT%H:%M:%S.%fZ"
        os.environ['TZ']='UTC'
        fetch_severity = demisto.params()['fetch_severity']

        severity_start = attivo_api.convert_severity_string(fetch_severity)
        if not severity_start:
            demisto.info("Attivo fetch-incidents: Unknown severity specified ('{}') using Medium".format(fetch_severity))
            severity_start = 7 # Medium
        severity_end = 15 # Very Hugh

        #demisto.setLastRun({'time': 1542740090000})

        last_run_time = demisto.getLastRun().get('time', None)
        if not last_run_time:
            # When run for the first time, get events from the last week
            # one_week = 7 * 24 * 60 * 60
            one_day = 24 * 60 * 60
            last_run_time = (int(time.time()) - one_day) * 1000

        demisto.info("Attivo fetch-incidents: Last run time {}, severity {}:{}".format(last_run_time, fetch_severity, severity_start))

        new_last_run = 0
        incidents = []

        events = attivo_api.get_events(timestampStart=last_run_time, timestampEnd='now',
                                       severity_start=severity_start, severity_end=severity_end)

        if events and ('eventdata' in events) and (len(events['eventdata']) > 0):
            demisto.info("Total new Attivo incidents to add: {}".format(len(events['eventdata'])))

            for event in events['eventdata']:
                event_date = event['timeStamp']
                #demisto.info('Creating Attivo incident with timestamp: {}'.format(event_date))
                event_time = int(time.mktime(time.strptime(event_date,date_pattern))) * 1000
                new_last_run = max(new_last_run,event_time)
                demisto_severity = attivo_api.convert_to_demisto_severity(event['alertLevel'])
                event_type = event['details']['Attack Phase']
                incidents.append({
                                   'name': event['attackName'],
                                   'occurred': event_date,
                                   'details': event['attackDesc'],
                                   'severity': demisto_severity,
                                   'type': event_type,
                                   'rawJSON': json.dumps(event)
                })


            demisto.info("Setting new last run value to {}".format(new_last_run))
            demisto.setLastRun({'time': new_last_run})
            demisto.incidents(incidents)
        else:
            demisto.info("No new Attivo incidents to add")

        logout_status = attivo_api.logout()

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)

        if login_status and 'sessionKey' in login_status:
            demisto.info("Attivo Login successful (session key = {})".format(login_status['sessionKey']))
            logout_status = attivo_api.logout()
            demisto.results('ok')
            sys.exit(0)
        else:
            demisto.error("Login to {} failed".format(server))
            demisto.error("API Results: {}".format(login_status))
            demisto.results("Login to {} failed\n{}".format(server,login_status))

    if demisto.command() == 'attivo-run-playbook':
        playbook_name = demisto.args()['playbook_name']
        attacker_ip = demisto.args()['attacker_ip']
        playbook_id = None
        playbook_status = None
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)
        all_playbooks = attivo_api.get_playbooks()
        for playbook in all_playbooks['pb']:
            if playbook['name'] == playbook_name:
                playbook_id = playbook['id']
                break

        if not playbook_id:
            demisto.error("ID not found for Attivo playbook named: {}".format(playbook_name))
            status_message = "Failed: could not find playbook named '{}'".format(playbook_name)
            status = False
        else:
            demisto.info("Running Attivo playbook named {} ({}) with attacker IP {}".format(playbook_name, playbook_id, attacker_ip))
            playbook_status = attivo_api.run_playbook(playbook_id, attacker_ip)
            demisto.info("Run playbook status = {}".format(playbook_status))

            if playbook_status['status']:
                status_text = playbook_status['status']
                if status_text == 'submitted':
                    status=True
                    status_message = "Attivo playbook '{}' (ID={}) has been run with attacker IP {}".format(playbook_name, playbook_id,attacker_ip)
                else:
                    status=False
                    status_message = "Attivo playbook has not been run.  Status = '{}'".format(status_text)
            else:
                status = False
                status_message = "Attivo playbook has not been run.  Status = 'Unknown failure'"

        entry = {
            'Type': entryTypes['note'],
            'Contents': playbook_status,
            'ContentsFormat': formats['json'],
            'HumanReadable': status_message,
            'ReadableContentsFormat': formats['text'],
            'EntryContext': {'Attivo.Playbook.Status': status,
                             'Attivo.Playbook.Message': status_message}
            }

        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-deploy-decoy':
        vulnerable_ip = demisto.args()['vulnerable_ip']
        decoy_number = demisto.args()['decoy_number']
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)
        demisto.info("Deploying {} decoy(s) on the subnet of {}".format(decoy_number, vulnerable_ip))
        deploy_status = {}
        deploy_status = attivo_api.deploy_decoys(vulnerable_ip,decoy_number=decoy_number)
        demisto.info("Deployment status = {}".format(deploy_status))

        status = False
        status_text = "Unknown failure"
        if 'result' in deploy_status:
            status_text = deploy_status['result'][0]['success']
            if status_text == True:
                status = True
        elif 'success' in deploy_status:
            status_text = deploy_status['success']
            if status_text == True:
                status = True
        elif 'error' in deploy_status:
            status_text = deploy_status['error']

        if status:
            status_message = "{} new Attivo decoy(s) deployed on the subnet with {}".format(decoy_number,vulnerable_ip)
        else:
            status_message = "No Attivo decoys have been deployed. {}".format(status_text)

        entry = {
            'Type': entryTypes['note'],
            'Contents': deploy_status,
            'ContentsFormat': formats['json'],
            'HumanReadable': status_message,
            'ReadableContentsFormat': formats['text'],
            'EntryContext': {'Attivo.DeployDecoy.Status': status,
                             'Attivo.DeployDecoy.Message': status_message}
            }

        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-check-user':
        user = demisto.args()['user']
        demisto.info("Check Attivo for user = {}".format(user))
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)

        is_deceptive = False
        this_user_object= None

        user_groups = attivo_api.get_deceptive_objects('USERS','ALL')
        in_groups = []
        for user_group in user_groups['objGroup']:
            group_id = user_group['esid']
            users_in_group = attivo_api.get_deceptive_objects('USERS', group_id)
            for user_object in users_in_group['objGroup']['objects']:
                this_user = user_object['username']
                if this_user == user:
                    # demisto.info("Attivo BOTSink user match ({}) ({})".format(this_user, user_group['name']))
                    this_user_object = user_object
                    is_deceptive = True
                    in_groups.append(user_group['name'])
                    break

        output_table = {'User': user, 'Is Deceptive': str(is_deceptive), 'Groups': ', '.join(in_groups)}

        entry = {'Type': entryTypes['note'],
                'Contents': this_user_object,
                'ContentsFormat': formats['text'],
                'HumanReadable': output_table,
                'ReadableContentsFormat': formats['table'],
                'EntryContext': {
                                    'Attivo.User.Name': user,
                                    'Attivo.User.IsDeceptive': is_deceptive,
                                    'Attivo.User.Groups': in_groups
                                 }
        }

        demisto.info("User {user}, deceptive = {is_deceptive}, group(s) = {groups}".format(user=user,is_deceptive=is_deceptive, groups=in_groups))
        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-check-host':
        host = demisto.args()['host']
        demisto.info("Check Attivo for host = {}".format(host))
        attivo_api = BSAPI(server, verify_ssl=verify_ssl)
        login_status = attivo_api.login(api_user,api_pass)

        is_deceptive = False
        this_rule = None
        host_info={}

        if valid_ip(host):
            ip_address = host
            host_name = None
        else:
            host_name = host
            ip_address = None

        # Check native Monitoring Rules
        bs_monitoring = attivo_api.get_monitoring_rules()
        if bs_monitoring is not None:
            for rule in bs_monitoring['cfg_monitoring_rules']['monitoringRules']:
                this_ip = rule['ipAddress']
                mac = rule['externalMAC']
                dhcp = rule['isDHCPIP']
                vlan = rule['vlanID']
                if vlan == -1:
                    vlan = None
                user_defined = rule['userDefined']
                this_host_name = []
                if 'dnsName' in rule and rule['dnsName']:
                    this_host_name.append(rule['dnsName'])
                if 'interfaceName' in rule and rule['interfaceName']:
                    this_host_name.append(rule['interfaceName'])

                if (ip_address and this_ip == ip_address) or (host_name and this_host_name and host_name in this_host_name):
                    this_rule = rule
                    is_deceptive = True
                    demisto.info("Attivo BOTSink IP/Host match ({ip}) ({name}) ({user_defined}) ({mac}) ({dhcp}) ({vlan})".format(ip=this_ip, name=this_host_name, user_defined=user_defined, mac=mac, dhcp=dhcp, vlan=vlan))
                    host_info = {'ip': this_ip, 'name': this_host_name, 'user_defined': user_defined, 'mac': mac, 'dhcp': dhcp, 'vlan': vlan}
                    break


        if not is_deceptive:
            # Check ThreatDirect Monitoring Rules
            td_monitoring = attivo_api.get_threatdirect_rules()
            if td_monitoring is not None:
                for rule in td_monitoring['forwarder_vm_monitoring_rules']['forwarderVmMonitoringRules']:
                    this_ip = rule['ip']
                    this_host_name = []
                    mac = rule['customized_mac']
                    vlan = rule['vlanID']
                    dhcp = rule['dhcpip']
                    td_name = rule['threatDirectName']
                    if rule['type'] == 'onNet':
                        td_type = "EP"
                    else:
                        td_type = "VM"
                    if 'dnsName' in rule and rule['dnsName']:
                        this_host_name.append(rule['dnsName'])

                    if (ip_address and this_ip == ip_address) or (host_name and this_host_name and host_name in this_host_name):
                        this_rule = rule
                        is_deceptive = True
                        demisto.info("Attivo ThreatDirect IP match ({ip}) ({name}) ({mac}) ({dhcp}) ({vlan}) ({td_name}) ({td_type})".format(ip=this_ip, name=this_host_name, mac=mac, dhcp=dhcp, vlan=vlan, td_name=td_name, td_type=td_type))
                        host_info = {'ip': this_ip, 'name': this_host_name, 'mac': mac, 'dhcp': dhcp, 'vlan': vlan, 'td_name': td_name, 'td_type': td_type}
                        break
                    #elif host_name and this_host_name and host_name in this_host_name:
                     #   this_rule = rule
                     #   is_deceptive = True
                     #   demisto.info("Attivo ThreatDirect host match ({ip}) ({name}) ({user_defined}) ({mac}) ({dhcp}) ({vlan})".format(this_ip, #this_host_name, user_defined, mac, dhcp, vlan))
                    #break

        if is_deceptive:
            output_table = {'Is Deceptive': 'True',
                'IP Address': this_ip,
                'Host Names': ', '.join(this_host_name),
                'MAC Address': mac,
                'DHCP': str(dhcp),
                'User Defined': str(user_defined),
                'VLAN': vlan
            }
        else:
            output_table = {'Is Deceptive': 'False',
                'IP Address': ip_address,
                'Host Names': host_name,
                'MAC Address': '',
                'DHCP': '',
                'User Defined': '',
                'VLAN': ''
            }


        entry = {'Type': entryTypes['note'],
                'Contents': output_table,
                'ContentsFormat': formats['table'],
                'HumanReadable': output_table,
                'ReadableContentsFormat': formats['table'],
                'EntryContext': {'Attivo.Host.HostInfo': host_info,
                                 'Attivo.Host.IsDeceptive': is_deceptive
                                }
                }

        demisto.info("Deception status for {host} is {is_deceptive}".format(host=host,is_deceptive=is_deceptive))
        demisto.results(entry)
        logout_status = attivo_api.logout()
  type: python
  commands:
  - name: attivo-check-user
    arguments:
    - name: user
      required: true
      description: User to validate
    outputs:
    - contextPath: Attivo.User.IsDeceptive
      description: Is the user part of the Deception environment
      type: boolean
    - contextPath: Attivo.User.Groups
      description: If the user is part of the Deception environment, it is a member
        of these groups
    description: Check whether a user is deceptive
  - name: attivo-check-host
    arguments:
    - name: host
      required: true
      description: Host name or IP to validate
    outputs:
    - contextPath: Attivo.Host.IsDeceptive
      description: Is the IP or hostname part of the Decpetion environment
      type: boolean
    - contextPath: Attivo.Host.IPAddress
      description: IP Address of deceptive host
    - contextPath: Attivo.Host.Name
      description: Hostname of deceptive host
    - contextPath: Attivo.Host.MACAddress
      description: MAC Address of deceptive host
    - contextPath: Attivo.Host.VLAN
      description: VLAN of deceptive host
    - contextPath: Attivo.Host.UserDefined
      description: Was this host manually defined
      type: boolean
    - contextPath: Attivo.Host.DHCP
      description: Does the host have a dynamic IP address
      type: boolean
    - contextPath: Attivo.Host.ThreatDirect.Name
      description: Name of the ThreatDirect device projecting this deceptive host
    - contextPath: Attivo.Host.ThreatDirect.Type
      description: The type of ThreatDirect device projecting the deceptive host
    description: Check whether a host is deceptive
  - name: attivo-run-playbook
    arguments:
    - name: playbook_name
      required: true
      description: The name of the prebuilt playbook
    - name: attacker_ip
      required: true
      description: Malicious source IP
    outputs:
    - contextPath: Attivo.Playbook.Message
      description: Complete status message
      type: string
    - contextPath: Attivo.Playbook.Status
      description: Success or failure boolean
      type: boolean
    description: Run a pre-built playbook on the BOTsink appliance
  - name: attivo-deploy-decoy
    arguments:
    - name: vulnerable_ip
      required: true
      description: Used to determine which subnet to deploy to
    - name: decoy_number
      default: true
      description: The number of decoys to deploy
      defaultValue: "1"
    outputs:
    - contextPath: Attivo.DeployDecoy.Status
      description: Success or failure boolean
      type: boolean
    - contextPath: Attivo.DeployDecoy.Message
      description: Complete status message
      type: string
    description: 'Deploy a new network decoy '
  - name: attivo-get-events
    arguments:
    - name: attacker_ip
      required: true
      description: Source IP
    - name: hours_back
      description: How many hours back to search
      defaultValue: "24"
    - name: severity
      auto: PREDEFINED
      predefined:
      - VeryHigh
      - High
      - Medium
      - Low
      - VeryLow
      - SystemActivity
      description: The minimum Attivo severity
      defaultValue: Medium
    outputs:
    - contextPath: Attivo.Events.Count
      description: Total number of events retrieved
      type: number
    - contextPath: Attivo.Events.List.Attack Name
      description: Short name of the attack
    - contextPath: Attivo.Events.List.Attack Phase
      description: Kill chain phase of hte attack
      type: string
    - contextPath: Attivo.Events.List.Server
      description: Internal name for target decoy
      type: string
    - contextPath: Attivo.Events.List.Targert
      description: External name for target decoy
      type: string
    - contextPath: Attivo.Events.List.Target OS
      description: Operating system of target decoy
      type: string
    - contextPath: Attivo.Events.List.Attacker
      description: Attacker IP address
      type: string
    - contextPath: Attivo.Events.List.Service
      description: The attacked service
      type: string
    - contextPath: Attivo.Events.List.Timestamp
      description: Time of the attack
      type: string
    - contextPath: Attivo.Events.List.Target IP
      description: IP address of the target decoy
      type: string
    - contextPath: Attivo.Events.List.Severity
      description: Attivo severity of the attack
      type: string
    description: Retrieve events for a specific source IP
  isfetch: true
  runonce: false
