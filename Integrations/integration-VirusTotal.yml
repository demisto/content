commonfields:
  id: VirusTotal
  version: -1
name: VirusTotal
display: VirusTotal
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Analyze suspicious hashes, URLs, domains and IP addresses
detaileddescription: |-
  Don’t have a Virustotal key?
  Register at https://www.virustotal.com
  After signing in click on your user name (top right) and go to “My API Key”
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: Server
  defaultvalue: https://www.virustotal.com/vtapi/v2/
  type: 0
  required: true
- display: API Key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: useproxy
  defaultvalue: true
  type: 8
  required: false
- display: Allow self-signed SSL certificates
  name: insecure
  defaultvalue: false
  type: 8
  required: false
script:
  script: |-
    var serverUrl = params.Server;
    if (serverUrl[serverUrl.length - 1] !== '/') {
        serverUrl += '/';
    }

    var doReq = function(method, path, parameters) {
        if (!parameters) {
            parameters = {};
        }
        parameters.apikey = params.APIKey;
        var result = http(
            serverUrl + path + (method === 'GET' ? encodeToURLQuery(parameters) : ''),
            {
                Headers: {'Content-Type': ['application/x-www-form-urlencoded'], 'Accept': ['application/json']},
                Method: method,
                Body: method == 'POST' ? encodeToURLQuery(parameters).substring(1) : ''
            },
            params.insecure,
            params.useproxy
        );

        if (result.StatusCode < 200 || result.StatusCode > 299) {
            throw 'Failed to perform request ' + path + ', request status code: ' + result.StatusCode;
        }
        if (result.Body === '' && result.StatusCode === 204) {
            return {statusCode: result.StatusCode};
        }
        if (result.Body === '') {
            throw 'No content received. Maybe you tried a private API?.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (!Array.isArray(obj) && obj.response_code !== 1 && obj.response_code !== 0) {
            throw 'Response code: ' + obj.response_code + ', message: ' + obj.verbose_msg;
        }
        return {body: result.Body, obj: obj, statusCode: result.StatusCode};
    };

    var withRetries = function(waitForRateLimit, retries, reqCall) {
        if (waitForRateLimit) {
            waitForRateLimit = parseInt(waitForRateLimit);
        }
        if (!waitForRateLimit) {
            waitForRateLimit = 60;
        }
        if (retries) {
            retries = parseInt(retries);
        }
        if (!retries) {
            retries = 0;
        }
        var res = reqCall();
        var tries = 0;
        while (res.statusCode === 204 && !res.body && tries < retries && waitForRateLimit > 0) {
            wait(waitForRateLimit);
            tries++;
            res = reqCall();
        }
        if (res.statusCode === 204 && !res.body) {
            throw 'No content received. Possible API rate limit reached.';
        }
        return res;
    };

    var doFile = function(hash, longFormat, threshold, waitForRateLimit, retries) {
        if (!threshold) {
            threshold = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('POST', 'file/report', {resource: hash});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: hash, Type: 'hash', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + hash + '\n' + res.obj.verbose_msg};
        }
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple hashes so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        ec.DBotScore = [];
        ec[outputPaths.file] = [];
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal Hash Reputation for: ' + r[i].resource + '\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            md += 'Scan date: **' + r[i].scan_date + '**\n';
            md += 'Positives / Total: **' + r[i].positives + '/' + r[i].total + '**\n';
            md += 'VT Link: [' + r[i].resource + '](' + r[i].permalink + ')\n';
            var dbotScore = 0;
            if (r[i].positives >= threshold) {
                dbotScore = 3;
                var malFile = {};
                addMalicious(malFile, outputPaths.file, {
                    MD5: r[i].md5,
                    SHA1: r[i].sha1,
                    SHA256: r[i].sha256,
                    Malicious: {Vendor: 'VirusTotal', Detections: r[i].positives, TotalEngines: r[i].total}
                });
                ec[outputPaths.file].push(malFile[outputPaths.file]);
            } else if (r[i].positives >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }
            ec.DBotScore.push({Indicator: hash, Type: 'hash', Vendor: 'VirusTotal', Score: dbotScore});
            md += 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\n';
            if (longFormat === 'true' && r[i].scans) {
                md += arrToMd(Object.keys(r[i].scans).map(function(curr) {
                    var o = r[i].scans[curr];
                    return {Engine: curr, Detected: o.detected, Result: o.result, Update: o.update};
                }));
            }
            md += '\n';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var calcRecentDownloads = function(checks) {
        var badDownloads = 0;
        var now = Date.now();
        for (var c=0; c<checks.length; c++) {
            if (checks[c]) {
                for (var ci=0; ci<checks[c].length; ci++) {
                    if (checks[c][ci].date) {
                        var d = new Date(checks[c][ci].date.replace(' ', 'T'));
                        if ((now - d.getTime()) / 1000 / 60 / 60 / 24 < 30) {
                            badDownloads++;
                        }
                    }
                }
            }
        }
        return badDownloads;
    };

    var doIP = function(ip, longFormat, threshold, sampleSize, waitForRateLimit, retries) {
        if (!isValidIP(ip)) {
            return {Type: entryTypes.error, Contents: 'IP - ' + ip + ' is not valid IP', ContentsFormat: formats.text};
        }
        if (!threshold) {
            threshold = 10;
        }
        if (!sampleSize) {
            sampleSize = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('GET', 'ip-address/report', {ip: ip});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + ip + '\n' + res.obj.verbose_msg};
        }
        // Calculate score based on recently found downloads
        var badDownloads = calcRecentDownloads([o.detected_downloaded_samples, o.undetected_downloaded_samples]);
        var dbotScore = 0;
        if (badDownloads >= threshold) {
            dbotScore = 3;
            addMalicious(ec, outputPaths.ip,{
                Address: ip,
                ASN: o.asn,
                Geo: {Country: o.country},
                Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}
            });
        } else if (badDownloads >= threshold / 2) {
            dbotScore = 2;
        } else {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: dbotScore};
        var md = '## VirusTotal IP Reputation for: ' + ip + '\n';
        md += (o.asn) ? 'ASN: **' + o.asn + ' (' + o.as_owner + ')**\n' : 'ASN: N/A\n';
        md += 'Country: **' + o.country + '**\n';
        md += 'VT Link: [' + ip + '](https://www.virustotal.com/en/search?query=' + encodeURIComponent(ip) + ')\n';
        var arrTitle = [{a: o.detected_urls, t: 'Detected URL'}, {a: o.detected_downloaded_samples, t: 'Detected downloaded sample'}, {a: o.undetected_downloaded_samples, t: 'Undetected downloaded sample'},
            {a: o.detected_communicating_samples, t: 'Detected communicating sample'}, {a: o.undetected_communicating_samples, t: 'Undetected communicating sample'},
            {a: o.detected_referrer_samples, t: 'Detected referrer sample'}, {a: o.undetected_referrer_samples, t: 'Undetected referrer sample'}, {a: o.resolutions, t: 'Resolutions'}];
        for (var i=0; i<arrTitle.length; i++) {
            if (arrTitle[i].a) {
                md += arrTitle[i].t + ' count: **' + arrTitle[i].a.length + '**\n';
            }
        }
        if (longFormat === 'true') {
            for (var j=0; j<arrTitle.length; j++) {
                if (arrTitle[j].a) {
                    md += '### ' + arrTitle[j].t + '\n';
                    // Print only the first 10 rows
                    var curr = [];
                    for (var k=0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {
                        curr.push(arrTitle[j].a[k]);
                    }
                    md += arrToMd(curr) + '\n';
                }
            }
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doURL = function(url, threshold, longFormat, sampleSize, submitWait, waitForRateLimit, retries) {
        if (!submitWait) {
            submitWait = 0;
        }
        if (!sampleSize) {
            sampleSize = 10;
        }
        if (!threshold) {
            threshold = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('POST', 'url/report', {resource: url, scan:1});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + url + '\n' + res.obj.verbose_msg};
        }

        var md = '## VirusTotal URL Reputation for: ' + url + '\n';

        if (!o.scans && submitWait>0) {
            wait(parseInt(submitWait));
            res = doReq('GET', 'url/report', {resource: url});
            o = res.obj;
        }
        if (!o.scans) {
            md += 'URL submitted for scan. Please retry command later\n';
            md += 'Scan ID: **' + o.scan_id + '**\n\n';
        } else {
            md += 'Last scan date: *' + o.scan_date + '*\n';
            md += 'Scan ID: **' + o.scan_id + '**\n\n';
            md += 'Total scans: **' + o.total + '**\n';
            md += 'Positive scans: **' + o.positives + '**\n';
            md += 'VT Link: [' + url + '](' + o.permalink + ')\n';

            if (longFormat === 'true') {
                md += '### Scans\n';
                // Print only the first 10 rows
                var curr = [];
                for (var i=0; i<Math.min(Object.keys(o.scans).length, sampleSize); i++) {
                    curr.push({Site: Object.keys(o.scans)[i], Detected: o.scans[Object.keys(o.scans)[i]].detected, Result: o.scans[Object.keys(o.scans)[i]].result});
                }
                md += arrToMd(curr) + '\n';
            }
            var dbotScore = 0;
            if (o.positives >= threshold) {
                dbotScore = 3;
                addMalicious(ec, outputPaths.url, {
                    Data: url,
                    Malicious: {Vendor: 'VirusTotal', Description: 'Positives / Total: ' + o.positives + ' / ' + o.total}
                });
            } else if (o.positives >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }
            ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: dbotScore};
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doDomain = function(domain, threshold, longFormat, sampleSize, waitForRateLimit, retries) {
        if (!sampleSize) {
            sampleSize = 10;
        }
        if (!threshold) {
            threshold = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('GET', 'domain/report', {domain: domain});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: domain, Type: 'domain', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + domain + '\n' + res.obj.verbose_msg};
        }

        // Calculate score based on recently found downloads
        var badDownloads = calcRecentDownloads([o.detected_downloaded_samples, o.undetected_downloaded_samples]);
        var dbotScore = 0;
        if (badDownloads >= threshold) {
            dbotScore = 3;
            addMalicious(ec, outputPaths.domain, {Name: domain,
                Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}});
        } else if (badDownloads >= threshold / 2) {
            dbotScore = 2;
        } else {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: domain, Type: 'domain', Vendor: 'VirusTotal', Score: dbotScore};

        var md = '## VirusTotal Domain Reputation for: ' + domain + '\n';
        md += '#### Domain categories: *' + o.categories + "*\n";
        md += 'VT Link: [' + domain + '](https://www.virustotal.com/en/search?query=' + encodeURIComponent(domain) + ')\n';

        var arrTitle = [{a: o.detected_urls, t: 'Detected URL'}, {a: o.detected_downloaded_samples, t: 'Detected downloaded sample'}, {a: o.undetected_downloaded_samples, t: 'Undetected downloaded sample'},
            {a: o.detected_communicating_samples, t: 'Detected communicating sample'}, {a: o.undetected_communicating_samples, t: 'Undetected communicating sample'},
            {a: o.detected_referrer_samples, t: 'Detected referrer sample'}, {a: o.undetected_referrer_samples, t: 'Undetected referrer sample'}, {a: o.resolutions, t: 'Resolutions'}];
        for (var i=0; i<arrTitle.length; i++) {
            if (arrTitle[i].a) {
                md += arrTitle[i].t + ' count: **' + arrTitle[i].a.length + '**\n';
            }
        }
        if (longFormat === 'true') {
            for (var j=0; j<arrTitle.length; j++) {
                if (arrTitle[j].a) {
                    md += '### ' + arrTitle[j].t + '\n';
                    // Print only the first 10 rows
                    var curr = [];
                    for (var k=0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {
                        curr.push(arrTitle[j].a[k]);
                    }
                    md += arrToMd(curr) + '\n';
                }
            }
        }
        if (o.resolutions && o.resolutions.length > 0) {
            md += tableToMarkdown("Passive DNS replication", o.resolutions, Object.keys(o.resolutions[0]), undefined, function (header) { return underscoreToCamelCase(header); });
        }
        if (o.domain_siblings && o.domain_siblings.length > 0) {
            md += "### Observed subdomains\n";
            for (var i = 0; i < o.domain_siblings.length; i++) {
                md += "- " + o.domain_siblings[i] + "\n";
            }
        }
        if (o.whois) {
            var whoIs = o.whois.trim();
            var lines = whoIs ? whoIs.split("\n") : [];
            md += '### Whois Lookup\n';
            for (var i = 0; i < lines.length; i++) {
                var parts = lines[i].split(': ');
                if (parts[0] && parts[1]) {
                    md += "**" + parts[0].trim() + "**: " + parts[1] + "\n";
                }
            }
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var scanURL = function(url) {
        var res = doReq('POST', 'url/scan', {url: url});
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple URLs so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        var ec = {vtScanID: []};
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal URL scan for: [' + r[i].url + '](' + r[i].permalink + ')\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            ec.vtScanID.push(r[i].scan_id);
            md += 'Scan Date: **' + r[i].scan_date + '**\n\n';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var scanFile = function(entry, uploadURL) {
        var url = uploadURL ? uploadURL : serverUrl + 'file/scan';
        var fileName = dq(invContext, "File(val.EntryID == '" + entry + "').Name");
        if (Array.isArray(fileName)) {
            if (fileName.length > 0) {
                fileName = fileName[0];
            } else {
                fileName = undefined;
            }
        }
        var result = httpMultipart(url, entry, {Method: 'POST', Headers: {'Accept': ['application/json']}}, {apikey: params.APIKey},
            params.insecure, params.proxy, undefined, 'file', fileName);
        if (result.StatusCode < 200 || result.StatusCode > 299) {
            throw 'Failed to perform request ' + url + ', request status code: ' + result.StatusCode;
        }
        if (result.Body === '' && result.StatusCode == 204) {
            throw 'No content recieved. Possible API rate limit reached.';
        }
        if (result.Body === '') {
            throw 'No content recieved. Maybe you tried a private API?.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (obj.response_code !== 1) {
            throw 'Response code: ' + obj.response_code + ', message: ' + obj.verbose_msg;
        }
        var ec = {};
        ec.vtScanID = obj.scan_id;
        var md = '## VirusTotal scan file for [' + entry + '](' + obj.permalink + ')\n';
        md += 'Resource: **' + obj.resource + '**\n';
        md += 'Scan ID: **' + obj.scan_id + '**\n';
        md += 'MD5 / SHA1 / SHA256: **' + obj.md5 + ' / ' + obj.sha1 + ' / ' + obj.sha256 + '**\n';
        return {Type: entryTypes.note, Contents: result.Body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var rescanFile = function(hash) {
        var res = doReq('POST', 'file/rescan', {resource: hash});
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple hashes so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        var ec = {vtScanID: []};
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal File Rescan for: [' + r[i].resource + '](' + r[i].permalink + ')\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            ec.vtScanID.push(r[i].scan_id);
            md += 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\n\n';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doComments = function(resource, comment) {
        var res = doReq('POST', 'comments/put', {resource: resource, comment: comment});
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: res.obj.verbose_msg};
    }

    var getComments = function(resource, before) {
        var params = {resource: resource};
        if (before) {
            params.before = before;
        }
        var res = doReq('GET', 'comments/get', params);
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: arrToMd(res.obj.comments)};
    }

    var fileScanUploadURL = function() {
        var res = doReq('GET', 'file/scan/upload_url');
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: res.obj.upload_url, EntryContext: {vtUploadURL: res.obj.upload_url}};
    }

    switch (command) {
        case 'test-module':
            doFile('7657fcb7d772448a6d8504e4b20168b8'); // Check sample file - it will throw an error if not successful
            return true;
        case 'file':
            return doFile(args.file, args.long, args.threshold, args.wait, args.retries);
        case 'ip':
            return doIP(args.ip, args.long, args.threshold, args.sampleSize, args.wait, args.retries);
        case 'url':
            return doURL(args.url, args.threshold, args.long, args.sampleSize, args.submitWait, args.wait, args.retries);
        case 'domain':
            return doDomain(args.domain, args.threshold, args.long, args.sampleSize, args.wait, args.retries);
        case 'file-scan':
            return scanFile(args.entryID, args.uploadURL);
        case 'file-rescan':
            return rescanFile(args.file);
        case 'url-scan':
            return scanURL(args.url);
        case 'vt-comments-add':
            return doComments(args.resource, args.comment);
        case 'vt-comments-get':
            return getComments(args.resource, args.before);
        case 'vt-file-scan-upload-url':
            return fileScanUploadURL();
        default:
            throw 'Unknown command - ' + command;
    }
  type: javascript
  commands:
  - name: file
    deprecated: false
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to query. Supports MD5, SHA1 and SHA256. Notice
        that you can pass comma-separated multiple values to efficiently retrieve
        multiple responses.
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with scans
      defaultValue: "false"
    - name: threshold
      description: If number of positives is bigger than the threshold we will consider
        it malicious
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: File.MD5
      description: Bad hash found
    - contextPath: File.SHA1
      description: Bad hash SHA1
    - contextPath: File.SHA256
      description: Bad hash SHA256
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: File.Malicious.Detections
      description: For malicious files. Total detections.
    - contextPath: File.Malicious.TotalEngines
      description: For malicious files. Total engines
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check file reputation of the given hash
  - name: ip
    deprecated: false
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: threshold
      description: If number of positive detected IPs is bigger than the threshold
        we will consider it malicious
      defaultValue: "10"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: IP.Address
      description: Bad IP Address found
    - contextPath: IP.ASN
      description: Bad IP ASN
    - contextPath: IP.Geo.Country
      description: Bad IP Country
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check IP Reputation
  - name: url
    deprecated: false
    arguments:
    - name: url
      required: true
      description: URL to be checked
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: threshold
      description: If number of positive detected URLs is bigger than the threshold
        we will consider it malicious
    - name: submitWait
      description: Seconds to wait if the URL does not exist and is submitted to be
        scanned
      defaultValue: "0"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check URL Reputation
  - name: domain
    deprecated: false
    arguments:
    - name: domain
      required: true
      default: true
      description: Domain name to check reputation
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: threshold
      description: If number of positive detected domains is bigger than the threshold
        we will consider it malicious
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: Domain.Name
      description: Bad domain found
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check domain reputation
  - name: file-scan
    deprecated: false
    arguments:
    - name: entryID
      required: true
      default: true
      description: The file entry ID to submit
    - name: uploadURL
      description: Private API extension. Special upload URL for files bigger than
        32M.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files
    description: Submit a file for scanning
  - name: file-rescan
    deprecated: false
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to re-scan. Supports MD5, SHA1 and SHA256.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files
    description: Rescan an already submitted file to save time and not upload
  - name: url-scan
    deprecated: false
    arguments:
    - name: url
      required: true
      default: true
      description: The URL to scan
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted URLs
    description: Scan a given URL
  - name: vt-comments-add
    deprecated: false
    arguments:
    - name: resource
      required: true
      default: true
      description: The hash (md5/sha1/sha256) or URL you're commenting on
    - name: comment
      required: true
      description: 'The actual review, you can tag it using the "#" twitter-like syntax
        (e.g. #disinfection #zbot) and reference users using the "@" syntax (e.g.
        @VirusTotalTeam).'
    description: Add comments for files and URLs
  - name: vt-file-scan-upload-url
    deprecated: false
    arguments: []
    outputs:
    - contextPath: vtUploadURL
      description: The special upload URL for large files
    description: Private API. Get a special URL for files above 32M.
  - name: vt-comments-get
    deprecated: false
    arguments:
    - name: resource
      required: true
      default: true
      description: The hash (md5/sha1/sha256) or URL you're retrieving comments for
    - name: before
      description: Datetime token in format YYYYMMDDHHMISS that can be used for paging
    description: Private API. Retrieve comments for a given resource
hidden: false
fromversion: 2.5.0
