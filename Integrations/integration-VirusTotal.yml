commonfields:
  id: VirusTotal
  version: -1
name: VirusTotal
display: VirusTotal
category: Data Enrichment
image: data:image/png;base64,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
description: Analyze suspicious hashes, URLs, domains and IP addresses
detaileddescription: |-
  Don’t have a Virustotal key?
  Register at https://www.virustotal.com
  After signing in click on your user name (top right) and go to “My API Key”
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: Server
  defaultvalue: https://www.virustotal.com/vtapi/v2/
  type: 0
  required: true
- display: API Key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: useproxy
  defaultvalue: true
  type: 8
  required: false
- display: Allow self-signed SSL certificates
  name: insecure
  defaultvalue: false
  type: 8
  required: false
script:
  script: |-
    var serverUrl = params.Server;
    if (serverUrl[serverUrl.length - 1] !== '/') {
        serverUrl += '/';
    }

    var doReq = function(method, path, parameters) {
        if (!parameters) {
            parameters = {};
        }
        parameters.apikey = params.APIKey;
        var result = http(
            serverUrl + path + (method === 'GET' ? encodeToURLQuery(parameters) : ''),
            {
                Headers: {'Content-Type': ['application/x-www-form-urlencoded'], 'Accept': ['application/json']},
                Method: method,
                Body: method == 'POST' ? encodeToURLQuery(parameters).substring(1) : ''
            },
            params.insecure,
            params.useproxy
        );

        if (result.StatusCode < 200 || result.StatusCode > 299) {
            throw 'Failed to perform request ' + path + ', request status code: ' + result.StatusCode;
        }
        if (result.Body === '' && result.StatusCode === 204) {
            return {statusCode: result.StatusCode};
        }
        if (result.Body === '') {
            throw 'No content received. Maybe you tried a private API?.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (!Array.isArray(obj) && obj.response_code !== 1 && obj.response_code !== 0) {
            throw 'Response code: ' + obj.response_code + ', message: ' + obj.verbose_msg;
        }
        return {body: result.Body, obj: obj, statusCode: result.StatusCode};
    };

    var withRetries = function(waitForRateLimit, retries, reqCall) {
        if (waitForRateLimit) {
            waitForRateLimit = parseInt(waitForRateLimit);
        }
        if (!waitForRateLimit) {
            waitForRateLimit = 60;
        }
        if (retries) {
            retries = parseInt(retries);
        }
        if (!retries) {
            retries = 0;
        }
        var res = reqCall();
        var tries = 0;
        while (res.statusCode === 204 && !res.body && tries < retries && waitForRateLimit > 0) {
            wait(waitForRateLimit);
            tries++;
            res = reqCall();
        }
        if (res.statusCode === 204 && !res.body) {
            throw 'No content received. Possible API rate limit reached.';
        }
        return res;
    };

    var doFile = function(hash, longFormat, threshold, waitForRateLimit, retries) {
        if (!threshold) {
            threshold = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('POST', 'file/report', {resource: hash});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: hash, Type: 'file', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + hash + '\n' + res.obj.verbose_msg};
        }
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple hashes so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        ec.DBotScore = [];
        ec[outputPaths.file] = [];
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal Hash Reputation for: ' + r[i].resource + '\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            md += 'Scan date: **' + r[i].scan_date + '**\n';
            md += 'Positives / Total: **' + r[i].positives + '/' + r[i].total + '**\n';
            md += 'VT Link: [' + r[i].resource + '](' + r[i].permalink + ')\n';
            var dbotScore = 0;
            if (r[i].positives >= threshold) {
                dbotScore = 3;
                var malFile = {};
                addMalicious(malFile, outputPaths.file, {
                    MD5: r[i].md5,
                    SHA1: r[i].sha1,
                    SHA256: r[i].sha256,
                    Malicious: {Vendor: 'VirusTotal', Detections: r[i].positives, TotalEngines: r[i].total}
                });
                ec[outputPaths.file].push(malFile[outputPaths.file]);
            } else if (r[i].positives >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }
            ec.DBotScore.push({Indicator: hash, Type: 'hash', Vendor: 'VirusTotal', Score: dbotScore});
            md += 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\n';
            if (longFormat === 'true' && r[i].scans) {
                md += arrToMd(Object.keys(r[i].scans).map(function(curr) {
                    var o = r[i].scans[curr];
                    return {Engine: curr, Detected: o.detected, Result: o.result, Update: o.update};
                }));
            }
            md += '\n';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var calcRecentDownloads = function(checks) {
        var badDownloads = 0;
        var now = Date.now();
        for (var c=0; c<checks.length; c++) {
            if (checks[c]) {
                for (var ci=0; ci<checks[c].length; ci++) {
                    if (checks[c][ci].date) {
                        var d = new Date(checks[c][ci].date.replace(' ', 'T'));
                        if ((now - d.getTime()) / 1000 / 60 / 60 / 24 < 30) {
                            badDownloads++;
                        }
                    }
                }
            }
        }
        return badDownloads;
    };

    var doIP = function(ip, longFormat, threshold, sampleSize, waitForRateLimit, retries) {
        if (!isValidIP(ip)) {
            return {Type: entryTypes.error, Contents: 'IP - ' + ip + ' is not valid IP', ContentsFormat: formats.text};
        }
        if (!threshold) {
            threshold = 10;
        }
        if (!sampleSize) {
            sampleSize = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('GET', 'ip-address/report', {ip: ip});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + ip + '\n' + res.obj.verbose_msg};
        }
        // Calculate score based on recently found downloads
        var badDownloads = calcRecentDownloads([o.detected_downloaded_samples, o.undetected_downloaded_samples]);
        var dbotScore = 0;
        if (badDownloads >= threshold) {
            dbotScore = 3;
            addMalicious(ec, outputPaths.ip,{
                Address: ip,
                ASN: o.asn,
                Geo: {Country: o.country},
                Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}
            });
        } else if (badDownloads >= threshold / 2) {
            dbotScore = 2;
        } else {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'VirusTotal', Score: dbotScore};
        var md = '## VirusTotal IP Reputation for: ' + ip + '\n';
        md += (o.asn) ? 'ASN: **' + o.asn + ' (' + o.as_owner + ')**\n' : 'ASN: N/A\n';
        md += 'Country: **' + o.country + '**\n';
        md += 'VT Link: [' + ip + '](https://www.virustotal.com/en/search?query=' + encodeURIComponent(ip) + ')\n';
        var arrTitle = [{a: o.detected_urls, t: 'Detected URL'}, {a: o.detected_downloaded_samples, t: 'Detected downloaded sample'}, {a: o.undetected_downloaded_samples, t: 'Undetected downloaded sample'},
            {a: o.detected_communicating_samples, t: 'Detected communicating sample'}, {a: o.undetected_communicating_samples, t: 'Undetected communicating sample'},
            {a: o.detected_referrer_samples, t: 'Detected referrer sample'}, {a: o.undetected_referrer_samples, t: 'Undetected referrer sample'}, {a: o.resolutions, t: 'Resolutions'}];
        for (var i=0; i<arrTitle.length; i++) {
            if (arrTitle[i].a) {
                md += arrTitle[i].t + ' count: **' + arrTitle[i].a.length + '**\n';
            }
        }
        if (longFormat === 'true') {
            for (var j=0; j<arrTitle.length; j++) {
                if (arrTitle[j].a) {
                    md += '### ' + arrTitle[j].t + '\n';
                    // Print only the first 10 rows
                    var curr = [];
                    for (var k=0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {
                        curr.push(arrTitle[j].a[k]);
                    }
                    md += arrToMd(curr) + '\n';
                }
            }
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doURL = function(url, threshold, longFormat, sampleSize, submitWait, waitForRateLimit, retries) {
        if (!submitWait) {
            submitWait = 0;
        }
        if (!sampleSize) {
            sampleSize = 10;
        }
        if (!threshold) {
            threshold = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('POST', 'url/report', {resource: url, scan:1});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + url + '\n' + res.obj.verbose_msg};
        }

        var md = '## VirusTotal URL Reputation for: ' + url + '\n';

        if (!o.scans && submitWait>0) {
            wait(parseInt(submitWait));
            res = doReq('GET', 'url/report', {resource: url});
            o = res.obj;
        }
        if (!o.scans) {
            md += 'URL submitted for scan. Please retry command later\n';
            md += 'Scan ID: **' + o.scan_id + '**\n\n';
        } else {
            md += 'Last scan date: *' + o.scan_date + '*\n';
            md += 'Scan ID: **' + o.scan_id + '**\n\n';
            md += 'Total scans: **' + o.total + '**\n';
            md += 'Positive scans: **' + o.positives + '**\n';
            md += 'VT Link: [' + url + '](' + o.permalink + ')\n';

            if (longFormat === 'true') {
                md += '### Scans\n';
                // Print only the first 10 rows
                var curr = [];
                for (var i=0; i<Math.min(Object.keys(o.scans).length, sampleSize); i++) {
                    curr.push({Site: Object.keys(o.scans)[i], Detected: o.scans[Object.keys(o.scans)[i]].detected, Result: o.scans[Object.keys(o.scans)[i]].result});
                }
                md += arrToMd(curr) + '\n';
            }
            var dbotScore = 0;
            if (o.positives >= threshold) {
                dbotScore = 3;
                addMalicious(ec, outputPaths.url, {
                    Data: url,
                    Malicious: {Vendor: 'VirusTotal', Description: 'Positives / Total: ' + o.positives + ' / ' + o.total}
                });
            } else if (o.positives >= threshold / 2) {
                dbotScore = 2;
            } else {
                dbotScore = 1;
            }
            ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: dbotScore};
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doDomain = function(domain, threshold, longFormat, sampleSize, waitForRateLimit, retries) {
        if (!sampleSize) {
            sampleSize = 10;
        }
        if (!threshold) {
            threshold = 10;
        }
        var res = withRetries(waitForRateLimit, retries, function() {return doReq('GET', 'domain/report', {domain: domain});});
        var o = res.obj;
        var ec = {};
        if (o.response_code === 0) {
            ec.DBotScore = {Indicator: domain, Type: 'domain', Vendor: 'VirusTotal', Score: 0};
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext: ec,
                HumanReadable: 'VirusTotal does not have details about ' + domain + '\n' + res.obj.verbose_msg};
        }

        // Calculate score based on recently found downloads
        var badDownloads = calcRecentDownloads([o.detected_downloaded_samples, o.undetected_downloaded_samples]);
        var dbotScore = 0;
        if (badDownloads >= threshold) {
            dbotScore = 3;
            addMalicious(ec, outputPaths.domain, {Name: domain,
                Malicious: {Vendor: 'VirusTotal', Description: 'Recent malicious downloads: ' + badDownloads}});
        } else if (badDownloads >= threshold / 2) {
            dbotScore = 2;
        } else {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: domain, Type: 'domain', Vendor: 'VirusTotal', Score: dbotScore};

        var md = '## VirusTotal Domain Reputation for: ' + domain + '\n';
        md += '#### Domain categories: *' + o.categories + "*\n";
        md += 'VT Link: [' + domain + '](https://www.virustotal.com/en/search?query=' + encodeURIComponent(domain) + ')\n';

        var arrTitle = [{a: o.detected_urls, t: 'Detected URL'}, {a: o.detected_downloaded_samples, t: 'Detected downloaded sample'}, {a: o.undetected_downloaded_samples, t: 'Undetected downloaded sample'},
            {a: o.detected_communicating_samples, t: 'Detected communicating sample'}, {a: o.undetected_communicating_samples, t: 'Undetected communicating sample'},
            {a: o.detected_referrer_samples, t: 'Detected referrer sample'}, {a: o.undetected_referrer_samples, t: 'Undetected referrer sample'}, {a: o.resolutions, t: 'Resolutions'}];
        for (var i=0; i<arrTitle.length; i++) {
            if (arrTitle[i].a) {
                md += arrTitle[i].t + ' count: **' + arrTitle[i].a.length + '**\n';
            }
        }
        if (longFormat === 'true') {
            for (var j=0; j<arrTitle.length; j++) {
                if (arrTitle[j].a) {
                    md += '### ' + arrTitle[j].t + '\n';
                    // Print only the first 10 rows
                    var curr = [];
                    for (var k=0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {
                        curr.push(arrTitle[j].a[k]);
                    }
                    md += arrToMd(curr) + '\n';
                }
            }
        }
        if (o.resolutions && o.resolutions.length > 0) {
            md += tableToMarkdown("Passive DNS replication", o.resolutions, Object.keys(o.resolutions[0]), undefined, function (header) { return underscoreToCamelCase(header); });
        }
        if (o.domain_siblings && o.domain_siblings.length > 0) {
            md += "### Observed subdomains\n";
            for (var i = 0; i < o.domain_siblings.length; i++) {
                md += "- " + o.domain_siblings[i] + "\n";
            }
        }
        if (o.whois) {
            var whoIs = o.whois.trim();
            var lines = whoIs ? whoIs.split("\n") : [];
            md += '### Whois Lookup\n';
            for (var i = 0; i < lines.length; i++) {
                var parts = lines[i].split(': ');
                if (parts[0] && parts[1]) {
                    md += "**" + parts[0].trim() + "**: " + parts[1] + "\n";
                }
            }
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var scanURL = function(url) {
        var res = doReq('POST', 'url/scan', {url: url});
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple URLs so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        var ec = {vtScanID: []};
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal URL scan for: [' + r[i].url + '](' + r[i].permalink + ')\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            ec.vtScanID.push(r[i].scan_id);
            md += 'Scan Date: **' + r[i].scan_date + '**\n\n';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var scanFile = function(entry, uploadURL) {
        var url = uploadURL ? uploadURL : serverUrl + 'file/scan';
        var fileName = dq(invContext, "File(val.EntryID == '" + entry + "').Name");
        if (Array.isArray(fileName)) {
            if (fileName.length > 0) {
                fileName = fileName[0];
            } else {
                fileName = undefined;
            }
        }
        var result = httpMultipart(url, entry, {Method: 'POST', Headers: {'Accept': ['application/json']}}, {apikey: params.APIKey},
            params.insecure, params.proxy, undefined, 'file', fileName);
        if (result.StatusCode < 200 || result.StatusCode > 299) {
            throw 'Failed to perform request ' + url + ', request status code: ' + result.StatusCode;
        }
        if (result.Body === '' && result.StatusCode == 204) {
            throw 'No content recieved. Possible API rate limit reached.';
        }
        if (result.Body === '') {
            throw 'No content recieved. Maybe you tried a private API?.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (obj.response_code !== 1) {
            throw 'Response code: ' + obj.response_code + ', message: ' + obj.verbose_msg;
        }
        var ec = {};
        ec.vtScanID = obj.scan_id;
        var md = '## VirusTotal scan file for [' + entry + '](' + obj.permalink + ')\n';
        md += 'Resource: **' + obj.resource + '**\n';
        md += 'Scan ID: **' + obj.scan_id + '**\n';
        md += 'MD5 / SHA1 / SHA256: **' + obj.md5 + ' / ' + obj.sha1 + ' / ' + obj.sha256 + '**\n';
        return {Type: entryTypes.note, Contents: result.Body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var rescanFile = function(hash) {
        var res = doReq('POST', 'file/rescan', {resource: hash});
        var r = [];
        if (Array.isArray(res.obj)) { // Got multiple hashes so need to nicely iterate
            r = res.obj;
        } else {
            r = [res.obj];
        }
        var md = '';
        var ec = {vtScanID: []};
        for (var i=0; i<r.length; i++) {
            md += '## VirusTotal File Rescan for: [' + r[i].resource + '](' + r[i].permalink + ')\n';
            md += 'Scan ID: **' + r[i].scan_id + '**\n';
            ec.vtScanID.push(r[i].scan_id);
            md += 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\n\n';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doComments = function(resource, comment) {
        var res = doReq('POST', 'comments/put', {resource: resource, comment: comment});
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: res.obj.verbose_msg};
    }

    var getComments = function(resource, before) {
        var params = {resource: resource};
        if (before) {
            params.before = before;
        }
        var res = doReq('GET', 'comments/get', params);
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: arrToMd(res.obj.comments)};
    }

    var fileScanUploadURL = function() {
        var res = doReq('GET', 'file/scan/upload_url');
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: res.obj.upload_url, EntryContext: {vtUploadURL: res.obj.upload_url}};
    }

    switch (command) {
        case 'test-module':
            doFile('7657fcb7d772448a6d8504e4b20168b8'); // Check sample file - it will throw an error if not successful
            return true;
        case 'file':
            return doFile(args.file, args.long, args.threshold, args.wait, args.retries);
        case 'ip':
            return doIP(args.ip, args.long, args.threshold, args.sampleSize, args.wait, args.retries);
        case 'url':
            return doURL(args.url, args.threshold, args.long, args.sampleSize, args.submitWait, args.wait, args.retries);
        case 'domain':
            return doDomain(args.domain, args.threshold, args.long, args.sampleSize, args.wait, args.retries);
        case 'file-scan':
            return scanFile(args.entryID, args.uploadURL);
        case 'file-rescan':
            return rescanFile(args.file);
        case 'url-scan':
            return scanURL(args.url);
        case 'vt-comments-add':
            return doComments(args.resource, args.comment);
        case 'vt-comments-get':
            return getComments(args.resource, args.before);
        case 'vt-file-scan-upload-url':
            return fileScanUploadURL();
        default:
            throw 'Unknown command - ' + command;
    }
  type: javascript
  commands:
  - name: file
    deprecated: false
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to query. Supports MD5, SHA1 and SHA256. Notice
        that you can pass comma-separated multiple values to efficiently retrieve
        multiple responses.
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with scans
      defaultValue: "false"
    - name: threshold
      description: If number of positives is bigger than the threshold we will consider
        it malicious
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: File.MD5
      description: Bad hash found
    - contextPath: File.SHA1
      description: Bad hash SHA1
    - contextPath: File.SHA256
      description: Bad hash SHA256
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: File.Malicious.Detections
      description: For malicious files. Total detections.
    - contextPath: File.Malicious.TotalEngines
      description: For malicious files. Total engines
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check file reputation of the given hash
  - name: ip
    deprecated: false
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: threshold
      description: If number of positive detected IPs is bigger than the threshold
        we will consider it malicious
      defaultValue: "10"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: IP.Address
      description: Bad IP Address found
    - contextPath: IP.ASN
      description: Bad IP ASN
    - contextPath: IP.Geo.Country
      description: Bad IP Country
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check IP Reputation
  - name: url
    deprecated: false
    arguments:
    - name: url
      required: true
      description: URL to be checked
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: threshold
      description: If number of positive detected URLs is bigger than the threshold
        we will consider it malicious
    - name: submitWait
      description: Seconds to wait if the URL does not exist and is submitted to be
        scanned
      defaultValue: "0"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check URL Reputation
  - name: domain
    deprecated: false
    arguments:
    - name: domain
      required: true
      default: true
      description: Domain name to check reputation
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected URLs
      defaultValue: "false"
    - name: sampleSize
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format
      defaultValue: "10"
    - name: threshold
      description: If number of positive detected domains is bigger than the threshold
        we will consider it malicious
      defaultValue: "10"
    - name: wait
      description: Wait time between tries if we reach the API rate limit in seconds
      defaultValue: "60"
    - name: retries
      description: Number of retries for API rate limit
      defaultValue: "0"
    outputs:
    - contextPath: Domain.Name
      description: Bad domain found
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check domain reputation
  - name: file-scan
    deprecated: false
    arguments:
    - name: entryID
      required: true
      default: true
      description: The file entry ID to submit
    - name: uploadURL
      description: Private API extension. Special upload URL for files bigger than
        32M.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files
    description: Submit a file for scanning
  - name: file-rescan
    deprecated: false
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to re-scan. Supports MD5, SHA1 and SHA256.
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files
    description: Rescan an already submitted file to save time and not upload
  - name: url-scan
    deprecated: false
    arguments:
    - name: url
      required: true
      default: true
      description: The URL to scan
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted URLs
    description: Scan a given URL
  - name: vt-comments-add
    deprecated: false
    arguments:
    - name: resource
      required: true
      default: true
      description: The hash (md5/sha1/sha256) or URL you're commenting on
    - name: comment
      required: true
      description: 'The actual review, you can tag it using the "#" twitter-like syntax
        (e.g. #disinfection #zbot) and reference users using the "@" syntax (e.g.
        @VirusTotalTeam).'
    description: Add comments for files and URLs
  - name: vt-file-scan-upload-url
    deprecated: false
    arguments: []
    outputs:
    - contextPath: vtUploadURL
      description: The special upload URL for large files
    description: Private API. Get a special URL for files above 32M.
  - name: vt-comments-get
    deprecated: false
    arguments:
    - name: resource
      required: true
      default: true
      description: The hash (md5/sha1/sha256) or URL you're retrieving comments for
    - name: before
      description: Datetime token in format YYYYMMDDHHMISS that can be used for paging
    description: Private API. Retrieve comments for a given resource
hidden: false
fromversion: 2.5.0
releaseNotes: 'Handling missing ASN scenario'