commonfields:
  id: google-vault
  version: -1
name: google-vault
display: Google Vault
category: IT Services
image: data:image/png;base64,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
description: Archiving and eDiscovery for G Suite.
configuration:
- display: Username
  name: gsuite_credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Authentication file contents
  name: auth_json
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (Unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |
    from googleapiclient.discovery import build
    from httplib2 import Http
    import json
    from oauth2client import file, client, tools, service_account
    from google.cloud import storage
    import dateparser
    import datetime

    #  @@@@@@@@ GLOBALS @@@@@@@@

    # If modifying these scopes, delete the file token.json.
    SCOPES = 'https://www.googleapis.com/auth/ediscovery'
    DEMISTO_MATTER = "test_search_phishing"

    ADMIN_EMAIL = demisto.params()["gsuite_credentials"]["identifier"].encode("utf-8")
    PRIVATE_KEY_CONTENT = demisto.params()["auth_json"].encode("utf-8")


    # @@@@@@@@ HELPER FUNCS @@@@@@@@

    def get_credentials(additional_scopes=None, delegated_user=ADMIN_EMAIL):
        """Gets valid user credentials from storage.
        If nothing has been stored, or if the stored credentials are invalid,
        the OAuth2 flow is completed to obtain the new credentials.
        Returns:
            Credentials, the obtained credential.
        """
        if delegated_user == 'me':
            delegated_user = ADMIN_EMAIL
        scopes = SCOPES
        if additional_scopes is not None:
            scopes += additional_scopes
        cred = service_account.ServiceAccountCredentials.from_json_keyfile_dict(json.loads(PRIVATE_KEY_CONTENT),
            scopes=scopes)
        return cred.create_delegated(delegated_user)


    def connect():
        creds = get_credentials()
        service = build('vault', 'v1', http=creds.authorize(Http()))
        return service


    def is_matter_exist(matter_name): # Not needed at the moment
        """
        Searches for existence of a matter by its name
        Note - this is case-sensitive
        :param matter_name: name of the matter to be searched
        :return: True if exists, False otherwise.
        """
        existing_matters = get_open_matters(service)
        if any(matter_name == matter['name'] for matter in existing_matters):
            return True
        return False


    def get_open_matters(service):
        """ Gets first 10 matters """
        open_matters = service.matters().list(state='OPEN').execute()
        return open_matters


    def get_matter_by_id(service, matter_id):
        matter = service.matters().get(matterId=matter_id).execute()
        return matter


    def get_matters_by_state(service, state):
        state = state.upper()
        matter_state = state if state in ('OPEN', 'CLOSED', 'DELETED') else 'STATE_UNSPECIFIED'
        matter_list = service.matters().list(state=matter_state).execute()
        return matter_list


    def get_matter_by_id(service, matter_id):
        return service.matters().get(matterId=matter_id).execute()


    def delete_matter(service, matter_id):
        delete_response = service.matters().delete(
            matterId=matter_id).execute()
        return get_matter_by_id(service, matter_id)  # Note - this is different that the other state updates


    def close_matter(service, matter_id):
        close_response = service.matters().close(matterId=matter_id, body={}).execute()
        return close_response['matter']


    def reopen_matter(service, matter_id):
        reopen_response = service.matters().reopen(matterId=matter_id, body={}).execute()
        return reopen_response['matter']


    def undelete_matter(service, matter_id):
        undeleted_matter = service.matters().undelete(matterId=matter_id, body={}).execute()
        return undeleted_matter


    def add_held_account(service, matter_id, hold_id, account_id):
        held_account = {'accountId': account_id}
        return service.matters().holds().accounts().create(matterId=matter_id, holdId=hold_id, body=held_account).execute()


    def remove_held_account(service, matter_id, hold_id, account_id):
        return service.matters().holds().accounts().delete(matterId=matter_id, holdId=hold_id, accountId=account_id).execute()


    def remove_hold(service, matter_id, hold_id):
        return service.matters().holds().delete(matterId=matter_id, holdId=hold_id).execute()


    def list_holds(service, matter_id):
        done_paginating = False
        holds = []
        response = service.matters().holds().list(
            matterId=matter_id).execute()
        # append first page:
        holds = response['holds']
        # Keep paginating and appending:
        while not done_paginating:
            if 'nextPageToken' in response:
                response = service.matters().holds.list(
                    pageSize=10, pageToken=response['nextPageToken']).execute()
                holds.extend(list_response2['holds'])
            else:
                done_paginating = True
        return holds


    def timeframe_to_utc_zulu_range(timeframe_str):
        '''
        Converts a time-frame to UTC Zulu format that can be used for startTime and endTime in various Google Vault requests.
        '''
        try:
            parsed_str = dateparser.parse(timeframe_str)
            end_time = datetime.datetime.utcnow().isoformat() + 'Z'  # Current time
            start_time = parsed_str.isoformat() + 'Z'
            return (start_time, end_time)
        except Exception, ex:
            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'Unable to parse date correctly: {}'.format(ex)})
            sys.exit(2)


    def create_hold_query(hold_name, corpus, accounts, terms, time_frame="", start_time="", end_time=""):
        '''
        Creates the query that will be used to request the creation of a new hold. Returns the ready-to-be-sent request.
        '''
        # --- Sanitizing Input ---
        corpus = corpus.upper()
        if time_frame:
            start_time, end_time = timeframe_to_utc_zulu_range(time_frame)  # Making it UTC Zulu format
        elif start_time:
            if not end_time:
                end_time = datetime.datetime.utcnow().isoformat() + 'Z'  # End time will be now, if no end time was given
        if isinstance(accounts, unicode):
            accounts = accounts.split(',')

        # --- Building Request ---
        request = {}
        mail_query = {}
        accounts_for_query = []
        if not terms:
            if start_time and end_time:
                mail_query = {'startTime': start_time, 'endTime': end_time}
        else:
            if start_time and end_time:
                mail_query = {'startTime': start_time, 'endTime': end_time, 'terms': terms}

        # --- Building all small parts into big request object ---
        request['name'] = hold_name
        request['corpus'] = corpus
        if mail_query:
            request['query'] = {'mailQuery': mail_query} # Adding the ready mail query
        for acc_id in accounts:
            accounts_for_query.append({'accountId': acc_id})
        request['accounts'] = accounts_for_query
        return request


    def create_hold_mail_accounts(service, matter_id, request_body):
        '''
        Creates a hold in Google Vault
        '''
        return service.matters().holds().create(matterId=matter_id, body=request_body).execute()


    def create_export(service, matter, request_body):
        '''
        Creates an export in the given matter, with the given request_body (which is the actual JSON for the request).
        '''
        return service.matters().exports().create(matterId=matter, body=request_body).execute()


    def create_mail_export_query(export_name, emails, time_frame, start_time, end_time, terms, org_unit="", export_pst="True", export_mbox="False", search_method="All Accounts", include_drafts="True", data_scope="All Data"):
        '''
        Creates the query that will be used in the request to create a mail export
        '''
        org_unit_id = org_unit
        # --- Sanitizing Input ---
        exclude_drafts = "false"
        if time_frame:
            start_time, end_time = timeframe_to_utc_zulu_range(time_frame)  # Making it UTC Zulu format
        elif start_time:
            if not end_time:
                end_time = datetime.datetime.utcnow().isoformat() + 'Z'  # End time will be now, if no end time was given
        if isinstance(emails, basestring):
            if ',' in emails:
                emails = emails.split(',')
            else:
                emails = [emails]
        if str(include_drafts).upper() == "FALSE":
            exclude_drafts = "true"
        if data_scope.upper() == "HELD DATA":
            data_scope = "HELD_DATA"
        if data_scope.upper() == "ALL DATA":
            data_scope = "ALL_DATA"
        if data_scope.upper() == "UNPROCESSED DATA":
            data_scope = "UNPROCESSED_DATA"
        if search_method.upper() == "ORGANIZATIONAL UNIT(REQUIRES OU ARGUMENT)":
            search_method = "ORG_UNIT"
        if search_method.upper() == "ALL ACCOUNTS":
            search_method = "ENTIRE_ORG"
        if search_method.upper() == "SPECIFIC ACCOUNTS(REQUIRES EMAILS ARGUMENT)":
            search_method = "ACCOUNT"

        # --- Building Request ---
        request = {}
        query = {}
        emails_for_query = []
        account_info = { 'emails': [] }
        org_unit_info = {'orgUnitId': org_unit_id}
        corpus = "MAIL"
        export_format = "PST"  # Default
        if export_mbox.upper() == "TRUE":
            export_format = "MBOX"
        mail_options = {
            'exportFormat': export_format
        }

        # --- Building all small parts into big request object ---
        query['dataScope'] = data_scope
        query['searchMethod'] = search_method
        query['corpus'] = corpus
        query['mailOptions'] = { 'excludeDrafts': exclude_drafts }
        if start_time and end_time:
            query['startTime'] = start_time
            query['endTime'] = end_time
        if terms:
            query['terms'] = terms
        if emails:  # If user specified emails
            for email in emails:  # Go over all of them
                emails_for_query.append(email)  # Add them to the list
            account_info['emails'] = emails_for_query  # Add the list to the account_info dictionary
            query['accountInfo'] = account_info  # Add the account_info dictionary into the query object
        if search_method == "ORG_UNIT":
            query['orgUnitInfo'] = org_unit_info
        request['query'] = query # Adding query AFTER IT'S COMPLETED
        request['exportOptions'] = { 'mailOptions': mail_options }
        request['name'] = export_name
        return request

    def create_drive_export_query(export_name, emails, team_drives, time_frame, start_time, end_time, terms, org_unit="", search_method="Specific Accounts(requires emails argument)", include_teamdrives="True", data_scope="All Data"):
        '''
        Creates the query that will be used in the request to create a groups export
        '''
        org_unit_id = org_unit
        # --- Sanitizing Input ---
        include_teamdrives = "true"
        if time_frame:
            start_time, end_time = timeframe_to_utc_zulu_range(time_frame)  # Making it UTC Zulu format
        elif start_time:
            if not end_time:
                end_time = datetime.datetime.utcnow().isoformat() + 'Z'  # End time will be now, if no end time was given
        if isinstance(emails, basestring):  # If emails were specified, making it a list:
            if ',' in emails:
                emails = emails.split(',')
            else:
                emails = [emails]
        if isinstance(team_drives, basestring): # If team_drives were specified, making it a list:
            if ',' in team_drives:
                team_drives = team_drives.split(',')
            else:
                team_drives = [team_drives]
        if str(include_teamdrives).upper() == "FALSE":
            include_teamdrives = "false"
        if data_scope.upper() == "HELD DATA":
            data_scope = "HELD_DATA"
        if data_scope.upper() == "ALL DATA":
            data_scope = "ALL_DATA"
        if data_scope.upper() == "UNPROCESSED DATA":
            data_scope = "UNPROCESSED_DATA"
        if search_method.upper() == "ORGANIZATIONAL UNIT(REQUIRES OU ARGUMENT)":
            search_method = "ORG_UNIT"
        if search_method.upper() == "SPECIFIC ACCOUNTS(REQUIRES EMAILS ARGUMENT)":
            search_method = "ACCOUNT"
        if search_method.upper() == "TEAM DRIVE":
            search_method = "TEAM_DRIVE"

        # --- Building Request ---
        request = {}
        query = {}
        emails_for_query = []
        teamdrives_for_query = []
        account_info = { 'emails': [] }
        teamdrive_info = {'teamDriveIds' : []}
        org_unit_info = {'orgUnitId': org_unit_id}
        corpus = "DRIVE"

        # --- Building all small parts into big request object ---
        query['dataScope'] = data_scope
        query['searchMethod'] = search_method
        query['corpus'] = corpus
        query['driveOptions'] = { 'includeTeamDrives': include_teamdrives }
        if start_time and end_time:
            query['startTime'] = start_time
            query['endTime'] = end_time
        if terms:
            query['terms'] = terms
        if emails:  # If user specified emails
            for email in emails:  # Go over all of them
                emails_for_query.append(email)  # Add them to the list
            account_info['emails'] = emails_for_query  # Add the list to the account_info dictionary
        if team_drives and include_teamdrives.upper() == "TRUE": # If user specified team_drives and not emails
            for teamdrive_id in team_drives:
                teamdrives_for_query.append(teamdrive_id)
            teamdrive_info['teamDriveIds'] = teamdrives_for_query
        if search_method == "ORG_UNIT":
            query['orgUnitInfo'] = org_unit_info
        if search_method == "TEAM_DRIVE":
            query['teamDriveInfo'] = teamdrive_info
        if search_method == "ACCOUNT":
            query['accountInfo'] = account_info  # Add the account_info dictionary into the query object. This line SHOULD NOT exist if the user wants to use team_drives.
        request['query'] = query # Adding query AFTER IT'S COMPLETED
        request['name'] = export_name
        return request


    def create_groups_export_query(export_name, emails, time_frame, start_time, end_time, terms, search_method, export_pst="True", export_mbox="False", data_scope="All Data"):
        '''
        Creates the query that will be used in the request to create a groups export
        '''
        # --- Sanitizing Input ---
        if time_frame:
            start_time, end_time = timeframe_to_utc_zulu_range(time_frame)  # Making it UTC Zulu format
        elif start_time:
            if not end_time:
                end_time = datetime.datetime.utcnow().isoformat() + 'Z'  # End time will be now, if no end time was given
        if isinstance(emails, basestring):
            if ',' in emails:
                emails = emails.split(',')
            else:
                emails = [emails]
        if data_scope.upper() == "HELD DATA":
            data_scope = "HELD_DATA"
        if data_scope.upper() == "ALL DATA":
            data_scope = "ALL_DATA"
        if data_scope.upper() == "UNPROCESSED DATA":
            data_scope = "UNPROCESSED_DATA"

        # --- Building Request ---
        request = {}
        query = {}
        emails_for_query = []
        account_info = { 'emails': [] }
        corpus = "GROUPS"
        export_format = "PST"  # Default
        if export_mbox.upper() == "TRUE":
            export_format = "MBOX"
        groups_options = {
            'exportFormat': export_format
        }

        # --- Building all small parts into big request object ---
        query['dataScope'] = data_scope
        query['searchMethod'] = search_method
        query['corpus'] = corpus
        if start_time and end_time:
            query['startTime'] = start_time
            query['endTime'] = end_time
        if terms:
            query['terms'] = terms
        if emails:  # If user specified emails
            for email in emails:  # Go over all of them
                emails_for_query.append(email)  # Add them to the list
            account_info['emails'] = emails_for_query  # Add the list to the account_info dictionary
            query['accountInfo'] = account_info  # Add the account_info dictionary into the query object
        request['query'] = query # Adding query AFTER IT'S COMPLETED
        request['exportOptions'] = { 'groupsOptions': groups_options }
        request['name'] = export_name
        return request


    def get_export_by_id(service, matter_id, export_id):
        return service.matters().exports().get(matterId=matter_id, exportId=export_id).execute()

    def list_held_accounts(service, matter_id, hold_id):
        return service.matters().holds().accounts().list(matterId=matter_id, holdId=hold_id).execute()['accounts']

    def remove_held_accounts(service, matter_id, hold_id):
        pass


    # @@@@@@@@ ACTUAL FUNCS @@@@@@@@

    def list_matters_command():
        '''
        Lists all matters in the project, with their corresponding state.
        '''
        service = connect()
        state = demisto.args().get('state', "STATE_UNSPECIFIED")
        matters = (get_matters_by_state(service, state))['matters']
        if not matters:
            demisto.results('No matters found.')
        else:
            output = []
            context_output = []
            for matter in matters:
                output.append({
                    'Matter Name': matter.get('name'),
                    'Matter ID': matter.get('matterId'),
                    'Matter State': matter.get('state')
                })
                context_output.append({
                    'Name': matter.get('name'),
                    'ID': matter.get('matterId'),
                    'State': matter.get('state')  # Getting new state
                    })
            markdown = '' # Use this to add extra line
            title = ""
            if state == "All" or not state:
                title = "Here are all your matters"
            else:
                title = "Here are your {} matters".format(state.lower())
            markdown += tableToMarkdown(title, output, ['Matter Name', 'Matter ID', 'Matter State'])

            demisto.results( {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': matters,
                'HumanReadable': markdown,
                'EntryContext': {
                    'GoogleVault.Matter(val.ID == obj.ID)': context_output
                             }
            } )


    def create_matter_command():
        service = connect()
        matter_name = demisto.getArg('name')
        matter_description = demisto.getArg('description')
        matter_content =   {
          'name': matter_name,
          'description': matter_description,
        }
        matter = service.matters().create(body=matter_content).execute()
        markdown = ""
        if matter_description:
            markdown = "Matter: {} was created successfully with description: {}.\nID: {}.".format(matter_name, matter_description, matter.get('matterId'))
        else:
            markdown = "Matter: {} was created successfully without a description.\nID: {}.".format(matter_name, matter.get('matterId'))
        title = "Matter creation successful."
        markdown_matter = []
        markdown_matter.append({
        'Matter Name': matter.get('name'),
        'Matter ID': matter.get('matterId'),
        'Matter State': matter.get('state')
        })
        markdown += tableToMarkdown(title, markdown_matter, ['Matter Name', 'Matter ID', 'Matter State']) #  Why is the title displayed in a weird way?

        output_context = []
        output_context.append({
        'Name': matter.get('name'),
        'ID': matter.get('matterId'),
        'State': matter.get('state')
        })

        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': matter,
            'HumanReadable': markdown,
            'EntryContext': {
            'GoogleVault.Matter(val.ID == obj.ID)': output_context
           }
        })


    def update_matter_state_command():
        """
        * Note: This updates context only if a change in the current state was successful
        """
        service = connect()
        matter_id = demisto.getArg('matterID')
        wanted_state = demisto.getArg('state')
        matter_found = get_matter_by_id(service, matter_id)
        current_state = matter_found.get('state')
        if current_state: # if a matter was found with that ID:
            context_output = []
            result_of_update = ""
            # Dealing with CLOSE:
            if wanted_state ==  'CLOSE':
                if current_state == 'DELETED':
                    result_of_update = "Matter is deleted and so it cannot be closed. It's possible to re-open it and then close."
                elif current_state == 'CLOSED':
                    demisto.results("Matter is already closed.")
                elif current_state == 'OPEN':
                    try:
                        close_response = close_matter(service, matter_id)
                        result_of_update = "Matter was successfully closed."
                    except Exception, ex:
                        if "Matters have users on hold" in str(ex):
                            demisto.log("{}".format(ex))
                            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'The matter has holds that prevent it from being closed.'})
                            sys.exit(2)

            # Dealing with DELETE:
            elif wanted_state == 'DELETE':
                if current_state == 'OPEN':
                    try:
                        close_response = close_matter(service, matter_id) # Todo: check if contains holds. If it does, return error to user
                        delete_response = delete_matter(service, matter_id)
                        result_of_update = "Matter was {} and is now DELETED.".format(current_state)
                    except Exception, ex:
                        if "Matters have users on hold" in str(ex):
                            demisto.log("{}".format(ex))
                            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'The matter has holds that prevent it from being deleted.'})
                            sys.exit(2)
                elif current_state == 'CLOSED':
                    try:
                        delete_response = delete_matter(service, matter_id)
                        result_of_update = "Matter was {} and is not DELETED.".format(current_state)
                    except Exception, ex:
                        if "Matters have users on hold" in str(ex):
                            demisto.log("{}".format(ex))
                            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'The matter has holds that prevent it from being deleted.'})
                            sys.exit(2)
                elif current_state == 'DELETED':
                    demisto.results("Matter is already deleted.")

            # Dealing with REOPEN:
            elif wanted_state == 'REOPEN':
                if current_state == 'OPEN':
                    demisto.results("Matter is already open.")
                elif current_state == 'CLOSED':
                    reopen_response = reopen_matter(service, matter_id)
                    result_of_update = "Matter was {} and is now OPEN.".format(current_state)
                elif current_state == 'DELETED':
                    undelete_response = undelete_matter(service, matter_id)
                    reopen_response = reopen_matter(service, matter_id)
                    result_of_update = "Matter was {} and is now OPEN.".format(current_state)

            # Dealing with UNDELETE:
            elif wanted_state == 'UNDELETE':
                if current_state == 'OPEN':
                    demisto.results("Matter is already open.")
                elif current_state == 'CLOSED':
                    demisto.results("Matter is closed at the moment.")
                elif current_state == 'DELETED':
                    undelete_response = undelete_matter(service, matter_id)
                    result_of_update = "Matter was {} and is now CLOSED.".format(current_state)

            if result_of_update:  # If an update was done then update context:
                context_output.append({
                'Name': matter_found.get('name'),
                'ID': matter_found.get('matterId'),
                'State': get_matter_by_id(service, matter_id).get('state')  # Getting new state
                    })

                demisto.results( {
                    'Type': entryTypes['note'],
                    'ContentsFormat': formats['text'],
                    'Contents': result_of_update,
                    'EntryContext': {
                    'GoogleVault.Matter(val.ID == obj.ID)': context_output
                                 }
                 })
        else:
            demisto.results("No matter was found with that ID.")  # Todo: never gets here. Gotta catch the exception


    def add_account_to_hold_command():  # Todo: Not sure if context is good (It works, but maybe not according to conventions)
        service = connect()
        matter_id = demisto.getArg('matterID')
        hold_id = demisto.getArg('holdID')
        account_id = demisto.getArg('accountID')
        response = add_held_account(service, matter_id, hold_id, account_id)

        msg_to_usr = "Account {} was successfully added to hold {} in matter {}".format(account_id, hold_id, matter_id)
        context_output = []
        context_output.append({
            "ID": hold_id,
            "matterID": matter_id,
            "HeldAccount": {
                "accountID": account_id,
                "IsHeld": True
                }
        })

        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': msg_to_usr,
            'EntryContext': {
            'GoogleVault.Hold(val.ID == obj.ID)': context_output
                         }
         })


    def search_matter_command():
        """
        * This can be highly optimized. What it currently does is search ALL matters and then filter by name / ID
        * If a matter with an ID is found, there's no need to keep on searching. This can be optimized too.
        * Note - this is case INSENSITIVE. Searching for "MatTER1" will find "matter1" too.
        """
        service = connect()
        wanted_name = demisto.getArg('matterName')
        wanted_id = demisto.getArg('matterID')
        if wanted_name or wanted_id:
            if wanted_name:
                wanted_name = wanted_name.lower()
            if wanted_id:
                wanted_id = wanted_id.lower()
        else:
            demisto.results("No name or ID were specified. Please specify at least one of them.")
            sys.exit(0)
        matters = get_matters_by_state(service, state='STATE_UNSPECIFIED')['matters']
        output = []
        markdown_matters = []
        found_anything = False
        for matter in matters:
            if matter.get('name').lower() == wanted_name or matter.get('matterId').lower() == wanted_id:
                found_anything = True
                markdown_matters.append({
                    'Matter Name': matter.get('name'),
                    'Matter ID': matter.get('matterId'),
                    'Matter State': matter.get('state')
                })
                output.append({
                    'Name': matter.get('name'),
                    'ID': matter.get('matterId'),
                    'State': matter.get('state')
                })
        if not found_anything: # If finished for loop through matters and no matter was found
            demisto.results('No matters found.')
        else:
            markdown = '' # Use this to add extra line
            if wanted_name:
                title = "Here are matters that have the name {}".format(wanted_name)
            else:
                title = "Here is the matter with ID {}".format(wanted_id)
            markdown += tableToMarkdown(title, markdown_matters, ['Matter Name', 'Matter ID', 'Matter State'])
            demisto.results( {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': markdown_matters,
                'HumanReadable': markdown,
                'EntryContext': {
                    'GoogleVault.Matter(val.ID == obj.ID)': output
                }
            } )


    def remove_account_from_hold_command():
        service = connect()
        matter_id = demisto.getArg('matterID')
        hold_id = demisto.getArg('holdID')
        account_id = demisto.getArg('accountID')
        response = remove_held_account(service, matter_id, hold_id, account_id)

        msg_to_usr = "Account {} was successfully removed from hold {} in matter {}".format(account_id, hold_id, matter_id)
        context_output = []
        context_output.append({
        'matterID': matter_id,
        "ID": hold_id,
        "HeldAccount": {  # Does this allow only 1 HeldAccount to exist in a hold?
            "ID": account_id,
            "IsHeld": False
            },
        })
        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': msg_to_usr,
            'EntryContext': {
            'GoogleVault.Hold(val.ID == obj.ID)': context_output
                         }
         })


    def delete_hold_command():
        service = connect()
        matter_id = demisto.getArg('matterID')
        hold_id = demisto.getArg('holdID')
        response = remove_hold(service, matter_id, hold_id)
        msg_to_usr = "Hold {} was successfully deleted from matter {}".format(hold_id, matter_id)
        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': msg_to_usr,
         })


    def list_holds_command():
        service = connect()
        matter_id = demisto.getArg('matterID')
        holds = list_holds(service, matter_id)
        if not holds:
            demisto.results('No holds found.')
        else:
            output = []
            context_output = []
            for hold in holds:
                output.append({
                    'Matter ID': matter_id,
                    'Hold Name': hold.get('name'),
                    'Hold ID': hold.get('holdId')
                })
                context_output.append({
                    'name': hold.get('name'),
                    'ID': hold.get('holdId'),
                    'matterID': matter_id
                    })
            markdown = '' # Use this to add extra line
            title = "Here are all the holds under matter {}.".format(matter_id)
            markdown += tableToMarkdown(title, output, ['Hold Name', 'Hold ID', 'Matter ID'])

            demisto.results( {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': holds,
                'HumanReadable': markdown,
                'EntryContext': {
                    'GoogleVault.Hold(val.ID == obj.ID)': context_output
                             }
            } )


    def create_hold_command():
        service = connect()
        matter_id = demisto.getArg('matterID')
        hold_name = demisto.getArg('holdName')
        corpus = demisto.getArg('corpus')
        accounts = demisto.getArg('accountID')
        time_frame = demisto.getArg('timeFrame')
        start_time = demisto.getArg('startTime')
        end_time = demisto.getArg('endTime')
        terms = demisto.getArg('terms')
        query = create_hold_query(hold_name, corpus, accounts, time_frame, start_time, end_time, terms)
        response = ""
        try:
            response = create_hold_mail_accounts(service, matter_id, query)
        except Exception, ex:
            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'Unable to create hold. Error: {}'.format(ex)})
            sys.exit(2)
        hold_id = response['holdId']
        output = []
        context_output = []
        output.append({
            'Hold Name': hold_name,
            'Hold ID': hold_id
        })
        context_output.append({
            'name': hold_name,
            'ID': hold_id,
            'matterID': matter_id
            })
        markdown = '' # Use this to add extra line
        title = "Here are the details of your newly created hold:"
        markdown += tableToMarkdown(title, output, ['Hold Name', 'Hold ID'])
        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {"Hold Name": hold_name, "Hold ID": hold_id},
            'HumanReadable': markdown,
            'EntryContext': {
                'GoogleVault.Hold(val.ID == obj.ID)': context_output
                         }
        } )


    def create_mail_export_command():
        '''
        Creates a mail export in Google Vault
        '''
        service = connect()
        matter_id = demisto.getArg('matterID')
        export_name = demisto.getArg('exportName')
        data_scope = demisto.getArg('dataScope')
        search_method = demisto.getArg('searchMethod')
        emails = demisto.getArg('emails')
        include_drafts = demisto.getArg('includeDrafts')
        start_time = demisto.getArg('startTime')
        end_time = demisto.getArg('endTime')
        time_frame = demisto.getArg('timeFrame')
        terms = demisto.getArg('terms')
        export_pst = demisto.getArg('exportPST')
        export_mbox = demisto.getArg('exportMBOX')
        org_unit = demisto.getArg('ou')

        query =  create_mail_export_query(export_name, emails, time_frame, start_time, end_time, terms, org_unit, export_pst, export_mbox, search_method, include_drafts, data_scope)
        response = ""
        try:
            response = create_export(service, matter_id, query)
        except Exception, ex:
            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'Unable to create export. Error: {}'.format(ex)})
            sys.exit(2)
        create_time = response.get('createTime')
        export_id = response.get('id')

        context_output = []
        context_output.append({
            'MatterID': matter_id,
            'ID': export_id,
            'Name': export_name,
            'CreateTime': create_time
        })
        title = "A new export has been created successfully:\n"
        output_for_markdown = {  # This one is for tableToMarkdown to correctly map
            'Matter ID': matter_id,
            'Export ID': export_id,
            'Export Name': export_name,
            'Created Time': create_time
        }
        markdown = tableToMarkdown(title, output_for_markdown, ['Matter ID', 'Export ID', 'Export Name', 'Created Time'])
        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': context_output,
            'HumanReadable': markdown,
            'EntryContext': {
                'GoogleVault.Export(val.ID == obj.ID)': context_output
            }
        })


    def create_drive_export_command():
        service = connect()
        matter_id = demisto.getArg('matterID')
        export_name = demisto.getArg('exportName')
        data_scope = demisto.getArg('dataScope')
        search_method = demisto.getArg('searchMethod')
        emails = demisto.getArg('emails')
        org_unit = demisto.getArg('ou')
        team_drives = demisto.getArg('teamDrive')
        include_teamdrives = demisto.getArg('includeTeamDrives')
        time_frame = demisto.getArg('timeFrame')
        start_time = demisto.getArg('startTime')
        end_time = demisto.getArg('endTime')
        terms = demisto.getArg('terms')

        query =  create_drive_export_query(export_name, emails, team_drives, time_frame, start_time, end_time, terms, org_unit, search_method, include_teamdrives, data_scope)
        response = ""
        try:
            response = create_export(service, matter_id, query)
        except Exception, ex:
            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'Unable to create export. Error: {}'.format(ex)})
            sys.exit(2)
        create_time = response.get('createTime')
        export_id = response.get('id')

        context_output = []
        context_output.append({
            'MatterID': matter_id,
            'ID': export_id,
            'Name': export_name,
            'CreateTime': create_time
        })
        title = "A new export has been created successfully:\n"
        output_for_markdown = {  # This one is for tableToMarkdown to correctly map
            'Matter ID': matter_id,
            'Export ID': export_id,
            'Export Name': export_name,
            'Created Time': create_time
        }
        markdown = tableToMarkdown(title, output_for_markdown, ['Matter ID', 'Export ID', 'Export Name', 'Created Time'])
        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': context_output,
            'HumanReadable': markdown,
            'EntryContext': {
                'GoogleVault.Export(val.ID == obj.ID)': context_output
            }
        })


    def create_groups_export_command():
        service = connect()
        matter_id = demisto.getArg('matterID')
        export_name = demisto.getArg('exportName')
        data_scope = demisto.getArg('dataScope')
        search_method = "ACCOUNT"  # Hard-coded only for groups export
        emails = demisto.getArg('groups')
        start_time = demisto.getArg('startTime')
        end_time = demisto.getArg('endTime')
        time_frame = demisto.getArg('timeFrame')
        terms = demisto.getArg('terms')
        export_pst = demisto.getArg('exportPST')
        export_mbox = demisto.getArg('exportMBOX')

        query =  create_groups_export_query(export_name, emails, time_frame, start_time, end_time, terms, search_method, export_pst, export_mbox, data_scope)
        response = ""
        try:
            response = create_export(service, matter_id, query)
        except Exception, ex:
            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'Unable to create export. Error: {}'.format(ex)})
            sys.exit(2)
        create_time = response.get('createTime')
        export_id = response.get('id')

        context_output = []
        context_output.append({
            'MatterID': matter_id,
            'ID': export_id,
            'Name': export_name,
            'CreateTime': create_time
        })
        title = "A new export has been created successfully:\n"
        output_for_markdown = {  # This one is for tableToMarkdown to correctly map
            'Matter ID': matter_id,
            'Export ID': export_id,
            'Export Name': export_name,
            'Created Time': create_time
        }
        markdown = tableToMarkdown(title, output_for_markdown, ['Matter ID', 'Export ID', 'Export Name', 'Created Time'])
        demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': context_output,
            'HumanReadable': markdown,
            'EntryContext': {
                'GoogleVault.Export(val.ID == obj.ID)': context_output
            }
        })


    def get_export_command():
        service = connect()
        matter_id = demisto.getArg('matterId')
        export_id = demisto.getArg('exportID')
        try:
            response = get_export_by_id(service, matter_id, export_id)
            usr_msg = "Here are your export details:\nMatter ID: {}\nExport ID: {}\nExport Name: {}\nExporting Status: {}.".format(matter_id, export_id, response.get('name'), response.get('status'))
            export_name = response.get('name')
            export_status = response.get('status')
            context_output = []
            context_output.append({
                'MatterID': matter_id,
                'ID': export_id,
                'Name': export_name,
                'Status': export_status
            })
            demisto.results( {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': context_output,
            'HumanReadable': usr_msg,
            'EntryContext': {
                'GoogleVault.Export(val.ID == obj.ID)': context_output
                             }
            })
        except Exception, ex:
            demisto.results( { "Type" : entryTypes["error"], "ContentsFormat" : formats["text"], "Contents" : 'Unable to get export. Error: {}'.format(ex)})
            sys.exit(2)


    # @@@@@@@@ DEMISTO COMMANDS @@@@@@@@

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        try:
            service = connect()
            get_matters_by_state(service, "STATE_UNSPECIFIED")
            demisto.results('ok')
            sys.exit(0)
        except Exception, ex:
            return_error(ex.message)
    elif demisto.command() == 'gvault-list-matters':
        list_matters_command()
    elif demisto.command() == 'gvault-create-matter':
        create_matter_command()
    elif demisto.command() == 'gvault-matter-update-state':
        update_matter_state_command()
    elif demisto.command() == 'gvault-add-heldAccount':
        add_account_to_hold_command()
    elif demisto.command() == 'gvault-get-matter':
        search_matter_command()
    elif demisto.command() == 'gvault-remove-heldAccount':
        remove_account_from_hold_command()
    elif demisto.command() == 'gvault-delete-hold':
        delete_hold_command()
    elif demisto.command() == 'gvault-list-holds':
        list_holds_command()
    elif demisto.command() == 'gvault-create-hold':
        create_hold_command()
    elif demisto.command() == 'gvault-create-export-mail':
        create_mail_export_command()
    elif demisto.command() == 'gvault-create-export-drive':
        create_drive_export_command()
    elif demisto.command() == 'gvault-create-export-groups':
        create_groups_export_command()
    elif demisto.command() == 'gvault-export-status':
        get_export_command()
  type: python
  commands:
  - name: gvault-create-export-mail
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: exportName
      required: true
      description: Export Name
    - name: dataScope
      auto: PREDEFINED
      predefined:
      - All Data
      - Held Data
      - Unprocessed Data
      description: Choice of Search scope
      defaultValue: All Data
    - name: searchMethod
      auto: PREDEFINED
      predefined:
      - All Accounts
      - Specific Accounts(requires emails argument)
      - Organizational Unit(requires ou argument)
      description: Choice of Search method
      defaultValue: All Accounts
    - name: emails
      description: If the search method is set to Specific Accounts (separated by
        comma)
    - name: ou
      description: The organizational unit (specify only if the search method is set
        to Organizational Unit)
    - name: includeDrafts
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Include/Exclude drafts in the search
      defaultValue: "true"
    - name: timeFrame
      description: 'Search time frame. E.g: "1 min ago","2 weeks ago","3 months ago"'
    - name: startTime
      description: UTC start time (2018-10-16T12:59:02.584000Z)
    - name: endTime
      description: UTC end time (2018-10-16T12:59:02.584000Z)
    - name: terms
      description: Add specific terms for the search (subject:example)
    - name: exportPST
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Export format
      defaultValue: "true"
    - name: exportMBOX
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Export format
      defaultValue: "false"
    outputs:
    - contextPath: GoogleVault.Export.MatterID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Export.ID
      description: Export ID
      type: string
    - contextPath: GoogleVault.Export.Name
      description: Export's name
      type: string
    - contextPath: GoogleVault.Export.CreateTime
      description: Export's creation time
      type: string
    description: Creates a Google Vault export in order to perform search actions
      on emails.
  - name: gvault-create-matter
    arguments:
    - name: name
      required: true
      description: New matter's name
    - name: description
      description: Description for the matter
    outputs:
    - contextPath: GoogleVault.Matter.Name
      description: Matter Name
      type: string
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Matter.State
      description: Matter's state
      type: string
    description: Creates a new matter with the given name and description. The initial
      state is open, and the owner is the method caller. First, checks if a matter
      with the same name already exists.
  - name: gvault-create-export-drive
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: exportName
      required: true
      description: Export Name
    - name: dataScope
      auto: PREDEFINED
      predefined:
      - All Data
      - Held Data
      - Unprocessed Data
      description: Choice of Search scope
      defaultValue: All Data
    - name: searchMethod
      auto: PREDEFINED
      predefined:
      - Specific Accounts(requires emails argument)
      - Organizational Unit(requires ou argument)
      - Team Drive
      description: Choice of Search method
      defaultValue: Specific Accounts(requires emails argument)
    - name: emails
      description: If the search method is set to Specific Accounts (separated by
        comma)
    - name: ou
      description: The organizational unit (specify only if the search method is set
        to Organizational Unit)
    - name: teamDrive
      description: If the search method is set to Team Drives
    - name: includeTeamDrives
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Include/Exclude team drives
      defaultValue: "true"
    - name: timeFrame
      description: Search time frame
    - name: startTime
      description: UTC start time (2018-10-16T12:59:02.584000Z)
    - name: endTime
      description: UTC end time (2018-10-16T12:59:02.584000Z)
    - name: terms
      description: Add specific terms for the search
    outputs:
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Matter.Export.ID
      description: Export ID
      type: string
    - contextPath: GoogleVault.Matter.Export.Name
      description: Export's name
      type: string
    - contextPath: GoogleVault.Matter.Export.CreateTime
      description: Export's creation time
      type: string
    description: Creates a Google Vault export in order to perform search actions
      on drives.
  - name: gvault-matter-update-state
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: state
      required: true
      auto: PREDEFINED
      predefined:
      - CLOSE
      - DELETE
      - REOPEN
      - UNDELETE
      description: New matter state
    outputs:
    - contextPath: GoogleVault.Matter.Name
      description: Matter name
      type: string
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Matter.State
      description: Matter's state
      type: string
    description: Change the matter's state
  - name: gvault-create-export-groups
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: exportName
      required: true
      description: Export Name
    - name: dataScope
      auto: PREDEFINED
      predefined:
      - All Data
      - Held Data
      - Unprocessed Data
      description: 'Choice of Search scope '
      defaultValue: All Data
    - name: groups
      required: true
      description: Enter one or more Groups separated by commas. You can search up
        to 50 Groups.
    - name: timeFrame
      description: Search time frame
    - name: startTime
      description: UTC start time (2018-10-16T12:59:02.584000Z)
    - name: endTime
      description: UTC end time (2018-10-16T12:59:02.584000Z)
    - name: terms
      description: Add specific terms for the search
    - name: exportPST
      default: true
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Export format
      defaultValue: "true"
    - name: exportMBOX
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Export format
      defaultValue: "false"
    outputs:
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Matter.Export.ID
      description: Export ID
      type: string
    - contextPath: GoogleVault.Matter.Export.Name
      description: Export's name
      type: string
    - contextPath: GoogleVault.Matter.Export.CreateTime
      description: Export's creation time
      type: string
    description: Creates a Google Vault Export in order to perform search actions
      on Google groups.
  - name: gvault-create-hold
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: holdName
      required: true
      description: New hold's name
    - name: corpus
      required: true
      auto: PREDEFINED
      predefined:
      - Mail
      - Drive
      - Groups
      description: New hold's corpus type
    - name: accountID
      required: true
      description: At least one account/group ID to place in the hold (comma separated)
      isArray: true
    - name: timeFrame
      description: User's choice for search time.
    - name: startTime
      description: UTC start time (1994-11-05T13:15:30Z )
    - name: endTime
      description: UTC end time (1994-11-05T13:15:30Z )
    - name: terms
      description: The terms that must be met for a message to be covered by this
        hold.
    outputs:
    - contextPath: GoogleVault.Matter.Hold.Name
      description: Hold name
      type: string
    - contextPath: GoogleVault.Matter.Hold.ID
      description: Hold ID
      type: string
    - contextPath: GoogleVault.Matter.Hold.Account.ID
      description: Held account ID
      type: string
    description: 'Creates a hold in the given matter. Holds are used to preserve data
      in the organization. '
  - name: gvault-add-heldAccount
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: holdID
      required: true
      description: Hold ID
    - name: accountID
      required: true
      description: Account/group ID to place in hold
    outputs:
    - contextPath: GoogleVault.Matter.Hold.Account.ID
      description: Held account ID
    description: 'Adds a Held Account to a hold. This structure is immutable. '
  - name: gvault-remove-heldAccount
    arguments:
    - name: matterID
      required: true
      description: Provide the wanted matter ID
    - name: holdID
      required: true
      description: Provide the wanted hold ID
    - name: accountID
      required: true
      description: Account ID to remove from hold
    description: Removes a Held Account from a hold.
  - name: gvault-delete-hold
    arguments:
    - name: matterID
      required: true
      description: Matter ID
    - name: holdID
      required: true
      description: Hold ID
    description: Removes a hold by ID. This will release any Held Accounts on this
      Hold.
  - name: gvault-list-matters
    arguments:
    - name: state
      auto: PREDEFINED
      predefined:
      - All
      - Open
      - Closed
      - Deleted
      description: 'If set, list only matters with that specific state. The default
        is listing matters of all states. '
      defaultValue: All
    outputs:
    - contextPath: GoogleVault.Matter.Name
      description: Matter Name
      type: string
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Matter.State
      description: Matter's state
      type: string
    description: Lists matters the user has access to.
  - name: gvault-get-matter
    arguments:
    - name: matterName
      description: Search by matter name (More than one matter with the same name
        can exist)
    - name: matterID
      description: Search by matter ID (Unique Identifier)
    outputs:
    - contextPath: GoogleVault.Matter.Name
      description: Matter Name
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
    - contextPath: GoogleVault.Matter.State
      description: Matter's state(OPEN,CLOSED,DELETED)
    description: Search for a matter by name or by ID
  - name: gvault-list-holds
    arguments:
    - name: matterID
      description: Matter ID
    outputs:
    - contextPath: GoogleVault.Matter.ID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Matter.Hold.name
      description: Hold name
      type: string
    - contextPath: GoogleVault.Matter.Hold.ID
      description: Hold ID
      type: string
    description: Lists all holds for a given matter
  - name: gvault-export-status
    arguments:
    - name: matterId
      required: true
      description: Matter ID
    - name: exportID
      required: true
      description: Export ID
    outputs:
    - contextPath: GoogleVault.Export.MatterID
      description: Matter ID
      type: string
    - contextPath: GoogleVault.Export.ID
      description: Export ID
      type: string
    - contextPath: GoogleVault.Export.Name
      description: Export Name
      type: string
    - contextPath: GoogleVault.Export.Status
      description: Export Status (COMPLETED,FAILED,IN_PROGRESS)
      type: string
    description: Gets a specified Export status
  dockerimage: demisto/gvault
  runonce: false
tests:
  - Google-Vault-Generic-Test
