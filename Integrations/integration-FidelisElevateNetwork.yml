commonfields:
  id: Fidelis Elevate Network
  version: -1
name: Fidelis Elevate Network
display: Fidelis Elevate Network
category: Network Security
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAF8ElEQVRo3tVaa2wUVRQ+lUeolLZQHwQxEUIi/GgpakvTst2d7fax7RaEUFOIRW2x7e7cme220BawNSQ1MQZFgYaH8gvlFVAxUYIIJPxRA7FSLCpBJMYnL5FEyh8cvzttodvd6e527izpJCezO3Pn3Pvde853zzkzRKKPAmUOScp+Kg/MoVF7FCiZJLHz5JA1nL8jlzxzxLoklgw908iBc5xBZKPTSzqIAcmvPU3Ltk+NSc/S5vGUz9YASBd0XIXOb2jpKm+cQDAnOvw9CAQXm1ej0ubj9PW5yVHpaXplLJU3bKN83xA9+F+gtJAnkGAdCIm50dm1EBADYgeYrJrDlF0d2UTscj7ZfXcMdN2kJW2PWwPCIZdC/jYEESwHATopwsquHVZHgb9IPAinvhI3owTRJ5L8ITm8xisjye8N+7xLtQk2JyUHPnElJhB3CcB7hCpff9TATI8bPmfzXUCfqeJAuPyzoPinEYEYkMKGr8jtnztkhbmZ3gr1MYiTXaPFgWKRFDuenMpBUyD0wemsBGqVt2EVWmgRmMoh3wjTthdAdlGpP120cz8EO/7FNJBQswm95mR7qKTBoujAqUzADJ4QDiREWDe5lInWbn5FgWysyiEAOmNgDuZFkt+N107+AGw3hUrU6VSsLsTvo4LBHMFEJVDcD7syBh1vEQikFz5SRPflkNRU2PY5cebF/oBPLjM/sMWBVEShKpRuJxeLjsMdyibx/sL2UUXHCNmrtiUZ9n/0bhSaW3uL1A2RuVxiqy1ismvQvR7ycKxx1GuUP0hRdo1GLVvfjsK8NlpMzRdhbowKlSmRQVSumg/kt4csr0Y5dZepyvuEMXh/Ctr1kA1t56vDC28jmaLnbkQZ9VSoJhqxzzh08rmhguyXPqI9xxINzOotPsDkhbXavMZlWmZgeVjh93gbHYx5//kWYFZQkfLg0P2hAg3+M3xwQb1GFe0nacVaDz3XOB3m9xiU5UP64i/M9rzG5dq+6xnanqsZ2u4rc4OEX+P3eBt9ZYQRgnf/4IAwERe7IsyARnl1PBTX9IRKYteD7mNwfNb5gD+4nKG9/9fcIOHX+D3eRggQbp42Pp616wYBUVeaVtwPhM8+H/iuPzODhF/j94QB4RNaFviR1h1K6wPxYkcyZvqHUQckC2y6utN3bzWatzDKqtZGHZDcuh56oWNSH4h3dqRRSdP5frsfXUAkVn1vNTxyO+V5zfG6GGe/ohMIn1BOKFJEej5NBfKEwfHRAWE0OBL6ldh+0H4ussRpOqVXrfFQRdtJneqN+7qD+G9J8N7hbkzEalRBusynrDFuiE7lzbCbK990s6s/Ns732WGkweMMQgxs95JSB0BnzPF61CHKWVC+cY1rZWAG5fmuhs1Vlq96JprsbzLyZRmoL1gaADrZGxHHsiSwKagwwUtDLmV9rBEwKiasvb9sY0FezgIRx/BsUybCoN5Bz32G2CppZLlJTfNssrO94sEoG6MrCLIytN8KS/EB/CQBNS1WCflNIJgeOHvKfcrLlULd2YT5ibwZ5zHxB+JAicbBjgg1MV5KcjcuIk/TdFBrKnwzTsCcyk6LmIynBd04f0Lu1qctNi05CZ2dtbxkKiknyNmQaA0Il5qOTkLDmZyXrQDzMyRNLACPmgmlu+Ebt0MTG991Yhs6sUM34n6nvufYTfsMJ4G9VMjGigNR0+LRbTf84P4lW31wWdOtZlCx8qUpMPw9fZEyUxyI1rYpCA8uGQ5Kkr8I+5y39RFa4Ds8QiCXwVpZYk2q1C9FeIexw/BZm5yMmY01PbgBJ7egcF3oLxnWjl1Kc4Ty6USAPRBDSbTYGpZqacMGJf8TvnqBxEaS8yLqyKpJhnyqfzRgHPrzzzQsfIWweE0CuHw12euHMpVG5f7N+Nwiuh2Yf77hbj6mf84Rap6/YoO1x2cnL3m1Dp2e0h1RwtkuB5CSxhZGPL9zKj4UONX/NncAxEWS/E/FOcaSJ+mfHDlNhNFlrTP0l5x9weL38LF0GrWHq2m2/uLGpT4pWvX/zRDqQjZWrVoAAAAASUVORK5CYII=
description: Automate Detection and Response to Network Threats and data leakage in
  your organization with Fidelis Elevate Network Integration.
configuration:
- display: Server URL
  name: server_url
  defaultvalue: ""
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3     months,
    1 year)
  name: fetch_time
  defaultvalue: 3 days
  type: 0
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import json
    import requests
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()


    ''' GLOBALS / PARAMS '''
    IS_FETCH = demisto.params()['isFetch']
    INCIDENT_TYPE = demisto.params()['incidentType']
    SERVER_URL = demisto.params()['server_url']
    CREDENTIALS = demisto.params()['credentials']
    INSECURE = demisto.params()['unsecure']
    PROXY = demisto.params()['proxy']
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    SESSION_ID = None

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' HELPER FUNCTIONS '''
    def http_request(method, url_suffix, params=None, data=None):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        headers = {}
        if SESSION_ID is not None:
            headers['x-uid'] = SESSION_ID
            headers['Content-Type'] = 'application/json'

        res = requests.request(
            method,
            SERVER_URL + url_suffix,
            data=None if data is None else json.dumps(data),
            headers=headers,
            # params=params,
            verify=not INSECURE,
        )

        # Handle error responses gracefully
        if res.status_code not in {200, 201}:
            return_error('Error in API call to Fidelis Integration [%d] - %s' % (res.status_code, res.reason))

        return res.json()


    @logger
    def login():
        global SESSION_ID
        if SESSION_ID is None:
            url = '/j/rest/v1/access/login/{}/{}/'.format(CREDENTIALS['identifier'], CREDENTIALS['password'])
            try:
                res = http_request('GET', url)
                if res.get('error') is not None:
                    raise requests.HTTPError('Failed to login: {}'.format(res['error']))
            except requests.ConnectionError as ce:
                return_error('Demisto has encounter a connection error, please check the server_url parameter')
            SESSION_ID = res.get('uid')


    def logout():
        global SESSION_ID
        if SESSION_ID is not None:
            try:
                url = '/j/rest/v1/access/logout/{}/'.format(SESSION_ID)
                http_request('GET', url)
                SESSION_ID = None
            except:
                pass


    def generate_pagination():
        return {
            'getLast': False,
            'page': 1,
            'referenceTime': '',
            'size': 200,
            'supportPaging': True,
        }


    def to_fidelis_time_format(t):
        if isinstance(t, basestring):
            t = datetime.strptime(t, '%Y-%m-%dT%H:%M:%SZ')

        return datetime.strftime(t, '%Y-%m-%d %H:%M:%S')


    def generate_time_settings(time_frame=None, start_time=None, end_time=None):
        # default value
        settings = {
            'from': '',
            'to': '',
            'key': 'all',
            'value': '',
        }

        if time_frame is None:
            return settings
        elif time_frame in ['Today', 'Yesterday']:
            settings['key'] = time_frame.lower()
        elif 'Last' in time_frame:
            settings['key'] = 'last'
            if time_frame == 'Last 7 Days':
                settings['value'] = '7:00:00:00'
            elif time_frame == 'Last 30 Days':
                settings['value'] = '30:00:00:00'
            elif time_frame == 'Last Hour':
                settings['value'] = '1:00:00'
            elif time_frame == 'Last 24 Hours':
                settings['value'] = '24:00:00'
            elif time_frame == 'Last 48 Hours':
                settings['value'] = '48:00:00'
            else:
                raise ValueError('Could not parse time frame: {}'.format(time_frame))
        elif time_frame == 'Custom':
            settings['key'] = 'custom'
            if start_time is None and end_time is None:
                raise ValueError('invalid custom time frame: need to specify one of start_time, end_time')
            if start_time is not None:
                settings['from'] = to_fidelis_time_format(start_time)
            if end_time is not None:
                settings['to'] = to_fidelis_time_format(end_time)

        return settings


    ''' COMMANDS + REQUESTS FUNCTIONS '''
    def fidelis_get_alert_command():
        args = demisto.args()
        alert_id = args['alert_id']

        alert = fidelis_get_alert(alert_id)

        ec = {
            'ID': alert['alertId'],
            'ThreatScore': alert['fidelisScore'],
            'Time': alert['time'],
            'RuleID': alert['ruleId'],
            'RuleName': alert['rule'],
            'Summary': alert['summary'],
            'PolicyName': alert['policy'],
            'Severity': alert['severity'],
            'Protocol': alert['protocol'],
            'Type': alert['alertType'],
            'AssignedUser': alert.get('ticket', {}).get('assignedUserId'),
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': alert,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Alert {}'.format(alert_id), ec, headerTransform=pascalToSpace),
            'EntryContext': {
                'Fidelis.Alert(val.ID && val.ID == obj.ID)': ec,
            },
        })


    @logger
    def fidelis_get_alert(alert_id):
        return http_request('GET', '/j/rest/v1/alert/info/{}/'.format(alert_id))


    def fidelis_delete_alert_command():
        args = demisto.args()
        alert_id = args['alert_id'].split(',')

        result = fidelis_delete_alert(alert_id)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '\n'.join('Alert ({}) deleted successfully!'.format(_id) for _id in alert_id),
        })


    @logger
    def fidelis_delete_alert(alert_id):
        data = {
            'type': 'byAlertID',
            'alertIds': alert_id,
        }
        result = http_request('POST', '/j/rest/v1/alert/delete/', data=data)

        return result


    def fidelis_export_alert_command():
        args = demisto.args()
        alert_id = args['alert_id']

        results = fidelis_export_alert(alert_id)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': results,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('<INSERT TITLE HERE>', results),
            # 'EntryContext': create_context([indicator]),
        })


    @logger
    def fidelis_export_alert(alert_id):
        raise NotImplementedError()


    def fidelis_get_malware_data_command():
        args = demisto.args()
        alert_id = args['alert_id']

        result = fidelis_get_malware_data(alert_id)

        ec = {
            'ID': alert_id,
            'Malware': {
                'Name': result['malwareName'],
                'Behavior': result['malwareBehavior'],
                'Description': result['malwareDescription'],
                'DetailName': result['malwareDetailName'],
                'Platform': result['malwarePlatform'],
                'Type': result['malwareType'],
                'Variant': result['malwareVariant'],
            }
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Alert {} Malware:'.format(alert_id), result, headerTransform=pascalToSpace),
            'EntryContext': {
                'Fidelis.Alert(val.ID && val.ID == obj.ID)': ec,
            },
        })


    @logger
    def fidelis_get_malware_data(alert_id):
        result = http_request('GET', '/j/rest/v1/alert/malware/{}/'.format(alert_id))
        return result


    def fidelis_get_alert_pcap_command():
        args = demisto.args()
        alert_id = args['alert_id']

        results = fidelis_get_alert_pcap(alert_id)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': results,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('<INSERT TITLE HERE>', results),
            # 'EntryContext': create_context([indicator]),
        })


    @logger
    def fidelis_get_alert_pcap(alert_id):
        raise NotImplementedError()


    def fidelis_get_alert_report_command():
        args = demisto.args()
        alert_id = args['alert_id']

        results = fidelis_get_alert_report(alert_id)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': results,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('<INSERT TITLE HERE>', results),
            # 'EntryContext': create_context([indicator]),
        })


    @logger
    def fidelis_get_alert_report(alert_id):
        raise NotImplementedError()


    def fidelis_sandbox_upload_command():
        args = demisto.args()
        upload_item = args['upload_item']

        results = fidelis_sandbox_upload(upload_item)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': results,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('<INSERT TITLE HERE>', results),
            # 'EntryContext': create_context([indicator]),
        })


    @logger
    def fidelis_sandbox_upload(upload_item):
        raise NotImplementedError()


    def fidelis_list_alerts_command():
        args = demisto.args()
        time_frame = args.get('time_frame')
        start_time = args.get('start_time')
        end_time = args.get('end_time')
        severity = args.get('severity')
        _type = args.get('type')
        threat_score = args.get('threat_score')
        ioc = args.get('ioc')

        results = fidelis_list_alerts(time_frame=time_frame, start_time=start_time, end_time=end_time, severity=severity, _type=_type, threat_score=threat_score, ioc=ioc)
        ec = [{
            'ID': alert['ALERT_ID'],
            'Time': alert['ALERT_TIME'],
            'Summary': alert['SUMMARY'],
            'Severity': alert['SEVERITY'],
            'Type': alert['ALERT_TYPE'],
        } for alert in results]

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': results,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Found {} Alerts:'.format(len(ec)), ec),
            'EntryContext': {
                'Fidelis.Alert(val.ID && val.ID == obj.ID)': ec,
            },
        })


    @logger
    def fidelis_list_alerts(time_frame=None, start_time=None, end_time=None, severity=None, _type=None, threat_score=None, ioc=None, additional_columns=None):
        columns = additional_columns if additional_columns is not None else []

        filters = [{'simple': {'column': 'ACTION', 'operator': '=', 'value': 'alert'}}]
        if severity is not None:
            filters.append({'simple': {'column': 'SEVERITY', 'operator': 'IN', 'value': severity}})
        if _type is not None:
            filters.append({'simple': {'column': 'ALERT_TYPE', 'operator': 'IN', 'value': _type}})
        if threat_score is not None:
            filters.append({'simple':{'column': 'FIDELIS_SCORE', 'operator': '>', 'value': threat_score}})
        if ioc is not None:
            filters.append({'simple': {'column': 'ANY_STRING', 'operator': '=~', 'value': ioc}})

        data = {
            'columns': columns + ['ALERT_ID', 'ALERT_TIME', 'SUMMARY', 'SEVERITY', 'ALERT_TYPE', ],
            'filter': {
                'composite': {
                    'logic': 'and',
                    'filters': filters,
                }
            },
            'order': [{'column': 'ALERT_TIME', 'direction': 'DESC'}],
            'pagination': generate_pagination(),
            'timeSettings': generate_time_settings(time_frame, start_time, end_time)
        }
        res = http_request('POST', '/j/rest/v1/alert/search/', data=data)

        return res['aaData']


    def fidelis_upload_pcap_command():
        args = demisto.args()


        results = fidelis_upload_pcap()

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': results,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('<INSERT TITLE HERE>', results),
            # 'EntryContext': create_context([indicator]),
        })


    @logger
    def fidelis_upload_pcap():
        raise NotImplementedError()


    def test_integration():
        # the login is executed in the switch panel code
        demisto.results('ok')


    def fetch_incidents():
        last_run = demisto.getLastRun()
        # Get the last fetch time, if exists
        last_fetch = last_run.get('time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')

        latest = datetime.strptime(last_fetch, '%Y-%m-%dT%H:%M:%SZ')

        incidents = []
        items = fidelis_list_alerts(time_frame='Custom', start_time=last_fetch)
        for item in items:
            incident_date = datetime.strptime(item['ALERT_TIME'], '%Y-%m-%d %H:%M:%S')
            incident = {
                'Type': 'Fidelis',
                'name': item['SUMMARY'],
                'occurred': incident_date.strftime('%Y-%m-%dT%H:%M:%SZ'),
                'rawJSON': json.dumps(item),
            }
            latest = max(latest, incident_date)
            incidents.append(incident)

        if latest != last_fetch:
            last_fetch = (latest + timedelta(seconds=1)).strftime('%Y-%m-%dT%H:%M:%SZ')
            demisto.setLastRun({'time' : last_fetch})

        demisto.incidents(incidents)


    ''' COMMANDS MANAGER / SWITCH PANEL '''
    try:
        command = demisto.command()
        LOG('Command being called is {}'.format(command))
        login()
        if command == 'test-module':
            test_integration()
        elif command == 'fetch-incidents':
            fetch_incidents()

        elif command == 'fidelis-get-alert':
            fidelis_get_alert_command()

        elif command == 'fidelis-delete-alert':
            fidelis_delete_alert_command()

        elif command == 'fidelis-export-alert':
            fidelis_export_alert_command()

        elif command == 'fidelis-get-malware-data':
            fidelis_get_malware_data_command()

        elif command == 'fidelis-get-alert-pcap':
            fidelis_get_alert_pcap_command()

        elif command == 'fidelis-get-alert-report':
            fidelis_get_alert_report_command()

        elif command == 'fidelis-sandbox-upload':
            fidelis_sandbox_upload_command()

        elif command == 'fidelis-list-alerts':
            fidelis_list_alerts_command()

        elif command == 'fidelis-upload-pcap':
            fidelis_upload_pcap_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
        return_error('error has occurred: {}\n{}'.format(type(e), e.message, ))
    finally:
        logout()
  type: python
  commands:
  - name: fidelis-get-alert
    arguments:
    - name: alert_id
      required: true
      description: Alert ID
    outputs:
    - contextPath: Fidelis.Alert.ID
      description: Alert ID
      type: string
    - contextPath: Fidelis.Alert.ThreatScore
      description: Alert threat score
      type: number
    - contextPath: Fidelis.Alert.Time
      description: Alert time
      type: date
    - contextPath: Fidelis.Alert.RuleID
      description: Related rule ID
      type: string
    - contextPath: Fidelis.Alert.RuleName
      description: Related rule name
      type: string
    - contextPath: Fidelis.Alert.Summary
      description: Alert summary
      type: string
    - contextPath: Fidelis.Alert.PolicyName
      description: Related Policy name
      type: string
    - contextPath: Fidelis.Alert.Severity
      description: Alert severity
      type: string
    - contextPath: Fidelis.Alert.Protocol
      description: Protocol involved in the alert
      type: string
    - contextPath: Fidelis.Alert.Type
      description: Alert type
      type: string
    - contextPath: Fidelis.Alert.AssignedUser
      description: Assigned user ID
      type: string
    description: Get alert details from Fidelis Elevate
  - name: fidelis-delete-alert
    arguments:
    - name: alert_id
      required: true
      description: Alert ID
      isArray: true
    description: Delete an alert from Fidelis Elevate
  - name: fidelis-export-alert
    arguments:
    - name: alert_id
      required: true
      description: Alert ID
    description: Export alert details to pdf
  - name: fidelis-get-malware-data
    arguments:
    - name: alert_id
      required: true
      description: Alert ID
    outputs:
    - contextPath: Fidelis.Alert.ID
      description: Alert ID
      type: string
    - contextPath: Fidelis.Alert.Malware.Name
      description: Malware name
      type: string
    - contextPath: Fidelis.Alert.Malware.Type
      description: Malware type
      type: string
    - contextPath: Fidelis.Alert.Malware.Behavior
      description: Malware behavior
      type: string
    - contextPath: Fidelis.Alert.Malware.Platform
      description: Malware platform
      type: string
    - contextPath: Fidelis.Alert.Malware.DetailName
      description: Malware detail name from Fidelis
      type: string
    - contextPath: Fidelis.Alert.Malware.Variant
      description: Malware variant
      type: string
    - contextPath: Fidelis.Alert.Malware.Description
      description: Malware description from Fidelis
      type: string
    description: Retrieve malware data related to a "Malware" type alert
  - name: fidelis-get-alert-pcap
    deprecated: true
    arguments:
    - name: alert_id
      required: true
      description: Alert ID
    description: Retrieve the alert pcap from Fidelis Elevate
  - name: fidelis-get-alert-report
    deprecated: true
    arguments:
    - name: alert_id
      required: true
      description: Alert ID
    description: Download a pdf report for a specified alert
  - name: fidelis-sandbox-upload
    deprecated: true
    arguments:
    - name: upload_item
      required: true
      description: File or URL to upload
    outputs:
    - contextPath: Fidelis.Alert.ID
      description: Alert ID generated from the upload
      type: string
    description: Upload a file or a URL for a sandbox analysis in Fidelis Elevate
  - name: fidelis-list-alerts
    arguments:
    - name: time_frame
      auto: PREDEFINED
      predefined:
      - Today
      - Yesterday
      - Last 7 Days
      - Last Hour
      - Last 24 Hours
      - Last 48 Hours
      - Last 30 Days
      - Custom
      description: Filter by time frame (i.e. Last 48 Hours)
    - name: start_time
      description: If time_frame is Custom, specify the start time for the time range
        (e.g. 2017-06-01T12:48:16.734Z)
    - name: end_time
      description: If time_frame is Custom, specify the end time for the time range
        (e.g. 2017-06-01T12:48:16.734Z)
    - name: severity
      auto: PREDEFINED
      predefined:
      - Low
      - Medium
      - High
      - Critical
      description: Filter by Alert's severity
    - name: type
      auto: PREDEFINED
      predefined:
      - Endpoint
      - DSI
      - DPI
      - DNS
      - Malware
      - Mail
      - File Upload
      - Collector Feed
      - Analytics
      description: Filter by Alert type
    - name: threat_score
      description: Filter by Alert Threat Score Threshold (Higher than)
    - name: ioc
      description: Filter Alerts that are related to a specified IOC
    outputs:
    - contextPath: Fidelis.Alert.ID
      description: Alert ID
      type: string
    - contextPath: Fidelis.Alert.Time
      description: Alert time
      type: date
    - contextPath: Fidelis.Alert.Summary
      description: Alert summary
      type: string
    - contextPath: Fidelis.Alert.Severity
      description: Alert severity
      type: string
    - contextPath: Fidelis.Alert.Type
      description: Alert type
      type: string
    description: List open Alerts from Fidelis Elevate
  - name: fidelis-upload-pcap
    deprecated: true
    arguments: []
    outputs:
    - contextPath: Fidelis.Alert.ID
      description: Alert ID generated from the upload
      type: string
    description: Upload a pcap file for analysis in Fidelis Elevate
  isfetch: true
  runonce: false
releaseNotes: "New implementation for Fidelis Elevate Network"
tests:
  - Fidelis-Test