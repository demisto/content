commonfields:
  id: EWS Mail Sender
  version: -1
name: EWS Mail Sender
display: EWS Mail Sender
category: Messaging
image: data:image/png;base64,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
description: Exchange Web Services and Office 365 Email sender
detaileddescription: |-
  For Office 365, use https://outlook.office365.com/EWS/Exchange.asmx (default) as the Server  URL.
  Default version is used when accessing the EWS API to determine the API version.

  To fetch emails from a specific folder, folder path needs to be specified. Inbox is the default folder.
configuration:
- display: Exchange URL or Server IP address
  name: ewsServer
  defaultvalue: https://outlook.office365.com/EWS/Exchange.asmx/
  type: 0
  required: true
- display: 'Authentication: Email address (for office365) or DOMAIN\USERNAME (e.g.
    DEMISTO.INT\admin)'
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Server Version (2007,2010,2010_SP2,2013,2016)
  name: defaultServerVersion
  defaultvalue: "2013"
  type: 0
  required: true
- display: Authentication Type (NTLM or Basic or Digest). Use Basic for Office365.
  name: authType
  defaultvalue: Basic
  type: 0
  required: true
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Has impersonation rights.
  name: impersonation
  defaultvalue: "false"
  type: 8
  required: false
- display: Mailbox (to send the message from)
  name: mailbox
  defaultvalue: ""
  type: 0
  required: false
script:
  script: |
    from cStringIO import StringIO
    import logging, warnings, traceback

    warnings.filterwarnings("ignore")
    log_stream = StringIO()
    logging.basicConfig(stream=log_stream, level=logging.DEBUG)

    from exchangelib.protocol import BaseProtocol, NoVerifyHTTPAdapter
    from exchangelib.version import EXCHANGE_2007, EXCHANGE_2010, EXCHANGE_2010_SP2, EXCHANGE_2013, EXCHANGE_2016
    from exchangelib import HTMLBody, Message, FileAttachment, Account, IMPERSONATION, ServiceAccount, Configuration, NTLM, \
        BASIC, DIGEST, Version, DELEGATE

    IS_TEST_MODULE = False

    # load arguments
    USE_PROXY = demisto.params()['proxy']
    NON_SECURE = demisto.params()['insecure']
    AUTH_METHOD_STR = demisto.params()['authType'].lower()
    VERSION_STR = demisto.params()['defaultServerVersion']
    EWS_SERVER = demisto.params()['ewsServer']
    USERNAME = demisto.params()['credentials']['identifier']
    ACCOUNT_EMAIL = demisto.params().get('mailbox', None)
    if not ACCOUNT_EMAIL:
        if "@" in USERNAME:
            ACCOUNT_EMAIL = USERNAME
    if ACCOUNT_EMAIL is None:
        raise Exception("Provide a valid email address in the mailbox field")
    PASSWORD = demisto.params()['credentials']['password']
    FOLDER_NAME = demisto.params().get('folder', 'Inbox')
    ACCESS_TYPE = IMPERSONATION if demisto.params()['impersonation'] else DELEGATE

    VERSIONS = {
        '2007': EXCHANGE_2007,
        '2010': EXCHANGE_2010,
        '2010_SP2': EXCHANGE_2010_SP2,
        '2013': EXCHANGE_2013,
        '2016': EXCHANGE_2016
    }


    def get_account(account_email):
        return Account(
            primary_smtp_address=account_email, autodiscover=False, config=config, access_type=ACCESS_TYPE,
        )


    def send_email_to_mailbox(account, to, subject, body, bcc=None, cc=None, reply_to=None, html_body=None, attachments=[]):
        message_body = HTMLBody(html_body) if html_body else body
        m = Message(
            account=account,
            folder=account.sent,
            cc_recipients=cc,
            bcc_recipients=bcc,
            subject=subject,
            body=message_body,
            to_recipients=to,
            reply_to=reply_to
        )
        if account.protocol.version.build <= EXCHANGE_2010_SP2:
            m.save()
            for attachment in attachments:
                m.attach(attachment)
            m.send()
        else:
            for attachment in attachments:
                m.attach(attachment)
            m.send_and_save()
        return m


    def get_auth_method(auth_method):
        auth_method = auth_method.lower()
        if auth_method == 'ntlm':
            return NTLM
        elif auth_method == 'basic':
            return BASIC
        elif auth_method == 'digest':
            return DIGEST
        raise Exception("%s auth method is not supported. Choose one of %s" % (auth_method, 'ntlm\\basic\\digest'))


    def get_version(version_str):
        if version_str not in VERSIONS:
            raise Exception("%s is unsupported version: %s. Choose one of" % (version_str, "\\".join(VERSIONS.keys())))
        return Version(VERSIONS[version_str])


    def collect_manual_attachments(manualAttachObj):
        attachments = []
        for attachment in manualAttachObj:
            res = demisto.getFilePath(os.path.basename(attachment['RealFileName']))

            file_path = res["path"]
            with open(file_path, 'rb') as f:
                attachments.append(FileAttachment(content=f.read(), name=attachment['FileName']))

        return attachments


    def send_email(to, subject, body="", bcc=None, cc=None, replyTo=None, htmlBody=None,
                   attachIDs="", attachNames="", from_mailbox=None, manualAttachObj=None):
        account = get_account(from_mailbox or ACCOUNT_EMAIL)
        bcc = bcc.split(",") if bcc is not None else None
        cc = cc.split(",") if cc is not None else None
        to = to.split(",") if to is not None else None
        manualAttachObj = manualAttachObj if manualAttachObj is not None else []

        file_entries_for_attachments = []
        attachments_names = []
        if attachIDs:
            file_entries_for_attachments = attachIDs.split(",")
            if attachNames:
                attachments_names = attachNames.split(",")
            else:
                for att_id in file_entries_for_attachments:
                    att_name = demisto.dt(demisto.context(), "File(val.EntryID === '%s').Name" % att_id)
                    if isinstance(att_name, list):
                        att_name = att_name[0]
                    attachments_names.append(att_name)
            if len(file_entries_for_attachments) != len(attachments_names):
                raise Exception("attachIDs and attachNames lists should be the same length")

        attachments = collect_manual_attachments(manualAttachObj)
        for i in range(0, len(file_entries_for_attachments)):
            entry_id = file_entries_for_attachments[i]
            attachment_name = attachments_names[i]
            try:
                res = demisto.getFilePath(entry_id)
            except:
                raise Exception("entry %s does not contain a file" % entry_id)
            file_path = res["path"]
            with open(file_path, 'rb') as f:
                attachments.append(FileAttachment(content=f.read(), name=attachment_name))

        send_email_to_mailbox(account, to, subject, body, bcc, cc, replyTo, htmlBody, attachments)
        result_object = {
            'from': account.primary_smtp_address,
            'to': to,
            'subject': subject,
            'attachments': attachments_names
        }

        return {
            'Type': entryTypes['note'],
            'Contents': result_object,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sent email', result_object),
        }


    def prepare():
        if NON_SECURE:
            BaseProtocol.HTTP_ADAPTER_CLS = NoVerifyHTTPAdapter

        if not USE_PROXY:
            def remove_from_dict(d, key):
                if key in d:
                    del d[key]

            import os

            remove_from_dict(os.environ, 'HTTP_PROXY')
            remove_from_dict(os.environ, 'http_proxy')
            remove_from_dict(os.environ, 'HTTPS_PROXY')
            remove_from_dict(os.environ, 'https_proxy')

            os.environ['NO_PROXY'] = EWS_SERVER

        version = get_version(VERSION_STR)
        credentials = ServiceAccount(username=USERNAME, password=PASSWORD, max_wait=300)
        config_args = {
            'credentials': credentials,
            'auth_type': get_auth_method(AUTH_METHOD_STR),
            'version': version
        }
        if 'http' in EWS_SERVER.lower():
            config_args['service_endpoint'] = EWS_SERVER
        else:
            config_args['server'] = EWS_SERVER
        config = Configuration(**config_args)
        return config


    def prepare_args(d):
        return dict((k.replace("-", "_"), v) for k, v in d.items())


    def test_module():
        global IS_TEST_MODULE
        IS_TEST_MODULE = True
        BaseProtocol.TIMEOUT = 20
        account = get_account(ACCOUNT_EMAIL)
        demisto.results('ok')

    config = prepare()
    args = prepare_args(demisto.args())

    try:
        if demisto.command() == 'test-module':
            test_module()
        elif demisto.command() == 'send-mail':
            demisto.results(send_email(**args))

    except Exception, e:
        import time

        time.sleep(2)
        debug_log = log_stream.getvalue()
        error_message = ""
        if "Status code: 401" in debug_log:
            error_message = "Got unauthorized from the server. " \
                            "Check credentials are correct and authentication method are supported. "

            error_message += "You can try using 'domain\\username' as username for authentication. " if AUTH_METHOD_STR.lower() == 'ntlm' else ''
        if "Status code: 503" in debug_log:
            error_message = "Got timeout from the server. " \
                            "Probably the server is not reachable with the current settings. " \
                            "Check proxy parameter. If you are using server URL - change to server IP address. "
        error_message = error_message + "\n" + e.message
        stacktrace = traceback.format_exc()
        if stacktrace:
            error_message += "\nFull stacktrace:\n" + stacktrace

        if debug_log:
            if IS_TEST_MODULE:
                error_message += "\nFull debug log:\n" + debug_log
            else:
                demisto.info(error_message + "\nFull debug log:\n" + debug_log)

        raise Exception(error_message)
  type: python
  commands:
  - name: send-mail
    arguments:
    - name: to
      required: true
      description: Email addresses for the 'to' field. Comma separated value supported.
    - name: cc
      description: Email addresses for the 'cc' field. Comma separated value supported.
    - name: bcc
      description: Email addresses for the 'bcc' field. Comma separated value supported.
    - name: subject
      required: true
      description: Subject for the email to be sent.
    - name: replyTo
      description: The address to reply to.
    - name: body
      description: The contents (body) of the email to be sent.
    - name: htmlBody
      description: Send an html formatted email - overrides "body" argument, cannot
        use both.
    - name: attachIDs
      description: 'A comma-separated list of IDs of war room entries that contain
        files. Used to attach files to the outgoing email. Example: attachIDs=15@8,19@8.'
    - name: attachNames
      description: A comma-separated list of names to the attachments to be send.
        Should be the same number of elements as attachIDs.
    description: Send email via EWS
  dockerimage: demisto/py-ews
releaseNotes: "-"
tests:
  - "EWS Mail Sender Test"
