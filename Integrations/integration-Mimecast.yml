commonfields:
  id: Mimecast_python
  version: -1
name: Mimecast_python
display: Mimecast_python
category: Email Gateway
image: data:image/png;base64,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
description: Mimecast unified email management offers cloud email services for email
  security, continuity and archiving emails
configuration:
- display: 'BaseUrl - API url including region, For example https://eu-api.mimecast.com  '
  name: baseUrl
  defaultvalue: https://api.mimecast.com
  type: 0
  required: true
- display: AccessKey
  name: accessKey
  defaultvalue: ""
  type: 0
  required: true
- display: SecretKey
  name: secretKey
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: App ID
  name: appId
  defaultvalue: ""
  type: 4
  required: true
- display: App key
  name: appKey
  defaultvalue: ""
  type: 4
  required: true
- display: Fetch URL incidents
  name: fetchURL
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch attachment incidents
  name: fetchAttachments
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch impersonation incidents
  name: fetchImpersonations
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |-
    ''' IMPORTS '''

    import os
    import re
    import sys
    import hmac
    import uuid
    import json
    import time
    import urllib
    import base64
    import hashlib
    import datetime
    import requests
    from urlparse import urlparse
    from distutils.util import strtobool
    # from datetime import datetime,timedelta

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    BASE_URL = demisto.params()['baseUrl']
    ACCESS_KEY = demisto.params()['accessKey']
    SECRET_KEY = demisto.params()['secretKey']
    APP_ID = demisto.params()['appId']
    APP_KEY = demisto.params()['appKey']
    USE_SSL = True if demisto.params().get('insecure') else False
    PROXY = True if demisto.params().get('proxy') else False
    FETCH_URL = demisto.params()['fetchURL']
    FETCH_ATTACHMENTS = demisto.params()['fetchAttachments']
    FETCH_IMPERSONATIONS = demisto.params()['fetchImpersonations']

    # remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    # default query xml template for test module
    default_query_xml = "<?xml version=\"1.0\"?> \n\
        <xmlquery trace=\"iql,muse\">\n\
        <metadata query-type=\"emailarchive\" archive=\"true\" active=\"false\" page-size=\"25\" startrow=\"0\">\n\
            <smartfolders/>\n\
            <return-fields>\n\
                <return-field>attachmentcount</return-field>\n\
                <return-field>status</return-field>\n\
                <return-field>subject</return-field>\n\
                <return-field>size</return-field>\n\
                <return-field>receiveddate</return-field>\n\
                <return-field>displayfrom</return-field>\n\
                <return-field>id</return-field>\n\
                <return-field>displayto</return-field>\n\
                <return-field>smash</return-field>\n\
            </return-fields>\n\
        </metadata>\n\
        <muse>\n\
            <text></text>\n\
            <date select=\"last_year\"/>\n\
            <sent></sent>\n\
            <docs select=\"optional\"></docs>\n\
            <route/>\n\
        </muse>\n\
    </xmlquery>"

    ''' HELPER FUNCTIONS '''


    def http_request(method, api_endpoint, params={}, payload=None, user_auth=True):
        url = BASE_URL + api_endpoint
        # 2 types of auth, user and non user, mostly user is needed
        if user_auth:
            # Generate request header values
            request_id = str(uuid.uuid4())
            hdr_date = datetime.datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S") + " UTC"

            # Create the HMAC SHA1 of the Base64 decoded secret key for the Authorization header
            hmac_sha1 = hmac.new(SECRET_KEY.decode("base64"), ':'.join([hdr_date, request_id, api_endpoint, APP_KEY]),
                          digestmod=hashlib.sha1).digest()

            # Use the HMAC SHA1 value to sign the hdrDate + ":" requestId + ":" + URI + ":" + appkey
            signature = base64.encodestring(hmac_sha1).rstrip()

            # Create request headers
            headers = {
                'Authorization': 'MC ' + ACCESS_KEY + ':' + signature,
                'x-mc-app-id': APP_ID,
                'x-mc-date': hdr_date,
                'x-mc-req-id': request_id,
                'Content-Type': 'application/json'
            }

        LOG('running %s request with url=%s\tparams=%s\tdata=%s' % (method, url, json.dumps(params), json.dumps(payload)))
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                headers=headers,
                data=payload
            )

            res.raise_for_status()
            return res.json()

        except Exception, e:
            LOG(e)
            raise

    def parse_query_args(args):
        query_xml = default_query_xml
        if args.get('pageSize'):
            query_xml = query_xml.replace('page-size=\"25\"','page-size=\"'+args.get('pageSize')+'\"')
        if args.get('startRow'):
            query_xml = query_xml.replace('startrow=\"0\"','startrow=\"'+args.get('startRow')+'\"')
        if args.get('active') == 'true':
            query_xml = query_xml.replace('active=\"false\"','active=\"true\"')
        if args.get('body'):
            query_xml = query_xml.replace('<text></text>','<text>(body: '+args.get('body')+')</text>')
        if args.get('subject'):
            query_xml = query_xml.replace('<text></text>','<text>(subject: '+args.get('subject')+')</text>')
        if args.get('text'):
            query_xml = query_xml.replace('<text></text>','<text>'+args.get('text')+'</text>')
        if args.get('date'):
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"'+args.get('date')+'\"/>')

            if args.get('dateTo') or args.get('dateFrom'):
                 return_error('Cannot use both date and dateFrom/dateTo arguments')

        date_to = ""
        date_from = ""

        if args.get('dateTo'):
            date_to = args.get('dateTo')
        if args.get('dateFrom'):
            date_from = args.get('dateFrom')
        if date_to and date_from:
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"between\" from=\"'+date_from+'\" to=\"'+date_to+'\" />')
        elif date_from:
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"between\" from=\"'+date_from+'\" />')
        elif date_to:
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"between\" to=\"'+date_to+'\" />')

        if args.get('sentFrom'):
            query_xml = query_xml.replace('<sent></sent>','<sent select=\"from\" >'+args.get('sentFrom')+'</sent>')
        if args.get('sentTo'):
            query_xml = query_xml.replace('<sent></sent>','<sent select=\"to\" >'+args.get('sentTo')+'</sent>')
        query_xml = query_xml.replace('<sent></sent>','') #no empty tag
        if args.get('attachmentText'):
            query_xml = query_xml.replace('</docs>',args.get('attachmentText')+'</docs>')
        if args.get('attachmentType'):
            query_xml = query_xml.replace('<docs select=\"optional\">','<docs select=\"'+args.get('attachmentType')+'\">')

        return query_xml


    '''COMMANDS '''


    def test_module():
        test_args = {}
        test_args['page_size'] = 1
        test_args['text'] = 'Demisto'
        is_admin = True
        query_xml = parse_query_args(test_args)
        query_request(query_xml, is_admin)


    def query():
        query_xml  = ''
        if demisto.args().get('queryXml'):
            query_xml = demisto.args().get('queryXml')
        else:
            query_xml = parse_query_args(demisto.args())
        if demisto.args().get('dryRun') == 'true':
            return query_xml
        response = query_request(query_xml, True)
        return response


    def query_request(query_xml, is_admin):
        request_params = {}
        api_endpoint = '/api/archive/search'
        payload = {}
        data = {}
        data['query'] = query_xml
        data['admin'] = is_admin
        payload['data'] = [data]
        response = http_request('POST', api_endpoint, request_params , json.dumps(payload))
        return response


    def url_decode():
        headers = []
        contents = {}
        context = {}
        protected_url =  demisto.args().get('url').encode('utf-8')
        decoded_url = url_decode_request(protected_url)
        contents['Decoded URL'] = decoded_url
        context[outputPaths['url']] = {
            'Data': protected_url,
            'Mimecast': {
                'DecodedURL': decoded_url
            }
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Decoded URL:', contents, headers),
            'EntryContext': context
        }

        return results


    def url_decode_request(url):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/ttp/url/decode-url'
        payload = {
            'data': [
                {
                    'url': url
                }
            ]
        }
        response = http_request('POST', api_endpoint, request_params , str(payload))
        if not response.get('data')[0].get('url'):
            return_error('No URL has been returned from the service')
        return response.get('data')[0].get('url')


    def get_policy():
        headers = ['Policy ID', 'Sender', 'Reciever', 'Bidirectional', 'Start', 'End']
        contents = []
        context = {}
        title = 'Mimecast list blocked sender policies: \n These are the existing Blocked Sender Policies:'
        policy_id =  demisto.args().get('policyID')
        if policy_id:
            policy_id = policy_id.encode('utf-8')
            title = 'Mimecast Get Policy'

        policies_list = get_policy_request(policy_id)
        policies_context = []
        for policy_list in policies_list:
            policy = policy_list.get('policy')
            sender = policy.get('from')
            reciever = policy.get('to')
            contents.append({
                'Policy ID': policy_list['id'],
                'Sender': {
                    'Group': sender.get('groupId'),
                    'Email Address': sender.get('emailAddress'),
                    'Domain': sender.get('emailDomain'),
                    'Type': sender.get('type')
                },
                'Reciever': {
                    'Group': reciever.get('groupId'),
                    'Email Address': reciever.get('emailAddress'),
                    'Domain': reciever.get('domain'),
                    'Type': reciever.get('type')
                },
                'Bidirectional': policy.get('bidirectional'),
                'Start': policy.get('fromDate'),
                'End': policy.get('toDate')
            })
            policies_context.append({
                'ID': policy_list['id'],
                'Sender': {
                    'Group': sender.get('groupId'),
                    'Address': sender.get('emailAddress'),
                    'Domain': sender.get('domain'),
                    'Type': sender.get('type')
                },
                'Reciever': {
                    'Group': reciever.get('groupId'),
                    'Address': reciever.get('emailAddress'),
                    'Domain': reciever.get('domain'),
                    'Type': reciever.get('type')
                },
                'Bidirectional': policy.get('bidirectional'),
                'FromDate': policy.get('fromDate'),
                'ToDate': policy.get('toDate')
            })

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def get_policy_request(policy_id=None):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/policy/blockedsenders/get-policy'
        data = []
        if policy_id:
            data.append({
                'id': policy_id
            })
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def create_policy():
        headers = ['Policy ID', 'Sender', 'Reciever', 'Bidirectional', 'Start', 'End']
        contents = {}
        context = {}
        policies_context = {}
        description = demisto.args().get('description').encode('utf-8')
        from_part = demisto.args().get('fromPart').encode('utf-8')
        from_type = demisto.args().get('fromType').encode('utf-8')
        from_value = demisto.args().get('fromValue').encode('utf-8')
        to_type = demisto.args().get('toType').encode('utf-8')
        to_value = demisto.args().get('toValue').encode('utf-8')
        option = demisto.args().get('option').encode('utf-8')

        policy_obj = {
            'description': description,
            'fromPart': from_part,
            'fromType': from_type,
            'fromValue': from_value,
            'toType': to_type,
            'toValue': to_value
        }

        policy_list = create_policy_request(policy_obj,option)
        policy = policy_list.get('policy')
        policy_id = policy_list.get('id')
        title = 'Mimecast Create Policy: \n Policy {} Was Created Successfully!'.format(policy_id)
        sender = policy.get('from')
        reciever = policy.get('to')
        contents = {
            'Policy ID': policy_id,
            'Sender': {
                'Group': sender.get('groupId'),
                'Email Address': sender.get('emailAddress'),
                'Domain': sender.get('emailDomain'),
                'Type': sender.get('type')
            },
            'Reciever': {
                'Group': reciever.get('groupId'),
                'Email Address': reciever.get('emailAddress'),
                'Domain': reciever.get('domain'),
                'Type': reciever.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'Start': policy.get('fromDate'),
            'End': policy.get('toDate')
        }
        policies_context = {
            'ID': policy_id,
            'Sender': {
                'Group': sender.get('groupId'),
                'Address': sender.get('emailAddress'),
                'Domain': sender.get('domain'),
                'Type': sender.get('type')
            },
            'Reciever': {
                'Group': reciever.get('groupId'),
                'Address': reciever.get('emailAddress'),
                'Domain': reciever.get('domain'),
                'Type': reciever.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'FromDate': policy.get('fromDate'),
            'ToDate': policy.get('toDate')
        }

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def create_policy_request(policy, option):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/policy/blockedsenders/create-policy'
        payload = {
            'data': [{
                'policy': policy,
                'option': option
            }]
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def delete_policy():
        headers = []
        contents = []
        context = {}
        policy_id =  demisto.args().get('policyID').encode('utf-8')

        deleted_policy = delete_policy_request(policy_id)

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = {
            'ID': policy_id,
            'Deleted': True
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Mimecast Policy {} deleted successfully!'.format(policy_id),
            'EntryContext': context
        }

        return results


    def delete_policy_request(policy_id=None):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/policy/blockedsenders/delete-policy'
        data = [{
            'id': policy_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        if response.get('data')[0].get('deleted') != 'true':
            return_error('Policy was not deleted.')
        return response.get('data')[0]


    def manage_sender():
        headers = []
        contents = []
        context = {}
        sender =  demisto.args().get('sender').encode('utf-8')
        recipient =  demisto.args().get('recipient').encode('utf-8')
        action =  demisto.args().get('action').encode('utf-8')
        title_action = 'permitted' if action == 'permit' else 'blocked'
        title = 'Mimecast messages from {} to {} will now be {}!'.format(sender,recipient,title_action)

        req_obj = {
            'sender': sender,
            'to': recipient,
            'action': action
        }

        managed_sender = manage_sender_request(req_obj)

        contents = {
            'Sender': managed_sender.get('sender'),
            'Recipient': managed_sender.get('to'),
            'Action': managed_sender.get('type'),
            'ID': managed_sender.get('id')
        }

        context['Mimecast.Managed(val.ID && val.ID == obj.ID)'] = {
            'Sender': managed_sender.get('sender'),
            'Recipient': managed_sender.get('to'),
            'Action': managed_sender.get('type'),
            'ID': managed_sender.get('id')
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def manage_sender_request(req_obj):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/managedsender/permit-or-block-sender'
        data = []
        data.append(req_obj)
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def list_managed_url():
        headers = []
        contents = []
        context = {}
        managed_urls_context = []
        url =  demisto.args().get('url')
        if url:
            url = url.encode('utf-8')

        managed_urls = list_managed_url_request()
        for managed_url in managed_urls:
            query_string = ''
            if managed_url.get('queryString'):
                query_string = '?' + managed_url.get('queryString')
            full_url_response = managed_url.get('scheme') + '://' + managed_url.get('domain') + managed_url.get('path') + query_string
            if (url and url in full_url_response) or not url:
                contents.append({
                    'URL': full_url_response,
                    'Match Type': managed_url.get('matchType'),
                    'Comment': managed_url.get('comment'),
                    'Action': managed_url.get('action'),
                    'URL Rewriting': managed_url.get('disableRewrite'),
                    'User Awareness': managed_url.get('disableUserAwareness')
                })
                managed_urls_context.append({
                    'Domain': managed_url.get('domain'),
                    'disableLogClick': managed_url.get('disableLogClick'),
                    'Action': managed_url.get('action'),
                    'Path': managed_url.get('path'),
                    'matchType': managed_url.get('matchType'),
                    'ID': managed_url.get('id'),
                    'disableRewrite': managed_url.get('disableRewrite')
                })

        context['Mimecast.URL(val.ID && val.ID == obj.ID)'] = managed_urls_context
        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Managed URLs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def list_managed_url_request():
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/ttp/url/get-all-managed-urls'
        data = []
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def create_managed_url():
        headers = []
        context = {}
        contents = {}
        url_req_obj = {}
        managed_urls_context = []
        url =  demisto.args().get('url').encode('utf-8')
        action = demisto.args().get('action').encode('utf-8')
        match_type = demisto.args().get('matchType').encode('utf-8')
        disable_rewrite = demisto.args().get('disableRewrite').encode('utf-8')
        disable_user_awareness = demisto.args().get('disableUserAwareness').encode('utf-8')
        disable_log_click = demisto.args().get('disableLogClick').encode('utf-8')
        comment = demisto.args().get('comment')
        if comment:
            comment = comment.encode('utf-8')

        url_req_obj = {
           'comment': comment,
           'disableRewrite': disable_rewrite,
           'url': url,
           'disableUserAwareness': disable_user_awareness,
           'disableLogClick': disable_log_click,
           'action': action,
           'matchType': match_type
        }

        managed_url = create_managed_url_request(url_req_obj)
        managed_urls_context.append({
            'Domain': managed_url.get('domain'),
            'disableLogClick': managed_url.get('disableLogClick'),
            'Action': managed_url.get('action'),
            'Path': managed_url.get('path'),
            'matchType': managed_url.get('matchType'),
            'ID': managed_url.get('id'),
            'disableRewrite': managed_url.get('disableRewrite')
        })

        context['Mimecast.URL(val.ID && val.ID == obj.ID)'] = managed_urls_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Managed URL {} created successfully!'.format(url),
            'EntryContext': context
        }

        return results


    def create_managed_url_request(url_obj):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/ttp/url/create-managed-url'
        data = []
        data.append(url_obj)
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def list_messages():
        headers = ['Subject', 'Size', 'Recieved Date', 'From', 'Attachment Count', 'Message ID']
        context = {}
        contents = []
        messages_context = []
        search_params = {}

        # can't send null values for keys, so if optional value not sent by user, do not add to request.
        mailbox =  demisto.args().get('mailbox','').encode('utf-8')
        if mailbox:
           search_params['mailbox'] = mailbox
        view =  demisto.args().get('view','').encode('utf-8')
        if view:
            search_params['view'] = view
        end_time =  demisto.args().get('endTime','').encode('utf-8')
        if end_time:
            search_params['end'] = end_time
        start_time =  demisto.args().get('startTime','').encode('utf-8')
        if start_time:
            search_params['start'] = start_time
        subject =  demisto.args().get('subject')

        messages_list = list_messages_request(search_params)

        for message in messages_list:
            if subject == message.get('subject') or not subject:
                contents.append({
                    'Message ID': message.get('id'),
                    'Subject': message.get('subject'),
                    'Size': message.get('size'),
                    'Recieved Date': message.get('received'),
                    'From': message.get('from').get('emailAddress'),
                    'Attachment Count': message.get('attachmentCount')
                })
                messages_context.append({
                    'subject': message.get('subject'),
                    'ID': message.get('id'),
                    'Size': message.get('size'),
                    'RecievedDate': message.get('received'),
                    'From': message.get('from').get('emailAddress'),
                    'AttachmentCount': message.get('attachmentCount')
                })

        context['Mimecast.Message(val.ID && val.ID == obj.ID)'] = messages_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast messages list', contents, headers),
            'EntryContext': context
        }

        return results


    def list_messages_request(search_params):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/archive/get-message-list'
        data = []
        data.append(search_params)
        payload = {
            'meta': {
              'pagination': {
              }
            },
            'data': data
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def get_url_logs():
        headers = []
        contents = []
        context = {}
        url_logs_context = []
        search_params = {}
        result_number =  demisto.args().get('resultsNumber', '').encode('utf-8')
        from_date =  demisto.args().get('fromDate', '').encode('utf-8')
        to_date =  demisto.args().get('toDate', '').encode('utf-8')
        scan_result =  demisto.args().get('resultType', '').encode('utf-8')
        limit = int(demisto.args().get('limit', 100))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if scan_result:
            search_params['scanResult'] = scan_result

        url_logs = get_url_logs_request(search_params, result_number)
        if limit:
           url_logs = url_logs[:limit]
        for url_log in url_logs:

            contents.append({
                'Action': url_log.get('action'),
                'Admin Override': url_log.get('adminOverride'),
                'Category': url_log.get('category'),
                'Date': url_log.get('date'),
                'Route': url_log.get('route'),
                'Scan Result': url_log.get('scanResult'),
                'URL': url_log.get('url'),
                'User Awareness Action': url_log.get('userAwarenessAction'),
                'User Email Address': url_log.get('userEmailAddress'),
                'User Override': url_log.get('userOverride')
            })
            url_logs_context.append({
                'Action' : url_log.get('action'),
                'AdminOverride': url_log.get('adminOverride'),
                'Category': url_log.get('category'),
                'Date': url_log.get('date'),
                'Route': url_log.get('route'),
                'Result': url_log.get('scanResult'),
                'URL': url_log.get('url'),
                'Awareness': url_log.get('userAwarenessAction'),
                'Address': url_log.get('userEmailAddress'),
                'UserOverride': url_log.get('userOverride')
            })


        context['Mimecast.UrlLog'] = url_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast URL logs: ', contents, headers),
            'EntryContext(val == obj)': context
        }

        return results

    def get_url_logs_request(search_params,result_number=None):
         # Setup required variables
        request_params = {}
        api_endpoint = '/api/ttp/url/get-logs'
        pagination = {}
        if result_number:
            pagination = { 'page_size': result_number }
        payload = {
            'meta': {
              'pagination': pagination
            },
            'data': [search_params]
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('clickLogs')


    def get_attachment_logs():
        headers = []
        contents = []
        context = {}
        attachment_logs_context = []
        search_params = {}
        result_number =  demisto.args().get('resultsNumber', '').encode('utf-8')
        from_date =  demisto.args().get('fromDate', '').encode('utf-8')
        to_date =  demisto.args().get('toDate', '').encode('utf-8')
        result =  demisto.args().get('resultType', '').encode('utf-8')
        limit = int(demisto.args().get('limit', 100))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if result:
            search_params['result'] = result

        attachment_logs = get_attachment_logs_request(search_params, result_number)
        if limit:
            attachment_logs = attachment_logs[:limit]
        for attachment_log in attachment_logs:
            contents.append({
                'Result': attachment_log.get('result'),
                'Date': attachment_log.get('date'),
                'Sender Address': attachment_log.get('senderAddress'),
                'File Name': attachment_log.get('fileName'),
                'Action': attachment_log.get('actionTriggered'),
                'Route': attachment_log.get('route'),
                'Details': attachment_log.get('details'),
                'Recipient Address': attachment_log.get('recipientAddress'),
                'File Type': attachment_log.get('fileType')
            })
            attachment_logs_context.append({
                'Result': attachment_log.get('result'),
                'Date': attachment_log.get('date'),
                'Sender': attachment_log.get('senderAddress'),
                'FileName': attachment_log.get('fileName'),
                'Action': attachment_log.get('actionTriggered'),
                'Route': attachment_log.get('route'),
                'Details': attachment_log.get('details'),
                'Recipient': attachment_log.get('recipientAddress'),
                'FileType': attachment_log.get('fileType')
            })

        context['Mimecast.AttachmentLog'] = attachment_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast attachment logs: ', contents, headers),
            'EntryContext(val == obj)': context
        }

        return results

    def get_attachment_logs_request(search_params,result_number=None):
         # Setup required variables
        request_params = {}
        api_endpoint = '/api/ttp/attachment/get-logs'
        pagination = {}
        if result_number:
            pagination = { 'page_size': result_number }
        payload = {
            'meta': {
              'pagination': pagination
            },
            'data': [search_params]
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('attachmentLogs')


    def get_impersonation_logs():
        headers = []
        contents = []
        context = {}
        impersonation_logs_context = []
        search_params = {}
        result_number =  demisto.args().get('resultsNumber', '').encode('utf-8')
        from_date =  demisto.args().get('fromDate', '').encode('utf-8')
        to_date =  demisto.args().get('toDate', '').encode('utf-8')
        tagged_malicious =  demisto.args().get('taggedMalicious', '').encode('utf-8')
        search_field =  demisto.args().get('searchField', '').encode('utf-8')
        query =  demisto.args().get('query', '').encode('utf-8')
        identifiers =  argToList(demisto.args().get('identifiers', '').encode('utf-8'))
        actions =  argToList(demisto.args().get('actions', '').encode('utf-8'))
        limit = int(demisto.args().get('limit', 100))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if tagged_malicious:
            search_params['taggedMalicious'] = tagged_malicious
        if search_field:
            search_params['searchField'] = search_field
        if query:
            search_params['query'] = query
        if identifiers:
            search_params['identifiers'] = identifiers
        if actions:
            search_params['actions'] = actions

        impersonation_logs, result_count = get_impersonation_logs_request(search_params, result_number)
        if limit:
            impersonation_logs = impersonation_logs[:limit]
        for impersonation_log in impersonation_logs:
            contents.append({
                'Result Count': result_count,
                'Hits': impersonation_log.get('hits'),
                'Malicious': impersonation_log.get('taggedMalicious'),
                'Sender IP': impersonation_log.get('senderIpAddress'),
                'Sender Address': impersonation_log.get('senderAddress'),
                'Subject': impersonation_log.get('subject'),
                'Identifiers': impersonation_log.get('identifiers'),
                'Date': impersonation_log.get('eventTime'),
                'Action': impersonation_log.get('action'),
                'Policy': impersonation_log.get('definition'),
                'ID': impersonation_log.get('id'),
                'Recipient Address': impersonation_log.get('recipientAddress'),
                'External': impersonation_log.get('taggedExternal')
            })
            impersonation_logs_context.append({
                'ResultCount': result_count,
                'Hits': impersonation_log.get('hits'),
                'Malicious': impersonation_log.get('taggedMalicious'),
                'SenderIP': impersonation_log.get('senderIpAddress'),
                'SenderAddress': impersonation_log.get('senderAddress'),
                'Subject': impersonation_log.get('subject'),
                'Identifiers': impersonation_log.get('identifiers'),
                'Date': impersonation_log.get('eventTime'),
                'Action': impersonation_log.get('action'),
                'Policy': impersonation_log.get('definition'),
                'ID': impersonation_log.get('id'),
                'RecipientAddress': impersonation_log.get('recipientAddress'),
                'External': impersonation_log.get('taggedExternal')
            })

        context['Mimecast.Impersonation'] = impersonation_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast impersonation logs: ', contents, headers),
            'EntryContext(val == obj)': context
        }

        return results

    def get_impersonation_logs_request(search_params,result_number=None):
         # Setup required variables
        request_params = {}
        api_endpoint = '/api/ttp/impersonation/get-logs'
        pagination = {}
        if result_number:
            pagination = { 'page_size': result_number }
        payload = {
            'meta': {
              'pagination': pagination
            },
            'data': [search_params]
        }

        response = http_request('POST', api_endpoint, request_params , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('impersonationLogs'), response.get('data')[0].get('resultCount')

    def fetch_incidents():
        last_run = demisto.getLastRun()
        last_fetch = last_run.get('time')

        # handle first time fetch
        if last_fetch is None:
            last_fetch = datetime.datetime.now() - datetime.timedelta(days=1)
            last_fetch_date_time = last_fetch.strftime("%Y-%m-%dT%H:%M:%S") + '+0000'
        else:
            last_fetch = datetime.datetime.strptime(last_fetch, '%Y-%m-%dT%H:%M:%SZ')
            last_fetch_date_time = last_fetch.strftime("%Y-%m-%dT%H:%M:%S") + '+0000'
        current_fetch = last_fetch

        incidents = []
        if FETCH_URL:
            search_params = {
                'fromDate': last_fetch_date_time,
                'scanResult': 'malicious'
            }
            url_logs = get_url_logs_request(search_params)
            for url_log in url_logs:
                incident = url_to_incident(url_log)
                temp_date = datetime.datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')
                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + datetime.timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        if FETCH_ATTACHMENTS:
            search_params = {
                'fromDate': last_fetch_date_time,
                'result': 'malicious'
            }
            attachment_logs = get_attachment_logs_request(search_params)
            for attachment_log in attachment_logs:
                incident = attachment_to_incident(attachment_log)
                temp_date = datetime.datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + datetime.timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        if FETCH_IMPERSONATIONS:
            search_params = {
                'from': last_fetch_date_time,
                'taggedMalicious': True
            }
            impersonation_logs, _ = get_impersonation_logs_request(search_params)
            for impersonation_log in impersonation_logs:
                incident = impersonation_to_incident(impersonation_log)
                temp_date = datetime.datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + datetime.timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        demisto.setLastRun({'time' : last_fetch.isoformat().split('.')[0] + 'Z'})
        demisto.incidents(incidents)


    def url_to_incident(url_log):
        incident = {}
        incident['name'] = 'Mimecast malicious URL: ' + url_log.get('url')
        incident['occurred'] = url_log.get('date').replace('+0000','Z')
        incident['rawJSON'] = json.dumps(url_log)
        return incident

    def attachment_to_incident(attachment_log):
        incident = {}
        incident['name'] = 'Mimecast malicious attachment: ' + attachment_log.get('fileName')
        incident['occurred'] = attachment_log.get('date').replace('+0000','Z')
        incident['rawJSON'] = json.dumps(attachment_log)
        return incident


    def impersonation_to_incident(impersonation_log):
        incident = {}
        incident['name'] = 'Mimecast malicious impersonation: ' + impersonation_log.get('subject')
        incident['occurred'] = impersonation_log.get('eventTime').replace('+0000','Z')
        incident['rawJSON'] = json.dumps(impersonation_log)
        return incident


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('command is %s' % (demisto.command(), ))


    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
            sys.exit(0)
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
            sys.exit(0)
        elif demisto.command() == 'mimecast-query':
            demisto.results(query())
        elif demisto.command() == 'mimecast-list-blocked-sender-policies':
            demisto.results(get_policy())
        elif demisto.command() == 'mimecast-get-policy':
            demisto.results(get_policy())
        elif demisto.command() == 'mimecast-create-policy':
            demisto.results(create_policy())
        elif demisto.command() == 'mimecast-delete-policy':
            demisto.results(delete_policy())
        elif demisto.command() == 'mimecast-manage-sender':
            demisto.results(manage_sender())
        elif demisto.command() == 'mimecast-list-managed-url':
            demisto.results(list_managed_url())
        elif demisto.command() == 'mimecast-create-managed-url':
            demisto.results(create_managed_url())
        elif demisto.command() == 'mimecast-get-message-content':
            demisto.results(get_message_content())
        elif demisto.command() == 'mimecast-list-messages':
            demisto.results(list_messages())
        elif demisto.command() == 'mimecast-get-attachment-logs':
            demisto.results(get_attachment_logs())
        elif demisto.command() == 'mimecast-get-url-logs':
            demisto.results(get_url_logs())
        elif demisto.command() == 'mimecast-get-impersonation-logs':
            demisto.results(get_impersonation_logs())
        elif demisto.command() == 'mimecast-url-decode':
            demisto.results(url_decode())

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
  type: python
  commands:
  - name: mimecast-query
    arguments:
    - name: queryXml
      default: true
      description: The query string xml for the search using Mimecast Unified Search
        Experience (MUSE) - read more on https://community.mimecast.com/docs/DOC-2262,
        using this will override other query arguments
    - name: text
      description: Search for this text in api messages
    - name: dryRun
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Will no execute the query, but just return the query string builded
    - name: date
      auto: PREDEFINED
      predefined:
      - today
      - yesterday
      - last_week
      - last_month
      - last_year
      description: Search in specific dates only
    - name: dateFrom
      description: search emails from date, format 2015-09-21T23:00:00Z
    - name: dateTo
      description: search emails to date, format 2015-09-21T23:00:00Z
    - name: sentTo
      description: filter on messages to a specific address
    - name: sentFrom
      description: filter on messages from a specific address
    - name: subject
      description: search email by subject, will override the text argument
    - name: attachmentType
      auto: PREDEFINED
      predefined:
      - optional
      - any
      - documents
      - spreadsheets
      - presentations
      - text
      - images
      - media
      - zips
      - none
      description: optional - messages with and without attachments any - messages
        with any attachment documents - messages with doc, dot, docx, docm, dotx,
        dotm, pdf, rtf, html attachments spreadsheets - messages with xls, xlt, xlsx,
        xlsm, xltx, xltm, xlsb, xlam, csv attachments presentations - messages with
        ppt, pptx, pptm, potx, potm, ppam, ppsx, ppsm, sldx, sldm, thms, pps attachments
        text - messages with txt, text, html, log attachments images - messages with
        jpg, jpeg, png, bmp, gif, psd, tif, tiff attachments media - messages with
        mp3, mp4, m4a, mpg, mpeg, avi, wav, aac, wma, mov attachments zips - messages
        with zip, rar, cab, gz, gzip, 7z attachments none - No attachments are to
        be present in the results
    - name: attachmentText
      description: search for text in attachments
    - name: body
      description: search email by text in body, will override the text and subject
        arguments
    - name: pageSize
      description: Sets the number of results to return per page (default 25)
    - name: startRow
      description: Sets the result to start returning results (default 0)
    - name: active
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Defines if the search should query recently received messages that
        are not fully indexed yet (default false). You can search by mailbox and date
        time across active messages
    description: query mimecast emails
  - name: mimecast-list-blocked-sender-policies
    arguments: []
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is Bidirectional or not
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to Receiver type address
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to Receiver type domain
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to Receiver type group
      type: string
    - contextPath: Mimecast.Policy.FromDate
      description: Policy validation start date
      type: date
    - contextPath: Mimecast.Policy.ToDate
      description: Policy expiration date
      type: date
    description: List all existing mimecast blocked sender policies
  - name: mimecast-get-policy
    arguments:
    - name: policyID
      required: true
      description: Filter by policy ID
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is Bidirectional or not
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to Receiver type address
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to Receiver type domain
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to Receiver type group
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: Policy validation start date
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: Policy expiration date
      type: date
    description: Get a blocked sender policy by ID
  - name: mimecast-create-policy
    arguments:
    - name: description
      required: true
      description: Policy description
    - name: fromPart
      auto: PREDEFINED
      predefined:
      - envelope_from
      - header_from
      - both
      description: Addresses based on
      defaultValue: envelope_from
    - name: fromType
      required: true
      auto: PREDEFINED
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - individual_email_address
      description: Blocked Sender type
    - name: fromValue
      description: 'Required if fromType is one of email domain, profile group, individual
        email address. Expected values: If fromType is email_domain, a domain name
        without the @ symbol. If fromType is profile_group, the ID of the profile
        group. If fromType is individual_email_address, an email address.'
    - name: toType
      required: true
      auto: PREDEFINED
      predefined:
      - everyone
      - internal addresses
      - external addresses
      - email domain
      - profile group
      - individual email address
      description: Receiver type
    - name: toValue
      description: 'Required if fromType is one of email domain, profile group, individual
        email address. Expected values: If toType is email_domain, a domain name without
        the @ symbol. If toType is profile_group, the ID of the profile group. If
        toType is individual_email_address, an email address.'
    - name: option
      required: true
      auto: PREDEFINED
      predefined:
      - no_action
      - block_sender
      description: 'The block option, must be one of: no_action, block_sender.'
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is Bidirectional or not
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to Receiver type address
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to Receiver type domain
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to Receiver type group
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: Policy validation start date
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: Policy expiration date
      type: date
    description: Create a Blocked Sender Policy
  - name: mimecast-delete-policy
    arguments:
    - name: policyID
      required: true
      description: Policy ID
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    description: Delete a Blocked Sender Policy
  - name: mimecast-manage-sender
    arguments:
    - name: sender
      required: true
      description: The email address of sender to permit or block
    - name: recipient
      required: true
      description: The email address of recipient to permit or block
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - permit
      - block
      description: Choose to either "permit" (to bypass spam checks) or "block" (to
        reject the email)
    outputs:
    - contextPath: Mimecast.Managed.Sender
      description: The email address of the sender
      type: string
    - contextPath: Mimecast.Managed.Recipient
      description: The email address of the recipient
      type: string
    - contextPath: Mimecast.Managed.Action
      description: Chosen action
      type: string
    - contextPath: Mimecast.Managed.ID
      description: The Mimecast secure ID of the managed sender object.
      type: string
    description: Permit or block a specific sender
  - name: mimecast-list-managed-url
    arguments:
    - name: url
      description: Filter results by specific URL
    outputs:
    - contextPath: Mimecast.URL.Domain
      description: The managed domain
      type: string
    - contextPath: Mimecast.URL.Disablelogclick
      description: If logging of user clicks on the URL is disabled
      type: boolean
    - contextPath: Mimecast.URL.Action
      description: Either block of permit
      type: string
    - contextPath: Mimecast.URL.Path
      description: The path of the managed URL
      type: string
    - contextPath: Mimecast.URL.matchType
      description: Either explicit - applies to the full URL or domain - applies to
        all URL values in the domain
      type: string
    - contextPath: Mimecast.URL.ID
      description: The Mimecast secure ID of the managed URL
      type: string
    - contextPath: Mimecast.URL.disableRewrite
      description: If rewriting of this URL in emails is disabled
      type: boolean
    description: Get a list of all managed URLs
  - name: mimecast-create-managed-url
    arguments:
    - name: url
      required: true
      description: The URL to block or permit. Do not include a fragment (#).
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - block
      - permit
      description: Set to "block" to blacklist the URL, "permit" to whitelist it
    - name: matchType
      auto: PREDEFINED
      predefined:
      - explicit
      - domain
      description: Set to "explicit" to block or permit only instances of the full
        URL. Set to "domain" to block or permit any URL with the same domain
      defaultValue: explicit
    - name: disableRewrite
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Disable rewriting of this URL in emails. Applies only if action
        = "permit". Default false
      defaultValue: "false"
    - name: comment
      description: Add a comment about the managed URL
    - name: disableUserAwareness
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Disable User Awareness challenges for this URL. Applies only if
        action = "permit". Default false
      defaultValue: "false"
    - name: disableLogClick
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Disable logging of user clicks on the URL. Default is false
      defaultValue: "false"
    outputs:
    - contextPath: Mimecast.URL.Domain
      description: The managed domain
      type: string
    - contextPath: Mimecast.URL.Action
      description: Either block of permit
      type: string
    - contextPath: Mimecast.URL.disableLogClick
      description: If logging of user clicks on the URL is disabled
      type: string
    - contextPath: Mimecast.URL.matchType
      description: Either explicit - applies to the full URL or domain - applies to
        all URL values in the domain
      type: string
    - contextPath: Mimecast.URL.ID
      description: The Mimecast secure ID of the managed URL
      type: string
    - contextPath: Mimecast.URL.disableRewrite
      description: If rewriting of this URL in emails is disabled
      type: boolean
    description: Create a managed URL on Mimecast
  - name: mimecast-get-message
    arguments:
    - name: messageID
      required: true
      description: Message ID
    - name: context
      required: true
      auto: PREDEFINED
      predefined:
      - delievered
      - received
      description: 'Defines which copy of the message part to return, must be one
        of: "delievered" the copy that has been processed by the Mimecast MTA with
        policies such as URL rewriting applied, OR "received" - the copy of the message
        that Mimecast originally received.'
    - name: type
      required: true
      auto: PREDEFINED
      predefined:
      - HTML
      - PLAIN
      - RFC822
      - TRANSMISSION_MESSAGE_BODY
      description: The message part to return
    - name: info
      auto: PREDEFINED
      predefined:
      - body
      - metadata
      - all
      defaultValue: all
      description: 'Message body, Message meta data or all.'
    outputs:
    - contextPath: Mimecast.Message.ID
      description: Message ID
      type: string
    description: Get the contents of a given message
  - name: mimecast-list-messages
    arguments:
    - name: mailbox
      description: The email address to return the message list for
    - name: startTime
      description: The start date of messages to return, in the following format,
        2015-11-16T14:49:18+0000. Default is the last calendar month
    - name: endTime
      description: The end date of messages to return, in the following format, 2015-11-16T14:49:18+0000.
        Default is the end of the current day
    - name: view
      auto: PREDEFINED
      predefined:
      - INBOX
      - SENT
      description: 'The message list type, must be one of: inbox or sent, default
        is inbox'
      defaultValue: INBOX
    - name: subject
      description: Filter by message subject
    outputs:
    - contextPath: Mimecast.Message.Subject
      description: Message Subject
      type: string
    - contextPath: Mimecast.Message.ID
      description: Message ID
      type: string
    - contextPath: Mimecast.Message.Size
      description: The size of the message in bytes
      type: number
    - contextPath: Mimecast.Message.RecievedDate
      description: The date the message was received
      type: date
    - contextPath: Mimecast.Message.From
      description: The mail Sender
      type: string
    - contextPath: Mimecast.Message.AttachmentCount
      description: The number of attachments on the message
      type: string
    description: Get a list of messages for a given user
  - name: mimecast-get-attachment-logs
    arguments:
    - name: resultsNumber
      description: The number of results to request. Default is all
    - name: fromDate
      description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day
    - name: toDate
      description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request
    - name: resultType
      auto: PREDEFINED
      predefined:
      - safe
      - malicious
      - timeout
      - error
      - unsafe
      - all
      description: Filters logs by scan result, default is malicious
      defaultValue: malicious
    - name: limit
      description: Limit number of returned results.
      defaultValue: "100"
    outputs:
    - contextPath: Mimecast.AttachmentLog.Result
      description: 'The result of the attachment analysis: clean, malicious, unknown,
        or timeout'
      type: string
    - contextPath: Mimecast.AttachmentLog.Date
      description: The time at which the attachment was released from the sandbox
      type: date
    - contextPath: Mimecast.AttachmentLog.Sender
      description: The sender of the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.FileName
      description: The file name of the original attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.Action
      description: The action triggered for the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.Recipient
      description: The address of the user that received the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.FileType
      description: The file type of the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.Route
      description: 'The route of the original email containing the attachment, either:
        inbound, outbound, internal, or external'
      type: string
    description: Returns Attachment Protect logs for a Mimecast customer account
  - name: mimecast-get-url-logs
    arguments:
    - name: resultsNumber
      description: The number of results to request. Default is all
    - name: fromDate
      description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day
    - name: toDate
      description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request
    - name: resultType
      auto: PREDEFINED
      predefined:
      - clean
      - malicious
      - all
      description: Filters logs by scan result, default is all
      defaultValue: malicious
    - name: limit
      description: Limit number of returned results.
      defaultValue: "100"
    outputs:
    - contextPath: Mimecast.UrlLog.Category
      description: The category of the URL clicked
      type: string
    - contextPath: Mimecast.UrlLog.UserAddress
      description: The email address of the user who clicked the link
      type: string
    - contextPath: Mimecast.UrlLog.URL
      description: The url clicked
      type: string
    - contextPath: Mimecast.UrlLog.Awareness
      description: The action taken by the user if user awareness was applied
      type: string
    - contextPath: Mimecast.UrlLog.AdminOverride
      description: The action defined by the administrator for the URL
      type: string
    - contextPath: Mimecast.UrlLog.Date
      description: The date that the URL was clicked
      type: date
    - contextPath: Mimecast.UrlLog.Result
      description: The result of the URL scan
      type: string
    - contextPath: Mimecast.UrlLog.Action
      description: The action that was taken for the click
      type: string
    - contextPath: Mimecast.UrlLog.Route
      description: 'The route of the original email containing the attachment, either:
        inbound, outbound, internal, or external'
      type: string
    - contextPath: Mimecast.UrlLog. userOverride
      description: The action requested by the user.
      type: string
    description: Returns URL protect logs for a Mimecast customer account
  - name: mimecast-get-impersonation-logs
    arguments:
    - name: resultsNumber
      description: The number of results to request. Default is all
    - name: taggedMalicious
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: ' Filters for messages tagged malicious (true) or not tagged malicious
        (false). Omit for no tag filtering. default is true'
      defaultValue: "true"
    - name: searchField
      auto: PREDEFINED
      predefined:
      - senderAddress
      - recipientAddress
      - subject
      - policy
      - all
      description: The field to search,Defaults to all (meaning all of the preceding
        fields)
    - name: query
      description: Required if searchField exists. A character string to search for
        in the logs.
    - name: identifiers
      auto: PREDEFINED
      predefined:
      - newly_observed_domain
      - internal_user_name
      - repy_address_mismatch
      - targeted_threat_dictionary
      description: Filters logs by identifiers, can include any of newly_observed_domain,
        internal_user_name, repy_address_mismatch, and targeted_threat_dictionary.
        you can choose more then one identifier separated by comma.
      isArray: true
    - name: fromDate
      description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day
    - name: toDate
      description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request
    - name: actions
      auto: PREDEFINED
      predefined:
      - delete
      - hold
      - bounce
      - smart_folder
      - disable_smart_folder
      - content_expire
      - meta_expire
      - stationery
      - gcc
      - secure_delivery
      - derivery_route
      - document_policy
      - disable_document_policy
      - attach_set_policy
      - remove_email
      description: Filters logs by action, you can choose more then one action separated
        by comma.
      isArray: true
    - name: limit
      description: Limit number of returned results.
      defaultValue: "100"
    outputs:
    - contextPath: Mimecast.Impersonation.ResultCount
      description: The total number of IMPERSONATION log lines found for the request
      type: number
    - contextPath: Mimecast.Impersonation.Hits
      description: The number of identifiers that the message triggered
      type: number
    - contextPath: Mimecast.Impersonation.Malicious
      description: Whether the message was tagged as malicious
      type: boolean
    - contextPath: Mimecast.Impersonation.SenderIP
      description: The source IP address of the message
      type: string
    - contextPath: Mimecast.Impersonation.SenderAddress
      description: The email address of the sender of the message
      type: string
    - contextPath: Mimecast.Impersonation.Subject
      description: The subject of the email
      type: string
    - contextPath: Mimecast.Impersonation.Identifiers
      description: 'The properties of the message that triggered the action: similar_internal_domain,
        newly_observed_domain, internal_user_name, reply_address_mismatch, and/or
        targeted_threat_dictionary'
      type: string
    - contextPath: Mimecast.Impersonation.Date
      description: The time at which the log was recorded
      type: date
    - contextPath: Mimecast.Impersonation.Action
      description: ' The action triggered by the email'
      type: string
    - contextPath: Mimecast.Impersonation.Policy
      description: The name of the policy definition that triggered the log
      type: string
    - contextPath: Mimecast.Impersonation.ID
      description: Impersonation Log ID
      type: string
    - contextPath: Mimecast.Impersonation.RecipientAddress
      description: The email address of the recipient of the email
      type: string
    - contextPath: Mimecast.Impersonation.External
      description: Whether the message was tagged as coming from an external address
      type: boolean
    description: Returns Impersonation Protect logs for a Mimecast customer account
  - name: mimecast-url-decode
    arguments:
    - name: url
      required: true
      description: URL to decode
    outputs:
    - contextPath: URL.Data
      description: The encoded url to parse
      type: string
    - contextPath: URL.Mimecast.DecodedURL
      description: Parsed url
      type: string
    description: Decodes a given url from mimecast
  isfetch: true
  runonce: false
releaseNotes: "Added 12 new commands, added fetch incidents: url, attachments, impersonations. Commands: mimecast-list-blocked-sender-policies, mimecast-create-policy, mimecast-delete-policy, mimecast-get-policy, mimecast-query, mimecast-url-decode, mimecast-manage-sender, mimecast-list-managed-url, mimecast-create-managed-url, mimecast-list-messages, mimecast-get-url-logs, mimecast-get-impersonation-logs, mimecast-get-attachment-logs"
tests:
  - Mimecast test
