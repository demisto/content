commonfields:
  id: Cylance Protect v2
  version: -1
name: Cylance Protect v2
display: Cylance Protect v2
category: Endpoint
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAABRCAYAAAByintQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA0xpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDE0IDc5LjE1Njc5NywgMjAxNC8wOC8yMC0wOTo1MzowMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzM0NkEwQTAzMUUxMTFFNTgyMzNCQTlGNzdBMTQyMjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzM0NkEwOUYzMUUxMTFFNTgyMzNCQTlGNzdBMTQyMjEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmM5Y2E4NDJkLTc4NDgtMTE3OC05YWFmLWFhYjViOTEyZmE5OSIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmM5Y2E4NDJkLTc4NDgtMTE3OC05YWFmLWFhYjViOTEyZmE5OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0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
description: Manage Endpoints using Cylance protect
configuration:
- display: Server URL
  name: server
  defaultvalue: https://protectapi.cylance.com
  type: 0
  required: true
- display: Application ID
  name: app_id
  defaultvalue: ""
  type: 0
  required: true
- display: Application Secret
  name: app_secret
  defaultvalue: ""
  type: 4
  required: true
- display: Tenant API Key
  name: tid
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: File Threshold
  name: file_threshold
  defaultvalue: "-59"
  type: 0
  required: false
script:
  script: |+
    import jwt
    import uuid
    import requests
    import json
    import re
    import zipfile
    import shutil
    from zipfile import ZipFile
    from StringIO import StringIO
    from datetime import datetime, timedelta

    # CONSTANTS
    TOKEN_TIMEOUT = 300 # 5 minutes

    URI_AUTH = 'auth/v2/token'
    URI_DEVICES = 'devices/v2'
    URI_POLICIES = 'policies/v2'
    URI_ZONES = 'zones/v2'
    URI_THREATS = 'threats/v2'
    URI_LISTS = 'globallists/v2'

    SCOPE_DEVICE_LIST = 'device:list'
    SCOPE_DEVICE_READ = 'device:read'
    SCOPE_DEVICE_UPDATE = 'device:update'
    SCOPE_DEVICE_THREATLIST = 'device:threatlist'
    SCOPE_POLICY_LIST = 'policy:list'
    SCOPE_POLICY_READ = 'policy:read'
    SCOPE_ZONE_CREATE = 'zone:create'
    SCOPE_ZONE_LIST = 'zone:list'
    SCOPE_ZONE_READ = 'zone:read'
    SCOPE_ZONE_UPDATE = 'zone:update'
    SCOPE_THREAT_READ = 'threat:read'
    SCOPE_THREAT_DEVICELIST = 'threat:devicelist'
    SCOPE_THREAT_UPDATE = 'threat:update'
    SCOPE_GLOBAL_LIST = 'globallist:list'
    SCOPE_THREAT_LIST = 'threat:list'
    SCOPE_GLOBAL_LIST_CREATE = 'globallist:create'
    SCOPE_GLOBAL_LIST_DELETE = 'globallist:delete'

    # PREREQUISITES
    def load_server_url():
        ''' Cleans and loads the server url from the configuration '''
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url

    # remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # GLOBALS
    APP_ID = demisto.params()['app_id']
    APP_SECRET = demisto.params()['app_secret']
    TID = demisto.params()['tid']
    SERVER_URL = load_server_url()
    FILE_THRESHOLD = demisto.params()['file_threshold']



    # HELPERS
    def generate_jwt_times():
        '''
        Generates the epoch time window in which the token will be valid
        Returns the current timestamp and the timeout timestamp (in that order)
        '''
        now = datetime.utcnow()
        timeout_datetime = now + timedelta(seconds=TOKEN_TIMEOUT)
        epoch_time = int((now - datetime(1970, 1, 1)).total_seconds())
        epoch_timeout = int((timeout_datetime - datetime(1970, 1, 1)).total_seconds())
        return epoch_time, epoch_timeout


    def api_call(uri, method = 'post', headers = {}, body = {}, params = {}, accept_404 = False):
        '''
        Makes an API call to the server URL with the supplied uri, method, headers, body and params
        '''
        url = '%s/%s' % (SERVER_URL, uri)
        res = requests.request(method, url, headers=headers, data=json.dumps(body), params=params)
        if res.status_code < 200 or res.status_code >= 300:
            if not res.status_code == 404 and not accept_404:
                return_error('Got status code ' + str(res.status_code) + ' with body ' + res.content + ' with headers ' + str(res.headers))
        return json.loads(res.text) if res.text else res.ok


    def get_authentication_token(scope = None):
        '''
        Generates a JWT authorization token with an optional scope and queries the API for an access token
        Returns the received API access token
        '''
        # Generate token ID
        token_id = str(uuid.uuid4())

        # Generate current time & token timeout
        epoch_time, epoch_timeout = generate_jwt_times()
        # Token claims
        claims = {
            'exp': epoch_timeout,
            'iat': epoch_time,
            'iss': 'http://cylance.com',
            'sub': APP_ID,
            'tid': TID,
            'jti': token_id
        }

        if scope:
            claims['scp'] = scope

        # Encode the token
        encoded = jwt.encode(claims, APP_SECRET, algorithm='HS256')
        payload = {'auth_token': encoded}
        headers = {'Content-Type': 'application/json; charset=utf-8'}
        res = api_call(method='post', uri=URI_AUTH, body=payload, headers=headers)
        return res['access_token']

    def threat_to_incident(threat):
            incident = {}
            incident['name'] = 'Cylance Protect v2 threat ' + threat['name']
            incident['occurred'] = threat['last_found'] + 'Z'
            incident['rawJSON'] = json.dumps(threat)

            host_name = None
            devices = get_threat_devices_request(threat['sha256'], None, None)['page_items']
            for device in devices:
                if device['date_found'] == threat['last_found']:
                    host_name = device['name']

            labels = []
            labels.append({'type':'Classification','value':threat['classification']})
            labels.append({'type':'MD5','value':threat['md5']})
            labels.append({'type':'SHA256','value':threat['sha256']})
            labels.append({'type':'ThreatLastFound','value':threat['last_found']})
            labels.append({'type':'HostName','value':host_name})
            incident['labels'] = labels
            return incident

    def normalize_score(score):
        ''' Translates API raw float (-1 to 1) score to UI score (-100 to 100) '''
        return score*100

    def translate_score(score, threshold):
        if score > 0:
            dbot_score = 1
        elif threshold <= score:
            dbot_score = 2
        else:
            dbot_score = 3
        return dbot_score

    # FUNCTIONS
    def test():
        access_token = get_authentication_token()
        if not access_token:
            raise Exception('Unable to get access token')
        demisto.results('ok')

    def get_devices():
        page = demisto.args()['pageNumber'] if 'pageNumber' in demisto.args() else None
        page_size = demisto.args()['pageSize'] if 'pageSize' in demisto.args() else None
        result = get_devices_request(page, page_size)
        devices = result['page_items']
        hr = []
        devices_context = []
        endpoint_context = []
        for device in devices:
            current_device_context = {
                'AgentVersion': device['agent_version'],
                'DateFirstRegistered': device['date_first_registered'],
                'ID': device['id'],
                'IPAddress': device['ip_addresses'],
                'MACAdress': device['mac_addresses'],
                'Hostname': device['name'],
                'State': device['state']
            }
            if device['policy']:
                policy = {}
                if device['policy']['id']:
                    policy['ID'] = device['policy']['id']
                if device['policy']['name']:
                    policy['Name'] = device['policy']['name']
                if policy:
                    current_device_context['Policy'] = policy
            devices_context.append(current_device_context)
            endpoint_context.append({
                'IPAddress': device['ip_addresses'],
                'MACAdress': device['mac_addresses'],
                'Hostname': device['name']
            })
            current_device = dict(device)
            current_device['ip_addresses'] = ', '.join(current_device['ip_addresses'])
            current_device['mac_addresses'] = ', '.join(current_device['mac_addresses'])
            current_device['policy'] = current_device['policy']['name']
            hr.append(current_device)

        ec = {
            'CylanceProtect.Device(val.ID && val.ID === obj.ID)': devices_context,
            'Endpoint(val.Hostname && val.Hostname === obj.Hostname)': endpoint_context
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': devices,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Cylance Protect Devices', hr, headerTransform=underscoreToCamelCase, removeNull=True),
            'EntryContext': ec
        }

        demisto.results(entry)


    def get_devices_request(page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_DEVICE_LIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if page:
            params['page'] = page
        if page_size:
            params['page_size'] = page_size
        res = api_call(uri=URI_DEVICES, method='get', headers=headers, params=params)
        return res

    def get_device():
        device_id = demisto.args()['id']
        device = get_device_request(device_id)
        device_context = {
            'IPAddress': device['ip_addresses'],
            'MACAdress': device['mac_addresses'],
            'Hostname': device['host_name'],
            'OSVersion': device['os_version'],
            'UpdateAvailable': device['update_available'],
            'BackgroundDetection': device['background_detection'],
            'DateFirstRegistered': device['date_first_registered'],
            'DateLastModified': device['date_last_modified'],
            'DateOffline': device['date_offline'],
            'IsSafe': device['is_safe'],
            'LastLoggedInUser': device['last_logged_in_user'],
            'State': device['state'],
            'ID': device['id'],
            'Name': device['name']
        }
        if device['update_type']:
            device_context['UpdateType'] = device['update_type']
        if device['policy']:
            policy = {}
            if device['policy']['id']:
                policy['ID'] = device['policy']['id']
            if device['policy']['name']:
                policy['Name'] = device['policy']['name']
            if policy:
                device_context['Policy'] = policy
        endpoint_context = {
            'IPAddress': device['ip_addresses'],
            'MACAdress': device['mac_addresses'],
            'Hostname': device['host_name'],
            'OSVersion': device['os_version']
        }
        ec = {
            'Endpoint(val.Hostname && val.Hostname === obj.Hostname)': endpoint_context,
            'CylanceProtect.Device(val.ID && val.ID === obj.ID)': device_context
        }

        hr = []
        current_device = dict(device)
        current_device['ip_addresses'] = ', '.join(current_device['ip_addresses'])
        current_device['mac_addresses'] = ', '.join(current_device['mac_addresses'])
        current_device['policy'] = current_device['policy']['name']
        hr.append(current_device)

        title = 'Cylance Protect Device ' + device_id
        entry = {
            'Type': entryTypes['note'],
            'Contents': device,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr, headerTransform=underscoreToCamelCase, removeNull=True),
            'EntryContext': ec
        }

        demisto.results(entry)

    def get_device_request(device_id):
        access_token = get_authentication_token(scope=SCOPE_DEVICE_READ)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
        uri = '%s/%s' % (URI_DEVICES, device_id)
        res = api_call(uri=uri, method='get', headers=headers)
        return res


    def update_device():
        device_id = demisto.args()['id']

        name = demisto.args()['name'] if 'name' in demisto.args() else None
        policy_id = demisto.args()['policyId'] if 'policyId' in demisto.args() else None
        add_zones = demisto.args()['addZones'] if 'addZones' in demisto.args() else None
        remove_zones = demisto.args()['removeZones'] if 'removeZones' in demisto.args() else None

        result = update_device_request(device_id, name, policy_id, add_zones, remove_zones)

        hr = {}

        if name:
            hr['Name'] = name
        if policy_id:
            hr['PolicyID'] = policy_id
        if add_zones:
            hr['AddedZones'] = add_zones
        if remove_zones:
            hr['RemovedZones'] = remove_zones

        device = hr.copy()
        device['id'] = device_id

        title = 'Device ' + device_id +  ' was updated successfully.'
        entry = {
            'Type': entryTypes['note'],
            'Contents': device,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, [hr])
        }

        demisto.results(entry)

    def update_device_request(device_id, name = None, policy_id = None, add_zones = None, remove_zones = None):
        access_token = get_authentication_token(scope=SCOPE_DEVICE_UPDATE)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        body = {}
        if name:
            body['name'] = name
        if policy_id:
            body['policy_id'] = policy_id
        if add_zones:
            body['add_zone_ids'] = [add_zones]
        if remove_zones:
            body['remove_zone_ids'] = [remove_zones]

        # Do we have anything to update?
        if not body:
            raise Exception('No changes detected')

        uri = '%s/%s' % (URI_DEVICES, device_id)
        res = api_call(uri=uri, method='put', headers=headers, body=body)
        return res


    def get_device_threats():
        device_id = demisto.args()['id']
        page = demisto.args()['pageNumber'] if 'pageNumber' in demisto.args() else None
        page_size = demisto.args()['pageSize'] if 'pageSize' in demisto.args() else None

        device_threats = get_device_threats_request(device_id, page, page_size)['page_items']
        dbot_score_array = []

        for threat in device_threats:
            dbot_score = 0
            score = threat.get('cylance_score', None)
            if score:
                threat['cylance_score'] = normalize_score(threat['cylance_score'])
                threshold = demisto.args().get('threshold', FILE_THRESHOLD)
                dbot_score = translate_score(threat['cylance_score'], int(threshold))
            dbot_score_array.append({
                'Indicator': threat['name'],
                'Type': 'file',
                'Vendor': 'Cylance Protect',
                'Score': dbot_score
            })
        if device_threats:
            threats_context = createContext(data=device_threats, keyTransform=underscoreToCamelCase)
            ec = {
                'File': threats_context,
                'DBotScore': dbot_score_array
            }

            title = 'Cylance Protect Device Threat ' + device_id
            entry = {
                'Type': entryTypes['note'],
                'Contents': device_threats,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, device_threats, headerTransform=underscoreToCamelCase),
                'EntryContext': ec
            }
        else:
            entry = 'No threats found.'

        demisto.results(entry)


    def get_device_threats_request(device_id, page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_DEVICE_THREATLIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if page:
            params['page'] = page
        if page_size:
            params['page_size'] = page_size
        uri = '%s/%s/threats' % (URI_DEVICES, device_id)
        res = api_call(uri=uri, method='get', headers=headers, params=params)
        return res


    def get_policies():
        page = demisto.args()['pageNumber'] if 'pageNumber' in demisto.args() else None
        page_size = demisto.args()['pageSize'] if 'pageSize' in demisto.args() else None

        policies = get_policies_request(page, page_size)['page_items']

        context_policies = createContext(data=policies, keyTransform=underscoreToCamelCase)
        ec = {
            'CylanceProtect.Policies(val.id && val.id === obj.id)': context_policies
        }

        title = 'Cylance Protect Policies'
        entry = {
            'Type': entryTypes['note'],
            'Contents': policies,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, policies, headerTransform=underscoreToCamelCase),
            'EntryContext': ec
        }

        demisto.results(entry)


    def get_policies_request(page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_POLICY_LIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if page:
            params['page'] = page
        if page_size:
            params['page_size'] = page_size

        res = api_call(uri=URI_POLICIES, method='get', headers=headers, params=params)
        return res


    def create_zone():
        name = demisto.args()['name']
        policy_id = demisto.args()['policy_id']
        criticality = demisto.args()['criticality']

        zone = create_zone_request(name, policy_id, criticality)

        title = 'Zone ' + name +  ' was created successfully.'
        entry = {
            'Type': entryTypes['note'],
            'Contents': zone,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, [zone], headerTransform=underscoreToCamelCase)
        }

        demisto.results(entry)


    def create_zone_request(name, policy_id, criticality):
        access_token = get_authentication_token(scope=SCOPE_ZONE_CREATE)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
        body = {
            'name': name,
            'policy_id': policy_id,
            'criticality': criticality
        }
        res = api_call(uri=URI_ZONES, method='post', headers=headers, body=body)
        return res


    def get_zones():
        page = demisto.args()['pageNumber'] if 'pageNumber' in demisto.args() else None
        page_size = demisto.args()['pageSize'] if 'pageSize' in demisto.args() else None

        zones = get_zones_request(page, page_size)['page_items']

        context_zones = createContext(data=zones, keyTransform=underscoreToCamelCase, removeNull=True)
        ec = {
            'CylanceProtect.Zones(val.Id && val.Id === obj.Id)':  context_zones
        }

        title = 'Cylance Protect Zones'
        entry = {
            'Type': entryTypes['note'],
            'Contents': zones,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, zones, headerTransform=underscoreToCamelCase, removeNull=True),
            'EntryContext': ec
        }

        demisto.results(entry)

    def get_zones_request(page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_ZONE_LIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if page:
            params['page'] = page
        if page_size:
            params['page_size'] = page_size

        res = api_call(uri=URI_ZONES, method='get', headers=headers, params=params)
        return res


    def get_zone():
        zone_id = demisto.args()['id']
        zone = get_zone_request(zone_id)

        context_zone = createContext(data=zone, keyTransform=underscoreToCamelCase, removeNull=True)
        ec = {
            'CylanceProtect.Zones(val.Id && val.Id === obj.Id)':  context_zone
        }

        title = 'Cylance Protect Zone ' + zone_id
        entry = {
            'Type': entryTypes['note'],
            'Contents': zone,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, zone, headerTransform=underscoreToCamelCase, removeNull=True),
            'EntryContext': ec
        }

        demisto.results(entry)

    def get_zone_request(zone_id):
        access_token = get_authentication_token(scope=SCOPE_ZONE_READ)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
        uri = '%s/%s' % (URI_ZONES, zone_id)
        res = api_call(uri=uri, method='get', headers=headers)
        return res


    def update_zone():
        zone_id = demisto.args()['id']

        # Get current zone and fill in requires missing arguments
        currentZone = get_zone_request(zone_id)

        # Details to update
        name = demisto.args()['name'] if 'name' in demisto.args() else currentZone['name']
        policy_id = demisto.args()['policy_id'] if 'policy_id' in demisto.args() else currentZone['policy_id']
        criticality = demisto.args()['criticality'] if 'criticality' in demisto.args() else currentZone['criticality']

        zone = update_zone_reqeust(zone_id, name, policy_id, criticality)

        hr = {}

        if name:
            hr['Name'] = name
        if policy_id:
            hr['PolicyID'] = policy_id
        if criticality:
            hr['Criticality'] = criticality

        title = 'Zone was updated successfully.'
        entry = {
            'Type': entryTypes['note'],
            'Contents': zone,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, [hr])
        }

        demisto.results(entry)

    def update_zone_reqeust(zone_id, name, policy_id, criticality):
        access_token = get_authentication_token(scope=SCOPE_ZONE_UPDATE)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        body = {}
        if name:
            body['name'] = name
        if policy_id:
            body['policy_id'] = policy_id
        if criticality:
            body['criticality'] = criticality

        # Do we have anything to update?
        if not body:
            raise Exception('No changes detected')

        uri = '%s/%s' % (URI_ZONES, zone_id)
        res = api_call(uri=uri, method='put', headers=headers, body=body)
        return res


    def get_threat():
        hash = demisto.args()['sha256']
        threat = get_threat_request(hash)
        if threat:
            dbot_score = 0
            score = threat.get('cylance_score', None)
            if score:
                threat['cylance_score'] = normalize_score(threat['cylance_score'])
                threshold = demisto.args().get('threshold', FILE_THRESHOLD)
                dbot_score = translate_score(threat['cylance_score'], int(threshold))
            context_threat = createContext(data=threat, keyTransform=underscoreToCamelCase, removeNull=True)
            ec = {
                'File':  context_threat,
                'DBotScore': {
                    'Indicator': threat['name'],
                    'Type': 'file',
                    'Vendor': 'Cylance Protect',
                    'Score': dbot_score
                }
            }

            title = 'Cylance Protect Threat ' + hash
            entry = {
                'Type': entryTypes['note'],
                'Contents': threat,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, threat, headerTransform=underscoreToCamelCase, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'Threat was not found.'

        demisto.results(entry)

    def get_threat_request(hash):
        access_token = get_authentication_token(scope=SCOPE_THREAT_READ)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
        uri = '%s/%s' % (URI_THREATS, hash)
        res = api_call(uri=uri, method='get', headers=headers, body = {}, params = {}, accept_404 = False)
        return res

    def get_threats():
        page = demisto.args()['page'] if 'page' in demisto.args() else None
        page_size = demisto.args()['page_size'] if 'page_size' in demisto.args() else None

        threats = get_threats_request(page, page_size)['page_items']
        dbot_score_array = []
        for threat in threats:
            dbot_score = 0
            score = threat.get('cylance_score', None)
            if score:
                threat['cylance_score'] = normalize_score(threat['cylance_score'])
                threshold = demisto.args().get('threshold', FILE_THRESHOLD)
                dbot_score = translate_score(threat['cylance_score'], int(threshold))
            dbot_score_array.append({
                'Indicator': threat['name'],
                'Type': 'file',
                'Vendor': 'Cylance Protect',
                'Score': dbot_score
            })
        context_threat = createContext(data=threats, keyTransform=underscoreToCamelCase, removeNull=True)
        ec = {
            'File':  context_threat,
            'DBotScore': dbot_score_array
        }

        title = 'Cylance Protect Threats'
        entry = {
            'Type': entryTypes['note'],
            'Contents': threats,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, threats, headerTransform=underscoreToCamelCase, removeNull=True),
            'EntryContext': ec
        }

        demisto.results(entry)


    def get_threats_request(page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_THREAT_LIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if page in demisto.args():
            params['page'] = demisto.args()['page']
        if page_size in demisto.args():
            params['page_size'] = demisto.args()['page_size']

        res = api_call(uri=URI_THREATS, method='get', headers=headers, params=params)
        return res


    def get_threat_devices():
        threat_hash = demisto.args()['sha256']
        page = demisto.args()['pageNumber'] if 'pageNumber' in demisto.args() else None
        page_size = demisto.args()['pageSize'] if 'pageSize' in demisto.args() else None

        threats = get_threat_devices_request(threat_hash, page, page_size)['page_items']

        if threats:
            threats_context = threats[:]

            for threat in threats:
                threat['ip_addresses'] = ', '.join(threat['ip_addresses'])
                threat['mac_addresses'] = ', '.join(threat['mac_addresses'])

            file_paths = []
            endpoint_context = []
            devices_context = []
            for threat in threats_context:
                endpoint_context.append({
                    'Hostname':threat['name'],
                    'IPAddress': threat['ip_addresses'],
                    'MACAddress': threat['mac_addresses']
                })
                current_device = {
                    'Hostname':threat['name'],
                    'IPAddress': threat['ip_addresses'],
                    'MACAddress': threat['mac_addresses'],
                    'AgentVersion': threat['agent_version'],
                    'DateFound': threat['date_found'],
                    'FilePath': threat['file_path'],
                    'MACAddress': threat['mac_addresses'],
                    'ID': threat['id'],
                    'State': threat['state'],
                    'FileStatus': threat['file_status']
                }
                if threat['policy_id']:
                    current_device['PolicyID'] = threat['policy_id']
                devices_context.append(current_device)
                file_path = threat.pop('file_path')
                file_paths.append({
                    'FilePath': file_path
                })

            file_context = {
                'SHA256': threat_hash,
                'Path': file_paths
            }

            ec = {
                'File':  file_context,
                'Endpoint(val.Hostname && val.Hostname === obj.Hostname)': endpoint_context,
                'CylanceProtect.Threat(val.SHA256 && val.SHA256 === obj.SHA256)': {
                        'SHA256': threat_hash,
                        'Devices': devices_context
                }
            }

            title = 'Cylance Protect Threat ' + threat_hash + ' Devices'
            entry = {
                'Type': entryTypes['note'],
                'Contents': threats,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, threats, headerTransform=underscoreToCamelCase, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No devices found on given threat.'

        demisto.results(entry)


    def get_threat_devices_request(threat_hash, page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_THREAT_DEVICELIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if page:
            params['page'] = page
        if page_size:
            params['page_size'] = page_size

        uri = '%s/%s/devices' % (URI_THREATS, threat_hash)
        res = api_call(uri=uri, method='get', headers=headers, params=params)
        return res

    def get_list():
        page = demisto.args()['pageNumber'] if 'pageNumber' in demisto.args() else None
        page_size = demisto.args()['pageSize'] if 'pageSize' in demisto.args() else None

        lst = get_list_request(demisto.args()['listTypeId'], page, page_size)['page_items']
        dbot_score_array = []
        for threat in lst:
            dbot_score = 0
            score = threat.get('cylance_score', None)
            if score:
                threat['cylance_score'] = normalize_score(threat['cylance_score'])
                threshold = demisto.args().get('threshold', FILE_THRESHOLD)
                dbot_score = translate_score(threat['cylance_score'], int(threshold))
            dbot_score_array.append({
                'Indicator': threat['name'],
                'Type': 'file',
                'Vendor': 'Cylance Protect',
                'Score': dbot_score
            })
        if lst:
            context_list = createContext(data=lst, keyTransform=underscoreToCamelCase, removeNull=True)
            ec = {
                'File':  context_list,
                'DBotScore': dbot_score_array
            }

            title = 'Cylance Protect Global List'
            entry = {
                'Type': entryTypes['note'],
                'Contents': lst,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, lst, headerTransform=underscoreToCamelCase, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No list of this type was found.'
        demisto.results(entry)

    def get_list_request(list_type_id, page = None, page_size = None):
        access_token = get_authentication_token(scope=SCOPE_GLOBAL_LIST)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        params = {}
        if list_type_id == 'GlobalQuarantine':
            params['listTypeId'] = 0
        else: # List Type ID is GlobalSafe
            params['listTypeId'] = 1
        if page:
            params['page'] = page
        if page_size:
            params['page_size'] = page_size
        res = api_call(uri=URI_LISTS, method='get', headers=headers, params=params)
        return res

    def get_list_entry_by_hash(sha256=None, listTypeId=None):
        if not sha256:
            sha256 = demisto.args()['sha256']
        if not listTypeId:
            listTypeId = demisto.args()['listTypeId']
        total_pages = None
        current_page = None
        found_hash = None
        while not found_hash and total_pages >= current_page:
            if not current_page:
                current_page = 1
            lst = get_list_request(listTypeId, current_page, 200)
            if not total_pages:
                total_pages = lst['total_pages']
            for i in lst['page_items']:
                if i['sha256'] == sha256:
                    found_hash = i
                    break
            current_page += 1
        if demisto.command() == 'cylance-protect-get-list-entry':
            if found_hash:
                context_list = createContext(data=found_hash, keyTransform=underscoreToCamelCase, removeNull=True)

                ec = {
                'CylanceListSearch':  context_list
                }

                title = 'Cylance Protect Global List Entry'

                entry = {
                'Type': entryTypes['note'],
                'Contents': found_hash,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, found_hash, headerTransform=underscoreToCamelCase, removeNull=True),
                'EntryContext': ec
                }

                demisto.results(entry)
            else:
                demisto.results("Hash not found")
        else:
            return found_hash


    def get_indicators_report():
        url = 'https://protect.cylance.com/Reports/ThreatDataReportV1/indicators/' + demisto.args()['token']
        res = requests.request('GET', url)
        filename = 'Indicators_Report.csv'
        demisto.results(fileResult(filename, res.content))

    def update_device_threats():

        device_id = demisto.args()['device_id']
        threat_id = demisto.args()['threat_id']
        event = demisto.args()['event']
        res = update_device_threats_request(device_id, threat_id, event)
        demisto.results('Device threat was updated successfully.')

    def update_device_threats_request(device_id, threat_id, event):
        access_token = get_authentication_token(scope=SCOPE_THREAT_UPDATE)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        body = {
            'threat_id': threat_id,
            'event': event
        }

        uri = '%s/%s/threats' % (URI_DEVICES, device_id)
        res = api_call(uri=uri, method='post', headers=headers, body=body)

        return res


    def download_threat():

        contents = {}
        context = {}
        dbot_score = 0
        score = 0

        hash = demisto.args()['sha256']
        threat_url = download_threat_request(hash)

        threat_file = requests.get(threat_url, allow_redirects=True)
        if threat_file.status_code == 200:
            if demisto.args()['unzip'] == "yes":
                file_archive = StringIO(threat_file.content)
                zip_file = zipfile.ZipFile(file_archive)
                file_data = zip_file.read(hash.upper(), pwd='infected')
                demisto.results(fileResult(hash, file_data))
            else:
                demisto.results(fileResult(hash, threat_file.content + '.zip'))
        else:
            return_error('Could not fetch the file')

        threat = get_threat_request(hash)
        if threat:
            # add data about the threat if found
            if threat.get('cylance_score'):
                score = normalize_score(threat.get('cylance_score'))
                threshold = demisto.args().get('threshold', FILE_THRESHOLD)
                dbot_score = translate_score(score, int(threshold))

            contents = {
                'Download URL': threat_url,
                'File Name': threat.get('name'),
                'File Size': threat.get('file_size'),
                'Detected By': threat.get('detected_by'),
                'GlobalQuarantine': threat.get('global_quarantined'),
                'Safelisted': threat.get('safelisted'),
                'Timestamp': threat.get('cert_timestamp'),
            }

            context[outputPaths['file']] = {
                'DownloadURL': threat_url,
                'SHA256': threat.get('sha256'),
                'Name': threat.get('name'),
                'Size': threat.get('file_size'),
                'Safelisted': threat.get('safelisted'),
                'Timestamp': threat.get('cert_timestamp'),
                'MD5': threat.get('md5')
            }

            if dbot_score == 3:
                context[outputPaths['file']]['Malicious'] = {
                    'Vendor': 'Cylance Protect',
                    'Description': 'Score determined by get threat command'
                }

            context[outputPaths['dbotscore']] = {
                'Indicator': threat.get('name'),
                'Type': 'file',
                'Vendor': 'Cylance Protect',
                'Score': dbot_score
            }


        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Cylance Protect - Downloading threat attached to the following hash: ' +  hash, contents),
            'EntryContext': context
        })


    def download_threat_request(hash):
        access_token = get_authentication_token(scope=SCOPE_THREAT_READ)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
        uri = '%s/%s/%s' % (URI_THREATS, "download", hash)
        res = api_call(uri=uri, method='get', headers=headers)
        if not res['url']:
            return_error('No url was found')
        return res['url']


    def add_hash_to_list():

        context = {}
        contents = {}

        hash = demisto.args().get('sha256')
        list_type = demisto.args().get('listType')
        reason = demisto.args().get('reason')
        category = demisto.args().get('category')

        if list_type == "GlobalSafe" and not category:
            return_error('Category argument is required for list type of Global Safe')

        add_hash = add_hash_to_list_request(hash, list_type, reason, category)
        if not add_hash:
            return_error('Could not add hash to list')

        contents = {
            'Threat File SHA256': hash,
            'List Type': list_type,
            'Category': category,
            'Reason': reason
        }

        context[outputPaths['file']] = {
            'SHA256': hash,
            'Cylance': {
                'ListType': list_type,
                'Category': category
            }
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('The requested threat has been successfully added to ' + list_type + ' hashlist.', contents),
            'EntryContext': context
        })

    def add_hash_to_list_request(sha256, list_type, reason, category=None):
        access_token = get_authentication_token(scope=SCOPE_GLOBAL_LIST_CREATE)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        body = {
            'sha256': sha256,
            'list_type': list_type,
            'reason': reason
        }
        if category:
            body['category'] = category.replace(" ", "")
        res = api_call(uri=URI_LISTS, method='post', headers=headers, body=body)
        return res


    def delete_hash_from_lists():

        hash = demisto.args().get('sha256')
        list_type = demisto.args().get('listType')
        contents = {}
        context =  {}

        delete_hash = delete_hash_from_lists_request(hash, list_type)

        contents = {
            'Threat File SHA256': hash,
            'Threat List Type': list_type
        }

        context[outputPaths['file']] = {
            'SHA256': hash,
            'Cylance': {
                'ListType': list_type
            }
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('The requested threat has been successfully removed from ' + list_type + ' hashlist.', contents),
            'EntryContext': context
        })


    def delete_hash_from_lists_request(sha256, list_type):
        access_token = get_authentication_token(scope=SCOPE_GLOBAL_LIST_DELETE)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        body = {
            'sha256': sha256,
            'list_type': list_type
        }
        res = api_call(uri=URI_LISTS, method='delete', headers=headers, body=body)
        return res


    def delete_devices():

        device_ids = demisto.args().get('deviceIds')
        device_ids_list = argToList(device_ids)
        contents = []
        context = []
        context_list = []

        for device_id in device_ids_list:
            device = get_device_request(device_id)
            if not device:
                continue
            device_name = device.get('name')
            context_list.append({
                'Id': device_id,
                'Name': device_name,
                'Deleted': True
            })
            contents.append({
                'Device Removed': device_id,
                'Device Name': device_name,
                'Deletion status': True
            })

        devices_deleted = delete_devices_request(device_ids_list)
        context = {
            'Cylance.Device(val.Id && val.Id == obj.Id)': context_list
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('The requested devices have been successfully removed from your organization list.', contents),
            'EntryContext': context
        })


    def delete_devices_request(device_ids):

        access_token = get_authentication_token()
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
        body = {
            'device_ids': device_ids
        }

        res = api_call(uri=URI_DEVICES, method='delete', headers=headers, body=body)
        if not res or not res.get('request_id'):
            return_error('Delete response does not contain request id')

        return res


    def get_policy_details():
        policy_id = demisto.args()['policyID']
        contents = {}
        context = {}
        title = 'Could not find policy details for that ID'
        filetype_actions_threat_contents = {}
        filetype_actions_suspicious_contents = {}
        safelist_contents = {}
        title_filetype_actions_threat = 'Cylance Policy Details - FileType Actions Threat Files'
        title_filetype_actions_suspicious = 'Cylance Policy Details - FileType Actions Suspicious Files'
        title_safelist = 'Cylance Policy Details - File Exclusions - SafeList'
        title_memory_exclusion = 'Cylance Policy Details - Memory Violation Actions \n' + 'This table provides detailed information about the memory voilation settings. \n' + 'Memory protections Exclusion List :'
        title_memory_violation = 'Memory Violation Settings: '
        title_additional_settings = 'Cylance Policy Details - Policy Settings. \n' + 'Various policy settings are contained within this section.'

        policy_details = get_policy_details_request(policy_id)
        if policy_details:
            title = 'Cylance Policy Details for: ' + policy_id
            timestamp = 0
            reg = None
            ts = 0
            date_time = ''
            # timestamp in response comes back as bugged string, convert to actual timestamp.
            timestamp = policy_details.get('policy_utctimestamp')
            if timestamp:
                reg = re.search("\d{13}", timestamp)
                ts = float(reg.group())
                date_time = datetime.fromtimestamp(ts/1000).strftime('%Y-%m-%dT%H:%M:%S.%f+00:00')

            context = {
                'Cylance.Policy(val.ID && val.ID == obj.ID)': {
                    'ID': policy_details.get('policy_id'),
                    'Name': policy_details.get('policy_name'),
                    'Timestamp': date_time
                }
            }

            contents = {
                'Policy Name': policy_details.get('policy_name'),
                'Policy Created At': date_time
            }

            suspicious_files = policy_details.get('filetype_actions').get('suspicious_files')
            if suspicious_files:
                suspicious_files_list = []
                for file in suspicious_files:
                    suspicious_files_list.append({
                        'Actions': file.get('actions'),
                        'File Type': file.get('file_type')
                    })

            threat_files = policy_details.get('filetype_actions').get('threat_files')
            if threat_files:
                threat_files_list = []
                for file in threat_files:
                    threat_files_list.append({
                        'Actions': file.get('actions'),
                        'File Type': file.get('file_type')
                    })

            filetype_actions_suspicious_contents = suspicious_files_list
            filetype_actions_threat_contents = threat_files_list
            safelist = policy_details.get('file_exclusions')
            if safelist:
                file_exclusions_list = []
                for file_exclusion in safelist:
                    file_exclusions_list.append({
                        'Research Class ID': file_exclusion.get('research_class_id'),
                        'Infinity': file_exclusion.get('infinity'),
                        'File Type': file_exclusion.get('file_type'),
                        'AV Industry': file_exclusion.get('av_industry'),
                        'Cloud Score': file_exclusion.get('cloud_score'),
                        'File Hash': file_exclusion.get('file_hash'),
                        'Research Subclass ID': file_exclusion.get('research_subclass_id'),
                        'Reason': file_exclusion.get('reason'),
                        'File Name': file_exclusion.get('file_name'),
                        'Category Id': file_exclusion.get('category_id'),
                        'MD5': file_exclusion.get('md5')
                    })

                safelist_contents = file_exclusions_list

            memory_violations = policy_details.get('memoryviolation_actions').get('memory_violations')
            memory_violations_content = []
            for memory_violation in memory_violations:
                memory_violations_content.append({
                    'Action': memory_violation.get('action'),
                    'Violation Type': memory_violation.get('violation_type')
                })

            additional_settings = policy_details.get('policy')
            additional_settings_content = []
            for additional_setting in additional_settings:
                additional_settings_content.append({
                    'Name': memory_violation.get('name'),
                    'Value': memory_violation.get('value')
                })


        demisto.results({
                'Type': entryTypes['note'],
                'Contents': contents,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, contents) +
                tableToMarkdown(title_filetype_actions_suspicious, filetype_actions_suspicious_contents) +
                tableToMarkdown(title_filetype_actions_threat, filetype_actions_threat_contents) +
                tableToMarkdown(title_safelist, safelist_contents) +
                tableToMarkdown(title_memory_exclusion, policy_details.get('memory_exclusion_list')) +
                tableToMarkdown(title_memory_violation, memory_violations_content) +
                tableToMarkdown(title_additional_settings, memory_violations_content),
                'EntryContext': context
            })


    def get_policy_details_request(policy_id):
        access_token = get_authentication_token(scope=SCOPE_POLICY_READ)
        headers = {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }

        uri = '%s/%s' % (URI_POLICIES, policy_id)
        res = api_call(uri=uri, method='get', headers=headers)
        return res


    def fetch_incidents():
        now = datetime.utcnow()
        last_run = demisto.getLastRun().get('time')
        if last_run is None:
            now = now - timedelta(days=3)
            last_run = now
        else:
            last_run = datetime.strptime(last_run, '%Y-%m-%dT%H:%M:%S') #Converts string to datetime object
        current_run = last_run
        threats = get_threats_request().get('page_items', [])

        incidents = []
        for threat in threats:
            last_found = datetime.strptime(threat['last_found'], '%Y-%m-%dT%H:%M:%S')
            if last_found > last_run:
                incident = threat_to_incident(threat)
                incidents.append(incident)
            if last_found > current_run:
                current_run = last_found

        demisto.incidents(incidents)
        demisto.setLastRun({ 'time': current_run.isoformat().split('.')[0] })


    # EXECUTION
    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-module':
            test()

        if demisto.command() == 'fetch-incidents':
            fetch_incidents()

        elif demisto.command() == 'cylance-protect-get-devices':
            get_devices()

        elif demisto.command() == 'cylance-protect-get-device':
            get_device()

        elif demisto.command() == 'cylance-protect-update-device':
            update_device()

        elif demisto.command() == 'cylance-protect-get-device-threats':
            get_device_threats()

        elif demisto.command() == 'cylance-protect-get-policies':
            get_policies()

        elif demisto.command() == 'cylance-protect-create-zone':
            create_zone()

        elif demisto.command() == 'cylance-protect-get-zones':
            get_zones()

        elif demisto.command() == 'cylance-protect-get-zone':
            get_zone()

        elif demisto.command() == 'cylance-protect-update-zone':
            update_zone()

        elif demisto.command() == 'cylance-protect-get-threat':
            get_threat()

        elif demisto.command() == 'cylance-protect-get-threats':
            get_threats()

        elif demisto.command() == 'cylance-protect-get-threat-devices':
            get_threat_devices()

        elif demisto.command() == 'cylance-protect-get-indicators-report':
            get_indicators_report()

        elif demisto.command() == 'cylance-protect-update-device-threats':
            update_device_threats()

        elif demisto.command() == 'cylance-protect-get-list':
            get_list()

        elif demisto.command() == 'cylance-protect-get-list-entry':
            get_list_entry_by_hash()

        # new commands
        elif demisto.command() == 'cylance-protect-download-threat':
            download_threat()

        elif demisto.command() == 'cylance-protect-add-hash-to-list':
            add_hash_to_list()

        elif demisto.command() == 'cylance-protect-delete-hash-from-lists':
            delete_hash_from_lists()

        elif demisto.command() == 'cylance-protect-delete-devices':
            delete_devices()

        elif demisto.command() == 'cylance-protect-get-policy-details':
            get_policy_details()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise

  type: python
  commands:
  - name: cylance-protect-get-devices
    arguments:
    - name: pageNumber
      description: The page number parameter is optional. When the value is not specified,
        the default is 1.
    - name: pageSize
      description: The page size parameter is optional. When the value is not specified,
        the default is 10. Max is 200.
    outputs:
    - contextPath: CylanceProtect.Device.AgentVersion
      description: The CylancePROTECT Agent version installed on the device.
      type: string
    - contextPath: CylanceProtect.Device.DateFirstRegistered
      description: The date and time (in UTC) when the device record was created.
      type: date
    - contextPath: CylanceProtect.Device.ID
      description: The device’s unique identifier.
      type: string
    - contextPath: Endpoint.IPAddress
      description: The list of IP addresses for the device.
    - contextPath: Endpoint.MACAddress
      description: The list of MAC addresses for the device.
    - contextPath: Endpoint.Hostname
      description: The device name.
      type: string
    - contextPath: CylanceProtect.Device.Policy.ID
      description: Device policy ID
      type: string
    - contextPath: CylanceProtect.Device.State
      description: Machine state
      type: string
    - contextPath: CylanceProtect.Device.Policy.Name
      description: Device policy name
      type: string
    - contextPath: CylanceProtect.Device.Hostname
      description: The device name.
      type: string
    - contextPath: CylanceProtect.Device.MACAddress
      description: The list of MAC addresses for the device.
      type: unknown
    - contextPath: CylanceProtect.Device.IPAddress
      description: The list of IP addresses for the device.
    description: Allows a caller to request a page with a list of Console device resources
      belongings to a Tenant, sorted by registration (created) date in descending
      order (most recent device registered listed first)
  - name: cylance-protect-get-device
    arguments:
    - name: id
      required: true
      default: true
      description: The device ID
    outputs:
    - contextPath: CylanceProtect.Device.AgentVersion
      description: The CylancePROTECT Agent version installed on the device.
      type: date
    - contextPath: CylanceProtect.Device.DateFirstRegistered
      description: The date and time (in UTC) when the device record was created.
      type: date
    - contextPath: CylanceProtect.Device.BackgroundDetection
      description: If true, the Agent is currently running.
      type: boolean
    - contextPath: CylanceProtect.Device.DateLastModified
      description: The date and time (in UTC) when the device record was last modified.
      type: date
    - contextPath: CylanceProtect.Device.DateOffline
      description: The date and time (in UTC) when the device last communicated with
        the Console.
      type: date
    - contextPath: CylanceProtect.Device.Hostname
      description: The hostname for the device.
      type: string
    - contextPath: CylanceProtect.Device.ID
      description: The unique identifier for the device.
      type: string
    - contextPath: CylanceProtect.Device.IPAddress
      description: The list of IP addresses for the device.
    - contextPath: CylanceProtect.Device.MACAddress
      description: The list of MAC addresses for the device.
    - contextPath: CylanceProtect.Device.IsSafe
      description: If true, there are no outstanding threats.
      type: boolean
    - contextPath: CylanceProtect.Device.UpdateAvailable
      description: If true, there is available update for the device
      type: boolean
    - contextPath: CylanceProtect.Device.State
      description: Machine state
      type: string
    - contextPath: Endpoint.Hostname
      description: Device hostname
      type: string
    - contextPath: Endpoint.MACAddress
      description: The list of MAC addresses for the device.
    - contextPath: Endpoint.IPAddress
      description: The list of IP addresses for the device.
    - contextPath: Endpoint.OSVersion
      description: Device OS version
      type: string
    - contextPath: CylanceProtect.Device.OSVersion
      description: Device OS version
      type: string
    - contextPath: CylanceProtect.Device.Name
      description: Device name
      type: string
    description: Allows a caller to request a specific device resource belonging to
      a Tenant
  - name: cylance-protect-update-device
    arguments:
    - name: id
      required: true
      default: true
      description: The device ID
    - name: name
      description: The device name
    - name: policyId
      description: The policy ID
    - name: addZones
      description: Zones IDs to add
      isArray: true
    - name: removeZones
      description: Zones IDs to remove
      isArray: true
    description: Allows a caller to update a specific Console device resource belonging
      to a Tenant
  - name: cylance-protect-get-device-threats
    arguments:
    - name: id
      required: true
      default: true
      description: The device ID
    - name: threshold
      description: If threat score is less or equal than the threshold, then file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    - name: pageNumber
      description: The page number parameter is optional. When the value is not specified,
        the default is 1.
    - name: pageSize
      description: The page size parameter is optional. When the value is not specified,
        the default is 10. Max is 200.
    outputs:
    - contextPath: File.Classification
      description: The threat classification assigned by Cylance.
      type: string
    - contextPath: File.CylanceScore
      description: The Cylance score assigned to the threat.
      type: number
    - contextPath: File.DateFound
      description: The date and time (in UTC) when the threat was found on the device.
      type: string
    - contextPath: File.FilePath
      description: The file path where the threat was found on the device.
      type: string
    - contextPath: File.FileStatus
      description: The current status of the file on the device. This can be one of
        the following:Default (0),Quarantined (1),Whitelisted (2),Suspicious (3),FileRemoved
        (4),Corrupt (5)
      type: number
    - contextPath: File.Name
      description: The name of the threat.
      type: string
    - contextPath: File.Sha256
      description: The SHA256 hash for the threat.
      type: string
    - contextPath: File.SubClassification
      description: The threat sub-classification assigned by Cylance.
      type: string
    - contextPath: DBotScore.Indicator
      description: The tested indicator
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Allows a caller to request a page with a list of threats found on
      a specific device
  - name: cylance-protect-get-policies
    arguments:
    - name: pageNumber
      description: The page number parameter is optional. When the value is not specified,
        the default is 1.
    - name: pageItems
      description: The page size parameter is optional. When the value is not specified,
        the default is 10. Max is 200.
    outputs:
    - contextPath: CylanceProtect.Policies.DateAdded
      description: The date and time (in UTC) when the Console policy resource was
        first created.
      type: string
    - contextPath: CylanceProtect.Policies.DateModified
      description: The date and time (in UTC) when the Console policy resource was
        last modified.
      type: string
    - contextPath: CylanceProtect.Policies.DeviceCount
      description: The number of devices assigned to this policy.
      type: number
    - contextPath: CylanceProtect.Policies.Id
      description: The unique ID for the policy resource.
      type: string
    - contextPath: CylanceProtect.Policies.Name
      description: The name of the policy.
      type: string
    - contextPath: CylanceProtect.Policies.ZoneCount
      description: The number of zones assigned to this policy.
      type: number
    description: Allows the caller to get a list of tenant policies
  - name: cylance-protect-create-zone
    arguments:
    - name: name
      required: true
      description: The name of the zone
    - name: policy_id
      required: true
      description: The unique ID for the policy assigned to the Zone
    - name: criticality
      required: true
      auto: PREDEFINED
      predefined:
      - Low
      - Medium
      - High
      description: The criticality value of the Zone
    description: Create (add) a zone to your Console
  - name: cylance-protect-get-zones
    arguments:
    - name: pageNumber
      description: The page number parameter is optional. When the value is not specified,
        the default is 1.
    - name: pageItems
      description: The page size parameter is optional. When the value is not specified,
        the default is 10. Max is 200.
    outputs:
    - contextPath: CylanceProtect.Zones.Criticality
      description: The Value of the Zone – Low, Medium, or High.
      type: string
    - contextPath: CylanceProtect.Zones.DateCreated
      description: The date and time (in UTC) when the zone was created.
      type: string
    - contextPath: CylanceProtect.Zones.DateModified
      description: The date and time (in UTC) when the zone was last modified.
      type: string
    - contextPath: CylanceProtect.Zones.Id
      description: The unique ID of the zone.
      type: string
    - contextPath: CylanceProtect.Zones.Name
      description: The name of the zone.
      type: string
    - contextPath: CylanceProtect.Zones.PolicyId
      description: The unique ID of the policy assigned to the zone.
      type: string
    - contextPath: CylanceProtect.Zones.UpdateType
      description: The update type for the zone.
      type: string
    - contextPath: CylanceProtect.Zones.ZoneRuleId
      description: The unique ID for the zone rule created for the zone.
      type: string
    description: Request zone information for your organization. This will return
      the top 100 records
  - name: cylance-protect-get-zone
    arguments:
    - name: id
      required: true
      default: true
      description: The zone ID
    outputs:
    - contextPath: CylanceProtect.Zones.Criticality
      description: The Value of the Zone – Low, Medium, or High.
      type: string
    - contextPath: CylanceProtect.Zones.DateCreated
      description: The date and time (in UTC) when the zone was created.
      type: string
    - contextPath: CylanceProtect.Zones.DateModified
      description: The date and time (in UTC) when the zone was last modified.
      type: string
    - contextPath: CylanceProtect.Zones.Id
      description: The unique ID of the zone.
      type: string
    - contextPath: CylanceProtect.Zones.Name
      description: The name of the zone.
      type: string
    - contextPath: CylanceProtect.Zones.PolicyId
      description: The unique ID of the policy assigned to the zone.
      type: string
    - contextPath: CylanceProtect.Zones.UpdateType
      description: The update type for the zone.
      type: string
    - contextPath: CylanceProtect.Zones.ZoneRuleId
      description: The unique ID for the zone rule created for the zone.
      type: string
    description: Request zone information for a specific zone in your organization
  - name: cylance-protect-update-zone
    arguments:
    - name: id
      required: true
      default: true
      description: The zone ID
    - name: name
      description: The name of the zone
    - name: policyId
      description: The unique ID for the policy assigned to the Zone
    - name: criticality
      auto: PREDEFINED
      predefined:
      - Low
      - Medium
      - High
      description: The criticality value of the Zone
    description: Update a zone in your organization
  - name: cylance-protect-get-threat
    arguments:
    - name: sha256
      required: true
      default: true
      description: The SHA256 hash of the threat
    outputs:
    - contextPath: File.AutoRun
      description: Indicates if the file is set to automatically run on system startup.
      type: boolean
    - contextPath: File.AvIndustry
      description: The score provided by the Anti-Virus industry.
      type: number
    - contextPath: File.CertIssuer
      description: The ID for the certificate issuer.
      type: string
    - contextPath: File.CertPublisher
      description: The ID for the certificate publisher.
      type: string
    - contextPath: File.CertTimestamp
      description: The date and time (in UTC) when the file was signed using the certificate.
      type: string
    - contextPath: File.Classification
      description: The threat classification for the threat.
      type: string
    - contextPath: File.CylanceScore
      description: The Cylance Score assigned to the threat.
      type: number
    - contextPath: File.DetectedBy
      description: The name of the Cylance module that detected the threat.
      type: string
    - contextPath: File.FileSize
      description: The size of the file.
      type: number
    - contextPath: File.GlobalQuarantine
      description: Identifies if the threat is on the Global Quarantine list.
      type: boolean
    - contextPath: File.Md5
      description: The MD5 hash for the threat.
      type: string
    - contextPath: File.Name
      description: The name of the threat.
      type: string
    - contextPath: File.Running
      description: Identifies if the threat is executing, or another executable loaded
        or called it.
      type: boolean
    - contextPath: File.Safelisted
      description: Identifies if the threat is on the Safe List.
      type: boolean
    - contextPath: File.Sha256
      description: The SHA256 hash for the threat.
      type: string
    - contextPath: File.Signed
      description: Identifies the file as signed or not signed.
      type: boolean
    - contextPath: File.SubClassification
      description: The threat sub-classification for the threat.
      type: string
    - contextPath: File.UniqueToCylance
      description: The threat was identified by Cylance but not by other anti-virus
        sources.
      type: boolean
    - contextPath: DBotScore.Indicator
      description: The tested indicator
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Request threat details for a specific threat
  - name: cylance-protect-get-threat-devices
    arguments:
    - name: sha256
      required: true
      default: true
      description: The SHA256 hash of the threat
    outputs:
    - contextPath: CylanceProtect.Threat.Devices.ID
      description: The device ID.
      type: string
    - contextPath: CylanceProtect.Threat.Devices.DateFound
      description: The date and time (in UTC) when the threat was found on the device.
      type: date
    - contextPath: CylanceProtect.Threat.Devices.AgentVersion
      description: The agent version installed on the device.
      type: string
    - contextPath: CylanceProtect.Threat.Devices.FileStatus
      description: Current quarantine status of the file on the device. Default (0),Quarantined
        (1),Whitelisted (2),Suspicious (3),FileRemoved (4),Corrupt (5)
      type: number
    - contextPath: Endpoint.IPAddress
      description: The list of IP addresses for the device.
    - contextPath: Endpoint.MACAddress
      description: The list of MAC addresses for the device.
    - contextPath: Endpoint.Hostname
      description: The device name for the device.
      type: string
    - contextPath: CylanceProtect.Threat.Devices.PolicyID
      description: The unique identifier of the policy assigned to the device, or
        null if no policy is assigned.
      type: string
    - contextPath: CylanceProtect.Threat.Devices.State
      description: The state of the device (Offline,Online).
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the threat
      type: string
    - contextPath: File.Path
      description: The path where the file was found on the device.
      type: string
    - contextPath: CylanceProtect.Threat.Devices.Hostname
      description: The device name for the device.
      type: string
    - contextPath: CylanceProtect.Threat.Devices.IPAddress
      description: The list of IP addresses for the device.
    - contextPath: CylanceProtect.Threat.Devices.MACAddress
      description: The list of MAC addresses for the device.
    description: Allows a caller to request  a list of devices on a specific threat
  - name: cylance-protect-get-indicators-report
    arguments:
    - name: token
      required: true
      description: Threat data report token
    description: Produces a CSV threat data report of the indicators
  - name: cylance-protect-get-threats
    arguments:
    - name: page_size
      description: The page size parameter is optional. When the value is not specified,
        the default is 10. Max is 200.
    - name: page
      description: The page number parameter is optional. When the value is not specified,
        the default is 1.
    outputs:
    - contextPath: File.Classification
      description: The threat classification for the threat.
      type: string
    - contextPath: File.SubClassification
      description: The threat sub-classification for the threat.
      type: string
    - contextPath: File.Sha256
      description: The SHA256 hash for the threat.
      type: string
    - contextPath: File.Safelisted
      description: Identifies if the threat is on the Safe List.
      type: boolean
    - contextPath: File.Name
      description: The name of the threat.
      type: string
    - contextPath: File.LastFound
      description: The date and time (in UTC) when the file was last found.
      type: string
    - contextPath: File.CylanceScore
      description: The Cylance Score assigned to the threat.
      type: number
    - contextPath: File.GlobalQuarantine
      description: Identifies if the threat is on the Global Quarantine list.
      type: string
    - contextPath: File.UniqueToCylance
      description: The threat was identified by Cylance but not by other anti-virus
        sources.
      type: string
    - contextPath: File.FileSize
      description: The size of the file.
      type: number
    - contextPath: File.Md5
      description: The MD5 hash for the threat.
      type: string
    - contextPath: DBotScore.Indicator
      description: The tested indicator
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Gets information about Cylance Protect threats
  - name: cylance-protect-update-device-threats
    arguments:
    - name: threat_id
      required: true
      description: The SHA256 hash of the convicted threat
    - name: event
      required: true
      auto: PREDEFINED
      predefined:
      - Quarantine
      - Waive
      description: The requested status update for the convicted threat.
    - name: device_id
      required: true
      description: ID of device to be updated
    description: ' Updates the status (waive or quarantine) of a convicted threat'
    execution: true
  - name: cylance-protect-get-list
    arguments:
    - name: listTypeId
      required: true
      auto: PREDEFINED
      predefined:
      - GlobalQuarantine
      - GlobalSafe
      description: 'The type of the list to retrieve the hashes for. '
    - name: page
      description: The page number parameter is optional. When the value is not specified,
        the default is 1.
    - name: page_size
      description: The page size parameter is optional. When the value is not specified,
        the default is 10. Max is 200.
    outputs:
    - contextPath: File.Added
      description: The timestamp when the file was added to the list.
      type: string
    - contextPath: File.AddedBy
      description: The tenant user ID who added the file to the list.
      type: string
    - contextPath: File.AvIndustry
      description: The score provided by the Anti-Virus industry.
      type: number
    - contextPath: File.Category
      description: The category for the list specified (for the Global Safe list only).
      type: string
    - contextPath: File.Classification
      description: The threat classification assigned by Cylance.
      type: string
    - contextPath: File.CylanceScore
      description: The Cylance score assigned to the threat.
      type: number
    - contextPath: File.ListType
      description: The list type that the threat belongs to (GlobalQuarantine or GlobalSafe).
      type: string
    - contextPath: File.Md5
      description: The MD5 has for the threat.
      type: string
    - contextPath: File.Sha256
      description: The SHA256 has for the threat.
      type: string
    - contextPath: File.Name
      description: The name of the threat.
      type: string
    - contextPath: DBotScore.Indicator
      description: The tested indicator
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Gets a list of global list resources for a tenant
  - name: cylance-protect-download-threat
    arguments:
    - name: sha256
      required: true
      description: The SHA256 hash for the file you want to download.
    - name: threshold
      description: file threshold to determine reputation
    - name: unzip
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Check if you want to file to be returned unzipped into the war
        room
      defaultValue: "no"
    outputs:
    - contextPath: File.SHA256
      description: SHA256
      type: string
    - contextPath: File.Name
      description: Name
      type: string
    - contextPath: File.Size
      description: Size
      type: number
    - contextPath: File.Safelisted
      description: Safelisted
      type: boolean
    - contextPath: File.Timestamp
      description: Timestamp
      type: string
    - contextPath: File.Md5
      description: Md5
      type: string
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
      type: string
    description: Download threat attached to a specific SHA256 hash.
  - name: cylance-protect-add-hash-to-list
    arguments:
    - name: sha256
      required: true
      description: SHA256 hash to add to the GlobalSafe/GlobalQuarantine list
    - name: listType
      required: true
      auto: PREDEFINED
      predefined:
      - GlobalQuarantine
      - GlobalSafe
      description: The list type to which the threat belongs (GlobalQuarantine or
        GlobalSafe).
    - name: reason
      description: The reason why the file was added to the list.
      defaultValue: Added by Demisto
    - name: category
      auto: PREDEFINED
      predefined:
      - Admin Tool
      - Commercial Software
      - Drivers
      - Internal Application
      - Operating System
      - Security Software
      - None
      description: This field is required only if the list_type value is Global Safe.
        The value can be one ofthe following:• Admin Tool• Commercial Software• Drivers•
        Internal Application• Operating System• Security Software• None
      defaultValue: None
    outputs:
    - contextPath: File.SHA256
      description: The SHA256 hash for the threat.
      type: string
    - contextPath: File.Cylance.ListType
      description: The list type to which the threat belongs (GlobalQuarantine or
        GlobalSafe).
      type: string
    - contextPath: File.Cylance.Category
      description: 'This field is required only if the list_type value is Global Safe.
        The value can be one of the following: • Admin Tool • Commercial Software
        • Drivers • Internal Application • Operating System • Security Software •
        None'
      type: string
    description: Add a convicted threat to either the Global Quarantine or the Global
      Safe list for a particular Tenant
  - name: cylance-protect-delete-hash-from-lists
    arguments:
    - name: sha256
      required: true
      description: The SHA256 hash for the threat.
    - name: listType
      required: true
      auto: PREDEFINED
      predefined:
      - GlobalSafe
      - GlobalQuarantine
      description: The list type to which the threat belongs (GlobalQuarantine or
        GlobalSafe).
    outputs:
    - contextPath: File.SHA256
      description: SHA256
      type: string
    - contextPath: File.Cylance.ListType
      description: The list type to which the threat belongs (GlobalQuarantine or
        GlobalSafe).
      type: string
    description: Remove a convicted threat from either the Global Quarantine or the
      Global Safe list for a particular Tenant.
    execution: true
  - name: cylance-protect-get-policy-details
    arguments:
    - name: policyID
      required: true
      description: The Tenant policy ID to the service endpoint.
    outputs:
    - contextPath: Cylance.Policy.ID
      description: The ID of the policy
      type: string
    - contextPath: Cylance.Policy.Name
      description: The name of the policy
      type: string
    - contextPath: Cylance.Policy.Timestamp
      description: The date and time the policy was created, in UTC.
      type: string
    description: Get details for a single policy.
  - name: cylance-protect-delete-devices
    arguments:
    - name: deviceIds
      required: true
      description: The unique identifiers for the devices to be deleted. The maximum
        number of Device IDs per request is 20.
      isArray: true
    outputs:
    - contextPath: Cylance.Device.Id
      description: The unique identifier of the deletion request.
      type: string
    - contextPath: Cylance.Device.Name
      description: Device Name
      type: string
    - contextPath: Cylance.Device.Deleted
      description: A boolean to check if the device was deleted.
      type: string
    description: Delete one or more devices from an organization.
    execution: true
  dockerimage: demisto/cylance_protect_v2
  isfetch: true
  runonce: false
tests:
  - Cylance Protect v2 Test
