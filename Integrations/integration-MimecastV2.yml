commonfields:
  id: MimecastV2
  version: -1
name: MimecastV2
display: Mimecast
category: Email Gateway
image: data:image/png;base64,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
description: Mimecast unified email management offers cloud email services for email
  security, continuity and archiving emails. Please read detailed instructions in
  order to understand how to set the integration's parameters.
detaileddescription: "1. In order to refresh token / discover auth types of the account
  / create new access & secret keys, \nyou are required to provide: App ID, Account
  email address & password.\nThese parameters support the following integration commands:
  \nmimecast-login -> fetches new access key & secret key\nmimecast-discover -> lists
  supported auth types of user\nmimecast-refresh-token -> refreshes the validity duration
  of access key & secret key (3 days)\n\n2. In order to use the rest of the commands,
  you are required to provide: App ID, App Key, Access Key & Secret Key.\n\n3. Fetch
  Incidents - the integration has the ability to fetch 3 types of incidents: url,
  attachment & impersonation.\nIn order to activate them first tick \"fetch incidents\"
  box, then tick the relevant boxes for each fetch type you want."
configuration:
- display: 'BaseUrl - API url including region, For example https://eu-api.mimecast.com  '
  name: baseUrl
  defaultvalue: https://api.mimecast.com
  type: 0
  required: true
- display: App ID
  name: appId
  defaultvalue: ""
  type: 0
  required: true
- display: User Email Address (Use for auto token refresh)
  name: email
  defaultvalue: ""
  type: 0
  required: false
- display: Password
  name: password
  defaultvalue: ""
  type: 4
  required: false
- display: App key
  name: appKey
  defaultvalue: ""
  type: 4
  required: false
- display: AccessKey
  name: accessKey
  defaultvalue: ""
  type: 0
  required: false
- display: SecretKey
  name: secretKey
  defaultvalue: ""
  type: 4
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch URL incidents
  name: fetchURL
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch attachment incidents
  name: fetchAttachments
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch impersonation incidents
  name: fetchImpersonations
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Hours before first fetch to retrieve incidents
  name: fetchDelta
  defaultvalue: "24"
  type: 0
  required: false
script:
  script: |-
    ''' IMPORTS '''

    import os
    import re
    import sys
    import hmac
    import uuid
    import json
    import time
    import urllib
    import base64
    import hashlib
    import datetime
    import requests
    from urlparse import urlparse
    from urllib2 import HTTPError
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    BASE_URL = demisto.params()['baseUrl']
    ACCESS_KEY = demisto.params()['accessKey']
    SECRET_KEY = demisto.params()['secretKey']
    APP_ID = demisto.params()['appId']
    APP_KEY = demisto.params()['appKey']
    USE_SSL = True if demisto.params().get('insecure') else False
    PROXY = True if demisto.params().get('proxy') else False
    # Flags to control which type of incidents are being fetched
    FETCH_URL = demisto.params().get('fetchURL')
    FETCH_ATTACHMENTS = demisto.params().get('fetchAttachments')
    FETCH_IMPERSONATIONS = demisto.params().get('fetchImpersonations')
    # Used to refresh token / discover available auth types / login
    EMAIL_ADDRESS = demisto.params().get('email')
    PASSWORD = demisto.params().get('password')
    FETCH_DELTA = int(demisto.params().get('fetchDelta', 24))


    # remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    # default query xml template for test module
    default_query_xml = "<?xml version=\"1.0\"?> \n\
        <xmlquery trace=\"iql,muse\">\n\
        <metadata query-type=\"emailarchive\" archive=\"true\" active=\"false\" page-size=\"25\" startrow=\"0\">\n\
            <smartfolders/>\n\
            <return-fields>\n\
                <return-field>attachmentcount</return-field>\n\
                <return-field>status</return-field>\n\
                <return-field>subject</return-field>\n\
                <return-field>size</return-field>\n\
                <return-field>receiveddate</return-field>\n\
                <return-field>displayfrom</return-field>\n\
                <return-field>id</return-field>\n\
                <return-field>displayto</return-field>\n\
                <return-field>smash</return-field>\n\
            </return-fields>\n\
        </metadata>\n\
        <muse>\n\
            <text></text>\n\
            <date select=\"last_year\"/>\n\
            <sent></sent>\n\
            <docs select=\"optional\"></docs>\n\
            <route/>\n\
        </muse>\n\
    </xmlquery>"

    ''' HELPER FUNCTIONS '''


    def epoch_seconds(d=None):
        """
        Return the number of seconds for given date. If no date, return current.
        """
        if not d:
            d = datetime.datetime.utcnow()
        return int((d - datetime.datetime.utcfromtimestamp(0)).total_seconds())


    def auto_refresh_token():
        """
        Check if we have a valid token, if not automatically renew validation time for 3 days when necessary params are provided
        """
        if APP_ID and EMAIL_ADDRESS and PASSWORD:
            integration_context = demisto.getIntegrationContext()
            last_update_ts = integration_context.get('token_last_update')
            current_ts = epoch_seconds()
            if (last_update_ts and current_ts - last_update_ts > 60 * 60 * 24 * 3 - 1800) or last_update_ts is None:
                response = refresh_token_request()
                current_ts = epoch_seconds()
                demisto.setIntegrationContext({'token_last_update': current_ts})


    def http_request(method, api_endpoint, payload=None, params= {}, user_auth=True, is_file=False):
        is_user_auth = True
        url = BASE_URL + api_endpoint
        # 2 types of auth, user and non user, mostly user is needed
        if user_auth:
            # Generate request header values
            request_id = str(uuid.uuid4())
            hdr_date = datetime.datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S") + " UTC"

            # Create the HMAC SHA1 of the Base64 decoded secret key for the Authorization header
            hmac_sha1 = hmac.new(SECRET_KEY.decode("base64"), ':'.join([hdr_date, request_id, api_endpoint, APP_KEY]),
                          digestmod=hashlib.sha1).digest()

            # Use the HMAC SHA1 value to sign the hdrDate + ":" requestId + ":" + URI + ":" + appkey
            signature = base64.encodestring(hmac_sha1).rstrip()

            # Create request headers
            headers = {
                'Authorization': 'MC ' + ACCESS_KEY + ':' + signature,
                'x-mc-app-id': APP_ID,
                'x-mc-date': hdr_date,
                'x-mc-req-id': request_id,
                'Content-Type': 'application/json'
            }
            auth_method = 'user'
        else:
            # This type of auth is only supported for basic commands: login/discover/refresh-token
            is_user_auth = False
            auth = base64.b64encode(EMAIL_ADDRESS + ':' + PASSWORD)
            auth_type = 'Basic-Cloud'
            auth_header = auth_type + ' ' + auth
            headers = {
                'x-mc-app-id': APP_ID,
                'Content-Type': 'application/json',
                'Authorization': auth_header
            }

        LOG('running %s request with url=%s\tparams=%s\tdata=%s\tis user auth=%s' % (method, url, json.dumps(params), json.dumps(payload), is_user_auth))
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                headers=headers,
                data=payload
            )

            res.raise_for_status()
            if is_file:
                return res
            return res.json()

        except HTTPError as e:
            LOG(e)
            if e.response.status_code == 418:
                if not APP_ID or not EMAIL_ADDRESS or not PASSWORD:
                    return_error('Credentials provided are expired, could not automatically refresh tokens. App ID + Email Address + Password are required.')
            else:
                raise

        except Exception, e:
            LOG(e)
            raise


    def parse_query_args(args):
        query_xml = default_query_xml
        if args.get('pageSize'):
            query_xml = query_xml.replace('page-size=\"25\"','page-size=\"'+args.get('pageSize')+'\"')
        if args.get('startRow'):
            query_xml = query_xml.replace('startrow=\"0\"','startrow=\"'+args.get('startRow')+'\"')
        if args.get('active') == 'true':
            query_xml = query_xml.replace('active=\"false\"','active=\"true\"')
        if args.get('body'):
            query_xml = query_xml.replace('<text></text>','<text>(body: '+args.get('body')+')</text>')
        if args.get('subject'):
            query_xml = query_xml.replace('<text></text>','<text>(subject: '+args.get('subject')+')</text>')
        if args.get('text'):
            query_xml = query_xml.replace('<text></text>','<text>'+args.get('text')+'</text>')
        if args.get('date'):
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"'+args.get('date')+'\"/>')

            if args.get('dateTo') or args.get('dateFrom'):
                 return_error('Cannot use both date and dateFrom/dateTo arguments')

        date_to = ""
        date_from = ""

        if args.get('dateTo'):
            date_to = args.get('dateTo')
        if args.get('dateFrom'):
            date_from = args.get('dateFrom')
        if date_to and date_from:
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"between\" from=\"'+date_from+'\" to=\"'+date_to+'\" />')
        elif date_from:
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"between\" from=\"'+date_from+'\" />')
        elif date_to:
            query_xml = query_xml.replace('<date select=\"last_year\"/>','<date select=\"between\" to=\"'+date_to+'\" />')

        if args.get('sentFrom'):
            query_xml = query_xml.replace('<sent></sent>','<sent select=\"from\" >'+args.get('sentFrom')+'</sent>')
        if args.get('sentTo'):
            query_xml = query_xml.replace('<sent></sent>','<sent select=\"to\" >'+args.get('sentTo')+'</sent>')
        query_xml = query_xml.replace('<sent></sent>','') #no empty tag
        if args.get('attachmentText'):
            query_xml = query_xml.replace('</docs>',args.get('attachmentText')+'</docs>')
        if args.get('attachmentType'):
            query_xml = query_xml.replace('<docs select=\"optional\">','<docs select=\"'+args.get('attachmentType')+'\">')

        return query_xml


    '''COMMANDS '''


    def test_module():
        list_managed_url()


    def query():
        headers = ['Subject', 'Display From', 'Display To', 'Received Date', 'Size', 'Attachment Count', 'Status', 'ID']
        contents = []
        context = {}
        messages_context = []
        query_xml  = ''

        if demisto.args().get('queryXml'):
            query_xml = demisto.args().get('queryXml')
        else:
            query_xml = parse_query_args(demisto.args())
        if demisto.args().get('dryRun') == 'true':
            return query_xml

        messages = query_request(query_xml)
        for message in messages:
            contents.append({
                'Subject': message.get('subject'),
                'From': message.get('displayfrom'),
                'To': message.get('displayto'),
                'Received Date': message.get('receiveddate'),
                'Size': message.get('size'),
                'Attachment Count': message.get('attachmentcount'),
                'Status': message.get('status'),
                'ID': message.get('id')
            })
            messages_context.append({
                'Subject': message.get('subject'),
                'Sender': message.get('displayfrom'),
                'Recipient': message.get('displayto'),
                'ReceivedDate': message.get('receiveddate'),
                'Size': message.get('size'),
                'AttachmentCount': message.get('attachmentcount'),
                'Status': message.get('status'),
                'ID': message.get('id')
            })

        context['Mimecast.Message(val.ID && val.ID == obj.ID)'] = messages_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast archived emails', contents, headers),
            'EntryContext': context
        }

        return results


    def query_request(query_xml):
        api_endpoint = '/api/archive/search'
        # API request demands admin boolean, since we don't have any other support but admin we simply pass true.
        data = [{
            'admin': True,
            'query': query_xml
        }]
        payload = {
            'data': data
        }
        response = http_request('POST', api_endpoint, json.dumps(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('items')


    def url_decode():
        headers = []
        contents = {}
        context = {}
        protected_url =  demisto.args().get('url').encode('utf-8')
        decoded_url = url_decode_request(protected_url)
        contents['Decoded URL'] = decoded_url
        context[outputPaths['url']] = {
            'Data': protected_url,
            'Mimecast': {
                'DecodedURL': decoded_url
            }
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Decoded URL:', contents, headers),
            'EntryContext': context
        }

        return results


    def url_decode_request(url):
        # Setup required variables
        api_endpoint = '/api/ttp/url/decode-url'
        payload = {
            'data': [
                {
                    'url': url
                }
            ]
        }
        response = http_request('POST', api_endpoint, str(payload))
        if not response.get('data')[0].get('url'):
            return_error('No URL has been returned from the service')
        return response.get('data')[0].get('url')


    def get_policy():
        headers = ['Policy ID', 'Sender', 'Reciever', 'Bidirectional', 'Start', 'End']
        contents = []
        context = {}
        title = 'Mimecast list blocked sender policies: \n These are the existing Blocked Sender Policies:'
        policy_id =  demisto.args().get('policyID')
        if policy_id:
            policy_id = policy_id.encode('utf-8')
            title = 'Mimecast Get Policy'

        policies_list = get_policy_request(policy_id)
        policies_context = []
        for policy_list in policies_list:
            policy = policy_list.get('policy')
            sender = policy.get('from')
            reciever = policy.get('to')
            contents.append({
                'Policy ID': policy_list['id'],
                'Sender': {
                    'Group': sender.get('groupId'),
                    'Email Address': sender.get('emailAddress'),
                    'Domain': sender.get('emailDomain'),
                    'Type': sender.get('type')
                },
                'Reciever': {
                    'Group': reciever.get('groupId'),
                    'Email Address': reciever.get('emailAddress'),
                    'Domain': reciever.get('domain'),
                    'Type': reciever.get('type')
                },
                'Bidirectional': policy.get('bidirectional'),
                'Start': policy.get('fromDate'),
                'End': policy.get('toDate')
            })
            policies_context.append({
                'ID': policy_list['id'],
                'Sender': {
                    'Group': sender.get('groupId'),
                    'Address': sender.get('emailAddress'),
                    'Domain': sender.get('domain'),
                    'Type': sender.get('type')
                },
                'Reciever': {
                    'Group': reciever.get('groupId'),
                    'Address': reciever.get('emailAddress'),
                    'Domain': reciever.get('domain'),
                    'Type': reciever.get('type')
                },
                'Bidirectional': policy.get('bidirectional'),
                'FromDate': policy.get('fromDate'),
                'ToDate': policy.get('toDate')
            })

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def get_policy_request(policy_id=None):
        # Setup required variables
        api_endpoint = '/api/policy/blockedsenders/get-policy'
        data = []
        if policy_id:
            data.append({
                'id': policy_id
            })
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def create_policy():
        headers = ['Policy ID', 'Sender', 'Reciever', 'Bidirectional', 'Start', 'End']
        contents = {}
        context = {}
        policies_context = {}
        description = demisto.args().get('description').encode('utf-8')
        from_part = demisto.args().get('fromPart').encode('utf-8')
        from_type = demisto.args().get('fromType').encode('utf-8')
        from_value = demisto.args().get('fromValue').encode('utf-8')
        to_type = demisto.args().get('toType').encode('utf-8')
        to_value = demisto.args().get('toValue').encode('utf-8')
        option = demisto.args().get('option').encode('utf-8')

        policy_obj = {
            'description': description,
            'fromPart': from_part,
            'fromType': from_type,
            'fromValue': from_value,
            'toType': to_type,
            'toValue': to_value
        }

        policy_list = create_policy_request(policy_obj,option)
        policy = policy_list.get('policy')
        policy_id = policy_list.get('id')
        title = 'Mimecast Create Policy: \n Policy {} Was Created Successfully!'.format(policy_id)
        sender = policy.get('from')
        reciever = policy.get('to')
        contents = {
            'Policy ID': policy_id,
            'Sender': {
                'Group': sender.get('groupId'),
                'Email Address': sender.get('emailAddress'),
                'Domain': sender.get('emailDomain'),
                'Type': sender.get('type')
            },
            'Reciever': {
                'Group': reciever.get('groupId'),
                'Email Address': reciever.get('emailAddress'),
                'Domain': reciever.get('domain'),
                'Type': reciever.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'Start': policy.get('fromDate'),
            'End': policy.get('toDate')
        }
        policies_context = {
            'ID': policy_id,
            'Sender': {
                'Group': sender.get('groupId'),
                'Address': sender.get('emailAddress'),
                'Domain': sender.get('domain'),
                'Type': sender.get('type')
            },
            'Reciever': {
                'Group': reciever.get('groupId'),
                'Address': reciever.get('emailAddress'),
                'Domain': reciever.get('domain'),
                'Type': reciever.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'FromDate': policy.get('fromDate'),
            'ToDate': policy.get('toDate')
        }

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def create_policy_request(policy, option):
        # Setup required variables
        api_endpoint = '/api/policy/blockedsenders/create-policy'
        payload = {
            'data': [{
                'policy': policy,
                'option': option
            }]
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def delete_policy():
        headers = []
        contents = []
        context = {}
        policy_id =  demisto.args().get('policyID').encode('utf-8')

        deleted_policy = delete_policy_request(policy_id)

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = {
            'ID': policy_id,
            'Deleted': True
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Mimecast Policy {} deleted successfully!'.format(policy_id),
            'EntryContext': context
        }

        return results


    def delete_policy_request(policy_id=None):
        # Setup required variables
        api_endpoint = '/api/policy/blockedsenders/delete-policy'
        data = [{
            'id': policy_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        if response.get('data')[0].get('id') != policy_id:
            return_error('Policy was not deleted.')
        return response.get('data')[0]


    def manage_sender():
        headers = []
        contents = []
        context = {}
        sender =  demisto.args().get('sender').encode('utf-8')
        recipient =  demisto.args().get('recipient').encode('utf-8')
        action =  demisto.args().get('action').encode('utf-8')
        title_action = 'permitted' if action == 'permit' else 'blocked'
        title = 'Mimecast messages from {} to {} will now be {}!'.format(sender,recipient,title_action)

        req_obj = {
            'sender': sender,
            'to': recipient,
            'action': action
        }

        managed_sender = manage_sender_request(req_obj)

        contents = {
            'Sender': managed_sender.get('sender'),
            'Recipient': managed_sender.get('to'),
            'Action': managed_sender.get('type'),
            'ID': managed_sender.get('id')
        }

        context['Mimecast.Managed(val.ID && val.ID == obj.ID)'] = {
            'Sender': managed_sender.get('sender'),
            'Recipient': managed_sender.get('to'),
            'Action': managed_sender.get('type'),
            'ID': managed_sender.get('id')
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def manage_sender_request(req_obj):
        # Setup required variables
        api_endpoint = '/api/managedsender/permit-or-block-sender'
        data = []
        data.append(req_obj)
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint , str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def list_managed_url():
        headers = ['URL','Action','Match Type','User Awareness','URL Rewriting','Comment']
        contents = []
        context = {}
        managed_urls_context = []
        url =  demisto.args().get('url')
        if url:
            url = url.encode('utf-8')

        managed_urls = list_managed_url_request()
        for managed_url in managed_urls:
            query_string = ''
            if managed_url.get('queryString'):
                query_string = '?' + managed_url.get('queryString')
            full_url_response = managed_url.get('scheme') + '://' + managed_url.get('domain') + managed_url.get('path') + query_string
            if (url and url in full_url_response) or not url:
                contents.append({
                    'URL': full_url_response,
                    'Match Type': managed_url.get('matchType'),
                    'Comment': managed_url.get('comment'),
                    'Action': managed_url.get('action'),
                    'URL Rewriting': managed_url.get('disableRewrite'),
                    'User Awareness': managed_url.get('disableUserAwareness')
                })
                managed_urls_context.append({
                    'Domain': managed_url.get('domain'),
                    'disableLogClick': managed_url.get('disableLogClick'),
                    'Action': managed_url.get('action'),
                    'Path': managed_url.get('path'),
                    'matchType': managed_url.get('matchType'),
                    'ID': managed_url.get('id'),
                    'disableRewrite': managed_url.get('disableRewrite')
                })

        context['Mimecast.URL(val.ID && val.ID == obj.ID)'] = managed_urls_context
        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Managed URLs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def list_managed_url_request():
        # Setup required variables
        api_endpoint = '/api/ttp/url/get-all-managed-urls'
        data = []
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def create_managed_url():
        headers = []
        context = {}
        contents = {}
        url_req_obj = {}
        managed_urls_context = []
        url =  demisto.args().get('url').encode('utf-8')
        action = demisto.args().get('action').encode('utf-8')
        match_type = demisto.args().get('matchType').encode('utf-8')
        disable_rewrite = demisto.args().get('disableRewrite').encode('utf-8')
        disable_user_awareness = demisto.args().get('disableUserAwareness').encode('utf-8')
        disable_log_click = demisto.args().get('disableLogClick').encode('utf-8')
        comment = demisto.args().get('comment')
        if comment:
            comment = comment.encode('utf-8')

        url_req_obj = {
           'comment': comment,
           'disableRewrite': disable_rewrite,
           'url': url,
           'disableUserAwareness': disable_user_awareness,
           'disableLogClick': disable_log_click,
           'action': action,
           'matchType': match_type
        }

        managed_url = create_managed_url_request(url_req_obj)
        managed_urls_context.append({
            'Domain': managed_url.get('domain'),
            'disableLogClick': managed_url.get('disableLogClick'),
            'Action': managed_url.get('action'),
            'Path': managed_url.get('path'),
            'matchType': managed_url.get('matchType'),
            'ID': managed_url.get('id'),
            'disableRewrite': managed_url.get('disableRewrite')
        })

        context['Mimecast.URL(val.ID && val.ID == obj.ID)'] = managed_urls_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Managed URL {} created successfully!'.format(url),
            'EntryContext': context
        }

        return results


    def create_managed_url_request(url_obj):
        # Setup required variables
        api_endpoint = '/api/ttp/url/create-managed-url'
        data = []
        data.append(url_obj)
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def list_messages():
        headers = ['Subject', 'Size', 'Recieved Date', 'From', 'Attachment Count', 'Message ID']
        context = {}
        contents = []
        messages_context = []
        search_params = {}

        # can't send null values for keys, so if optional value not sent by user, do not add to request.
        mailbox =  demisto.args().get('mailbox','').encode('utf-8')
        if mailbox:
           search_params['mailbox'] = mailbox
        view =  demisto.args().get('view','').encode('utf-8')
        if view:
            search_params['view'] = view
        end_time =  demisto.args().get('endTime','').encode('utf-8')
        if end_time:
            search_params['end'] = end_time
        start_time =  demisto.args().get('startTime','').encode('utf-8')
        if start_time:
            search_params['start'] = start_time
        subject =  demisto.args().get('subject')

        messages_list = list_messages_request(search_params)

        for message in messages_list:
            if subject == message.get('subject') or not subject:
                contents.append({
                    'Message ID': message.get('id'),
                    'Subject': message.get('subject'),
                    'Size': message.get('size'),
                    'Recieved Date': message.get('received'),
                    'From': message.get('from').get('emailAddress'),
                    'Attachment Count': message.get('attachmentCount')
                })
                messages_context.append({
                    'Subject': message.get('subject'),
                    'ID': message.get('id'),
                    'Size': message.get('size'),
                    'RecievedDate': message.get('received'),
                    'From': message.get('from').get('emailAddress'),
                    'AttachmentCount': message.get('attachmentCount')
                })

        context['Mimecast.Message(val.ID && val.ID == obj.ID)'] = messages_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast messages list', contents, headers),
            'EntryContext': context
        }

        return results


    def list_messages_request(search_params):
        # Setup required variables
        api_endpoint = '/api/archive/get-message-list'
        data = []
        data.append(search_params)
        payload = {
            'meta': {
              'pagination': {
              }
            },
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def get_url_logs():
        headers = []
        contents = []
        context = {}
        url_logs_context = []
        search_params = {}
        result_number =  demisto.args().get('resultsNumber', '').encode('utf-8')
        from_date =  demisto.args().get('fromDate', '').encode('utf-8')
        to_date =  demisto.args().get('toDate', '').encode('utf-8')
        scan_result =  demisto.args().get('resultType', '').encode('utf-8')
        limit = int(demisto.args().get('limit', 100))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if scan_result:
            search_params['scanResult'] = scan_result

        url_logs = get_url_logs_request(search_params, result_number)
        if limit:
           url_logs = url_logs[:limit]
        for url_log in url_logs:

            contents.append({
                'Action': url_log.get('action'),
                'Admin Override': url_log.get('adminOverride'),
                'Category': url_log.get('category'),
                'Date': url_log.get('date'),
                'Route': url_log.get('route'),
                'Scan Result': url_log.get('scanResult'),
                'URL': url_log.get('url'),
                'User Awareness Action': url_log.get('userAwarenessAction'),
                'User Email Address': url_log.get('userEmailAddress'),
                'User Override': url_log.get('userOverride')
            })
            url_logs_context.append({
                'Action' : url_log.get('action'),
                'AdminOverride': url_log.get('adminOverride'),
                'Category': url_log.get('category'),
                'Date': url_log.get('date'),
                'Route': url_log.get('route'),
                'Result': url_log.get('scanResult'),
                'URL': url_log.get('url'),
                'Awareness': url_log.get('userAwarenessAction'),
                'Address': url_log.get('userEmailAddress'),
                'UserOverride': url_log.get('userOverride')
            })


        context['Mimecast.UrlLog'] = url_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast URL logs: ', contents, headers),
            'EntryContext': context
        }

        return results

    def get_url_logs_request(search_params,result_number=None):
         # Setup required variables
        api_endpoint = '/api/ttp/url/get-logs'
        pagination = {}
        if result_number:
            pagination = { 'page_size': result_number }
        payload = {
            'meta': {
              'pagination': pagination
            },
            'data': [search_params]
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('clickLogs')


    def get_attachment_logs():
        headers = []
        contents = []
        context = {}
        attachment_logs_context = []
        search_params = {}
        result_number =  demisto.args().get('resultsNumber', '').encode('utf-8')
        from_date =  demisto.args().get('fromDate', '').encode('utf-8')
        to_date =  demisto.args().get('toDate', '').encode('utf-8')
        result =  demisto.args().get('resultType', '').encode('utf-8')
        limit = int(demisto.args().get('limit', 100))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if result:
            search_params['result'] = result

        attachment_logs = get_attachment_logs_request(search_params, result_number)
        if limit:
            attachment_logs = attachment_logs[:limit]
        for attachment_log in attachment_logs:
            contents.append({
                'Result': attachment_log.get('result'),
                'Date': attachment_log.get('date'),
                'Sender Address': attachment_log.get('senderAddress'),
                'File Name': attachment_log.get('fileName'),
                'Action': attachment_log.get('actionTriggered'),
                'Route': attachment_log.get('route'),
                'Details': attachment_log.get('details'),
                'Recipient Address': attachment_log.get('recipientAddress'),
                'File Type': attachment_log.get('fileType')
            })
            attachment_logs_context.append({
                'Result': attachment_log.get('result'),
                'Date': attachment_log.get('date'),
                'Sender': attachment_log.get('senderAddress'),
                'FileName': attachment_log.get('fileName'),
                'Action': attachment_log.get('actionTriggered'),
                'Route': attachment_log.get('route'),
                'Details': attachment_log.get('details'),
                'Recipient': attachment_log.get('recipientAddress'),
                'FileType': attachment_log.get('fileType')
            })

        context['Mimecast.AttachmentLog'] = attachment_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast attachment logs: ', contents, headers),
            'EntryContext': context
        }

        return results

    def get_attachment_logs_request(search_params,result_number=None):
         # Setup required variables
        api_endpoint = '/api/ttp/attachment/get-logs'
        pagination = {}
        if result_number:
            pagination = { 'page_size': result_number }
        payload = {
            'meta': {
              'pagination': pagination
            },
            'data': [search_params]
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('attachmentLogs')


    def get_impersonation_logs():
        headers = []
        contents = []
        context = {}
        impersonation_logs_context = []
        search_params = {}
        result_number =  demisto.args().get('resultsNumber', '').encode('utf-8')
        from_date =  demisto.args().get('fromDate', '').encode('utf-8')
        to_date =  demisto.args().get('toDate', '').encode('utf-8')
        tagged_malicious =  demisto.args().get('taggedMalicious', '').encode('utf-8')
        search_field =  demisto.args().get('searchField', '').encode('utf-8')
        query =  demisto.args().get('query', '').encode('utf-8')
        identifiers =  argToList(demisto.args().get('identifiers', '').encode('utf-8'))
        actions =  argToList(demisto.args().get('actions', '').encode('utf-8'))
        limit = int(demisto.args().get('limit', 100))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if tagged_malicious:
            search_params['taggedMalicious'] = tagged_malicious
        if search_field:
            search_params['searchField'] = search_field
        if query:
            search_params['query'] = query
        if identifiers:
            search_params['identifiers'] = identifiers
        if actions:
            search_params['actions'] = actions

        impersonation_logs, result_count = get_impersonation_logs_request(search_params, result_number)
        if limit:
            impersonation_logs = impersonation_logs[:limit]
        for impersonation_log in impersonation_logs:
            contents.append({
                'Result Count': result_count,
                'Hits': impersonation_log.get('hits'),
                'Malicious': impersonation_log.get('taggedMalicious'),
                'Sender IP': impersonation_log.get('senderIpAddress'),
                'Sender Address': impersonation_log.get('senderAddress'),
                'Subject': impersonation_log.get('subject'),
                'Identifiers': impersonation_log.get('identifiers'),
                'Date': impersonation_log.get('eventTime'),
                'Action': impersonation_log.get('action'),
                'Policy': impersonation_log.get('definition'),
                'ID': impersonation_log.get('id'),
                'Recipient Address': impersonation_log.get('recipientAddress'),
                'External': impersonation_log.get('taggedExternal')
            })
            impersonation_logs_context.append({
                'ResultCount': result_count,
                'Hits': impersonation_log.get('hits'),
                'Malicious': impersonation_log.get('taggedMalicious'),
                'SenderIP': impersonation_log.get('senderIpAddress'),
                'SenderAddress': impersonation_log.get('senderAddress'),
                'Subject': impersonation_log.get('subject'),
                'Identifiers': impersonation_log.get('identifiers'),
                'Date': impersonation_log.get('eventTime'),
                'Action': impersonation_log.get('action'),
                'Policy': impersonation_log.get('definition'),
                'ID': impersonation_log.get('id'),
                'RecipientAddress': impersonation_log.get('recipientAddress'),
                'External': impersonation_log.get('taggedExternal')
            })

        context['Mimecast.Impersonation'] = impersonation_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast impersonation logs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def get_impersonation_logs_request(search_params,result_number=None):
         # Setup required variables
        api_endpoint = '/api/ttp/impersonation/get-logs'
        pagination = {}
        if result_number:
            pagination = { 'page_size': result_number }
        payload = {
            'meta': {
              'pagination': pagination
            },
            'data': [search_params]
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0].get('impersonationLogs'), response.get('data')[0].get('resultCount')



    def fetch_incidents():
        last_run = demisto.getLastRun()
        last_fetch = last_run.get('time')

        # handle first time fetch
        if last_fetch is None:
            last_fetch = datetime.datetime.now() - datetime.timedelta(hours=FETCH_DELTA)
            last_fetch_date_time = last_fetch.strftime("%Y-%m-%dT%H:%M:%S") + '+0000'
        else:
            last_fetch = datetime.datetime.strptime(last_fetch, '%Y-%m-%dT%H:%M:%SZ')
            last_fetch_date_time = last_fetch.strftime("%Y-%m-%dT%H:%M:%S") + '+0000'
        current_fetch = last_fetch

        incidents = []
        if FETCH_URL:
            search_params = {
                'from': last_fetch_date_time,
                'scanResult': 'malicious'
            }
            url_logs = get_url_logs_request(search_params)
            for url_log in url_logs:
                incident = url_to_incident(url_log)
                temp_date = datetime.datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')
                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + datetime.timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        if FETCH_ATTACHMENTS:
            search_params = {
                'from': last_fetch_date_time,
                'result': 'malicious'
            }
            attachment_logs = get_attachment_logs_request(search_params)
            for attachment_log in attachment_logs:
                incident = attachment_to_incident(attachment_log)
                temp_date = datetime.datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + datetime.timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        if FETCH_IMPERSONATIONS:
            search_params = {
                'from': last_fetch_date_time,
                'taggedMalicious': True
            }
            impersonation_logs, _ = get_impersonation_logs_request(search_params)
            for impersonation_log in impersonation_logs:
                incident = impersonation_to_incident(impersonation_log)
                temp_date = datetime.datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + datetime.timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        demisto.setLastRun({'time' : last_fetch.isoformat().split('.')[0] + 'Z'})
        demisto.incidents(incidents)


    def url_to_incident(url_log):
        incident = {}
        incident['name'] = 'Mimecast malicious URL: ' + url_log.get('url')
        incident['occurred'] = url_log.get('date').replace('+0000','Z')
        incident['rawJSON'] = json.dumps(url_log)
        return incident

    def attachment_to_incident(attachment_log):
        incident = {}
        incident['name'] = 'Mimecast malicious attachment: ' + attachment_log.get('fileName')
        incident['occurred'] = attachment_log.get('date').replace('+0000','Z')
        incident['rawJSON'] = json.dumps(attachment_log)
        return incident


    def impersonation_to_incident(impersonation_log):
        incident = {}
        incident['name'] = 'Mimecast malicious impersonation: ' + impersonation_log.get('subject')
        incident['occurred'] = impersonation_log.get('eventTime').replace('+0000','Z')
        incident['rawJSON'] = json.dumps(impersonation_log)
        return incident


    def discover():
        headers = []
        context = {}
        context_obj = {}
        contents = []

        response = discover_request()

        contents.append({
            'Authentication Types': response.get('authenticate'),
            'Email Address': response.get('emailAddress'),
            'Email Token': response.get('emailToken')
        })

        context_obj = {
            'AuthenticationTypes': response.get('authenticate'),
            'EmailAddress': response.get('emailAddress'),
            'EmailToken': response.get('emailToken')
        }

        context['Mimecast.Authentication(val.EmailAddress && val.EmailAddress === obj.EmailAddress)'] = context_obj

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Authentication Information', contents, headers),
            'EntryContext': context
        }

        return results


    def discover_request():
        if not EMAIL_ADDRESS:
            return_error('In order to discover account\'s auth types, account\'s email is required.')
        email = EMAIL_ADDRESS.encode('utf-8')
         # Setup required variables
        api_endpoint = '/api/login/discover-authentication'
        payload = {
            'data': [{
                'emailAddress': email
            }]
        }
        response = http_request('POST', api_endpoint, str(payload), {}, user_auth=False)
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def refresh_token():
        headers = []
        context = {}
        context_obj = {}
        contents = []

        contents = refresh_token_request()

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Token has been refreshed succesfully and is valid for the next 3 days'
        }

        return results


    def refresh_token_request():
        if not EMAIL_ADDRESS:
            return_error('In order to refresh a token validty duration, account\'s email is required.')
        if not ACCESS_KEY:
            return_error('In order to refresh a token validty duration, account\'s access key is required.')
        email = EMAIL_ADDRESS.encode('utf-8')
        access_key = ACCESS_KEY.encode('utf-8')
        # Setup required variables
        api_endpoint = '/api/login/login'
        payload = {
            'data': [{
                'userName': email,
                'accessKey': access_key
            }]
        }
        response = http_request('POST', api_endpoint, str(payload), {}, user_auth=False)
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def login():
        headers = ['Access Key','Secret Key']
        contents = []

        response = login_request()

        contents.append({
            'Access Key': response.get('accessKey'),
            'Secret Key': response.get('secretKey')
        })

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast authentication details \n Tokens are valid for 3 days', contents, headers)
        }

        return results


    def login_request():
        if not EMAIL_ADDRESS:
            return_error('In order to refresh a token validty duration, account\'s email is required.')
        email = EMAIL_ADDRESS.encode('utf-8')
         # Setup required variables
        api_endpoint = '/api/login/login'
        payload = {
            'data': [{
                'userName': email
            }]
        }
        response = http_request('POST', api_endpoint, str(payload), {}, user_auth=False)
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def get_message():
        context = {}
        contents = {}
        metadata_context = {}
        results = []
        message_id = demisto.args().get('messageID').encode('utf-8')
        message_context = demisto.args().get('context').encode('utf-8')
        message_type = demisto.args().get('type').encode('utf-8')
        message_part = demisto.args().get('part')

        if message_part == 'all' or message_part == 'metadata':
            contents, metadata_context = get_message_metadata(message_id)

            context['Mimecast.Message(val.ID && val.ID === obj.ID)'] = metadata_context

            results.append({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': contents,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('Mimecast message details', contents, removeNull=True),
                'EntryContext': context
            })

        if message_part == 'all' or message_part == 'message':
            email_file = get_message_body_content_request(message_id, message_context, message_type)
            results.append(fileResult(message_id, email_file))

        return results


    def get_message_body_content_request(message_id, message_context, message_type):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/archive/get-message-part'

        data = [{
            'id': message_id,
            'type': message_type,
            'context': message_context
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload), is_file=True)
        if isinstance(response, dict) and response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.content


    def get_message_metadata(message_id):
        contents = {}
        context = {}
        message = get_message_metadata_request(message_id)

        receivers = message.get('to', [])
        to_context = []
        to_contents = []
        for receiver in receivers:
            to_context.append({
                'EmailAddress': receiver.get('emailAddress')
            })
            to_contents.append(
                receiver.get('emailAddress')
            )

        copies = message.get('cc', [])
        cc_context = []
        cc_contents = []
        for copy in copies:
            cc_context.append({
                'EmailAddress': copy.get('emailAddress')
            })
            cc_contents.append(
                copy.get('emailAddress')
            )

        response_headers = message.get('headers', [])
        headers_contents = []
        headers_context = []
        for header in response_headers:
            values = header.get('values')
            values = [value.encode('utf-8') for value in values]
            headers_context.append({
                'Name': header.get('name'),
                'Values': values
            })
            headers_contents.append(
                'Name: {}, Values: {}'.format(str(header.get('name')), str(values))
            )

        attachments = message.get('attachments', [])
        attachments_context = []
        attachments_contents = []
        for attachment in attachments:
            attachments_context.append({
                'FileName': attachment.get('filename'),
                'SHA256': attachment.get('sha256'),
                'ID': attachment.get('id'),
                'Size': attachment.get('size')
            })
            attachments_contents.append(
                'FileName: {}, SHA256: {}, ID: {}, Size: {}'.format(str(attachment.get('filename')),str(attachment.get('sha256')),str(attachment.get('id')),str(attachment.get('size')))
            )

        contents = {
            'Subject': message.get('subject'),
            'Header Date': message.get('headerDate'),
            'Size': message.get('size'),
            'From': message.get('from', {}).get('emailAddress'),
            'To': to_contents,
            'Reply To': message.get('replyTo', {}).get('emailAddress'),
            'CC': cc_contents,
            'Envelope From': message.get('envelopeFrom', {}).get('emailAddress'),
            'Headers': headers_contents,
            'Attachments': attachments_contents,
            'Processed': message.get('processed'),
            'Has Html Body': message.get('hasHtmlBody'),
            'ID': message.get('id')
        }

        context = {
            'Subject': message.get('subject'),
            'HeaderDate': message.get('headerDate'),
            'Size': message.get('size'),
            'From': message.get('from', {}).get('emailAddress'),
            'To': to_context,
            'ReplyTo': message.get('replyTo', {}).get('emailAddress'),
            'CC': cc_context,
            'EnvelopeFrom': message.get('envelopeFrom', {}).get('emailAddress'),
            'Headers': headers_context,
            'Attachments': attachments_context,
            'Processed': message.get('processed'),
            'HasHtmlBody': message.get('hasHtmlBody'),
            'ID': message.get('id')
        }

        return contents, context


    def get_message_metadata_request(message_id):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/archive/get-message-detail'
        data = [{
            'id': message_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload))
        if response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def download_attachment():
        attachment_id = demisto.args().get('attachmentID').encode('utf-8')
        attachment_file = download_attachment_request(attachment_id)
        return fileResult(attachment_id, attachment_file)


    def download_attachment_request(attachment_id):
        # Setup required variables
        request_params = {}
        api_endpoint = '/api/archive/get-file'

        data = [{
            'id': attachment_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, str(payload), is_file=True)
        if isinstance(response, dict) and response.get('fail'):
            return_error(json.dumps(response.get('fail')[0].get('errors')))
        return response.content


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('command is %s' % (demisto.command(), ))

    # Check if token needs to be refresh, if it does and relevant params are set, refresh.
    auto_refresh_token()

    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() == 'mimecast-query':
            demisto.results(query())
        elif demisto.command() == 'mimecast-list-blocked-sender-policies':
            demisto.results(get_policy())
        elif demisto.command() == 'mimecast-get-policy':
            demisto.results(get_policy())
        elif demisto.command() == 'mimecast-create-policy':
            demisto.results(create_policy())
        elif demisto.command() == 'mimecast-delete-policy':
            demisto.results(delete_policy())
        elif demisto.command() == 'mimecast-manage-sender':
            demisto.results(manage_sender())
        elif demisto.command() == 'mimecast-list-managed-url':
            demisto.results(list_managed_url())
        elif demisto.command() == 'mimecast-create-managed-url':
            demisto.results(create_managed_url())
        elif demisto.command() == 'mimecast-list-messages':
            demisto.results(list_messages())
        elif demisto.command() == 'mimecast-get-attachment-logs':
            demisto.results(get_attachment_logs())
        elif demisto.command() == 'mimecast-get-url-logs':
            demisto.results(get_url_logs())
        elif demisto.command() == 'mimecast-get-impersonation-logs':
            demisto.results(get_impersonation_logs())
        elif demisto.command() == 'mimecast-url-decode':
            demisto.results(url_decode())
        elif demisto.command() == 'mimecast-discover':
            demisto.results(discover())
        elif demisto.command() == 'mimecast-login':
            demisto.results(login())
        elif demisto.command() == 'mimecast-refresh-token':
            demisto.results(refresh_token())
        elif demisto.command() == 'mimecast-get-message':
            demisto.results(get_message())
        elif demisto.command() == 'mimecast-download-attachments':
            demisto.results(download_attachment())


    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
  type: python
  commands:
  - name: mimecast-query
    arguments:
    - name: queryXml
      default: true
      description: The query string xml for the search using Mimecast Unified Search
        Experience (MUSE) - read more on https://community.mimecast.com/docs/DOC-2262,
        using this will override other query arguments
    - name: text
      description: Search for this text in messages
    - name: dryRun
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Will not execute the query, but just return the query string built
      defaultValue: "false"
    - name: date
      auto: PREDEFINED
      predefined:
      - today
      - yesterday
      - last_week
      - last_month
      - last_year
      description: Search in specific dates only (default is all mails fomr)
    - name: dateFrom
      description: Search emails from date, format YYYY-MM-DDTHH:MM:SZ (e.g. 2015-09-21T23:00:00Z)
    - name: dateTo
      description: Search emails to date, format YYYY-MM-DDTHH:MM:SZ (e.g. 2015-09-21T23:00:00Z)
    - name: sentTo
      description: Filter on messages to a specific address
    - name: sentFrom
      description: Filter on messages from a specific address
    - name: subject
      description: Search email by subject, will override the text argument
    - name: attachmentType
      auto: PREDEFINED
      predefined:
      - optional
      - any
      - documents
      - spreadsheets
      - presentations
      - text
      - images
      - media
      - zips
      - none
      description: 'These are the attachment types available: optional - messages
        with and without attachments any - messages with any attachment documents
        - messages with doc, dot, docx, docm, dotx, dotm, pdf, rtf, html attachments
        spreadsheets - messages with xls, xlt, xlsx, xlsm, xltx, xltm, xlsb, xlam,
        csv attachments presentations - messages with ppt, pptx, pptm, potx, potm,
        ppam, ppsx, ppsm, sldx, sldm, thms, pps attachments text - messages with txt,
        text, html, log attachments images - messages with jpg, jpeg, png, bmp, gif,
        psd, tif, tiff attachments media - messages with mp3, mp4, m4a, mpg, mpeg,
        avi, wav, aac, wma, mov attachments zips - messages with zip, rar, cab, gz,
        gzip, 7z attachments none - No attachments are to be present in the results'
    - name: attachmentText
      description: Search for text in attachments
    - name: body
      description: Search email by text in body, will override the text and subject
        arguments
    - name: pageSize
      description: Sets the number of results to return per page (default 25)
    - name: startRow
      description: Sets the result to start returning results (default 0)
    - name: active
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Defines if the search should query recently received messages that
        are not fully processed yet (default false). You can search by mailbox and
        date time across active messages
      defaultValue: "false"
    outputs:
    - contextPath: Mimecast.Message.ID
      description: Message ID
      type: string
    - contextPath: Mimecast.Message.Subject
      description: Message subject
      type: string
    - contextPath: Mimecast.Message.Sender
      description: Message sender address
      type: string
    - contextPath: Mimecast.Message.Recipient
      description: Message recipient address
      type: string
    - contextPath: Mimecast.Message.RecievedDate
      description: Message received date
      type: date
    - contextPath: Mimecast.Message.Size
      description: The size of the message in bytes
      type: number
    - contextPath: Mimecast.Message.AttachmentCount
      description: Message attachments count
      type: number
    - contextPath: Mimecast.Message.Status
      description: Message status
      type: string
    description: Query mimecast emails
  - name: mimecast-list-blocked-sender-policies
    arguments: []
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is Bidirectional or not
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to Receiver type address
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to Receiver type domain
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to Receiver type group
      type: string
    - contextPath: Mimecast.Policy.FromDate
      description: Policy validation start date
      type: date
    - contextPath: Mimecast.Policy.ToDate
      description: Policy expiration date
      type: date
    - contextPath: Mimecast.Policy.Sender.Type
      description: Block emails to Sender type
      type: string
    - contextPath: Mimecast.Policy.Receiver.Type
      description: Block emails to Receiver type
      type: string
    description: List all existing mimecast blocked sender policies
  - name: mimecast-get-policy
    arguments:
    - name: policyID
      required: true
      description: Filter by policy ID
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is Bidirectional or not
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to Receiver type address
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to Receiver type domain
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to Receiver type group
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: Policy validation start date
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: Policy expiration date
      type: date
    description: Get a blocked sender policy by ID
  - name: mimecast-create-policy
    arguments:
    - name: description
      required: true
      description: Policy description
    - name: fromPart
      auto: PREDEFINED
      predefined:
      - envelope_from
      - header_from
      - both
      description: Addresses based on
      defaultValue: envelope_from
    - name: fromType
      required: true
      auto: PREDEFINED
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - individual_email_address
      description: Blocked Sender type
    - name: fromValue
      description: 'Required if fromType is one of email domain, profile group, individual
        email address. Expected values: If fromType is email_domain, a domain name
        without the @ symbol. If fromType is profile_group, the ID of the profile
        group. If fromType is individual_email_address, an email address.'
    - name: toType
      required: true
      auto: PREDEFINED
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - address_attribute_value
      - individual_email_address
      - free_mail_domains
      - header_display_name
      description: Receiver type
    - name: toValue
      description: 'Required if fromType is one of email domain, profile group, individual
        email address. Expected values: If toType is email_domain, a domain name without
        the @ symbol. If toType is profile_group, the ID of the profile group. If
        toType is individual_email_address, an email address.'
    - name: option
      required: true
      auto: PREDEFINED
      predefined:
      - no_action
      - block_sender
      description: 'The block option, must be one of: no_action, block_sender.'
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is Bidirectional or not
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to Receiver type address
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to Receiver type domain
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to Receiver type group
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: Policy validation start date
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: Policy expiration date
      type: date
    description: Create a Blocked Sender Policy
  - name: mimecast-delete-policy
    arguments:
    - name: policyID
      required: true
      description: Policy ID
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID
      type: string
    description: Delete a Blocked Sender Policy
  - name: mimecast-manage-sender
    arguments:
    - name: sender
      required: true
      description: The email address of sender to permit or block
    - name: recipient
      required: true
      description: The email address of recipient to permit or block
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - permit
      - block
      description: Choose to either "permit" (to bypass spam checks) or "block" (to
        reject the email)
    outputs:
    - contextPath: Mimecast.Managed.Sender
      description: The email address of the sender
      type: string
    - contextPath: Mimecast.Managed.Recipient
      description: The email address of the recipient
      type: string
    - contextPath: Mimecast.Managed.Action
      description: Chosen action
      type: string
    - contextPath: Mimecast.Managed.ID
      description: The Mimecast secure ID of the managed sender object.
      type: string
    description: Permit or block a specific sender
  - name: mimecast-list-managed-url
    arguments:
    - name: url
      description: Filter results by specific URL
    outputs:
    - contextPath: Mimecast.URL.Domain
      description: The managed domain
      type: string
    - contextPath: Mimecast.URL.Disablelogclick
      description: If logging of user clicks on the URL is disabled
      type: boolean
    - contextPath: Mimecast.URL.Action
      description: Either block of permit
      type: string
    - contextPath: Mimecast.URL.Path
      description: The path of the managed URL
      type: string
    - contextPath: Mimecast.URL.matchType
      description: Either explicit - applies to the full URL or domain - applies to
        all URL values in the domain
      type: string
    - contextPath: Mimecast.URL.ID
      description: The Mimecast secure ID of the managed URL
      type: string
    - contextPath: Mimecast.URL.disableRewrite
      description: If rewriting of this URL in emails is disabled
      type: boolean
    description: Get a list of all managed URLs
  - name: mimecast-create-managed-url
    arguments:
    - name: url
      required: true
      description: The URL to block or permit. Do not include a fragment (#).
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - block
      - permit
      description: Set to "block" to blacklist the URL, "permit" to whitelist it
    - name: matchType
      auto: PREDEFINED
      predefined:
      - explicit
      - domain
      description: Set to "explicit" to block or permit only instances of the full
        URL. Set to "domain" to block or permit any URL with the same domain
      defaultValue: explicit
    - name: disableRewrite
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Disable rewriting of this URL in emails. Applies only if action
        = "permit". Default false
      defaultValue: "false"
    - name: comment
      description: Add a comment about the managed URL
    - name: disableUserAwareness
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Disable User Awareness challenges for this URL. Applies only if
        action = "permit". Default false
      defaultValue: "false"
    - name: disableLogClick
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Disable logging of user clicks on the URL. Default is false
      defaultValue: "false"
    outputs:
    - contextPath: Mimecast.URL.Domain
      description: The managed domain
      type: string
    - contextPath: Mimecast.URL.Action
      description: Either block of permit
      type: string
    - contextPath: Mimecast.URL.disableLogClick
      description: If logging of user clicks on the URL is disabled
      type: string
    - contextPath: Mimecast.URL.matchType
      description: Either explicit - applies to the full URL or domain - applies to
        all URL values in the domain
      type: string
    - contextPath: Mimecast.URL.ID
      description: The Mimecast secure ID of the managed URL
      type: string
    - contextPath: Mimecast.URL.disableRewrite
      description: If rewriting of this URL in emails is disabled
      type: boolean
    description: Create a managed URL on Mimecast
  - name: mimecast-list-messages
    arguments:
    - name: mailbox
      description: The email address to return the message list for
    - name: startTime
      description: The start date of messages to return, in the following format,
        2015-11-16T14:49:18+0000. Default is the last calendar month
    - name: endTime
      description: The end date of messages to return, in the following format, 2015-11-16T14:49:18+0000.
        Default is the end of the current day
    - name: view
      auto: PREDEFINED
      predefined:
      - INBOX
      - SENT
      description: 'The message list type, must be one of: inbox or sent, default
        is inbox'
      defaultValue: INBOX
    - name: subject
      description: Filter by message subject
    outputs:
    - contextPath: Mimecast.Message.Subject
      description: Message Subject
      type: string
    - contextPath: Mimecast.Message.ID
      description: Message ID
      type: string
    - contextPath: Mimecast.Message.Size
      description: The size of the message in bytes
      type: number
    - contextPath: Mimecast.Message.RecievedDate
      description: The date the message was received
      type: date
    - contextPath: Mimecast.Message.From
      description: The mail Sender
      type: string
    - contextPath: Mimecast.Message.AttachmentCount
      description: The number of attachments on the message
      type: string
    description: Get a list of messages for a given user
  - name: mimecast-get-attachment-logs
    arguments:
    - name: resultsNumber
      description: The number of results to request. Default is all
    - name: fromDate
      description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day
    - name: toDate
      description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request
    - name: resultType
      auto: PREDEFINED
      predefined:
      - safe
      - malicious
      - timeout
      - error
      - unsafe
      - all
      description: Filters logs by scan result, default is malicious
      defaultValue: malicious
    - name: limit
      description: Limit number of returned results.
      defaultValue: "100"
    outputs:
    - contextPath: Mimecast.AttachmentLog.Result
      description: 'The result of the attachment analysis: clean, malicious, unknown,
        or timeout'
      type: string
    - contextPath: Mimecast.AttachmentLog.Date
      description: The time at which the attachment was released from the sandbox
      type: date
    - contextPath: Mimecast.AttachmentLog.Sender
      description: The sender of the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.FileName
      description: The file name of the original attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.Action
      description: The action triggered for the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.Recipient
      description: The address of the user that received the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.FileType
      description: The file type of the attachment
      type: string
    - contextPath: Mimecast.AttachmentLog.Route
      description: 'The route of the original email containing the attachment, either:
        inbound, outbound, internal, or external'
      type: string
    description: Returns Attachment Protect logs for a Mimecast customer account
  - name: mimecast-get-url-logs
    arguments:
    - name: resultsNumber
      description: The number of results to request. Default is all
    - name: fromDate
      description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day
    - name: toDate
      description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request
    - name: resultType
      auto: PREDEFINED
      predefined:
      - clean
      - malicious
      - all
      description: Filters logs by scan result, default is all
      defaultValue: malicious
    - name: limit
      description: Limit number of returned results.
      defaultValue: "100"
    outputs:
    - contextPath: Mimecast.UrlLog.Category
      description: The category of the URL clicked
      type: string
    - contextPath: Mimecast.UrlLog.UserAddress
      description: The email address of the user who clicked the link
      type: string
    - contextPath: Mimecast.UrlLog.URL
      description: The url clicked
      type: string
    - contextPath: Mimecast.UrlLog.Awareness
      description: The action taken by the user if user awareness was applied
      type: string
    - contextPath: Mimecast.UrlLog.AdminOverride
      description: The action defined by the administrator for the URL
      type: string
    - contextPath: Mimecast.UrlLog.Date
      description: The date that the URL was clicked
      type: date
    - contextPath: Mimecast.UrlLog.Result
      description: The result of the URL scan
      type: string
    - contextPath: Mimecast.UrlLog.Action
      description: The action that was taken for the click
      type: string
    - contextPath: Mimecast.UrlLog.Route
      description: 'The route of the original email containing the attachment, either:
        inbound, outbound, internal, or external'
      type: string
    - contextPath: Mimecast.UrlLog. userOverride
      description: The action requested by the user.
      type: string
    description: Returns URL protect logs for a Mimecast customer account
  - name: mimecast-get-impersonation-logs
    arguments:
    - name: resultsNumber
      description: The number of results to request. Default is all
    - name: taggedMalicious
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: ' Filters for messages tagged malicious (true) or not tagged malicious
        (false). Omit for no tag filtering. default is true'
      defaultValue: "true"
    - name: searchField
      auto: PREDEFINED
      predefined:
      - senderAddress
      - recipientAddress
      - subject
      - policy
      - all
      description: The field to search,Defaults to all (meaning all of the preceding
        fields)
    - name: query
      description: Required if searchField exists. A character string to search for
        in the logs.
    - name: identifiers
      auto: PREDEFINED
      predefined:
      - newly_observed_domain
      - internal_user_name
      - repy_address_mismatch
      - targeted_threat_dictionary
      description: Filters logs by identifiers, can include any of newly_observed_domain,
        internal_user_name, repy_address_mismatch, and targeted_threat_dictionary.
        you can choose more then one identifier separated by comma.
      isArray: true
    - name: fromDate
      description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day
    - name: toDate
      description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request
    - name: actions
      auto: PREDEFINED
      predefined:
      - delete
      - hold
      - bounce
      - smart_folder
      - disable_smart_folder
      - content_expire
      - meta_expire
      - stationery
      - gcc
      - secure_delivery
      - derivery_route
      - document_policy
      - disable_document_policy
      - attach_set_policy
      - remove_email
      description: Filters logs by action, you can choose more then one action separated
        by comma.
      isArray: true
    - name: limit
      description: Limit number of returned results.
      defaultValue: "100"
    outputs:
    - contextPath: Mimecast.Impersonation.ResultCount
      description: The total number of IMPERSONATION log lines found for the request
      type: number
    - contextPath: Mimecast.Impersonation.Hits
      description: The number of identifiers that the message triggered
      type: number
    - contextPath: Mimecast.Impersonation.Malicious
      description: Whether the message was tagged as malicious
      type: boolean
    - contextPath: Mimecast.Impersonation.SenderIP
      description: The source IP address of the message
      type: string
    - contextPath: Mimecast.Impersonation.SenderAddress
      description: The email address of the sender of the message
      type: string
    - contextPath: Mimecast.Impersonation.Subject
      description: The subject of the email
      type: string
    - contextPath: Mimecast.Impersonation.Identifiers
      description: 'The properties of the message that triggered the action: similar_internal_domain,
        newly_observed_domain, internal_user_name, reply_address_mismatch, and/or
        targeted_threat_dictionary'
      type: string
    - contextPath: Mimecast.Impersonation.Date
      description: The time at which the log was recorded
      type: date
    - contextPath: Mimecast.Impersonation.Action
      description: ' The action triggered by the email'
      type: string
    - contextPath: Mimecast.Impersonation.Policy
      description: The name of the policy definition that triggered the log
      type: string
    - contextPath: Mimecast.Impersonation.ID
      description: Impersonation Log ID
      type: string
    - contextPath: Mimecast.Impersonation.RecipientAddress
      description: The email address of the recipient of the email
      type: string
    - contextPath: Mimecast.Impersonation.External
      description: Whether the message was tagged as coming from an external address
      type: boolean
    description: Returns Impersonation Protect logs for a Mimecast customer account
  - name: mimecast-url-decode
    arguments:
    - name: url
      required: true
      description: URL to decode
    outputs:
    - contextPath: URL.Data
      description: The encoded url to parse
      type: string
    - contextPath: URL.Mimecast.DecodedURL
      description: Parsed url
      type: string
    description: Decodes a given url from mimecast
  - name: mimecast-discover
    arguments: []
    outputs:
    - contextPath: Mimecast.Authentication.AuthenticationTypes
      description: List of authentication types available to the user
      type: string
    - contextPath: Mimecast.Authentication.EmailAddress
      description: Email address of the request sender
      type: string
    - contextPath: Mimecast.Authentication.EmailToken
      description: Email token of the request sender
      type: string
    description: discover authentication types that are supported for your account
      and which base URL to use for the requesting user.
  - name: mimecast-refresh-token
    arguments: []
    description: Refresh access key validity
  - name: mimecast-login
    arguments: []
    description: Login to generate Access Key and  Secret Key
  - name: mimecast-get-message
    arguments:
    - name: messageID
      required: true
      description: Message ID
    - name: context
      required: true
      auto: PREDEFINED
      predefined:
      - DELIVERED
      - RECEIVED
      description: 'Defines which copy of the message part to return, must be one
        of: "delievered" the copy that has been processed by the Mimecast MTA with
        policies such as URL rewriting applied, OR "received" - the copy of the message
        that Mimecast originally received. (Only relevant for part argument = message
        or all)'
    - name: type
      auto: PREDEFINED
      predefined:
      - HTML
      - PLAIN
      - RFC822
      - TRANSMISSION_MESSAGE_BODY
      description: The message type to return. (Only relevant for part argument =
        message or all)
      defaultValue: PLAIN
    - name: part
      auto: PREDEFINED
      predefined:
      - message
      - metadata
      - all
      description: Define what message part to return - download message, get metadata
        or both.
      defaultValue: all
    outputs:
    - contextPath: Mimecast.Message.ID
      description: Message ID
      type: string
    - contextPath: Mimecast.Message.Subject
      description: The message subject.
      type: string
    - contextPath: Mimecast.Message.HeaderDate
      description: The date of the message as defined in the message headers.
      type: date
    - contextPath: Mimecast.Message.Size
      description: The message size.
      type: number
    - contextPath: Mimecast.Message.From
      description: Sender of the message as defined in the message header.
      type: string
    - contextPath: Mimecast.Message.To.EmailAddress
      description: Recipient of the message.
      type: string
    - contextPath: Mimecast.Message.ReplyTo
      description: The value of the Reply-To header.
      type: string
    - contextPath: Mimecast.Message.CC.EmailAddress
      description: Each CC recipient of the message.
      type: string
    - contextPath: Mimecast.Message.EnvelopeFrom
      description: Sender of the message as defined in the message envelope.
      type: string
    - contextPath: Mimecast.Message.Headers.Name
      description: Header's name.
      type: string
    - contextPath: Mimecast.Message.Headers.Values
      description: Header's value.
      type: string
    - contextPath: Mimecast.Message.Attachments.FileName
      description: Message attachment's file name.
      type: string
    - contextPath: Mimecast.Message.Attachments.SHA256
      description: Message attachment's SHA256.
      type: string
    - contextPath: Mimecast.Message.Attachments.ID
      description: Message attachment's ID.
      type: string
    - contextPath: Mimecast.Message.Attachments.Size
      description: Message attachment's file size.
      type: number
    - contextPath: Mimecast.Message.Processed
      description: The date the message was processed by Mimecast in ISO 8601 format.
      type: date
    - contextPath: Mimecast.Message.HasHtmlBody
      description: If the message has an HTML body part.
      type: boolean
    - contextPath: File.Size
      description: File Size
      type: number
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    - contextPath: File.Name
      description: The sample name
      type: string
    - contextPath: File.SSDeep
      description: SSDeep hash of the file
      type: string
    - contextPath: File.EntryID
      description: War-Room Entry ID of the file
      type: string
    - contextPath: File.Info
      description: Basic information of the file
      type: string
    - contextPath: File.Type
      description: File type e.g. "PE"
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    description: Get the contents or metadata of a given message
  - name: mimecast-download-attachments
    arguments:
    - name: attachmentID
      required: true
      description: The Mimecast ID of the message attachment to return. (Can be retrieved
        from mimecast-get-message)
    outputs:
    - contextPath: File.Size
      description: File Size
      type: number
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    - contextPath: File.Name
      description: The sample name
      type: string
    - contextPath: File.SSDeep
      description: SSDeep hash of the file
      type: string
    - contextPath: File.EntryID
      description: War-Room Entry ID of the file
      type: string
    - contextPath: File.Info
      description: Basic information of the file
      type: string
    - contextPath: File.Type
      description: File type e.g. "PE"
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    description: Download attachments from a specified message
  isfetch: true
  runonce: false
tests:
 - Mimecast test
