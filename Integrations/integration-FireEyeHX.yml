commonfields:
  id: FireEye HX
  version: -1
name: FireEye HX
display: FireEye HX
category: Endpoint
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHMAAAAhCAYAAADqBZQaAAAGqUlEQVR4Ae3ZA3AcfR/A8V/Y6GI711xSK8ldH9u2bdu2bdsoHte2bdt2+3u/M+9mZmdnb7N1b2Y782mM/X/zx+3Jnvg3qbIuFSGIZ//ZU98oGm+hFBLJvJjAJXgCEvm8mI3wN1pDIpkXE/gN70IinxezA7pCIpsXMwbj8AEksnkx67ACbXEd2kIikxfzRbyOIqzEoZDI48WMRQcU4Wgo7oJEHi9mBd6B4GIo5sEPiSBezOmBYJpxBygOT+I2jMdwZEMighcTWFgdqptbFSqfEwhWQHhfayzHVFRCIoAX00EQS7EA7SEOopGARi4kIAqCHJQhEbK3iWRHQQ5Mu/aFUUhDAYpFsniZ6YNYGTN0qaENJIzmGI1xmOhgKgYjH4IOUJy8D0KehtEYjGENGI+jD9SYCTgSL6EH5mA5VmAlFqELYa/Kjc2LHu6vLZlTFToP5iV3HkogNtphGxSrHazHHBRB0A2KM/dBzMuhhq3Y5kBxJmRviorNi0I0RPjPEV8QwNMYAw1jG2ZgPKYxI/883VcSmBEIPjW1Mvg8xJg5il8gNtpCMQuNkYMCB9EQtMHxyNkHMS+GYiiKUYbyMPxI2gchT8ZtaO4UsQRvYK0l2jKoyQAcyoyMhyAGh4mknntfduPERdXtJ0ysrLsUwoC8CcWJDjFnIg3ikg9ZiIMYElCKPAjScApuRR3EJAVBXI6bcC78iHaI2QfiUiZKkQ1xkItypEJM8nAULsWFqEWyETMRN+AZHGEXMQ3PWSLOxvsI4TGoYQJyIVY1CUVRkFmB4F2T/7/PRSMPW/BpAzMzA+JSR5s983jswJ9ogmlQw2cQw6WYAbXYjh+QGyZmP4hLJ2Iz5qAMYqMFlhpaQpCB97EOajENZxlB89EaPnPEGFyO6VCswdc4B6kQw+dQw/WQeguqQjHEu35eVegQCITHoOcZA3QwBF0xFtFhYk6HD+LSP1CcCjGcBMUkTMZqdEBHPATBPVBswze4CufiHoyFYjDXkwGBOWZfiEvR6AvFExAb70DRwRSyHxRz8Cyuwg34GtuhuNp6AGqEELpAsRQvohRi42sodqA9pB4X/wCehdSbyEywHFCewSIk2cTcji0YhH7ob2MUHmsg5glQQ18UQkzaYBMUV0IsktENyqryHAQiklUfcy0GY2gYI9EVORBcDcVsm+W2GEuhOAGC96EYhQKIxSVQLEaxOeZlWGX6YBOIgwehhhMtMXvhNIjhVii2oBUE92EOEmxiboW68IXLmKtQCbF4ymbJtToIihmzq4KpEJHMi12eZhWLTCFSMA6KayAmt0DRDYIsLMZ2BCFh/ATFneaYgoPQDYou8EHCqMZKKL6G1GNJ/YqZuM6YjQOghvcghtfQx2HPnIs2qEDARjXyXcYcBrHRAYqx6IJeFj3RHVugLLEhmGfmUJSgHBU2/ChFDMRwMxT9EA1BIkZDcR4EIezAenRAR3Sy+BljoPgZpphANO7BFgxDISSMp6HYgbMhkFH+2pzF1e07QQmrRF3DYLxvWVKH4KE9eJp1ijkYYuM/KOZgMqbZmIrRmEDIgywx+0B2Ui4WQnESBBdAMRkpEBwDxSbMxDwb8zEDs/GFNaZZBf7BCpwHCeMlKLbgYZagZMgTOdWxb+Q39Xcta1MzLRAsMN12E1yMQUjeg6dZp5hDIDY+hOJhCBrZiIYgnpAxlpj9ILvgOSg6QfA3FLdDDFXYjEXIRxySLRIQhRgkOMQEcBGGogNqITZOQAcsxwgu9mOC3iviK4GYMSgX4j80huznmOe5eJruQvTEsxCY98zekF1QhmVYhfOwHnORDTHEYTAUT0Fs+PA6fkVNwzGBRNyOwfgWZyAnzDdvhiqRjFQIZAZ/0QxCDV7GK8iE7OGYf+9CzDh0hWIcjoEPCcjGLdgA5RpOhsD80GQizsTZOCeMC9ECYvERFKugeB1icTbU8AwKEIt4BPAbFH3sZ6azeByLt9EZn+ImHI8qJELMuCfbgj3zTgbkbjSHNKAGivnIgrjU1ebe7GlQjICEkY3/oIaVmI1NUCzHOZabBldBd8IbEIsabDYFDUBsXI2NUGzCZMzCdii6IHd3nzVJQluci3twKdqJZPkgkJmBYBwXX450iEv5eAA3IAHi0rl4FJUQgx8P41KIg3icjY8wEGPxLx6CH2KJ2QrP4FE81oBncQzERkco3oM4aIan0B3TMAk/4WIkQKwxPftWAeZBcTDEpSiDAPBi7nfvm0+0O8+Lub/dgCEYBcVa1HoxI9NtWI7ZGIzTIHva/wAx/Zd/Mj383wAAAABJRU5ErkJggg==
description: FireEye Endpoint Security is an integrated solution that detects what others miss and protects endpoint against known and unknown threats. The HX Demisto integration provides access to information about endpoints, acquisitions, alerts, indicators, and containment. Customers can extract critical data and effectively operate security operations automated playbook
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Version
  name: version
  defaultvalue: v3
  type: 0
  required: true
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |-
    """

    IMPORTS

    """
    import requests
    import base64
    import time
    import json
    import os
    import re
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    """

    HANDLE PROXY

    """

    def set_proxies():
        if not demisto.params().get('proxy', False):
            del os.environ['HTTP_PROXY']
            del os.environ['HTTPS_PROXY']
            del os.environ['http_proxy']
            del os.environ['https_proxy']

    """

    GLOBAL VARS

    """
    SERVER_URL = demisto.params()['server']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    USE_SSL = not demisto.params()['insecure']
    VERSION = demisto.params()['version']
    GET_HEADERS = {
        'Accept': 'application/json'
    }
    POST_HEADERS = {
        'Accept': 'application/json',
        'Content-type': 'application/json'
    }
    PATCH_HEADERS = {
        'Content-Type': 'text/plain'
    }
    BASE_PATH = '{}/hx/api/{}'.format(SERVER_URL, VERSION)
    INDICATOR_MAIN_ATTRIBUTES = [
        'OS',
        'Name',
        'Created By',
        'Active Since',
        'Category',
        'Signature',
        'Active Condition',
        'Hosts With Alerts',
        'Source Alerts'
    ]
    ALERT_MAIN_ATTRIBUTES = [
        'Alert ID',
        'Reported',
        'Event Type',
        'Agent ID'
    ]
    HOST_MAIN_ATTRIBUTES = [
        'Host Name',
        'Host IP',
        'Agent ID',
        'Agent Version',
        'OS',
        'Last Poll',
        'Containment State',
        'Domain',
        'Last Alert'
    ]
    HOST_SET_MAIN_ATTRIBUTES = [
        'Name',
        'ID',
        'Type'
    ]
    #scripts for data acquisitions
    STANDART_INVESTIGATIVE_DETAILS_OSX = {
        "commands": [
            {
                "name": "sysinfo"
            },
            {
                "name": "disks"
            },
            {
                "name": "volumes"
            },
            {
                "name": "useraccounts"
            },
            {
                "name": "groups"
            },
            {
                "name": "files-api",
                "parameters": [
                    {
                        "name": "Path",
                        "value": "/"
                    },
                    {
                        "name": "Regex",
                        "value": "^(?:Applications|Library|System|User|bin|cores|opt|private|sbin|usr)+"
                    },
                    {
                        "name": "Include Remote Locations",
                        "value": False
                    },
                    {
                        "name": "Depth",
                        "value": -1
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": False
                    },
                    {
                        "name": "AND Operator",
                        "value": False
                    },
                    {
                        "name": "Include Files",
                        "value": True
                    },
                    {
                        "name": "Include Directories",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "persistence",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": False
                    }
                ]
            },
            {
                "name": "tasks",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "processes-api"
            },
            {
                "name": "urlhistory",
                "parameters": [
                    {
                        "name": "TargetBrowser",
                        "value": "Chrome"
                    },
                    {
                        "name": "TargetBrowser",
                        "value": "Firefox"
                    },
                    {
                        "name": "TargetBrowser",
                        "value": "Safari"
                    }
                ]
            },
            {
                "name": "quarantine-events"
            },
            {
                "name": "ports"
            },
            {
                "name": "services",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "stateagentinspector",
                "parameters": [
                    {
                        "name": "eventTypes",
                        "value": []
                    }
                ]
            },
            {
                "name": "syslog"
            }
        ]
    }
    STANDART_INVESTIGATIVE_DETAILS_LINUX = {
        "commands": [
            {
                "name": "sysinfo"
            },
            {
                "name": "files-api",
                "parameters": [
                    {
                        "name": "Path",
                        "value": "/"
                    },
                    {
                        "name": "Regex",
                        "value": "^(?:usr|lib|lib64|opt|home|sbin|bin|etc|root)+"
                    },
                    {
                        "name": "Include Remote Locations",
                        "value": False
                    },
                    {
                        "name": "Depth",
                        "value": -1
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "AND Operator",
                        "value": False
                    },
                    {
                        "name": "Include Files",
                        "value": True
                    },
                    {
                        "name": "Include Directories",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "processes-api"
            },
            {
                "name": "ports"
            },
            {
                "name": "shell-history",
                "parameters": [
                    {
                        "name": "ShellList",
                        "value": [
                            "bash",
                            "zsh",
                            "ksh93"
                        ]
                    }
                ]
            }
        ]
    }
    STANDART_INVESTIGATIVE_DETAILS_WIN = {
        "commands": [
            {
                "name": "sysinfo"
            },
            {
                "name": "disks",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "volumes",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "useraccounts",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "prefetch",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "files-raw",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "Active Files",
                        "value": True
                    },
                    {
                        "name": "Deleted Files",
                        "value": True
                    },
                    {
                        "name": "Parse NTFS INDX Buffers",
                        "value": True
                    },
                    {
                        "name": "Path",
                        "value": "%systemdrive%"
                    },
                    {
                        "name": "Depth",
                        "value": -1
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Analyze Entropy",
                        "value": False
                    },
                    {
                        "name": "Enumerate Imports",
                        "value": False
                    },
                    {
                        "name": "Enumerate Exports",
                        "value": False
                    },
                    {
                        "name": "Analyze File Anomalies",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": False
                    },
                    {
                        "name": "Strings",
                        "value": False
                    },
                    {
                        "name": "AND Operator",
                        "value": False
                    },
                    {
                        "name": "Include Files",
                        "value": True
                    },
                    {
                        "name": "Include Directories",
                        "value": True
                    },
                    {
                        "name": "Get Resources",
                        "value": False
                    },
                    {
                        "name": "Get Resource Data",
                        "value": False
                    },
                    {
                        "name": "Get Version Info",
                        "value": False
                    }
                ]
            },
            {
                "name": "persistence",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "Enumerate Imports",
                        "value": False
                    },
                    {
                        "name": "Enumerate Exports",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Analyze Entropy",
                        "value": False
                    },
                    {
                        "name": "Analyze File Anomalies",
                        "value": False
                    },
                    {
                        "name": "Get Resources",
                        "value": False
                    },
                    {
                        "name": "Get Version Info",
                        "value": False
                    },
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "registry-raw",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "Type",
                        "value": "All"
                    }
                ]
            },
            {
                "name": "tasks",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "raw mode",
                        "value": False
                    }
                ]
            },
            {
                "name": "eventlogs",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "processes-memory",
                "parameters": [
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "MemD5",
                        "value": False
                    },
                    {
                        "name": "enumerate imports",
                        "value": True
                    },
                    {
                        "name": "enumerate exports",
                        "value": True
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "sections",
                        "value": True
                    },
                    {
                        "name": "ports",
                        "value": True
                    },
                    {
                        "name": "handles",
                        "value": True
                    },
                    {
                        "name": "detect injected dlls",
                        "value": True
                    },
                    {
                        "name": "raw mode",
                        "value": False
                    },
                    {
                        "name": "strings",
                        "value": False
                    }
                ]
            },
            {
                "name": "urlhistory",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "GetThumbnails",
                        "value": False
                    },
                    {
                        "name": "GetIndexedPageContent",
                        "value": False
                    }
                ]
            },
            {
                "name": "ports",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "services",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "raw mode",
                        "value": False
                    }
                ]
            },
            {
                "name": "stateagentinspector",
                "parameters": [
                    {
                        "name": "eventTypes",
                        "value": []
                    }
                ]
            }
        ]
    }

    SYS_SCRIPT_MAP = {
        'osx': STANDART_INVESTIGATIVE_DETAILS_OSX,
        'win': STANDART_INVESTIGATIVE_DETAILS_WIN,
        'linux': STANDART_INVESTIGATIVE_DETAILS_LINUX
    }

    """

    COMMAND HANDLERS

    """

    def get_token_request():
        """
        returns a token on successful request
        """

        url = '{}/token'.format(BASE_PATH)

        #basic authentication
        try:
            response = requests.request(
                'GET',
                url,
                headers=GET_HEADERS,
                verify=USE_SSL,
                auth=(USERNAME,PASSWORD)
            )
        except requests.exceptions.SSLError as e:
            LOG(e.message)
            raise ValueError('An SSL error occurred when trying to connect to the server. Consider configuring unsecure connection in the integration settings')

        #handle request failure
        if response.status_code not in range(200,205):
            message = parse_error_response(response)
            raise ValueError('Token request failed with status code {}\n{}'.format(response.status_code, message))
        #successful request
        response_headers = response.headers
        token = response_headers.get('X-FeApi-Token')
        return token

    def get_token():
        token = get_token_request()
        if token:
            return token
        raise ('Failed to get a token, unexpected response structure from the server')

    """

    HOST INFORMATION

    """

    def get_host_by_agent_request(agent_id):
        """
        returns the response body

        raises an exception on:

            - http request failure
            - response status code different from 200
        """
        url = '{}/hosts/{}'.format(BASE_PATH, agent_id)


        response = http_request(
            'GET',
            url,
            headers = GET_HEADERS
        )

        #successful request
        try:
            return response.json()['data']
        except Exception as e:
            raise ValueError('Failed to get host information - unexpected response structure from the server.')

    def get_host_information():
        """

        return the host information to the war room, given an agentId or hostName from input.

        """
        args = demisto.args()

        if not args.get('agentId') and not args.get('hostName'):
            raise ValueError('Please provide either agentId or hostName')

        host = get_host_by_agent_request(args.get('agentId')) if args.get('agentId') else get_host_by_name_request(args.get('hostName'))

        md_table = tableToMarkdown(
            'FireEye HX Get Host Information',
            host_entry(host),
            headers=HOST_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': host,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": host,
                "Endpoint(obj.ID==val.ID)": collect_endpoint_contxt(host)
            }
        }
        demisto.results(entry)

    def get_host_set_information():
        """
        return host set information to the war room according to given id or filters

        """
        args = demisto.args()

        url = '{}/host_sets/{}'.format(BASE_PATH, args.get('hostSetID', ''))
        url_params = {
            'limit': args.get('limit'),
            'offset': args.get('offset'),
            'search': args.get('search'),
            'sort': args.get('sort'),
            'name': args.get('name'),
            'type': args.get('type')
        }
        response = http_request(
            'GET',
            url,
            headers = GET_HEADERS,
            url_params=url_params
        )
        host_sets = []
        try:
            host_sets = response.json()['data']
        except Exception as e:
            raise ValueError('Failed to get host set information - unexpected response from the server.\n'+response.text)

        md_table = "No host sets found"
        host_sets_list = [host_sets] if args.get('hostSetID') else host_sets.get('entries', [])
        if len(host_sets_list) > 0:
            md_table = tableToMarkdown(
                'FireEye HX Get Host Sets Information',
                host_set_entry(host_sets_list),
                headers=HOST_SET_MAIN_ATTRIBUTES
            )

        entry = {
            'Type': entryTypes['note'],
            'Contents': host_sets,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.HostSets(obj._id==val._id)": host_sets_list
            }
        }
        demisto.results(entry)

    def get_hosts_request(limit=None, offset=None, has_active_threats=None, has_alerts=None, agent_version=None, containment_queued=None, containment_state=None,
        host_name=None, os_platform=None, reported_clone=None, time_zone=None):
        """
        returns the response body

        raises an exception on:

            - http request failure
            - response status code different from 200
        """
        url = '{}/hosts'.format(BASE_PATH)
        url_params = {
            'limit': limit,
            'offset': offset,
            'has_active_threats': has_active_threats,
            'has_alerts': has_alerts,
            'agent_version': agent_version,
            'containment_queued': containment_queued,
            'containment_state': containment_state,
            'hostname': host_name,
            'os.platform': os_platform,
            'reported_clone': reported_clone,
            'time_zone': time_zone
        }
        #remove None values
        url_params = { k:v for k,v in url_params.items() if v is not None}

        response = http_request(
            'GET',
            url,
            url_params = url_params,
            headers = GET_HEADERS
        )
        #successful request
        try:
            return response.json()['data']['entries']
        except Exception as e:
            raise ValueError('Failed to parse response body - unexpected response structure from the server.')

    def get_host_by_name_request(host_name):
        try:
            return get_hosts_request(host_name=host_name, limit=1)[0]
        except Exception as e:
            LOG(e)
            raise ValueError('Host {} not found.'.format(host_name))

    def get_all_agents_ids():
        """
        returns a list of all agents ids
        """
        offset = 0
        hosts = []

        #get all hosts
        while True:
            hosts_partial_results = get_hosts_request(offset=offset, limit=1000)
            if not hosts_partial_results:
                break
            hosts.extend(hosts_partial_results)
            offset = len(hosts)
        return [host.get('_id') for host in hosts]

    def get_agent_id(host_name):
        """
        returns the agent id given the host name

        raises an exception on:
            - unexpected response structure
            - empty results

        """
        host = get_host_by_name_request(host_name)
        try:
            return host['_id']
        except Exception as e:
            raise ValueError('Failed to get agent id for host {}'.format(host_name))

    def collect_endpoint_contxt(host):
        return {
            'Hostname': host['hostname'],
            'ID': host['_id'],
            'IPAddress': host['primary_ip_address'],
            'Domain': host['domain'],
            'MACAddress': host['primary_mac'],
            'OS': host['os']['platform'],
            'OSVersion': host['os']['product_name']
        }

    """

    HOST CONTAINMENT

    """
    def containment_request(agent_id):
        """

        no return value on successful request

        """
        url = '{}/hosts/{}/containment'.format(BASE_PATH, agent_id)
        body = {
            'state': 'contain'
        }

        response = http_request(
            'POST',
            url,
            body = body,
            headers = POST_HEADERS
        )
        #no exception raised - successful request

    def containment():
        """

        returns a success message to the war room

        """

        args = demisto.args()

        #validate one of the arguments was passed
        if not args:
            raise ValueError('Please provide either agentId or hostName')

        #in case a hostName was given, set the agentId accordingly
        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        containment_request(args['agentId'])
        #no exceptions raised->successful request

        host = get_host_by_agent_request(args['agentId'])
        entry = {
            'Type': entryTypes['note'],
            'Contents': 'Containment rquest for the host was sent and approved successfuly',
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": host,
                "Endpoint(obj.ID==val.ID)": collect_endpoint_contxt(host)
            }
        }
        demisto.results(entry)

    def containment_cancellation_request(agent_id):
        """

        no return value on successful request

        """
        url = '{}/hosts/{}/containment'.format(BASE_PATH, agent_id)

        response = http_request(
            'DELETE',
            url,
            headers = GET_HEADERS
        )
        #no exceptions are raised - successful request

    def containment_cancellation():
        """

        returns a success message to the war room

        """

        args = demisto.args()

        #validate one of the arguments was passed
        if not args:
            raise ValueError('Please provide either agentId or hostName')

        #in case a hostName was given, set the agentId accordingly
        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        containment_cancellation_request(args['agentId'])
        #no exceptions raised->successful request

        host = get_host_by_agent_request(args['agentId'])
        entry = {
            'Type': entryTypes['note'],
            'Contents': 'The host is released from containment.',
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": host,
                "Endpoint(obj.ID==val.ID)": collect_endpoint_contxt(host)
            }
        }
        demisto.results(entry)

    """

    ALERTS

    """

    def get_alert_request(alert_id):

        url = '{}/alerts/{}'.format(BASE_PATH, alert_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )
        return response.json().get('data')

    def get_alert():

        alert_id = demisto.args().get('alertId')
        alert = get_alert_request(alert_id)

        alert_table = tableToMarkdown(
            'FireEye HX Get Alert #{}'.format(alert_id),
            alert_entry(alert),
            headers=ALERT_MAIN_ATTRIBUTES
        )

        event_type = re.sub("([a-z])([A-Z])","\g<1> \g<2>",alert.get('event_type','NewEvent')).title()
        event_table = tableToMarkdown(
            event_type,
            alert.get('event_values')
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': alert,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '{}\n{}'.format(alert_table, event_table),
            'EntryContext': {
                "FireEyeHX.Alerts(obj._id==val._id)": alert
            }
        }
        demisto.results(entry)


    def get_alerts_request(has_share_mode=None, resolution=None, agent_id=None, host_name=None, condition_id=None, limit=None,
        offset=None, sort=None, min_id=None, event_at=None, alert_id=None, matched_at=None, reported_at=None, source=None):
        """

        returns the response body on successful request

        """
        url = '{}/alerts'.format(BASE_PATH)

        body = {
            'has_share_mode': has_share_mode,
            'resolution': resolution,
            'agent._id': agent_id,
            'condition._id': condition_id,
            'event_at': event_at,
            'min_id': min_id,
            '_id': alert_id,
            'matched_at': matched_at,
            'reported_at': reported_at,
            'source': source,
            'limit': limit,
            'offset': offset,
            'sort': sort
        }

        #remove None values
        body = {k:v for k,v in body.items() if v is not None}


        response = http_request(
            'GET',
            url,
            url_params=body,
            headers=GET_HEADERS
        )
        try:
            return response.json()['data']['entries']
        except Exception as e:
            raise ValueError('Failed to parse response body')

    def get_all_alerts(has_share_mode=None, resolution=None, agent_id=None, condition_id=None, limit=None,
        sort=None, min_id=None, event_at=None, alert_id=None, matched_at=None, reported_at=None, source=None):
        """

        returns a list of alerts, all results up to limit

        """
        offset = 0
        alerts = []

        max_records = limit or float('inf')

        while len(alerts) < max_records:
            alerts_partial_results = get_alerts_request(
                has_share_mode = has_share_mode,
                resolution = resolution,
                agent_id = agent_id,
                condition_id = condition_id,
                event_at = event_at,
                alert_id = alert_id,
                matched_at = matched_at,
                reported_at = reported_at,
                source = source,
                min_id = min_id,
                offset = offset,
                limit = limit or 100,
                sort = sort
            )
            #empty list
            if not alerts_partial_results:
                break
            alerts.extend(alerts_partial_results)
            offset = len(alerts)

        #remove access results
        if len(alerts) > max_records:
            alerts[max_records-1 : -1] = []

        return alerts

    def general_context_from_event(alert):

        def file_context(values):
            return {
                'Name': values.get('fileWriteEvent/fileName'),
                'MD5': values.get('fileWriteEvent/md5'),
                'Extension': values.get('fileWriteEvent/fileExtension'),
                'Path': values.get('fileWriteEvent/fullPath')
            }
        def ip_context(values):
            return {
                'Address' : values.get('ipv4NetworkEvent/remoteIP')
            }
        def registry_key_context(values):
            return {
                'Path': values.get('regKeyEvent/path'),
                'Name': values.get('regKeyEvent/valueName'),
                'Value': values.get('regKeyEvent/value')
            }
        context_map = {
            'fileWriteEvent': file_context,
            'ipv4NetworkEvent': ip_context,
            'regKeyEvent': registry_key_context
        }

        if context_map.get(alert['event_type']):
            return context_map.get(alert['event_type'])(alert['event_values'])
        return None

    def collect_context(alerts):

        #collect_context
        files = []
        ips = []
        registry_keys = []

        for alert in alerts:
            event_type = alert.get('event_type')
            context = general_context_from_event(alert)
            if event_type == 'fileWriteEvent':
                files.append(context)
            elif event_type == 'ipv4NetworkEvent':
                ips.append(context)
            elif event_type == 'regKeyEvent':
                registry_keys.append(context)
        return (files, ips, registry_keys)


    def get_alerts():
        """

        returns a list of alerts to the war room

        """

        args = demisto.args()
        source = []
        #add source type
        if args.get('MALsource'):
            source.append ('mal')
        if args.get('EXDsource'):
            source.append('exd')
        if args.get('IOCsource'):
            source.append('ioc')

        sort_map = {
            'agentId': 'agent._id',
            'conditionId': 'condition._id',
            'eventAt': 'event_at',
            'alertId': '_id',
            'matchedAt': 'matched_at',
            'id': '_id',
            'reportedAt': 'reported_at'
        }

        if args.get('sort'):
            args['sort'] = '{}+{}'.format(sort_map.get(args['sort']),args.get('sortOrder', 'ascending'))

        if args.get('hostName'):
            args['agentId'] = get_agent_id(args.get('hostName'))

        if args.get('limit'):
            args['limit'] = int(args['limit'])

        alerts = get_all_alerts(
            has_share_mode = args.get("hasShareMode"),
            resolution = args.get('resolution'),
            agent_id = args.get('agentId'),
            condition_id = args.get('conditionId'),
            event_at = args.get('eventAt'),
            alert_id = args.get('alertId'),
            matched_at = args.get('matchedAt'),
            reported_at = args.get('reportedAt'),
            source = source,
            min_id = args.get('min_id'),
            limit = args.get('limit'),
            sort = args.get('sort')
        )

        #parse each alert to a record displayed in the human readable table
        alerts_entries = [alert_entry(alert) for alert in alerts]

        files, ips, registry_keys = collect_context(alerts)

        md_table = tableToMarkdown(
            'FireEye HX Get Alerts',
            alerts_entries,
            headers=ALERT_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': alerts,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Alerts(obj._id==val._id)": alerts,
                'File': files,
                'RegistryKey': registry_keys,
                'IP': ips
            }
        }
        demisto.results(entry)

    def suppress_alert_request(alert_id):
        """

        no return value on successful request

        """

        url = '{}/alerts/{}'.format(BASE_PATH, alert_id)

        response = http_request(
            'DELETE',
            url
        )

    def suppress_alert():
        """

        returns a success message to the war room

        """

        alert_id = demisto.args().get('alertId')

        suppress_alert_request(alert_id)
        #no exceptions raised->successful request

        entry = {
            'Type': entryTypes['note'],
            'Contents': 'Alert {} suppressed successfuly.'.format(alert_id),
            'ContentsFormat': formats['text']
        }
        demisto.results(entry)

    """

    INDICATORS

    """
    def new_indicator_request(category):
        """
        Create a new indicator
        """
        url = '{}/indicators/{}'.format(BASE_PATH, category)

        response = http_request(
            'POST',
            url,
            headers = GET_HEADERS
        )
        try:
            return response.json().get('data')
        except Exception as e:
            raise ValueError('Failed to parse response body, unexpected response structure from the server.')


    def create_indicator():
        """
        Get new indicator details
        returns a success message to the war room
        """

        category = demisto.args().get('category')

        response = new_indicator_request(category)

        md_table =  {
            'ID': response.get('_id'),
        }
        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FireEye HX New Indicator created successfully', md_table),
            'EntryContext': {
                "FireEyeHX.Indicators(obj._id===val._id)": response
            }
        }
        demisto.results(entry)

    def append_conditions_request(name, category, body):
        """
        Append conditions to indicator request
        """

        url = '{}/indicators/{}/{}/conditions'.format(BASE_PATH, category, name)

        response = http_request(
            'PATCH',
            url,
            conditions_params = body,
            headers = PATCH_HEADERS
        )

        return response.json()

    def append_conditions():
        """
        Append conditions to indicator
        no return value on successfull request
        """
        name = demisto.args().get('name')
        category = demisto.args().get('category')
        body = demisto.args().get('condition')

        body = body.replace(',', '\n')

        response = append_conditions_request(name, category, body)

        md_table =  {
            'Name': name,
            'Category': category,
            'Conditions': body
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('The conditions were added successfully', md_table)
        }
        demisto.results(entry)

    def get_indicator_request(category, name):
        """

        returns a json object representing an indicator

        """

        url = '{}/indicators/{}/{}'.format(BASE_PATH, category, name)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS,
        )
        return response.json().get('data')

    def get_indicator_conditions_request(category, name, limit=None, offset=None, enabled=None, has_alerts=None):
        """

        returns a list of json objects, each representing an indicator condition
        if no results are found- returns None

        """
        url = '{}/indicators/{}/{}/conditions'.format(BASE_PATH, category, name)
        url_params = {
            'limit': limit,
            'offset': offset,
            'enabled': enabled,
            'has_alerts': has_alerts
        }
        #remove None values
        url_params = { k:v for k,v in url_params.items() if v is not None}

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS,
            url_params=url_params
        )
        try:
            return response.json()['data']['entries']
        except Exception as e:
            raise ValueError('Failed to parse response body')

    def get_all_enabled_conditions(indicator_category, indicator_name):

        offset = 0
        conditions =[]

        #get all results
        while True:
            conditions_partial_results = get_indicator_conditions_request(
                indicator_category,
                indicator_name,
                enabled=True,
                offset=offset
            )
            if not conditions_partial_results:
                break
            conditions.extend(conditions_partial_results)
            offset = len(conditions)
        return conditions

    def get_indicator_conditions():
        """

        returns a list of enabled conditions assosiated with a specific indicator to the war room

        """

        args = demisto.args()

        conditions = get_all_enabled_conditions(
            args.get('category'),
            args.get('name')
        )

        conditions_entries = [condition_entry(condition) for condition in conditions]

        md_table = tableToMarkdown(
            'Indicator "{}" Alerts on'.format(args.get('name')),
            conditions_entries
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': conditions,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Conditions(obj._id==val._id)": conditions
            }
        }
        demisto.results(entry)

    def get_indicator():

        args = demisto.args()

        indicator = get_indicator_request(
            args.get('category'),
            args.get('name')
        )

        md_table = tableToMarkdown(
            'FireEye HX Get Indicator- {}'.format(args.get('name')),
            indicator_entry(indicator),
            headers=INDICATOR_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': indicator,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Indicators(obj._id==val._id)": indicator
            }
        }
        demisto.results(entry)

    def get_indicators_request(category=None, search=None, limit=None, offset=None, share_mode=None, sort=None, created_by=None, alerted=None):

        url = '{}/indicators'.format(BASE_PATH)
        if category:
            url = url + '/' + category

        url_params = {
            'search': search,
            'limit': limit,
            'offset': offset,
            'category.share_mode': share_mode,
            'sort': sort,
            'created_by': created_by,
            'stats.alerted_agents': alerted
        }

        #remove None value
        url_params = { k:v for k,v in url_params.items() if v}

        response = http_request(
            'GET',
            url,
            url_params=url_params,
            headers=GET_HEADERS,
        )
        try:
            response_body = response.json()
            data = response_body['data']
            #no results found
            if data['total'] == 0:
                return None
            return data['entries']
        except Exception as e:
            raise ValueError('Failed to parse response body')

    def get_all_indicators(category=None, search=None, share_mode=None, sort=None, created_by=None, alerted=None, limit=None):

        max_records = limit or float('inf')
        offset=0
        indicators = []

        #get all results
        while len(indicators) < max_records:
            indicators_partial_results = get_indicators_request(
                category=category,
                search=search,
                offset=offset,
                share_mode=share_mode,
                sort=sort,
                created_by=created_by,
                alerted=alerted,
                limit=limit or 100
            )
            if not indicators_partial_results:
                break
            indicators.extend(indicators_partial_results)
            offset = len(indicators)

        #remove access results
        if len(indicators) > max_records:
            indicators[max_records-1 : -1] = []

        return indicators

    def get_indicators():

        args = demisto.args()

        sort_map = {
            'category': 'category',
            'activeSince': 'active_since',
            'createdBy': 'created_by',
            'alerted': 'stats.alerted_agents'
        }

        if args.get('limit'):
            args['limit'] = int(args['limit'])
        if args.get('alerted'):
            args['alerted'] = args['alerted'] == 'yes'
        if args.get('sort'):
            args['sort'] = sort_map.get(args.get('sort'))

        #get all results
        indicators = get_all_indicators(
            category=args.get('category'),
            search=args.get('searchTerm'),
            share_mode=args.get('shareMode'),
            sort=args.get('sort'),
            created_by=args.get('createdBy'),
            alerted=args.get('alerted'),
            limit=args.get('limit')
        )

        indicators_entries = [indicator_entry(indicator) for indicator in indicators]

        md_table = tableToMarkdown(
            'FireEye HX Get Indicator- {}'.format(args.get('name')),
            indicators_entries,
            headers=INDICATOR_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': indicators,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Indicators(obj._id==val._id)": indicators
            }
        }
        demisto.results(entry)

    """

    SEARCH

    """

    def search_request(query, host_set=None, hosts=None, exhaustive=False):

        url = '{}/searches'.format(BASE_PATH)

        body = { 'query': query }

        if host_set:
            body['host_set'] = {'_id': int(host_set)}
        elif hosts:
            body['hosts'] = [{'_id': host} for host in hosts]

        if exhaustive:
            body['exhaustive'] = True

        try:
            response = http_request(
                'POST',
                url,
                headers=POST_HEADERS,
                body=body
            )
        except Exception as e:
            raise e
        if response.status_code == 409:
            LOG(e.message)
            raise ValueError('Request unsuccessful because the search limits (10 existing searches or 5 running searches) have been exceeded')
        return response.json().get('data')

    def get_search_information_request(search_id):
        """

        returns the search information represented by a json object.

        """

        url = '{}/searches/{}'.format(BASE_PATH, search_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )
        return response.json().get('data')

    def get_search_results_request(search_id):
        """

        returns the search results represented by a json object.

        """

        url = '{}/searches/{}/results'.format(BASE_PATH, search_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )
        return response.json().get('data', {}).get('entries', [])

    def stop_search_request(search_id):
        """

        returns the search information represented by a json object.

        """

        url = '{}/searches/{}/actions/stop'.format(BASE_PATH,search_id)

        response = http_request(
            'POST',
            url,
            headers=POST_HEADERS
        )
        return response.json()

    def delete_search_request(search_id):
        """

        no return value on successful request

        """

        url = '{}/searches/{}'.format(BASE_PATH,search_id)
        response = http_request(
            'DELETE',
            url
        )

    def search_results_to_context(results, search_id):
        for res in results:
            res["SearchID"] = search_id
            res["HostID"] = res.get("host", {}).get("_id")
            res["HostName"] = res.get("host", {}).get("hostname")
            res["HostUrl"] = res.get("host", {}).get("url")
            del res['host']
            res["Results"] = res.get("results")
            del res["results"]
            for resData in res.get("Results"):
                resData.update(resData.get("data", {}))
                del resData['data']
        return results
    def start_search():

        args = demisto.args()

        '''
        to search all hosts past none of the arguments?

        #validate at list one of the arguments 'agentsIds', 'hostsNames', 'hostSet' was passed
        if not any([args.get('agentsIds'),args.get('hostsNames'),args.get('hostSet'), args.get('searchAllHosts')]):
            raise ValueError('Please provide one of the followings: agentsIds, hostsNames, hostSet')
        '''

        agents_ids = []
        if args.get('agentsIds'):
            agents_ids = args['agentsIds'].split(',')
        elif args.get('hostsNames'):
            names = args.get('hostsNames').split(',')
            for name in names:
                try:
                    agent_id = get_agent_id(name)
                    agents_ids.append(agent_id)
                except Exception as e:
                    LOG(e.message)
                    pass
            if not agents_ids:
                raise ValueError('None of the host names were matched with an agent')

        #limit can't exceed 1000.
        limit = args.get('limit')
        if not limit or limit > 1000:
            limit = 1000

        arg_to_query_field_map = {
            'dnsHostname': 'DNS Hostname',
            'fileFullPath': 'File Full Path',
            'fileMD5Hash': 'File MD5 Hash',
            'ipAddress': 'IP Address'
        }

        query = []
        for arg in arg_to_query_field_map.keys():
            if not args.get(arg):
                continue
            field_filter = {
                'field': arg_to_query_field_map[arg],
                'operator': args['{}Operator'.format(arg)],
                'value': args[arg]
            }
            query.append(field_filter)

        search = search_request(
            query,
            hosts=agents_ids,
            host_set=args.get('hostSet'),
            exhaustive=args.get('exhaustive')=='yes'
        )

        search_id = search.get('_id')

        #loop to get search status once a minute. break on: search has stopped, matched results exceeded limit, or no more pending hosts.
        while True:
            search_info = get_search_information_request(search_id)
            matched = search_info.get('stats', {}).get('search_state', {}).get('MATCHED',0)
            pending = search_info.get('stats', {}).get('search_state', {}).get('PENDING',0)
            if search_info.get('state')=='STOPPED' or matched >= limit or pending == 0 :
                break
            time.sleep(60)

        results = get_search_results_request(search_id)
        md_entries = [host_results_md_entry(host_results) for host_results in results]

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '## Search Results\n' + '\n'.join(md_entries),
            'EntryContext': {
                "FireEyeHX.Search": search_results_to_context(results, search_id)
            }
        }
        demisto.results(entry)

        #finally stop or delete the search
        possible_error_message = None
        try:
            if args.get('stopSearch') == 'stop':
                possible_error_message = 'Failed to stop search'
                stop_search_request(search_id)
            #no need to stop a search before deleting it.
            if args.get('stopSearch') == 'stopAndDelete':
                possible_error_message = 'Failed to delete search'
                delete_search_request(search_id)
            possible_error_message = None
        except Exception as e:
            LOG('{}\n{}'.format(possible_error_message, e.message))
            pass
        #add warning entry if neccessery
        if possible_error_message:
            warning_entry = {
                'Type': entryTypes['note'],
                'Contents': possible_error_message,
                'ContentsFormat': formats['text'],
            }
            demisto.results(warning_entry)

    """

    ACQUISITIONS

    """


    def file_acquisition_request(agent_id, file_name, file_path, comment=None, external_id=None, req_use_api=None):

        url = '{}/hosts/{}/files'.format(BASE_PATH, agent_id)

        body = {
            'req_path': file_path,
            'req_filename': file_name,
            'comment': comment,
            'external_id': external_id,
            'req_use_api': req_use_api
        }

        #remove None values
        body = {k:v for k,v in body.items() if v is not None}

        response = http_request(
            'POST',
            url,
            body=body,
            headers=POST_HEADERS
        )

        return response.json().get('data')

    def file_acquisition_package_request(acquisition_id):

        url = '{}/acqs/files/{}.zip'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url
        )

        return response.content

    def file_acquisition_information_request(acquisition_id):

        url = '{}/acqs/files/{}'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )

        return response.json().get('data')

    def delete_file_acquisition_request(acquisition_id):
        """

        no return value on successful request

        """

        url = '{}/acqs/files/{}'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'DELETE',
            url
        )

    def delete_file_acquisition():
        """

        returns a success message to the war room

        """
        acquisition_id = demisto.args().get('acquisitionId')
        delete_file_acquisition_request(acquisition_id)
        #successful request

        return {
            'Type': entryTypes['note'],
            'Contents': 'file acquisition {} deleted successfuly'.format(acquisition_id),
            'ContentsFormat': formats['text'],
        }


    def file_acquisition():

        args = demisto.args()

        if not args.get('hostName') and not args.get('agentId'):
            raise ValueError('Please provide either agentId or hostName')

        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        use_api = args.get('acquireUsing') == 'API'

        acquisition_info = file_acquisition_request(
            args.get('agentId'),
            args.get('fileName'),
            args.get('filePath'),
            req_use_api=use_api
        )

        acquisition_id = acquisition_info.get('_id')

        LOG('acquisition request was successful. Waiting for acquisition process to be complete.')
        while True:
            acquisition_info = file_acquisition_information_request(acquisition_id)
            if acquisition_info.get('state') == 'COMPLETE':
                break
            time.sleep(10)
        LOG('acquisition process has been complete. Fetching zip file.')

        acquired_file = file_acquisition_package_request(acquisition_id)

        message = '{} acquired successfuly'.format(args.get('fileName'))
        if acquisition_info.get('error_message'):
            message = acquisition_info.get('error_message')

        entry = {
            'Type': entryTypes['note'],
            'Contents': '{}\nacquisition ID: {}'.format(message, acquisition_id),
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Acquisitions.Files(obj._id==val._id)": acquisition_info
            }
        }

        demisto.results(entry)
        demisto.results(fileResult('{}.zip'.format(os.path.splitext(args.get('fileName'))[0]), acquired_file))

    def data_acquisition_request(agent_id, script_name, script):

        url = '{}/hosts/{}/live'.format(BASE_PATH, agent_id)

        body = {
            'name': script_name,
            'script': {'b64': script}
        }

        response = http_request(
            'POST',
            url,
            body=body
        )

        return response.json()['data']

    def data_acquisition_information_request(acquisition_id):

        url = '{}/acqs/live/{}'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )

        return response.json()['data']


    def data_collection_request(acquisition_id):

        url ='{}/acqs/live/{}.mans'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url
        )

        return response.content

    def data_acquisition():
        """

        returns the mans file to the war room

        """

        args = demisto.args()

        #validate the host name or agent ID was passed
        if not args.get('hostName') and not args.get('agentId'):
            raise ValueError('Please provide either agentId or hostName')

        if not args.get('defaultSystemScript') and not args.get('script'):
            raise ValueError('If the script is not provided, defaultSystemScript must be specified.')

        if args.get('script') and not args.get('scriptName'):
            raise ValueError('If the script is provided, script name must be specified as well.')

        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        #determine whether to use the default script
        sys = args.get('defaultSystemScript')
        if sys:
            args['script'] = json.dumps(SYS_SCRIPT_MAP[sys])
            args['scriptName'] = '{}DefaultScript'.format(sys)


        acquisition_info = data_acquisition_request(
            args['agentId'],
            args['scriptName'],
            base64.b64encode(args['script'])
        )

        acquisition_id = acquisition_info.get('_id')

        LOG('Acquisition request was successful. Waiting for acquisition process to be complete.')
        #loop to inquire acquisition state every 30 seconds
        #break when state is complete
        while True:
            acquisition_info = data_acquisition_information_request(acquisition_id)
            if acquisition_info.get('state') == 'COMPLETE':
                break
            time.sleep(30)
        LOG('Acquisition process has been complete. Fetching mans file.')

        message = '{} acquired successfuly'.format(args.get('fileName'))
        if acquisition_info.get('error_message'):
            message = acquisition_info.get('error_message')

        #output file and acquisition information to the war room
        data = data_collection_request(acquisition_id)
        entry = {
            'Type': entryTypes['note'],
            'Contents': '{}\nacquisition ID: {}'.format(message, acquisition_id),
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Acquisitions.Data(obj._id==val._id)": acquisition_info
            }
        }
        demisto.results(entry)
        demisto.results(fileResult('agent_{}_data.mans'.format(args['agentId']), data))

    def delete_data_acquisition_request(acquisition_id):
        """

        no return value on successful request

        """

        url = '{}/acqs/live/{}'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'DELETE',
            url
        )

    def delete_data_acquisition():
        """

        returns a success message to the war room

        """
        acquisition_id = demisto.args().get('acquisitionId')
        delete_data_acquisition_request(acquisition_id)
        #successful request

        return {
            'Type': entryTypes['note'],
            'Contents': 'data acquisition {} deleted successfuly'.format(acquisition_id),
            'ContentsFormat': formats['text'],
        }
    """

    FETCH INCIDENTS

    """


    def fetch_incidents():

        lastRun = demisto.getLastRun()
        alerts = []
        if lastRun and lastRun.get('min_id'):
            #get all alerts with id greater than min_id
            alerts = get_all_alerts(
                min_id=lastRun.get('min_id'),
                sort='_id+ascending'
            )
            #results are sorted in ascending order - the last alert holds the greatest id
            min_id = alerts[-1].get('_id') if alerts else None
        else:
            #get the last 100 alerts
            alerts = get_all_alerts(
                sort='_id+descending',
                limit=100
            )
            #results are sorted in descending order - the first alert holds the greatest id
            min_id = alerts[0].get('_id') if alerts else None

        incidents = [parse_alert_to_incident(alert) for alert in alerts]
        demisto.incidents(incidents)
        if min_id is not None:
            demisto.setLastRun({'min_id': min_id})


    def parse_alert_to_incident(alert):

        event_type = alert.get('event_type', 'NewEvent')
        event_values = alert.get('event_values', {})
        event_indicators_map = {
            'fileWriteEvent': 'fileWriteEvent/fileName',
            'ipv4NetworkEvent': 'ipv4NetworkEvent/remoteIP',
            'dnsLookupEvent': 'dnsLookupEvent/hostname',
            'regKeyEvent': 'regKeyEvent/valueName'
        }
        event_indicator = event_indicators_map.get(event_type)

        incident_name = '{event_type_parsed}: {indicator}'.format(
            event_type_parsed=re.sub("([a-z])([A-Z])","\g<1> \g<2>", event_type).title(),
            indicator= event_values.get(event_indicator)
        )

        incident = {
            'name': incident_name,
            'rawJSON': json.dumps(alert)
        }
        return incident

    """

    ENTRY ENTITIES

    """
    def indicator_entry(indicator):

        indicator_entry = {
            'OS' : ', '.join(indicator.get('platforms',[])),
            'Name': indicator.get('name'),
            'Created By': indicator.get('created_by'),
            'Active Since': indicator.get('active_since'),
            'Category': indicator.get('category', {}).get('name'),
            'Signature': indicator.get('signature'),
            'Active Condition': indicator.get('stats',{}).get('active_conditions'),
            'Hosts With Alerts': indicator.get('stats',{}).get('alerted_agents'),
            'Source Alerts': indicator.get('stats',{}).get('source_alerts')
        }
        return indicator_entry

    def host_entry(host):

        host_entry = {
            'Host Name': host.get('hostname'),
            'Last Poll':  host.get('last_poll_timestamp'),
            'Agent ID': host.get('_id'),
            'Agent Version': host.get('agent_version'),
            'Host IP': host.get('primary_ip_address'),
            'OS': host.get('os', {}).get('platform'),
            'Containment State': host.get('containment_state'),
            'Domain': host.get('domain'),
            'Last Alert': host.get('last_alert')
        }
        return host_entry

    def host_set_entry(host_sets):
        host_set_entries = [{
            'Name': host_set.get('name'),
            'ID': host_set.get('_id'),
            'Type': host_set.get('type')
        } for host_set in host_sets]
        return host_set_entries

    def alert_entry(alert):

        alert_entry = {
            'Alert ID': alert.get('_id'),
            'Reported': alert.get('reported_at'),
            'Event Type': alert.get('event_type'),
            'Agent ID': alert.get('agent', {}).get('_id')
        }
        return alert_entry

    def condition_entry(condition):

        indicator_entry = {
            'Event Type': condition.get('event_type'),
            'Operator': condition.get('tests', {})[0].get('operator'),
            'Value': condition.get('tests', {})[0].get('value'),

        }
        return indicator_entry

    def host_results_md_entry(host_entry):

        results = host_entry.get('results', [])
        host_info = host_entry.get('host',{})
        entries = []
        for result in results:
            data = result.get('data',{})
            entry = {
                'Item Type': result.get('type'),
                'Summary': ' '.join(['**{}** {}'.format(k,v) for k,v in data.items()])
            }
            entries.append(entry)

        md_table = tableToMarkdown(
            host_info.get('hostname'),
            entries,
            headers=['Item Type', 'Summary']
        )
        return md_table

    """

    ADDITIONAL FUNCTIONS

    """

    def http_request(method, url, body=None, headers={}, url_params=None, conditions_params=None):
        """

        returns the http response

        """

        #add token to headers
        headers['X-FeApi-Token'] = TOKEN

        request_kwargs = {
            'headers': headers,
            'verify': USE_SSL
        }

        #add optional arguments if specified
        if body:
            #request_kwargs['data'] = ' '.join(format(x, 'b') for x in bytearray(json.dumps(body)))
            request_kwargs['data'] = json.dumps(body)
        if url_params:
            request_kwargs['params'] = url_params
        if conditions_params:
            request_kwargs['data'] = conditions_params


        LOG('attempting {} request sent to {} with arguments:\n{}'.format(method, url, json.dumps(request_kwargs, indent=4)))
        try:
            response = requests.request(
            method,
            url,
            **request_kwargs
        )
        except requests.exceptions.SSLError as e:
            LOG(e.message)
            raise ValueError('An SSL error occurred when trying to connect to the server. Consider configuring unsecure connection in the integration settings.')

        #handle request failure
        if response.status_code not in range(200,205):
            message = parse_error_response(response)
            raise ValueError('Request failed with status code {}\n{}'.format(response.status_code, message))

        return response

    def logout():
        url = '{}/token'.format(BASE_PATH)

        try:
            response = http_request(
                'DELETE',
                url
            )
        except ValueError as e:
            LOG('Failed to logout with token')
            raise e
        LOG('logout successfuly')

    def parse_error_response(response):
        try:
            res = response.json()
            msg = res.get('message')
            if res.get('details') is not None and res.get('details')[0].get('message') is not None:
                msg = msg + "\n"+json.dumps(res.get('details')[0])
        except Exception as e:
            return response.text
        return msg

    def return_error_entry(message):
        error_entry = {
            'Type': entryTypes['error'],
            'Contents': message,
            'ContentsFormat': formats['text']
        }
        demisto.results(error_entry)

    """

    EXECUTION

    """

    set_proxies()

    command = demisto.command()
    LOG('Running command "{}"'.format(command))

    #ask for a token using user credentials
    TOKEN = get_token()

    try:
        if command == 'test-module':
            #token generated - credentials are valid
            demisto.results('ok')
        elif command == 'fetch-incidents':
            fetch_incidents()
        elif command == 'fireeye-hx-get-alerts':
            get_alerts()
        elif command == 'fireeye-hx-cancel-containment':
            containment_cancellation()
        elif command == 'fireeye-hx-host-containment':
            containment()
        elif command == 'fireeye-hx-create-indicator':
            create_indicator()
        elif command == 'fireeye-hx-get-indicator':
            get_indicator()
            get_indicator_conditions()
        elif command == 'fireeye-hx-get-indicators':
            get_indicators()
        elif command == 'fireeye-hx-suppress-alert':
            suppress_alert()
        elif command == 'fireeye-hx-get-host-information':
            get_host_information()
        elif command == 'fireeye-hx-get-alert':
            get_alert()
        elif command == 'fireeye-hx-file-acquisition':
            file_acquisition()
        elif command == 'fireeye-hx-delete-file-acquisition':
            delete_file_acquisition()
        elif command == 'fireeye-hx-data-acquisition':
            data_acquisition()
        elif command == 'fireeye-hx-delete-data-acquisition':
            delete_data_acquisition_request()
        elif command == 'fireeye-hx-search':
            start_search()
        elif command == 'fireeye-hx-get-host-set-information':
            get_host_set_information()
        elif command == 'fireeye-hx-append-conditions':
            append_conditions()
    except ValueError as e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
    finally:
        logout()
  type: python
  commands:
  - name: fireeye-hx-host-containment
    arguments:
    - name: hostName
      description: The host name to be contained. If the hostName is not specified,
        the agentId must be specified.
    - name: agentId
      description: The agent id running on the host to be contained. If the agentId
        is not specified, the hostName must be specified.
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
    description: Apply containment for a specific host, so that it no longer has access
      to other systems.
  - name: fireeye-hx-cancel-containment
    arguments:
    - name: hostName
      description: The host name to be contained. If the hostName is not specified,
        the agentId must be specified.
    - name: agentId
      description: The agent id running on the host to be contained. If the agentId
        is not specified, the hostName must be specified.
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
    description: Release a specific host from containment.
  - name: fireeye-hx-get-alerts
    arguments:
    - name: hasShareMode
      auto: PREDEFINED
      predefined:
      - any
      - restricted
      - unrestricted
      description: Identifies which alerts result from indicators with the specified
        share mode.
    - name: resolution
      auto: PREDEFINED
      predefined:
      - active_threat
      - alert
      - block
      - partial_block
      description: Sorts the results by the specified field.
    - name: agentId
      description: Filter by the agent ID.
    - name: conditionId
      description: Filter by condition ID.
    - name: eventAt
      description: Filter event occurred time. ISO-8601 timestamp..
    - name: alertId
      description: Filter by alert ID.
    - name: matchedAt
      description: Filter by match detection time. ISO-8601 timestamp.
    - name: minId
      description: Filter that returns only records with an AlertId field value great
        than the minId value
    - name: reportedAt
      description: Filter by reported time. ISO-8601 timestamp.
    - name: IOCsource
      auto: PREDEFINED
      predefined:
      - "yes"
      description: Source of alert- indicator of compromise
    - name: EXDsource
      auto: PREDEFINED
      predefined:
      - "yes"
      description: Source of alert - exploit detection
    - name: MALsource
      auto: PREDEFINED
      predefined:
      - "yes"
      description: Source of alert - malware alert
    - name: minId
      description: Return only records with id greater than minId
    - name: limit
      description: Limit the results returned
    - name: sort
      auto: PREDEFINED
      predefined:
      - agentId
      - conditionId
      - eventAt
      - alertId
      - matchedAt
      - id
      - reportedAt
      description: Sorts the results by the specified field in ascending order.
    - name: sortOrder
      auto: PREDEFINED
      predefined:
      - ascending
      - descending
      description: The sort order for the results.
    outputs:
    - contextPath: FireEyeHX.Alerts._id
      description: FireEye alert ID.
    - contextPath: FireEyeHX.Alerts.agent._id
      description: FireEye agent ID.
    - contextPath: FireEyeHX.Alerts.agent.containment_state
      description: Host containment state.
    - contextPath: FireEyeHX.Alerts.condition._id
      description: The condition unique ID.
    - contextPath: FireEyeHX.Alerts.event_at
      description: Time when the event occoured.
    - contextPath: FireEyeHX.Alerts.matched_at
      description: Time when the event was matched.
    - contextPath: FireEyeHX.Alerts.reported_at
      description: Time when the event was reported.
    - contextPath: FireEyeHX.Alerts.source
      description: Source of alert.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts._id
      description: Source alert ID.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.appliance_id
      description: Appliance ID
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.meta
      description: Source alert meta.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.indicator_id
      description: Indicator ID.
    - contextPath: FireEyeHX.Alerts.resolution
      description: Alert resulotion.
    - contextPath: FireEyeHX.Alerts.event_type
      description: Event type.
    description: Get a list of alerts, use the different arguments to filter the results
      returned.
  - name: fireeye-hx-suppress-alert
    arguments:
    - name: alertId
      description: The alert id. The alert id is listed in the output of 'get-alerts'
        command.
    description: Suppress alert by ID
  - name: fireeye-hx-get-indicators
    arguments:
    - name: category
      description: The indicator category
    - name: searchTerm
      description: The searchTerm can be any name, category, signature, source, or
        condition value.
    - name: shareMode
      auto: PREDEFINED
      predefined:
      - any
      - restricted
      - unrestricted
      - visible
      description: Determines who can see the indicator. You must belong to the correct
        authorization group .
    - name: sort
      auto: PREDEFINED
      predefined:
      - category
      - activeSince
      - createdBy
      - alerted
      description: Sorts the results by the specified field in ascending  order
    - name: createdBy
      description: Person who created the indicator
    - name: alerted
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Whether the indicator resulted in alerts
    - name: limit
      description: Limit the number of results
    outputs:
    - contextPath: FireEyeHX.Indicators._id
      description: FireEye unique indicator ID.
    - contextPath: FireEyeHX.Indicators.name
      description: The indicator name as displayed in the UI.
    - contextPath: FireEyeHX.Indicators.description
      description: Indicator description.
    - contextPath: FireEyeHX.Indicators.category.name
      description: Catagory name.
    - contextPath: FireEyeHX.Indicators.created_by
      description: The "Created By" field as displayed in UI
    - contextPath: FireEyeHX.Indicators.active_since
      description: Date indicator became active.
    - contextPath: FireEyeHX.Indicators.stats.source_alerts
      description: Total number of source alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.stats.alerted_agents
      description: Total number of agents with HX alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.platforms
      description: List of families of operating systems.
    description: Get a list of indicators
  - name: fireeye-hx-get-indicator
    arguments:
    - name: category
      required: true
      description: Indicator category.
    - name: name
      required: true
      description: Indicator name.
    outputs:
    - contextPath: FireEyeHX.Indicators._id
      description: FireEye unique indicator ID.
    - contextPath: FireEyeHX.Indicators.name
      description: The indicator name as displayed in the UI.
    - contextPath: FireEyeHX.Indicators.description
      description: Indicator description.
    - contextPath: FireEyeHX.Indicators.category.name
      description: Catagory name.
    - contextPath: FireEyeHX.Indicators.created_by
      description: The "Created By" field as displayed in UI
    - contextPath: FireEyeHX.Indicators.active_since
      description: Date indicator became active.
    - contextPath: FireEyeHX.Indicators.stats.source_alerts
      description: Total number of source alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.stats.alerted_agents
      description: Total number of agents with HX alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.platforms
      description: List of families of operating systems.
    - contextPath: FireEyeHX.Conditions._id
      description: FireEye unique condition ID.
    - contextPath: FireEyeHX.Conditions.event_type
      description: Event type.
    - contextPath: FireEyeHX.Conditions.enabled
      description: Indicates whether the condition is enabled.
    description: Get a specific indicator details
  - name: fireeye-hx-get-host-information
    arguments:
    - name: agentId
      description: The agent ID. If the agent ID is not specified, the host Name must
        be specified.
    - name: hostName
      description: The host name. If the host name is not specified, the agent ID
        must be specified.
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
    description: Get information on a host associated with an agent.
  - name: fireeye-hx-get-alert
    arguments:
    - name: alertId
      required: true
      description: The alert ID.
    outputs:
    - contextPath: FireEyeHX.Alerts._id
      description: FireEye alert ID.
    - contextPath: FireEyeHX.Alerts.agent._id
      description: FireEye agent ID.
    - contextPath: FireEyeHX.Alerts.agent.containment_state
      description: Host containment state.
    - contextPath: FireEyeHX.Alerts.condition._id
      description: The condition unique ID.
    - contextPath: FireEyeHX.Alerts.event_at
      description: Time when the event occoured.
    - contextPath: FireEyeHX.Alerts.matched_at
      description: Time when the event was matched.
    - contextPath: FireEyeHX.Alerts.reported_at
      description: Time when the event was reported.
    - contextPath: FireEyeHX.Alerts.source
      description: Source of alert.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts._id
      description: Source alert ID.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.appliance_id
      description: Appliance ID
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.meta
      description: Source alert meta.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.indicator_id
      description: Indicator ID.
    - contextPath: FireEyeHX.Alerts.resolution
      description: Alert resulotion.
    - contextPath: FireEyeHX.Alerts.event_type
      description: Event type.
    description: Get details of a specific alert
  - name: fireeye-hx-file-acquisition
    arguments:
    - name: fileName
      required: true
      description: The file name.
    - name: filePath
      required: true
      description: The file path.
    - name: acquireUsing
      auto: PREDEFINED
      predefined:
      - API
      - RAW
      description: Whether to aqcuire the file using the API or RAW. By default, raw
        file will be acquired. Use API option when file is encrypted.
    - name: agentId
      description: The agent ID associated with the host that holds the file. If the
        hostName is not specified, the agentId must be specified.
    - name: hostName
      description: The host that holds the file. If the agentId is not specified,
        hostName must be specified.
    outputs:
    - contextPath: FireEyeHX.Acquisitions.Files._id
      description: The acquisition unique ID.
    - contextPath: FireEyeHX.Acquisitions.Files.state
      description: The acquisition state.
    - contextPath: FireEyeHX.Acquisitions.Files.md5
      description: File md5.
    - contextPath: FireEyeHX.Acquisitions.Files.req_filename
      description: The file name.
    - contextPath: FireEyeHX.Acquisitions.Files.req_path
      description: The file path.
    - contextPath: FireEyeHX.Acquisitions.Files.host._id
      description: FireEye HX agent ID.
    description: Aquire a specific file as a password protected zip file. The password
      for unlocking the zip file is 'unzip-me'.
  - name: fireeye-hx-delete-file-acquisition
    arguments:
    - name: acquisitionId
      required: true
      description: The acquisition ID.
    description: Delete the file acquisition, by ID.
  - name: fireeye-hx-data-acquisition
    arguments:
    - name: script
      description: Acquisition script in JSON format.
    - name: scriptName
      description: The script name. If the Acquisition script is specified, the script
        name must be specified as well.
    - name: defaultSystemScript
      auto: PREDEFINED
      predefined:
      - osx
      - win
      - linux
      description: Use default script. Select the host system.
    - name: agentId
      description: The agent ID. If the host name is not specified, the agent ID must
        be specified.
    - name: hostName
      description: The host name. If the agent ID is not specified, the host name
        must be specified.
    outputs:
    - contextPath: FireEyeHX.Acquisitions.Data._id
      description: The acquisition unique ID.
    - contextPath: FireEyeHX.Acquisitions.Data.state
      description: The acquisition state.
    - contextPath: FireEyeHX.Acquisitions.Data.md5
      description: File md5.
    - contextPath: FireEyeHX.Acquisitions.Data.host._id
      description: Time when the acquisition was finished.
    description: Start a data acquisition process to gather artifacts from the system
      disk and memory. The data is fetched as mans file.
  - name: fireeye-hx-delete-data-acquisition
    arguments:
    - name: acquisitionId
      required: true
      description: The acquisition ID.
    description: Delete data acquisition.
  - name: fireeye-hx-search
    arguments:
    - name: agentsIds
      description: IDs of agents to be searched
    - name: hostsNames
      description: Names of hosts to be searched
    - name: hostSet
      description: Id of host set to be searched
    - name: limit
      description: Limit results count (once limit is reached, the search is stopped)
    - name: exhaustive
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Should search be exhaustive or quick
      defaultValue: "yes"
    - name: ipAddress
      description: A valid IPv4 address to search for
    - name: ipAddressOperator
      auto: PREDEFINED
      predefined:
      - equals
      - not equals
      description: Which operator to apply to the given IP address
    - name: fileMD5Hash
      description: A 32-character MD5 hash value to search for
    - name: fileMD5HashOperator
      auto: PREDEFINED
      predefined:
      - equals
      - not equals
      description: Which operator to apply to the given MD5 hash
    - name: fileFullPath
      description: Full path of file to search
    - name: fileFullPathOperator
      auto: PREDEFINED
      predefined:
      - equals
      - not equals
      - contains
      - not contains
      description: Which operator to apply to the given file path
    - name: dnsHostname
      description: DNS value to search for
    - name: dnsHostnameOperator
      auto: PREDEFINED
      predefined:
      - equals
      - not equals
      - contains
      - not contains
      description: Which operator to apply to the given DNS
    - name: stopSearch
      auto: PREDEFINED
      predefined:
      - stopAndDelete
      - stop
      description: Method in which search should be stopped after finding <limit>
        number of results
    outputs:
    - contextPath: FireEyeHX.Search.Results.Timestamp - Modified
      description: Time when the entry was last modified
      type: string
    - contextPath: FireEyeHX.Search.Results.File Text Written
      description: The file text content
      type: string
    - contextPath: FireEyeHX.Search.Results.File Name
      description: Name of the file
      type: string
    - contextPath: FireEyeHX.Search.Results.File Full Path
      description: The full path of the file
      type: string
    - contextPath: FireEyeHX.Search.Results.File Bytes Written
      description: Number of bytes written to the file
      type: string
    - contextPath: FireEyeHX.Search.Results.Size in bytes
      description: Size of the file in bytes
      type: string
    - contextPath: FireEyeHX.Search.Results.Browser Version
      description: Version of the browser
      type: string
    - contextPath: FireEyeHX.Search.Results.Browser Name
      description: Name of the browser
      type: string
    - contextPath: FireEyeHX.Search.Results.Cookie Name
      description: Name of the cookie
      type: string
    - contextPath: FireEyeHX.Search.Results.DNS Hostname
      description: Name of the DNS host
      type: string
    - contextPath: FireEyeHX.Search.Results.URL
      description: The event URL
      type: string
    - contextPath: FireEyeHX.Search.Results.Username
      description: The event username
      type: string
    - contextPath: FireEyeHX.Search.Results.File MD5 Hash
      description: MD5 hash of the file
      type: string
    - contextPath: FireEyeHX.Search.HostID
      description: ID of the host
      type: string
    - contextPath: FireEyeHX.Search.HostName
      description: Name of host
      type: string
    - contextPath: FireEyeHX.Search.HostUrl
      description: Inner FireEye host url
      type: string
    - contextPath: FireEyeHX.Search.SearchID
      description: ID of performed search
      type: string
    - contextPath: FireEyeHX.Search.Results.Timestamp - Accessed
      description: Last accessed time
      type: string
    - contextPath: FireEyeHX.Search.Results.Port
      description: Port
      type: number
    - contextPath: FireEyeHX.Search.Results.Process ID
      description: ID of the process
      type: string
    - contextPath: FireEyeHX.Search.Results.Local IP Address
      description: Local IP Address
      type: string
    - contextPath: FireEyeHX.Search.Results.Local IP Address
      description: Local IP Address
      type: string
    - contextPath: FireEyeHX.Search.Results.Local Port
      description: Local Port
      type: number
    - contextPath: FireEyeHX.Search.Results.Username
      description: Username
      type: string
    - contextPath: FireEyeHX.Search.Results.Remote Port
      description: Remote Port
      type: number
    - contextPath: FireEyeHX.Search.Results.IP Address
      description: IP Address
      type: string
    - contextPath: FireEyeHX.Search.Results.Process Name
      description: Process Name
      type: string
    - contextPath: FireEyeHX.Search.Results.Timestamp - Event
      description: Timestamp - Event
      type: string
    - contextPath: FireEyeHX.Search.Results.type
      description: The type of the event
      type: string
    - contextPath: FireEyeHX.Search.Results.id
      description: ID of the result
      type: string
    description: Search endpoints to check all hosts or a subset of hosts for a specific
      file or indicator.
  - name: fireeye-hx-get-host-set-information
    arguments:
    - name: hostSetID
      description: ID of a specific host set to get
    - name: offset
      description: Specifies which record to start with in the response. The offset
        value must be an unsigned 32-bit integer. The default is 0.
    - name: limit
      description: Specifies how many records are returned. The limit value must be
        an unsigned 32-bit integer. The default is 50.
    - name: search
      description: Searches the names of all host sets connected to the specified
        HX appliance.
    - name: sort
      description: Sorts the results by the specified field in ascending or descending
        order. The default is sorting by name in ascending order. Sortable fields
        are _id (host set ID) and name (host set name).
    - name: name
      description: Specifies the name of host set to look for
    - name: type
      description: Specifies the type of host sets to search for
    outputs:
    - contextPath: FireEyeHX.HostSets._id
      description: host set id
      type: number
    - contextPath: FireEyeHX.HostSets._revision
      description: Revision number
      type: string
    - contextPath: FireEyeHX.HostSets.name
      description: Host set name
      type: string
    - contextPath: FireEyeHX.HostSets.type
      description: Host set type (static/dynamic/hidden)
      type: string
    - contextPath: FireEyeHX.HostSets.url
      description: Host set FireEye url
      type: string
    description: Get a list of all host sets known to your HX Series appliance
  - name: fireeye-hx-create-indicator
    arguments:
    - name: category
      required: true
      description: The indicator category
    outputs:
    - contextPath: FireEyeHX.Indicators.active_since
      description: Date indicator became active.
      type: date
    - contextPath: FireEyeHX.Indicators.meta
      description: Meta data for new indicator
      type: string
    - contextPath: FireEyeHX.Indicators.display_name
      description: The indicator display name
      type: string
    - contextPath: FireEyeHX.Indicators.name
      description: The indicator name as displayed in the UI.
      type: string
    - contextPath: FireEyeHX.Indicators.created_by
      description: The "Created By" field as displayed in UI
      type: string
    - contextPath: FireEyeHX.Indicators.url
      description: The data URL
      type: string
    - contextPath: FireEyeHX.Indicators.create_text
      description: The indicator create text
    - contextPath: FireEyeHX.Indicators.platforms
      description: List of families of operating systems.
      type: string
    - contextPath: FireEyeHX.Indicators.create_actor._id
      description: The ID of the actor
      type: number
    - contextPath: FireEyeHX.Indicators.create_actor.username
      description: Actor user name
      type: string
    - contextPath: FireEyeHX.Indicators.signature
      description: 'Signature of indicator '
      type: string
    - contextPath: FireEyeHX.Indicators._revision
      description: Indicator revision
      type: string
    - contextPath: FireEyeHX.Indicators._id
      description: FireEye unique indicator ID.
      type: string
    - contextPath: FireEyeHX.Indicator.description
      description: Indicator description
      type: string
    - contextPath: FireEyeHX.Indicators.category._id
      description: Category ID
      type: number
    - contextPath: FireEyeHX.Indicators.category.name
      description: Category name
      type: string
    - contextPath: FireEyeHX.Indicators.category.share_mode
      description: Category share mode
      type: string
    - contextPath: FireEyeHX.Indicators.category.uri_name
      description: Category uri name
      type: string
    - contextPath: FireEyeHX.Indicators.category.url
      description: Category URL
      type: string
    - contextPath: FireEyeHX.Indicators.uri_name
      description: The indicator uri name
      type: string
    - contextPath: FireEyeHX.Indicators.stats.active_conditions
      description: Indicator active conditions
      type: number
    - contextPath: FireEyeHX.Indicators.stats.alerted_agents
      description: Total number of agents with HX alerts associated with this indicator.
      type: number
    - contextPath: FireEyeHX.Indicators.stats.source_alerts
      description: Total number of source alerts associated with this indicator.
      type: number
    - contextPath: FireEyeHX.Indicators.update_actor._id
      description: Update actor ID
      type: number
    - contextPath: FireEyeHX.Indicators.update_actor.username
      description: Update actor name
      type: string
    description: Create new indicator
  - name: fireeye-hx-append-conditions
    arguments:
    - name: category
      required: true
      description: The indicator category
    - name: name
      required: true
      description: The name of the indicator
    - name: condition
      required: true
      description: 'A list of conditions to add. The list can include a list of IPv4
        addresses, MD5 files, and domain names. For example: example.netexample.orgexample.lol'
    description: 'Add conditions to an indicator. Conditions can be MD5, hash values,
      domain names and IP addresses. '
  isfetch: true
  runonce: false
tests:
  - FireEye HX Test