commonfields:
  id: PagerDuty v2
  version: -1
name: PagerDuty v2
display: PagerDuty v2
category: Messaging
image: data:image/png;base64,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
description: Alert and notify users using PagerDuty
configuration:
- display: API Key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Service Key (for triggering events only)
  name: ServiceKey
  defaultvalue: ""
  type: 0
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Initial Fetch Interval(In minutes, used only for first fetch or after Reset last run)
  name: FetchInterval
  defaultvalue: "1"
  type: 0
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import os
    import json
    import requests
    from datetime import datetime, timedelta

    ''' GLOBAL VARS '''
    # Pagerduty API works only with secured communication.
    USE_SSL = True

    API_KEY = demisto.params()['APIKey']
    SERVICE_KEY = demisto.params()['ServiceKey']
    FETCH_INTERVAL = demisto.params()['FetchInterval']

    SERVER_URL = 'https://api.pagerduty.com/'
    CREATE_EVENT_URL = 'https://events.pagerduty.com/v2/enqueue'

    DEFAULT_HEADERS = {
                          'Authorization': 'Token token=' + API_KEY,
                          'Accept': 'application/vnd.pagerduty+json;version=2'
                      }


    '''PARAMS'''
    UTC_PARAM = '&time_zone=UTC'
    STATUSES = 'statuses%5B%5D'
    INCLUDED_FIELDS = '&include%5B%5D=first_trigger_log_entries&include%5B%5D=assignments'

    '''SUFFIX ENDPOINTS'''
    GET_SCHEDULES_SUFFIX = 'schedules'
    CREATE_INCIDENT_SUFFIX = 'incidents'
    ON_CALL_BY_SCHEDULE_SUFFIX = 'schedules/{0}/users'
    ON_CALLS_USERS_SUFFIX = 'oncalls?include%5B%5D=users'
    USERS_NOTIFICATION_RULE = 'users/{0}/notification_rules'
    GET_INCIDENTS_SUFFIX = 'incidents?include%5B%5D=assignees'
    USERS_CONTACT_METHODS_SUFFIX = 'users/{0}/contact_methods'

    '''CONTACT_METHOD_TYPES'''
    SMS_CONTACT_TYPE = 'sms_contact_method'
    EMAIL_CONTACT_TYPE = 'email_contact_method'
    PHONE_CONTACT_TYPE = 'phone_contact_method'
    PUSH_CONTACT_TYPE = 'push_notification_contact_method'

    CONTACT_METHODS_TO_HUMAN_READABLE = {
        '': 'Unknown',
        SMS_CONTACT_TYPE: 'SMS',
        PUSH_CONTACT_TYPE: 'Push',
        EMAIL_CONTACT_TYPE: 'Email',
        PHONE_CONTACT_TYPE: 'Phone'
    }

    '''TABLE NAMES'''
    SCHEDULES = 'All Schedules'
    TRIGGER_EVENT = 'Trigger Event'
    RESOLVE_EVENT = 'Resolve Event'
    ACKNOLWEDGE_EVENT = 'Acknowledge Event'
    USERS_ON_CALL = 'Users On Call'
    INCIDETS = 'PagerDuty Incidents'
    CONTACT_METHODS = 'Contact Methods'
    USERS_ON_CALL_NOW = 'Users On Call Now'
    NOTIFICATION_RULES = 'User notification rules'

    '''TABLE HEADERS'''
    CONTACT_METHODS_HEADERS = ['ID', 'Type', 'Details']
    NOTIFICATION_RULES_HEADERS = ['ID', 'Type', 'Urgency', 'Notification timeout(minutes)']
    SCHEDULES_HEADERS = ['ID', 'Name', 'Today', 'Time Zone', 'Escalation Policy', 'Escalation Policy ID']
    USERS_ON_CALL_NOW_HEADERS = ['ID', 'Email', 'Name', 'Role', 'User Url', 'Time Zone']
    INCIDENTS_HEADERS = ['ID', 'Title', 'Description', 'Status', 'Created On', 'Urgency', 'Html Url', 'Assigned To User', 'Service ID', 'Service Name',
                         'Escalation Policy', 'Last Status Change On', 'Last Status Change By', 'Number Of Escalations', 'Resolved By User', 'Resolve Reason']

    ''' HELPER FUNCTIONS '''
    def http_request(method, url, params_dict=None, data=None):
        LOG('running %s request with url=%s\nparams=%s' % (method, url, json.dumps(params_dict)))

        try:
            res = requests.request(method,
                                   url,
                                   verify=USE_SSL,
                                   params=params_dict,
                                   headers=DEFAULT_HEADERS,
                                   data=data
                                  )
            res.raise_for_status()

            return res.json()

        except Exception as e:
            LOG(e)
            raise(e)

    def translate_severity(sev):
        if sev == 'high':
            return 3
        elif sev == 'Low':
            return 1
        return 0

    def test_module():
        try:
            get_on_call_now_users_command()
        except Exception as e:
            raise Exception(e.message)

        demisto.results('ok')

    def extract_on_call_user_data(users):
        """Extact data about user from a given schedule."""
        outputs = []
        contexts = []
        for user in users:
            output = {}
            context = {}

            output['ID'] = user.get('id')
            output['Name'] = user.get('name')
            output['Role'] = user.get('role')
            output['Email'] = user.get('email')
            output['Time Zone'] = user.get('time_zone')
            output['User Url'] = user.get('html_url')


            context['ID'] = output['ID']
            context['Role'] = output['Role']
            context['Email'] = output['Email']
            context['Username'] = output['Name']
            context['DisplayName'] = output['Name']
            context['TimeZone'] = output['Time Zone']

            outputs.append(output)
            contexts.append(context)

        return {
            'Type': entryTypes['note'],
            'Contents': users,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(USERS_ON_CALL, outputs, USERS_ON_CALL_NOW_HEADERS),
            'EntryContext': {
                'PagerDutyUser(val.ID==obj.ID)': contexts
            }
        }

    def extract_on_call_now_user_data(users_on_call_now):
        """Extract the user data from the oncalls json."""
        outputs = []
        contexts = []
        oncalls = users_on_call_now.get('oncalls', {})

        for i in xrange(len(oncalls)):
            output = {}
            context = {}

            data = oncalls[i]
            user = data.get('user')

            output['ID'] = user.get('id')
            output['Name'] = user.get('name')
            output['Role'] = user.get('role')
            output['Email'] = user.get('email')
            output['User Url'] = user.get('html_url')
            output['Time Zone'] = user.get('time_zone')

            context['ID'] = output['ID']
            context['Role'] = output['Role']
            context['Email'] = output['Email']
            context['Username'] = output['Name']
            context['DisplayName'] = output['Name']
            context['TimeZone'] = output['Time Zone']

            escal_level = data.get('escalation_level', 1)
            outputs.insert(escal_level - 1, output)
            contexts.insert(escal_level - 1, context)

        return {
            'Type': entryTypes['note'],
            'Contents': users_on_call_now,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(USERS_ON_CALL_NOW, outputs, USERS_ON_CALL_NOW_HEADERS),
            'EntryContext': {
                'PagerDutyUser(val.ID==obj.ID)': contexts
            }
        }

    def parse_incident_data(incidents):
        """Parse incident data to output,context format"""
        outputs = []
        contexts = []
        raw_response = []
        for i, incident in enumerate(incidents):
            output = {}
            context = {}

            context['ID'] = output['ID'] = incident.get('id')
            context['Title'] = output['Title'] = incident.get('summary')
            context['Description'] = output['Description'] = incident.get('first_trigger_log_entry', {}).get('channel', {}).get('details', '')
            context['Status'] = output['Status'] = incident.get('status')
            context['created_at'] = output['Created On'] = incident.get('created_at')
            context['urgency'] = output['Urgency'] = incident.get('urgency', '')
            output['Html Url'] = incident.get('html_url')

            if len(incident.get('assignments', [])) > 0:
                output['Assigned To User'] = incident['assignments'][0].get('assignee', {}).get('name')
            else:
                output['Assigned To User'] = '-'

            context['assignee'] = output['Assigned To User']

            context['service_id'] = output['Service ID'] = incident.get('service', {}).get('id')
            context['service_name'] = output['Service Name'] = incident.get('service', {}).get('summary')

            context['escalation_policy'] = output['Escalation Policy'] = incident.get('escalation_policy', {}).get('summary')

            context['last_status_change_at'] = output['Last Status Change On'] = incident.get('last_status_change_at')
            context['last_status_change_by'] = output['Last Status Change By'] = incident.get('last_status_change_by', {}).get('summary')

            context['number_of_escalations'] = output['Number Of Escalations'] = incident.get('number_of_escalations')

            if output['Status'] == 'resolved':
                output['Resolved By User'] = output['Last Status Change By']
            else:
                output['Resolved By User'] = '-'

            context['resolved_by'] = output['Assigned To User']
            context['resolve_reason'] = output['Resolve reason'] = incident.get('resolve_reason', '')

            context['teams'] = []
            for team in incident.get('teams', []):
                team_id = team.get('id', '')
                team_name = team.get('summary', '')

                team_data = {
                    "ID": team_id,
                    "Name": team_name
                }

                context['teams'].append(team_data)

            assignment = incident.get('assignments', [{},])
            if len(assignment) > 0:
                context['assignment'] = {
                    "time": assignment[0].get('at', ''),
                    "assignee":assignment[0].get('assignee', {}).get('summary', ''),
                }
            else:
                context['assignment'] = {}

            acknowledgements = incident.get('acknowledgements', [{},])
            if len(acknowledgements) > 0:
                context['acknowledgement'] = {
                    "time": assignment[0].get('at', ''),
                    "acknowledger":assignment[0].get('acknowledger', {}).get('summary', ''),
                }
            else:
                context['acknowledgement'] = {}

            outputs.append(output)
            contexts.append(context)
            raw_response.append(incident)

        return outputs, contexts, raw_response

    def extract_incidents_data(incidents):
        """Extact data about incidents."""
        outputs, contexts, _ = parse_incident_data(incidents)

        return {
            'Type': entryTypes['note'],
            'Contents': incidents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(INCIDETS, outputs, INCIDENTS_HEADERS),
            'EntryContext': {
                'PagerDuty.Incidents(val.ID==obj.ID)': contexts
            }
        }

    def extract_all_schedules_data(schedules):
        """Extract the data about all the schedules."""
        outputs = []
        contexts = []
        for i in range(len(schedules)):
            output = {}
            context = {}
            data = schedules[i]

            output['ID'] = data.get('id')
            output['Name'] = data.get('name')
            output['Time Zone'] = data.get('time_zone')
            output['Today'] = datetime.today().strftime('%Y-%m-%d')
            escalation_policies = data.get('escalation_policies', [])
            if len(escalation_policies) > 0:
                output['Escalation Policy ID'] = escalation_policies[0].get('id')
                output['Escalation Policy'] = escalation_policies[0].get('summary')

                context['escalation_policies'] = [{}, ]
                context['escalation_policies'][0]['name'] = output['Escalation Policy']
                context['escalation_policies'][0]['id'] = output['Escalation Policy ID']
            else:
                output['Escalation Policy'] = '-'
                output['Escalation Policy ID'] = '-'

            context['id'] = output['ID']
            context['name'] = output['Name']
            context['today'] = output['Today']
            context['time_zone'] = output['Time Zone']

            outputs.append(output)
            contexts.append(context)

        return {
            'Type': entryTypes['note'],
            'Contents': schedules,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(SCHEDULES, outputs, SCHEDULES_HEADERS),
            'EntryContext': {
                'PagerDuty.Schedules(val.id==obj.id)': contexts,
            }
        }

    def create_new_incident(source, summary, severity, action, description='No description', group='', event_class='', component='', incident_key=None, service_key=SERVICE_KEY):
        """Create a new incident in the PagerDuty instance."""
        payload = {
                        'routing_key': service_key,
                        'event_action': action,
                        'dedup_key': incident_key,
                        'images': [],
                        'links': [],
                        'payload': {
                            'summary': summary,
                            'source': source,
                            'severity': severity,
                            'group': group,
                            'class': event_class,
                            'component': component,
                            'custom_details': {
                                'description': description
                            }
                        }
                  }

        return http_request('POST', CREATE_EVENT_URL, data=json.dumps(payload))

    def resolve_or_ack_incident(action, incident_key, service_key=SERVICE_KEY):
        """Resolve or Acknowledge an incident in the PagerDuty instance."""
        payload = {
                        'routing_key': service_key,
                        'event_action': action,
                        'dedup_key': incident_key
                  }

        return http_request('POST', CREATE_EVENT_URL, data=json.dumps(payload))

    def extract_new_event_data(table_name, response):
        """Extract the data from the response of creating a new command."""
        output = {}
        context = {}

        output['Status'] = response.get('status', '')
        output['Message'] = response.get('message', '')
        output['Incident key'] = response.get('dedup_key', '')

        context['Status'] = output['Status']
        context['Message'] = output['Message']
        context['incident_key'] = output['Incident key']

        return {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(table_name, output),
            'EntryContext': {
                'PagerDuty.Event(val.incident_key==obj.dedup_key)': context,
                'Event.ID(val.ID==obj.dedup_key)': context['incident_key']
            }
        }

    def extract_users_contact_methods(user_contact_methods):
        """Extract all the contact methods of a given user."""
        outputs = []
        contexts = []
        contact_methods = user_contact_methods.get('contact_methods')
        for contact_method in contact_methods:
            output = {}

            output['ID'] = contact_method.get('id')
            output['Type'] = CONTACT_METHODS_TO_HUMAN_READABLE[contact_method.get('type', '')]

            country_code = str(contact_method.get('country_code' ,''))
            address = contact_method.get('address', '')
            output['Details'] = country_code + address

            outputs.append(output)

            del contact_method['address']
            if output['Type'] == 'SMS' or output['Type'] == 'Phone':
                del contact_method['country_code']
                contact_method['phone'] = output['Details']
            else:
                contact_method['email'] = output['Details']

            contexts.append(contact_method)

        return {
            'Type': entryTypes['note'],
            'Contents': user_contact_methods,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(CONTACT_METHODS, outputs, CONTACT_METHODS_HEADERS),
            'EntryContext': {
                'PagerDuty.Contact_methods(val.id==obj.id)': contexts,
            }
        }

    def extract_users_notification_role(user_notication_role):
        """Extract the notification role of a given user."""
        outputs = []
        notification_rules = user_notication_role.get('notification_rules')
        for notification_rule in notification_rules:
            output = {}

            output['ID'] = notification_rule.get('id')
            output['Type'] = notification_rule.get('type', '')
            output['Urgency'] = notification_rule.get('urgency')
            output['Notification timeout(minutes)'] = notification_rule.get('start_delay_in_minutes')

            outputs.append(output)

        return {
            'Type': entryTypes['note'],
            'Contents': user_notication_role,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(NOTIFICATION_RULES, outputs, NOTIFICATION_RULES_HEADERS),
            'EntryContext': {
                'PagerDuty.Notification_rules(val.id==obj.id)': notification_rules,
            }
        }

    '''COMMANDS'''

    def fetch_incidents():
        param_dict = {}
        now_time = datetime.utcnow()
        now = datetime.isoformat(now_time)
        lastRunObject = demisto.getLastRun()
        if lastRunObject:
            param_dict['since'] = lastRunObject['time']
        else:
            param_dict['since'] = datetime.isoformat(now_time - timedelta(minutes=int(FETCH_INTERVAL)))

        param_dict['until'] = now

        url = SERVER_URL + GET_INCIDENTS_SUFFIX + configure_status()
        res = http_request('GET', url, param_dict)
        _, parsed_incidents, raw_responses = parse_incident_data(res.get('incidents',[]))

        incidents = []
        for incident, raw_response in zip(parsed_incidents, raw_responses):
            incidents.append({
                'name': incident['ID'] + ' - ' + incident['Title'],
                'occurred': incident['created_at'],
                'severity': translate_severity(incident['urgency']),
                'rawJSON': json.dumps(raw_response)
            })

        demisto.incidents(incidents)
        demisto.setLastRun({'time': now})


    def configure_status(status='triggered,acknowledged'):
        statuses = status.split(',')
        statuses_string = "&" + STATUSES + '='
        statuses = statuses_string.join(statuses)
        status_request = '&' + STATUSES + '=' + statuses

        status_request = status_request + INCLUDED_FIELDS + UTC_PARAM
        return status_request


    def get_incidents_command(since=None, until=None, status='triggered,acknowledged', sortBy=None):
        """Get incidents command."""
        param_dict = {}
        if since is not None:
            param_dict['since'] = since
        if until is not None:
            param_dict['until'] = until
        if sortBy is not None:
            param_dict['sortBy'] = sortBy

        url = SERVER_URL + GET_INCIDENTS_SUFFIX + configure_status(status)
        res = http_request('GET', url, param_dict)
        return extract_incidents_data(res.get('incidents',[]))

    def submit_event_command(source, summary, severity, action, description='No description', group='', event_class='', component='', incident_key=None, serviceKey=SERVICE_KEY):
        """Create new event."""
        if serviceKey is None:
            raise Exception('You must enter a ServiceKey at the integration parmaters or in the command to process this action.')

        res = create_new_incident(source, summary, severity, action, description, group, event_class, component, incident_key, serviceKey)
        return extract_new_event_data(TRIGGER_EVENT, res)

    def get_all_schedules_command(query=None, limit=None):
        """Get all the schedules."""
        param_dict = {}
        if query is not None:
            param_dict['query'] = query
        if limit is not None:
            param_dict['limit'] = limit

        url = SERVER_URL + GET_SCHEDULES_SUFFIX
        res = http_request('GET', url, param_dict)
        schedules = res.get('schedules', [])
        return extract_all_schedules_data(schedules)

    def get_on_call_users_command(scheduleID, since=None, until=None):
        """Get the list of user on call in a from scheduleID"""
        param_dict = {}
        if since is not None:
            param_dict['since'] = since
        if until is not None:
            param_dict['until'] = until


        url = SERVER_URL + ON_CALL_BY_SCHEDULE_SUFFIX.format(scheduleID)
        users_on_call = http_request('GET', url, param_dict)
        return extract_on_call_user_data(users_on_call.get('users', []))

    def get_on_call_now_users_command(limit=None):
        """Get the list of users that are on call now."""
        param_dict = {}
        if limit is not None:
            param_dict['limit'] = limit

        url = SERVER_URL + ON_CALLS_USERS_SUFFIX
        users_on_call_now = http_request('GET', url, param_dict)
        return extract_on_call_now_user_data(users_on_call_now)

    def get_users_contact_methods_command(UserID):
        """Get the contact methods of a given user."""
        url = SERVER_URL + USERS_CONTACT_METHODS_SUFFIX.format(UserID)
        user_contact_methods = http_request('GET', url, {})
        return extract_users_contact_methods(user_contact_methods)

    def get_users_notification_command(UserID):
        """Get the notification rule of a given user"""
        url = SERVER_URL + USERS_NOTIFICATION_RULE.format(UserID)
        user_notication_role = http_request('GET', url, {})
        return extract_users_notification_role(user_notication_role)


    def resolve_event(incident_key=None, serviceKey=SERVICE_KEY):
        if serviceKey is None:
            raise Exception('You must enter a ServiceKey at the integration parmaters or in the command to process this action.')

        action_response = resolve_or_ack_incident('resolve', incident_key, serviceKey)

        res = http_request('GET', SERVER_URL + GET_INCIDENTS_SUFFIX, {'incident_key': incident_key})
        _, contexts, _ = parse_incident_data(res.get('incidents',[]))
        if contexts[0]['Status'] != "resolved":
            raise Exception('Could not resolve incident, you may have created it with different Service Key')

        return extract_new_event_data(RESOLVE_EVENT, action_response)


    def acknowledge_event(incident_key=None, serviceKey=SERVICE_KEY):
        if serviceKey is None:
            raise Exception('You must enter a ServiceKey at the integration parmaters or in the command to process this action.')

        action_response = resolve_or_ack_incident('acknowledge', incident_key, serviceKey)

        res = http_request('GET', SERVER_URL + GET_INCIDENTS_SUFFIX, {'incident_key': incident_key})
        _, contexts, _ = parse_incident_data(res.get('incidents',[]))
        if contexts[0]['Status'] != "acknowledged":
            raise Exception('Could not acknowledge incident, you may have created it with different Service Key')

        return extract_new_event_data(ACKNOLWEDGE_EVENT, action_response)


    ''' EXECUTION CODE '''

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            test_module()
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() == 'PagerDuty-incidents':
            demisto.results(get_incidents_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-submit-event':
            demisto.results(submit_event_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-users-on-call':
            demisto.results(get_on_call_users_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-all-schedules':
            demisto.results(get_all_schedules_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-users-on-call-now':
            demisto.results(get_on_call_now_users_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-contact-methods':
            demisto.results(get_users_contact_methods_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-get-users-notification':
            demisto.results(get_users_notification_command(**demisto.args()))
        elif demisto.command() == 'PagerDuty-resolve-event':
            demisto.results(resolve_event(**demisto.args()))
        elif demisto.command() == 'PagerDuty-acknowledge-event':
            demisto.results(acknowledge_event(**demisto.args()))


    except Exception as e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
  commands:
  - name: PagerDuty-get-all-schedules
    arguments:
    - name: query
      description: Show only the schedules whose name matches the query
    - name: limit
      description: The limit for the amount of schedules to receive(Default is 25,
        max value is 100)
    outputs:
    - contextPath: PagerDuty.Schedules.id
      description: The ID of the schedule
      type: string
    - contextPath: PagerDuty.Schedules.name
      description: The name of the schedule
      type: string
    description: Receive all schedules from PagerDuty
  - name: PagerDuty-get-users-on-call
    arguments:
    - name: scheduleID
      required: true
      default: true
      description: (default and mandatory) The unique identifier of the schdule
    - name: since
      description: The start of the date range Using ISO 8601 Representation. E.g.
        !PagerDutyGetUsersOnCall since=2011-05-06T17:00Z
    - name: until
      description: The end of the date range
    outputs:
    - contextPath: PagerDutyUser.id
      description: User's ID
      type: string
    - contextPath: PagerDutyUser.Emails
      description: Email of user
      type: string
    - contextPath: PagerDutyUser.Username
      description: Username of person
      type: string
    - contextPath: PagerDutyUser.DisplayName
      description: Display name of person
      type: string
    - contextPath: PagerDutyUser.Role
      description: Display role of person
      type: string
    - contextPath: PagerDutyUser.TimeZone
      description: The time zone of the user
      type: string
    description: Returns the names and details of on call users at a certain time
      or by specific schedule
  - name: PagerDuty-get-users-on-call-now
    arguments:
    - name: limit
      description: The limit for the amount of users to receive(Default is 25, max
        value is 100)
    outputs:
    - contextPath: PagerDutyUser.ID
      description: User's ID
      type: string
    - contextPath: PagerDutyUser.Email
      description: Email of user
      type: string
    - contextPath: PagerDutyUser.Username
      description: Username of person
      type: string
    - contextPath: PagerDutyUser.DisplayName
      description: Display name of person
      type: string
    - contextPath: PagerDutyUser.Role
      description: Role of person
      type: string
    - contextPath: PagerDutyUser.TimeZone
      description: The time zone of the user
      type: string
    description: Returns the names and details of current on call personnel
  - name: PagerDuty-incidents
    arguments:
    - name: status
      auto: PREDEFINED
      predefined:
      - triggered
      - acknowledged
      - resolved
      description: Returns only the incidents currently in the passed status(es).
        Valid status options are triggered,acknowledged, and resolved. (Default values
        are triggered,acknowledged)
    - name: since
      description: Beginning date and time. Using ISO 8601 Representation. E.g. PagerDutyIncidents
        since=2011-05-06T17:00Z (must be used with until argument)
    - name: sortBy
      description: Used to specify both the field you wish to sort the results on,
        as well as the direction (ascending/descending) of the results.See more https://v2.developer.pagerduty.com/v2/page/api-reference#!/Incidents/get_incidents
    - name: until
      description: Last date and time.  Using ISO 8601 Representation. E.g. PagerDutyIncidents
        until=2016-05-06T13:00Z
    outputs:
    - contextPath: PagerDuty.Incidents.ID
      description: Incident ID
      type: string
    - contextPath: PagerDuty.Incidents.Title
      description: The title of the incident
      type: string
    - contextPath: PagerDuty.Incidents.Status
      description: Incident Status
      type: string
    - contextPath: PagerDuty.Incidents.created_at
      description: Time in which the incident was created
      type: date
    - contextPath: PagerDuty.Incidents.urgency
      description: Incident Urgency
      type: string
    - contextPath: PagerDuty.Incidents.assignee
      description: 'The assignee of the incident '
      type: string
    - contextPath: PagerDuty.Incidents.service_id
      description: The id of the impacted service
      type: string
    - contextPath: PagerDuty.Incidents.service_name
      description: The name of the impacted service
      type: string
    - contextPath: PagerDuty.Incidents.escalation_policy
      description: The escalation policy
      type: string
    - contextPath: PagerDuty.Incidents.last_status_change_at
      description: Time in which the last status change occurred
      type: date
    - contextPath: PagerDuty.Incidents.last_status_change_by
      description: Name of the user who done the last status change
      type: string
    - contextPath: PagerDuty.Incidents.number_of_escalations
      description: Number of escalations that took place
      type: number
    - contextPath: PagerDuty.Incidents.resolved_by
      description: Name of the User who resolved the incident
      type: string
    - contextPath: PagerDuty.Incidents.resolve_reason
      description: The reason for resolving the issue
      type: string
    - contextPath: PagerDuty.Incidents.Description
      description: The Description of the incident
      type: string
    - contextPath: PagerDuty.Incidents.teams.ID
      description: The ID of the team assigned for the incident.
      type: string
    - contextPath: PagerDuty.Incidents.teams.ID
      description: The name of the team assigned for the incident.
      type: string
    - contextPath: PagerDuty.Incidents.assignment.time
      description: The time of the assignment to the incident
      type: date
    - contextPath: PagerDuty.Incidents.assignment.assignee
      description: The name of the assignee to the incident
      type: string
    - contextPath: PagerDuty.Incidents.acknowledgement.time
      description: The time of the acknowledgement to the incident
      type: date
    - contextPath: PagerDuty.Incidents.acknowledgement.acknowledger
      description: The name of the acknowledger to the incident
      type: string
    description: Shows incidents in PagerDuty. Default status parameters are triggered,acknowledged
  - name: PagerDuty-submit-event
    arguments:
    - name: source
      required: true
      description: Specific human-readable unique identifier, such as a hostname,
        for the system having the problem.
    - name: summary
      required: true
      description: "\t A high-level, text summary message of the event. Will be used
        to construct an alert's description."
    - name: severity
      required: true
      auto: PREDEFINED
      predefined:
      - critical
      - error
      - warning
      - info
      description: The severity of the event
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - trigger
      - acknowledge
      - resolve
      description: The action to be executed
    - name: description
      description: A short description of the problem
    - name: group
      description: 'A cluster or grouping of sources. For example, sources “prod-datapipe-02”
        and “prod-datapipe-03” might both be part of “prod-datapipe”. Example: "prod-datapipe"
        "www"'
    - name: event_class
      description: 'The class/type of the event. Example: "High CPU" "Latency"'
    - name: component
      description: 'The part or component of the affected system that is broken. Example:
        "keepalive" "webping"'
    - name: incident_key
      description: Incident key, used to acknowledge/resolve specific event
    - name: serviceKey
      description: Service key for the integration
    outputs:
    - contextPath: PagerDuty.Event.Status
      description: Status of the action on the event
      type: string
    - contextPath: PagerDuty.Event.incident_key
      description: Incident key
      type: string
    description: Creates a new event/incident in PagerDuty(In order to use this command
      you have to enter the Service Key in the integration settings)
  - name: PagerDuty-get-contact-methods
    arguments:
    - name: UserID
      required: true
      description: 'ID of the wanted user '
    outputs:
    - contextPath: PagerDuty.Contact_methods.phone
      description: The phone number of the user
      type: string
    - contextPath: PagerDuty.Contact_methods.id
      description: ID of the contact method
      type: string
    - contextPath: PagerDuty.Contact_methods.type
      description: The type of the current contact method
      type: string
    - contextPath: PagerDuty.Contact_methods.email
      description: The email of the user
      type: string
    description: Get the contact methods of a given user
  - name: PagerDuty-get-users-notification
    arguments:
    - name: UserID
      required: true
      description: ID of the wanted user
    outputs:
    - contextPath: PagerDuty.Notification_rules.start_delay_in_minutes
      description: The delay time for notifying the user
      type: string
    - contextPath: PagerDuty.Notification_rules.urgency
      description: The urgency of the notification
      type: string
    - contextPath: PagerDuty.Notification_rules.id
      description: The id of the notification rule
      type: string
    description: Get the users notification rules
  - name: PagerDuty-resolve-event
    arguments:
    - name: incident_key
      required: true
      description: Incident key
    - name: serviceKey
      required: true
      description: Service key for the integration
    outputs:
    - contextPath: PagerDuty.Event.Status
      description: Status of the action on the event
      type: string
    - contextPath: PagerDuty.Event.incident_key
      description: Incident key
      type: string
    description: Resolves an existing event in PagerDuty
  - name: PagerDuty-acknowledge-event
    arguments:
    - name: incident_key
      required: true
      description: Incident key
    - name: serviceKey
      required: true
      description: Service key for the integration
    outputs:
    - contextPath: PagerDuty.Event.Status
      description: Status of the action on the event
      type: string
    - contextPath: PagerDuty.Event.incident_key
      description: Incident key
      type: string
    description: Acknowledges an existing event in PagerDuty
  isfetch: true
  runonce: false
tests:
- PagerDuty Test
