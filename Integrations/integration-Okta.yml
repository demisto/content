commonfields:
  id: okta
  version: -1
name: okta
display: okta
category: Authentication
image: data:image/png;base64,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
description: Integration with Okta's cloud-based identity management service
detaileddescription: |-
  To get an API token go to the following URL:
  http://developer.okta.com/docs/api/getting_started/getting_a_token.html
configuration:
- display: okta URL https://<domain.okta.com>
  name: url
  defaultvalue: ""
  type: 0
  required: true
- display: API Token
  name: apitoken
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    function fixUrl(base) {
        var res = base;
        if (base && base[base.length - 1] !== '/') {
            res = res + '/';
        }
        return res;
    }

    var PROFILE_ARGS = [
        'firstName',
        'lastName',
        'email',
        'login',
        'secondEmail',
        'middleName',
        'honorificPrefix',
        'honorificSuffix',
        'title',
        'displayName',
        'nickName',
        'profileUrl',
        'primaryPhone',
        'mobilePhone',
        'streetAddress',
        'city',
        'state',
        'zipCode',
        'countryCode',
        'postalAddress',
        'preferredLanguage',
        'locale',
        'timezone',
        'userType',
        'employeeNumber',
        'costCenter',
        'organization',
        'division',
        'department',
        'managerId',
        'manager'
    ];

    var API_POSTFIX = 'api/v1/'
    var SERVER_URL = fixUrl(params.url) + API_POSTFIX;
    var DEFAULT_SEARCH_LIMIT = 200;
    var CLIENT_USERAGENT = 'Demisto/1.0'

    function createReadableLog(log){
        var logObject = {};

        var time  = new Date(log.published);
        logObject.Time = time.toLocaleString();
        logObject.Actor = log.actor.displayName + ' (' + log.actor.type + ')';
        logObject.ActorAlternateId = log.actor.alternateId;
        logObject.EventInfo = log.displayMessage;
        logObject.EventOutcome = log.outcome.result + (log.outcome.reason ? ': ' + log.outcome.reason : '');
        logObject.EventSeverity = log.severity;
        logObject.Client = '';
        if(log.client.userAgent){
            var browser = log.client.userAgent.browser;
            var os = log.client.userAgent.os;
            logObject.Client += (browser && browser.toLowerCase() !== 'unknown' ? browser : 'Unknown browser') + ' on ';
            logObject.Client += (os && os.toLowerCase() !== 'unknown' ? os : 'Unknown OS') + ' ';
        }
        if(log.client.device){
            logObject.Client += log.client.device.toLowerCase() !== 'unknown' ? log.client.device : 'Unknown device';
        }
        logObject.RequestIP = log.client.ipAddress;
        logObject.ChainIP = dq(log.request.ipChain, 'ip');

        var targets = '';
        if(log.target){
            log.target.forEach(function(target){
                targets += target.displayName + ' (' + target.type + ')\n';
            });
        }

        logObject.Targets = targets || '-';

        return logObject;
    }

    function getPagedResults(path, queryParams){
        var results = [];

        do {
            var resObject = sendRequest(path, 'GET', queryParams, '', true);
            results = results.concat(resObject.body);
            var link = resObject.link;

            if(!link || link.length < 2 || queryParams.limit){
                // No next page or limit is specified
                break;
            }
            else{
                // Get the next page for the results
                var afterPattern = /\bafter=(.*)>/;
                var linkMatch = link[1].match(afterPattern);
                if(!linkMatch){
                    break;
                }

                queryParams['after'] = linkMatch[1];
            }

        } while(resObject.body.length > 0)

        return results;
    }

    function buildProfile(args) {
        var profile = {};
        var keys = Object.keys(args);
        for (var i = 0 ; i < PROFILE_ARGS.length; i++) {
            if (args[PROFILE_ARGS[i]]) {
                profile[PROFILE_ARGS[i]] = args[PROFILE_ARGS[i]];
            }
        }
        return profile;
    }

    function buildCredentials(args) {
        var creds = {};
        if (args.password) {
            var  pswd = { value: args.password };
            creds.password = pswd;
        }
        if (args.passwordQuestion || args.passwordAnswer) {
            var recovery = {
                question: args.passwordQuestion,
                answer: args.passwordAnswer
            };
            creds.recovery_question = recovery;
        }
        if (args.providerName || args.providerType) {
            var provider = {
                name: args.providerName,
                type: args.providerType
            };
            creds.provider = provider;
        }
        return creds;
    }

    function identLevel(count) {
        var ret='';
        for (var i=0;i<count;i++) {
            ret += '     ';
        }
        return ret;
    }

    function flattenValue(value, level, isArray) {
        if (!level) {
            level=0;
        }
        if (!value || value === '') {
            return '<br>';
        } else if (typeof value === 'string') {
            return value + '<br>';
        } else {
            var ret = (level>0) ? (identLevel(level-1) + (isArray ? '' : '{') + ' <br>') : '';
            for (var key in value) {
                ret += identLevel(level) + (isArray ? '' : key + ': ') + flattenValue(value[key],level+1,isArray);
            }
            return (level>0) ? (ret + identLevel(level-1) + (isArray ? '' : '}') + '<br>') : ret;
        }

    }

    function profileToMd(profile) {
        var head = '|';
        var line = '|';
        var data = '|';

        for (var key in profile) {
            head += key + '|';
            line += '-|';
            data += profile[key] + '|';
        }
        return head + '\n' + line + '\n' + data + '\n';
    }

    function usersToMarkdown(users, verbose) {
        var md='';

        if (!Array.isArray(users)) {
            users = [users] ;
        }

        var user;
        if (verbose==='true') {
            for (var i=0;i<users.length;i++) {
                user=users[i];
                md += '### User: ' + user.profile.login +'\n';
                md += '#### Profile:\n';
                md += profileToMd(user.profile);
                md += '#### Additional data:\n';
                md += 'Key|Value\n-|-\n';
                for (var key in user) {
                    if (key !== 'profile') {
                        md += key+'|'+flattenValue(user[key]) + '\n';
                    }
                }
            }
        } else {
            md += 'ID|Login|First Name|Last Name|Mobile Phone|Last Login|Status\n-|-|-|-|-|-|-\n';
            for (var i=0;i<users.length;i++) {
                user = users[i];
                md += user.id + '|';
                md += user.profile.login + '|';
                md += user.profile.firstName+'|';
                md += user.profile.lastName+'|';
                md += user.profile.mobilePhone+'|';
                md += user.lastLogin+'|';
                md += user.status+'\n';
            }
        }
        return md;
    }

    function usersToEntryContext(users) {
        var ec={};
        ec.Account = [];
        if (!Array.isArray(users)) {
            users = [users] ;
        }
        for (var i=0;i<users.length;i++) {
            var user=users[i];
            var ecItem={id:user.id, ID:user.id,Type:'Okta'};
            if (user.profile.firstName || user.profile.lastName) {
                var displayName='';
                displayName += (user.profile.firstName)? user.profile.firstName + ' ' : '';
                displayName += (user.profile.lastName)? user.profile.lastName : '';
                ecItem.DisplayName = displayName.trim();
            }
            if (user.profile.email) {
                ecItem.Email = user.profile.email;
            }
            if (user.profile.login) {
                ecItem.Username = user.profile.login;
            }
            if (user.objectClass) {
                ecItem.Groups = user.objectClass;
            }
            if (user.group){
                ecItem.Group = user.group;
            }
            ec.Account.push(ecItem);
        }
        return ec;
    }


    function sendRequest(path, method, queryParams, body, pagination){
        var url = SERVER_URL.concat(path);
        var query = '';
        if(queryParams){
            query = encodeToURLQuery(queryParams);
        }

        url = url.concat(query);

        // backward compatibility
        if(params.proxy){
            if(params.proxy === 'true'){
                params.proxy = true;
            }
            else if(params.proxy === 'false'){
                params.proxy = false;
            }
        }

        var res = http(
            url,
            {
                Method: method ? method : 'GET',
                Headers: {
                    'User-Agent': [CLIENT_USERAGENT],
                    Authorization: ['SSWS ' + params.apitoken],
                    Accept: ['application/json'],
                    'Content-Type': ['application/json']
                },
                Body: body ? JSON.stringify(body) : body
            },
            params.insecure,
            params.proxy
        );
        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Failed on request ' + url + ' , request status code: ' + res.StatusCode + ' and Body: ' + res.Body + '.';
        }

        if(pagination){
            return {
                body: JSON.parse(res.Body),
                link: res.Headers['Link']
            };
        }

        if(!(res.Body)){
            return '';
        }

        return JSON.parse(res.Body);
    }

    function getUserId(username){
        var uri = 'users?filter=' + encodeURIComponent('profile.login eq "' + username + '"');
        var res = sendRequest(uri);
        if (res && res.length && res.length === 1) {
            return res[0].id;
        } else {
            throw 'Unable to find userId ' + username + '\n' + JSON.stringify(res);
        }
    }

    function getGroupId(groupName){
        var group = listGroups(groupName);
        if(!group){
            throw 'Unable to find group ' + groupName + '\n' + JSON.stringify(group);
        }

        return group[0].id;
    }

    function suspendUserCommand(){
        var userId = getUserId(args.username);

        var res = suspendUser(userId);

        var md = '### Okta user suspended: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function suspendUser(userId){
        var uri = 'users/' + userId + '/lifecycle/suspend';

        return sendRequest(uri, 'POST');
    }

    function unSuspendUser(userId){
        var uri = 'users/' + userId + '/lifecycle/unsuspend';

        return sendRequest(uri, 'POST');
    }

    function unSuspendUserCommand(){
        var userId = getUserId(args.username);

        var res = unSuspendUser(userId);

        var md = '### Okta user unsuspended: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }


    function unlockUserCommand(){
        var userId = getUserId(args.username);

        var res = unlockUser(userId);

        var md = '### Okta user unlocked: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function unlockUser(userId){
        var uri = 'users/' + userId + '/lifecycle/unlock';
        return sendRequest(uri, 'POST');
    }

    function deactivateUserCommand() {
        var userId = getUserId(args.username);

        var res = deactivateUser(userId);

        var md = '### Okta user deactivated: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function deactivateUser(userId){
        var uri = 'users/' + userId + '/lifecycle/deactivate';

        return sendRequest(uri, 'POST');
    }

    function activateUserCommand(){
        var userId = getUserId(args.username);

        var res = activateUser(userId);

        var md = '### Okta user activated: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function activateUser(userId) {
        var uri = 'users/' + userId + '/lifecycle/activate';

        return sendRequest(uri, 'POST');
    }

    function getGroupsCommand() {
        var userId = getUserId(args.username);

        var results = getGroups(userId);
        var hr = getGroupsHumanReadable(results);
        var ec = {
            Group: hr,
            ID: userId,
            Type: 'Okta'
        };

        var md = '### Okta groups for user ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';;
        md += tableToMarkdown('Groups', hr);
        return {
            Type: entryTypes.note,
            EntryContext: {
                'Account(val.ID===obj.ID)' : ec
            },
            Contents: results,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function getGroupsHumanReadable(results){
        if(!Array.isArray(results)){
            results = [results];
        }

        var groups = [];
        results.forEach(function(resGroup){
            var group = {
                ID: resGroup.id,
                Created: resGroup.created,
                ObjectClass: resGroup.objectClass,
                LastUpdated: resGroup.lastUpdated,
                LastMembershipUpdated: resGroup.lastMembershipUpdated,
                Type: resGroup.type,
                Name: resGroup.profile.name,
                Description: resGroup.profile.description
            };

            groups.push(group);
        });

        return groups;
    }

    function getGroups(userId) {
        var uri = 'users/' + userId + '/groups';

        return sendRequest(uri);
    }

    function listGroupsCommand(){
        var results = listGroups(args.query, args.filter, args.limit);

        var hr = getGroupsHumanReadable(results);

        return {
            Type: entryTypes.note,
            entryContext: {
                'Okta.Group(val.ID===obj.ID)' : hr
            },
            Contents: results,
            ContentsFormat: formats.json,
            HumanReadable: tableToMarkdown('Groups', hr)
        };
    }

    function listGroups(query, filter, limit){
        var queryParams = {};

        if(filter){
            queryParams.filter = filter;
        }

        if(query){
            queryParams.q = encodeURIComponent(query);
        }

        if(limit){
            queryParams.limit = limit;
        }

        return getPagedResults('groups', queryParams);
    }

    function getGroupMembersCommand(){
        var groupId = args.groupId;
        var groupName = args.groupName;

        if(!groupId && !groupName){
            throw 'Missing arguments for command';
        }

        if(!groupId){
            groupId = getGroupId(groupName);
        }

        var members = getGroupMembers(groupId, args.limit);
        var group = getGroupsHumanReadable(listGroups(groupName)[0]);

        members.forEach(function(member){
            member.group = group;
        });

        var md = usersToMarkdown(members, args.verbose);
        var ec = usersToEntryContext(members);

        var entry = {
            Type: entryTypes.note,
            EntryContext: ec,
            Contents: members,
            ContentsFormat: formats.json,
            HumanReadable: md
        };

        return entry;
    }

    function getGroupMembers(groupId, limit){
        queryParams = {}

        if(limit){
            queryParams.limit = limit;
        }

        return getPagedResults('groups/' + groupId + '/users', queryParams);
    }

    function addUserToGroupCommand(){
        var groupId = args.groupId;
        var userId = args.userId;
        var username = args.username;
        var groupName = args.groupName;

        if((!userId && !username) || (!groupId && !groupName)){
            throw 'Missing arguments for command';
        }

        if(!userId){
            userId = getUserId(username);
        }

        if(!groupId){
            groupId = getGroupId(groupName);
        }

        var res = addUserToGroup(userId, groupId);

        return 'Succesfully added user to group';
    }

    function addUserToGroup(userId, groupId){
        var uri = 'groups/' + groupId + '/users/' + userId;

        return sendRequest(uri, 'PUT');
    }

    function removeUserFromGroupCommand(){
        var groupId = args.groupId;
        var userId = args.userId;
        var username = args.username;
        var groupName = args.groupName;

        if((!userId && !username) || (!groupId && !groupName)){
            throw 'Missing arguments for command';
        }

        if(!userId){
            userId = getUserId(username);
        }

        if(!groupId){
            groupId = getGroupId(groupName);
        }

        var res = removeUserFromGroup(userId, groupId);

        return 'Succesfully removed user from group';
    }

    function removeUserFromGroup(userId, groupId){
        var uri = 'groups/' + groupId + '/users/' + userId;

        return sendRequest(uri, 'DELETE');
    }

    function setPasswordCommand(){
        var userId = getUserId(args.username);

        var res = setPassword(userId, args.password);

        var md = '### Okta user password set: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat:
            formats.json,
            HumanReadable: md
        };
    }

    function setPassword(userId, password) {
        var uri = 'users/' + userId;

        var body =  {
            'credentials': {
                'password' : { 'value': password }
            }
        };

        return sendRequest(uri, 'POST', null, body);
    }

    function searchCommand(){
        var limit = args.limit ? args.limit : DEFAULT_SEARCH_LIMIT;
        var term = args.term ? encodeURIComponent(args.term) : args.term;

        var res = search(term, limit);

        var md;
        var ec;
        if (res && res.length>0) {
            md = '### Okta users found:\n';
            md += usersToMarkdown(res, args.verbose);
            ec = usersToEntryContext(res);
        }
        else {
            md = '### No users found in Okta\n';
        }

        return {
            Type: entryTypes.note,
            EntryContext: ec,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function search(term, limit) {
        var uri = 'users?q=' + term + '&limit=' + limit;

        return sendRequest(uri);
    }

    function getUserCommand(){
        var term = args.username ? encodeURIComponent(args.username) : args.userid;

        if (!term) {
            throw "You must supply either 'username' or 'userid'";
        }

        var res = getUser(term);

        var md = '### Okta user:\n';
        md += usersToMarkdown(res,args.verbose);
        var ec = usersToEntryContext(res);
        return {
            Type: entryTypes.note,
            EntryContext: ec,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function getUser(term){
        var uri = 'users/' + term;

        return sendRequest(uri);
    }

    function getUserFactorsCommand(){
        var userId = args.userId;
        var username = args.username;

        if(!userId && !username){
            throw "You must supply either 'username' or 'userid'";
        }

        if(!userId){
            userId = getUserId(username);
        }

        var factors = getUserFactors(userId);

        if(!factors || factors.length === 0){
            return 'No factors found';
        }

        var mappedFactors = [];
        var hr = [];

        factors.forEach(function(factor){
           mappedFactors.push({
               ID: factor.id,
               FactorType: factor.factorType,
               Provider: factor.provider,
               Status: factor.status,
               Profile: factor.profile
           });

           hr.push({
               'ID': factor.id,
               'Factor Type': factor.factorType,
               'Provider': factor.provider,
               'Status': factor.status
           });
        });

        var md = tableToMarkdown('Okta available factors for user with ID: ' + userId, hr);
        var account = {
            ID: userId,
            Factor: mappedFactors
        };

        return {
            Type: entryTypes.note,
            Contents: factors,
            ContentsFormat: formats.json,
            HumanReadable: md,
            EntryContext: {
                'Account(val.ID===obj.ID)': account
            }
        }
    }

    function getUserFactors(userId){
        var uri = 'users/' + userId + '/factors';

        return sendRequest(uri);
    }

    function verifyPushCommand(){
        var userId = args.userId;
        var factorId = args.factorId;
        var response = verifyPush(userId, factorId);

        if (!response) {
            throw 'Did not receive a response from the factor challenge';
        }

        var links = response._links;

        if (!links || !links.poll){
            throw 'Did not recieve a polling link for the push factor challenge';
        }

        var result = pollVerifyPush(links.poll.href);

        var account = {
            ID: userId,
            VerifyPushResult: result.factorResult
        };

        return {
            Type: entryTypes.note,
            EntryContext: {
                'Account(val.ID===obj.ID)': account
            },
            Contents: response,
            ContentsFormat: formats.json,
            HumanReadable: 'Verify push factor result: ' + account.VerifyPushResult
        };
    }

    function verifyPush(userId, factorId){
        var path = '/users/' + userId + '/factors/' + factorId + '/verify';

        return sendRequest(path, 'POST');
    }


    function pollVerifyPush(verifyLink){
        // Get the query string of the link
        var index = verifyLink.indexOf(API_POSTFIX);
        var path = verifyLink.substr(index + API_POSTFIX.length);

        do {
            var response = sendRequest(path);
            if (!response) {
                throw 'Did not receive a response from the factor verfication';
            }

            // Wait 5 seconds
            wait(5);

        } while (response.factorResult === 'WAITING')

        return response;
    }

    function resetFactorCommand(){
        var userId = args.userId;
        var username = args.username;
        var factorId = args.factorId;

        if(!userId && !username){
            throw "You must supply either 'username' or 'userid'";
        }

        if(!userId){
            userId = getUserId(username);
        }

        var response = resetFactor(userId, factorId);

        return {
            Type: entryTypes.note,
            Contents: response,
            ContentsFormat: formats.json,
            HumanReadable: 'Successfully reset factor for user with ID: ' + userId
        };
    }

    function resetFactor(userId, factorId){
        var path = '/users/' + userId + '/factors/' + factorId;

        return sendRequest(path, 'DELETE');
    }

    function createUserCommand(){
        var cred = buildCredentials(args);
        var profile = buildProfile(args);
        var groupIds = args.groupIds;
        if (groupIds) {
            groupIds = groupIds.split(',');
        }

        var activate = false;
        if (args.activate) {
            activate = args.activate.toLowerCase() === 'true';
        }

        var res = createUser(cred, profile, groupIds, activate);

        var md = '### Okta user created: ' + args.login + '\n';
        md += profileToMd(res.profile);
        var ec = usersToEntryContext(res);
        return {
            Type: entryTypes.note,
            EntryContext: ec,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function createUser(cred, profile, groupIds, activate) {
        var body = {
            profile: profile,
            groupIds: groupIds,
            credentials: cred
        };

        var uri = 'users?activate=' + activate;
        if (cred && cred.provider) {
            uri += '&provider=true';
        }

        return sendRequest(uri, 'POST','', body);
    }

    function updateUserCommand() {
        var userId = getUserId(args.username);
        var cred = buildCredentials(args);
        var profile = buildProfile(args);
        profile.login = args.username;

        var res = updateUser(userId, profile, cred);
        var md = '### Okta user updated: ' + args.username + '\n';
        md += 'User ID: ' + userId + '\n';
        md += profileToMd(res.profile);
        return {
            Type: entryTypes.note,
            Contents: res,
            ContentsFormat: formats.json,
            HumanReadable: md
        };
    }

    function updateUser(userId, profile, cred){
        var body = {
            profile: profile,
            credentials: cred
        };

        var uri = 'users/' + userId;

        return sendRequest(uri, 'POST', '', body);
    }

    function getLogs(filter, query, since, until, sortOrder, limit)
    {
        var queryParams = {};

        if(filter){
            queryParams.filter =  encodeURIComponent(filter);
        }

        if(query){
            queryParams.q = encodeURIComponent(query);
        }

        if(since){
            queryParams.since = since;
        }

        if(until){
            queryParams.until = until;
        }

        if(sortOrder){
            queryParams.sortOrder = sortOrder;
        }

        if(limit){
            queryParams.limit = limit;
        }

        return getPagedResults('logs', queryParams)
    }

    function getFailedLoginsCommand(){
        var readableLogs = [];
        var filter = 'eventType eq "user.session.start" and outcome.result eq "FAILURE"';
        var logs = getLogs(filter, args.query, args.since, args.until, args.sortOrder, args.limit);

        if(!logs || logs.length === 0){
            return 'No events found';
        }

        for(var i = 0; i < logs.length; i++){
            readableLogs.push(createReadableLog(logs[i]));
        }

        var md = tableToMarkdown('Failed Login events', readableLogs);

        return {
            Type: entryTypes.note,
            Contents: logs,
            ContentsFormat: formats.json,
            EntryContext: {
                'Okta.Logs.Events(val.uuid===obj.uuid)' : logs
            },
            HumanReadable: md
        };
    }

    function getGroupAssignmentsCommand(){
        var readableLogs = [];
        var filter = 'eventType eq "group.user_membership.add"';
        var logs = getLogs(filter, args.query, args.since, args.until, args.sortOrder, args.limit);

        if(!logs || logs.length === 0){
            return 'No events found';
        }

        for(var i = 0; i < logs.length; i++){
            readableLogs.push(createReadableLog(logs[i]));
        }

        var md = tableToMarkdown('Group assignment events', readableLogs);

        return {
            Type: entryTypes.note,
            Contents: logs,
            ContentsFormat: formats.json,
            EntryContext: {
                'Okta.Logs.Events(val.uuid===obj.uuid)' : logs
            },
            HumanReadable: md
        };
    }

    function getApplicationAssignmentsCommand(){
        var readableLogs = [];
        var filter = 'eventType eq "application.user_membership.add"';
        var logs = getLogs(filter, args.query, args.since, args.until, args.sortOrder, args.limit);

        if(!logs || logs.length === 0){
            return 'No events found';
        }

        for(var i = 0; i < logs.length; i++){
            readableLogs.push(createReadableLog(logs[i]));
        }

        var md = tableToMarkdown('Application assignment events', readableLogs);

        return {
            Type: entryTypes.note,
            Contents: logs,
            ContentsFormat: formats.json,
            EntryContext: {
                'Okta.Logs.Events(val.uuid===obj.uuid)' : logs
            },
            HumanReadable: md
        };
    }

    function getApplicationAuthenticationCommand(){
        var readableLogs = [];
        var filter = 'eventType eq "user.authentication.sso"';
        var logs = getLogs(filter, args.query, args.since, args.until, args.sortOrder, args.limit);

        if(!logs || logs.length === 0){
            return 'No events found';
        }

        for(var i = 0; i < logs.length; i++){
            readableLogs.push(createReadableLog(logs[i]));
        }

        var md = tableToMarkdown('Application authentication events', readableLogs);

        return {
            Type: entryTypes.note,
            Contents: logs,
            ContentsFormat: formats.json,
            EntryContext: {
                'Okta.Logs.Events(val.uuid===obj.uuid)' : logs
            },
            HumanReadable: md
        };
    }

    function getLogsCommand(){
        var readableLogs = [];
        var logs = getLogs(args.filter, args.query, args.since, args.until, args.sortOrder, args.limit);

        if(!logs || logs.length === 0){
            return 'No events found';
        }

        for(var i = 0; i < logs.length; i++){
            readableLogs.push(createReadableLog(logs[i]));
        }

        var md = tableToMarkdown('Okta events', readableLogs);

        return {
            Type: entryTypes.note,
            Contents: logs,
            ContentsFormat: formats.json,
            EntryContext: {
                'Okta.Logs.Events(val.uuid===obj.uuid)' : logs
            },
            HumanReadable: md
        };
    }

    function test() {
        var uri = 'users/me';
        var res = sendRequest(uri);

        return res ? 'ok' : 'not ok';
    }

    var entry;
    switch (command){
        case 'test-module':
            return test();
        case 'okta-unlock-user':
            entry = unlockUserCommand();
            break;
        case 'okta-deactivate-user':
            entry = deactivateUserCommand();
            break;
        case 'okta-activate-user':
            entry = activateUserCommand();
            break;
        case 'okta-get-groups':
            entry = getGroupsCommand();
            break;
        case 'okta-set-password':
            entry = setPasswordCommand();
            break;
        case 'okta-search':
            entry = searchCommand();
            break;
        case 'okta-get-user':
            entry = getUserCommand();
            break;
        case 'okta-create-user':
            entry = createUserCommand();
            break;
        case 'okta-update-user':
            entry = updateUserCommand();
            break;
        case 'okta-get-failed-logins':
            entry = getFailedLoginsCommand();
            break;
        case 'okta-get-group-assignments':
            entry = getGroupAssignmentsCommand();
            break;
        case 'okta-get-application-assignments':
            entry = getApplicationAssignmentsCommand();
            break;
        case 'okta-get-application-authentication':
            entry = getApplicationAuthenticationCommand();
            break;
        case 'okta-add-to-group':
            entry = addUserToGroupCommand();
            break;
        case 'okta-remove-from-group':
            entry = removeUserFromGroupCommand();
            break;
        case 'okta-get-logs':
            entry = getLogsCommand();
            break;
        case 'okta-list-groups':
            entry = listGroupsCommand();
            break;
        case 'okta-get-group-members':
            entry = getGroupMembersCommand();
            break;
        case 'okta-suspend-user':
            entry = suspendUserCommand();
            break;
        case 'okta-unsuspend-user':
            entry = unSuspendUserCommand();
            break;
        case 'okta-get-user-factors':
            entry = getUserFactorsCommand();
            break;
        case 'okta-verify-push-factor':
            entry = verifyPushCommand();
            break;
        case 'okta-reset-factor':
            entry = resetFactorCommand();
            break;
    }


    return entry;
  type: javascript
  commands:
  - name: okta-unlock-user
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to unlock
    description: Unlock user
    execution: true
  - name: okta-deactivate-user
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to deactivate
    description: Deactivate user
    execution: true
  - name: okta-activate-user
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to activate
    description: Activate user
    execution: true
  - name: okta-suspend-user
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to suspend
    description: Suspends a user.  This operation can only be performed on users with
      an ACTIVE status. The user has a status of SUSPENDED when the process is complete.
    execution: true
  - name: okta-unsuspend-user
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to unsuspend
    description: Unsuspends a user and returns them to the ACTIVE state.  This operation
      can only be performed on users that have a SUSPENDED status.
    execution: true
  - name: okta-get-user-factors
    arguments:
    - name: userId
      description: The user Id
    - name: username
      description: The user name
    outputs:
    - contextPath: Account.ID
      description: Okta account ID
      type: string
    - contextPath: Account.Factor.ID
      description: Okta account factor ID
      type: string
    - contextPath: Account.Factor.FactorType
      description: Okta account factor type
      type: string
    - contextPath: Account.Factor.Provider
      description: Okta account factor provider
      type: string
    - contextPath: Account.Factor.Status
      description: Okta account factor status
      type: string
    - contextPath: Account.Factor.Profile
      description: Okta account factor profile
      type: string
    description: Enumerates all the enrolled factors for the specified user.
  - name: okta-verify-push-factor
    arguments:
    - name: userId
      required: true
      description: The id of the user to challenge
    - name: factorId
      required: true
      description: The push factor id
    outputs:
    - contextPath: Account.ID
      description: Okta user ID
      type: string
    - contextPath: Account.VerifyPushResult
      description: Okta user verify push factor result
      type: string
    description: Creates and verifies a push factor for a specified user.
    execution: true
  - name: okta-reset-factor
    arguments:
    - name: userId
      description: The user id
    - name: username
      description: The user name
    - name: factorId
      required: true
      description: The id of the factor to reset
    description: Unenrolls an existing factor for the specified user, allowing the
      user to enroll a new factor.
    execution: true
  - name: okta-get-groups
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to get groups for
    outputs:
    - contextPath: Account.Group
      description: Okta groups the account is associated with
    - contextPath: Account.ID
      description: Okta account ID
      type: string
    - contextPath: Account.Type
      description: Account type - Okta
      type: string
    - contextPath: Account.Group.ID
      description: Unique key for group
      type: string
    - contextPath: Account.Group.Created
      description: Timestamp when group was created
      type: date
    - contextPath: Account.Group.ObjectClass
      description: Determines the group’s profile
      type: string
    - contextPath: Account.Group.LastUpdated
      description: Timestamp when group’s profile was last updated
      type: date
    - contextPath: Account.Group.LastMembershipUpdated
      description: Timestamp when group’s memberships were last updated
      type: date
    - contextPath: Account.Group.Type
      description: Determines how a group’s profile and memberships are managed
      type: string
    - contextPath: Account.Group.Name
      description: Name of the group
      type: string
    - contextPath: Account.Group.Description
      description: Description of the group
      type: string
    description: Get all user groups
  - name: okta-set-password
    arguments:
    - name: username
      required: true
      default: true
      description: Username in Okta to set the password for
    - name: password
      required: true
      description: The new password to set for the user
    description: Creates a user without a recovery question & answer  The new user
      is able to login immediately after activation with the assigned password. This
      flow is common when developing a custom user registration experience.
    execution: true
  - name: okta-search
    arguments:
    - name: term
      required: true
      default: true
      description: Term to search for, this term can be first name, last name or email
    - name: limit
      description: Max number of results to return (defaults to 200)
    - name: verbose
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Print all details of users that match search term
    outputs:
    - contextPath: Account.ID
      description: Okta account IDs returned by search
      type: string
    - contextPath: Account.Username
      description: Okta account usernames returned by search
      type: string
    - contextPath: Account.Email
      description: Okta account emails returned by search
      type: string
    - contextPath: Accout.DisplayName
      description: Okta account display names returned by search
      type: string
    - contextPath: Account.Type
      description: Account type returned by search - Okta
      type: string
    description: Search for Okta users
  - name: okta-get-user
    arguments:
    - name: username
      description: Username of requested user, please note that this will not work
        for usernames that contains a '/' character
    - name: userid
      description: User ID of requested user
    - name: verbose
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Print all details of user
    outputs:
    - contextPath: Account.ID
      description: Okta account ID
      type: string
    - contextPath: Account.Email
      description: Okta account email
      type: string
    - contextPath: Account.Username
      description: Okta account username
      type: string
    - contextPath: Account.DisplayName
      description: Okta account display name
      type: string
    - contextPath: Account.Type
      description: Account type - Okta
      type: string
    description: Fetches a specific user given you know the user’s login, please note
      that one of the parameters bellow is mandatory.
  - name: okta-create-user
    arguments:
    - name: firstName
      required: true
      description: Given name of the user (givenName)
    - name: lastName
      required: true
      description: Family name of the user (familyName)
    - name: email
      required: true
      description: primary email address of user
    - name: login
      required: true
      description: Unique identifier for the user (username)
    - name: secondEmail
      description: Secondary email address of user typically used for account recovery
    - name: middleName
      description: "Middle name(s) of the user\t"
    - name: honorificPrefix
      description: Honorific prefix(es) of the user, or title in most Western languages
    - name: honorificSuffix
      description: honorific suffix(es) of the user
    - name: title
      description: User’s title, such as “Vice President”
    - name: displayName
      description: Name of the user, suitable for display to end-users
    - name: nickName
      description: Casual way to address the user in real life
    - name: profileUrl
      description: Url of user’s online profile (e.g. a web page)
    - name: primaryPhone
      description: "Primary phone number of user such as home number\t"
    - name: mobilePhone
      description: mobile phone number of user
    - name: streetAddress
      description: Full street address component of user’s address
    - name: city
      description: City or locality component of user’s address (locality)
    - name: state
      description: State or region component of user’s address (region)
    - name: zipCode
      description: Zipcode or postal code component of user’s address (postalCode)
    - name: countryCode
      description: Country name component of user’s address (country)
    - name: postalAddress
      description: Mailing address component of user’s address
    - name: preferredLanguage
      description: User’s preferred written or spoken languages
    - name: locale
      description: User’s default location for purposes of localizing items such as
        currency, date time format, numerical representations, etc.
    - name: timezone
      description: User’s time zone
    - name: userType
      description: Used to identify the organization to user relationship such as
        “Employee” or “Contractor”
    - name: employeeNumber
      description: Organization or company assigned unique identifier for the user
    - name: costCenter
      description: name of a cost center assigned to
    - name: organization
      description: Name of user’s organization
    - name: division
      description: Name of user’s division
    - name: department
      description: Name of user’s department
    - name: managerId
      description: ID of a user’s manager
    - name: manager
      description: DisplayName of the user’s manager
    - name: password
      description: Password for new user
    - name: passwordQuestion
      description: Password question for new user
    - name: passwordAnswer
      description: Password answer for question supplied
    - name: providerType
      auto: PREDEFINED
      predefined:
      - OKTA
      - ACTIVE_DIRECTORY
      - LDAP
      - FEDERATION
      - SOCIAL
      description: OKTA, ACTIVE_DIRECTORY,LDAP, FEDERATION, or SOCIAL
    - name: providerName
      description: Name of provider
    - name: groupIds
      description: Ids of groups that user will be immediately added to at time of
        creation (Do not include default group)
    - name: activate
      description: Executes activation lifecycle operation when creating the user
    outputs:
    - contextPath: Account.ID
      description: Created okta account ID
      type: string
    - contextPath: Account.Email
      description: Created okta account email
      type: string
    - contextPath: Account.Username
      description: Created okta account username
      type: string
    - contextPath: Account.DisplayName
      description: Created okta account display name
      type: string
    - contextPath: Account.Type
      description: Type of create account - Okta
      type: string
    description: Creates a new user with an option of setting password, recovery question
      and answer. The new user will immediately be able to login after activation
      with the assigned password. This flow is common when developing a custom user
      registration experience.
    execution: true
  - name: okta-update-user
    arguments:
    - name: firstName
      description: Given name of the user (givenName)
    - name: lastName
      description: Family name of the user (familyName)
    - name: email
      description: primary email address of user
    - name: username
      required: true
      description: Unique identifier for the user (login)
    - name: secondEmail
      description: Secondary email address of user typically used for account recovery
    - name: middleName
      description: "Middle name(s) of the user\t"
    - name: honorificPrefix
      description: Honorific prefix(es) of the user, or title in most Western languages
    - name: honorificSuffix
      description: honorific suffix(es) of the user
    - name: title
      description: User’s title, such as “Vice President”
    - name: displayName
      description: Name of the user, suitable for display to end-users
    - name: nickName
      description: Casual way to address the user in real life
    - name: profileUrl
      description: Url of user’s online profile (e.g. a web page)
    - name: primaryPhone
      description: "Primary phone number of user such as home number\t"
    - name: mobilePhone
      description: mobile phone number of user
    - name: streetAddress
      description: Full street address component of user’s address
    - name: city
      description: City or locality component of user’s address (locality)
    - name: state
      description: State or region component of user’s address (region)
    - name: zipCode
      description: Zipcode or postal code component of user’s address (postalCode)
    - name: countryCode
      description: Country name component of user’s address (country)
    - name: postalAddress
      description: Mailing address component of user’s address
    - name: "preferredLanguage\t"
      description: User’s preferred written or spoken languages
    - name: locale
      description: User’s default location for purposes of localizing items such as
        currency, date time format, numerical representations, etc.
    - name: "timezone\t"
      description: User’s time zone
    - name: userType
      description: Used to identify the organization to user relationship such as
        “Employee” or “Contractor”
    - name: employeeNumber
      description: Organization or company assigned unique identifier for the user
    - name: costCenter
      description: name of a cost center assigned to
    - name: organization
      description: Name of user’s organization
    - name: division
      description: Name of user’s division
    - name: department
      description: Name of user’s department
    - name: managerId
      description: ID of a user’s manager
    - name: manager
      description: DisplayName of the user’s manager
    - name: password
      description: Password for new user
    - name: passwordQuestion
      description: Password question for new user
    - name: passwordAnswer
      description: Password answer for question supplied
    - name: providerType
      auto: PREDEFINED
      predefined:
      - OKTA
      - ACTIVE_DIRECTORY
      - LDAP
      - FEDERATION
      - SOCIAL
      description: OKTA, ACTIVE_DIRECTORY,LDAP, FEDERATION, or SOCIAL
    - name: providerName
      description: Name of provider
    description: Update user with a given login, all fields are optional, fields which
      are not set will not be overriden
    execution: true
  - name: okta-get-failed-logins
    arguments:
    - name: since
      description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: until
      description: 'Filters the upper time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: sortOrder
      auto: PREDEFINED
      predefined:
      - ASCENDING
      - DESCENDING
      description: The order of the returned events, default is ASCENDING
    - name: limit
      description: Sets the number of results returned in the response. Default is
        100.
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of actor
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The Operating System the client runs on (e.g. Windows 10)
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: If the client is a web browser, this field identifies the type
        of web browser (e.g. CHROME, FIREFOX)
      type: string
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device that the client operated from (e.g. Computer)
      type: string
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests this is the id of the OAuth client making the
        request. For SSWS token requests, this is the id of the agent making the request.
      type: string
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: Ip address that the client made its request from
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event
      type: string
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published
      type: string
    - contextPath: Okta.Logs.Events.outcome.result
      description: 'Result of the action: SUCCESS, FAILURE, SKIPPED, UNKNOWN'
      type: string
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result, for example INVALID_CREDENTIALS
      type: string
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when event was published
      type: string
    - contextPath: Okta.Logs.Events.severity
      description: 'Indicates how severe the event is: DEBUG, INFO, WARN, ERROR'
      type: string
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to
      type: number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to sent the event’s request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event’s request is from a known proxy
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source
      type: string
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target
      type: string
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target
      type: string
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative id of a target
      type: string
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target
      type: string
    description: Get events for when Okta issued a session to a user who is authenticating
      and the user failed to log-in
  - name: okta-get-group-assignments
    arguments:
    - name: since
      description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: until
      description: 'Filters the upper time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: sortOrder
      auto: PREDEFINED
      predefined:
      - ASCENDING
      - DESCENDING
      description: The order of the returned events, default is ASCENDING
    - name: limit
      description: Sets the number of results returned in the response. Default is
        100.
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of actor
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The Operating System the client runs on (e.g. Windows 10)
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: If the client is a web browser, this field identifies the type
        of web browser (e.g. CHROME, FIREFOX)
      type: string
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device that the client operated from (e.g. Computer)
      type: string
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests this is the id of the OAuth client making the
        request. For SSWS token requests, this is the id of the agent making the request.
      type: string
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: Ip address that the client made its request from
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event
      type: string
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published
      type: string
    - contextPath: Okta.Logs.Events.outcome.result
      description: 'Result of the action: SUCCESS, FAILURE, SKIPPED, UNKNOWN'
      type: string
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result, for example INVALID_CREDENTIALS
      type: string
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when event was published
      type: string
    - contextPath: Okta.Logs.Events.severity
      description: 'Indicates how severe the event is: DEBUG, INFO, WARN, ERROR'
      type: string
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to
      type: number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to sent the event’s request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event’s request is from a known proxy
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source
      type: string
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target
      type: string
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target
      type: string
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative id of a target
      type: string
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target
      type: string
    description: Get events for when a user was added to a group.
  - name: okta-get-application-assignments
    arguments:
    - name: since
      description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: until
      description: 'Filters the upper time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: sortOrder
      auto: PREDEFINED
      predefined:
      - ASCENDING
      - DESCENDING
      description: The order of the returned events, default is ASCENDING
    - name: limit
      description: Sets the number of results returned in the response. Default is
        100.
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of actor
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The Operating System the client runs on (e.g. Windows 10)
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: If the client is a web browser, this field identifies the type
        of web browser (e.g. CHROME, FIREFOX)
      type: string
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device that the client operated from (e.g. Computer)
      type: string
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests this is the id of the OAuth client making the
        request. For SSWS token requests, this is the id of the agent making the request.
      type: string
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: Ip address that the client made its request from
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event
      type: string
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published
      type: string
    - contextPath: Okta.Logs.Events.outcome.result
      description: 'Result of the action: SUCCESS, FAILURE, SKIPPED, UNKNOWN'
      type: string
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result, for example INVALID_CREDENTIALS
      type: string
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when event was published
      type: string
    - contextPath: Okta.Logs.Events.severity
      description: 'Indicates how severe the event is: DEBUG, INFO, WARN, ERROR'
      type: string
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to
      type: number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to sent the event’s request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event’s request is from a known proxy
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source
      type: string
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target
      type: string
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target
      type: string
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative id of a target
      type: string
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target
      type: string
    description: Get events for when a user was assigned to an application.
  - name: okta-get-application-authentication
    arguments:
    - name: since
      description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: until
      description: 'Filters the upper time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: sortOrder
      auto: PREDEFINED
      predefined:
      - ASCENDING
      - DESCENDING
      description: The order of the returned events, default is ASCENDING
    - name: limit
      description: Sets the number of results returned in the response. Default is
        100.
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of actor
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The Operating System the client runs on (e.g. Windows 10)
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: If the client is a web browser, this field identifies the type
        of web browser (e.g. CHROME, FIREFOX)
      type: string
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device that the client operated from (e.g. Computer)
      type: string
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests this is the id of the OAuth client making the
        request. For SSWS token requests, this is the id of the agent making the request.
      type: string
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: Ip address that the client made its request from
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event
      type: string
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published
      type: string
    - contextPath: Okta.Logs.Events.outcome.result
      description: 'Result of the action: SUCCESS, FAILURE, SKIPPED, UNKNOWN'
      type: string
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result, for example INVALID_CREDENTIALS
      type: string
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when event was published
      type: string
    - contextPath: Okta.Logs.Events.severity
      description: 'Indicates how severe the event is: DEBUG, INFO, WARN, ERROR'
      type: string
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to
      type: number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to sent the event’s request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event’s request is from a known proxy
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source
      type: string
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target
      type: string
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target
      type: string
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative id of a target
      type: string
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target
      type: string
    description: Get events for when a user attempted to SSO to an application managed
      in Okta
  - name: okta-get-logs
    arguments:
    - name: filter
      description: "An expression filter is useful for performing structured queries
        where constraints on LogEvent attribute values can be explicitly targeted.
        \ The following expressions are supported for events with the filter query
        parameter: eventType eq \":eventType\" -\tEvents that have a specific action;
        eventType target.id eq \":id\" - Events published with a specific target id;
        actor.id eq \":id\" - Events published with a specific actor id. For more
        information about filtering, visit https://developer.okta.com/docs/api/getting_started/design_principles#filtering"
    - name: query
      description: 'The query parameter can be used to perform keyword matching against
        a LogEvents object’s attribute values. In order to satisfy the constraint,
        all supplied keywords must be matched exactly. Note that matching is case-insensitive.  The
        following are some examples of common keyword filtering: Events that mention
        a specific city: query=San Francisco; Events that mention a specific url:
        query=interestingURI.com; Events that mention a specific person: query=firstName
        lastName.'
    - name: since
      description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: until
      description: 'Filters the upper time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
    - name: sortOrder
      auto: PREDEFINED
      predefined:
      - ASCENDING
      - DESCENDING
      description: The order of the returned events, default is ASCENDING
    - name: limit
      description: Sets the number of results returned in the response. Default is
        100.
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of actor
      type: string
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of actor
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The Operating System the client runs on (e.g. Windows 10)
      type: string
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: If the client is a web browser, this field identifies the type
        of web browser (e.g. CHROME, FIREFOX)
      type: string
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device that the client operated from (e.g. Computer)
      type: string
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests this is the id of the OAuth client making the
        request. For SSWS token requests, this is the id of the agent making the request.
      type: string
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: Ip address that the client made its request from
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event
      type: string
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published
      type: string
    - contextPath: Okta.Logs.Events.outcome.result
      description: 'Result of the action: SUCCESS, FAILURE, SKIPPED, UNKNOWN'
      type: string
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result, for example INVALID_CREDENTIALS
      type: string
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when event was published
      type: string
    - contextPath: Okta.Logs.Events.severity
      description: 'Indicates how severe the event is: DEBUG, INFO, WARN, ERROR'
      type: string
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to
      type: number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to sent the event’s request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request
      type: string
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event’s request is from a known proxy
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geolocation coordinates,
        if available (e.g. Seattle, San Francisco)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state/province encompassing the area containing
        the geolocation coordinates (e.g. Montana, Incheon)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geolocation
        coordinates (e.g. France, Uganda)
      type: string
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source
      type: string
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target
      type: string
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target
      type: string
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative id of a target
      type: string
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target
      type: string
    description: Get logs by providing optional filters
  - name: okta-add-to-group
    arguments:
    - name: userId
      description: ID of the user to add
    - name: groupId
      description: ID of the group to add the user to
    - name: username
      description: Name of the user to add
    - name: groupName
      description: Name of the group to add the user to
    description: Adds a user to a group with OKTA_GROUP type.
    execution: true
  - name: okta-remove-from-group
    arguments:
    - name: userId
      description: ID of the user to remove
    - name: groupId
      description: ID of the group to remove the user from
    - name: username
      description: Name of the user to remove
    - name: groupName
      description: Name of the group to remove the user from
    description: Removes a user from a group with OKTA_GROUP type.
    execution: true
  - name: okta-list-groups
    arguments:
    - name: query
      description: Searches the name property of groups for matching value
    - name: filter
      description: 'An expression filter is useful for performing structured queries
        where constraints on group attribute values can be explicitly targeted. The
        following expressions are supported(among others) for groups with the filter
        query parameter: type eq "OKTA_GROUP" - Groups that have a type of OKTA_GROUP;
        lastUpdated lt "yyyy-MM-dd''T''HH:mm:ss.SSSZ" - Groups with profile last updated
        before a specific timestamp; lastMembershipUpdated eq "yyyy-MM-dd''T''HH:mm:ss.SSSZ"
        - Groups with memberships last updated at a specific timestamp; id eq "00g1emaKYZTWRYYRRTSK"
        - Group with a specified id. For more information about filtering, visit https://developer.okta.com/docs/api/getting_started/design_principles#filtering'
    - name: limit
      description: Sets the number of results returned in the response.
      defaultValue: "200"
    outputs:
    - contextPath: Okta.Group.ID
      description: Unique key for the group
      type: string
    - contextPath: Okta.Group.Created
      description: Timestamp for when the group was created
      type: date
    - contextPath: Okta.Group.ObjectClass
      description: The group’s profile
      type: unknown
    - contextPath: Okta.Group.LastUpdated
      description: Timestamp for when the group’s profile was last updated
      type: date
    - contextPath: Okta.Group.LastMembershipUpdated
      description: Timestamp for when the group’s memberships were last updated
      type: date
    - contextPath: Okta.Group.Type
      description: Determines how a group’s profile and memberships are managed -
        OKTA_GROUP, APP_GROUP and BUILT_IN
      type: string
    - contextPath: Okta.Group.Name
      description: Name of the group
      type: string
    - contextPath: Okta.Group.Description
      description: Description of the group
      type: string
    description: Enumerates groups in your organization. A subset of groups can be
      returned that match a supported filter expression or query.
  - name: okta-get-group-members
    arguments:
    - name: groupId
      description: Id of the group
    - name: limit
      description: Specifies the number of user results
    - name: verbose
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Print all details of user
    - name: groupName
      description: Name of the group
    outputs:
    - contextPath: Account.ID
      description: Okta account ID
      type: string
    - contextPath: Account.Email
      description: Okta account email
      type: string
    - contextPath: Account.Username
      description: Okta account username
      type: string
    - contextPath: Account.DisplayName
      description: Okta account display name
      type: string
    - contextPath: Account.Type
      description: Account type - Okta
      type: string
    description: Enumerates all users that are members of a group
  runonce: false
fromversion: 3.6.0
releaseNotes: "Added option to send and verify push factor, also reset a user's factor"