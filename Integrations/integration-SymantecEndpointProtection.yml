category: Endpoint
commonfields:
  id: Symantec Endpoint Protection V2
  version: -1
configuration:
- defaultvalue: ''
  display: Server (e.g. https://1.2.3.4:8446)
  name: server
  options: [
    ]
  required: true
  type: 0
- defaultvalue: ''
  display: Authentication
  name: authentication
  options: [
    ]
  required: true
  type: 9
- defaultvalue: ''
  display: SEPM domain for the user
  name: domain
  options: [
    ]
  required: false
  type: 0
- defaultvalue: 'false'
  display: Trust any certificate (unsecure)
  name: insecure
  options: [
    ]
  required: false
  type: 8
- defaultvalue: 'true'
  display: Use proxy system settings
  name: proxy
  options: [
    ]
  required: false
  type: 8
- defaultvalue: ''
  display: 'Local time zone (for example: +02:30,-06:00)'
  name: timeZone
  options: [
    ]
  required: false
  type: 0
description: Query the Symantec Endpoint Protection Manager using the official REST
  API.
detaileddescription: Integration with Symantec Endpoint Protection Manager using the
  sepm REST API.
display: Symantec Endpoint Protection V2
name: Symantec Endpoint Protection V2
script:
  commands:
  - arguments:
    - default: false
      defaultValue: ''
      description: The columns to show.
      isArray: false
      name: columns
      predefined: [
        ]
      required: false
      secret: false
    - default: false
      defaultValue: ''
      description: Filter by the host name of a computer. Wild card is supported as
        '*'.
      isArray: false
      name: computerName
      predefined: [
        ]
      required: false
      secret: false
    - default: false
      defaultValue: ''
      description: Indicates when a computer last updated its status. The default
        value of 0 gets all the results.
      isArray: false
      name: lastUpdate
      predefined: [
        ]
      required: false
      secret: false
    - default: false
      defaultValue: ''
      description: Operating system to filter.
      isArray: false
      name: os
      predefined:
      - CentOs
      - Debian
      - Fedora
      - MacOSX
      - Oracle
      - OSX
      - RedHat
      - SUSE
      - Ubuntu
      - Win10
      - Win2K
      - Win7
      - Win8
      - WinEmb7
      - WinEmb8
      - WinEmb81
      - WinFundamental
      - WinNT
      - Win2K3
      - Win2K8
      - Win2K8R2
      - WinVista
      - WinXP
      - WinXPEmb
      - WinXPProf64
      required: false
      secret: false
    - default: false
      defaultValue: ''
      description: The number of results to include on each page. The default is 20.
      isArray: false
      name: pageSize
      predefined: [
        ]
      required: false
      secret: false
    description: Get information about endpoints.
    execution: false
    name: sep-endpoints-info
    outputs:
    - contextPath: SEPM.Endpoint.Hostname
      description: The endpoint's hostname.
      type: string
    - contextPath: SEPM.Endpoint.Domain
      description: The endpoint's domain.
      type: string
    - contextPath: SEPM.Endpoint.IPAddresses
      description: The endpoint's IP addresses.
      type: string
    - contextPath: SEPM.Endpoint.OS
      description: The endpoint's OS information.
      type: string
    - contextPath: SEPM.Endpoint.Description
      description: The endpoint's description.
      type: string
    - contextPath: SEPM.Endpoint.MACAddresses
      description: The endpoint's MAC address.
      type: string
    - contextPath: SEPM.Endpoint.BIOSVersion
      description: The endpoint's BIOS version.
      type: string
    - contextPath: SEPM.Endpoint.DHCPServer
      description: The endpoint's DHCP server address.
      type: string
    - contextPath: SEPM.Endpoint.HardwareKey
      description: ' Hardware-Key of the client to be moved'
      type: String
  - arguments:
    - default: false
      defaultValue: ''
      description: The columns to show.
      isArray: false
      name: columns
      predefined: [
        ]
      required: false
      secret: false
    description: Get information about groups.
    execution: false
    name: sep-groups-info
    outputs:
    - contextPath: SEPM.Groups
      description: The list of groups.
      type: Unknown
    - contextPath: SEPM.Groups.created
      description: Creation time in Epoch
      type: number
    - contextPath: SEPM.Groups.fullPathName
      description: Name of the group
      type: string
    - contextPath: SEPM.Groups.id
      description: ID of the group
      type: string
    - contextPath: SEPM.Groups.numberOfPhysicalComputers
      description: Number of physical computers in the group
      type: number
    - contextPath: SEPM.Groups.numberOfRegisteredUsers
      description: Number of registered users in the group
      type: number
    - contextPath: SEPM.Groups.policyDate
      description: Policy date in Epoch
      type: number
    - contextPath: SEPM.Groups.policySerialNumber
      description: Policy serial number
      type: number
  - arguments: [
      ]
    description: Get the system information (version, AV definition).
    execution: false
    name: sep-system-info
    outputs:
    - contextPath: SEPM.ServerAVDefVersion
      description: The serverAV definition version.
      type: string
  - arguments:
    - default: false
      defaultValue: ''
      description: The command ID.
      isArray: false
      name: commandId
      predefined: [
        ]
      required: true
      secret: false
    description: Retrieves the status of a command.
    execution: false
    name: sep-command-status
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: The details of the command.
      type: string
    - contextPath: SEPM.LastCommand.CommandId
      description: The ID of the command.
      type: string
  - arguments: [
      ]
    description: Retrieves the client content.
    execution: false
    name: sep-client-content
    outputs:
    - contextPath: SEPM.ClientContentVersions
      description: The versions of the clients.
      type: string
    - contextPath: SEPM.LastUpdated
      description: The last-updated date.
      type: string
  - arguments: [
      ]
    description: Retrieve a list of existing policies
    execution: false
    name: sep-list-policies
    outputs:
    - contextPath: SEPM.PoliciesList.PolicyName
      description: Name of policy
      type: string
    - contextPath: SEPM.PoliciesList.Type
      description: Policy type
      type: string
    - contextPath: SEPM.PoliciesList.ID
      description: Policy ID
      type: string
    - contextPath: SEPM.PoliciesList.Discription
      description: Policy discription
      type: string
    - contextPath: SEPM.PoliciesList.Enabled
      description: True if enabled false otherwise
      type: boolean
    - contextPath: SEPM.PoliciesList.AssignedLocations.GroupID
      description: 'Group ID of the locations assigned with this policy '
      type: string
    - contextPath: SEPM.PoliciesList.AssignedLocations.Locations
      description: List of locations IDs assigned with this policy
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.GroupID
      description: 'Cloud Group ID of the locations assigned with this policy '
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.Locations
      description: List of locations IDs belonging to a cloud group assigned with
        this policy
      type: string
  - arguments:
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: groupID
      predefined: [
        ]
      required: true
      secret: false
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: locationID
      predefined: [
        ]
      required: true
      secret: false
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: policyType
      predefined: [
        ]
      required: true
      secret: false
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: policyID
      predefined: [
        ]
      required: true
      secret: false
    description: Assign existing policy to a designated location
    execution: false
    name: sep-assign-policy
    outputs: [
      ]
  - arguments:
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: groupID
      predefined: [
        ]
      required: true
      secret: false
    description: Retrieve a list of location ID's for a given group
    execution: false
    name: sep-list-locations
    outputs:
    - contextPath: SEPM.Locations.ID
      description: The ID of the location
      type: Unknown
  - arguments:
    - default: false
      defaultValue: ''
      description: IP ro Hostname of the endpoint
      isArray: false
      name: endpoint
      predefined: [
        ]
      required: true
      secret: false
    - default: false
      defaultValue: ''
      description: Add or remove endpoint from quarantine.
      isArray: false
      name: actionType
      predefined:
      - Add
      - Remove
      required: true
      secret: false
    description: Quarantines the endpoint according to its policy.
    execution: false
    name: sep-endpoint-quarantine
    outputs:
    - contextPath: SEPM.Quarantine.CommandID
      description: ID of the invoked command
      type: string
    - contextPath: SEPM.Quarantine.Action
      description: The action type ('Add' or 'Remove')
      type: string
    - contextPath: SEPM.Quarantine.Endpoint
      description: The endpoint identifier (IP or Host Name)
      type: string
  - arguments:
    - default: false
      defaultValue: ''
      description: IP ro Hostname of the endpoint
      isArray: false
      name: endpoint
      predefined: [
        ]
      required: true
      secret: false
    - default: false
      defaultValue: ''
      description: Type of scan.
      isArray: false
      name: scanType
      predefined:
      - ScanNow_Quick
      - ScanNow_Full
      - ScanNow_Custom
      required: true
      secret: false
    description: Scans an endpoint.
    execution: false
    name: sep-scan-endpoint
    outputs:
    - contextPath: SEPM.Scan.CommandID
      description: ID of the invoked command
      type: string
    - contextPath: SEPM.Scan.Type
      description: Type of the scan (ScanNow_Quick, ScanNow_Full or ScanNow_Custom)
      type: string
    - contextPath: SEPM.Quarantine.Endpoint
      description: The endpoint identifier (IP or Host Name)
      type: Unknown
  - arguments:
    - default: false
      defaultValue: ''
      description: IP ro Hostname of the endpoint
      isArray: false
      name: endpoint
      predefined: [
        ]
      required: true
      secret: false
    description: Updates the content of the given client.
    execution: false
    name: sep-update-endpoint-content
    outputs: [
      ]
  - arguments:
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: groupID
      predefined: [
        ]
      required: true
      secret: false
    - default: false
      defaultValue: ''
      description: ''
      isArray: false
      name: hardwareKey
      predefined: [
        ]
      required: true
      secret: false
    description: Moves a client to a group
    execution: false
    name: sep-move-client-to-group
    outputs: [
      ]
  dockerimage: ''
  isfetch: false
  runonce: false
  script: |-
    from CommonServerPython import *
    from CommonServerUserPython import *
    import requests
    import json
    import re

    requests.packages.urllib3.disable_warnings()

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ENDPOINTS_INFO_DEFAULT_COLUMNS = [
        'computerName',
        'ipAddresses',
        'operatingSystem',
        'osBitness',
        'cidsDefsetVersion',
        'lastScanTime',
        'description',
        'quarantineDesc',
        'domainOrWorkgroup',
        'macAddresses',
        'group',
        'dhcpServer',
        'biosVersion',
        'virtualizationPlatform',
        'computerTimeStamp',
        'creationTime',
        'agentTimestamp',
        'hardwareKey'
    ]

    GROUPS_INFO_DEFAULT_COLUMNS = [
        'fullPathName',
        'numberOfPhysicalComputers',
        'numberOfRegisteredUsers',
        'policySerialNumber',
        'policyDate',
        'description',
        'created',
        'id'
    ]

    # @@@@@@@@@@@@@@@@@@@@@@@@@@    LITERALS    @@@@@@@@@@@@@@@@@@@@@@@@@@

    # TOKEN = demisto.getIntegrationContext().get('TOKEN')
    EPOCH_MINUTE = 60 * 1000
    EPOCH_HOUR = 60 * EPOCH_MINUTE


    # @@@@@@@@@@@@@@@@@@@@@@@@@@    HELPER FUNCTIONS    @@@@@@@@@@@@@@@@@@@@@@@@@@

    def fix_url(base):
        return base if base.endswith('/') else (base + '/')


    def build_query_params(params):
        list_params = map(lambda key: key + '=' + str(params[key]), params.keys())
        quert_params = '&'.join(list_params)
        return '?' + quert_params if quert_params else ''


    def do_auth(server, crads, insecure):
        url = fix_url(str(server)) + 'sepm/api/v1/identity/authenticate'
        body = {
            'username': crads.get('identifier') if crads.get('identifier') else '',
            'password': crads.get('password') if crads.get('password') else '',
            'domain': crads.get('domain') if crads.get('domain') else ''
        }
        res = requests.post(url, headers={"Content-Type": "application/json"}, data=json.dumps(body), verify=not insecure)
        return parse_response(res)


    def do_get(token, raw, suffix):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.get(url, headers={'Authorization': 'Bearer ' + token}, verify=not insecure)
        if (raw):
            return res
        else:
            return parse_response(res)


    def do_post(token, is_xml, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.post(url, headers={'Authorization': 'Bearer ' + token}, data=body, verify=not insecure)
        if (is_xml):
            parsed_response = xml2json(res.content)
        else:
            parsed_response = parse_response(res)
        return parsed_response


    def do_put(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.put(url, headers={'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify=not insecure)
        # res = requests.put('https://httpbin.org/put', headers = {'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify = not insecure)
        parsed_response = parse_response(res)
        return parsed_response

    def do_patch(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.patch(url, headers={'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify=not insecure)
        parsed_response = parse_response(res)
        return parsed_response

    def parse_response(resp):
        if resp.status_code == 200 or resp.status_code == 207:
            if resp.text == '':
                return resp
            try:
                return resp.json()
            except Exception, ex:
                return_error('Unable to parse response: {}'.format(ex))
        else:
            try:
                message = resp.json().get('errorMessage')
                return_error('Error: {}'.format(message))
            except Exception:
                return_error('Error: {}'.format(resp))


    def get_token_from_response(resp):
        if resp.get('token'):
            return resp.get('token')
        else:
            return_error('No token: {}'.format(resp))


    def choose_columns(column_arg, default_list):
        if not column_arg:
            columns_list = default_list
            columns_list.sort()
        elif column_arg == 'all' or column_arg == '*':
            columns_list = []
        else:
            columns_list = argToList(column_arg)
        return columns_list


    def build_command_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:com="http://command.client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def build_client_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cli="http://client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def get_command_status_details(token, command_id):
        xml = build_command_xml('<com:getCommandStatusDetails><commandID>{0}</commandID></com:getCommandStatusDetails>'.format(command_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)

        return res_json

    def build_command_response_output(title, command_id, message, response):
        cmd_status_details = response.get('cmdStatusDetail')
        cmd_status_details.pop('hardwareKey', None)

        md = tableToMarkdown(title, cmd_status_details) + '\n'
        md += '### Command ID: {0}\n'.format(command_id)
        md += '### ' + message;

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_details,
                'commandId': command_id

            },
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_details, 'CommandId': command_id}, removeNull=True)
            }
        })


    def get_computer_id_by_ip(token, ip):
        xml = build_client_xml('<cli:getComputersByIP><ipAddresses>{0}</ipAddresses></cli:getComputersByIP>'.format(ip))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)

        return demisto.get(json.loads(res_json), 'Envelope.Body.getComputersByIPResponse.ComputerResult.computers.computerId')


    def get_computer_id_by_hostname(token, hostname):
        xml = build_client_xml('<cli:getComputersByHostName><computerHostNames>{0}</computerHostNames></cli:getComputersByHostName>'.format(hostname))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)

        return demisto.get(json.loads(res_json), 'Envelope.Body.getComputersByHostNameResponse.ComputerResult.computers.computerId')


    def get_computer_id(token, endpoint_ip, endpoint_host_name):
        if endpoint_ip:
            try:
                computer_id = get_computer_id_by_ip(token, endpoint_ip)
            except Exception, ex:
                return_error('Failed to locate the endpoint by its IP address.')
        elif endpoint_host_name:
            try:
                computer_id = get_computer_id_by_hostname(token, endpoint_host_name)
            except Exception, ex:
                return_error('Failed to locat the endpoint by its hostname.')
        else:
            return_error('Please provide the IP address or the hostname of endpoint.')
        return computer_id


    def update_content(token, computer_id):
        xml = build_command_xml('<com:runClientCommandUpdateContent><computerGUIDList>{0}</computerGUIDList></com:runClientCommandUpdateContent>'.format(computer_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.commandId')

        if not command_id:
            error_code = demisto.get(res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def scan(token, computer_id, scan_type):
        xml = build_command_xml('<com:runClientCommandScan><computerGUIDList>{0}</computerGUIDList><scanType>{1}</scanType></com:runClientCommandScan>'.format(computer_id, scan_type))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.commandId')

        if not command_id:
            error_code = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def quarantine(token, computer_id, action_type):
        xml = build_command_xml(
            '<com:runClientCommandQuarantine><command><commandType>{0}</commandType><targetObjectIds>{1}</targetObjectIds><targetObjectType>COMPUTER</targetObjectType></command></com:runClientCommandQuarantine>'.format(
                action_type, computer_id));
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml);
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(res_json, 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(res_json, 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(error_message, error_code))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def validate_time_zone(time_zone):
        pattern = re.compile("^[+-][0-9][0-9]:[0-9][0-9]")
        return bool(pattern.match(time_zone))


    def parse_epoch_to_local(epoch, time_zone):
        if not validate_time_zone(time_zone):
            return_error('timeZone param should be in the format of [+/-][h][h]:[m][m]. For exmaple +04:30')
        operator = time_zone[0]
        hour = int(time_zone[1:3])
        minutes = int(time_zone[4:6])
        time_zone_epoch = hour * EPOCH_HOUR + minutes * EPOCH_MINUTE
        local = int(epoch) + time_zone_epoch if operator == '+' else int(epoch) - time_zone_epoch
        return local


    def change_assigined(policy):
        new_format = {
            'Policy Name': policy.get('PolicyName'),
            'Type': policy.get('Type'),
            'ID': policy.get('ID'),
            'Assigned': True if (policy.get('AssignedLocations') or policy.get('AssignedCloudGroups')) else False,
            'Discription': policy.get('Discription'),
            'Enabled': policy.get('Enabled')
        }
        return new_format


    def sanitize_policies_list_for_md(policies_list):
        return map(change_assigined, policies_list)


    def sanitize_policies_list(policies_list):
        return map(lambda policy: {
            'PolicyName': policy['name'],
            'Type': policy['policytype'],
            'ID': policy['id'],
            'Discription': policy['desc'],
            'Enabled': policy['enabled'],
            'AssignedLocations': map(lambda location: {
                'GroupID': location.get('groupId'),
                'Locations': location.get('locationIds')
            }, policy.get('assignedtolocations') if policy.get('assignedtolocations') else []),
            'AssignedCloudGroups': map(lambda location: {
                'GroupID': location.get('groupId'),
                'Locations': location.get('locationIds')
            }, policy.get('assignedtocloudgroups') if policy.get('assignedtocloudgroups') else []),
        }, policies_list)


    def validate_ip(ip):
        pattern = re.compile('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
        return bool(pattern.match(ip))


    # @@@@@@@@@@@@@@@@@@@@@@@@@@    COMMANDS    @@@@@@@@@@@@@@@@@@@@@@@@@@


    def system_info_command(token):
        insecure = demisto.getParam('insecure')
        version_json = do_get(token, False, 'sepm/api/v1/version')
        avdef_json = do_get(token, False, 'sepm/api/v1/content/avdef/latest')
        system_info_json = {
            'version': version_json,
            'avdef': avdef_json
        }

        md = '## System Information\n'
        md += tableToMarkdown('Version', version_json)
        md += tableToMarkdown('AV Definitions', avdef_json)

        context = avdef_json.get('publishedBySymantec')
        if type(context) is dict    :
            context = createContext(context, removeNull=True)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': system_info_json,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.ServerAVDefVersion': context
            }
        })


    def client_content_command(token):
        time_zone = demisto.getParam('timeZone')
        client_content_json = do_get(token, False, 'sepm/api/v1/stats/client/content')
        epoch_time = client_content_json.get('lastUpdated')
        if time_zone:
            epoch_time = parse_epoch_to_local(epoch_time, time_zone)
        # epoch_time = '1546185294597'
        # last_update_date = time.localtime(int(epoch_time) /1000)
        last_update_date = timestamp_to_datestring(epoch_time, '%a %b %d %y %H:%M:%S %z')
        client_version = client_content_json.get('clientDefStatusList')
        md = '## Client Content, last updated on {0}\n'.format(last_update_date)
        md += tableToMarkdown('Client Content Versions', client_version)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': client_content_json,
            'HumanReadable': md,
            # 'EntryContext': createContext({'SEPM': sepm_context}, removeNull=True)
            'EntryContext': {
                'SEPM.ClientContentVersions': client_version,
                'SEPM.LastUpdated': last_update_date

            }
        })


    def endpoints_info_command(token):
        computer_name = demisto.getArg('computerName')
        last_update = demisto.getArg('lastUpdate')
        os = demisto.getArg('os')
        page_size = demisto.getArg('pageSize')
        columns = demisto.getArg('columns')

        json_response = do_get(token, False, 'sepm/api/v1/computers' + build_query_params(demisto.args()))

        md = '## Endpoints Information'
        md += ', filtered for last updated status: {}'.format(last_update) if last_update else ''
        md += ', filtered for hostname: {}'.format(computer_name) if computer_name else ''
        md += ', filtered for os: {}'.format(os) if os else ''
        md += ', page size: {}'.format(page_size) if page_size else ''
        md += '\n'

        entry_context = []
        filtered_json_response = json_response.get('content')
        for content in filtered_json_response:
            entry_context.append({
                'Hostname': content.get('computerName'),
                'Domain': content.get('domainOrWorkgroup'),
                'IPAddresses': content.get('ipAddresses'),
                'OS': content.get('operatingSystem') + ' | ' + content.get('osBitness'),
                'Description': content.get('content.description'),
                'MACAddresses': content.get('macAddresses'),
                'BIOSVesrsion': content.get('biosVersion'),
                'DHCPServer': content.get('dhcpServer'),
                'HardwareKey': content.get('hardwareKey')
            })

        columns_list = choose_columns(columns, ENDPOINTS_INFO_DEFAULT_COLUMNS)

        md += tableToMarkdown('Endpoints', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': filtered_json_response,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Endpoint(val.Hostname: == obj.Hostname:)': createContext(entry_context, removeNull=True)
            }
        })


    def groups_info_command(token):
        columns = demisto.getArg('columns')
        json_res = do_get(token, False, 'sepm/api/v1/groups' + build_query_params(demisto.args()))
        sepm_groups = []
        filtered_json_response = json_res.get('content')
        for entry in filtered_json_response:
            group = {}
            for header in GROUPS_INFO_DEFAULT_COLUMNS:
                group[header] = entry[header]
                sepm_groups.append(group)
        default_headers = GROUPS_INFO_DEFAULT_COLUMNS
        columns_list = choose_columns(columns, default_headers)

        md = tableToMarkdown('Groups Information', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': json_res,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext':
                {
                    'SEPM.Groups': sepm_groups
                }
        })


    def command_status(token):
        command_id = demisto.getArg('commandId')

        command_status_json = get_command_status_details(token, command_id)
        cmd_status_detail = demisto.get(json.loads(command_status_json), 'Envelope.Body.getCommandStatusDetailsResponse.CommandStatusDetailResult.cmdStatusDetail')
        cmd_status_detail.pop('hardwareKey', None)

        state_id = cmd_status_detail.get('stateId')
        is_done = False
        if state_id == '2' or state_id == '3':
            is_done = True
        message = 'Command is done.' if is_done else 'Command is in progress. Run !sep-command-status to check again.';

        # md = tableToMarkdown(title, cmd_status_details) + '\n'
        md = '### Command ID: {0}\n'.format(command_id)
        md += '### State ID: {0}\n'.format(cmd_status_detail.get('stateId'))
        md += '### ' + message;

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_detail,
                'commandId': command_id
            },
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_detail, 'CommandID': command_id}, removeNull=True)
            }
        })

    def list_policies_command(token):
        policies_list = do_get(token, False, 'sepm/api/v1/policies/summary').get('content')

        fixed_policie_list = sanitize_policies_list(policies_list)
        md_list = sanitize_policies_list_for_md(fixed_policie_list)
        md = tableToMarkdown('List of existing policies', md_list, ['Policy Name', 'Type', 'ID', 'Enabled', 'Assigned', 'Discription'])
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': policies_list,
            'HumanReadable': md,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.PoliciesList': createContext(fixed_policie_list, removeNull=True)
            }
        })


    def assign_policie_command(token):
        group_id = demisto.getArg('groupID')
        locatoion_id = demisto.getArg('locationID')
        policy_type = demisto.getArg('policyType').lower()
        policy_id = demisto.getArg('policyID')
        resp = do_put(token, 'sepm/api/v1/groups/{0}/locations/{1}/policies/{2}'.format(group_id, locatoion_id, policy_type), {'id': policy_id})
        md = '### Policy: {0}, of type: {1}, was assigned to location: {2}, in group: {3}'.format(policy_id, policy_type, locatoion_id, group_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': '',
            'HumanReadable': md,
            'EntryContext': {}
        })


    def list_locations_command(token):
        group_id = demisto.getArg('groupID')
        url = 'sepm/api/v1/groups/{}/locations'.format(group_id)
        url_resp = do_get(token, False, url)
        location_ids = map(lambda location_string: {'ID': location_string.split('/')[-1]}, url_resp)
        # demisto.results(location_ids )
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': url_resp,
            'HumanReadable': tableToMarkdown('Locations', map(lambda location: {'Location ID': location.get('ID')}, location_ids)),
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Locations': location_ids
            }
        })


    def endpoint_quarantine_command(token):
        endpoint = demisto.getArg('endpoint')
        action = demisto.getArg('actionType')
        action_type = 'Quarantine' if action == 'Add' else 'Undo'

        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)
        command_id = quarantine(token, computer_id, action_type)
        message = '### Initiated quarantine for endpoint {0}. Command ID: {1}.'.format(endpoint, command_id) if action == 'Add' else '### Removing endpoint: {0} from quarantine. Command ID: {1}.'.format(
            endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Action': action,
            'Endpoint': endpoint
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Quarantine': context
            }
        })


    def scan_endpoint_command(token):
        endpoint = demisto.getArg('endpoint')
        scan_type = demisto.getArg('scanType')

        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)
        command_id = scan(token, computer_id, scan_type)
        message = '### Initiated scan on endpoint: {0} with type: {1}. Command ID: {2}.'.format(endpoint, scan_type, command_id)
        context = {
            'CommandID': command_id,
            'Type': scan_type,
            'Endpoint': endpoint
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Scan': context
            }
        })


    def update_endpoint_content_command(token):
        endpoint = demisto.getArg('endpoint')
        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)

        command_id = update_content(token, computer_id)
        message = '### Updating endpoint: {0}. Command ID: {1}.'.format(endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Endpoint': endpoint
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'IgnoreAutoExtract': True,
            'EntryContext': {
                'SEPM.Update': context
            }
        })

    def move_client_to_group_command(token):
        group_id = demisto.getArg('groupID')
        hardware_key = demisto.getArg('hardwareKey')
        body = [{
            'group': {
                'id': group_id
            },
            'hardwareKey': hardware_key
        }]
        response = do_patch(token, 'sepm/api/v1/computers', body)
        message = '### Moved client to requested group successfully' \
            if response[0].get('responseCode') == '200' \
            else '### Error moving client'
        demisto.results(
                {
                    'Type': entryTypes['note'],
                    'ContentsFormat': formats['text'],
                    'Contents': response,
                    'HumanReadable': message,
                    'IgnoreAutoExtract': True,
                })


    # @@@@@@@@@@@@@@@@@@@@@@@@@@    COMMANDS SWITCH    @@@@@@@@@@@@@@@@@@@@@@@@@@
    current_command = demisto.command()
    try:
        '''
        Before EVERY command the follwing tow lines are performed (do_auth and get_token_from_response)
        '''
        resp = do_auth(server=demisto.getParam('server'), crads=demisto.getParam('authentication'), insecure=demisto.getParam('insecure'))
        token = get_token_from_response(resp)
        if current_command == 'test-module':
            # This is the call made when pressing the integration test button.
            if token:
                demisto.results('ok')
        if current_command == 'sep-system-info':
            system_info_command(token)
        if current_command == 'sep-client-content':
            client_content_command(token)
        if current_command == 'sep-endpoints-info':
            endpoints_info_command(token)
        if current_command == 'sep-groups-info':
            groups_info_command(token)
        if current_command == 'sep-command-status':
            command_status(token)
        if current_command == 'sep-list-policies':
            list_policies_command(token)
        if current_command == 'sep-assign-policy':
            assign_policie_command(token)
        if current_command == 'sep-list-locations':
            list_locations_command(token)
        if current_command == 'sep-endpoint-quarantine':
            endpoint_quarantine_command(token)
        if current_command == 'sep-scan-endpoint':
            scan_endpoint_command(token)
        if current_command == 'sep-update-endpoint-content':
            update_endpoint_content_command(token)
        if current_command == 'sep-move-client-to-group':
            move_client_to_group_command(token)

    except Exception, ex:
        demisto.results('Cannot perform the command: {}. Error'.format(current_command))
  type: python
image: data:image/png;base64,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
releaseNotes: Enhancments for the integration. New commands sep-list-policies - Retrieve
  a list of existing policies, sep-assign-policie - Assign existing policy to a designated
  location. sep-list-locations - Retrieve a list of location ID's for a given group.
  sep-endpoint-quarantine - Quarantines the endpoint according to its policy. sep-scan-endpoint
  - Scans an endpoint. sep-update-endpoint-content - Updates the content of the given
  client.
tests:
- SymantecEndpointProtection Test
