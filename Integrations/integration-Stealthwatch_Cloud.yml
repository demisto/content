commonfields:
  id: Stealthwatch Cloud
  version: -1
name: Stealthwatch Cloud
display: Stealthwatch Cloud
category: Network Security
image: data:image/png;base64,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
description: Protect your cloud assets and private network
configuration:
- display: Stealthwatch's server URL
  name: serverURL
  defaultvalue: ""
  type: 0
  required: true
- display: Stealthwatch Cloud API key. Should be in the form of "ApiKey <username>:<api_key>"
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: proxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |+
    ''' IMPORTS '''
    import requests
    import json
    import os
    from datetime import datetime, timedelta
    import collections

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    SERVER = demisto.params().get('serverURL')[:-1] if demisto.params().get('serverURL').endswith('/') else demisto.params().get('serverURL')
    SERVER_URL=SERVER + '/api/v3'
    API_KEY=demisto.params()['APIKey']

    USE_SSL = not demisto.params().get('insecure')

    DEFAULT_HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': API_KEY
    }

    ''' HELPER FUNCTIONS '''

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    def http_request(method, url_suffix, params_dict, headers, data=None):
        req_params = {
        }
        if params_dict is not None:
            req_params.update(params_dict)

        url = SERVER_URL + url_suffix

        LOG('running %s request with url=%s\theaders=%s\nparams=%s' % (method, url, headers, json.dumps(req_params)))

        try:
            res = requests.request(method,
                url,
                verify=USE_SSL,
                params=req_params,
                headers=headers,
                data=data
            )
            res.raise_for_status()
            try:
                return res.json()
            except ValueError:
                # in case the response doesn't have JSON
                return "Request completed"
        except Exception, e:
            LOG(e)
            raise(e)

    def underscore_to_camelcase(word):
        return ' '.join(x.capitalize() or '_' for x in word.split('_'))

    def create_incident_data_from_alert(alert):
        alert.pop('comments')
        alert.pop('observations')
        return {
            'name': 'Stealthwatch alert ' + str(alert.get('id', '')),
            'rawJSON': json.dumps(alert),
            'occurred': alert.get('created', '')
        }

    def get_latest_id(alerts_data):
        latest_id = 0
        for alert in alerts_data:
            current_id = alert.get('id', None)
            if current_id is not None and current_id > latest_id:
                latest_id = current_id

        return latest_id

        ''' COMMANDS FUNCTIONS '''

    def show_alert(alert_id):
        """
        Returns alert by specific id
        """

        api_endpoint = "/alerts/alert/{}/".format(alert_id)
        return http_request('GET', api_endpoint, {}, DEFAULT_HEADERS)

    def show_alert_command():
        """
        corresponds to 'sw-show-alert' command. Returns information about a specific alert
        """
        alert_id = demisto.args().get('alertID')

        alert_data = show_alert(alert_id)

        if not demisto.args().get('addComments', False) == 'true':
            alert_data.pop('comments')
            alert_data.pop('new_comment')

        alert_data.pop('observations')

        list_for_md = ['resolved','id', 'last_modified', 'obj_created', 'assigned_to']

        dict_for_md = {underscore_to_camelcase(k):v for k,v in alert_data.iteritems() if k in list_for_md}
        md = tableToMarkdown(alert_data.get('text',''), dict_for_md)

        return {
            'Type': entryTypes['note'],
            'Contents': alert_data,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                "Stealthwatch.Alert(val.id==obj.id)": alert_data
            }
        }

    def update_alert(alert_id, params):
        """
        Updates alert by specific id
        """

        api_endpoint = "/alerts/alert/{}/".format(alert_id)
        return http_request('PUT', api_endpoint, params, DEFAULT_HEADERS)

    def update_alert_command():
        """
        corresponds to 'sw-update-alert' command. Returns information about a specific alert
        """
        args = demisto.args()
        alert_id = args.get('alertID')
        update_params = {}
        # adding the possible params for update
        possible_params = ['new_comment', 'tags', 'publish_time', 'resolved', 'snooze_settings', 'merit', 'assigned_to']
        for param in possible_params:
            current_param = args.get(param, False)
            if current_param:
                update_params[param] = current_param
        username = args.get('resolved_user', None)
        if username is not None:
            update_params['resolved_user'] = {
                'username': username
            }

        alert_data = update_alert(alert_id, update_params)

        alert_data.pop('comments')
        alert_data.pop('new_comment')
        alert_data.pop('observations')

        list_for_md = ['resolved','id', 'last_modified', 'obj_created', 'assigned_to']

        dict_for_md = {k:v for k,v in alert_data.iteritems() if k in list_for_md}
        md = tableToMarkdown(alert_data.get('text',''), dict_for_md)

        return {
            'Type': entryTypes['note'],
            'Contents': alert_data,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                "Stealthwatch.Alert(val.id==obj.id)": alert_data
            }
        }

    def list_alerts(params):
        """
        Retrieves alerts
        """

        api_endpoint = "/alerts/alert/"
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)

    def build_alert_dic(alert):
        dic = collections.OrderedDict()
        list_for_md = ['id', 'last_modified', 'resolved', 'text', 'obj_created', 'assigned_to', 'description']
        for item in list_for_md:
            dic[underscore_to_camelcase(item)] = alert[item]

        return dic

    def list_alerts_command():
        """
        corresponds to 'sw-list-alerts' command. Returns a list of Stealthwatch alerts
        """
        args = demisto.args()
        alert_id = args.get('alertID')
        list_params = {}
        # adding the possible params for update
        possible_params = ['status', 'tags', 'search', 'assignee', 'limit']
        for param in possible_params:
            current_param = args.get(param, False)
            if current_param:
                list_params[param] = current_param

        alerts_data = list_alerts(list_params).get('objects')
        md_dicts_list = []

        for alert in alerts_data:
            if not demisto.args().get('addComments', False) == 'true':
                alert.pop('comments')
                alert.pop('new_comment')
            alert.pop('observations')
            md_dicts_list.append(build_alert_dic(alert))

        md = tableToMarkdown("The following alerts were retrieved", md_dicts_list)
        return {
            'Type': entryTypes['note'],
            'Contents': alerts_data,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                "Stealthwatch.Alert(val.id==obj.id)": alerts_data
            }
        }

    def domain_block(params):
        """
        Updates domain blacklist status
        """

        api_endpoint = "/blacklist/domains/"
        return http_request('POST', api_endpoint, {}, DEFAULT_HEADERS, params)

    def block_domain_command():
        """
        corresponds to 'sw-block-domain-or-ip' command. Adds a domain to the blacklist
        """
        domain = demisto.args().get('domain')
        ip = demisto.args().get('ip')

        if not (domain or ip):
            return {
                "Type" : entryTypes["error"],
                "ContentsFormat" : formats["text"],
                "Contents" : 'Please enter either domain or ip'
            }


        if domain and ip:
            return {
                "Type" : entryTypes["error"],
                "ContentsFormat" : formats["text"],
                "Contents" : 'Please enter only domain or ip, not both'
            }

        identifier = None
        if domain:
            identifier = domain
        else:
            identifier = ip

        domain_params = {
            "identifier": identifier,
            "category": "domain",
            "list_on": "blacklist"
        }

        domain_result = domain_block(json.dumps(domain_params))

        ec = None

        if domain:
            ec = {
                "Stealthwatch.Domain(val.identifier==obj.identifier)": domain_result
            }
        else:
            ec = {
                "Stealthwatch.IP(val.identifier==obj.identifier)": domain_result
            }

        return {
            'Type': entryTypes['note'],
            'Contents': domain_result,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Blacklist ' + domain + ' result', domain_result),
            'EntryContext': ec
        }

    def domain_unblock(domain_id):
        """
        Removes domain from the blacklist
        """

        api_endpoint = "/blacklist/domains/{}/".format(domain_id)
        return http_request('DELETE', api_endpoint, None, DEFAULT_HEADERS, None)

    def unblock_domain_command():
        """
        corresponds to 'sw-unblock-domain' command. Removes a domain to the blacklist
        """
        domain_id = demisto.args().get('id')

        domain_result = domain_unblock(domain_id)

        return {
            'Type': entryTypes['note'],
            'Contents': domain_result,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Unblocked domain with id: ' + domain_id,
        }

    def list_domains(list_params):
        """
        Lists blacklisted domains
        """

        api_endpoint = "/blacklist/domains/"
        return http_request('GET', api_endpoint, list_params, DEFAULT_HEADERS, {})

    def list_blocked_domains_command():
        """
        corresponds to 'sw-list-blocked-domains' command. Returns a list of the blocked domains
        """
        args = demisto.args()
        list_params = {}
        # adding the possible params for update
        possible_params = ['search', 'limit']
        for param in possible_params:
            current_param = args.get(param, False)
            if current_param:
                list_params[param] = current_param

        specific_domain = args.get('domain', None)
        if specific_domain is not None:
            list_params['identifier'] = specific_domain

        domains_data = list_domains(list_params)

        domains_result = domains_data.get('objects', {})

        data_output = []
        for obs in domains_result:
            data_output.append({underscore_to_camelcase(k):v for k, v in obs.items()})

        return {
            'Type': entryTypes['note'],
            'Contents': domains_data,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Current blacklisted domains are', data_output),
            'EntryContext': {
                "Stealthwatch.Domain(val.identifier==obj.identifier)": domains_result
            }
        }

    def list_observations(params):
        """
        Lists observations
        """

        api_endpoint = "/observations/all/"
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)

    def list_observations_command():
        """
        corresponds to 'sw-list-observations' command. Returns a list of Stealthwatch observations
        """
        args = demisto.args()
        list_params = {
            "order_by": 'creation_time'
        }
        # adding the possible params for update
        possible_params = ['alert', 'id', 'search', 'limit']
        for param in possible_params:
            current_param = args.get(param, False)
            if current_param:
                list_params[param] = current_param

        observations_data = list_observations(list_params).get('objects')

        data_output = []
        for obs in observations_data:
            data_output.append({underscore_to_camelcase(k):v for k, v in obs.items()})

        return {
            'Type': entryTypes['note'],
            'Contents': data_output,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Found the following observations', data_output),
            'EntryContext': {
                "Stealthwatch.Observation(val.id==obj.id)": observations_data
            }
        }

    def list_sessions(params):
        """
        Lists observations
        """

        api_endpoint = "/snapshots/session-data/"
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)

    def list_sessions_command():
        """
        corresponds to 'sw-list-sessions' command. Returns a list of Stealthwatch
        sessions
        """
        date_format = "%Y-%m-%dT%H:%M:%SZ"
        list_params = {}

        ip = demisto.args().get('ip')
        connected_ip = demisto.args().get('connectedIP')
        connected_device_id = demisto.args().get('connectedDeviceId')
        limit = demisto.args().get('limit')
        start_time = demisto.args().get('startTime', None)
        end_time = demisto.args().get('endTime', None)
        session_type = demisto.args().get('sessionType', 'all')

        if start_time and end_time:
            list_params['start_datetime'] = start_time
            list_params['end_datetime'] = end_time
        elif end_time is None:
            start_time_object = datetime.strptime(start_time, date_format)
            start_time_object = start_time_object - timedelta(minutes=5)
            end_time_object = start_time_object + timedelta(minutes=5)
            start_time = start_time_object.strftime(date_format)
            end_time = end_time_object.strftime(date_format)

        list_params['ip'] = ip
        list_params['connected_ip'] = connected_ip
        list_params['limit'] = limit
        list_params['start_datetime'] = start_time
        list_params['end_datetime'] = end_time
        list_params['connected_device_id'] = connected_device_id

        unique_session_ids = []
        final_sessions_data = []
        sessions_data = list_sessions(list_params).get('objects')
        for sess in sessions_data:
            if sess['connected_ip'] not in unique_session_ids:
                unique_session_ids.append(sess['connected_ip'])
                if demisto.get(sess, 'connected_device_id'):
                    sess['connected_device_is_external'] = False
                    if session_type == 'internal':
                        final_sessions_data.append(sess)
                else:
                    sess['connected_device_is_external'] = True
                    if session_type == 'external':
                        final_sessions_data.append(sess)
                if session_type == 'all':
                    final_sessions_data.append(sess)

        data_output = []
        for sess in final_sessions_data:
            data_output.append({underscore_to_camelcase(k):v for k, v in sess.items()})

        return {
            'Type': entryTypes['note'],
            'Contents': data_output,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Found the following session data', data_output),
            'EntryContext': {
                "Stealthwatch.Session(val.id==obj.id)": final_sessions_data
            }
        }

    def fetch_incidents():

        list_params = {
            "order_by": 'newest',
            "limit": 100
        }
        final_alerts = []

        known_ids = demisto.getLastRun().get('ids',None)
        if known_ids is None or not known_ids:
            known_ids = []

        alerts_response = list_alerts(list_params)

        alerts_data = alerts_response.get('objects', None)

        for alert in alerts_data:
            current_alert_id = alert.get('id')
            if current_alert_id not in known_ids:
                incident_from_alert = create_incident_data_from_alert(alert)
                final_alerts.append(incident_from_alert)

                # maintaining queue of 100 last seen alert ids
                if len(known_ids) >= 100:
                    known_ids.pop(0)
                known_ids.append(current_alert_id)

        demisto.setLastRun({
            'ids': known_ids
        })
        demisto.incidents(final_alerts)

    ''' EXECUTION CODE '''
    try:
        if demisto.command() == 'test-module':
            #This is the call made when pressing the integration test button.
            if list_alerts_command():
                demisto.results('ok')
            else:
                demisto.results('test failed')
        elif demisto.command() == 'sw-show-alert':
            demisto.results(show_alert_command())
        elif demisto.command() == 'sw-update-alert':
            demisto.results(update_alert_command())
        elif demisto.command() == 'sw-list-alerts':
            demisto.results(list_alerts_command())
        elif demisto.command() == 'sw-block-domain-or-ip':
            demisto.results(block_domain_command())
        elif demisto.command() == 'sw-unblock-domain':
            demisto.results(unblock_domain_command())
        elif demisto.command() == 'sw-list-blocked-domains':
            demisto.results(list_blocked_domains_command())
        elif demisto.command() == 'sw-list-observations':
            demisto.results(list_observations_command())
        elif demisto.command() == 'sw-list-sessions':
            demisto.results(list_sessions_command())
        elif demisto.command() == 'fetch-incidents':
            demisto.results(fetch_incidents())
    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise

  type: python
  commands:
  - name: sw-show-alert
    arguments:
    - name: alertID
      required: true
      description: The id of the required alert
    - name: addComments
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Add comments information, can be long
      defaultValue: "false"
    outputs:
    - contextPath: Stealthwatch.Alert.id
      description: Alert's id
      type: number
    - contextPath: Stealthwatch.Alert.assigned_to
      description: Alert's assignee
      type: string
    - contextPath: Stealthwatch.Alert.obj_created
      description: Alert's creation date
      type: date
    - contextPath: Stealthwatch.Alert.last_modified
      description: Alert's last modification
      type: date
    - contextPath: Stealthwatch.Alert.resolved
      description: 'Alert''s state '
      type: boolean
    - contextPath: Stealthwatch.Alert.source_info.ips
      description: IP of the alert's source
      type: string
    - contextPath: Stealthwatch.Alert.source_info.hostnames
      description: Hostname of the alert's source
      type: string
    description: Get info about a specific alert by its ID
  - name: sw-update-alert
    arguments:
    - name: alertID
      required: true
      description: The id of the alert for update
    - name: resolved
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Set the resolved field to true and set the merit field to close
        an alert. merit can be 8 ("helpful") or 9 ("not helpful").
    - name: merit
      auto: PREDEFINED
      predefined:
      - "0"
      - "1"
      - "2"
      - "3"
      - "4"
      - "5"
      - "6"
      - "8"
      - "9"
      description: Set the resolved field to true and set the merit field to close
        an alert. merit can be 8 ("helpful") or 9 ("not helpful").
    - name: tags
      description: Tags (string)
    - name: new_comment
      description: Set the new_comment field to add a comment to the alert.
    - name: publish_time
      description: Publish time (string). Example, publish_time=2018-08-01T07:54:39Z
    - name: snooze_settings
      description: Snooze settings (string)
    - name: resolved_user
      description: 'Username (string) '
    - name: assigned_to
      description: Assigned to (integer)
    outputs:
    - contextPath: Stealthwatch.Alert.id
      description: Alert's id
      type: number
    - contextPath: Stealthwatch.Alert.assigned_to
      description: Alert's assignee
      type: string
    - contextPath: Stealthwatch.Alert.obj_created
      description: Alert's creation date
      type: date
    - contextPath: Stealthwatch.Alert.last_modified
      description: Alert's last modification
      type: date
    - contextPath: Stealthwatch.Alert.resolved
      description: 'Alert''s state '
      type: boolean
    - contextPath: Stealthwatch.Alert.source_info.ips
      description: IP of the alert's source
      type: string
    - contextPath: Stealthwatch.Alert.source_info.hostname
      description: Hostname of the alert's source
      type: string
    description: Update an alert
  - name: sw-list-alerts
    arguments:
    - name: status
      auto: PREDEFINED
      predefined:
      - open
      - closed
      - all
      description: 'status filters alerts by status: open, closed, or all. Default
        is open. all allows you to see an individual alert regardless of whether it''s
        open or closed.'
    - name: search
      description: search finds a particular string amongst the alerts. For example,
        a particular IP address, hostname, or alert type.
    - name: assignee
      description: assignee filters shows only alerts assigned to a particular user.
    - name: tags
      description: tags shows alerts that are assigned a particular incident tag.
    - name: limit
      description: Amount of alerts to list. Default is 5
      defaultValue: "5"
    - name: addComments
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Add comments information, can be long
      defaultValue: "false"
    outputs:
    - contextPath: Stealthwatch.Alert.id
      description: Alert's id
      type: number
    - contextPath: Stealthwatch.Alert.assigned_to
      description: Alert's assignee
      type: string
    - contextPath: Stealthwatch.Alert.obj_created
      description: Alert's creation date
      type: date
    - contextPath: Stealthwatch.Alert.last_modified
      description: Alert's last modification
      type: date
    - contextPath: Stealthwatch.Alert.resolved
      description: 'Alert''s state '
      type: boolean
    - contextPath: Stealthwatch.Alert.source_info.ips
      description: IP of the alert's source
      type: string
    - contextPath: Stealthwatch.Alert.source_info.hostname
      description: Hostname of the alert's source
      type: string
    description: Get the list of Stealthwatch alerts
  - name: sw-block-domain-or-ip
    arguments:
    - name: domain
      description: Domain to add to the blacklist
    - name: ip
      description: IP to add to the blacklist
    outputs:
    - contextPath: Stealthwatch.Domain.identifier
      description: Domain name
      type: string
    - contextPath: Stealthwatch.Domain.title
      description: Domain title
      type: string
    - contextPath: Stealthwatch.Domain.id
      description: Domain id
      type: number
    - contextPath: Stealthwatch.IP.identifier
      description: IP address
      type: string
    - contextPath: Stealthwatch.IP.title
      description: IP title
      type: string
    - contextPath: Stealthwatch.IP.id
      description: IP id
      type: string
    description: Add a domain or IP to the blacklist
  - name: sw-unblock-domain
    arguments:
    - name: id
      required: true
      description: ID of the domain to remove from the blacklist. You can find the
        id using 'sw-list-blocked-domains'
    description: Remove a domain from the blacklist
  - name: sw-list-blocked-domains
    arguments:
    - name: search
      description: search finds a particular string amongst the alerts. For example,
        a particular IP address, hostname, or alert type.
    - name: domain
      description: Search for specific domain
    - name: limit
      description: Amount of domains to list. Default is 5
      defaultValue: "5"
    outputs:
    - contextPath: Stealthwatch.Domain.identifier
      description: Domain name
      type: string
    - contextPath: Stealthwatch.Domain.title
      description: Domain title
      type: string
    - contextPath: Stealthwatch.Domain.id
      description: Domain id
      type: number
    description: ' Returns list of the blocked domains'
  - name: sw-list-observations
    arguments:
    - name: search
      description: search finds a particular string amongst the alerts. For example,
        a particular IP address, hostname, or alert type.
    - name: alert
      description: Use the alert query parameter with an alert id to only show observations
        referenced by the alert.
    - name: id
      description: Get a specific observation by its id
    - name: limit
      description: Amount of observations to list. Default is 5
      defaultValue: "5"
    outputs:
    - contextPath: Stealthwatch.Observation.id
      description: Observation ID
      type: number
    - contextPath: Stealthwatch.Observation.port_count
      description: Observation port count
      type: number
    - contextPath: Stealthwatch.Observation.creation_time
      description: Observation creation time
      type: string
    - contextPath: Stealthwatch.Observation.end_time
      description: Observation end time
      type: string
    - contextPath: Stealthwatch.Observation.scanned_ip
      description: Observation scanned ip
      type: string
    - contextPath: Stealthwatch.Observation.scanner_ip
      description: Observation scanner ip
      type: string
    - contextPath: Stealthwatch.Observation.source
      description: Observation source
      type: unknown
    description: Get observations by alert ID, observation ID, or free search
  - name: sw-list-sessions
    arguments:
    - name: startTime
      required: true
      description: Session's start time (UTC). For example, startTime="2018-09-30T12:00:00Z"
    - name: endTime
      description: Session's end time (UTC). For example, endTime="2018-07-31T15:00:00Z"
    - name: limit
      description: Amount of observations to list. Default is 400
      defaultValue: "400"
    - name: ip
      description: Source IP address to filter by
    - name: connectedIP
      description: Connected IP to filter by
    - name: connectedDeviceId
      description: Connected device ID
    - name: sessionType
      auto: PREDEFINED
      predefined:
      - all
      - external
      - internal
      description: Select type of session - external/internal to receive data only
        about this kind of session
      defaultValue: all
    outputs:
    - contextPath: Stealthwatch.Session.id
      description: Session ID
      type: number
    - contextPath: Stealthwatch.Session.port
      description: Session port
      type: number
    - contextPath: Stealthwatch.Session.start_timestamp_utc
      description: Session start time
      type: string
    - contextPath: Stealthwatch.Session.ip
      description: Session IP
      type: string
    - contextPath: Stealthwatch.Session.connected_ip
      description: Session connected IP
      type: string
    - contextPath: Stealthwatch.Session.device_id
      description: Source device ID
      type: number
    - contextPath: Stealthwatch.Session.connected_device_id
      description: Connected device ID
      type: number
    - contextPath: Stealthwatch.Session.connected_device_is_external
      description: Is the connected device external
      type: boolean
    description: 'Get sessions by the session''s occurrence time ( Time format: YYYY-MM-DDTHH:MM:SSZ)'
  isfetch: true
  runonce: false
releaseNotes: "-"
tests:
- No test
