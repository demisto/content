import demistomock as demisto
from CommonServerPython import *
from CommonServerUserPython import *
""" IMPORTS """

import requests
from requests_oauthlib import OAuth2Session
from oauthlib.oauth2 import BackendApplicationClient
import json
import sys
import traceback
import time
from typing import Dict

# Disable insecure warnings
requests.packages.urllib3.disable_warnings()


# Get OAuth2 token
def NEBULA_URL(path):
    return "{NEBULA_URL}{PATH}".format(NEBULA_URL="https://cloud.malwarebytes.com", PATH=path)


def get_nebula_client(client_id, client_secret, account_id):
    client_scope = ["read", "write", "execute"]
    headers = {"x-mwb-clientid": client_id,
               "x-mwb-accountid": account_id}

    client = BackendApplicationClient(client_id, scope=client_scope)
    nebula = OAuth2Session(client=client, scope=client_scope)
    nebula.headers.update(headers)
    token = nebula.fetch_token(
        token_url=NEBULA_URL('/oauth2/token'),
        client_secret=client_secret, scope=client_scope)

    return "Bearer " + token['access_token']


# Test connectivity to the Nebula cloud
def test_connectivity(account_id, client_id, auth_token):

    url = 'https://cloud.malwarebytes.com/api/v2/endpoints'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }
    response = requests.request("GET", url, headers=headers)

    if response.status_code == 200:
        return True
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on testing connectivity", error='')


# Get all the endpoints from the Malwarebytes Cloud
def get_all_endpoints(account_id, client_id, auth_token):

    url = 'https://cloud.malwarebytes.com/api/v2/endpoints'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }
    response = requests.request("GET", url, headers=headers)

    if response.status_code == 200:

        machine = response.text
        machine = json.loads(machine)
        machines = machine['machines']
        cursor = machine['next_cursor']
        while cursor != "":
            cursor_temp, machines_temp = get_all_endpoints_paginated(account_id, client_id, auth_token, cursor)
            machines.extend(machines_temp)
            cursor = cursor_temp
        return machines
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting All Endpoints", error='')


def get_all_endpoints_paginated(account_id, client_id, auth_token, cursor):

    url = 'https://cloud.malwarebytes.com/api/v2/endpoints?next_cursor=' + cursor

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }
    response = requests.request("GET", url, headers=headers)

    if response.status_code == 200:
        machine = response.text
        machine = json.loads(machine)
        machines = machine['machines']
        cursor = machine['next_cursor']
        return cursor, machines
    else:
        return False


# Get the scan status to acquire the scan info
def get_scan_status(account_id, client_id, auth_token, job_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs/' + str(job_id)
    response = requests.request("GET", url, headers=headers)
    if response.status_code == 200:
        scan_status = response.text
        scan_status = json.loads(scan_status)
        scan_status = scan_status['state']
        return scan_status
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting Scan Status", error='')


# Get the scanid for the scan jobs initiated
def get_scan_id(account_id, client_id, auth_token, job_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs/' + str(job_id)
    response = requests.request("GET", url, headers=headers)
    if response.status_code == 200:
        scan_id = response.text
        scan_id = json.loads(scan_id)
        scan_id = scan_id['scan_id']
        return scan_id
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting Scan ID", error='')


# Get the machine_id associated with scan_id
def get_scan_id_machine(account_id, client_id, auth_token, job_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs/' + str(job_id)
    response = requests.request("GET", url, headers=headers)
    if response.status_code == 200:
        scan_id = response.text
        scan_id = json.loads(scan_id)
        machine_id = scan_id['machine_id']
        return machine_id
    else:
        return_error(message="HTTP Error: " + str(response.status_code)
                             + " on getting Machine ID associated with Scan ID", error='')


# Get detections for the scan jobs initiated
def get_scan_detections(account_id, client_id, auth_token, ids, scan_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints/' + str(ids) + '/scans/' + str(scan_id) + '/detections'
    response = requests.request("GET", url, headers=headers)
    if response.status_code == 200:
        detection = response.text
        detection = json.loads(detection)
        detections = detection['detections']
        cursor = detection['next_cursor']
        while cursor != "":
            cursor_temp, detections_temp = get_scan_detections_paginated(account_id, client_id, auth_token, ids, scan_id, cursor)
            detections.extend(detections_temp)
            cursor = cursor_temp
        return detections
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting Scan Detections", error='')


def get_scan_detections_paginated(account_id, client_id, auth_token, ids, scan_id, cursor):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints/' + str(ids) + '/scans/' + str(
        scan_id) + '/detections?next_cursor=' + cursor
    response = requests.request("GET", url, headers=headers)
    if response.status_code == 200:
        detection = response.text
        detection = json.loads(detection)
        detections = detection['detections']
        cursor = detection['next_cursor']

        return cursor, detections
    else:
        return False


# Get Suspicious Activities found on all the endpoints
def get_suspicious_activities(account_id, client_id, auth_token):

    url = 'https://cloud.malwarebytes.com/api/v2/sa'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    response = requests.request("GET", url, headers=headers)

    if response.status_code == 200:
        sa_detections = response.text
        sa_detections = json.loads(sa_detections)
        sa_detection = sa_detections['sa']
        cursor = sa_detections['next_cursor']
        while cursor != "":
            cursor_temp, sa_detections_temp = get_suspicious_activities_paginated(account_id, client_id, auth_token, cursor)
            sa_detection.extend(sa_detections_temp)
            cursor = cursor_temp

        return sa_detection
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting Suspicious Activities", error='')


def get_suspicious_activities_paginated(account_id, client_id, auth_token, cursor):

    url = 'https://cloud.malwarebytes.com/api/v2/sa?next_cursor' + cursor

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    response = requests.request("GET", url, headers=headers)

    if response.status_code == 200:
        sa_detections = response.text
        sa_detections = json.loads(sa_detections)
        sa_detection = sa_detections['sa']
        cursor = sa_detections['next_cursor']

        return cursor, sa_detection
    else:
        return False, False


# Get RTP Detections found on all the endpoints
def get_rtp_detections(account_id, client_id, auth_token):
    url = 'https://cloud.malwarebytes.com/api/v2/detections/search'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    body: Dict[str, str] = {}
    response = requests.post(url, data=json.dumps(body), headers=headers)

    if response.status_code == 200:
        rtp_detections = response.text
        rtp_detections = json.loads(rtp_detections)
        detections = rtp_detections['detections']
        cursor = rtp_detections['next_cursor']
        while cursor != "":
            cursor_temp, detections_temp = get_rtp_detections_paginated(account_id, client_id, auth_token, cursor)
            detections.extend(detections_temp)
            cursor = cursor_temp

        return detections
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting RTP Detections", error='')


def get_rtp_detections_paginated(account_id, client_id, auth_token, cursor):
    url = 'https://cloud.malwarebytes.com/api/v2/detections/search' + cursor

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    body: Dict[str, str] = {}
    response = requests.post(url, data=json.dumps(body), headers=headers)
    if response.status_code == 200:
        rtp_detections = response.text
        rtp_detections = json.loads(rtp_detections)
        detections = rtp_detections['detections']
        cursor = rtp_detections['next_cursor']

        return cursor, detections
    else:
        return False


# Resolve machine_id from IP Address
def get_machine_id_ip(account_id, client_id, auth_token, ip):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints'

    data = {
        "nics.ips": ip
    }

    response = requests.post(url, data=json.dumps(data), headers=headers)
    if response.status_code == 200:
        machine = response.text
        machine = json.loads(machine)
        if len(machine['machines']) != 0:
            machine_id = machine['machines'][0]
            machine_id = machine_id['machine']['id']
            return machine_id
        else:
            return False
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting Machine Id by IP", error='')


# Resolve machine_id from Hostname
def get_machine_id_hostname(account_id, client_id, auth_token, hostname):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints'

    data = {
        "fully_qualified_host_name_partial": hostname
    }

    response = requests.post(url, data=json.dumps(data), headers=headers)
    if response.status_code == 200:
        machine = response.text
        machine = json.loads(machine)
        if len(machine['machines']) != 0:
            machine_id = machine['machines'][0]
            machine_id = machine_id['machine']['id']
            return machine_id
        else:
            return False
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting Machine Id by Hostname", error='')


# Initiate POST Request for scan and report
def post_scan_report(account_id, client_id, auth_token, ids):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs'
    scan = {
        "command": "command.threat.scan",
        "data": {"scan_settings": {"type": "ThreatScan", "remove": False}},
        "machine_ids": [ids]}
    response = requests.post(url, data=json.dumps(scan), headers=headers)

    if response.status_code == 201:
        scan_result = response.text
        scan_result = json.loads(scan_result)
        job_id = scan_result['jobs'][0]
        job_id = job_id['job_id']
        return job_id

    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on Initiating Scan and Report action", error='')


# Initiate POST Request for scan and quarantine
def post_scan_remediate(account_id, client_id, auth_token, ids):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs'
    scan = {
        "command": "command.threat.scan",
        "data": {"scan_settings": {"type": "ThreatScan", "remove": True}},
        "machine_ids": [ids]}
    response = requests.post(url, data=json.dumps(scan), headers=headers)

    if response.status_code == 201:
        scan_result = response.text
        scan_result = json.loads(scan_result)
        job_id = scan_result['jobs'][0]
        job_id = job_id['job_id']
        return job_id

    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on Initiating Scan and Remediate action", error='')


# Initiate POST Request for Isolate actions
def post_isolate(account_id, client_id, auth_token, ids, isolated):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs/endpoints/isolate'

    if isolated == 'isolate':
        isolate = {"data": {"desktop": True, "network": True, "process": True}, "machine_ids": [ids]}

    elif isolated == 'desktop_isolate':
        isolate = {"data": {"desktop": True, "network": False, "process": False}, "machine_ids": [ids]}

    elif isolated == 'network_isolate':
        isolate = {"data": {"desktop": False, "network": True, "process": False}, "machine_ids": [ids]}

    elif isolated == 'process_isolate':
        isolate = {"data": {"desktop": False, "network": False, "process": True}, "machine_ids": [ids]}

    response = requests.post(url, data=json.dumps(isolate), headers=headers)

    if response.status_code == 201:
        isolate_result = response.text
        isolate_result = json.loads(isolate_result)
        job_id = isolate_result['jobs'][0]
        job_id = job_id['job_id']
        return job_id
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on Initiating Isolate actions", error='')


# Initiate POST Request for deisolation
def post_deisolate(account_id, client_id, auth_token, ids):

    url = 'https://cloud.malwarebytes.com'
    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/jobs/endpoints/unlock'
    deisolate = {"machine_ids": [ids]}
    response = requests.post(url, data=json.dumps(deisolate), headers=headers)

    if response.status_code == 201:
        deisolate_result = response.text
        deisolate_result = json.loads(deisolate_result)
        job_id = deisolate_result['jobs'][0]
        job_id = job_id['job_id']
        return job_id

    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on Initiating deisolate action", error='')


# Get endpoint info
def get_endpoint_info(account_id, client_id, auth_token, ids):
    url = 'https://cloud.malwarebytes.com/api/v2/endpoints/'
    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + ids + '/assets'

    response = requests.request("GET", url, headers=headers)

    if response.status_code == 200:
        assets = response.text
        assets = json.loads(assets)
        return assets

    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on getting endpoint info", error='')


# Get Latest High Severity Suspicious Activities to create incidents
def fetch_suspicious_activities(suspicious_activities, suspicious_activity_severity, last_fetch_time, last_count, last_custom):

    if last_custom is not None and last_custom != suspicious_activity_severity:
        demisto.setLastRun({'time': None, 'count': None, 'custom': None})
        return False, False

    asc_suspicious_activities = []

    if len(suspicious_activities) != 0:
        for i in reversed(suspicious_activities):
            asc_suspicious_activities.append(i)
    else:
        return False, False

    SA_severity = severity_text_to_number(suspicious_activity_severity)

    Filtered_SA = []

    if len(asc_suspicious_activities) != 0:

        if last_fetch_time is None and last_count is None and last_custom is None:
            last_count = 0
            for i in asc_suspicious_activities:
                if i['level'] == SA_severity and i['status'] == 'detected':
                    Filtered_SA.append(i)

            if len(Filtered_SA) != 0:
                incident = {'name': "Malwarebytes Suspicious Activity Incident Detected on Host: "
                                    + str(Filtered_SA[last_count]["pc_hostname"]),
                            'occurred': str(Filtered_SA[last_count]["timestamp"]),
                            'severity': SA_severity,
                            'rawJSON': json.dumps(Filtered_SA[last_count])}
                lastPointer = {'time': str(Filtered_SA[last_count]["timestamp"]), 'count': last_count,
                               'custom': str(suspicious_activity_severity)}
                return lastPointer, incident
            else:
                return False, False

        else:
            last_count = last_count + 1
            for i in asc_suspicious_activities:
                if i['level'] == SA_severity and i['status'] == 'detected':
                    Filtered_SA.append(i)

            if len(Filtered_SA) != 0:
                try:
                    if Filtered_SA[last_count]:
                        incident = {'name': "Malwarebytes Suspicious Activity Incident Detected on Host: "
                                            + str(Filtered_SA[last_count]["pc_hostname"]),
                                    'occurred': str(Filtered_SA[last_count]["timestamp"]),
                                    'severity': SA_severity,
                                    'rawJSON': json.dumps(Filtered_SA[last_count])}
                        lastPointer = {'time': str(Filtered_SA[last_count]["timestamp"]), 'count': last_count,
                                       'custom': str(suspicious_activity_severity)}
                        return lastPointer, incident

                except Exception:
                    return False, False
            else:
                return False, False
    else:
        return False, False


# Get Real Time Protection Detections to Create Incidents
def fetch_rtp_detections(category, rtp_detections, last_fetch_time, last_count, last_custom):

    if last_custom is not None and last_custom != category:
        demisto.setLastRun({'time': None, 'count': None, 'custom': None})
        return False, False

    asc_rtp_events_by_category = []
    if len(rtp_detections) != 0:
        if last_fetch_time is None and last_count is None and last_custom is None:
            last_count = 0
            if category == 'all':
                for i in reversed(rtp_detections):
                    asc_rtp_events_by_category.append(i)
            else:
                for i in reversed(rtp_detections):
                    if i['category'] == category:
                        asc_rtp_events_by_category.append(i)

            if len(asc_rtp_events_by_category) != 0:
                incident = {'name': "Malwarebytes RTP has protected against threat "
                                    + str(asc_rtp_events_by_category[last_count]["threat_name"]) + " on Host: "
                                    + str(asc_rtp_events_by_category[last_count]["machine_name"]),
                            'occurred': str(asc_rtp_events_by_category[last_count]["reported_at"]),
                            'severity': 3,
                            'rawJSON': json.dumps(asc_rtp_events_by_category[last_count])}
                lastPointer = {'time': str(asc_rtp_events_by_category[last_count]["reported_at"]),
                               'count': last_count, 'custom': str(category)}
                return lastPointer, incident
            else:
                return False, False

        else:
            last_count = last_count + 1
            if category == 'all':
                for i in reversed(rtp_detections):
                    asc_rtp_events_by_category.append(i)
            else:
                for i in reversed(rtp_detections):
                    if i['category'] == category:
                        asc_rtp_events_by_category.append(i)

            if len(asc_rtp_events_by_category) != 0:
                try:
                    if asc_rtp_events_by_category[last_count]:
                        incident = {'name': "Malwarebytes RTP has protected against threat "
                                            + str(asc_rtp_events_by_category[last_count]["threat_name"]) + " on Host: "
                                            + str(asc_rtp_events_by_category[last_count]["machine_name"]),
                                    'occurred': str(asc_rtp_events_by_category[last_count]["reported_at"]),
                                    'severity': 3,
                                    'rawJSON': json.dumps(asc_rtp_events_by_category[last_count])}
                        lastPointer = {'time': str(asc_rtp_events_by_category[last_count]["reported_at"]),
                                       'count': last_count, 'custom': str(category)}
                        return lastPointer, incident

                except Exception:
                    return False, False
            else:
                return False, False

    else:
        return False, False


# Convert Text Category to Malwarebytes Category
def category_to_code(rtp_malware_category):

    if rtp_malware_category == 'All':
        return 'all'
    elif rtp_malware_category == 'Malware':
        return 'MALWARE'
    elif rtp_malware_category == 'PUP':
        return 'PUP'
    elif rtp_malware_category == 'PUM':
        return 'PUM'
    elif rtp_malware_category == 'Exploit':
        return 'AE'
    elif rtp_malware_category == 'Ransomware':
        return 'ARW'
    elif rtp_malware_category == 'Website':
        return 'MWAC'
    else:
        return None


# Remove empty fields from Scan Detections
def remove_empty_detection_fields(detections):
    for i in detections:
        del i['affected_application'], i['detection_id_from_endpoint'], i['group_id'], i['id'], i['ip_address'], i[
            'md5'], i['port'], i['process_name'], i['reported_at'], i['scan_id'], i['scanned_at'], i[
            'scanned_at_local'], i['url']


# Convert Severity Text to Severity Number
def severity_text_to_number(suspicious_activity_severity):

    if suspicious_activity_severity == 'High':
        return 3
    elif suspicious_activity_severity == 'Medium':
        return 2
    elif suspicious_activity_severity == 'Low':
        return 1


# Function to execute Scan and Remediate action
def scan_and_remediate(account_id, client_id, auth_token, ip, hostname):

    # This is the call made initiating scan_and_remediate action
    LOG('command is %s' % (demisto.command(),))
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_scan_remediate(account_id, client_id, auth_token, ids)
            return_outputs(
                'Scan and Remediate action has been successfully started on the Endpoint: ' + str(ip),
                outputs={
                    'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                    'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                }
            )
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_scan_remediate(account_id, client_id, auth_token, ids)
            return_outputs(
                'Scan and Remediate action has been successfully started on the Endpoint: ' + str(hostname),
                outputs={
                    'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                    'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                }
            )
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    else:
        return_error(message="Please Enter IP or Hostname", error='')


# Function to execute Scan and Report action
def scan_and_report(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating scan_and_report action
    LOG('command is %s' % (demisto.command(),))
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_scan_report(account_id, client_id, auth_token, ids)
            return_outputs(
                'Scan and Report action has been successfully started on the Endpoint: ' + str(ip),
                outputs={
                    'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                    'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                }
            )
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_scan_report(account_id, client_id, auth_token, ids)
            return_outputs(
                'Scan and Report action has been successfully started on the Endpoint: ' + str(hostname),
                outputs={
                    'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                    'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                }
            )
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    else:
        return_error(message="Please Enter IP or Hostname", error='')


# Functions to execute Isolate Command
def isolate_endpoint(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating Isolate Endpoint action
    LOG('command is %s' % (demisto.command(),))
    isolated = 'isolate'
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Isolation action has been successfully started on the Endpoint: ' + str(ip),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Isolation action Failed for the Endpoint: ' + str(ip), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Isolation action has been successfully started on the Endpoint: ' + str(hostname),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Isolation action Failed for the Endpoint: ' + str(hostname), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    else:
        return_error(message="Please Enter IP or Hostname", error='')


def isolate_process(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating Isolate Process action
    LOG('command is %s' % (demisto.command(),))
    isolated = 'process_isolate'
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Process Isolation action has been successfully started on the Endpoint: ' + str(ip),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Process Isolation action Failed for the Endpoint: ' + str(ip), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')
            sys.exit(0)

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Process Isolation action has been successfully started on the Endpoint: ' + str(hostname),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Process Isolation action Failed for the Endpoint: ' + str(hostname), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')
    else:
        return_error(message="Please Enter IP or Hostname", error='')


def isolate_network(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating Isolate Network action
    LOG('command is %s' % (demisto.command(),))
    isolated = 'network_isolate'
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Network Isolation action has been successfully started on the Endpoint: ' + str(ip),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Network Isolation action Failed for the Endpoint: ' + str(ip), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Network Isolation action has been successfully started on the Endpoint: ' + str(hostname),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Network Isolation action Failed for the Endpoint: ' + str(hostname), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')
    else:
        return_error(message="Please Enter IP or Hostname", error='')


def isolate_desktop(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating Isolate Desktop action
    LOG('command is %s' % (demisto.command(),))
    isolated = 'desktop_isolate'
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Desktop Isolation action has been successfully started on the Endpoint: ' + str(ip),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Desktop Isolation action Failed for the Endpoint: ' + str(ip), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_isolate(account_id, client_id, auth_token, ids, isolated)
            if job_id:
                return_outputs(
                    'Desktop Isolation action has been successfully started on the Endpoint: ' + str(hostname),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Desktop Isolation action Failed for the Endpoint: ' + str(hostname), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')
    else:
        return_error(message="Please Enter IP or Hostname", error='')


# Function to execute Deisolate Command
def deisolate_endpoint(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating scan_and_report action
    LOG('command is %s' % (demisto.command(),))
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            job_id = post_deisolate(account_id, client_id, auth_token, ids)
            if job_id:
                return_outputs(
                    'Deisolation action has been successfully started on the Endpoint: ' + str(ip),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Deisolation action Failed for the Endpoint: ' + str(ip), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            job_id = post_deisolate(account_id, client_id, auth_token, ids)
            if job_id:
                return_outputs(
                    'Deisolation action has been successfully started on the Endpoint: ' + str(hostname),
                    outputs={
                        'Malwarebytes.Scan.Machine_ID(val.Machine_ID == obj.Machine_ID)': ids,
                        'Malwarebytes.Scan.Job_ID(val.Job_ID == obj.Job_ID)': job_id
                    }
                )
            else:
                return_error(message='Deisolation action Failed for the Endpoint: ' + str(hostname), error='')
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')
    else:
        return_error(message="Please Enter IP or Hostname", error='')


# Function to execute List all endpoints Command
def list_all_endpoints(account_id, client_id, auth_token, endpoint):
    LOG('command is %s' % (demisto.command(),))
    if endpoint == 'all':
        machines = get_all_endpoints(account_id, client_id, auth_token)
        if len(machines) != 0:
            return_outputs(
                readable_output=tableToMarkdown('All Endpoints from Malwarebytes Cloud: ', machines),
                outputs={},
                raw_response=machines
            )
        else:
            return_error(message='List all endpoints action Failed ', error='')

    elif endpoint == 'online':
        machines = get_all_endpoints(account_id, client_id, auth_token)
        online = []
        if len(machines) != 0:
            for i in machines:
                if i['online'] is True:
                    online.append(i)
            return_outputs(
                readable_output=tableToMarkdown('All Online Endpoints from Malwarebytes Cloud: ', online),
                outputs={},
                raw_response=online
            )
        else:
            return_error(message='List all online endpoints action Failed ', error='')

    elif endpoint == 'offline':
        machines = get_all_endpoints(account_id, client_id, auth_token)
        offline = []
        if len(machines) != 0:
            for i in machines:
                if i['online'] is False:
                    offline.append(i)
            return_outputs(
                readable_output=tableToMarkdown('All Offline Endpoints from Malwarebytes Cloud: ', offline),
                outputs={},
                raw_response=offline
            )
        else:
            return_error(message='List all Offline endpoints action Failed ', error='')


# Function to execute List endpoint info Command
def list_endpoint_info(account_id, client_id, auth_token, ip, hostname):
    # This is the call made initiating get endpoint info action
    LOG('command is %s' % (demisto.command(),))
    if ip:
        ids = get_machine_id_ip(account_id, client_id, auth_token, ip)
        if ids:
            assets = get_endpoint_info(account_id, client_id, auth_token, ids)
            del assets['dhcp_scope_name'], assets['domain_name'], assets['object_guid'], assets['object_sid']
            return_outputs(
                readable_output=tableToMarkdown(f'Endpoint Information for the IP: {ip}', assets),
                outputs={
                    'Malwarebytes.Endpoint.Hostname(val.Hostname == obj.Hostname)': assets['host_name']
                },
                raw_response=assets
            )
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')

    elif hostname:
        ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname)
        if ids:
            assets = get_endpoint_info(account_id, client_id, auth_token, ids)
            del assets['dhcp_scope_name'], assets['domain_name'], assets['object_guid'], assets['object_sid']
            return_outputs(
                readable_output=tableToMarkdown(f'Endpoint Information for the Hostname: {hostname}', assets),
                outputs={
                    'Malwarebytes.Endpoint.Hostname(val.Hostname == obj.Hostname)': assets['host_name']
                },
                raw_response=assets
            )
        else:
            return_error(message="Endpoint is not found in the Malwarebytes Cloud", error='')
    else:
        demisto.results("Please Input an IP or Hostname")


# Function to execute Get Scan Detections Command
def scan_detections(account_id, client_id, auth_token, job_id):

    if job_id:
        status = get_scan_status(account_id, client_id, auth_token, job_id)
        if status == 'COMPLETED':
            scan_id = get_scan_id(account_id, client_id, auth_token, job_id)
            machine_id = get_scan_id_machine(account_id, client_id, auth_token, job_id)
            detections = get_scan_detections(account_id, client_id, auth_token, machine_id, scan_id)
            if len(detections) != 0:
                remove_empty_detection_fields(detections)
                return_outputs(
                    readable_output=tableToMarkdown(f'Scan Detections Report for the Job_Id: {job_id}', detections),
                    outputs={
                        'Malwarebytes.Scan.Status(val.Status == obj.Status)': status
                    },
                    raw_response=detections
                )
            else:
                demisto.results("Scan has been Completed and No Threats have been found !")
        else:
            demisto.results('Scan Status for the job_id ' + str(job_id) + ' is ' + str(status))

    else:
        return_error(message="Please Enter Job_Id", error='')


# Function to execute Get Scan Status Command
def scan_status(account_id, client_id, auth_token, job_id):

    if job_id:
        status = get_scan_status(account_id, client_id, auth_token, job_id)
        return_outputs(
            'Scan Status for the job_id ' + str(job_id) + ' is ' + str(status),
            outputs={
                'Malwarebytes.Scan.Status(val.Status == obj.Status)': status
            },
            raw_response=status
        )

    else:
        return_error(message="Please Enter Job_Id", error='')


# Function to execute Fetch Incidents Command
def fetch_incidents(account_id, client_id, auth_token, Event_list):

    if Event_list == 'Suspicious Activity (EPR)':

        suspicious_activities = get_suspicious_activities(account_id, client_id, auth_token)

        # And retrieve it for use later
        lastRun = demisto.getLastRun()
        last_fetch_time = lastRun.get("time")
        last_count = lastRun.get("count")
        last_custom = lastRun.get("custom")
        suspicious_activity_severity = demisto.params().get('suspicious_activity_severity')
        if suspicious_activity_severity:
            lastPointer, incident = fetch_suspicious_activities(suspicious_activities, suspicious_activity_severity,
                                                                last_fetch_time, last_count, last_custom)
            if lastPointer and incident:
                demisto.incidents([incident])
                # You can store the last run time...
                demisto.setLastRun(lastPointer)
            else:
                demisto.incidents([])
        else:
            demisto.incidents([])

    elif Event_list == 'RTP Detections (EP)':

        rtp_detections = get_rtp_detections(account_id, client_id, auth_token)

        # And retrieve it for use later
        lastRun = demisto.getLastRun()
        last_fetch_time = lastRun.get("time")
        last_count = lastRun.get("count")
        last_custom = lastRun.get("custom")
        rtp_malware_category = demisto.params().get('rtp_threat_category')
        if rtp_malware_category:
            category = category_to_code(rtp_malware_category)
            lastPointer, incident = fetch_rtp_detections(category, rtp_detections,
                                                         last_fetch_time, last_count, last_custom)
            if incident and lastPointer:
                demisto.incidents([incident])
                # You can store the last run time...
                demisto.setLastRun(lastPointer)
            else:
                demisto.incidents([])
        else:
            demisto.incidents([])
    else:
        demisto.incidents([])


def get_token(client_id, client_secret, account_id):
    integration_context = demisto.getIntegrationContext()
    token = integration_context.get('access_token')
    valid_until = integration_context.get('valid_until')
    time_now = int(time.time())
    if token and valid_until:
        if time_now < valid_until:
            # Token is still valid - did not expire yet
            return token
    # get_nebula_client() should be the implementation of retrieving the token from the API
    token = get_nebula_client(client_id, client_secret, account_id)
    integration_context = {
        'access_token': token,
        'valid_until': time_now + 3599  # Assuming the expiration time is 1 hour
    }
    demisto.setIntegrationContext(integration_context)
    return token


# Function to execute Open SA action
def open_sa_incident(account_id, client_id, auth_token, machine_id, detection_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints/' + str(machine_id) + '/sa/' + str(detection_id) + '/open'
    response = requests.put(url, data=None, headers=headers)
    if response.status_code == 201:
        demisto.results("Open SA Incident action is initiated Successfully for the detection id: " + str(detection_id))
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on initiating Open SA Incident action",
                     error='')


# Function to execute Remediate SA action
def remediate_sa_incident(account_id, client_id, auth_token, machine_id, detection_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Content-Type': "application/json",
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints/' + str(machine_id) + '/sa/' + str(detection_id) + '/remediate'
    response = requests.post(url, data=json.dumps({}), headers=headers)
    if response.status_code == 201:
        demisto.results("Remediate SA Incident action is initiated Successfully for the detection id: " + str(detection_id))
    elif response.status_code == 404:
        return_error(message="HTTP Error: " + str(response.status_code) + " as threat with detection id: "
                             + str(detection_id) + " is already remediated", error='')
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on initiating Remediate SA Incident action",
                     error='')


# Function to execute Close Remediate SA action
def close_sa_incident(account_id, client_id, auth_token, machine_id, detection_id):

    url = 'https://cloud.malwarebytes.com'

    headers = {
        'X-MWB-AccountID': account_id,
        'X-MWB-ClientID': client_id,
        'Authorization': auth_token
    }

    url = url + '/api/v2/endpoints/' + str(machine_id) + '/sa/' + str(detection_id) + '/close'
    response = requests.put(url, data=None, headers=headers)
    if response.status_code == 201:
        demisto.results("Close SA Incident action is initiated Successfully for the detection id: " + str(detection_id))
    else:
        return_error(message="HTTP Error: " + str(response.status_code) + " on initiating Close SA Incident action",
                     error='')


def main():
    '''CONSTANTS'''
    account_id = demisto.params().get('accountid')
    client_id = demisto.params().get('clientid')
    client_secret = demisto.params().get('clientsecret')

    auth_token = get_token(client_id, client_secret, account_id)

    try:
        # The command demisto.command() holds the command sent from the user.
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            LOG('command is %s' % (demisto.command(), ))
            status = test_connectivity(account_id, client_id, auth_token)
            if status is True:
                demisto.results('ok')
                sys.exit(0)
            else:
                demisto.results('Connection Failed! Please check your Credentials')
                sys.exit(0)

        elif demisto.command() == 'scan_and_remediate':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            scan_and_remediate(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'scan_and_report':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            scan_and_report(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'isolate_endpoint':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            isolate_endpoint(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'isolate_process':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            isolate_process(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'isolate_network':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            isolate_network(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'isolate_desktop':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            isolate_desktop(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'deisolate_endpoint':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            deisolate_endpoint(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'list_all_endpoints':
            endpoint = demisto.args().get('endpoints')
            list_all_endpoints(account_id, client_id, auth_token, endpoint)

        elif demisto.command() == 'list_endpoint_info':
            ip = demisto.args().get('ip')
            hostname = demisto.args().get('hostname')
            list_endpoint_info(account_id, client_id, auth_token, ip, hostname)

        elif demisto.command() == 'get_scan_detections':
            job_id = demisto.args().get('job_id')
            scan_detections(account_id, client_id, auth_token, job_id)

        elif demisto.command() == 'get_scan_status':
            job_id = demisto.args().get('job_id')
            scan_status(account_id, client_id, auth_token, job_id)

        elif demisto.command() == 'open_sa_incident':
            machine_id = demisto.args().get('machine_id')
            detection_id = demisto.args().get('detection_id')
            open_sa_incident(account_id, client_id, auth_token, machine_id, detection_id)

        elif demisto.command() == 'remediate_sa_incident':
            machine_id = demisto.args().get('machine_id')
            detection_id = demisto.args().get('detection_id')
            remediate_sa_incident(account_id, client_id, auth_token, machine_id, detection_id)

        elif demisto.command() == 'close_sa_incident':
            machine_id = demisto.args().get('machine_id')
            detection_id = demisto.args().get('detection_id')
            close_sa_incident(account_id, client_id, auth_token, machine_id, detection_id)

        elif demisto.command() == 'fetch-incidents':
            Event_list = demisto.params().get('Fetch_Event_List')
            fetch_incidents(account_id, client_id, auth_token, Event_list)

    except Exception as e:
        # Log exceptions
        return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}{str(traceback.format_exc())}')


if __name__ in ['__main__', 'builtin', 'builtins']:
    main()
