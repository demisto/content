commonfields:
  id: Tenable.sc
  version: -1
name: Tenable.sc
display: Tenable.sc
category: Vulnerability Management
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAABBVBMVEUAAABFVWVIV2ZEVWZIV2hJW2lFVWVFVWVKXGpOXnMAqLYAp7ZEVGQAp7UAqLYAqLZsdIAAp7ZEVWUAp7UAp7UAqLUAp7VFVWUAp7UAqLUAqLZEVGQAqLZFVWUAqLYAqLdEVGUAp7UAp7UAp7VEVWQAp7YAussAp7UAp7UAp7UAqLZFVmZHV2YAr7xQZHNEVWRFVWRFVWVFV2YAqbYAt8FEVGVEVWVFVWZGVmUAqrhIWGlMWmxFVGVEVWVFVWVFVWRGVWYAqLZHV2YAqrYArbtFVGUAqbVFWGlHV2lFVWREVWUAp7QAp7VGV2ZEVWVGVmVFVmYArLdEVWREVmUAq7dEVWVEVGQidPTWAAAAVnRSTlMAjCF7JhjRmRUMdmD0h2pSBIv8k4+voZ+Yb0/qZGRKRLy1qZyWgwXFgH5ZRjMQCPm1h008CfB1XEIoHxDj24+CbkE5LhewNyob5sK8pC+rVFEgpqEz5PhyY/gAAAQ1SURBVFjD7ZTZctowFEAva8DGNsZL7GDM4pp9h7AECBAC2ZukTfX/n1ItcQwkM51Op+lDOQ/oXkvWsdCV4MCBAwcO/D4be9yHf4BQbUiKXukV4XMRpJ7r3JXypVJBHMPnIQj31lJdFkWh52qybpzAH/AFIRTz0yBOA/Axap6/dK2GxHFiybpU+L5ZBcZjIBCI/zWxWlqZjpzXtILCibrSs8pFAxhHZJK/JZbvqiVBtmyxAStx495XZc7S/0B89EvxpHZFvIWCmS1nTVZTtsVrDa4krD6apNnccyST4NPcEzffi5Ns20adIfZWS32zzGXhlSKv3vdPShydoj3Fb+Xa30hydXyDUPpbncSZdrsdiQVmqVZ0QN1nnWgLJWbnZ564vk6gxNfwtvj6fIZQYl3D0WMNXIlTQTGK4HOpCS/3GolmiJHGcSiFGHOcBHCbOWX5Gi+k43Wmukw8YA8SQ188TCDGd/qpOiiVfn73+HC8IZaKu+I5eiNDxT4juPCTRJiIfeqeeMg+DJGMihvlii3vinmzXL1b4mAxj+Jx5/MB1HE7fZrER/hBesLEt4vRgKw6BNBGucxDcDgjo5k4t6iFSOftqziC13uaiTXrOYRaZAfKWb4i23tiUZUc4e1oRHC7xsOvABNLI9Sh4nO62Tg4xvufAcIVMVLxnKRhLEMXTNzBv11aX/jTv+K2J9sVY/NerOjb4iae4jZOOUYoSsVBOjcTw+RxMHxIQpp0HtF3MNQ2YGKsu4lTBng/kriINUmoZPfEriipcsMX0/l9Wr44wsQDWjg3j1MiZu8QuuSPYeIU2oYUf0EsjK09cWEjqXZvS/yAdojviTNe4aR2VkyL7oiKm2gHciZN3TjhdsViYVWV+9aW+Bo3s9AbzT1xGv8u4qRwtsWskjtsxaS2/Amucef4riyVK9ve4j23cu2s5InJqCnemIk/ZFd8hki9EG488RlNyYcMqZiGV7BDXgNJE5/BI1t2N6t8VgFP3H01teO0nBYfir8D4YcnjgbJtULq4ZqJM+RhhL4SAoaR54q8Y/N9mo3NpWg+awrzQohcH19z+BSR4HzRyaXQaF+cTGPBE0DsGHlilIq2bxBVUjE9RShxtJivWygDlGrVkE9454XHG90Qs5J1knfzCjBGiBKBi1PkEQX4qLhO01vFNUWMH5NXMQTZIzoyzq5mYWlmVZOzTNWVhYLrOOO8AR7fEWL/djiHKKl18J0Y5i16XWamnvjhFhHaMf+ujn1LIcrtBTB0WAp9scCPObnS2yi9Z80Bn/CoO2KlEruodWsPExqGw+EkvYdwEKF9T916E4Lh8BlEaGew9lQLe0NiQJjU8QT1mF9NellSpYahNPDq+UbFMeCzeLac/J3BFRzdFCoS2V+bW8En8cJpmmpfwtKgFcfZ8Hn0s4Kuq0Vacb0iHDhw4MCB/5yfYHowcdS9KS4AAAAASUVORK5CYII=
description: With Tenable.sc (formerly SecurityCenter) you get a real-time, continuous
  assessment of your security posture so you can find and fix vulnerabilities faster.
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |
    import time
    import re
    from requests import Request, Session
    import requests
    import json
    import datetime
    import time


    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' GLOBAL VARIABLES'''
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    VERIFY_SSL = not demisto.params().get('unsecure', False)
    SESSION = None

    def get_server_url():
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    BASE_URL = get_server_url()
    SERVER_URL = BASE_URL + '/rest'

    ''' HELPER FUNCTIONS '''
    def send_request(path, method='get', body=None, params=None, headers=None):
        body = body if body is not None else {}
        params = params if params is not None else {}

        url = '{}/{}'.format(SERVER_URL, path)

        headers = headers if headers is not None else get_headers()
        res = SESSION.request(method, url, data=json.dumps(body), params=params, verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            try:
                error = res.json()
            except:
                return_error('Got status code {} with url {} with body {} with headers {}'.format(str(res.status_code), url, res.content, str(res.headers)))
            return_error('Got an error from TenableSC, code: {}, details: {}'.format(error['error_code'], error['error_msg']))
        return res.json()


    def get_headers():
            headers = {}
            headers['Accept'] = 'application/json'
            headers['Content-Type'] = 'application/json'

            return headers


    def send_login_request(login_body):
        path = 'token'
        url = '{}/{}'.format(SERVER_URL, path)

        headers = get_headers()
        res = SESSION.request('post', url, headers=headers, data=json.dumps(login_body), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            return_error('Got status code {} with url {} with body {} with headers {}'.format(str(res.status_code), url, res.content, str(res.headers)))

        return res.json()


    def login(user_name, password):
        login_body = {
            'username': user_name,
            'password': password
        }
        login_response = send_login_request(login_body)

        if 'response' not in login_response:
            return_error('Could not retrieve login token')

        token = login_response['response'].get('token')
        # There might be a case where the API does not return a token because there are too many sessions with the same user.
        # In that case we need to add 'releaseSession = true'
        if not token:
            login_body['releaseSession'] = 'true'
            login_response = send_login_request(login_body)
            if 'response' not in login_response or 'token' not in login_response['response']:
                return_error('Could not retrieve login token')
            token = login_response['response']['token']

        return token


    def logout():
        send_request(path='token', method='delete')


    def return_message(msg):
        demisto.results(msg)
        sys.exit(0)

    ''' FUNCTIONS '''
    def list_scans_command():
        res = get_scans('id,name,description,policy,ownerGroup,owner')
        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return_message('No scans found')

        scans_dicts = get_elements(res['response'], manageable)

        if len(scans_dicts) == 0:
            return_message('No scans found')

        headers = ['ID','Name','Description','Policy','Group','Owner']

        mapped_scans = [{
            'Name': s['name'],
            'ID': s['id'],
            'Description': s['description'],
            'Policy': s['policy'].get('name'),
            'Group': s['ownerGroup'].get('name'),
            'Owner': s['owner'].get('username')
            } for s in scans_dicts]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scans", mapped_scans, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Scan(val.ID==obj.ID)': createContext(mapped_scans, removeNull=True)
            }
        })


    def get_scans(fields):
        path = 'scan'
        params = None

        if fields:
            params = {
                'fields': fields
            }


        return send_request(path,params=params)


    def list_policies_command():
        res = get_policies('id,name,description,tags,modifiedTime,owner,ownerGroup,policyTemplate')

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return_message('No policies found')

        policies = get_elements(res['response'], manageable)

        if len(policies) == 0:
            return_message('No policies found')

        headers = ['ID','Name','Description','Tag','Type','Group','Owner','LastModified']

        mapped_policies = [{
            'ID': p['id'],
            'Name': p['name'],
            'Description': p['description'],
            'Tag': p['tags'],
            'Type': p['policyTemplate'].get('name'),
            'Group': p['ownerGroup'].get('name'),
            'Owner': p['owner'].get('username'),
            'LastModified': datetime.datetime.utcfromtimestamp(int(p['modifiedTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if p['modifiedTime'] else ''
        } for p in policies]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Policies", mapped_policies, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanPolicy(val.ID==obj.ID)': createContext(mapped_policies, removeNull=True)
            }
        })


    def get_policies(fields):
        path = 'policy'
        params = None

        if fields:
            params = {
                'fields': fields
            }

        return send_request(path, params=params)

    def list_repositories_command():
        res = get_repositories()

        if not res or 'response' not in res or not res['response']:
            return_message('No repositories found')


        repositories = res['response']

        if len(repositories) == 0:
            return_message('No repositories found')

        headers = [
            'ID',
            'Name',
            'Description'
        ]

        mapped_repositories = [{'ID': r['id'], 'Name': r['name'], 'Description': r['description']} for r in repositories]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Repositories", mapped_repositories, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanRepository(val.ID==obj.ID)': createContext(mapped_repositories, removeNull=True)
            }
        })


    def get_repositories():
        path = 'repository'

        return send_request(path)


    def list_credentials_command():
        res = get_credentials('id,name,description,type,ownerGroup,owner,tags,modifiedTime')

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return_message('No credentials found')

        credentials = get_elements(res['response'], manageable)

        if len(credentials) == 0:
            return_message('No credentials found')

        headers = ['ID','Name','Description','Type','Tag','Group','Owner','LastModified']

        mapped_credentials = [{
            'ID': c['id'],
            'Name': c['name'],
            'Description': c['description'],
            'Type': c['type'],
            'Tag': c['tags'],
            'Group': c.get('ownerGroup', {}).get('name'),
            'Owner': c.get('owner', {}).get('name'),
            'LastModified': datetime.datetime.utcfromtimestamp(int(c['modifiedTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if c['modifiedTime'] else ''
        } for c in credentials]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Credentials", mapped_credentials, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Credential(val.ID==obj.ID)': createContext(mapped_credentials, removeNull=True)
            }
        })


    def get_credentials(fields):
        path = 'credential'
        params = None

        if fields:
            params = {
                'fields': fields
            }

        return send_request(path, params=params)

    def list_assets_command():
        res = get_assets('id,name,description,ipCount,type,tags,modifiedTime,groups,owner')

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return_message('No assets found')

        assets = get_elements(res['response'], manageable)

        if len(assets) == 0:
            return_message('No assets found')

        headers = [
            'ID',
            'Name',
            'Tag',
            'Owner',
            'Group',
            'Type'
            'HostCount',
            'LastModified'
        ]

        mapped_assets = [{
            'ID': a['id'],
            'Name': a['name'],
            'Tag': a['tags'],
            'Owner': a.get('owner', {}).get('username'),
            'Type': a['type'],
            'Group': a.get('ownerGroup', {}).get('name'),
            'HostCount': a['ipCount'],
            'LastModified': datetime.datetime.utcfromtimestamp(int(a['modifiedTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if a['modifiedTime'] else ''
        } for a in assets]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Assets", mapped_assets, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Asset(val.ID==obj.ID)': createContext(mapped_assets, removeNull=True)
            }
        })


    def get_assets(fields):
        path = 'asset'
        params = None

        if fields:
            params = {
                'fields': fields
            }

        return send_request(path, params=params)


    def get_asset_command():
        asset_id = demisto.args()['asset_id']

        res = get_asset(asset_id)

        if not res or 'response' not in res:
            return_message('Asset not found')

        asset = res['response']

        ips = []
        ip_lists = [v['ipList'] for v in asset['viewableIPs']]



        for ip_list in ip_lists:
            # Extract IPs
            ips += re.findall('[0-9]+(?:\.[0-9]+){3}', ip_list)

        headers = ['ID', 'Name', 'Description', 'Tag', 'Created', 'Modified', 'Owner', 'Group', 'IPs']

        mapped_asset = {
            'ID': asset['id'],
            'Name': asset['name'],
            'Description': asset['description'],
            'Tag': asset['tags'],
            'Created': datetime.datetime.utcfromtimestamp(int(asset['createdTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if asset['createdTime'] else '',
            'Modified': datetime.datetime.utcfromtimestamp(int(asset['modifiedTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if asset['modifiedTime'] else '',
            'Owner': asset.get('owner', {}).get('username'),
            'Group': asset.get('ownerGroup', {}).get('name'),
            'IPs': ips
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Asset", mapped_asset, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Asset(val.ID==obj.ID)': createContext(mapped_asset, removeNull=True)
            }
        })


    def get_asset(asset_id):
        path = 'asset/' + asset_id

        params = {
            'fields': 'id,name,description,status,createdTime,modifiedTime,viewableIPs,ownerGroup,tags,owner'
        }

        return send_request(path, params=params)


    def create_asset_command():
        name = demisto.args()['name']
        description = demisto.args().get('description')
        owner_id = demisto.args().get('owner_id')
        tags = demisto.args().get('tags')
        ips = demisto.args().get('ip_list')

        res = create_asset(name, description, owner_id, tags, ips)

        if not res or 'response' not in res:
            return_error('Could not retrieve the asset')

        asset = res['response']

        mapped_asset = {
            'ID': asset['id'],
            'Name': asset['name'],
            'OwnerName': asset['owner'].get('username'),
            'Tags': asset['tags'],
        }

        headers = [
        'ID',
        'Name',
        'OwnerName',
        'Tags'
        ]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Asset created successfully', mapped_asset, headers=headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Asset(val.ID==obj.ID)': createContext(mapped_asset, removeNull=True)
            }
        })


    def create_asset(name, description, owner_id, tags, ips):
        path = 'asset'

        body = {
            'name': name,
            'definedIPs' : ips,
            'type': 'static'
        }

        if description:
            body['description'] = description

        if owner_id:
            body['ownerID'] = owner_id

        if tags:
            body['tags'] = tags

        return send_request(path, method='post', body=body)


    def delete_asset_command():
        asset_id = demisto.args()['asset_id']

        res = delete_asset(asset_id)

        if not res:
            return_error('Could not delete the asset')

        demisto.results({
                'Type': entryTypes['note'],
                'Contents': res,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Asset successfully deleted'
            })


    def delete_asset(asset_id):
        path = 'asset/' + asset_id

        return send_request(path, method='delete')


    def list_report_definitions_command():
        res = get_report_definitions('id,name,description,modifiedTime,type,ownerGroup,owner')

        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return_message('No report definitions found')

        reports = get_elements(res['response'], manageable)
        # Remove duplicates, take latest
        reports = [reduce(lambda x, y: x if int(x['modifiedTime']) > int(y['modifiedTime']) else y, filter(lambda e: e['name'] == n, reports)) for n in {r['name'] for r in reports}]

        if len(reports) == 0:
            return_message('No report definitions found')

        headers = ['ID','Name','Description','Type','Group','Owner']

        mapped_reports = [{
            'ID': r['id'],
            'Name': r['name'],
            'Description': r['description'],
            'Type': r['type'],
            'Group': r.get('ownerGroup', {}).get('name'),
            'Owner': r.get('owner', {}).get('username')
        } for r in reports]

        hr = tableToMarkdown("Tenable.sc Report Definitions", mapped_reports, headers, removeNull=True)
        for r in mapped_reports:
            del r['Description']


        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'TenableSC.ReportDefinition(val.ID==obj.ID)': createContext(mapped_reports, removeNull=True)
            }
        })


    def get_report_definitions(fields):
        path = 'reportDefinition'
        params = None

        if fields:
            params = {
                'fields': fields
            }

        return send_request(path, params=params)


    def list_zones_command():
        res = get_zones()

        if not res or 'response' not in res:
            return_message('No zones found')

        zones = res['response']
        if len(zones) == 0:
            zones = [{
                'id': 0,
                'name': 'All Zones',
                'description': '',
                'ipList': '',
                'activeScanners': ''
            }]

        headers = ['ID','Name','Description','IPList','ActiveScanners']

        mapped_zones = [{
            'ID': z['id'],
            'Name': z['name'],
            'Description': z['description'],
            'IPList': z['ipList'],
            'ActiveScanners': z['activeScanners']
        } for z in zones]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Zones", mapped_zones, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanZone(val.ID==obj.ID)': createContext(mapped_zones, removeNull=True)
            }
        })


    def get_zones():
        path = 'zone'

        return send_request(path)

    def get_elements(elements, manageable):
        if manageable == 'false':
            return elements.get('usable')

        return elements.get('manageable')


    def create_scan_command():
        name = demisto.args()['name']
        repo_id = demisto.args()['repository_id']
        policy_id = demisto.args()['policy_id']
        plugin_id = demisto.args().get('plugin_id')
        description = demisto.args().get('description')
        zone_id = demisto.args().get('zone_id')
        schedule = demisto.args().get('schedule')
        asset_ids = demisto.args().get('asset_ids')
        ips = demisto.args().get('ip_list')
        scan_virtual_hosts = demisto.args().get('scan_virtual_hosts')
        report_ids = demisto.args().get('report_ids')
        credentials = demisto.args().get('credentials')
        timeout_action = demisto.args().get('timeout_action')
        max_scan_time = demisto.args().get('max_scan_time')
        dhcp_track = demisto.args().get('dhcp_tracking')
        rollover_type = demisto.args().get('rollover_type')
        dependent = demisto.args().get('dependent_id')

        #if not policy_id and not plugin_id:
            #return_error('Policy and/or Plugin ID must be provided')

        if not asset_ids and not ips:
            return_error('Assets and/or IPs must be provided')

        if schedule == 'dependent' and not dependent:
            return_error('Dependent schedule must include a dependent scan ID')

        res = create_scan(name, repo_id, policy_id, plugin_id, description, zone_id, schedule, asset_ids,
                         ips, scan_virtual_hosts, report_ids, credentials, timeout_action, max_scan_time, dhcp_track, rollover_type, dependent)

        if not res or 'response' not in res:
            return_error('Could not retrieve the scan')

        scan = res['response']

        headers = [
            'ID',
            'CreatorID',
            'Name',
            'Type',
            'CreationTime',
            'OwnerName',
            'Reports'
        ]

        mapped_scan = {
            'ID': scan['id'],
            'CreatorID': scan['creator'].get('id'),
            'Name': scan['name'],
            'Type': scan['type'],
            'CreationTime': datetime.datetime.utcfromtimestamp(int(scan['createdTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if scan['createdTime'] else '',
            'OwnerName': scan['owner'].get('name'),
            'Reports': demisto.dt(scan['reports'], 'id')
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Scan created successfully", mapped_scan, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Scan(val.ID==obj.ID)': createContext(mapped_scan, removeNull=True)
            }
        })


    def create_scan(name, repo_id, policy_id, plugin_id, description, zone_id, schedule, asset_ids,
                    ips, scan_virtual_hosts, report_ids, credentials, timeout_action, max_scan_time, dhcp_track, rollover_type, dependent):
        path = 'scan'

        scan_type = 'policy' if policy_id else 'plugin'

        body = {
            'name' : name,
            'type' : scan_type,
            'repository' : {
                'id' : repo_id
            }
        }

        if policy_id:
            body['policy'] = {
                'id': policy_id
            }

        if plugin_id:
            body['pluginID'] = plugin_id

        if description:
            body['description'] = description

        if zone_id:
            body['zone'] = {
                'id' : zone_id
            }

        if dhcp_track:
            body['dhcpTracking'] = dhcp_track

        if schedule:
            body['schedule'] = {
                'type' : schedule
            }

            if dependent:
                body['schedule']['dependentID'] = dependent

        if report_ids:
            body['reports'] = [{'id' : r_id, 'reportSource' : 'individual'} for r_id in argToList(report_ids)]

        if asset_ids:
            if str(asset_ids).startswith('All'):
                manageable = True if asset_ids == 'AllManageable' else False
                res = get_assets(None)
                assets = get_elements(res['response'], manageable)
                asset_ids = list(map(lambda a: a['id'], assets))
            body['assets'] = [{'id' : a_id} for a_id in argToList(asset_ids)]

        if credentials:
            body['credentials'] = [{'id' : c_id} for c_id in argToList(credentials)]

        if timeout_action:
            body['timeoutAction'] = timeout_action

        if scan_virtual_hosts:
            body['scanningVirtualHosts'] = scan_virtual_hosts

        if rollover_type:
            body['rolloverType'] = rollover_type

        if ips:
            body['ipList'] = ips

        if max_scan_time:
            body['maxScanTime'] = max_scan_time * 3600

        return send_request(path, method='post', body=body)

    def launch_scan_command():
        scan_id = demisto.args()['scan_id']
        target_address = demisto.args().get('diagnostic_target')
        target_password = demisto.args().get('diagnostic_password')

        if (target_address and not target_password) or (target_password and not target_address):
            return_error('If a target is provided, both IP/Hostname and the password must be provided')

        res = launch_scan(scan_id, {'address': target_address, 'password': target_password})

        if not res or 'response' not in res or not res['response'] or 'scanResult' not in res['response']:
            return_error('Could not retrieve the scan')

        scan_result = res['response']['scanResult']

        headers = [
            'Name',
            'ID',
            'OwnerID',
            'JobID',
            'Status'
        ]

        mapped_scan = {
            'Name': scan_result['name'],
            'ID': scan_result['id'],
            'OwnerID': scan_result['ownerID'],
            'JobID': scan_result['jobID'],
            'Status': scan_result['status']
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan", mapped_scan, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanResults(val.ID==obj.ID)': createContext(mapped_scan, removeNull=True)
            }
        })


    def launch_scan(scan_id, scan_target):
        path = 'scan/' + scan_id + '/launch'
        body = None
        if scan_target:
            body = {
                'diagnosticTarget': scan_target['address'],
                'diagnosticPassword': scan_target['password']
            }

        return send_request(path, 'post', body=body)

    def get_scan_status_command():
        scan_results_ids = argToList(demisto.args()['scan_results_id'])

        scans_results = []
        for scan_results_id in scan_results_ids:
            res = get_scan_results(scan_results_id)
            if not res or 'response' not in res or not res['response']:
                return_message('Scan results not found')

            scans_results.append(res['response'])

        headers = ['ID','Name','Status','Description']

        mapped_scans_results = [{
            'ID': scan_result['id'],
            'Name': scan_result['name'],
            'Status': scan_result['status'],
            'Description': scan_result['description']
        } for scan_result in scans_results]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable.sc Scan Status", mapped_scans_results, headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.ScanResults(val.ID==obj.ID)': createContext(mapped_scans_results, removeNull=True)
            }
        })


    def get_scan_results(scan_results_id):
        path = 'scanResult/' + scan_results_id

        return send_request(path)

    def get_scan_report_command():
        scan_results_id = demisto.args()['scan_results_id']
        vulnerabilities_to_get = argToList(demisto.args().get('vulnerability_severity', []))

        res = get_scan_report(scan_results_id)

        if not res or 'response' not in res or not res['response']:
            return_message('Scan results not found')

        scan_results = res['response']

        headers = ['ID','Name','Description','Policy','Group','Owner','Group','ScannedIPs','StartTime','EndTime','Duration','Checks','ImportTime''RepositoryName','Status']
        vuln_headers = ['ID','Name','Family','Severity','Total']

        mapped_results = {
            'ID': scan_results['id'],
            'Name': scan_results['name'],
            'Status': scan_results['status'],
            'Description': scan_results['description'],
            'Policy': scan_results['details'],
            'Group': scan_results.get('ownerGroup', {}).get('name'),
            'Status': scan_results['status'],
            'Checks': scan_results['completedChecks'],
            'StartTime': datetime.datetime.utcfromtimestamp(int(scan_results['startTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if scan_results['startTime'] else '',
            'EndTime': datetime.datetime.utcfromtimestamp(int(scan_results['finishTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if scan_results['finishTime'] else '',
            'Duration': float(scan_results['scanDuration']) / 60 if scan_results['scanDuration'] else '',
            'ImportTime': datetime.datetime.utcfromtimestamp(int(scan_results['importStart'])).strftime('%Y-%m-%dT%H:%M:%SZ') if scan_results['importStart'] else '',
            'ScannedIPs': scan_results['scannedIPs'],
            'Owner': scan_results['owner'].get('username'),
            'RepositoryName': scan_results['repository'].get('name')
        }

        hr = tableToMarkdown('Tenable.sc Scan ' + mapped_results['ID'] + ' Report', mapped_results, headers, removeNull=True)

        if len(vulnerabilities_to_get) > 0:
            vulns = get_vulnearbilites(scan_results_id)

            if isinstance(vulns, list):
                vulnerabilities = list(filter(lambda v: v['Severity'] in vulnerabilities_to_get, vulns))
                if vulnerabilities and len(vulnerabilities) > 0:
                    hr += tableToMarkdown('Vulnerabilities', vulnerabilities, vuln_headers, removeNull=True)
                    mapped_results['Vulnerability'] = vulnerabilities


        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                'TenableSC.ScanResults(val.ID==obj.ID)': createContext(mapped_results, removeNull=True)
            }
        })


    def get_scan_report(scan_results_id):
        path = 'scanResult/' + scan_results_id

        params = {
            'fields': 'name,description,details,status,scannedIPs,progress,startTime,scanDuration,importStart,finishTime,completedChecks,owner,ownerGroup,repository,policy'
        }

        return send_request(path, params=params)


    def list_plugins_command():
        name = demisto.args().get('name'),
        cve = demisto.args().get('cve'),
        plugin_type = demisto.args().get('type')

        res = list_plugins(name, plugin_type, cve)

        if not res or 'response' not in res:
            return_message('No plugins found')


        plugins = res['response']

        headers = ['ID','Name','Type','Description','Family']
        mapped_plugins = [{
            'ID': p['id'],
            'Name': p['name'],
            'Type': p['type'],
            'Description': p['description'],
            'Family': p['family'].get('name')
        } for p in plugins]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tenable.sc Plugins', mapped_plugins, headers=headers,removeNull=True),
            'EntryContext': {
                'TenableSC.Plugin(val.ID==obj.ID)': createContext(mapped_plugins, removeNull=True)
            }
        })

    def list_plugins(name, plugin_type, cve):
        path = 'plugin'

        params = {
            'fields': 'id,type,name,description,family'
        }

        if cve:
            params['filterField'] = 'xrefs:CVE'
            params['op'] = 'eq'
            params['value'] = cve


        if plugin_type:
            params['type'] = plugin_type


        return send_request(path, params=params)


    def get_vulnearbilites(scan_results_id):
        query = create_query(scan_results_id, 'vulnipdetail')

        if not query or 'response' not in query:
            return 'Could not get vulnerabilites query'

        analysis = get_analysis(query['response']['id'], scan_results_id)

        if not analysis or 'response' not in analysis:
            return 'Could not get vulnerabilites analysis'

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return 'No vulnerabilities found'


        mapped_vulns = []

        for vuln in results:
            mapped_vuln =  {
                'ID': vuln['pluginID'],
                'Name': vuln['name'],
                'Description': vuln['pluginDescription'],
                'Family': vuln['family'].get('name'),
                'Severity': vuln['severity'].get('name'),
                'Total': vuln['total']
            }

            mapped_vulns.append(mapped_vuln)

        sv = [
          'Critical',
          'High',
          'Medium',
          'Low',
          'Info'
        ]

        mapped_vulns.sort(key=lambda r: r['Severity'], cmp=lambda a,b: sv.index(a) - sv.index(b))

        return mapped_vulns


    def create_query(scan_id, tool, query_filters=None):
        path = 'query'

        body = {
            'name': 'scan ' + scan_id + ' query',
            'type': 'vuln',
            'tool': tool,
            'scanID': scan_id
        }

        if query_filters:
            body['filters'] = query_filters

        return send_request(path, method='post', body=body)

    def get_analysis(query_id, scan_results_id):
        path = 'analysis'

        body = {
            'type': 'vuln',
            'query': {
                'id': query_id
            },
            'sourceType': 'individual',
            'scanID': scan_results_id,
            'view': 'all'
        }

        return send_request(path, method='post', body=body)

    def get_vulnerability_command():
        vuln_id = demisto.args()['vulnerability_id']
        scan_results_id = demisto.args()['scan_results_id']

        vuln_filter = [{
            'filterName': 'pluginID',
            'operator': '=',
            'value': vuln_id
        }]

        query = create_query(scan_results_id, 'vulnipdetail', vuln_filter)

        if not query or 'response' not in query:
            return_error('Could not get vulnerability query')

        analysis = get_analysis(query['response']['id'], scan_results_id)

        if not analysis or 'response' not in analysis:
            return_error('Could not get vulnerability analysis')

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return_error('Vulnerability not found in the scan results')

        vuln_response = get_vulnerability(vuln_id)

        if not vuln_response or 'response' not in vuln_response:
            return_message('Vulnerability not found')

        vuln = vuln_response['response']

        vuln['severity'] = results[0]['severity']
        vuln['hosts'] = results[0]['hosts']

        vuln_hosts = vuln['hosts']
        severity = vuln['severity'].get('name')
        hosts = [{'IP': h['ip'], 'MAC': h['macAddress']} for h in demisto.dt(vuln_hosts, 'iplist')]


        cves = None
        cves_output = []
        if vuln.get('xrefs'):
            # Extract CVE
            cve_filter = list(filter(lambda x: x.strip().startswith('CVE'), vuln['xrefs'].split(',')))
            if cve_filter and len(cve_filter) > 0:
                cves = list(map(lambda c: c.replace('CVE:', '').strip(), cve_filter))
                cves_output += map(lambda c: {
                'ID': c
                }, cves)

        mapped_vuln =  {
            'ID': vuln['id'],
            'Name': vuln['name'],
            'Description': vuln['description'],
            'Type': vuln['type'],
            'Severity': severity,
            'Synopsis': vuln['synopsis'],
            'Solution': vuln['solution'],

        }

        vuln_info = {
            'Published': datetime.datetime.utcfromtimestamp(int(vuln['vulnPubDate'])).strftime('%Y-%m-%dT%H:%M:%SZ') if vuln['vulnPubDate'] else '',
            'CPE': vuln['cpe'],
            'CVE': cves
        }

        exploit_info = {
            'ExploitAvailable': vuln['exploitAvailable'],
            'ExploitEase': vuln['exploitEase']
        }

        risk_info = {
            'RiskFactor': vuln['riskFactor'],
            'CVSSBaseScore': vuln['baseScore'],
            'CVSSTemporalScore': vuln['temporalScore'],
            'CVSSVector': vuln['cvssVector']
        }

        plugin_details = {
            'Family': vuln['family'].get('name'),
            'Published': datetime.datetime.utcfromtimestamp(int(vuln['pluginPubDate'])).strftime('%Y-%m-%dT%H:%M:%SZ') if vuln['pluginPubDate'] else '',
            'Modified': datetime.datetime.utcfromtimestamp(int(vuln['pluginModDate'])).strftime('%Y-%m-%dT%H:%M:%SZ') if vuln['pluginModDate'] else '',
            'CheckType': vuln['checkType']
        }

        hr = '## Vulnerability: {} ({})\n'.format(mapped_vuln['Name'], mapped_vuln['ID'])
        hr += '### Synopsis\n{}\n### Description\n{}\n### Solution\n{}\n'.format(mapped_vuln['Synopsis'], mapped_vuln['Description'], mapped_vuln['Solution'])
        hr += tableToMarkdown('Hosts', hosts, removeNull=True)
        hr += tableToMarkdown('Risk Information', risk_info, removeNull=True)
        hr += tableToMarkdown('Exploit Information', exploit_info, removeNull=True)
        hr += tableToMarkdown('Plugin Details', plugin_details, removeNull=True)
        hr += tableToMarkdown('Vulnerability Information', vuln_info, removeNull=True)

        mapped_vuln.update(vuln_info)
        mapped_vuln.update(exploit_info)
        mapped_vuln.update(risk_info)
        mapped_vuln['PluginDetails'] = plugin_details

        scan_result = {
            'ID': scan_results_id,
            'Vulnerability': mapped_vuln,
        }

        context = {}

        context['TenableSC.ScanResults(val.ID==obj.ID)'] = createContext(scan_result, removeNull=True)
        if len(cves_output) > 0:
            context['CVE(val.ID==obj.ID)'] = createContext(cves_output)

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': vuln_response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': context
        })


    def get_vulnerability(vuln_id):
        path = 'plugin/' + vuln_id

        params = {
            'fields': 'name,description,family,type,cpe,riskFactor,solution,synopsis,exploitEase,exploitAvailable,cvssVector,baseScore,pluginPubDate,pluginModDate,vulnPubDate,temporalScore,xrefs,checkType'
        }

        return send_request(path, params=params)


    def stop_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'stop')

        if not res:
            return_error('Could not stop the scan')

        demisto.results({
                'Type': entryTypes['note'],
                'Contents': res,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Scan succsefully stopped'
            })

    def pause_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'pause')

        if not res:
            return_error('Could not pause the scan')

        demisto.results({
                'Type': entryTypes['note'],
                'Contents': res,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Successfully paused the scan'
            })

    def resume_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'resume')

        if not res:
            return_error('Could not resume the scan')

        demisto.results({
                'Type': entryTypes['note'],
                'Contents': res,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Scan successfully resumed'
            })

    def change_scan_status(scan_results_id, status):
        path = 'scanResult/' + scan_results_id + '/' + status

        return send_request(path, method='post')

    def delete_scan_command():
        scan_id = demisto.args()['scan_id']

        res = delete_scan(scan_id)

        if not res:
            return_error('Could not delete the scan')

        demisto.results({
                'Type': entryTypes['note'],
                'Contents': res,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['text'],
                'HumanReadable': 'Scan successfully deleted'
            })

    def delete_scan(scan_id):
        path = 'scan/' + scan_id

        return send_request(path, method='delete')

    def get_device_command():
        uuid = demisto.args().get('uuid')
        ip = demisto.args().get('ip')
        dns_name = demisto.args().get('dnsName')

        res = get_device(uuid, ip, dns_name)

        if not res or 'response' not in res:
            return_message('Device not found')

        device = res['response']

        headers = [
            'IP',
            'UUID',
            'MacAddress',
            'RepositoryID',
            'RepositoryName',
            'NetbiosName',
            'DNSName',
            'OS',
            'OsCPE',
            'LastScan',
            'TotalScore',
            'LowSeverity',
            'MediumSeverity',
            'HighSeverity',
            'CriticalSeverity'
        ]

        mapped_device = {
            'IP': device['ip'],
            'UUID': device['uuid'],
            'MacAddress': device['macAddress'],
            'RepositoryID': device['repository'].get('id'),
            'RepositoryName': device['repository'].get('name'),
            'NetbiosName': device['netbiosName'],
            'DNSName': device['dnsName'],
            'OS': re.sub('<[^<]+?>', ' ', device['os']).lstrip() if device['os'] else '',
            'OsCPE': device['osCPE'],
            'LastScan': datetime.datetime.utcfromtimestamp(int(device['lastScan'])).strftime('%Y-%m-%dT%H:%M:%SZ') if device['lastScan'] else '',
            'TotalScore': device['total'],
            'LowSeverity': device['severityLow'],
            'MediumSeverity': device['severityMedium'],
            'HighSeverity': device['severityHigh'],
            'CriticalSeverity': device['severityCritical']
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tenable.sc Device', mapped_device, headers=headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Device(val.UUID==obj.UUID)': createContext(mapped_device, removeNull=True)
            }
        })


    def get_device(uuid, ip, dns_name):
        path = 'deviceInfo'
        params = {
            'fields': 'ip,uuid,macAddress,netbiosName,dnsName,os,osCPE,lastScan,repository,total,severityLow,severityMedium,severityHigh,severityCritical'
        }
        if uuid:
            params['uuid'] = uuid
        else:
            params['ip'] = ip
            if dns_name:
                params['dnsName'] = dns_name

        return send_request(path)


    def list_users_command():
        user_id = demisto.args().get('id')
        username = demisto.args().get('username')
        email = demisto.args().get('email')

        res = get_users('id,username,firstname,lastname,title,email,createdTime,modifiedTime,lastLogin,role', user_id)

        if not res or 'response' not in res:
            return_message('No users found')

        users = res['response']

        if not isinstance(users, list):
            users = [users]

        if not user_id:
            if username:
                users = list(filter(lambda u: u['username'] == username, users))
            elif email:
                users = list(filter(lambda u: u['email'] == email, users))

        if len(users) == 0:
            return_message('No users found')

        headers = [
            'ID',
            'Username',
            'Firstname',
            'Lastname',
            'Title',
            'Email',
            'Created',
            'Modified',
            'LastLogin',
            'Role'
        ]

        mapped_users = [{
            'ID': u['id'],
            'Username': u['username'],
            'FirstName': u['firstname'],
            'LastName': u['lastname'],
            'Title': u['title'],
            'Email': u['email'],
            'Created': datetime.datetime.utcfromtimestamp(int(u['createdTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if u['createdTime'] else '',
            'Modified': datetime.datetime.utcfromtimestamp(int(u['modifiedTime'])).strftime('%Y-%m-%dT%H:%M:%SZ') if u['modifiedTime'] else '',
            'LastLogin': datetime.datetime.utcfromtimestamp(int(u['lastLogin'])).strftime('%Y-%m-%dT%H:%M:%SZ') if u['lastLogin'] else '',
            'Role': u['role'].get('name')
        } for u in users]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tenable.sc Users', mapped_users, headers=headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.User(val.ID==obj.ID)': createContext(mapped_users, removeNull=True)
            }
        })

    def get_users(fields, user_id):
        path = 'user'

        if user_id:
            path += '/' + user_id

        params = None

        if fields:
            params = {
                'fields': fields
            }

        return send_request(path)


    def get_system_licensing_command():
        res = get_system_licensing()

        if not res or 'response' not in res:
            return_error('Could not retrieve system licensing')

        status = res['response']

        mapped_licensing = {
            'License': status['licenseStatus'],
            'LicensedIPS': status['licensedIPs'],
            'ActiveIPS': status['activeIPs']
        }

        headers = [
            'License',
            'LicensedIPS',
            'ActiveIPS'
        ]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tenable.sc Licensing information', mapped_licensing, headers=headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Status': createContext(mapped_licensing, removeNull=True)
            }
        })



    def get_system_licensing():
        path = 'status'

        return send_request(path)


    def get_system_information_command():
        sys_res = get_system()

        if not sys_res or 'response' not in sys_res:
            return_error('Could not retrieve system information')

        diag_res = get_system_diagnostics()

        if not diag_res or 'response' not in diag_res:
            return_error('Could not retrieve system information')

        sys_res.update(diag_res)
        diagnostics = diag_res['response']
        system = sys_res['response']

        mapped_information = {
            'Version': system['version'],
            'BuildID': system['buildID'],
            'ReleaseID': system['releaseID'],
            'License': system['licenseStatus'],
            'RPMStatus': diagnostics['statusRPM'],
            'JavaStatus': diagnostics['statusJava'],
            'DiskStatus': diagnostics['statusDisk'],
            'DiskThreshold': diagnostics['statusThresholdDisk'],
            'LastCheck': datetime.datetime.utcfromtimestamp(int(diagnostics['statusLastChecked'])).strftime('%Y-%m-%dT%H:%M:%SZ') if diagnostics['statusLastChecked'] else '',
        }

        headers = [
            'Version',
            'BuildID',
            'ReleaseID',
            'License',
            'RPMStatus',
            'JavaStatus',
            'DiskStatus',
            'DiskThreshold',
            'LastCheck'
        ]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': sys_res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tenable.sc System information', mapped_information, headers=headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.System(val.BuildID==obj.BuildID)': createContext(mapped_information, removeNull=True)
            }
        })


    def get_system_diagnostics():
        path = 'system/diagnostics'

        return send_request(path)

    def get_system():
        path = 'system'

        return send_request(path)


    def list_alerts_command():
        res = get_alerts(fields='id,name,description,didTriggerLastEvaluation,lastTriggered,action,lastEvaluated,ownerGroup,owner')
        manageable = demisto.args().get('manageable', 'false').lower()

        if not res or 'response' not in res or not res['response']:
            return_message('No alerts found')

        alerts = get_elements(res['response'], manageable)

        if len(alerts) == 0:
            return_message('No alerts found')

        headers = ['ID','Name','Action','State','LastTriggered','LastEvaluated','Group','Owner']
        mapped_alerts = [{
            'ID': a['id'],
            'Name': a['name'],
            'State': 'Triggered' if a['didTriggerLastEvaluation'] == 'true' else 'Not Triggered',
            'Actions': demisto.dt(a['action'], 'type'),
            'LastTriggered': datetime.datetime.utcfromtimestamp(int(a['lastTriggered'])).strftime('%Y-%m-%dT%H:%M:%SZ') if a['lastTriggered'] and int(a['lastTriggered']) > 0 else 'Never',
            'LastEvaluated': datetime.datetime.utcfromtimestamp(int(a['lastEvaluated'])).strftime('%Y-%m-%dT%H:%M:%SZ') if a['lastEvaluated'] else '',
            'Group': a['ownerGroup'].get('name'),
            'Owner': a['owner'].get('username')
        } for a in alerts]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tenable.sc Alerts', mapped_alerts, headers=headers, removeNull=True),
            'EntryContext': {
                  'TenableSC.Alert(val.ID==obj.ID)': createContext(mapped_alerts, removeNull=True)
            }
        })


    def get_alert_command():
        alert_id = demisto.args()['alert_id']
        res = get_alerts(None, alert_id)

        if not res or 'response' not in res or not res['response']:
            return_message('Alert not found')

        alert = res['response']
        query_res = get_query(alert['query'].get('id'))
        query = query_res.get('response')


        alert_headers = ['ID','Name','Description','LastTriggered','State','Behavior','Actions']
        query_headers = ['Trigger','Query']
        filter_headers = ['Name','Values']
        mapped_alert = {
            'ID': alert['id'],
            'Name': alert['name'],
            'Description': alert['description'],
            'LastTriggered': datetime.datetime.utcfromtimestamp(int(alert['lastTriggered'])).strftime('%Y-%m-%dT%H:%M:%SZ') if alert['lastTriggered'] and int(alert['lastTriggered']) > 0 else 'Never',
            'State': 'Triggered' if alert['didTriggerLastEvaluation'] == 'true' else 'Not Triggered',
            'Behavior': 'Execute on every trigger ' if alert['executeOnEveryTrigger'] == 'true' else 'Execute only on first trigger',
            'Actions': demisto.dt(alert['action'], 'type')
        }

        mapped_condition = {
            'Trigger': '{} {} {}'.format(alert['triggerName'],alert['triggerOperator'],alert['triggerValue']),
            'Query': alert['query'].get('name')
        }

        mapped_filters = None
        if query:
            mapped_filters = [{
                'Name': f['filterName'],
                'Values': demisto.dt(f['value'], 'name') if isinstance(f['value'], list) else f['value']
                } for f in query.get('filters', [])]
            mapped_condition['Filter'] = mapped_filters

        hr = tableToMarkdown('Tenable.sc Alert', mapped_alert, headers=alert_headers, removeNull=True)
        hr += tableToMarkdown('Condition', mapped_condition, headers=query_headers, removeNull=True)
        if mapped_filters:
            hr += tableToMarkdown('Filters', mapped_filters, headers=filter_headers, removeNull=True)

        mapped_alert['Condition'] = mapped_condition

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'TenableSC.Alert(val.ID==obj.ID)': createContext(mapped_alert, removeNull=True)
            }
        })



    def get_alerts(fields, alert_id=None):
        path = 'alert'
        params = {}

        if alert_id:
            path += '/' + alert_id

        if fields:
            params = {
                'fields': fields
            }

        return send_request(path, params=params)

    def get_query(query_id):
        path = 'query/' + query_id

        return send_request(path)


    def fetch_incidents():
        incidents = []
        last_run = demisto.getLastRun()
        if 'time' not in last_run:
            timestamp = int(time.time())
        else:
            timestamp = last_run['time']

        res = get_alerts(fields='id,name,description,lastTriggered,triggerName,triggerOperator,triggerValue,action,query,owner')

        for alert in get_elements(res.get('response', {}), False):
            if int(alert.get('lastTriggered', 0)) > timestamp:
                labels = []
                for k,v in alert.iteritems():
                    if isinstance(v, basestring):
                        labels.append({
                            'type': k,
                            'value': v
                        })
                    else:
                        labels.append({
                            'type': k,
                            'value': json.dumps(v)
                        })

                incidents.append({
                    'name': 'Tenable.sc Alert Triggered - ' + alert['name'],
                    'labels': labels,
                    'occurred': datetime.datetime.utcfromtimestamp(int(alert['lastTriggered'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'details': json.dumps(alert),
                    'rawJSON': json.dumps(alert)
                })

                timestamp = int(alert['lastTriggered'])

        demisto.incidents(incidents)
        demisto.setLastRun({'time': timestamp})


    ''' LOGIC '''

    LOG('Executing command ' + demisto.command())

    SESSION = Session()
    token = login(USERNAME, PASSWORD)
    SESSION.headers.update({'X-SecurityCenter': str(token)})

    try:
        if demisto.command() == 'test-module':
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() == 'tenable-sc-list-scans':
            list_scans_command()
        elif demisto.command() == 'tenable-sc-list-policies':
            list_policies_command()
        elif demisto.command() == 'tenable-sc-list-repositories':
            list_repositories_command()
        elif demisto.command() == 'tenable-sc-list-credentials':
            list_credentials_command()
        elif demisto.command() == 'tenable-sc-list-zones':
            list_zones_command()
        elif demisto.command() == 'tenable-sc-list-report-definitions':
            list_report_definitions_command()
        elif demisto.command() == 'tenable-sc-list-assets':
            list_assets_command()
        elif demisto.command() == 'tenable-sc-list-plugins':
            list_plugins_command()
        elif demisto.command() == 'tenable-sc-get-asset':
            get_asset_command()
        elif demisto.command() == 'tenable-sc-create-asset':
            create_asset_command()
        elif demisto.command() == 'tenable-sc-delete-asset':
            delete_asset_command()
        elif demisto.command() == 'tenable-sc-create-scan':
            create_scan_command()
        elif demisto.command() == 'tenable-sc-launch-scan':
            launch_scan_command()
        elif demisto.command() == 'tenable-sc-get-scan-status':
            get_scan_status_command()
        elif demisto.command() == 'tenable-sc-get-scan-report':
            get_scan_report_command()
        elif demisto.command() == 'tenable-sc-get-vulnerability':
            get_vulnerability_command()
        elif demisto.command() == 'tenable-sc-delete-scan':
            delete_scan_command()
        elif demisto.command() == 'tenable-sc-get-device':
            get_device_command()
        elif demisto.command() == 'tenable-sc-list-users':
            list_users_command()
        elif demisto.command() == 'tenable-sc-list-alerts':
            list_alerts_command()
        elif demisto.command() == 'tenable-sc-get-alert':
            get_alert_command()
        elif demisto.command() == 'tenable-sc-get-system-information':
            get_system_information_command()
        elif demisto.command() == 'tenable-sc-get-system-licensing':
            get_system_licensing_command()
    except Exception as e:
        LOG(e)
        LOG.print_log(False)
        return_error(e.message)
    finally:
        logout()
  type: python
  commands:
  - name: tenable-sc-list-scans
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable scans. Returns both usable and
        manageable scans by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.ID
      description: Scan ID
      type: number
    - contextPath: TenableSC.Scan.Description
      description: Scan description
      type: string
    - contextPath: TenableSC.Scan.Policy
      description: Scan policy name
      type: string
    - contextPath: TenableSC.Scan.Group
      description: Scan policy owner group name
      type: string
    - contextPath: TenableSC.Scan.Owner
      description: Scan policy owner user name
      type: string
    description: Get a list of Tenable.sc existing scans
  - name: tenable-sc-launch-scan
    arguments:
    - name: scan_id
      required: true
      description: Scan ID, can be retrieved from list-scans command
    - name: diagnostic_target
      description: Valid IP/Hostname of a specific target to scan. Must be provided
        with diagnosticPassword.
    - name: diagnostic_password
      description: Non empty string password
    outputs:
    - contextPath: TenableSC.ScanResults.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.ScanResults.ID
      description: Scan Results ID
      type: string
    - contextPath: TenableSC.ScanResults.OwnerID
      description: Scan owner ID
      type: string
    - contextPath: TenableSC.ScanResults.JobID
      description: Job ID
      type: string
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status
      type: string
    description: Launch an existing scan from Tenable.sc
  - name: tenable-sc-get-vulnerability
    arguments:
    - name: vulnerability_id
      required: true
      description: Vulnerability ID from the scan-report command
    - name: scan_results_id
      required: true
      description: Scan results ID from the scan-report command
    outputs:
    - contextPath: TenableSC.ScanResults.ID
      description: Scan results ID
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.ID
      description: Vulnerability plugin ID
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.Name
      description: Vulnerability name
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Description
      description: Vulnerability description
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Type
      description: Vulnerability type
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Severity
      description: Vulnerability Severity
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Synopsis
      description: Vulnerability Synopsis
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Solution
      description: Vulnerability Solution
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Published
      description: Vulnerability publish date
      type: date
    - contextPath: TenableSC.ScanResults.Vulnerability.CPE
      description: Vulnerability CPE
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.CVE
      description: Vulnerability CVE
    - contextPath: TenableSC.ScanResults.Vulnerability.ExploitAvailable
      description: Vulnerability exploit available
      type: boolean
    - contextPath: TenableSC.ScanResults.Vulnerability.ExploitEase
      description: Vulnerability exploit ease
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.RiskFactor
      description: Vulnerability risk factor
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.CVSSBaseScore
      description: Vulnerability CVSS base score
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.CVSSTemporalScore
      description: Vulnerability CVSS temporal score
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.CVSSVector
      description: Vulnerability CVSS vector
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.PluginDetails
      description: Vulnerability plugin details
    - contextPath: CVE.ID
      description: CVE ID
    description: 'Get details about a given vulnerability from a given Tenable.sc
      scan '
  - name: tenable-sc-get-scan-status
    arguments:
    - name: scan_results_id
      required: true
      description: Scan results ID from the launch-scan command
      isArray: true
    outputs:
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status
      type: string
    - contextPath: TenableSC.ScanResults.Name
      description: Scan Name
      type: string
    - contextPath: TenableSC.ScanResults.Description
      description: Scan description
    - contextPath: TenableSC.ScanResults.ID
      description: Scan results ID
    description: Get the status of a specific scan in Tenable.sc
  - name: tenable-sc-get-scan-report
    arguments:
    - name: scan_results_id
      required: true
      description: Scan results ID
    - name: vulnerability_severity
      description: Comma separated list of severity values of vulnerabilities to retrieve
      isArray: true
      defaultValue: Critical,High,Medium,Low,Info
    outputs:
    - contextPath: TenableSC.ScanResults.ID
      description: Scan results ID
      type: number
    - contextPath: TenableSC.ScanResults.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status
      type: string
    - contextPath: TenableSC.ScanResults.ScannedIPs
      description: Scan number of scanned IPs
      type: number
    - contextPath: TenableSC.ScanResults.StartTime
      description: Scan start time
      type: date
    - contextPath: TenableSC.ScanResults.EndTime
      description: Scan end time
      type: date
    - contextPath: TenableSC.ScanResults.Checks
      description: Scan completed checks
      type: number
    - contextPath: TenableSC.ScanResults.RepositoryName
      description: Scan repository name
      type: string
    - contextPath: TenableSC.ScanResults.Description
      description: Scan description
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.ID
      description: Scan vulnerability ID
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.Name
      description: Scan vulnerability Name
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Family
      description: Scan vulnerability family
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Severity
      description: Scan vulnerability severity
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Total
      description: Scan vulnerability total hosts
      type: number
    - contextPath: TenableSC.ScanResults.Policy
      description: Scan policy
      type: string
    - contextPath: TenableSC.ScanResults.Group
      description: Scan owner group name
      type: string
    - contextPath: TenableSC.ScanResults.Owner
      description: Scan owner user name
      type: string
    - contextPath: TenableSC.ScanResults.Duration
      description: Scan duration in minutes
      type: number
    - contextPath: TenableSC.ScanResults.ImportTime
      description: Scan import time
      type: date
    description: Get a report with a Tenable.sc scan results
  - name: tenable-sc-list-credentials
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable scan credentials. Returns both
        usable and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Credential.Name
      description: Credential name
      type: string
    - contextPath: TenableSC.Credential.ID
      description: Credential ID
      type: number
    - contextPath: TenableSC.Credential.Description
      description: Credential description
      type: string
    - contextPath: TenableSC.Credential.Type
      description: Credential type
      type: string
    - contextPath: TenableSC.Credential.Tag
      description: Credential tag
      type: string
    - contextPath: TenableSC.Credential.Group
      description: Credential owner group name
      type: string
    - contextPath: TenableSC.Credential.Owner
      description: Credential owner user name
      type: string
    - contextPath: TenableSC.Credential.LastModified
      description: Credential last modified time
      type: date
    description: Get a list of Tenable.sc credentials
  - name: tenable-sc-list-policies
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable scan policies. Returns both usable
        and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.ScanPolicy.Name
      description: Scan policy name
      type: string
    - contextPath: TenableSC.ScanPolicy.ID
      description: Scan policy ID
      type: number
    - contextPath: TenableSC.ScanPolicy.Description
      description: Scan policy description
      type: string
    - contextPath: TenableSC.ScanPolicy.Tag
      description: Scan policy tag
      type: string
    - contextPath: TenableSC.ScanPolicy.Group
      description: Scan policy owner group name
      type: string
    - contextPath: TenableSC.ScanPolicy.Owner
      description: Scan policy owner user name
      type: string
    - contextPath: TenableSC.ScanPolicy.LastModified
      description: Scan policy last modified time
      type: date
    - contextPath: TenableSC.ScanPolicy.Type
      description: Scan policy type
      type: string
    description: Get a list of Tenable.sc scan policies
  - name: tenable-sc-list-report-definitions
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable reports. Returns both usable
        and manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.ReportDefinition.Name
      description: Report definition name
      type: string
    - contextPath: TenableSC.ReportDefinition.ID
      description: Report definition ID
      type: number
    - contextPath: TenableSC.ReportDefinition.Description
      description: Report definition description
      type: string
    - contextPath: TenableSC.ReportDefinition.Type
      description: Report definition type
      type: string
    - contextPath: TenableSC.ReportDefinition.Group
      description: Report definition owner group name
      type: string
    - contextPath: TenableSC.ReportDefinition.Owner
      description: Report definition owner user name
      type: string
    description: Get a list of Tenable.sc report definitions
  - name: tenable-sc-list-repositories
    arguments: []
    outputs:
    - contextPath: TenableSC.ScanRepository.Name
      description: Scan Repository name
      type: string
    - contextPath: TenableSC.ScanRepository.ID
      description: Scan Repository ID
      type: number
    - contextPath: TenableSC.ScanRepository.Description
      description: Scan Repository
      type: string
    description: Get a list of Tenable.sc scan repositories
  - name: tenable-sc-list-zones
    arguments: []
    outputs:
    - contextPath: TenableSC.ScanZone.Name
      description: Scan Zone name
      type: string
    - contextPath: TenableSC.ScanZone.ID
      description: Scan Zone ID
      type: number
    - contextPath: TenableSC.ScanZone.Description
      description: Scan Zone description
      type: string
    - contextPath: TenableSC.ScanZone.IPList
      description: Scan Zone IP list
      type: unknown
    - contextPath: TenableSC.ScanZone.ActiveScanners
      description: Scan Zone active scanners
      type: number
    description: Get a list of Tenable.sc scan zones
  - name: tenable-sc-create-scan
    arguments:
    - name: name
      required: true
      description: Scan name
    - name: policy_id
      required: true
      description: Policy ID, can be retrieved from list-policies command
    - name: description
      description: Scan description
    - name: repository_id
      required: true
      description: Scan Repository ID, can be retrieved from list-repositories command
    - name: zone_id
      description: Scan zone ID (default is all zones), can be retrieved from list-zones
        command
    - name: schedule
      auto: PREDEFINED
      predefined:
      - dependent
      - ical
      - never
      - rollover
      description: Schedule for the scan
    - name: asset_ids
      auto: PREDEFINED
      predefined:
      - All
      - AllManageable
      description: Either all assets or comma separated asset IDs to scan, can be
        retrieved from list-assets command
      isArray: true
    - name: scan_virtual_hosts
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to includes virtual hosts, default false
    - name: ip_list
      description: Comma separated IPs to scan e.g 10.0.0.1,10.0.0.2
    - name: report_ids
      description: Comma separated list of report definition IDs to create post-scan,
        can be retrieved from list-report-definitions command
      isArray: true
    - name: credentials
      description: Comma separated credentials IDs to use, can be retrieved from list-credentials
        command
      isArray: true
    - name: timeout_action
      auto: PREDEFINED
      predefined:
      - discard
      - import
      - rollover
      description: Scan timeout action, default is import
    - name: max_scan_time
      description: Maximum scan run time in hours, default is 1
    - name: dhcp_tracking
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Track hosts which have been issued new IP address, (e.g. DHCP)
    - name: rollover_type
      auto: PREDEFINED
      predefined:
      - nextDay
      description: Scan rollover type
    - name: dependent_id
      description: Dependent scan ID in case of a dependent schedule, can be retrieved
        from list-scans command
    outputs:
    - contextPath: TenableSC.Scan.ID
      description: Scan ID
      type: string
    - contextPath: TenableSC.Scan.CreatorID
      description: Scan's creator ID
      type: string
    - contextPath: TenableSC.Scan.Name
      description: Scan Name
      type: string
    - contextPath: TenableSC.Scan.Type
      description: Scan type
      type: string
    - contextPath: TenableSC.Scan.CreatedTime
      description: Scan creation time
      type: date
    - contextPath: TenableSC.Scan.OwnerName
      description: Scan owner Username
      type: string
    - contextPath: TenableSC.Scan.Reports
      description: Scan report defintion IDs
      type: unknown
    description: Create a scan on Tenable.sc
  - name: tenable-sc-delete-scan
    arguments:
    - name: scan_id
      required: true
      description: Scan ID, can be. retrieved from the list-scans command
    description: Delete a scan in Tenable.sc
  - name: tenable-sc-list-assets
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable assets. Returns both usable and
        manageable by default.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: string
    - contextPath: TenableSC.Asset.Name
      description: Asset Name
      type: string
    - contextPath: TenableSC.Asset.HostCount
      description: Asset host IPs count
      type: number
    - contextPath: TenableSC.Asset.Type
      description: Asset type
      type: string
    - contextPath: TenableSC.Asset.Tag
      description: Asset tag
      type: string
    - contextPath: TenableSC.Asset.Owner
      description: Asset owner username
      type: string
    - contextPath: TenableSC.Asset.Group
      description: Asset group
      type: string
    - contextPath: TenableSC.Asset.LastModified
      description: Asset last modified time
      type: date
    description: Get a list of Tenable.sc Assets
  - name: tenable-sc-create-asset
    arguments:
    - name: name
      required: true
      description: Asset Name
    - name: description
      description: Asset description
    - name: owner_id
      description: Asset owner ID, default is the Session User ID, can be retrieved
        from the list-users command
    - name: tag
      description: 'Asset tag '
      isArray: true
    - name: ip_list
      required: true
      description: Comma separated list of IPs to include in the asset, e.g 10.0.0.2,10.0.0.4
    outputs:
    - contextPath: TenableSC.Asset.Name
      description: Asset Name
      type: string
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: string
    - contextPath: TenableSC.Asset.OwnerName
      description: Asset owner name
      type: string
    - contextPath: TenableSC.Asset.Tags
      description: Asset tags
      type: string
    description: Create an Asset in Tenable.sc with provided IP addresses
  - name: tenable-sc-get-asset
    arguments:
    - name: asset_id
      required: true
      description: Asset ID that can be retrieved from the list-assets command
    outputs:
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: number
    - contextPath: TenableSC.Asset.Name
      description: Asset name
      type: string
    - contextPath: TenableSC.Asset.Description
      description: Asset description
      type: string
    - contextPath: TenableSC.Asset.Tag
      description: Asset tag
      type: string
    - contextPath: TenableSC.Asset.Modified
      description: Asset last modified time
      type: date
    - contextPath: TenableSC.Asset.Owner
      description: Asset owner user name
      type: string
    - contextPath: TenableSC.Asset.Group
      description: Asset owner group
      type: string
    - contextPath: TenableSC.Asset.IPs
      description: Asset viewable IPs
      type: unknown
    description: Get details for a given asset in Tenable.sc
  - name: tenable-sc-delete-asset
    arguments:
    - name: asset_id
      required: true
      description: Asset ID
    description: Delete the Asset with the given ID from Tenable.sc
    execution: true
  - name: tenable-sc-list-alerts
    arguments:
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to return only manageable alerts. Returns both usable and
        manageable by default.
    outputs:
    - contextPath: TenableSC.Alert.ID
      description: Alert ID
      type: string
    - contextPath: TenableSC.Alert.Name
      description: Alert name
      type: string
    - contextPath: TenableSC.Alert.Description
      description: Alert description
      type: string
    - contextPath: TenableSC.Alert.State
      description: Alert state
      type: string
    - contextPath: TenableSC.Alert.Actions
      description: Alert Actions
      type: string
    - contextPath: TenableSC.Alert.LastTriggered
      description: Alert last triggered time
      type: date
    - contextPath: TenableSC.Alert.LastEvaluated
      description: Alert last evaluated time
      type: date
    - contextPath: TenableSC.Alert.Group
      description: Alert owner group name
      type: string
    - contextPath: TenableSC.Alert.Owner
      description: Alert owner user name
      type: string
    description: List alerts from Tenable.sc
  - name: tenable-sc-get-alert
    arguments:
    - name: alert_id
      required: true
      description: Alert ID, can be retrieved from list-alerts command
    outputs:
    - contextPath: TenableSC.Alert.ID
      description: Alert ID
      type: string
    - contextPath: TenableSC.Alert.Name
      description: Alert name
      type: string
    - contextPath: TenableSC.Alert.Description
      description: Alert description
      type: string
    - contextPath: TenableSC.Alert.State
      description: Alert state
      type: string
    - contextPath: TenableSC.Alert.Condition.Trigger
      description: Alert trigger
      type: string
    - contextPath: TenableSC.Alert.LastTriggered
      description: Alert last triggered time
      type: date
    - contextPath: TenableSC.Alert.Action
      description: Alert action type
      type: string
    - contextPath: TenableSC.Alert.Condition.Query
      description: Alert query name
      type: string
    - contextPath: TenableSC.Alert.Condition.Filter.Name
      description: Alert query filter name
      type: string
    - contextPath: TenableSC.Alert.Condition.Filter.Values
      description: Alert query filter values
    description: Get information about a given alert in tenabel.sc
  - name: tenable-sc-get-device
    arguments:
    - name: ip
      description: A valid IP address to filter by
    - name: dnsName
      description: DNS name for the IP address
    outputs:
    - contextPath: TenableSC.Device.IP
      description: Device IP address
      type: string
    - contextPath: TenableSC.Device.UUID
      description: Device UUID
      type: string
    - contextPath: TenableSC.Device.RepositoryID
      description: Device repository ID
      type: string
    - contextPath: TenableSC.Device.MacAddress
      description: Device Mac address
      type: string
    - contextPath: TenableSC.Device.NetbiosName
      description: Device Netbios name
      type: string
    - contextPath: TenableSC.Device.DNSName
      description: Device DNS name
      type: string
    - contextPath: TenableSC.Device.OS
      description: Device Operating System
      type: string
    - contextPath: TenableSC.Device.OsCPE
      description: Device Common Platform Enumeration
      type: string
    - contextPath: TenableSC.Device.LastScan
      description: Device's last scan time
      type: date
    - contextPath: TenableSC.Device.RepositoryName
      description: Device repository name
      type: string
    - contextPath: TenableSC.Device.TotalScore
      description: Device total threat score
      type: number
    - contextPath: TenableSC.Device.LowSeverity
      description: Device total threat scores with low severity
      type: number
    - contextPath: TenableSC.Device.MediumSeverity
      description: Device total threat scores with medium severity
      type: number
    - contextPath: TenableSC.Device.HighSeverity
      description: Device total threat scores with high severity
      type: number
    - contextPath: TenableSC.Device.CriticalSeverity
      description: Device total threat scores with critical severity
      type: number
    description: Gets the device information from the current user in Tenable.sc
  - name: tenable-sc-list-users
    arguments:
    - name: id
      description: Filter by user ID
    - name: username
      description: Filter by user username
    - name: email
      description: Filter by user email address
    outputs:
    - contextPath: TenableSC.User.ID
      description: User ID
      type: string
    - contextPath: TenableSC.User.Username
      description: Username
      type: string
    - contextPath: TenableSC.User.FirstName
      description: User first name
      type: string
    - contextPath: TenableSC.User.LastName
      description: User last name
      type: string
    - contextPath: TenableSC.User.Title
      description: User title
      type: string
    - contextPath: TenableSC.User.Email
      description: User email address
      type: string
    - contextPath: TenableSC.User.Created
      description: The creation time of the user
      type: date
    - contextPath: TenableSC.User.Modified
      description: Last modification time of the user
      type: date
    - contextPath: TenableSC.User.Login
      description: User last login
      type: date
    - contextPath: TenableSC.User.Role
      description: User role name
      type: string
    description: List users in Tenable.sc
  - name: tenable-sc-get-system-licensing
    arguments: []
    outputs:
    - contextPath: TenableSC.Status.ActiveIPS
      description: Number of active IP addresses
      type: number
    - contextPath: TenableSC.Status.LicensedIPS
      description: Number of licensed IP addresses
    - contextPath: TenableSC.Status.License
      description: License status
    description: Retrieve licensing information from Tenable.sc
  - name: tenable-sc-get-system-information
    arguments: []
    outputs:
    - contextPath: TenableSC.System.Version
      description: System version
      type: string
    - contextPath: TenableSC.System.BuildID
      description: System build ID
      type: string
    - contextPath: TenableSC.System.ReleaseID
      description: System release ID
      type: string
    - contextPath: TenableSC.System.License
      description: System license status
      type: string
    - contextPath: TenableSC.System.JavaStatus
      description: Server java status
      type: boolean
    - contextPath: TenableSC.System.RPMStatus
      description: Server RPM status
      type: boolean
    - contextPath: TenableSC.System.DiskStatus
      description: Server disk status
      type: boolean
    - contextPath: TenableSC.System.DiskThreshold
      description: System left space on disk
      type: number
    - contextPath: TenableSC.System.LastCheck
      description: System last check time
      type: date
    description: Get the system information and diagnostics from Tenable.sc
releaseNotes: "tenable.sc integration"
tests:
  - tenable-sc-test