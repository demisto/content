commonfields:
  id: XFE
  version: -1
name: XFE
display: IBM X-Force Exchange
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: IBM X-Force Exchange lets you receive threat intelligence about applications,
  IP addresses, URls and hashes
detaileddescription: |-
  Don’t have XFE credentials?
  Create IBM ID: https://www.ibm.com/account/profile/us?page=reg
  Login to XFE: https://exchange.xforce.ibmcloud.com/
  Select the “Show User Menu” icon
  Choose settings / API Access / Generate

  Indicators threshold:
  Configure the default threshold for each indicator type in the instance settings.
  Note that it is also possible to specify the threshold when runing the command.
  Indicators with risk score equal or bigger than the threshold will be considered malicious.
  Indicators with risk score equal or bigger than half of the threshold value, and lower than the threshold, will be considered suspicious.
configuration:
- display: Language
  name: Language
  defaultvalue: en-US
  type: 0
  required: true
- display: API Key
  name: authentication
  defaultvalue: ""
  type: 9
  required: true
- display: Use system proxy settings
  name: useproxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: IP Threshold. Minimum risk score for the IP to be consodered malicious
    (ranges from 1 to 10).
  name: ipThreshold
  defaultvalue: "7"
  type: 0
  required: false
- display: URL Threshold. Minimum risk score for the URL to be consodered malicious
    (ranges from 1 to 10).
  name: urlThreshold
  defaultvalue: "7"
  type: 0
  required: false
script:
  script: |-
    var SERVER = 'https://api.xforce.ibmcloud.com/';


    function doReq(method, path, query, body) {
        var result = http(
            SERVER + path + encodeToURLQuery(query),
            {
                Headers: {'Content-Type': ['application/json'], 'Accept': ['application/json'], 'Accept-Language': [params.Language]},
                Method: method,
                Body: body ? JSON.stringify(body) : '',
                Username: params.authentication.identifier,
                Password: params.authentication.password
            },
            params.insecure,
            params.useproxy
        );

        if (result.StatusCode == 401) {
            throw '401 Unauthorized - Wrong or invalid API key.';
        }
        if (result.StatusCode < 200 || result.StatusCode > 299 && result.StatusCode != 404) {
            throw 'Failed to perform request ' + path + ', request status code: ' + result.StatusCode + ', body: ' + result.Body;
        }
        if (result.Body === '') {
            throw 'No content recieved.';
        }
        var obj;
        try {
            obj = JSON.parse(result.Body);
        } catch (ex) {
            throw 'Error parsing reply - ' + result.Body + ' - ' + ex;
        }
        if (obj.error && result.StatusCode != 404) {
            throw 'XFE error - ' + obj.error;
        }
        return {body: result.Body, obj: obj, statusCode: result.StatusCode};
    }


    function doFile(hash, longFormat) {
        var res = doReq('GET', 'malware/' + hash);
        if (res.statusCode === 404) {
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json,
                HumanReadable: 'XFE does not have details about ' + hash};
        }
        var o = res.obj.malware;
        var ec = {};
        var dbotScore = 0;
        if (o && o.family) {
            dbotScore = 3;
        } else if (o && o.risk === 'high') {
            dbotScore = 3;
        } else if (o && o.risk === 'medium') {
            dbotScore = 2;
        } else if (o) {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: hash, Type: 'hash', Vendor: 'XFE', Score: dbotScore};
        if (dbotScore === 3) {
            var malFile = {Malicious: {Vendor: 'XFE', Description: 'Risk: ' + o.risk + ' Family: ' + o.family, Score: o.risk}};
            malFile[o.type.toUpperCase()] = hash;
            addMalicious(ec, outputPaths.file, malFile);
        }
        var md = '## X-Force Hash Reputation for: ' + hash + '\n';
        md += 'Type: **' + o.type + '**\n';
        md += 'Risk: **' + o.risk + '**\n';
        md += 'Created: **' + o.created + '**\n';
        md += 'Family: **' + (o.family ? o.family.join(', ') : 'N/A') + '**\n';
        md += 'Family members: **' + (o.familyMembers ? Object.keys(o.familyMembers).map(function(curr) {return curr + ' (' + o.familyMembers[curr].count + ')';}).join(', ') : 'N/A') + '**\n';
        md += 'XFE Link: [' + hash + '](https://exchange.xforce.ibmcloud.com/malware/' + hash + ')\n';
        if (longFormat === 'true' && o.origins) {
            if (o.origins.CnCServers && o.origins.CnCServers.rows) {
                md += '### CNC Servers\n';
                md += arrToMd(o.origins.CnCServers.rows) + '\n';
            }
            if (o.origins.downloadServers && o.origins.downloadServers.rows) {
                md += '### Download Servers\n';
                md += arrToMd(o.origins.downloadServers.rows) + '\n';
            }
            if (o.origins.emails && o.origins.emails.rows) {
                md += '### Emails\n';
                md += arrToMd(o.origins.emails.rows) + '\n';
            }
            if (o.origins.subjects && o.origins.subjects.rows) {
                md += '### Subjects\n';
                md += arrToMd(o.origins.subjects.rows) + '\n';
            }
            if (o.origins.external) {
                md += '### External\n';
                md += objToMd(o.origins.external) + '\n';
            }
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    }


    var doIP = function(ip, longFormat, threshold) {
        if (!threshold) {
            threshold = params.ipThreshold || 7;
        }
        threshold = parseInt(threshold);
        // Need to make sure to be backwards compatible with the JSON
        var res = {};
        var ipRes = doReq('GET', 'ipr/' + ip);
        if (ipRes.statusCode === 404) {
            return {Type: entryTypes.note, Contents: ipRes.body, ContentsFormat: formats.json,
                HumanReadable: 'XFE does not have details about ' + ip};
        }
        var malwareRes = doReq('GET', 'ipr/malware/' + ip);
        res.reputation = ipRes.obj;
        res.malware = malwareRes.obj;
        var o = res.reputation;
        var ec = {};
        var dbotScore = 0;
        if (o.score && o.score >= threshold) {
            dbotScore = 3;
            addMalicious(ec, outputPaths.ip, {Address: ip, Malicious: {Vendor: 'XFE', Description: 'Score above ' + threshold, Score: o.score}});
        } else if (o.score && o.score >= threshold / 2) {
            dbotScore = 2;
        } else if (o.score) {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'XFE', Score: dbotScore};
        var md = '## X-Force IP Reputation for: ' + ip + '\n';
        md += 'Score: **' + o.score + '**\n';
        md += 'Categories: **' + Object.keys(o.cats).map(function(curr) {return curr + ' (' + o.cats[curr] + ')';}).join(', ') + '**\n';
        md += 'Country: **' + (o.geo && o.geo.country ? o.geo.country : 'N/A') + '**\n';
        md += 'Reason: **' + o.reason + '**\n';
        md += 'Reason description: **' + o.reasonDescription + '**\n';
        md += 'XFE Link: [' + ip + '](https://exchange.xforce.ibmcloud.com/ip/' + ip + ')\n';
        if (o.subnets) {
            md += '### Subnets\n';
            md += arrToMd(o.subnets) + '\n';
        }
        if (longFormat === 'true') {
            if (o.history) {
                md += '### History\n';
                md += arrToMd(o.history) + '\n';
            }
            if (res.malware.malware) {
                md += '### Malware\n';
                md += arrToMd(res.malware.malware) + '\n';
            }
        }
        return {Type: entryTypes.note, Contents: JSON.stringify(res), ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    var doURL = function(url, longFormat, threshold) {
        if (!threshold) {
            threshold = params.urlThreshold || 7;
        }
        threshold = parseInt(threshold);
        // Need to make sure to be backwards compatible with the JSON
        var res = {};
        var resolutionRes = doReq('GET', 'resolve/' + url);
        if (resolutionRes.statusCode === 404) {
            return {Type: entryTypes.note, Contents: resolutionRes.body, ContentsFormat: formats.json,
                HumanReadable: 'XFE does not have details about ' + url};
        }
        var urlRes = doReq('GET', 'url/' + url);
        if (urlRes.statusCode === 404) {
            return {Type: entryTypes.note, Contents: urlRes.body, ContentsFormat: formats.json,
                HumanReadable: 'XFE does not have details about ' + url};
        }
        var malwareRes = doReq('GET', 'url/malware/' + url);
        res.resolution = resolutionRes.obj;
        res.url = urlRes.obj;
        res.malware = malwareRes.obj;
        if (res.resolution && res.resolution.A) {
            var countryRes = doReq('GET', 'ipr/' + res.resolution.A[0]);
            if (countryRes.obj.geo) {
                res.country = countryRes.obj.geo.country;
            }
        }
        var o = res.url;
        var ec = {};
        var dbotScore = 0;
        if (o.result && o.result.score && o.result.score >= threshold) {
            addMalicious(ec, outputPaths.url, {Data: url, Malicious: {Vendor: 'XFE', Description: 'Score above ' + threshold, Score: o.result.score}});
            dbotScore = 3;
        } else if (o.result && o.result.score && o.result.score >= threshold / 2) {
            dbotScore = 2;
        } else if (o.result && o.result.score) {
            dbotScore = 1;
        }
        ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'XFE', Score: dbotScore};
        var md = '## X-Force URL Reputation for: ' + url + '\n';
        if (o.result) {
            md += 'Score: **' + o.result.score + '**\n';
            md += 'Categories: **' + Object.keys(o.result.cats).join(', ') + '**\n';
            md += 'XFE Link: [' + url + '](https://exchange.xforce.ibmcloud.com/url/' + encodeURIComponent(url) + ')\n';
        } else {
            md += 'No result found';
        }
        if (res.resolution) {
            md += '### Resolution\n';
            if (res.country) {
                md += 'Country: **' + res.country + '**\n';
            }
            md += objToMd(res.resolution) + '\n';
        }
        if (longFormat === 'true') {
            if (o.result && o.result.associated) {
                md += '### Associated\n';
                md += arrToMd(o.result.associated.map(function(curr) {
                    return {URL: curr.url, Score: curr.score, Categories: Object.keys(curr.result.cats).join(', ')};
                })) + '\n';
            }
            // Retrieve malware on the URL
            if (res.malware.malware) {
                md += '### Malware\n';
                md += 'Count: **' + res.malware.count + '**\n';
                md += arrToMd(res.malware.malware);
            }
        }
        return {Type: entryTypes.note, Contents: JSON.stringify(res), ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};
    };

    function cveToMd(o) {
        var cve = 'Unknown';
        if (o.stdcode) {
            for (var i=0; i<o.stdcode.length; i++) {
                if (o.stdcode[i].toUpperCase().indexOf('CVE') >= 0) {
                    cve = o.stdcode[i].toUpperCase();
                    break;
                }
            }
        }
        var md = '### Standard code: ' + cve + '\n';
        md += 'Title: **' + nvl(o.title) + '**\n';
        md += 'Description: **' + nvl(o.description) + '**\n';
        md += 'Risk: **' + nvl(o.risk_level) + '**\n';
        md += 'Type: **' + nvl(o.type) + '**\n';
        md += 'Variant: **' + nvl(o.variant) + '**\n';
        md += 'Temporal score: **' + nvl(o.temporal_score) + '**\n';
        md += 'Remedy: **' + nvl(o.remedy) + '**\n';
        md += 'Reported: **' + nvl(o.reported) + '**\n';
        md += 'Standard codes: **' + (o.stdcode ? o.stdcode.join(', ') : 'N/A') + '**\n';
        md += 'Platforms: **' + (o.platforms_affected ? o.platforms_affected.join(', ') : 'N/A') + '**\n';
        md += 'Exploitability: **' + nvl(o.exploitability) + '**\n';
        md += 'Consequences: **' + nvl(o.consequences) + '**\n';
        md += 'Confidence: **' + nvl(o.report_confidence) + '**\n';
        md += objToList(o.cvss, 'CVSS');
        if (o.references) {
            md += '### References' + '\n';
            md += arrToMd(o.references) + '\n';
        }
        return md;
    }


    function cveToContext(o) {
        var cve = 'Unknown';
        if (o.stdcode) {
            for (var i=0; i<o.stdcode.length; i++) {
                if (o.stdcode[i].toUpperCase().indexOf('CVE') >= 0) {
                    cve = o.stdcode[i].toUpperCase();
                    break;
                }
            }
        }
        return {ID: cve, CVSS: o.risk_level, Published: o.reported, Modified: o.reported};
    }


    function doCVE(cve) {
        var res = doReq('GET', 'vulnerabilities/search/' + cve);
        if (res.statusCode === 404) {
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json,
                HumanReadable: 'XFE does not have details about ' + cve};
        }
        var o = res.obj;
        var md = '## X-Force CVE Search for: ' + cve + '\n';
        var context = {};
        var ec = [];
        if (o && Array.isArray(o)) {
            for (var i=0; i<o.length; i++) {
                md += cveToMd(o[i]) + '\n';
                ec.push(cveToContext(o[i]));
            }
            if (ec.length > 0) {
                context[outputPaths.cve] = ec;
            }
        } else {
            md += 'No result found.';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: context};
    }


    function doCVELatest(limit) {
        if (!limit) {
            limit = '30';
        }
        var res = doReq('GET', 'vulnerabilities', {limit: limit});
        // This should never happen
        if (res.statusCode === 404) {
            return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json,
                HumanReadable: 'XFE does not have a list of latest vulnerabilities'};
        }
        var o = res.obj;
        var md = '## X-Force Latest CVEs\n';
        var context = {};
        var ec = [];
        if (o && Array.isArray(o)) {
            for (var i=0; i<o.length; i++) {
                md += cveToMd(o[i]) + '\n';
                ec.push(cveToContext(o[i]));
            }
            if (ec.length > 0) {
                context[outputPaths.cve] = ec;
            }
        } else {
            md += 'No result found.';
        }
        return {Type: entryTypes.note, Contents: res.body, ContentsFormat: formats.json, HumanReadable: md, EntryContext: context};
    }


    switch (command) {
        case 'test-module':
            doReq('GET', 'user/profile'); // Get user will validate keys
            return true;
        case 'file':
            return doFile(args.file, args.long);
        case 'ip':
            return doIP(args.ip, args.long, args.threshold);
        case 'url':
            return doURL(args.url, args.long, args.threshold);
        case 'domain':
            return doURL(args.domain, args.long, args.threshold);
        case 'cve-search':
            return doCVE(args.cveId);
        case 'cve-latest':
            return doCVELatest(args.limit);
        default:
            throw 'Unknown command - ' + command;
    }
  type: javascript
  commands:
  - name: url
    arguments:
    - name: url
      required: true
      default: true
      description: URL to be checked
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response with detected malware on the URLs
      defaultValue: "false"
    - name: threshold
      description: If the score is above the given threshold, will be considered malicious.
        If threshold is not specified, the default URL threshold, as configured in
        the instance settings, will be used.
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
    - contextPath: URL.Malicious.Score
      description: For malicious URLs, the score from the vendor
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check the given URL reputation
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: The file hash md5/sha1/sha256 to check
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response
      defaultValue: "false"
    outputs:
    - contextPath: File.MD5
      description: Bad hash MD5
    - contextPath: File.SHA1
      description: Bad hash SHA1
    - contextPath: File.SHA256
      description: Bad hash SHA256
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
    - contextPath: File.Malicious.Score
      description: For malicious files, the score from the vendor
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check file reputation
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: IP to check
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response
      defaultValue: "false"
    - name: threshold
      description: If the score is above the given threshold, will be considered malicious.
        If threshold is not specified, the default IP threshold, as configured in
        the instance settings, will be used.
    outputs:
    - contextPath: IP.Address
      description: Bad IP found
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
    - contextPath: IP.Malicious.Score
      description: For malicious IPs, the score from the vendor
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check IP reputation
  - name: domain
    arguments:
    - name: domain
      required: true
      default: true
      description: The domain to check
    - name: long
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Should we return full response
      defaultValue: "false"
    - name: threshold
      description: If the score is above the given threshold, will be considered malicious.
        If threshold is not specified, the default URL threshold, as configured in
        the instance settings, will be used.
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
    - contextPath: URL.Malicious.Score
      description: For malicious URLs, the score from the vendor
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check domain reputation
  - name: cve-search
    arguments:
    - name: cveId
      required: true
      default: true
      description: The cve to search for
    outputs:
    - contextPath: CVE.ID
      description: The ID of the CVE
    - contextPath: CVE.CVSS
      description: The CVSS score of the CVE
    - contextPath: CVE.Published
      description: The date this was published
    - contextPath: CVE.Modified
      description: When CVE was last modified
    - contextPath: CVE.Description
      description: The CVE description
    description: Search for details about the given CVE
  - name: cve-latest
    arguments:
    - name: limit
      default: true
      description: The number of results to return
    outputs:
    - contextPath: CVE.ID
      description: The ID of the CVE
    - contextPath: CVE.CVSS
      description: The CVSS score of the CVE
    - contextPath: CVE.Published
      description: The date this was published
    - contextPath: CVE.Modified
      description: When CVE was last modified
    - contextPath: CVE.Description
      description: The CVE description
    description: Return the latest vulnerabilities found
  runonce: false
fromversion: 2.5.0
releaseNotes: 401 error handling
tests:
  - XFE Test