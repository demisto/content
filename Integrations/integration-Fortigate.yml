commonfields:
  id: FortiGate
  version: -1
name: FortiGate
display: FortiGate
category: Network Security
image: data:image/png;base64,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
description: Manage FortiGate Firewall
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Account username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    ''' IMPORTS '''

    import json
    import requests

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USER_NAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    SERVER = demisto.params()['server'][:-1] if (demisto.params()['server'] and demisto.params()['server'].endswith('/')) else demisto.params()['server']
    USE_SSL = not demisto.params().get('unsecure', False)
    BASE_URL = SERVER + '/api/v2/'


    # remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' HELPER FUNCTIONS '''


    def login():
        """
        Due to token not providing the right level of access, we are going to create a session and inject into its headers the csrf token provided with the service.
        This won't work with usual requests as the session must be kept alive during this time.
        """
        # create session.
        session = requests.session()
        url_suffix = '/logincheck'
        params = {
            'username': USER_NAME,
            'secretkey': PASSWORD,
            'ajax': 1
        }
        session.post(SERVER+url_suffix, data=params, verify=USE_SSL)
        # check for the csrf token in cookies we got, add it to headers of session or else we can't perform HTTP request that is not get.
        for cookie in session.cookies:
            if cookie.name == 'ccsrftoken':
                csrftoken = cookie.value[1:-1] # strip quotes
                session.headers.update({'X-CSRFTOKEN': csrftoken})
        return session


    SESSION = login()

    def http_request(method, url_suffix, params={}, data=None):

        res = SESSION.request(
            method,
            BASE_URL + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data
        )
        if res.status_code not in {200}:
            return_error('Error in API call to FortiGate [%d] - %s' % (res.status_code, res.reason))
        if method.upper() != 'GET':
            return res.status_code
        return res.json()


    def does_path_exist(target_url):
        """
        Check if the path itself already exists in the instance, if it does we will not want to resume with certain requests.
        """
        res = SESSION.get(BASE_URL+target_url, verify=USE_SSL)
        if res.status_code == 200:
            return True
        return False


    def logout(session):
        """
        Due to limited amount of simultaneous connections we log out after each API request. Simple post request to /logout endpoint without params.
        """
        url_suffix = '/logout'
        params = {}
        session.post(SERVER+url_suffix, data=params, verify=USE_SSL)


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Perform basic login and logout operation, validate connection.
        """
        login_check = http_request('GET', 'cmdb/system/vdom')
        return True

    def get_addresses_command():
        contents = []
        context = {}
        addresses_context = []
        address =  demisto.args().get('address')
        name =  demisto.args().get('name', '')

        addresses = get_addresses_request(address, name)
        for address in addresses:
            subnet = address.get('subnet')
            if subnet:
                subnet = subnet.replace(" ", "-")
            contents.append({
                'Name': address.get('name'),
                'Subnet': subnet,
                'StartIP': address.get('start-ip'),
                'EndIP': address.get('end-ip')
            })
            addresses_context.append({
                'Name': address.get('name'),
                'Subnet': subnet,
                'StartIP': address.get('start-ip'),
                'EndIP': address.get('end-ip')
            })

        context['Fortigate.Address(val.Name && val.Name === obj.Name)'] = addresses_context
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate addresses', contents),
            'EntryContext': context
        })



    def get_addresses_request(address, name):
        uri_suffix = 'cmdb/firewall/address/' + name
        params = {
            'vdom': address
        }
        response = http_request('GET', uri_suffix, params)
        # Different structure if we choose all domains
        if address == '*':
            return response[0].get('results')
        return response.get('results')


    def get_service_groups_command():
        contents = []
        context = {}
        service_groups_context = []
        name =  demisto.args().get('name', '')

        service_groups = get_service_groups_request(name)
        for service_group in service_groups:
            service_group_members = []
            members = service_group.get('member')
            for member in members:
                service_group_members.append(member.get('name'))
            contents.append({
                'Name': service_group.get('name'),
                'Members': service_group_members
            })
            service_groups_context.append({
                'Name': service_group.get('name'),
                'Member': { 'Name': service_group_members }
            })

        context['Fortigate.ServiceGroup(val.Name && val.Name === obj.Name)'] = service_groups_context
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate service groups', contents),
            'EntryContext': context
        })


    def get_service_groups_request(name):
        uri_suffix = 'cmdb/firewall.service/group/' + name
        response = http_request('GET', uri_suffix)
        return response.get('results')


    def update_service_group_command():
        contents = {}
        context = {}
        service_group_context = {}

        group_name =  demisto.args().get('groupName')
        service_name =  demisto.args().get('serviceName')
        action = demisto.args().get('action')
        if action not in ['add','remove']:
            return_error('Action must be add or remove')

        old_service_groups = get_service_groups_request(group_name)
        service_group_members = []
        new_service_group_members = []

        if isinstance(old_service_groups, list):
            old_service_group = old_service_groups[0]
            service_group_members = old_service_group.get('member')
        if action == 'add':
            service_group_members.append({'name': service_name})
            new_service_group_members = service_group_members
        if action == 'remove':
            for service_group_member in service_group_members:
                if service_group_member.get('name') != service_name:
                    new_service_group_members.append(service_group_member)

        response = update_service_group_request(group_name, new_service_group_members)
        service_group = get_service_groups_request(group_name)[0]

        service_group_members = []
        members = service_group.get('member')
        for member in members:
            service_group_members.append(member.get('name'))

        contents = {
            'Name': service_group.get('name'),
            'Services': service_group_members
        }

        service_group_context = {
            'Name': service_group.get('name'),
            'Service': {
                'Name': service_group_members
            }
        }

        context['Fortigate.ServiceGroup(val.Name && val.Name === obj.Name)'] = service_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate service group: ' + group_name + ' was successfully updated' , contents),
            'EntryContext': context
        })

    def update_service_group_request(group_name, members_list):
        uri_suffix = 'cmdb/firewall.service/group/' + group_name
        if not does_path_exist(uri_suffix):
            return_error('Requested service group ' + group_name + ' does not exist in Firewall config.')

        payload = {
            'member': members_list
        }

        response = http_request('PUT', uri_suffix, {}, json.dumps(payload))
        return response


    def delete_service_group_command():
        contents = {}
        context = {}
        service_group_context = {}
        group_name =  demisto.args().get('groupName').encode('utf-8')

        response = delete_service_group_request(group_name)

        service_group_context = {
            'Name': group_name,
            'Deleted': True
        }

        contents = service_group_context
        context['Fortigate.ServiceGroup(val.Name && val.Name === obj.Name)'] = service_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate service group: ' + group_name + ' was deleted successfully', contents),
            'EntryContext': context
        })


    def delete_service_group_request(group_name):
        uri_suffix = 'cmdb/firewall.service/group/' + group_name
        response = http_request('DELETE', uri_suffix)
        return response


    def get_firewall_service_command():
        contents = []
        context = {}
        service_context = []
        service_name =  demisto.args().get('serviceName', '')
        service_title = service_name
        if not service_name:
            service_title = 'all services'

        services = get_firewall_service_request(service_name)
        for service in services:
            contents.append({
                'Name': service.get('name'),
                'Ports': {
                    'TCP': service.get('tcp-portrange'),
                    'UDP': service.get('udp-portrange')
                }
            })
            service_context.append({
                'Name': service.get('name'),
                'Ports': {
                    'TCP': service.get('tcp-portrange'),
                    'UDP': service.get('udp-portrange')
                }
            })

        context['Fortigate.Service(val.Name && val.Name === obj.Name)'] = service_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate firewall services ' + service_title, contents),
            'EntryContext': context
        })


    def get_firewall_service_request(service_name):
        uri_suffix = 'cmdb/firewall.service/custom/' + service_name
        response = http_request('GET', uri_suffix)
        return response.get('results')


    def create_firewall_service_command():
        contents = []
        context = {}
        service_context = []
        service_name =  demisto.args().get('serviceName')
        tcp_range =  demisto.args().get('tcpRange', '')
        udp_range =  demisto.args().get('udpRange', '')

        response = create_firewall_service_request(service_name, tcp_range, udp_range)

        contents.append({
            'Name': service_name,
            'Ports': {
                'TCP': tcp_range,
                'UDP': udp_range
            }
        })
        service_context.append({
            'Name': service_name,
            'Ports': {
                'TCP': tcp_range,
                'UDP': udp_range
            }
        })

        context['Fortigate.Service(val.Name && val.Name === obj.Name)'] = service_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate firewall service ' + service_name + ' created successfully', contents),
            'EntryContext': context
        })


    def create_firewall_service_request(service_name, tcp_range, udp_range):
        uri_suffix = 'cmdb/firewall.service/custom/'
        if does_path_exist(uri_suffix + service_name):
            return_error('Firewall service already exists.')

        payload = {
            'name': service_name,
            'tcp-portrange': tcp_range,
            'udp-portrange': udp_range
        }

        response = http_request('POST', uri_suffix, {}, json.dumps(payload))
        return response


    def get_policy_command():
        contents = []
        context = {}
        policy_context = []
        policy_name = demisto.args().get('policyName')
        policy_id = demisto.args().get('policyID')
        policy_title = 'all policies'

        policies = get_policy_request(policy_id)

        for policy in policies:
            if policy_name == policy.get('name') or not policy_name:
                if policy_name or policy_id:
                    policy_title = policy.get('name')
                security_profiles = []
                all_security_profiles = [ policy.get('webfilter-profile'), policy.get('ssl-ssh-profile'), policy.get('dnsfilter-profile'),                                                                                                     policy.get('profile-protocol-options'), policy.get('profile-type'), policy.get('av-profile') ]
                for security_profile in all_security_profiles:
                    if security_profile:
                        security_profiles.append(security_profile)

                src_address = policy.get('srcaddr')
                if src_address and isinstance(src_address, list) and isinstance(src_address[0], dict):
                    src_address = src_address[0].get('name')
                dest_address = policy.get('dstaddr')
                if dest_address and isinstance(dest_address, list) and isinstance(dest_address[0], dict):
                    dest_address = dest_address[0].get('name')
                service = policy.get('service')
                if service and isinstance(service, list) and isinstance(service[0], dict):
                    service = service[0].get('name')

                contents.append({
                    'Name': policy.get('name'),
                    'ID': policy.get('policyid'),
                    'Description': policy.get('comments'),
                    'Status': policy.get('status'),
                    'Source': src_address,
                    'Destination': dest_address,
                    'Service': service,
                    'Action': policy.get('action'),
                    'Log': policy.get('logtraffic'),
                    'Security': security_profiles,
                    'NAT': policy.get('nat')
                })
                policy_context.append({
                    'Name': policy.get('name'),
                    'ID': policy.get('policyid'),
                    'Description': policy.get('comments'),
                    'Status': policy.get('status'),
                    'Source': src_address,
                    'Destination': dest_address,
                    'Service': service,
                    'Action': policy.get('action'),
                    'Log': policy.get('logtraffic'),
                    'Security': security_profiles,
                    'NAT': policy.get('nat')
                })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy details for ' + policy_title , contents),
            'EntryContext': context
        })


    def get_policy_request(policy_id):
        uri_suffix = 'cmdb/firewall/policy/'
        if policy_id:
            uri_suffix = uri_suffix + policy_id + '/'
        # We have the option to filter only the data we need from each policy, reducing by over 80% the amount of data we need to read.
        params = {
            'format': 'policyid|action|name|comments|status|service|logtraffic|srcaddr|dstaddr|webfilter-profile|ssl-ssh-profile|dnsfilter-profile|profile-protocol-options|profile-type|av-profile|nat'
        }
        response = http_request('GET', uri_suffix, params)
        return response.get('results')


    def update_policy_command():
        contents = []
        context = {}
        policy_context = []
        security_profiles = []

        policy_id = demisto.args().get('policyID')
        policy_field = demisto.args().get('field')
        policy_field_value = demisto.args().get('value')

        update_policy = update_policy_request(policy_id, policy_field, policy_field_value)
        policy = get_policy_request(policy_id)[0]
        all_security_profiles = [ policy.get('webfilter-profile'), policy.get('ssl-ssh-profile'), policy.get('dnsfilter-profile'),                                                                                                     policy.get('profile-protocol-options'), policy.get('profile-type'), policy.get('av-profile') ]

        for security_profile in all_security_profiles:
            if security_profile:
                security_profiles.append(security_profile)

        src_address = policy.get('srcaddr')
        if src_address and isinstance(src_address, list) and isinstance(src_address[0], dict):
            src_address = src_address[0].get('name')
        dest_address = policy.get('dstaddr')
        if dest_address and isinstance(dest_address, list) and isinstance(dest_address[0], dict):
            dest_address = dest_address[0].get('name')
        service = policy.get('service')
        if service and isinstance(service, list) and isinstance(service[0], dict):
            service = service[0].get('name')

        contents.append({
            'Name': policy.get('name'),
            'ID': policy.get('policyid'),
            'Description': policy.get('comments'),
            'Status': policy.get('status'),
            'Source': src_address,
            'Destination': dest_address,
            'Service': service,
            'Action': policy.get('action'),
            'Log': policy.get('logtraffic'),
            'Security': security_profiles,
            'NAT': policy.get('nat')
        })
        policy_context.append({
            'Name': policy.get('name'),
            'ID': policy.get('policyid'),
            'Description': policy.get('comments'),
            'Status': policy.get('status'),
            'Source': src_address,
            'Destination': dest_address,
            'Service': service,
            'Action': policy.get('action'),
            'Log': policy.get('logtraffic'),
            'Security': security_profiles,
            'NAT': policy.get('nat')
        })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy ID ' + policy_id + ' has been updated successfully.' , contents),
            'EntryContext': context
        })


    def update_policy_request(policy_id, policy_field, policy_field_value):
        uri_suffix = 'cmdb/firewall/policy/' + policy_id
        if not does_path_exist(uri_suffix):
            return_error('Requested policy ID ' + policy_id + ' does not exist in Firewall config.')

        field_to_api_key = {
            'description': 'comments',
            'source': 'srcaddr',
            'destination': 'dstaddr',
            'log': 'logtraffic'
        }

        if policy_field in field_to_api_key:
            policy_field = field_to_api_key[policy_field]

        payload = {
            policy_field: policy_field_value
        }

        response = http_request('PUT', uri_suffix, {}, json.dumps(payload))
        return response


    def create_policy_command():
        contents = []
        context = {}
        policy_context = []

        policy_name = demisto.args().get('policyName')
        policy_description = demisto.args().get('description', '')
        policy_srcintf = demisto.args().get('sourceIntf')
        policy_dstintf = demisto.args().get('dstIntf')
        policy_source_address = demisto.args().get('source')
        policy_destination_address = demisto.args().get('destination')
        policy_service = demisto.args().get('service')
        policy_action = demisto.args().get('action')
        policy_status = demisto.args().get('status')
        policy_log = demisto.args().get('log')
        policy_nat = demisto.args().get('nat')

        create_policy = create_policy_request(policy_name, policy_description, policy_srcintf, policy_dstintf, policy_source_address,                                                                          policy_destination_address, policy_service, policy_action, policy_status, policy_log, policy_nat)

        contents.append({
            'Name': policy_name,
            'Description': policy_description,
            'Status': policy_status,
            'Service': policy_service,
            'Action': policy_action,
            'Log': policy_log,
            'Source': {
                'Interface': policy_srcintf,
                'Address': policy_source_address
            },
            'Destination': {
                'Interface': policy_dstintf,
                'Address': policy_destination_address
            },
            'NAT': policy_nat
        })

        policy_context.append({
            'Name': policy_name,
            'Description': policy_description,
            'Status': policy_status,
            'Service': policy_service,
            'Action': policy_action,
            'Log': policy_log,
            'Source': {
                'Interface': policy_srcintf,
                'Address': policy_source_address
            },
            'Destination': {
                'Interface': policy_dstintf,
                'Address': policy_destination_address
            },
            'NAT': policy_nat
        })

        context['Fortigate.Policy(val.Name && val.Name === obj.Name)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy ' + policy_name + ' created successfully', contents),
            'EntryContext': context
        })


    def create_policy_request(policy_name, policy_description, policy_srcintf, policy_dstintf, policy_source_address,                                                                                            policy_destination_address, policy_service, policy_action, policy_status, policy_log, policy_nat):

        uri_suffix = 'cmdb/firewall/policy/'

        payload = {
            'json': {
                'name': policy_name,
                'srcintf': [{'name': policy_srcintf }],
                'dstintf': [{'name': policy_dstintf }],
                'srcaddr': [{'name': policy_source_address }],
                'dstaddr': [{'name': policy_destination_address }],
                'action': policy_action,
                'status': policy_status,
                'schedule': 'always',
                'service':[{'name': policy_service }],
                'comments': policy_description,
                'logtraffic': policy_log,
                'nat': policy_nat
            }
        }

        response = http_request('POST', uri_suffix, {}, json.dumps(payload))
        return response


    def move_policy_command():
        contents = []
        context = {}
        policy_id = demisto.args().get('policyID')
        position = demisto.args().get('position')
        neighbour = demisto.args().get('neighbor')

        response = move_policy_request(policy_id, position, neighbour)

        policy_context = {
            'ID': policy_id,
            'Moved': True
        }
        contents.append({
            'ID': policy_id,
            'Moved': True
        })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy with ID ' + policy_id + ' moved successfully', contents),
            'EntryContext': context
        })

    def move_policy_request(policy_id, position, neighbour):
        uri_suffix = 'cmdb/firewall/policy/' + policy_id
        params = {
            'action': 'move',
            position: neighbour
        }

        response = http_request('PUT', uri_suffix, params)
        return response


    def delete_policy_command():
        contents = []
        context = {}
        policy_id = demisto.args().get('policyID')

        response = delete_policy_request(policy_id)

        policy_context = {
            'ID': policy_id,
            'Deleted': True
        }
        contents.append({
            'ID': policy_id,
            'Deleted': True
        })

        context['Fortigate.Policy(val.ID && val.ID === obj.ID)'] = policy_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate policy with ID ' + policy_id + ' deleted successfully', contents),
            'EntryContext': context
        })


    def delete_policy_request(policy_id):
        uri_suffix = 'cmdb/firewall/policy/' + policy_id
        response = http_request('DELETE', uri_suffix)
        return response


    def get_address_groups_command():
        contents = []
        context = {}
        address_groups_context = []
        address_group_name = demisto.args().get('groupName', '')
        title = address_group_name if address_group_name else 'all'

        address_groups = get_address_groups_request(address_group_name)
        for address_group in address_groups:
            members = address_group.get('member')
            members_list = []
            for member in members:
                members_list.append(member.get('name'))
            contents.append({
                'Name': address_group.get('name'),
                'Members': members_list,
                'UUID': address_group.get('uuid')
            })
            address_groups_context.append({
                'Name': address_group.get('name'),
                'Member': {
                    'Name': members_list
                },
                'UUID': address_group.get('uuid')
            })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_groups_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address groups ' + title, contents),
            'EntryContext': context
        })


    def get_address_groups_request(address_group_name):
        uri_suffix = 'cmdb/firewall/addrgrp/' + address_group_name
        response = http_request('GET', uri_suffix)
        return response.get('results')


    def update_address_group_command():
        contents = []
        context = {}
        address_group_context = []
        group_name = demisto.args().get('groupName', '')
        address = demisto.args().get('address', '')
        action = demisto.args().get('action')
        if action not in ['add','remove']:
            return_error('Action must be add or remove')

        old_address_groups = get_address_groups_request(group_name)
        address_group_members = []
        new_address_group_members = []

        if isinstance(old_address_groups, list):
            old_address_group = old_address_groups[0]
            address_group_members = old_address_group.get('member')
        if action == 'add':
            address_group_members.append({'name': address})
            new_address_group_members = address_group_members
        if action == 'remove':
            for address_group_member in address_group_members:
                if address_group_member.get('name') != address:
                    new_address_group_members.append(address_group_member)

        response = update_address_group_request(group_name, new_address_group_members)
        address_group = get_address_groups_request(group_name)[0]
        members = address_group.get('member')
        members_list = []
        for member in members:
            members_list.append(member.get('name'))
        contents.append({
            'Name': address_group.get('name'),
            'Members': members_list,
            'UUID': address_group.get('uuid')
        })
        address_group_context.append({
            'Name': address_group.get('name'),
            'Address': {
                'Name': members_list
            },
            'UUID': address_group.get('uuid')
        })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address group ' + group_name + ' updated successfully', contents),
            'EntryContext': context
        })


    def update_address_group_request(group_name, new_address_group_members):
        uri_suffix = 'cmdb/firewall/addrgrp/' + group_name
        # Check whether target object already exists
        if not does_path_exist(uri_suffix):
            return_error('Requested address group' + group_name + 'does not exist in Firewall config.')
        payload = {
            'member': new_address_group_members
        }
        result = http_request('PUT', uri_suffix, {}, json.dumps(payload))
        return result


    def create_address_group_command():
        contents = []
        context = {}
        address_group_context = []
        group_name = demisto.args().get('groupName', '')
        address = demisto.args().get('address', '')

        response = create_address_group_request(group_name, address)

        contents.append({
            'Name': group_name,
            'Address': address,
        })
        address_group_context.append({
            'Name': group_name,
            'Address': address
        })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address group ' + group_name + ' created successfully', contents),
            'EntryContext': context
        })


    def create_address_group_request(group_name, address):
        uri_suffix = 'cmdb/firewall/addrgrp/'
        if does_path_exist(uri_suffix + group_name):
            return_error('Address group already exists.')
        payload = {
            'name': group_name, 'member': [{'name': address}]
        }
        result = http_request('POST', uri_suffix, {} ,json.dumps(payload))
        return result


    def delete_address_group_command():
        contents = []
        context = {}
        address_group_context = []
        name = demisto.args().get('name', '')

        response = delete_address_group_request(name)

        contents.append({
            'Name': name,
            'Deleted': True
        })
        address_group_context.append({
            'Name': name,
            'Deleted': True
        })

        context['Fortigate.AddressGroup(val.Name && val.Name === obj.Name)'] = address_group_context

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FortiGate address group ' + name + ' deleted successfully', contents),
            'EntryContext': context
        })

    def delete_address_group_request(name):
        uri_suffix = 'cmdb/firewall/addrgrp/' + name
        response = http_request('DELETE', uri_suffix)
        return response



    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
        elif demisto.command() == 'fortigate-get-addresses':
            get_addresses_command()
        elif demisto.command() == 'fortigate-get-service-groups':
            get_service_groups_command()
        elif demisto.command() == 'fortigate-update-service-group':
            update_service_group_command()
        elif demisto.command() == 'fortigate-delete-service-group':
            delete_service_group_command()
        elif demisto.command() == 'fortigate-get-firewall-service':
            get_firewall_service_command()
        elif demisto.command() == 'fortigate-create-firewall-service':
            create_firewall_service_command()
        elif demisto.command() == 'fortigate-get-policy':
            get_policy_command()
        elif demisto.command() == 'fortigate-update-policy':
            update_policy_command()
        elif demisto.command() == 'fortigate-create-policy':
            create_policy_command()
        elif demisto.command() == 'fortigate-move-policy':
            move_policy_command()
        elif demisto.command() == 'fortigate-delete-policy':
            delete_policy_command()
        elif demisto.command() == 'fortigate-get-address-groups':
            get_address_groups_command()
        elif demisto.command() == 'fortigate-update-address-group':
            update_address_group_command()
        elif demisto.command() == 'fortigate-create-address-group':
            create_address_group_command()
        elif demisto.command() == 'fortigate-delete-address-group':
            delete_address_group_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise

    finally:
        logout(SESSION)
  type: python
  commands:
  - name: fortigate-get-addresses
    arguments:
    - name: address
      description: Filter by address (ip or domain)
      defaultValue: root
    - name: name
      description: Filter by address name
    outputs:
    - contextPath: Fortigate.Address.Name
      description: Address name
      type: string
    - contextPath: Fortigate.Address.Subnet
      description: Address subnet
      type: string
    - contextPath: Fortigate.Address.StartIP
      description: Address object start IP address
      type: string
    - contextPath: Fortigate.Address.EndIP
      description: Address object end IP address
      type: string
    description: Get all address objects from your firewall
  - name: fortigate-get-service-groups
    arguments:
    - name: name
      description: Filter by group name
    outputs:
    - contextPath: Fortigate.ServiceGroup.Name
      description: Service Group name
      type: string
    - contextPath: Fortigate.ServiceGroup.Member.Name
      description: Service Group member name
      type: string
    description: Get information about FortiGate service groups
  - name: fortigate-update-service-group
    arguments:
    - name: groupName
      required: true
      description: Group name to update
    - name: serviceName
      required: true
      description: Service name to update from the group (If providing data argument
        value does not matter)
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - add
      - remove
      description: Action to take on the service
    outputs:
    - contextPath: Fortigate.ServiceGroup.Name
      description: Service group name
      type: string
    - contextPath: Fortigate.ServiceGroup.Service.Name
      description: Service name
      type: string
    description: Update a FortiGate service group
  - name: fortigate-delete-service-group
    arguments:
    - name: groupName
      required: true
      description: Group name of the group you would like to delete
    outputs:
    - contextPath: Fortigate.ServiceGroup.Name
      description: Service group name
      type: string
    - contextPath: Fortigate.ServiceGroup.Deleted
      description: Was service group deleted
      type: boolean
    description: Delete a service group from FortiGate
  - name: fortigate-get-firewall-service
    arguments:
    - name: serviceName
      description: Service name
    outputs:
    - contextPath: Fortigate.Service.Name
      description: Service name
      type: string
    - contextPath: Fortigate.Service.Ports.TCP
      description: TCP Port range included for the service
      type: string
    - contextPath: Fortigate.Service.Ports.UDP
      description: UDP Port range included for the service
      type: string
    description: Get information about a service from FortiGate Firewall
  - name: fortigate-create-firewall-service
    arguments:
    - name: serviceName
      required: true
      description: Service name
    - name: tcpRange
      description: 'TCP Port range for the service. Example: 100-120 or simply a single
        port.'
    - name: udpRange
      description: 'UDP Port range for the service. Example: 100-120, or simply a
        single port.'
    outputs:
    - contextPath: Fortigate.Service.Name
      description: Service name
      type: string
    - contextPath: Fortigate.Service.Ports.TCP
      description: TCP Port range included for the service
      type: string
    - contextPath: Fortigate.Service.Ports.UDP
      description: UDP Port range included for the service
      type: string
    description: Create a service in FortiGate firewall
  - name: fortigate-get-policy
    arguments:
    - name: policyName
      description: Policy name
    - name: policyID
      description: Policy ID
    outputs:
    - contextPath: Fortigate.Policy.Name
      description: Policy name
      type: string
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Fortigate.Policy.Description
      description: Policy description
      type: string
    - contextPath: Fortigate.Policy.Status
      description: The status of the poilcy (Enabled or Disabled)
      type: string
    - contextPath: Fortigate.Policy.Source
      description: Source address
      type: string
    - contextPath: Fortigate.Policy.Destination
      description: Destination address
      type: string
    - contextPath: Fortigate.Policy.Service
      description: Service for the policy (for example HTTP)
      type: string
    - contextPath: Fortigate.Policy.Action
      description: Policy action (Allow, Block)
      type: string
    - contextPath: Fortigate.Policy.Log
      description: Does the policy log the traffic or not
      type: string
    - contextPath: Fortigate.Policy.Security
      description: Policy attached security profile
      type: string
    description: Get information about a firewall policy on FortiGate
  - name: fortigate-update-policy
    arguments:
    - name: policyID
      required: true
      description: Policy ID
    - name: field
      required: true
      auto: PREDEFINED
      predefined:
      - description
      - status
      - source
      - destination
      - service
      - action
      - log
      - nat
      description: Field parameter to update
    - name: value
      required: true
      description: Value of field parameter to update
    outputs:
    - contextPath: Fortigate.Policy.Name
      description: Policy name
      type: string
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: string
    - contextPath: Fortigate.Policy.Description
      description: Policy description
      type: string
    - contextPath: Fortigate.Policy.Status
      description: The status of the poilcy (Enabled or Disabled)
      type: string
    - contextPath: Fortigate.Policy.Source
      description: Source address
      type: string
    - contextPath: Fortigate.Policy.Destination
      description: Destination address
      type: string
    - contextPath: Fortigate.Policy.Service
      description: Service for the policy (for example HTTP)
      type: string
    - contextPath: Fortigate.Policy.Action
      description: Policy action (Allow, Block)
      type: string
    - contextPath: Fortigate.Policy.Log
      description: Does the policy log the traffic or not
      type: boolean
    description: Update a firewall policy on FortiGate
    execution: true
  - name: fortigate-create-policy
    arguments:
    - name: policyName
      required: true
      description: Policy name
    - name: description
      description: Description for the policy
    - name: sourceIntf
      required: true
      description: 'Source interface  (examples : port1, port2 or port3)'
    - name: dstIntf
      required: true
      description: 'Destination interface (examples : port1, port2 or port3)'
    - name: source
      required: true
      description: 'Source IP address, range or domain (examples : all, update.microsoft.com)'
    - name: destination
      required: true
      description: 'Destination IP address, range or domain (examples : all, update.microsoft.com)'
    - name: service
      required: true
      description: Service for the policy (for example HTTP)
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - accept
      - block
      description: Action to take
    - name: status
      auto: PREDEFINED
      predefined:
      - enable
      - disable
      description: policy status
      defaultValue: enable
    - name: log
      auto: PREDEFINED
      predefined:
      - all
      - utm
      - disable
      description: Will the policy log the traffic or not
      defaultValue: enable
    - name: nat
      auto: PREDEFINED
      predefined:
      - enable
      - disable
      description: enable/disable NAT
      defaultValue: enable
    outputs:
    - contextPath: Fortigate.Policy.Name
      description: Policy name
      type: string
    - contextPath: Fortigate.Policy.Description
      description: Policy description
      type: string
    - contextPath: Fortigate.Policy.Status
      description: The status of the poilcy (Enabled or Disabled)
      type: string
    - contextPath: Fortigate.Policy.Source.Address
      description: Source address
      type: string
    - contextPath: Fortigate.Policy.Destination.Address
      description: Destination address
      type: string
    - contextPath: Fortigate.Policy.Service
      description: Service for the policy (for example HTTP)
      type: string
    - contextPath: Fortigate.Policy.Action
      description: Policy action (Allow, Block)
      type: string
    - contextPath: Fortigate.Policy.Log
      description: Does the policy log the traffic or not
      type: boolean
    - contextPath: Fortigate.Policy.Source.Intf
      description: Source interface
      type: string
    - contextPath: Fortigate.Policy.Destination.Intf
      description: Destination interface
      type: string
    - contextPath: Fortigate.Policy.NAT
      description: Policy NAT
      type: string
    description: Create a firewall policy (rule) on FortiGate
    execution: true
  - name: fortigate-move-policy
    arguments:
    - name: policyID
      required: true
      description: Policy ID
    - name: position
      required: true
      auto: PREDEFINED
      predefined:
      - before
      - after
      description: Position for the policy (before or after)
    - name: neighbor
      required: true
      description: The ID of the policy being used as a positional anchor
    outputs:
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: number
    - contextPath: Fortigate.Policy.Moved
      description: Was policy moved successfully
      type: boolean
    description: Move a firewall policy rule to a different position
  - name: fortigate-delete-policy
    arguments:
    - name: policyID
      required: true
      description: Policy ID
    outputs:
    - contextPath: Fortigate.Policy.ID
      description: Policy ID
      type: number
    - contextPath: Fortigate.Policy.Deleted
      description: Was policy deleted successfully
      type: boolean
    description: Delete a policy from FortiGate firewall
    execution: true
  - name: fortigate-get-address-groups
    arguments:
    - name: groupName
      description: Filter by group name
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address Group name
      type: string
    - contextPath: Fortigate.AddressGroup.Member.Name
      description: Address Group member name
      type: string
    - contextPath: Fortigate.AddressGroup.UUID
      description: Address Group UUID
      type: string
    description: Get information about address groups from FortiGate
  - name: fortigate-update-address-group
    arguments:
    - name: groupName
      required: true
      description: Group name
    - name: address
      required: true
      description: An address to add or remove from the group (If providing data argument,
        value does not matter)
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - add
      - remove
      description: Action to take on the service
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address group name
      type: string
    - contextPath: Fortigate.AddressGroup.Address.Name
      description: Address name
      type: string
    - contextPath: Fortigate.AddressGroup.UUID
      description: Address group UUID
    description: Update an address group on FortiGate firewall
  - name: fortigate-create-address-group
    arguments:
    - name: groupName
      required: true
      description: Group name
    - name: address
      required: true
      description: Address member to add to the group
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address group name
      type: string
    - contextPath: Fortigate.AddressGroup.Address
      description: Address group member address
      type: string
    description: Create an address group in FortiGate firewall
  - name: fortigate-delete-address-group
    arguments:
    - name: name
      required: true
      description: Address group name
    outputs:
    - contextPath: Fortigate.AddressGroup.Name
      description: Address group name
      type: string
    - contextPath: Fortigate.AddressGroup.Deleted
      description: Was address group deleted
      type: boolean
    description: Delete an address group from FortiGate firewall
  runonce: false
releaseNotes: "New integration with CRUD options for policy, services groups, services and address groups."
tests:
  - Fortigate Test