commonfields:
  id: SplunkPy
  version: -1
name: SplunkPy
display: SplunkPy
category: Analytics & SIEM
image: data:image/png;base64,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
description: Run queries on Splunk servers
detaileddescription: |
  Support fetching incidents from Splunk ES, and query of results by sid
configuration:
- display: Host - ip (x.x.x.x)
  name: host
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: authentication
  defaultvalue: ""
  type: 9
  required: true
- display: ""
  name: port
  defaultvalue: "8089"
  type: 0
  required: true
- display: Fetch notable events ES query
  name: fetchQuery
  defaultvalue: search index=notable | eval rule_name=if(isnull(rule_name),source,rule_name)
    | eval rule_title=if(isnull(rule_title),rule_name,rule_title) | `get_urgency`
    | `risk_correlation` | eval rule_description=if(isnull(rule_description),source,rule_description)
    | eval security_domain=if(isnull(security_domain),source,security_domain)
  type: 0
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: 'Proxy - in format: 127.0.0.1:8080'
  name: proxy
  defaultvalue: ""
  type: 0
  required: false
- display: Timezone of Splunk server in minutes e.g. for gmt +3 set +180 (set only
    if different than Demisto server), relevent for fetch notable events only
  name: timezone
  defaultvalue: ""
  type: 0
  required: false
- display: Parse Raw of notable events
  name: parseNotableEventsRaw
  defaultvalue: "false"
  type: 8
  required: false
- display: 'Extract Fields - comma separated fields that will be parsed out of _raw
    notable events '
  name: extractFields
  defaultvalue: ""
  type: 12
  required: false
- display: Use Splunk Clock Time For Fetch
  name: useSplunkTime
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |+
    import splunklib.client as client
    import splunklib.results as results
    import json
    from time import gmtime, strftime
    from datetime import timedelta, datetime
    import urllib2
    import ssl
    from StringIO import StringIO
    import requests
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    SPLUNK_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

    def get_current_splunk_time(splunk_service):
        t = datetime.utcnow() - timedelta(days=3)
        time = t.strftime(SPLUNK_TIME_FORMAT)
        kwargs_oneshot = {'count':1,'earliest_time':time}
        searchquery_oneshot = '| gentimes start=-1 | eval clock = strftime(time(), "%Y-%m-%dT%H:%M:%S") | sort 1 -_time | table clock'

        oneshotsearch_results = splunk_service.jobs.oneshot(searchquery_oneshot, **kwargs_oneshot)

        reader = results.ResultsReader(oneshotsearch_results)
        for item in reader:
            if isinstance(item, results.Message):
                return item.message["clock"]
            if isinstance(item, dict):
                return item["clock"]
        raise ValueError('Error: Could not fetch Splunk time')

    def rawToDict(raw):
        result = {}
        raw = raw.strip("}")
        raw = raw.strip("{")
        key_val_arr = raw.split(",")

        for key_val in key_val_arr:
          single_key_val = key_val.split("=")
          if len(single_key_val)>1:
              val = single_key_val[1]
              val = val.strip("\\")
              val = val.strip("\"")
              val = val.strip("\\")
              key = single_key_val[0].strip()

              alreadyThere = False
              for dictkey, dictvalue in result.items():
                if dictkey == key:
                  alreadyThere = True
                  result[dictkey] = dictvalue + "," + val

              if alreadyThere == False:
                result[key] = val

        return result

    def updateNotableEvents(sessionKey, baseurl, comment, status=None, urgency=None, owner=None, eventIDs=None, searchID=None):
        """
        Update some notable events.

        Arguments:
        sessionKey -- The session key to use
        comment -- A description of the change or some information about the notable events
        status -- A status (only required if you are changing the status of the event)
        urgency -- An urgency (only required if you are changing the urgency of the event)
        owner -- A nowner (only required if reassigning the event)
        eventIDs -- A list of notable event IDs (must be provided if a search ID is not provided)
        searchID -- An ID of a search. All of the events associated with this search will be modified unless a list of eventIDs are provided that limit the scope to a sub-set of the results.
        """

        # Make sure that the session ID was provided
        if sessionKey is None:
            raise Exception("A session key was not provided")

        # Make sure that rule IDs and/or a search ID is provided
        if eventIDs is None and searchID is None:
            raise Exception("Either eventIDs of a searchID must be provided (or both)")
            return False

        # These the arguments to the REST handler
        args = {}
        args['comment'] = comment

        if status is not None:
            args['status'] = status

        if urgency is not None:
            args['urgency'] = urgency

        if owner is not None:
            args['newOwner'] = owner

        # Provide the list of event IDs that you want to change:
        if eventIDs is not None:
            args['ruleUIDs'] = eventIDs

        # If you want to manipulate the notable events returned by a search then include the search ID
        if searchID is not None:
            args['searchID'] = searchID

        auth_header = {'Authorization': 'Splunk %s' % sessionKey}

        args['output_mode'] = 'json'
        mod_notables = requests.post(baseurl + 'services/notable_update', data=args, headers=auth_header, verify=False)

        return mod_notables.json()

    def severity_to_level(severity):
        if severity == 'informational':
            return 0.5
        elif severity == 'critical':
            return 4
        elif severity == 'high':
            return 3
        elif severity == 'medium':
            return 2
        else:
            return 1

    def notable_to_incident(event):
        incident = {}
        rule_title = ''
        rule_name = ''
        if demisto.get(event, 'rule_title'):
            rule_title = event['rule_title']
        if demisto.get(event, 'rule_name'):
            rule_name = event['rule_name']
        incident["name"] = rule_title + ' : ' + rule_name
        if demisto.get(event, 'urgency'):
            incident["severity"]= severity_to_level(event['urgency'])
        if demisto.get(event, 'rule_description'):
            incident["details"] = event["rule_description"]
        incident["occurred"] = event["_time"]
        incident["rawJSON"] = json.dumps(event)
        labels = []
        if demisto.get(demisto.params(),'parseNotableEventsRaw'):
            isParseNotableEventsRaw = demisto.params()['parseNotableEventsRaw']
            if isParseNotableEventsRaw:
                rawDict = rawToDict(event['_raw'])
                for rawKey in rawDict:
                    labels.append({'type':rawKey,'value':rawDict[rawKey]})
        if demisto.get(event, 'security_domain'):
            labels.append({'type':'security_domain','value':event["security_domain"]})
        incident['labels'] = labels
        return incident

    def handler(proxy):
        proxy_handler = urllib2.ProxyHandler({'http': proxy, 'https': proxy})
        opener = urllib2.build_opener(proxy_handler)
        urllib2.install_opener(opener)
        return request

    def request(url, message, **kwargs):
        method = message['method'].lower()
        data = message.get('body', "") if method == 'post' else None
        headers = dict(message.get('headers', []))
        req = urllib2.Request(url, data, headers)
        try:
            response = urllib2.urlopen(req)
        except urllib2.URLError, response:
            # If running Python 2.7.9+, disable SSL certificate validation and try again
            if sys.version_info >= (2, 7, 9):
                response = urllib2.urlopen(req, context=ssl._create_unverified_context())
            else:
                raise
        except urllib2.HTTPError, response:
            pass # Propagate HTTP errors via the returned response message
        return {
            'status': response.code,
            'reason': response.msg,
            'headers': response.info().dict,
            'body': StringIO(response.read())
        }

    service = None
    proxy = demisto.params()['proxy']
    if proxy:
        try:
            service = client.connect(
                handler=handler(proxy),
                host=demisto.params()['host'],
                port=demisto.params()['port'],
                username=demisto.params()['authentication']['identifier'],
                password=demisto.params()['authentication']['password'])
        except urllib2.URLError as e:
            if e.reason.errno == 1 and sys.version_info < (2, 6, 3):
                pass
            else:
                raise
    else:
        service = client.connect(
            host=demisto.params()['host'],
            port=demisto.params()['port'],
            username=demisto.params()['authentication']['identifier'],
            password=demisto.params()['authentication']['password'])

    # The command demisto.command() holds the command sent from the user.
    if demisto.command() == 'test-module':
        #for app in service.apps:
        #    print app.name
        if len(service.jobs) >= 0:
            demisto.results('ok')
        sys.exit(0)
    if demisto.command() == 'splunk-search':
        t = datetime.utcnow() - timedelta(days=7)
        time = t.strftime(SPLUNK_TIME_FORMAT)
        kwargs_oneshot = {"earliest_time":time}
        if demisto.get(demisto.args(), 'earliest_time'):
            kwargs_oneshot['earliest_time'] = demisto.args()['earliest_time']
        if demisto.get(demisto.args(), 'latest_time'):
            kwargs_oneshot['latest_time'] = demisto.args()['latest_time']
        if demisto.get(demisto.args(), 'event_limit'):
            kwargs_oneshot['count'] = int(demisto.args()['event_limit'])
        searchquery_oneshot = demisto.args()['query']
        searchquery_oneshot = searchquery_oneshot.encode('utf-8')
        if not searchquery_oneshot.startswith('search') and not searchquery_oneshot.startswith('Search') and not searchquery_oneshot.startswith('|'):
            searchquery_oneshot = 'search '+searchquery_oneshot
        oneshotsearch_results = service.jobs.oneshot(searchquery_oneshot, **kwargs_oneshot)

        reader = results.ResultsReader(oneshotsearch_results)
        res = []
        dbot_scores = []
        for item in reader:
            if isinstance(item, results.Message):
                demisto.results({"Type": 1, "ContentsFormat": "json", "Contents": json.dumps(item.message)})
            elif isinstance(item, dict):
                if demisto.get(item, 'host'):
                    dbot_scores.append({'Indicator': item['host'], 'Type': 'hostname', 'Vendor': 'Splunk', 'Score': 0, 'isTypedIndicator': True})
                # Normal events are returned as dicts
                res.append(item)
        ec = {};
        ec['Splunk.Result'] = res
        if len(dbot_scores) > 0:
            ec['DBotScore'] = dbot_scores
        demisto.results({"Type": 1, "ContentsFormat": "json", "Contents": json.dumps(res), "EntryContext": ec})
        sys.exit(0)
    if demisto.command() == 'splunk-job-create':
        searchquery_normal = demisto.args()['query']
        if not searchquery_normal.startswith('search'):
            searchquery_normal = 'search '+searchquery_normal
        kwargs_normalsearch = {"exec_mode": "normal"}
        job = service.jobs.create(searchquery_normal, **kwargs_normalsearch)

        ec = {};
        ec['Splunk.Job'] = job.sid
        demisto.results({"Type": 1, "ContentsFormat": formats['text'], "Contents": "Splunk Job created with SID: "+job.sid, "EntryContext": ec})
        sys.exit(0)
    if demisto.command() == 'splunk-results':
        jobs = service.jobs
        found = False
        res = []
        for job in jobs:
            if job.sid == demisto.args()['sid']:
                rr = results.ResultsReader(job.results())
                for result in rr:
                    if isinstance(result, results.Message):
                        demisto.results({"Type": 1, "ContentsFormat": "json", "Contents": json.dumps(result.message)})
                    elif isinstance(result, dict):
                        # Normal events are returned as dicts
                        res.append(result)
                found = True
        if not found:
            demisto.results("Found no job for sid: "+demisto.args()['sid'])
        if found:
            demisto.results({"Type": 1, "ContentsFormat": "json", "Contents": json.dumps(res)})
        sys.exit(0)
    if demisto.command() == 'fetch-incidents':
        lastRun = demisto.getLastRun() and demisto.getLastRun()['time']

        incidents = []
        t = datetime.utcnow()
        if demisto.get(demisto.params(), 'timezone'):
            timezone = demisto.params()['timezone']
            t = t + timedelta(minutes=int(timezone))

        now = t.strftime(SPLUNK_TIME_FORMAT)
        if demisto.get(demisto.params(), 'useSplunkTime'):
            now = get_current_splunk_time(service)
            t = datetime.strptime(now, SPLUNK_TIME_FORMAT)
        if len(lastRun) == 0:
            t = t - timedelta(minutes=10)
            lastRun = t.strftime(SPLUNK_TIME_FORMAT)
        kwargs_oneshot = {"index_earliest": lastRun,
                      "index_latest": now, "count": 0}
        searchquery_oneshot = demisto.params()['fetchQuery']

        if demisto.get(demisto.params(), 'extractFields'):
            extractFields = demisto.params()['extractFields']
            extra_raw_arr = extractFields.split(',')
            for field in extra_raw_arr:
                field_trimmed = field.strip()
                searchquery_oneshot = searchquery_oneshot + ' | eval '+field_trimmed+'='+field_trimmed

        oneshotsearch_results = service.jobs.oneshot(searchquery_oneshot, **kwargs_oneshot)
        reader = results.ResultsReader(oneshotsearch_results)
        for item in reader:
            inc = notable_to_incident(item)
            incidents.append(inc)
        demisto.incidents(incidents)
        demisto.setLastRun({'time': now})
        sys.exit(0)
    if demisto.command() == 'splunk-get-indexes':
        indexes = service.indexes
        indexesNames = []
        for index in indexes:
            index_json = {'name':index.name, 'count': index["totalEventCount"]}
            indexesNames.append(index_json)
        demisto.results({"Type": 1, "ContentsFormat": "json", "Contents": json.dumps(indexesNames), 'HumanReadable':tableToMarkdown("Splunk Indexes names", indexesNames, '')})
        sys.exit(0)
    if demisto.command() == 'splunk-submit-event':
        try:
            index = service.indexes[demisto.args()['index']]
        except KeyError:
            demisto.results({'ContentsFormat': formats['text'],'Type': entryTypes['error'],'Contents':"Found no Splunk index: "+demisto.args()['index']})
            sys.exit(0)
        else:
            data = demisto.args()['data']
            data_formatted = data.encode('utf8')
            r = index.submit(data_formatted, sourcetype=demisto.args()['sourcetype'], host=demisto.args()['host'])
            demisto.results('Event was created in Splunk index: '+r.name)
        sys.exit(0)
    if demisto.command() == 'splunk-notable-event-edit':
        if not proxy:
            os.environ["HTTPS_PROXY"] = ""
            os.environ["HTTP_PROXY"] = ""
            os.environ["https_proxy"] = ""
            os.environ["http_proxy"] = ""
        baseurl = 'https://'+demisto.params()['host']+':'+demisto.params()['port']+'/'
        username=demisto.params()['authentication']['identifier']
        password=demisto.params()['authentication']['password']
        auth_req = requests.post(baseurl + 'services/auth/login', data={'username': username, 'password': password, 'output_mode': 'json'}, verify=False)
        sessionKey = auth_req.json()['sessionKey']
        eventIDs = None
        if demisto.get(demisto.args(), 'eventIDs'):
            eventIDsStr = demisto.args()['eventIDs']
            eventIDs = eventIDsStr.split(",")
        status = None
        if demisto.get(demisto.args(), 'status'):
            status = int(demisto.args()['status'])
        response_info = updateNotableEvents( sessionKey=sessionKey, baseurl=baseurl, comment=demisto.get(demisto.args(), 'comment'), status=status,
            urgency=demisto.get(demisto.args(), 'urgency'),
            owner=demisto.get(demisto.args(), 'owner'), eventIDs=eventIDs)
        if not response_info['success']:
                demisto.results({'ContentsFormat': formats['text'],'Type': entryTypes['error'],
                    'Contents':"Could not update notable events: "+demisto.args()['eventIDs']+' : '+str(response_info)})
                sys.exit(0)
        demisto.results('Splunk ES Notable events: '+response_info['message'])
        sys.exit(0)
    if demisto.command() == 'splunk-parse-raw':
        raw = demisto.args()['raw']
        rawDict = rawToDict(raw)
        ec = {};
        ec['Splunk.Raw.Parsed'] = rawDict
        demisto.results({"Type": 1, "ContentsFormat": "json", "Contents": json.dumps(rawDict), "EntryContext": ec})
        sys.exit(0)
  type: python
  commands:
  - name: splunk-results
    arguments:
    - name: sid
      required: true
      default: true
      description: search id
    description: fetch splunk search results, can be used in conjunction with splunk-job-create
  - name: splunk-search
    arguments:
    - name: query
      required: true
      default: true
      description: The splunk search language string to execute, example :"index=*
        | head 3"
    - name: earliest_time
      description: 'Specifies the earliest time in the time range to search. The time
        string can be a UTC time (with fractional seconds), a relative time specifier
        (to now), or a formatted time string. Default is 1 week ago, in this format
        "-7d", also possible to do time as: 2014-06-19T12:00:00.000-07:00"'
    - name: latest_time
      description: Specifies the latest time in the time range to search. The time
        string can be a UTC time (with fractional seconds), a relative time specifier
        (to now), or a formatted time string, example "2014-06-19T12:00:00.000-07:00"
        or "-3d" (for time 3 days before now)
    - name: event_limit
      description: Limit the amount of events to return, Default is 100, put 0 for
        unlimited
    outputs:
    - contextPath: Splunk.Result
      description: The splunk search result, json array where each item is a splunk
        event
    description: Search Splunk for events
  - name: splunk-submit-event
    arguments:
    - name: index
      required: true
      description: Splunk index to push data to, run splunk-print-indexes to get all
        indexes
    - name: data
      required: true
      default: true
      description: The new event data to push, can be any string
    - name: sourcetype
      required: true
      description: Event sourcetype
    - name: host
      required: true
      description: Event host, can be 'Local' or '120.0.0.1' for example
    description: Create new event in splunk
  - name: splunk-get-indexes
    arguments: []
    description: Print all Splunk index names
  - name: splunk-notable-event-edit
    arguments:
    - name: eventIDs
      required: true
      description: 'The notable events event_id, comma separated for a list '
    - name: owner
      description: Splunk user to assign to notable event
    - name: comment
      required: true
      description: Comment to add to notable event
    - name: urgency
      auto: PREDEFINED
      predefined:
      - critical
      - high
      - medium
      - low
      - informational
      description: Notable Event urgency
    - name: status
      description: Notable event status- 0 for Unassigned,1 for Assigned, 2 for In
        Progress, 3 for pending, 4 for Resolved, 5 for Closed
    description: Update an existing Notable event in Splunk ES
    execution: true
  - name: splunk-job-create
    arguments:
    - name: query
      required: true
      description: The splunk search language string to execute, example :"index=*
        | head 3"
    outputs:
    - contextPath: Splunk.Job
      description: The created job SID
    description: 'Create new search job in Splunk '
  - name: splunk-parse-raw
    arguments:
    - name: raw
      default: true
      description: The Raw data of splunk event, in string format
      defaultValue: ${Splunk.Result._raw}
    outputs:
    - contextPath: Splunk.Raw.Parsed
      description: The raw event data parsed
      type: unknown
    description: Parse the Raw part of the event
  dockerimage: demisto/splunksdk:1.0
  isfetch: true
