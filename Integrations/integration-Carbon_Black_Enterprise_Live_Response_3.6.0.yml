commonfields:
  id: carbonblackliveresponse
  version: -1
name: carbonblackliveresponse
display: Carbon Black Enterprise Live Response
toversion: 3.6.0
category: Endpoint
image: data:image/png;base64,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
description: Collect information and take action on remote endpoints in real time
  with Carbon Black Enterprise Live Response.
configuration:
- display: Server URL
  name: serverurl
  defaultvalue: ""
  type: 0
  required: true
- display: API Token (CB Response)
  name: apitoken
  defaultvalue: ""
  type: 4
  required: false
- display: API Key (CB Defense)
  name: apikey
  defaultvalue: ""
  type: 4
  required: false
- display: Connector ID (CB Defense)
  name: connector
  defaultvalue: ""
  type: 0
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |-
    "use strict";

    /// Global Vars
    let CB_PRODUCT;
    let BASE_URL;
    let AUTH;
    let COMMAND_DATA;
    let SLEEP_BETWEEN_RETRIES = 5000;
    let ERROR_MESSAGE = 'Use Live Response for Cb Defense or Cb Response.\nFor Cb Defense: Provide \'Live Response\' API key and connector.\nFor Cb Response: Provide API Token.';

    //validate the credentials are provided to match only one of the products
    if (params.apitoken && (params.apikey || params.connector) ) {
        throw ERROR_MESSAGE;
    }
    //determain Cb product
    if (params.apitoken) {
        CB_PRODUCT = 'Response';
        BASE_URL = `${params.serverurl}/api/v1/cblr`;
        AUTH = params.apitoken;
        COMMAND_DATA = [
            {to: 'CbSensorID', from: 'sensor_id'},
            {to: 'CbSessionID', from: 'session_id'},
            {to: 'CbCommandID', from: 'id'},
            {to: 'CommandName', from: 'name'},
            {to: 'Status', from: 'status'},
            {to: 'CreateTime', from: 'create_time'},
            {to: 'CommandCompletionTime', from: 'completion'},
            {to: 'OperandObject', from: 'object'}
        ];
    } else if (params.apikey && params.connector){
        CB_PRODUCT = 'Defense';
        BASE_URL = `${params.serverurl}/integrationServices/v3/cblr`
        AUTH = params.apikey + '/' + params.connector;
        COMMAND_DATA = [
            {to: 'CbSensorID', from: 'sensor_id'},
            {to: 'CbSessionID', from: 'session_id'},
            {to: 'CbCommandID', from: 'id'},
            {to: 'CommandName', from: 'name'},
            {to: 'Status', from: 'status'},
            {to: 'CreateTime', from: 'create_time'},
            {to: 'CommandCompletionTime', from: 'completion_time'},
            {to: 'OperandObject', from: 'obj.object'}
        ];
    } else {
        throw ERROR_MESSAGE;
    }

    /// Base Functions

    function sendRequest(path, method, requestParams, headers, ignoredStatusCodes) {

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [AUTH];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: method,
            Headers: headers
        };
        let querystring = '';
        if (requestParams) {
            if (typeof requestParams === 'string') {
                querystring = requestParams;
            } else {
                request.Body = JSON.stringify(requestParams);
            }
        }
        let result = http(BASE_URL + path + querystring, request, params.insecure, params.proxy);

        if (!ignoredStatusCodes || ignoredStatusCodes.indexOf(result.StatusCode) === -1) {
            if (result.StatusCode < 200 || result.StatusCode >= 300) {
                if (result.StatusCode === 404) {
                    throw `Cannot find the requested resource\nError message: ${result.Body}\nStatus Code: 404`;
                }
                throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${result.Body}.`;
            }
        }
        return result;
    }

    function sendFileRequest(path, fileId, requestParams, headers, ignoredStatusCodes) {

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [AUTH];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: 'POST',
            Headers: headers
        };

        let result = httpMultipart(BASE_URL + path, fileId, request, requestParams, params.insecure, params.proxy);

        if (result.StatusCode < 200 || result.StatusCode >= 300) {
            if (result.StatusCode === 404) {
                throw `${result.Body} (Status Code: 404)`;
            }
            throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${JSON.stringify(result.Body)}`;
        }

        return result;
    }

    /// Commands

    function testModule() {
        let res = sendRequest('/session', 'GET');
        if (res.StatusCode === 200) {
            return 'ok';
        }
        return `Test failed. Status Code: ${res.StatusCode}`
    }

    const sessionData = [
        {to: 'CbSensorID', from: 'sensor_id'},
        {to: 'CbSessionID', from: 'id'},
        {to: 'Hostname', from: 'hostname'},
        {to: 'Status', from: 'status'},
        {to: 'WaitTimeout', from: 'sensor_wait_timeout'},
        {to: 'SessionTimeout', from: 'session_timeout'},
        {to: 'SupportedCommands', from: 'supported_commands'}
    ];

    function getSessionsRequest(sessionId, sensorId, status) {
        let path = `/session`;
        if (sessionId) {
            path += '/' + sessionId;
        }

        let response = sendRequest(path, 'GET').Body;
        let result;
        try {
            result = JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }

        // If optional sensor argument is given, filter the results by it.
        if (!sessionId && sensorId) {
            sensorId = parseInt(sensorId);
            result = result.filter(session => (parseInt(session.sensor_id) === sensorId));
        }
        if (!sessionId && status) {
            result = result.filter(session => (status.indexOf(session.status) > -1));
        }

        return result;
    }

    function getSessions() {
        let result = getSessionsRequest(args.session, args.sensor, args.status);

        let title = 'CB Response - Get Sessions';
        let dataMap = sessionData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    function createSessionRequest(sensorId, commandTimeout, keepaliveTimeout) {
        let queryParams = {
            sensor_id: parseInt(sensorId)
        };
        if (commandTimeout) {
            queryParams.session_timeout = commandTimeout;
        }
        if (keepaliveTimeout) {
            queryParams.sensor_wait_timeout = keepaliveTimeout;
        }
        let path = CB_PRODUCT === 'Response' ?  '/session' : `/session/${sensorId}`;
        let response = sendRequest(path, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function createSession() {
        let result = createSessionRequest(args.sensor, args['command-timeout'], args['keepalive-timeout']);

        let title = 'CB Response - Create Session';
        let dataMap = sessionData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    function createSessionAndWait() {
        let result = createSessionRequest(args.sensor, args['command-timeout'], args['keepalive-timeout']);
        sleep(1000);
        let sessionId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : 20 * 1000;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getSessionsRequest(sessionId, args.sensor);
            if (result.status === 'active') {
                let title = 'CB Response - Create Session And Wait';
                let dataMap = sessionData;
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': createContext(translatedData)
                };
                return {
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context,
                };
                return;
            } else if (result.status !== 'pending') {
                throw `Executing session ${sessionId} failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Creating session ${sessionId} timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }

    function closeSessionRequest(sessionId) {
        let queryParams = {
            session: sessionId
        };
        queryParams.status = CB_PRODUCT === 'Response' ? 'close' : 'CLOSE';
        let path = CB_PRODUCT === 'Response' ? `/session/${sessionId}` : '/session';
        let response = sendRequest(path, 'PUT', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }

    }

    function closeSession() {
        let result = closeSessionRequest(parseInt(args.session));

        let title = 'CB Response - Session Closed';
        let dataMap = sessionData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    function sessionKeepaliveRequest(sessionId) {
        let response = sendRequest(`/session/${sessionId}/keepalive`, 'GET', undefined, undefined, [404]);

        if (response.StatusCode === 404) {
            throw `Session ${sessionId} has expired and is now closed. Create a new session to continue working.`;
        }

        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }

    function sessionKeepAlive() {
        let result = sessionKeepaliveRequest(args.session);

        let translatedData = mapObjFunction(sessionData)(result);
        let context = {
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: `Keepalive successful for session ${args.session}`,
            EntryContext: context,
        };
    }

    function archiveSessionRequest(sessionId) {
        let response = sendRequest(`/session/${sessionId}/archive`, 'GET', undefined, undefined, [500]);
        if (response.StatusCode === 500) {  // Current bug in CBResponse returns 500 for empty sessions
            throw `Session ${sessionId} is empty and so it has no archive.`;
        }
        return response;
    }

    function archiveSession() {
        let response = archiveSessionRequest(args.session);
        let fileEntryId = saveFile(response.Bytes);
        let fileName = `session-${args.session}-archive.zip`;
        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: fileName,
            Contents: fileName
        };
    }

    function createCommandRequest(sessionId, name, timeout, object, compress, wait, workingDir, outputFile, valueData,
                                  valueType, overwrite, offset, getCount) {
        let queryParams = {
            name: name.split('-').join(' ')
        };
        if (timeout) {
            queryParams.timeout = timeout;
        }
        if (object) {
            queryParams.object = object;
        }
        if (compress) {
            queryParams.compress = compress;
        }
        queryParams.wait = true;
        if (wait !== undefined && wait === false) {
            queryParams = wait;
        }
        if (workingDir) {
            queryParams.working_directory = workingDir;
        }
        if (outputFile) {
            queryParams.output_file = outputFile;
        }
        if (valueData) {
            queryParams.value_data = valueData;
        }
        if (valueType) {
            queryParams.value_type = valueType;
        }
        if (overwrite) {
            queryParams.overwrite = overwrite;
        }
        if (offset) {
            queryParams.offset = offset;
        }
        if (getCount) {
            queryParams.get_count = getCount;
        }

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    //TODO: Spec for commands interface
    function createCommand() {
        let result = createCommandRequest(args.session, args.name, args.timeout, args.object, args.compress, args.wait,
            args['working-dir'], args['output-file'], args['value-data'], args['value-type'], args.overwrite, args.offset,
            args['get-count']);

        let title = `CB Response - Run Command ${args.name}`;
        let dataMap = COMMAND_DATA;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    function createCommandAndWait() {
        let result = createCommandRequest(args.session, args.name, args.timeout, args.object, args.compress, args.wait,
            args['working-dir'], args['output-file'], args['value-data'], args['value-type'], args.overwrite, args.offset,
            args['get-count']);
        sleep(1000);
        let commandId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : 20 * 1000;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getCommandsRequest(args.session, commandId);

            if (result.status === 'complete') {
                let entries = [];
                let title = 'CB Response - Execute Command And Wait';
                let dataMap = COMMAND_DATA.concat([
                    {to: 'Result.Desc', from: 'result_desc'},
                    {to: 'Result.Type', from: 'result_type'},
                    {to: 'Result.Code', from: 'result_code'}
                ]);
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
                };
                entries.push({
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context,
                });

                // If we have the command in args then we get info for the command,
                // in this case we want to parse the result:
                let contents = result;
                switch (result.name) {
                    case "directory list":
                        contents = result.files;
                        break;
                    case "process list":
                        contents = result.processes;
                        break;
                }
                logInfo("Here2");
                entries.push({
                    Type: entryTypes.note,
                    Contents: contents,
                    ContentsType: formats.json,
                    // TODO: Add human readable and context for specific commands
                });

                return entries;

            } else if (result.status !== 'pending') {
                throw `Executing command ${commandId} failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Executing command ${commandId} timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }

    function terminateProcess() {
        let result = createCommandRequest(args.session, 'kill', undefined, args.pid, undefined, args.wait);
        sleep(1000);
        let commandId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : 20 * 1000;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getCommandsRequest(args.session, commandId);
            if (result.status === 'complete') {
                let title = `CB Response - Terminate Process ${args.pid}`;
                let dataMap = COMMAND_DATA;
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
                };
                return {
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context,
                };
            } else if (result.status !== 'pending') {
                throw `Terminating process failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Terminating process timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }

    function getCommandsRequest(sessionId, commandId) {
        let path = `/session/${sessionId}/command`;
        if (commandId) {
            path += '/' + commandId;
        }
        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function getCommands() {
        let result = getCommandsRequest(args.session, args.command);

        let entries = [];

        let title = 'CB Response - Get Commands';
        let dataMap = COMMAND_DATA.concat([
            {to: 'Result.Desc', from: 'result_desc'},
            {to: 'Result.Type', from: 'result_type'},
            {to: 'Result.Code', from: 'result_code'}
        ]);
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
        };

        entries.push({
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        });

        // If we have the command in args then we get info for the command,
        // in this case we want to parse the result:
        if (args.command) {
            let contents = result;
            switch (result.name) {
                case "directory list":
                    contents = result.files;
                    break;
                case "process list":
                    contents = result.processes;
                    break;
            }
            entries.push({
                Type: entryTypes.note,
                Contents: contents,
                ContentsType: formats.json,
                // TODO: Add human readable and context for specific commands
            });
        }

        return entries;
    }

    function cancelCommandRequest(sessionId, commandId) {
        let queryParams = {cmdid: commandId};
        let response = sendRequest(`/session/${sessionId}/command/${commandId}`, 'PUT', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function cancelCommand() {
        let result = cancelCommandRequest(args.session, args.command);

        let title = 'CB Response - Cancel Command';
        let dataMap = COMMAND_DATA.concat([
            {to: 'Result.Desc', from: 'result_desc'},
            {to: 'Result.Type', from: 'result_type'},
            {to: 'Result.Code', from: 'result_code'}
        ]);
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    const fileData = [
        {to: 'CbFileID', from: 'id'},
        {to: 'Filename', from: 'file_name'},
        {to: 'Size', from: 'size_uploaded'},
        {to: 'Status', from: 'status'},
        {to: 'Delete', from: 'delete'},
    ];

    function listFilesRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        let path = `/session/${sessionId}/file`;
        if (fileId) {
            path += '/' + fileId;
        }

        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function listFiles() {
        let result = listFilesRequest(args.session, args['file-id']);
        let title = 'CB Response - List Files';
        let dataMap = fileData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Files(val.CbFileID==obj.CbFileID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    function downloadFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let path = `/session/${sessionId}/file/${fileId}`;
        return sendRequest(path + '/content', 'GET');
    }

    function downloadFile() {
        let fileInfo = listFilesRequest(args.session, args['file-id']);
        let fileContentResponse = downloadFileRequest(args.session, args['file-id']);
        let fileEntryId = saveFile(fileContentResponse.Bytes);
        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: fileInfo.file_name,
            Contents: fileInfo.file_name
        };
    }

    function uploadFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let response = sendFileRequest(`/session/${sessionId}/file`, fileId);
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function uploadFile() {
        let result = uploadFileRequest(args.session, args['file-id']);

        let title = 'CB Response - Upload File';
        let dataMap = fileData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Files(val.CbFileID==obj.CbFileID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    function deleteFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let path = `/session/${sessionId}/file/${fileId}`;
        let response = sendRequest(path, 'DELETE').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function deleteFile() {
        let result = deleteFileRequest(args.session, args['file-id']);

        let title = 'CB Response - Delete File';
        let dataMap = fileData;
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(result);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
        let context = {
            'CbResponse.Files(val.CbFileID==obj.CbFileID)': createContext(translatedData)
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    try {
        switch (command) {
            case 'test-module':
                return testModule();
            case 'cb-list-sessions':
                if (CB_PRODUCT == 'Defense') {
                    throw '\'cb-list-sessions\' is not available for Cb Defense.';
                }
                  return getSessions();
            case 'cb-session-info':
                return getSessions();
            case 'cb-session-create':
                return createSession();
            case 'cb-session-create-and-wait':
                return createSessionAndWait();
            case 'cb-session-close':
                return closeSession();
            case 'cb-keepalive':
                return sessionKeepAlive();
            case 'cb-archive':
                if (CB_PRODUCT == 'Defense') {
                    throw '\'cb-archive\' is not available for Cb Defense.';
                }
                return archiveSession();
            case 'cb-list-commands':
            case 'cb-command-info':
                return getCommands();
            case 'cb-terminate-process':
                return terminateProcess();
            case 'cb-command-create':
                return createCommand();
            case 'cb-command-create-and-wait':
                return createCommandAndWait();
            case 'cb-command-cancel':
                return cancelCommand();
            case 'cb-file-get':
                return downloadFile();
            case 'cb-list-files':
            case 'cb-file-info':
                return listFiles();
            case 'cb-file-upload':
                return uploadFile();
            case 'cb-file-delete':
                return deleteFile();
            default:
                throw `Unknown Command: ${command}`;
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: err
        };
    }

    /// Util methods

    function sleep(ms) {
        var start = new Date().getTime();
        var expire = start + ms;
        while (new Date().getTime() < expire) {
            /*Do nothing*/
        }
        return;
    }
  type: javascript
  commands:
  - name: cb-archive
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID to return the archive of
    description: Archive the given session (If the session has no content it will
      fail)
  - name: cb-command-cancel
    arguments:
    - name: session
      required: true
      description: Session ID of command to cancel
    - name: command
      required: true
      description: Command ID to cancel
    description: Cancel the given command
  - name: cb-command-create
    arguments:
    - name: name
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - put-file
      - get-file
      - delete-file
      - directory-list
      - reg-enum-key
      - reg-query-value
      - reg-create-key
      - reg-delete-key
      - reg-delete-value
      - reg-set-value
      - process-list
      - kill
      - create-process
      - memdump
      description: Command name
    - name: timeout
      description: Command timeout
    - name: object
      description: the object the command operates on. This is specific to the command
        but has meaning in a generic way for logging, and display purposes
    - name: compress
      description: '"true" or "false" - an optional parameter to specify whether to
        compress resulting memory dump'
    - name: working-dir
      description: An optional parameter to specify the working directory of the executable
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: value-data
      description: the data associated with the registry value
    - name: value-type
      description: the string representation of the registry value type (ie REG_DWORD,
        REG_QWORD, ….)
    - name: overwrite
      description: “true” or “false”. An optional parameter to specify whether to
        overwrite the value if it already exists (default value is “false”)
    - name: offset
      description: a byte offset to start getting the file. Supports a partial get.
    - name: get-count
      description: the number of bytes to grab
    - name: session
      required: true
      description: Session ID to create command for
    outputs:
    - contextPath: CbResponse.Commands.Status
      description: The Command Status
    - contextPath: CbResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory
        list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbResponse.Commands.WaitTimeout
      description: The Wait timeout
    description: Create a live response command
  - name: cb-command-create-and-wait
    arguments:
    - name: name
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - put-file
      - get-file
      - delete-file
      - directory-list
      - reg-enum-key
      - reg-query-value
      - reg-create-key
      - reg-delete-key
      - reg-delete-value
      - reg-set-value
      - process-list
      - kill
      - create-process
      - memdump
      description: Command name
    - name: timeout
      description: Command timeout
    - name: object
      description: the object the command operates on. This is specific to the command
        but has meaning in a generic way for logging, and display purposes
    - name: compress
      description: '"true" or "false" - an optional parameter to specify whether to
        compress resulting memory dump'
    - name: working-dir
      description: An optional parameter to specify the working directory of the executable
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: value-data
      description: the data associated with the registry value
    - name: value-type
      description: the string representation of the registry value type (ie REG_DWORD,
        REG_QWORD, ….)
    - name: overwrite
      description: “true” or “false”. An optional parameter to specify whether to
        overwrite the value if it already exists (default value is “false”)
    - name: offset
      description: a byte offset to start getting the file. Supports a partial get.
    - name: get-count
      description: the number of bytes to grab
    - name: session
      required: true
      description: Session ID to create command for
    - name: wait-timeout
      description: Time to wait in seconds to wait for command to finish executing
      defaultValue: "20"
    outputs:
    - contextPath: CbResponse.Commands.Status
      description: The Command Status
    - contextPath: CbResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory
        list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbResponse.Commands.WaitTimeout
      description: The Wait timeout
    description: Create a live response command and wait for it to finish executing
  - name: cb-command-info
    arguments:
    - name: session
      required: true
      description: Session ID of the command
    - name: command
      required: true
      description: Command ID
    outputs:
    - contextPath: CbResponse.Commands.Status
      description: The Command Status
    - contextPath: CbResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory
        list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbResponse.Commands.WaitTimeout
      description: The Wait timeout
    - contextPath: CbResponse.Commands.Result.Desc
      description: Result description
    - contextPath: CbResponse.Commands.Result.Type
      description: Result type
    - contextPath: CbResponse.Commands.Result.Code
      description: Result code
    description: Display information about a given command
  - name: cb-file-delete
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    - name: file-id
      required: true
      description: File ID
    outputs:
    - contextPath: CbResponse.Files.Filename
      description: The Filename
    - contextPath: CbResponse.Files.Size
      description: The File size
    - contextPath: CbResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get
    - contextPath: CbResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Delete a given file in the session
  - name: cb-file-get
    arguments:
    - name: session
      required: true
      description: Session ID
    - name: file-id
      required: true
      description: File ID
    description: Retrieve a file in a given session
  - name: cb-file-info
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    - name: file-id
      description: File ID
    outputs:
    - contextPath: CbResponse.Files.Filename
      description: The Filename
    - contextPath: CbResponse.Files.Size
      description: The File size
    - contextPath: CbResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get.
    - contextPath: CbResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Get file info for a given file in a session
  - name: cb-file-upload
    arguments:
    - name: session
      required: true
      description: Session ID to upload the file through
    - name: file-id
      required: true
      description: File entry id of an attachment to upload to a sensor
    outputs:
    - contextPath: CbResponse.Files.Filename
      description: The Filename
    - contextPath: CbResponse.Files.Size
      description: The File size
    - contextPath: CbResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get.
    - contextPath: CbResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Uploads an attachment to the requested sensor by session
  - name: cb-keepalive
    arguments:
    - name: session
      required: true
      default: true
      description: The session ID to keepalive
    description: Keep the session alive to avoid closing due to timeout
  - name: cb-list-commands
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    description: List the CarbonBlack existing commands for a given session
  - name: cb-list-files
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    outputs:
    - contextPath: CbResponse.Files.Filename
      description: The Filename
    - contextPath: CbResponse.Files.Size
      description: The File size
    - contextPath: CbResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get.
    - contextPath: CbResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbResponse.Files.Delete
      description: Whether the file was deleted or not
    description: List files in a given session
  - name: cb-list-sessions
    arguments:
    - name: sensor
      description: Sensor ID to filter sessions by
    - name: status
      auto: PREDEFINED
      predefined:
      - active
      - pending
      - timeout
      - inactive
      - close
      description: 'Status to filter by (One of: active, pending, timeout, inactive,
        close)'
      isArray: true
    outputs:
    - contextPath: CbResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbResponse.Sessions.Status
      description: Session Status
    - contextPath: CbResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    - contextPath: CbResponse.Sessions.SessionTimeout
      description: Session Timeout
    description: List the CarbonBlack sessions
  - name: cb-session-close
    arguments:
    - name: session
      required: true
      description: The session ID to close
    outputs:
    - contextPath: CbResponse.Sessions.Status
      description: Session Status
    - contextPath: CbResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Close the given session
  - name: cb-session-create
    arguments:
    - name: sensor
      required: true
      default: true
      description: Sensor ID to create session for
    - name: command-timeout
      description: Session timeout (If a command will not be issued after this time
        the session will be closed)
    - name: keepalive-timeout
      description: Session keepalive timeout (If a keepalive is not issued after this
        time, the session will close)
    outputs:
    - contextPath: CbResponse.Sessions.Status
      description: Session Status
    - contextPath: CbResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Create a new CarbonBlack session for a given sensor
  - name: cb-session-create-and-wait
    arguments:
    - name: sensor
      required: true
      default: true
      description: Sensor ID to create session for
    - name: command-timeout
      description: Session timeout (If a command will not be issued after this time
        the session will be closed)
    - name: keepalive-timeout
      description: Session keepalive timeout (If a keepalive is not issued after this
        time, the session will close)
    - name: wait-timeout
      description: Time in seconds to wait for session to be active
      defaultValue: "20"
    outputs:
    - contextPath: CbResponse.Sessions.Status
      description: Session Status
    - contextPath: CbResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Create a new CarbonBlack session for a given sensor and wait for
      it to be active
  - name: cb-session-info
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID to get info for
    outputs:
    - contextPath: CbResponse.Sessions.Status
      description: Session Status
    - contextPath: CbResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Display session info
  - name: cb-terminate-process
    arguments:
    - name: session
      required: true
      description: Session ID
    - name: pid
      required: true
      description: Process ID to terminate
    - name: wait-timeout
      description: Time to wait in seconds for process to complete termination
      defaultValue: "20"
    description: Terminates a process at the sensor/endpoint
  runonce: false
