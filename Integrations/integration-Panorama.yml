commonfields:
  id: Panorama
  version: -1
name: Panorama
display: Palo Alto Networks PAN-OS
fromversion: 3.0.0
category: Network Security
image: data:image/png;base64,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
description: Manage Palo Alto Networks Firewalls and Panorama. Make sure you read
  the Detailed Instructions section.
detaileddescription: |-
  The integration uses the Panorama XML API.
  To obtain an API Key, run the following REST command and copy the key:
  https://[PanoramaIP]/api/?type=keygen&user=[user]&password=[password]

  For more information, visit the [Palo Alto Networks documentation](https://www.paloaltonetworks.com/documentation).

  ---
  You need to create a separate integration instance for Palo Alto Networks Firewall and Palo Alto Networks. Unless specified otherwise, all commands are valid for both Firewall and Panorama.

  ---
  ### Firewall: Configure the vsys
  - The vsys is located in the Firewall URL; e.g, https://<server>#device::<vsys>::device/setup

  ### Panorama: Configure a device group
  - Access the Panorama UI.
  - Go to Panorama --> Device Groups.
  - Choose a device group name.
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Port (e.g 443)
  name: port
  defaultvalue: "443"
  type: 0
  required: false
- display: API Key
  name: key
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Device group - Only for Panorama instance
  name: device_group
  defaultvalue: ""
  type: 0
  required: false
- display: Vsys - Only for Firewall instance
  name: vsys
  defaultvalue: ""
  type: 0
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import string
    from datetime import datetime
    import requests
    import json
    import re
    import uuid
    import time
    import os

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get("proxy", False):
        del os.environ["HTTP_PROXY"]
        del os.environ["HTTPS_PROXY"]
        del os.environ["http_proxy"]
        del os.environ["https_proxy"]

    if not demisto.params().get('port'):
        return_error('Set a port for the instance')

    ''' GLOBALS '''
    URL = demisto.params()['server'].rstrip('/:') + ':' + demisto.params().get('port') + '/api/'
    API_KEY = str(demisto.params()['key']);
    USE_SSL = not demisto.params()['insecure']

    # determine a vsys or a device-group
    VSYS = demisto.params().get('vsys')
    DEVICE_GROUP = demisto.params().get('device_group')
    # configuration check
    if DEVICE_GROUP and VSYS:
        return_error('Cannot configure both vsys and Device group. Set vsys for firewall, set Device group for Panorama')
    if not DEVICE_GROUP and not VSYS:
        return_error('Set vsys for firewall or Device group for Panorama')

    # setting security xpath relevant to FW or panorama managment
    XPATH_SECURITY_RULES = None
    if DEVICE_GROUP:
        XPATH_SECURITY_RULES = "/config/devices/entry/device-group/entry[@name=\'" + DEVICE_GROUP + "\']/"
    else:
        XPATH_SECURITY_RULES = "/config/devices/entry/vsys/entry[@name=\'" + VSYS + "\']/rulebase/security/rules/entry"

    # setting objects xpath relevant to FW or panorama managment
    XPATH_OBJECTS = None
    if DEVICE_GROUP:
        XPATH_OBJECTS = "/config/devices/entry/device-group/entry[@name=\'" + DEVICE_GROUP + "\']/"
    else:
        XPATH_OBJECTS = "/config/devices/entry/vsys/entry[@name=\'" + VSYS + "\']/"

    # Security rule arguments for output handling
    SECURITY_RULE_ARGS = {
        'rulename': 'Name',
        'source': 'Source',
        'destination': 'Destination',
        'negate_source': 'NegateSource',
        'negate_destination': 'NegateDestination',
        'action': 'Action',
        'service': 'Service',
        'disable': 'Disabled',
        'application': 'Application',
        'source_user': 'SourceUser',
        'disable_server_response_inspection': 'DisableServerResponseInspection',
        'descripton': 'Description',
        'target': 'Target'
    }

    PAN_OS_ERROR_DICT = {
        '1': 'Unknown command - The specific config or operational command is not recognized.',
        '2': 'Internal errors - Check with technical support when seeing these errors.',
        '3': 'Internal errors - Check with technical support when seeing these errors.',
        '4': 'Internal errors - Check with technical support when seeing these errors.',
        '5': 'Internal errors - Check with technical support when seeing these errors.',
        '6': 'Bad Xpath -The xpath specified in one or more attributes of the command is invalid. Check the API browser for proper xpath values.',
        '7': 'Object not present - Object specified by the xpath is not present. For example, entry[@name=value] where no object with name value is present.',
        '8': 'Object not unique - For commands that operate on a single object, the specified object is not unique.',
        '10': 'Reference count not zero - Object cannot be deleted as there are other objects that refer to it. For example, address object still in use in policy.',
        '11': 'Internal error - Check with technical support when seeing these errors.',
        '12': 'Invalid object - Xpath or element values provided are not complete.',
        '14': 'Operation not possible - Operation is allowed but not possible in this case. For example, moving a rule up one position when it is already at the top.',
        '15': 'Operation denied - Operation is allowed. For example, Admin not allowed to delete own account, Running a command that is not allowed on a passive device.',
        '16': 'Unauthorized -The API role does not have access rights to run this query.',
        '17': 'Invalid command -Invalid command or parameters.',
        '18': 'Malformed command - The XML is malformed.',
        # 19,20: success
        '21': 'Internal error - Check with technical support when seeing these errors.',
        '22': 'Session timed out - The session for this query timed out.'
    }

    ''' HELPERS '''
    def http_request(uri, method, headers = {}, body = {}, params={}, files = None):
        ''' Makes an API call with the given arguments '''
        result = requests.request(
            method,
            uri,
            headers=headers,
            data=body,
            verify=USE_SSL,
            params=params,
            files=files
        )

        if result.status_code < 200 or result.status_code >= 300:
            return_error('Request Failed. with status: ' + str(result.status_code) + '. Reason is: ' + str(result.reason))

        # if pcap download
        if params['type'] == 'export':
            return result
        jresult = json.loads(xml2json(result.text))

        #honadle non success
        if jresult['response']['@status'] != 'success':
            if 'msg' in jresult['response'] and 'line' in jresult['response']['msg']:

                # catch non existing object error and display a meaningful message
                if jresult['response']['msg']['line'] == 'No such node':
                    return_error('Object was not found, verify that the name is correct and that the instance was committed.')

                # catch non valid jobID errors and display a meaningful message
                elif isinstance(jresult['response']['msg']['line'], str) and jresult['response']['msg']['line'].find('job') != -1 and jresult['response']['msg']['line'].find('not found') != -1:
                    return_error('Invalid Job ID error: ' + jresult['response']['msg']['line'])

                # catch already at the top/bottom error for rules and return this as an entry.note
                elif str(jresult['response']['msg']['line']).find('already at the') != -1:
                    demisto.results('Rule ' + str(jresult['response']['msg']['line']))
                    sys.exit(0)

                # catch already registered ip tags and return this as an entry.note
                elif str(jresult['response']['msg']['line']).find('already exists, ignore') != -1:
                    if isinstance(jresult['response']['msg']['line']['uid-response']['payload']['register']['entry'], list):
                        ips = [o['@ip'] for o in jresult['response']['msg']['line']['uid-response']['payload']['register']['entry']]
                    else:
                        ips = jresult['response']['msg']['line']['uid-response']['payload']['register']['entry']['@ip']
                    demisto.results('IP ' + str(ips) + ' already exist in the tag. All submitted IPs were not registered to the tag')
                    sys.exit(0)

            if '@code' in jresult['response']:
                return_error('Request Failed.\nStatus code: ' + str(jresult['response']['@code']) + '\nWith message: ' + str(jresult['response']['msg']['line']))
            else:
                return_error('Request Failed.\n' + str(jresult['response']))

        # handle @code
        if 'response' in jresult and '@code' in jresult['response']:
            if jresult['response']['@code'] in PAN_OS_ERROR_DICT:
                return_error('Request Failed.\n' + PAN_OS_ERROR_DICT[jresult['response']['@code']])
            if jresult['response']['@code'] not in ['19','20']:
            # error code non exist in dict and not of success
                if 'msg' in jresult['response']:
                    return_error('Request Failed.\nStatus code: ' + str(jresult['response']['@code']) + '\nWith message: ' + str(jresult['response']['msg']))
                else:
                    return_error('Request Failed.\n' + str(jresult['response']))

        return jresult


    def add_argument_list(arg, field_name, member):
        member_stringify_list = ''
        if arg:
            for item in arg:
                member_stringify_list += '<member>' + item + '</member>'
            if field_name == 'member':
                return member_stringify_list
            elif member:
                return '<' + field_name + '>' + member_stringify_list + '</' + field_name + '>'
            else:
                return '<' + field_name + '>' + arg + '</' + field_name + '>'
        else:
            return ''


    def add_argument(arg, field_name, member):
        if arg:
            if member:
                return '<' + field_name + '><member>' + arg + '</member></' + field_name + '>'
            else:
                return '<' + field_name + '>' + arg + '</' + field_name + '>'
        else:
            return ''


    def add_argument_open(arg, field_name, member):
        if arg:
            if member:
                return '<' + field_name + '><member>' + arg + '</member></' + field_name + '>'
            else:
                return '<' + field_name + '>' + arg + '</' + field_name + '>'
        else:
            if member:
                return '<' + field_name + '><member>any</member></' + field_name + '>'
            else:
                return '<' + field_name + '>any</' + field_name + '>'


    def add_argument_yes_no(arg, field_name):
        if (arg and arg == 'No'):
            return '<' + field_name + '>' + 'no' + '</' + field_name + '>'
        else:
            return '<' + field_name + '>' + ('yes' if arg else 'no') + '</' + field_name + '>'


    def add_argument_target(arg, field_name):
        if arg:
            return '<' + field_name + '>' +  '<devices>' + '<entry name=\"' + arg + '\"/>' +'</devices>' + '</' + field_name + '>'
        else:
            return ''


    def prepare_security_rule_params(api_action = None, xpath = None, rulename = None, source = None, destination = None,
                    negate_source = None, negate_destination = None, action = None, service = None,
                    disable = None, application = None, source_user = None, category = None,
                    fromm = None, to = None, disable_server_response_inspection = None,
                    description = None, target = None):
        rulename = rulename if rulename else ('demisto-' + (str(uuid.uuid4()))[:8])
        params = {
            'type': 'config',
            'action': api_action,
            'key': API_KEY,
            'element': add_argument_open(action, 'action', False)
                    + add_argument_target(target, 'target')
                    + add_argument_open(description, 'description', False)
                    + add_argument_open(source, 'source', True)
                    + add_argument_open(destination, 'destination', True)
                    + add_argument_open(application, 'application', True)
                    + add_argument_open(category, 'category', True)
                    + add_argument_open(source_user, 'source-user', True)
                    # default from, to will always be any
                    + add_argument_open(fromm, 'from', True)
                    + add_argument_open(to, 'to', True)
                    + add_argument_open(service, 'service', True)
                    + add_argument_yes_no(negate_source, 'negate-source')
                    + add_argument_yes_no(negate_destination, 'negate-destination')
                    + add_argument_yes_no(disable, 'disabled')
        }
        if DEVICE_GROUP:
            if 'pre_post' not in demisto.args():
                return_error('Please provide the pre_post argument when configuring a security rule in Panorama instance.')
            else:
                params['xpath'] = XPATH_SECURITY_RULES + demisto.args()['pre_post'] + '/security/rules/entry' + '[@name=\'' + rulename + '\']'
        else:
            params['xpath'] = XPATH_SECURITY_RULES + '[@name=\'' + rulename + '\']'

        return params


    ''' FUNCTIONS'''
    def panorama_test():
        ''' test module '''
        params = {
            'type':'op',
            'cmd': '<show><system><info></info></system></show>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params
        )
        demisto.results('ok')


    @logger
    def panorama_command():
        ''' Executes a command '''
        params = {}
        params['key'] = API_KEY
        for arg in demisto.args().keys():
            params[arg] = demisto.args()[arg]

        result = http_request(
            URL,
            'POST',
            params=params
        )

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Command was executed successfully',
        })


    @logger
    def panorama_commit():
        params = {
            'type': 'commit',
            'cmd': '<commit></commit>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params
        )

        return result


    def panorama_commit_command():
        ''' Commit and show message in warroom '''
        result = panorama_commit()

        if 'result' in result['response']:
            # commit has been given a jobid
            commit_output = {
                'JobID': result['response']['result']['job'],
                'Status': 'Pending'
            }
            demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Commit:',commit_output, ['JobID', 'Status'], None, True),
            'EntryContext': {
                "Panorama.Commit(val.JobID == obj.JobID)": commit_output
            }
        })
        else:
            # no changes to commit
            demisto.results(result['response']['msg'])


    @logger
    def panorama_commit_status():
        params = {
            'type': 'op',
            'cmd': '<show><jobs><id>' + demisto.args()['job_id'] + '</id></jobs></show>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params
        )

        return result


    def panorama_commit_status_command():
        ''' Check jobID of commit status '''
        result = panorama_commit_status()

        if (result['response']['result']['job']['type'] != 'Commit'):
            return_error('JobID given is not of a commit')

        commit_status_output = {'JobID' : result['response']['result']['job']['id']}
        if (result['response']['result']['job']['status'] == 'FIN'):
            if (result['response']['result']['job']['result'] == 'OK'):
                commit_status_output['Status'] = 'Completed'
            else:
            # result['response']['job']['result'] == 'FAIL'
                commit_status_output['Status'] = 'Failed'
            commit_status_output['Details'] = result['response']['result']['job']['details']['line']

        if (result['response']['result']['job']['status'] == 'ACT'):
            if (result['response']['result']['job']['result'] == 'PEND'):
                commit_status_output['Status'] = 'Pending'

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Commit status:',commit_status_output, ['JobID', 'Status', 'Details'], None, True),
            'EntryContext': {"Panorama.Commit(val.JobID == obj.JobID)": commit_status_output}
        })


    @logger
    def panorama_push_to_device_group():
        params = {
            'type': 'commit',
            'action': 'all',
            'cmd': '<commit-all><shared-policy><device-group><entry name=\"' + DEVICE_GROUP + '\"/></device-group></shared-policy></commit-all>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params
        )

        return result


    def panorama_push_to_device_group_command():
        ''' Push Panorama configuration and show message in warroom '''
        if not DEVICE_GROUP:
            return_error("The 'panorama-push-to-device-group' command is relevant for a Palo Alto Panorama instance.")

        result = panorama_push_to_device_group()
        if 'result' in result['response']:
            # commit has been given a jobid
            push_output = {
                'DeviceGroup': DEVICE_GROUP,
                'JobID': result['response']['result']['job'],
                'Status': 'Pending'
            }
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': result,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('Push to Device Group:',push_output, ['JobID', 'Status'], None, True),
                'EntryContext': {
                    "Panorama.Push(val.JobID == obj.JobID)": push_output
                }
            })
        else:
            # no changes to commit
            demisto.results(result['response']['msg']['line'])


    @logger
    def panorama_push_status():
        params = {
            'type': 'op',
            'cmd': '<show><jobs><id>' + demisto.args()['job_id'] + '</id></jobs></show>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params
        )

        return result


    def panorama_push_status_command():
        ''' Check jobID of push status '''

        result = panorama_push_status()
        if (result['response']['result']['job']['type'] != 'CommitAll'):
            return_error('JobID given is not of a Push')

        push_status_output = {'JobID' : result['response']['result']['job']['id']}
        if (result['response']['result']['job']['status'] == 'FIN'):
            if (result['response']['result']['job']['result'] == 'OK'):
                push_status_output['Status'] = 'Completed'
            else:
            # result['response']['job']['result'] == 'FAIL'
                push_status_output['Status'] = 'Failed'
            push_status_output['Details'] = result['response']['result']['job']['devices']['entry']['status']

        if (result['response']['result']['job']['status'] == 'PEND'):
            push_status_output['Status'] = 'Pending'

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Push to Device Group status:', push_status_output, ['JobID', 'Status', 'Details'], None, True),
            'EntryContext': {"Panorama.Push(val.JobID == obj.JobID)": push_status_output}
        })


    ''' Addresses Commands '''
    def prettify_addresses_arr(addresses_arr):
        pretty_addresses_arr = []
        for address in addresses_arr:
            pretty_address = {
                'Name': address['@name'],
            }
            if 'description' in address:
                pretty_address['Description'] = address['description']

            if 'ip-netmask' in address:
                pretty_address['IP_Netmask'] = address['ip-netmask']

            if 'ip-range' in address:
                pretty_address['IP_Range'] = address['ip-range']

            if 'fqdn' in address:
                pretty_address['FQDN'] = address['fqdn']

            pretty_addresses_arr.append(pretty_address)

        return pretty_addresses_arr


    @logger
    def panorama_list_addresses():
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address/entry",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_list_addresses_command():
        ''' Get all addresses '''
        addresses_arr = panorama_list_addresses()
        addresses_output = prettify_addresses_arr(addresses_arr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': addresses_arr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Addresses:', addresses_output, ['Name', 'IP_Netmask', 'IP_Range', 'FQDN'], None, True),
            'EntryContext': {
                  "Panorama.Addresses(val.Name == obj.Name)": addresses_output
            }
        })


    def prettify_address(address):
        pretty_address = {
                'Name': address['@name'],
        }
        if 'description' in address:
            pretty_address['Description'] = address['description']

        if 'ip-netmask' in address:
            pretty_address['IP_Netmask'] = address['ip-netmask']

        if 'ip-range' in address:
            pretty_address['IP_Range'] = address['ip-range']

        if 'fqdn' in address:
            pretty_address['FQDN'] = address['fqdn']

        return pretty_address


    @logger
    def panorama_get_address(address_name):
        params = {
            'action': 'show',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address/entry[@name='" + address_name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_address_command():
        ''' Get an address '''
        address_name = demisto.args()['name']

        address = panorama_get_address(address_name)
        address_output = prettify_address(address)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': address,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Address:', address_output, ['Name', 'IP_Netmask', 'IP_Range', 'FQDN'], None, True),
            'EntryContext': {
                  "Panorama.Addresses(val.Name == obj.Name)": address_output
            }
        })


    @logger
    def panorama_create_address(address_name, fqdn = None, ip_netmask = None, ip_range = None, description = None):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address/entry[@name='" + address_name + "']",
            'key': API_KEY
        }
        params['element'] = add_argument(fqdn, 'fqdn', False) + add_argument(ip_netmask, 'ip-netmask', False)  + add_argument(ip_range, 'ip-range', False) + add_argument(description, 'description', False)
        result = http_request(
            URL,
            'POST',
            params = params,
        )


    def panorama_create_address_command():
        ''' Create an address object '''
        address_name = demisto.args()['name']
        description = demisto.args().get('description')

        fqdn = demisto.args().get('fqdn')
        ip_netmask = demisto.args().get('ip_netmask')
        ip_range = demisto.args().get('ip_range')

        if (not fqdn and not ip_netmask and not ip_range):
            return_error('Please specify exactly one of the following: fqdn, ip_netmask, ip_range')

        if ((fqdn and ip_netmask) or (fqdn and ip_range) or (ip_netmask and ip_range)):
            return_error('Please specify exactly one of the following: fqdn, ip_netmask, ip_range')

        address = panorama_create_address(address_name, fqdn, ip_netmask, ip_range, description)

        address_output = {'Name': address_name}
        if fqdn:
            address_output['FQDN'] = fqdn
        if ip_netmask:
            address_output['IP_Netmask'] = ip_netmask
        if ip_range:
            address_output['IP_Range'] = ip_range
        if description:
            address_output['Description'] = description

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': address,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Address was added successfully',
            'EntryContext': {
                  "Panorama.Addresses(val.Name == obj.Name)": address_output
            }
        })


    @logger
    def panorama_delete_address(address_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address/entry[@name='" + address_name + "']",
            'element': "<entry name='" + address_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_address_command():
        ''' Delete an address '''
        address_name = demisto.args()['name']

        address = panorama_delete_address(address_name)
        address_output = {'Name': address_name}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': address,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Address was deleted successfully',
            'EntryContext': {
                  "Panorama.Addresses(val.Name == obj.Name)": address_output
            }
        })


    ''' Address Group Commands '''
    def prettify_address_groups_arr(address_groups_arr):
        pretty_address_groups_arr = []
        for address_group in address_groups_arr:
            pretty_address_group = {
                'Name': address_group['@name'],
                'Type': 'static' if 'static'in address_group else 'dynamic',
            }
            if 'description' in address_group:
                pretty_address_group['Description'] = address_group['description']

            if pretty_address_group['Type'] == 'static':
                # static address groups can have empty lists
                if address_group['static']:
                    pretty_address_group['Addresses'] = address_group['static']['member']
            else:
                pretty_address_group['Match'] = address_group['dynamic']['filter']

            pretty_address_groups_arr.append(pretty_address_group)

        return pretty_address_groups_arr


    @logger
    def panorama_list_address_groups():
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address-group/entry",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_list_address_groups_command():
        ''' Get all address groups '''
        address_groups_arr = panorama_list_address_groups()
        address_groups_output = prettify_address_groups_arr(address_groups_arr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': address_groups_arr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Address groups:', address_groups_output, ['Name', 'Type', 'Addresses', 'Match', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.AddressGroups(val.Name == obj.Name)": address_groups_output
            }
        })


    def prettify_address_group(address_group):
        pretty_address_group = {
            'Name': address_group['@name'],
            'Type': 'static' if 'static'in address_group else 'dynamic',
        }

        if 'description' in address_group:
            pretty_address_group['Description'] = address_group['description']

        if pretty_address_group['Type'] == 'static':
            pretty_address_group['Addresses'] = address_group['static']['member']
        else:
            pretty_address_group['Match'] = address_group['dynamic']['filter']

        return pretty_address_group


    @logger
    def panorama_get_address_group(address_group_name):
        params = {
            'action': 'show',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_address_group_command():
        ''' Get an address group '''
        address_group_name = demisto.args()['name']

        result = panorama_get_address_group(address_group_name)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Address group:', prettify_address_group(result), ['Name', 'Type', 'Addresses', 'Match', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.AddressGroups(val.Name == obj.Name)": prettify_address_group(result)
            }
        })


    @logger
    def panorama_create_static_address_group(address_group_name, addresses, description = None):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']",
            'element': "<static>" + add_argument_list(addresses, 'member', True) + "</static>" + add_argument(description, 'description', False),
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )
        return result


    def panorama_create_dynamic_address_group(address_group_name, match, description = None):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']",
            'element': "<dynamic>" + add_argument(match, 'filter', False) + "</dynamic>" + add_argument(description, 'description', False),
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )
        return result


    def panorama_create_address_group_command():
        ''' Create an address group '''
        address_group_name = demisto.args()['name']
        typee = demisto.args()['type']
        description = demisto.args().get('description')
        match = demisto.args().get('match')
        addresses = argToList(demisto.args()['addresses']) if 'addresses' in demisto.args() else None
        if match and addresses:
                return_error('Please specify only one of the following: addresses, match')
        if typee == 'static':
            if not addresses:
                return_error('Please specify addresses in order to create a static address group')
        if typee == 'dynamic':
            if not match:
                return_error('Please specify a match in order to create a dynamic address group')

        if typee == 'static':
            result = panorama_create_static_address_group(address_group_name, addresses, description)
        else:
            result = panorama_create_dynamic_address_group(address_group_name, match, description)

        address_group_output = {
            'Name': address_group_name,
            'Type': typee
        }
        if match:
            address_group_output['Match'] = match
        if addresses:
            address_group_output['Addresses'] = addresses
        if description:
            address_group_output['Description'] = description

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Address group was created successfully',
            'EntryContext': {
                  "Panorama.AddressGroups(val.Name == obj.Name)": address_group_output
            }
        })


    @logger
    def panorama_delete_address_group(address_group_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']",
            'element': "<entry name='" + address_group_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_address_group_command():
        ''' Delete an address group '''
        address_group_name = demisto.args()['name']

        address_group = panorama_delete_address_group(address_group_name)
        address_group_output = {'Name': address_group_name}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': address_group,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Address group was deleted successfully',
            'EntryContext': {
                  "Panorama.AddressGroups(val.Name == obj.Name)": address_group_output
            }
        })


    def panorama_edit_address_group_command():
        ''' Edit an address group '''
        address_group_name = demisto.args()['name']
        typee = demisto.args()['type']
        match = demisto.args().get('match')
        element_to_add = argToList(demisto.args()['element_to_add']) if 'element_to_add' in demisto.args() else None
        element_to_remove = argToList(demisto.args()['element_to_remove']) if 'element_to_remove' in demisto.args() else None

        if (typee == 'dynamic'):
            if (not match):
                return_error('To edit a Dynamic Address group, Please provide a match')
            match_param = add_argument_open(match, 'filter', False)
            match_path = XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']/dynamic/filter",


        if (typee == 'static'):
            if ((element_to_add and element_to_remove) or (not element_to_add and not element_to_remove)):
                return_error('To edit a Static Address group, Please specify exactly one of the following: element_to_add, element_to_remove')
            address_group_prev = panorama_get_address_group(address_group_name)
            address_group_list = []
            if 'static' in address_group_prev:
                if address_group_prev['static']:
                    address_group_list = argToList(address_group_prev['static']['member'])
            if (element_to_add):
                addresses = list(set(element_to_add + address_group_list))
            else:
                addresses = [item for item in address_group_list if item not in element_to_remove]
            addresses_param = add_argument_list(addresses, 'member', False)
            addresses_path = XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']/static",

        description = demisto.args().get('description')
        description_param = add_argument_open(description, 'description', False)
        description_path = XPATH_OBJECTS + "address-group/entry[@name='" + address_group_name + "']/description",

        params = {
            'action': 'edit',
            'type': 'config',
            'key': API_KEY,
        }

        address_group_output = {'Name': address_group_name}

        if (match):
            params['xpath'] = match_path
            params['element'] = match_param
            result = http_request(URL, 'POST', params = params)
            address_group_output['Match'] = match
        if (addresses):
            params['xpath'] = addresses_path
            params['element'] = "<static>" + addresses_param + "</static>"
            result = http_request(URL, 'POST', params = params)
            address_group_output['Addresses'] = addresses
        if (description):
            params['xpath'] = description_path
            params['element'] = description_param
            result = http_request(URL, 'POST', params = params)
            address_group_output['Description'] = description

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Address Group was edited successfully',
            'EntryContext': {
                  "Panorama.AddressGroups(val.Name == obj.Name)": address_group_output
            }
        })


    ''' Services Commands '''
    def prettify_services_arr(services_arr):
        pretty_services_arr = []
        for service in services_arr:
            pretty_service = {
                'Name': service['@name'],
            }
            if 'description' in service:
                pretty_service['Description'] = service['description']

            protocol = ''
            if 'protocol' in service:
                if 'tcp' in service['protocol']:
                    protocol = 'tcp'
                elif 'udp' in service['protocol']:
                    protocol = 'udp'
                else:
                    protocol = 'sctp'
            pretty_service['Protocol'] = protocol

            if 'port' in service['protocol'][protocol]:
                pretty_service['DestinationPort'] = service['protocol'][protocol]['port']
            if 'source-port' in service['protocol'][protocol]:
                pretty_service['SourcePort'] = service['protocol'][protocol]['source-port']

            pretty_services_arr.append(pretty_service)

        return pretty_services_arr


    @logger
    def panorama_list_services():
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service/entry",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_list_services_command():
        ''' Get all Services '''
        services_arr = panorama_list_services()
        services_output = prettify_services_arr(services_arr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': services_arr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Services:', services_output, ['Name', 'Protocol', 'SourcePort', 'DestinationPort', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.Services(val.Name == obj.Name)": services_output
            }
        })


    def prettify_service(service):
        pretty_service = {
                'Name': service['@name'],
        }
        if 'description' in service:
            pretty_service['Description'] = service['description']

        protocol = ''
        if 'protocol' in service:
            if 'tcp' in service['protocol']:
                protocol = 'tcp'
            elif 'udp' in service['protocol']:
                protocol = 'udp'
            else:
                protocol = 'sctp'
        pretty_service['Protocol'] = protocol

        if 'port' in service['protocol'][protocol]:
            pretty_service['DestinationPort'] = service['protocol'][protocol]['port']
        if 'source-port' in service['protocol'][protocol]:
            pretty_service['SourcePort'] = service['protocol'][protocol]['source-port']

        return pretty_service


    @logger
    def panorama_get_service(service_name):
        params = {
            'action': 'show',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service/entry[@name='" + service_name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_service_command():
        ''' Get a service '''
        service_name = demisto.args()['name']

        service = panorama_get_service(service_name)
        service_output = prettify_service(service)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': service,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Address:', service_output, ['Name', 'Protocol', 'SourcePort', 'DestinationPort', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.Services(val.Name == obj.Name)": service_output
            }
        })


    @logger
    def panorama_create_service(service_name, protocol, destination_port, source_port = None, description = None):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service/entry[@name='" + service_name + "']",
            'key': API_KEY
        }
        params['element'] = '<protocol>' + '<' + protocol + '>' + add_argument(destination_port, 'port', False) + add_argument(source_port, 'source-port', False) + '</' + protocol + '>' + '</protocol>' + add_argument(description, 'description', False)

        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_create_service_command():
        ''' Create a service object '''
        service_name = demisto.args()['name']
        protocol = demisto.args()['protocol']
        destination_port = demisto.args()['destination_port']
        source_port = demisto.args().get('source_port')
        description = demisto.args().get('description')

        service = panorama_create_service(service_name, protocol, destination_port, source_port, description)

        service_output = {
            'Name': service_name,
            'Protocol': protocol,
            'DestinationPort': destination_port
        }
        if source_port:
            service_output['SourcePort'] = source_port
        if description:
            service_output['Description'] = description

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': service,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Service was added successfully',
            'EntryContext': {
                  "Panorama.Services(val.Name == obj.Name)": service_output
            }
        })


    @logger
    def panorama_delete_service(service_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service/entry[@name='" + service_name + "']",
            'element': "<entry name='" + service_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_service_command():
        ''' Delete a service '''
        service_name = demisto.args()['name']

        service = panorama_delete_service(service_name)
        service_output = {'Name': service_name}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': service,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Service was deleted successfully',
            'EntryContext': {
                  "Panorama.Services(val.Name == obj.Name)": service_output
            }
        })


    ''' Service Group Commands '''
    def prettify_service_groups_arr(service_groups_arr):
        pretty_service_groups_arr = []
        for service_group in service_groups_arr:
            pretty_service_group = {
                'Name': service_group['@name'],
                'Services': service_group['members']['member']
            }
            pretty_service_groups_arr.append(pretty_service_group)

        return pretty_service_groups_arr


    @logger
    def panorama_list_service_groups():
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service-group/entry",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_list_service_groups_command():
        ''' Get all address groups '''
        service_groups_arr = panorama_list_service_groups()
        service_groups_output = prettify_service_groups_arr(service_groups_arr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': service_groups_arr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Service groups:', service_groups_output, ['Name', 'Services'], None, True),
            'EntryContext': {
                  "Panorama.ServiceGroups(val.Name == obj.Name)": service_groups_output
            }
        })


    def prettify_service_group(service_group):
        pretty_service_group = {
            'Name': service_group['@name'],
            'Services': service_group['members']['member']
        }
        return pretty_service_group


    @logger
    def panorama_get_service_group(service_group_name):
        params = {
            'action': 'show',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service-group/entry[@name='" + service_group_name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_service_group_command():
        ''' Get an address group '''
        service_group_name = demisto.args()['name']

        result = panorama_get_service_group(service_group_name)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Service group:', prettify_service_group(result), ['Name', 'Services'], None, True),
            'EntryContext': {
                  "Panorama.ServiceGroups(val.Name == obj.Name)": prettify_service_group(result)
            }
        })


    def panorama_create_service_group(service_group_name, services):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service-group/entry[@name='" + service_group_name + "']",
            'element': '<members>' + add_argument_list(services, 'member', True) + '</members>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_create_service_group_command():
        ''' Create a service group '''
        service_group_name = demisto.args()['name']
        services = argToList(demisto.args()['services'])

        result = panorama_create_service_group(service_group_name, services)

        service_group_output = {
            'Name': service_group_name,
            'Services': services
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Service group was created successfully',
            'EntryContext': {
                  "Panorama.ServiceGroups(val.Name == obj.Name)": service_group_output
            }
        })


    @logger
    def panorama_delete_service_group(service_group_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service-group/entry[@name='" + service_group_name + "']",
            'element': "<entry name='" + service_group_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_service_group_command():
        ''' Delete a service group '''
        service_group_name = demisto.args()['name']

        service_group = panorama_delete_service_group(service_group_name)
        service_group_output = {'Name': service_group_name}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': service_group,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Service group was deleted successfully',
            'EntryContext': {
                  "Panorama.ServiceGroups(val.Name == obj.Name)": service_group_output
            }
        })


    @logger
    def panorama_edit_service_group(service_group_name, services):
        params = {
            'action': 'edit',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "service-group/entry[@name='" + service_group_name + "']/members",
            'element': '<members>' + add_argument_list(services, 'member', False) + '</members>',
            'key': API_KEY,
        }
        result = http_request(
            URL,
            'POST',
            params = params
        )

        return result


    def panorama_edit_service_group_command():
        ''' Edit a service group '''
        service_group_name = demisto.args()['name']
        services_to_add = argToList(demisto.args()['services_to_add']) if 'services_to_add' in demisto.args() else None
        services_to_remove = argToList(demisto.args()['services_to_remove']) if 'services_to_remove' in demisto.args() else None

        if (services_to_add and services_to_remove) or (not services_to_add and not services_to_remove):
            return_error('Specify exactly one of the following arguments: services_to_add, services_to_remove')

        service_group_prev = panorama_get_service_group(service_group_name)
        service_group_list = argToList(service_group_prev['members']['member'])

        if (services_to_add):
            services = list(set(services_to_add + service_group_list))
        else:
            services = [item for item in service_group_list if item not in services_to_remove]

        if (len(services) == 0):
            return_error ('A Service group must have at least one service')
        result = panorama_edit_service_group(service_group_name, services)

        service_group_output = {
            'Name': service_group_name,
            'Services': services
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Service group was edited successfully',
            'EntryContext': {
                  "Panorama.ServiceGroups(val.Name == obj.Name)": service_group_output
            }
        })


    ''' Custom URL Category Commands '''
    def prettify_custom_url_category(custom_url_category):
        pretty_custom_url_category = {
            'Name': custom_url_category['@name'],
        }

        if 'description' in custom_url_category:
            pretty_custom_url_category['Description'] = custom_url_category['description']

        if 'list' in custom_url_category:
            pretty_custom_url_category['Sites'] = custom_url_category['list']['member']

        return pretty_custom_url_category


    @logger
    def panorama_get_custom_url_category(name):
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/custom-url-category/entry[@name='" + name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_custom_url_category_command():
        ''' Get a custom url category'''
        name = demisto.args()['name']

        custom_url_category = panorama_get_custom_url_category(name)
        custom_url_category_output = prettify_custom_url_category(custom_url_category)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': custom_url_category,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Custom URL Category:', custom_url_category_output, ['Name', 'Sites', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.CustomURLCategory(val.Name == obj.Name)": custom_url_category_output
            }
        })


    @logger
    def panorama_create_custom_url_category(custom_url_category_name, sites = None, description = None):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/custom-url-category/entry[@name='" + custom_url_category_name + "']",
            'element': add_argument(description, 'description', False) + add_argument_list(sites, 'list', True),
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        custom_url_category_output = {'Name': custom_url_category_name}
        if sites:
            custom_url_category_output['Sites'] = sites
        if description:
            custom_url_category_output['Description'] = description

        return result, custom_url_category_output


    def panorama_create_custom_url_category_command():
        ''' Create a custom URL category '''
        custom_url_category_name = demisto.args()['name']
        sites = argToList(demisto.args()['sites']) if 'sites' in demisto.args() else None
        description = demisto.args().get('description')

        custom_url_category, custom_url_category_output = panorama_create_custom_url_category(custom_url_category_name, sites, description)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': custom_url_category,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Created Custom URL Category:', custom_url_category_output, ['Name', 'Sites', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.CustomURLCategory(val.Name == obj.Name)": custom_url_category_output
            }
        })


    @logger
    def panorama_delete_custom_url_category(custom_url_category_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/custom-url-category/entry[@name='" + custom_url_category_name + "']",
            'element': "<entry name='" + custom_url_category_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_custom_url_category_command():
        ''' Delete a custom url category '''
        custom_url_category_name = demisto.args()['name']

        result = panorama_delete_custom_url_category(custom_url_category_name)
        custom_url_category_output = {'Name': custom_url_category_name}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Custom URL category was deleted successfully',
            'EntryContext': {
                  "Panorama.CustomURLCategory(val.Name == obj.Name)": custom_url_category_output
            }
        })

    @logger
    def panorama_edit_custom_url_category(custom_url_category_name, sites, description = None):
        params = {
            'action': 'edit',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/custom-url-category/entry[@name='" + custom_url_category_name + "']",
            'element': "<entry name='" + custom_url_category_name + "'>" + add_argument(description, 'description', False) + add_argument_list(sites, 'list', True) + "</entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        custom_url_category_output = {'Name': custom_url_category_name}
        if sites:
            custom_url_category_output['Sites'] = sites
        if description:
            custom_url_category_output['Description'] = description

        return result, custom_url_category_output


    def panorama_custom_url_category_add_sites_command():
        ''' Add sites to a configured custom url category'''
        custom_url_category_name = demisto.args()['name']

        custom_url_category = panorama_get_custom_url_category(custom_url_category_name)

        description = custom_url_category.get('description')

        custom_url_category_sites = []
        if 'list' in custom_url_category:
            if custom_url_category['list']:
                custom_url_category_sites = argToList(custom_url_category['list']['member'])

        sites = argToList(demisto.args()['list'])
        merged_sites = list((set(sites)).union(set(custom_url_category_sites)))

        result, custom_url_category_output = panorama_edit_custom_url_category(custom_url_category_name, merged_sites, description)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Updated Custom URL Category:', custom_url_category_output, ['Name', 'Sites', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.CustomURLCategory(val.Name == obj.Name)": custom_url_category_output
            }
        })

    def panorama_custom_url_category_remove_sites_command():
        ''' Add sites to a configured custom url category'''
        custom_url_category_name = demisto.args()['name']

        custom_url_category = panorama_get_custom_url_category(custom_url_category_name)
        description = custom_url_category.get('description')

        custom_url_category_list = []
        if 'list' in custom_url_category:
            if 'member' in custom_url_category['list']:
                custom_url_category_sites = custom_url_category['list']['member']

        sites = argToList(demisto.args()['sites'])

        substructed_sites = [item for item in custom_url_category_lsites if item not in sites]
        result, custom_url_category_output = panorama_edit_custom_url_category(custom_url_category_name, substructed_sites, description)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Updated Custom URL Category:', custom_url_category_output, ['Name', 'Sites', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.CustomURLCategory(val.Name == obj.Name)": custom_url_category_output
            }
        })


    ''' URL Filtering '''
    @logger
    def panorama_get_url_category(url):
        params = {
            'action': 'show',
            'type': 'op',
            'key': API_KEY,
            'cmd': '<test><url>' + url + '</url></test>'
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        s = result['response']['result'].splitlines()[1]
        return s.split(' ')[1]


    def populate_url_filter_category_from_context(url_category_hr):
        url_filter_category = demisto.dt(demisto.context(), 'Panorama.URLFilter(val.Category === "{0}")'.format(url_category_hr['Category']))

        if not url_filter_category:
            url_filter_category = {
                'Category': url_category_hr['Category'],
                'URL': []
            }

        if type(url_filter_category) is dict:
            url_filter_category = [url_filter_category]

        url_filter_category[0]['URL'] += [url_category_hr['URL']]

        return url_filter_category


    def panorama_get_url_category_command():
        ''' Get the url category from Palo Alto URL Filtering '''
        url = demisto.args()['url']

        category = panorama_get_url_category(url)

        url_category_hr = {
            'URL': url,
            'Category': category
        }

        url_category_output = populate_url_filter_category_from_context(url_category_hr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': category,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('URL Filtering:', url_category_hr, ['URL', 'Category'], None, True),
            'EntryContext': {
                  "Panorama.URLFilter(val.Category === obj.Category)": url_category_output
            }
        })


    def prettify_get_url_filter(url_filter):
        pretty_url_filter = {'Name': url_filter['@name']}
        if 'description' in url_filter:
            pretty_url_filter['Description'] = url_filter['description']

        pretty_url_filter['Category'] = []
        url_category_list = []
        action = ''
        if 'alert' in url_filter:
            url_category_list = url_filter['alert']['member']
            action = 'alert'
        elif 'allow' in url_filter:
            url_category_list = url_filter['allow']['member']
            action = 'allow'
        elif 'block' in url_filter:
            url_category_list = url_filter['block']['member']
            action = 'block'
        elif 'continue' in url_filter:
            url_category_list = url_filter['continue']['member']
            action = 'continue'
        elif 'override' in url_filter:
            url_category_list = url_filter['override']['member']
            action = 'override'

        for category in url_category_list:
            pretty_url_filter['Category'].append({
                'Name': category,
                'Action': action
            })

        if 'allow-list' in url_filter or 'block-list' in url_filter:
            pretty_url_filter['Overrides'] = []
            if 'allow-list' in url_filter:
                pretty_url_filter['OverrideAllowList'] = url_filter['allow-list']['member']
            else:
                pretty_url_filter['OverrideBlockList'] = url_filter['block-list']['member']

        return pretty_url_filter

    @logger
    def panorama_get_url_filter(name):
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/url-filtering/entry[@name='" + name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_url_filter_command():
        ''' Get a URL Filter '''
        name = demisto.args()['name']

        url_filter = panorama_get_url_filter(name)

        url_filter_output = prettify_get_url_filter(url_filter)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': url_filter,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('URL Filter:', url_filter_output, ['Name', 'Category', 'OverrideAllowList', 'OverrideBlockList', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.URLFilter(val.Name == obj.Name)": url_filter_output
            }
        })


    @logger
    def panorama_create_url_filter(
        url_filter_name, action,
        url_category_list,
        override_allow_list = None,
        override_block_list = None,
        description = None):

        element = add_argument_list(url_category_list, action, True) + add_argument_list(override_allow_list, 'allow-list', True) + add_argument_list(override_block_list, 'block-list', True) + add_argument(description, 'description', False) + "<action>block</action>"

        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/url-filtering/entry[@name='" + url_filter_name + "']",
            'element': element,
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )
        return result


    def panorama_create_url_filter_command():
        ''' Create a URL Filter '''
        url_filter_name = demisto.args()['name']
        action = demisto.args()['action']
        url_category_list = argToList(demisto.args()['url_category'])
        override_allow_list = argToList(demisto.args().get('override_allow_list'))
        override_block_list = argToList(demisto.args().get('override_block_list'))
        description = demisto.args().get('description')

        result = panorama_create_url_filter(url_filter_name, action, url_category_list, override_allow_list, override_block_list, description)

        url_filter_output = {'Name': url_filter_name}
        url_filter_output['Category'] = []
        for category in url_category_list:
            url_filter_output['Category'].append({
                'Name': category,
                'Action': action
            })
        if override_allow_list:
            url_filter_output['OverrideAllowList'] = override_allow_list
        if override_block_list:
            url_filter_output['OverrideBlockList'] = override_block_list
        if description:
            url_filter_output['Description'] = description

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'URL Filter was created successfully',
            'EntryContext': {
                  "Panorama.URLFilter(val.Name == obj.Name)": url_filter_output
            }
        })


    @logger
    def panorama_edit_url_filter(url_filter_name, element_to_change, element_value, add_remove_element = None):

        url_filter_prev = panorama_get_url_filter(url_filter_name)
        if '@dirtyId' in url_filter_prev:
            return_error('Please commit the instance prior to editing the URL Filter')

        url_filter_output = {'Name': url_filter_name}
        params = {
            'action': 'edit',
            'type': 'config',
            'key': API_KEY,
        }

        if element_to_change == 'description':
            params['xpath'] = XPATH_OBJECTS + "profiles/url-filtering/entry[@name='" + url_filter_name + "']/" + element_to_change
            params['element'] = add_argument_open(element_value, 'description', False)
            result = http_request(URL, 'POST', params = params)
            url_filter_output['Description'] = element_value

        elif element_to_change == 'override_allow_list':
            prev_override_allow_list = argToList(url_filter_prev['allow-list']['member'])
            if add_remove_element == 'add':
                new_override_allow_list = list((set(prev_override_allow_list)).union(set([element_value])))
            else:
                new_override_allow_list = [url for url in prev_override_allow_list if url != element_value]

            params['xpath'] = XPATH_OBJECTS + "profiles/url-filtering/entry[@name='" + url_filter_name + "']/allow-list"
            params['element'] = add_argument_list(new_override_allow_list, 'allow-list', True)
            result = http_request(URL, 'POST', params = params)
            url_filter_output[element_to_change] = new_override_allow_list

        # element_to_change == 'override_block_list'
        else:
            prev_override_block_list = argToList(url_filter_prev['block-list']['member'])
            if add_remove_element == 'add':
                new_override_block_list = list((set(prev_override_block_list)).union(set([element_value])))
            else:
                new_override_block_list = [url for url in prev_override_block_list if url != element_value]

            params['xpath'] = XPATH_OBJECTS + "profiles/url-filtering/entry[@name='" + url_filter_name + "']/block-list"
            params['element'] = add_argument_list(new_override_block_list, 'block-list', True)
            result = http_request(URL, 'POST', params = params)
            url_filter_output[element_to_change] = new_override_block_list

        return result, url_filter_output


    def panorama_edit_url_filter_command():
        ''' Edit a URL Filter '''
        url_filter_name = demisto.args()['name']
        element_to_change = demisto.args()['element_to_change']
        add_remove_element = demisto.args()['add_remove_element']
        element_value = demisto.args()['element_value']

        result, url_filter_output = panorama_edit_url_filter(url_filter_name, element_to_change, element_value, add_remove_element)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'URL Filter was edited successfully',
            'EntryContext': {
                  "Panorama.URLFilter(val.Name == obj.Name)": url_filter_output
            }
        })


    @logger
    def panorama_delete_url_filter(url_filter_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "profiles/url-filtering/entry[@name='" + url_filter_name + "']",
            'element': "<entry name='" + url_filter_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_url_filter_command():
        ''' Delete a custom url category '''
        url_filter_name = demisto.args()['name']
        result = panorama_delete_url_filter(url_filter_name)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'URL Filter was deleted successfully',
        })


    ''' Security Rules Managing '''
    @logger
    def panorama_move_rule_command():
        ''' Move a security rule'''
        rulename = demisto.args()['rulename']
        params = {
            'type': 'config',
            'action': 'move',
            'key': API_KEY,
            'where': demisto.args()['where'],
        }

        if DEVICE_GROUP:
            if 'pre_post' not in demisto.args():
                return_error('Please provide the pre_post argument when moving a rule in Panorama instance.')
            else:
                params['xpath'] = XPATH_SECURITY_RULES + demisto.args()['pre_post'] + '/security/rules/entry' + '[@name=\'' + rulename + '\']'
        else:
            params['xpath'] = XPATH_SECURITY_RULES + '[@name=\'' + rulename + '\']'

        if 'dst' in demisto.args():
            params['dst'] = demisto.args()['dst']

        result = http_request(URL, 'POST', params = params)
        rule_output = {'Name': rulename}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Rule ' + rulename + ' moved successfully',
            'EntryContext': {
                  "Panorama.SecurityRule(val.Name == obj.Name)": rule_output
            }
        })


    ''' Security Rule Configuration '''
    @logger
    def panorama_create_rule_command():
        ''' Create a security rule '''
        rulename =  demisto.args()['rulename'] if 'rulename' in demisto.args() else ('demisto-' + (str(uuid.uuid4()))[:8])
        source =  demisto.args().get('source')
        destination =  demisto.args().get('destination')
        negate_source = demisto.args().get('negate_source')
        negate_destination = demisto.args().get('negate_destination')
        action =  demisto.args().get('action')
        service =  demisto.args().get('service')
        disable =  demisto.args().get('disable')
        application = demisto.args().get('application')
        source_user = demisto.args().get('source_user')
        disable_server_response_inspection = demisto.args().get('disable_server_response_inspection')
        description = demisto.args().get('description')
        target = demisto.args().get('target')
        if not DEVICE_GROUP and target:
            return_error('The target argument is only relevant for a Palo Alto Panorama instance.')

        params = prepare_security_rule_params(api_action= 'set', rulename = rulename, source = source, destination = destination,
                    negate_source = negate_source, negate_destination = negate_destination, action = action, service = service,
                    disable = disable, application = application, source_user = source_user,
                    disable_server_response_inspection = disable_server_response_inspection,
                    description = description, target = target)
        result = http_request(
            URL,
            'POST',
            params = params
        )

        rule_output = {SECURITY_RULE_ARGS[key] : value for key, value in demisto.args().items() if key in SECURITY_RULE_ARGS}
        rule_output['Name'] = rulename

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Rule configured successfully',
            'EntryContext': {
                  "Panorama.SecurityRule(val.Name == obj.Name)": rule_output
            }
        })


    @logger
    def panorama_edit_rule_command():
        ''' Edit a security rule '''
        rulename =  demisto.args()['rulename']
        element_to_change = demisto.args()['element_to_change']
        element_value = demisto.args()['element_value']
        target = demisto.args().get('target')
        if not DEVICE_GROUP and target:
            return_error('The target argument is only relevant for a Palo Alto Panorama instance.')

        params = {
            'type': 'config',
            'action': 'edit',
            'key': API_KEY
        }
        if element_to_change in ['action', 'description']:
            params['element'] = add_argument_open(element_value, element_to_change, False)
        elif element_to_change in ['source', 'destination', 'application', 'categry', 'source-user', 'service']:
            params['element'] = add_argument_open(element_value, element_to_change, True)
        else:
            # element_to_change in ['negate_source', 'negate_destination', 'disable']
            params['element'] = add_argument_yes_no(element_value, element_to_change)

        if target:
            params['element'] += add_argument_target(target, 'target')

        if DEVICE_GROUP:
            if 'pre_post' not in demisto.args():
                return_error('please provide the pre_post argument when moving a rule in Panorama instance.')
            else:
                params['xpath'] = XPATH_SECURITY_RULES + demisto.args()['pre_post'] + '/security/rules/entry' + '[@name=\'' + rulename + '\']'
        else:
            params['xpath'] = XPATH_SECURITY_RULES + '[@name=\'' + rulename + '\']'

        params['xpath'] = params['xpath'] + '/' + element_to_change

        result = http_request(
            URL,
            'POST',
            params = params
        )
        rule_output = {'Name': rulename}
        rule_output[SECURITY_RULE_ARGS[element_to_change]] = element_value

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Rule editted successfully',
            'EntryContext': {
                  "Panorama.SecurityRule(val.Name == obj.Name)": rule_output
            }
        })


    @logger
    def panorama_delete_rule_command():
        ''' Delete a security rule '''
        rulename =  demisto.args()['rulename']

        params = {
            'type': 'config',
            'action': 'delete',
            'key': API_KEY
        }
        if DEVICE_GROUP:
            if 'pre_post' not in demisto.args():
                return_error('Please provide the pre_post argument when moving a rule in Panorama instance.')
            else:
                params['xpath'] = XPATH_SECURITY_RULES + demisto.args()['pre_post'] + '/security/rules/entry' + '[@name=\'' + rulename + '\']'
        else:
            params['xpath'] = XPATH_SECURITY_RULES + '[@name=\'' + rulename + '\']'

        result = http_request(
            URL,
            'POST',
            params = params
        )

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Rule deleted successfully',
        })


    @logger
    def panorama_custom_block_rule_command():
        ''' Block an object in Panorama '''
        object_type = demisto.args()['object_type']
        object_value = demisto.args()['object_value']
        direction = demisto.args()['direction'] if 'direction' in demisto.args() else 'both'
        rulename =  demisto.args()['rulename'] if 'rulename' in demisto.args() else ('demisto-' + (str(uuid.uuid4()))[:8])
        block_destination = False if direction == 'from' else True
        block_source =  False if direction == 'to' else True
        target = demisto.args().get('target')
        if target and not DEVICE_GROUP:
            return_error('The target argument is relevant only for a Palo Alto Panorama instance.')

        custom_block_output = {
            'Name': rulename,
            'Direction': direction,
            'Disabled': False
        }

        if object_type == 'ip':
            if block_source:
                params = prepare_security_rule_params(api_action= 'set', action = 'drop', source = object_value, destination = 'any', rulename = rulename + '-from', target = target)
                result = http_request(URL, 'POST', params = params)
            if block_destination:
                params = prepare_security_rule_params(api_action= 'set', action = 'drop', destination = object_value, source = 'any', rulename = rulename + '-to', target = target)
                result = http_request(URL, 'POST', params = params)
            custom_block_output['IP'] = object_value

        elif object_type == 'address-group':
            if block_source:
                params = prepare_security_rule_params(api_action= 'set', action = 'drop', source = object_value, destination = 'any', rulename = rulename + '-from', target = target)
                result = http_request(URL, 'POST', params = params)
            if block_destination:
                params = prepare_security_rule_params(api_action= 'set', action = 'drop', destination = object_value, source = 'any', rulename = rulename + '-to', target = target)
                result = http_request(URL, 'POST', params = params)
            custom_block_output['AddressGroup'] = object_value

        elif object_type == 'url-category':
            params = prepare_security_rule_params(api_action= 'set', action = 'drop', source = 'any', destination = 'any', category = object_value, rulename = rulename, target = target)
            result = http_request(URL, 'POST', params = params)
            custom_block_output['CustomURLCategory'] = object_value

        elif object_type == 'application':
                params = prepare_security_rule_params(api_action= 'set', action = 'drop', source = 'any', destination = 'any', application = object_value, rulename = rulename, target = target)
                result = http_request(URL, 'POST', params = params)
                custom_block_output['Application'] = object_value

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Object was blocked successfully',
            'EntryContext': {
                  "Panorama.SecurityRule(val.Name == obj.Name)": custom_block_output
            }
        })


    ''' PCAPS '''
    @logger
    def panorama_list_pcaps_command():
        ''' Get list of pcap files '''
        params = {
            'type': 'export',
            'key': API_KEY,
            'category': demisto.args()['pcapType']
        }

        if 'password' in demisto.args():
            params['dlp-password'] = demisto.args()['password']
        elif demisto.args()['pcapType'] == 'dlp-pcap':
            return_error('can not provide dlp-pcap without password')


        result = http_request(URL, 'GET', params = params)

        jresult = json.loads(xml2json(result.text))['response']
        if jresult['@status'] != 'success':
            return_error('Request to get list of Pcaps Failed.\nStatus code: ' + str(jresult['response']['@code']) + '\nWith message: ' + str(jresult['response']['msg']['line']))

        pcap_list = jresult['result']['dir-listing']['file']
        pcap_list = [pcap[1:] for pcap in pcap_list]

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': jresult,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('List of Pcaps:', pcap_list, ['Pcap name']),
            'EntryContext': {
                  "Panorama.Pcaps(val.Name == obj.Name)": pcap_list
            }
        })


    @logger
    def panorama_get_pcap_command():
        ''' Get pcap file '''
        params = {
            'type': 'export',
            'key': API_KEY,
            'category': demisto.args()['pcapType']
        }

        if 'password' in demisto.args():
            params['dlp-password'] = demisto.args()['password']
        elif demisto.args()['pcapType'] == 'dlp-pcap':
            return_error('can not provide dlp-pcap without password')

        if 'pcapID' in demisto.args():
            params['pcap-id'] = demisto.args()['pcapID']
        elif demisto.args()['pcapType'] == 'threat-pcap':
            return_error('can not provide threat-pcap without pcap-id')

        pcap_name = demisto.args().get('from')
        localName = demisto.args().get('localName')
        serialno = demisto.args().get('serialNo')
        search_time = demisto.args().get('searchTime')

        file_name = None
        if (pcap_name):
            params['from'] = pcap_name
            file_name = pcap_name
        if (localName):
            params['to'] = localName
            file_name = localName
        if (serialno):
            params['serialno'] = serialno
        if (search_time):
            params['search-time'] = search_time

        # set file name to the current time if from/to were not specified
        if not file_name:
            file_name = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S')

        result = http_request(URL, 'GET', params = params)

        # due pcap file size limitation in the product, for more details, please see the documentation.
        if result.headers['Content-Type'] != 'application/octet-stream':
            return_error('PCAP download failed. Most likely cause is the file size limitation. For information on how to download manually, see the documentation for this integration.')

        file = fileResult(file_name + ".pcap", result.content)
        demisto.results(file)


    ''' Applications '''
    def prettify_applications_arr(applications_arr):
        pretty_application_arr = []
        for i in range (len(applications_arr)):
            application = applications_arr[i]
            pretty_application_arr.append({
                'SubCategory': application['subcategory'],
                'Risk': application['risk'],
                'Technology': application['technology'],
                'Name': application['@name'],
                'Description': application['description'],
                'Id': application['@id']
            })
        return pretty_application_arr;


    @logger
    def panorama_list_applications():
        params = {
            'type': 'op',
            'command': '<show><objects></objects></show>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params
        )
        return result['response']['result']['config']['shared']['content-preview']['application']['entry']


    def panorama_list_applications_command():
        ''' List all applications '''
        applications_arr = panorama_list_applications()

        applications_arr_output = prettify_applications_arr(applications_arr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': applications_arr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Applications', applications_arr_output, ['Name', 'Id', 'Risk', 'Category', 'SubCategory', 'Technology', 'Description']),
            'EntryContext': {
                  "Panorama.Applications(val.Id == obj.Id)": applications_arr_output
            }
        })


    ''' External Dynamic Lists Commands '''
    def prettify_edls_arr(edls_arr):
        pretty_edls_arr = []
        if not isinstance(edls_arr, list): # handle case of only one edl in the instance
            return prettify_edl(edls_arr)
        for edl in edls_arr:
            pretty_edl = {
                'Name': edl['@name'],
                'Type': ''.join(edl['type'].keys())
            }
            edl_type = pretty_edl['Type']

            if edl['type'][edl_type]:
                if 'url' in edl['type'][edl_type]:
                    pretty_edl['URL'] = edl['type'][edl_type]['url']
                if 'certificate-profile' in edl['type'][edl_type]:
                    pretty_edl['CertificateProfile'] = edl['type'][edl_type]['certificate-profile']
                if 'recurring' in edl['type'][edl_type]:
                    pretty_edl['Recurring'] = ''.join(edl['type'][edl_type]['recurring'].keys())
                if 'description' in edl['type'][edl_type]:
                    pretty_edl['Description'] = edl['type'][edl_type]['description']

            pretty_edls_arr.append(pretty_edl)

        return pretty_edls_arr


    @logger
    def panorama_list_edls():
        params = {
            'action': 'get',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "external-list/entry",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )
        return result['response']['result']['entry']


    def panorama_list_edls_command():
        ''' Get all EDLs '''
        edls_arr = panorama_list_edls()
        edls_output = prettify_edls_arr(edls_arr)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': edls_arr,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('External Dynamic Lists:', edls_output, ['Name', 'Type', 'URL', 'Recurring', 'CertificateProfile', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.EDL(val.Name == obj.Name)": edls_output
            }
        })


    def prettify_edl(edl):
        pretty_edl = {
            'Name': edl['@name'],
            'Type': ''.join(edl['type'].keys())
        }
        edl_type = pretty_edl['Type']

        if edl['type'][edl_type]:
            if 'url' in edl['type'][edl_type]:
                pretty_edl['URL'] = edl['type'][edl_type]['url']
            if 'certificate-profile' in edl['type'][edl_type]:
                pretty_edl['CertificateProfile'] = edl['type'][edl_type]['certificate-profile']
            if 'recurring' in edl['type'][edl_type]:
                pretty_edl['Recurring'] = ''.join(edl['type'][edl_type]['recurring'].keys())
            if 'description' in edl['type'][edl_type]:
                pretty_edl['Description'] = edl['type'][edl_type]['description']

        return pretty_edl


    @logger
    def panorama_get_edl(edl_name):
        params = {
            'action': 'show',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "external-list/entry[@name='" + edl_name + "']",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'GET',
            params = params,
        )

        return result['response']['result']['entry']


    def panorama_get_edl_command():
        ''' Get an EDL '''
        edl_name = demisto.args()['name']
        edl = panorama_get_edl(edl_name)
        edl_output = prettify_edl(edl)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': edl,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('External Dynamic List:', edl_output, ['Name', 'Type', 'URL', 'Recurring', 'CertificateProfile', 'Description'], None, True),
            'EntryContext': {
                  "Panorama.EDL(val.Name == obj.Name)": edl_output
            }
        })


    @logger
    def panorama_create_edl(edl_name, url, type_, recurring, certificate_profile = None, description = None):
        params = {
            'action': 'set',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "external-list/entry[@name='" + edl_name + "']/type/" + type_,
            'key': API_KEY
        }
        params['element'] = add_argument(url, 'url', False) + '<recurring><' + recurring + '/></recurring>' + add_argument(certificate_profile, 'certificate-profile', False) + add_argument(description, 'description', False)
        result = http_request(
            URL,
            'POST',
            params = params,
        )
        return result


    def panorama_create_edl_command():
        ''' Create an edl object '''
        edl_name = demisto.args().get('name')
        url = demisto.args().get('url')
        type_ = demisto.args().get('type')
        recurring = demisto.args().get('recurring')
        certificate_profile = demisto.args().get('certificate_profile')
        description = demisto.args().get('description')

        edl = panorama_create_edl(edl_name, url, type_, recurring, certificate_profile, description)

        edl_output = {
            'Name': edl_name,
            'URL': url,
            'Type': type_,
            'Recurring': recurring
        }
        if description:
            edl_output['Description'] = description
        if certificate_profile:
            edl_output['CertificateProfile'] = certificate_profile

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': edl,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'EXternal Dynamic List was added successfully',
            'EntryContext': {
                  "Panorama.EDL(val.Name == obj.Name)": edl_output
            }
        })


    @logger
    def panorama_edit_edl(edl_name, element_to_change, element_value):

        edl_prev = panorama_get_edl(edl_name)
        if '@dirtyId' in edl_prev:
            return_error('Please commit the instance prior to editing the External Dynamic List')
        edl_type = ''.join(edl_prev['type'].keys())
        edl_output = {'Name': edl_name}
        params = {
            'action': 'edit',
            'type': 'config',
            'key': API_KEY,
            'xpath': XPATH_OBJECTS + "external-list/entry[@name='" + edl_name + "']/type/" + edl_type + "/" + element_to_change
        }

        if element_to_change == 'url':
            params['element'] = add_argument_open(element_value, 'url', False)
            result = http_request(URL, 'POST', params = params)
            edl_output['URL'] = element_value

        elif element_to_change == 'certificate_profile':
            params['element'] = add_argument_open(element_value, 'certificate-profile', False)
            result = http_request(URL, 'POST', params = params)
            edl_output['CertificateProfile'] = element_value

        elif element_to_change == 'description':
            params['element'] = add_argument_open(element_value, 'description', False)
            result = http_request(URL, 'POST', params = params)
            edl_output['Description'] = element_value

        # element_to_change == 'recurring'
        else:
            if element_value not in ['five-minute', 'hourly']:
                return_error('Recurring segment must be five-minute or hourly')
            params['element'] = '<recurring><' + element_value + '/></recurring>'
            result = http_request(URL, 'POST', params = params)
            edl_output['Recurring'] = element_value

        return result, edl_output


    def panorama_edit_edl_command():
        ''' Edit an EDL '''
        edl_name = demisto.args()['name']
        element_to_change = demisto.args()['element_to_change']
        element_value = demisto.args()['element_value']

        result, edl_output = panorama_edit_edl(edl_name, element_to_change, element_value)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'External Dynamic List was editted successfully',
            'EntryContext': {
                  "Panorama.EDL(val.Name == obj.Name)": edl_output
            }
        })


    @logger
    def panorama_delete_edl(edl_name):
        params = {
            'action': 'delete',
            'type': 'config',
            'xpath': XPATH_OBJECTS + "external-list/entry[@name='" + edl_name + "']",
            'element': "<entry name='" + edl_name + "'></entry>",
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_delete_edl_command():
        ''' Delete an EDL '''
        edl_name = demisto.args()['name']

        edl = panorama_delete_edl(edl_name)
        edl_output = {'Name': edl_name}

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': edl,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'External Dynamic List was deleted successfully',
            'EntryContext': {
                  "Panorama.EDL(val.Name == obj.Name)": edl_output
            }
        })


    def panorama_refresh_edl(edl_name):
        edl = panorama_get_edl(edl_name)
        edl_type = ''.join(edl['type'].keys())

        params = {
            'type': 'op',
            'cmd': '<request><system><external-list><refresh><type><' + edl_type + '><name>' + edl_name + '</name></' + edl_type + '></type></refresh></external-list></system></request>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_refresh_edl_command():
        ''' Refresh an EDL '''
        edl_name = demisto.args()['name']

        result = panorama_refresh_edl(edl_name)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Refreshed External Dynamic List successfully',
        })


    @logger
    def panorama_register_ip_tag(tag, ips, persistent):
        entry = ''
        for ip in ips:
            entry += '<entry ip=\"' + ip + '\" persistent=\"' + persistent + '\"><tag><member>' + tag + '</member></tag></entry>'

        params = {
            'type': 'user-id',
            'cmd': '<uid-message><version>2.0</version><type>update</type><payload><register>' + entry + '</register></payload></uid-message>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_register_ip_tag_command():
        ''' Register IPs to a Tag '''
        tag = demisto.args()['tag']
        ips = argToList(demisto.args()['IPs'])

        persistent = demisto.args()['persistent'] if 'persistent' in demisto.args() else 'true'
        persistent = '1' if persistent == 'true' else '0'

        result = panorama_register_ip_tag(tag, ips, persistent)

        registered_ip = {}
        # update context only if IPs are persistent
        if persistent == '1':
            # get existing IPs for this tag
            context_ips = demisto.dt(demisto.context(), 'Panorama.DynamicTags(val.Tag ==\"' + tag + '\").IPs')

            if (context_ips):
                all_ips = ips + context_ips
            else:
                all_ips = ips

            registered_ip = {
                'Tag': tag,
                'IPs': all_ips
            }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Registered ip-tag successfully',
            'EntryContext': {
                "Panorama.DynamicTags(val.Tag == obj.Tag)": registered_ip
            }
        })


    @logger
    def panorama_unregister_ip_tag(tag, ips):
        entry = ''
        for ip in ips:
            entry += '<entry ip=\"' + ip + '\"><tag><member>' + tag + '</member></tag></entry>'

        params = {
            'type': 'user-id',
            'cmd': '<uid-message><version>2.0</version><type>update</type><payload><unregister>' + entry + '</unregister></payload></uid-message>',
            'key': API_KEY
        }
        result = http_request(
            URL,
            'POST',
            params = params,
        )

        return result


    def panorama_unregister_ip_tag_command():
        ''' Register IPs to a Tag '''
        tag = demisto.args()['tag']
        ips = argToList(demisto.args()['IPs'])

        result = panorama_unregister_ip_tag(tag, ips)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': result,
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Unregistered ip-tag successfully'
        })


    ''' EXECUTION '''
    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-module':
            panorama_test()

        elif demisto.command() == 'panorama':
            panorama_command()

        elif demisto.command() == 'panorama-commit':
            panorama_commit_command()

        elif demisto.command() == 'panorama-commit-status':
            panorama_commit_status_command()

        elif demisto.command() == 'panorama-push-to-device-group':
            panorama_push_to_device_group_command()

        elif demisto.command() == 'panorama-push-status':
            panorama_push_status_command()

        # Addresses commands
        elif demisto.command() == 'panorama-list-addresses':
            panorama_list_addresses_command()

        elif demisto.command() == 'panorama-get-address':
            panorama_get_address_command()

        elif demisto.command() == 'panorama-create-address':
            panorama_create_address_command()

        elif demisto.command() == 'panorama-delete-address':
            panorama_delete_address_command()

        # Address groups commands
        elif demisto.command() == 'panorama-list-address-groups':
            panorama_list_address_groups_command()

        elif demisto.command() == 'panorama-get-address-group':
            panorama_get_address_group_command()

        elif demisto.command() == 'panorama-create-address-group':
            panorama_create_address_group_command()

        elif demisto.command() == 'panorama-delete-address-group':
            panorama_delete_address_group_command()

        elif demisto.command() == 'panorama-edit-address-group':
            panorama_edit_address_group_command()

        # Services commands
        elif demisto.command() == 'panorama-list-services':
            panorama_list_services_command()

        elif demisto.command() == 'panorama-get-service':
            panorama_get_service_command()

        elif demisto.command() == 'panorama-create-service':
            panorama_create_service_command()

        elif demisto.command() == 'panorama-delete-service':
            panorama_delete_service_command()

        # Service groups commands
        elif demisto.command() == 'panorama-list-service-groups':
            panorama_list_service_groups_command()

        elif demisto.command() == 'panorama-get-service-group':
            panorama_get_service_group_command()

        elif demisto.command() == 'panorama-create-service-group':
            panorama_create_service_group_command()

        elif demisto.command() == 'panorama-delete-service-group':
            panorama_delete_service_group_command()

        elif demisto.command() == 'panorama-edit-service-group':
            panorama_edit_service_group_command()

        # Custom Url Category commands
        elif demisto.command() == 'panorama-get-custom-url-category':
            panorama_get_custom_url_category_command()

        elif demisto.command() == 'panorama-create-custom-url-category':
            panorama_create_custom_url_category_command()

        elif demisto.command() == 'panorama-delete-custom-url-category':
            panorama_delete_custom_url_category_command()

        elif demisto.command() == 'panorama-edit-custom-url-category':
            if demisto.args()['action'] == 'remove':
                panorama_custom_url_category_remove_sites_command()
            else:
                panorama_custom_url_category_add_sites_command()

        # URL Filtering capabilities
        elif demisto.command() == 'panorama-get-url-category':
            panorama_get_url_category_command()

        elif demisto.command() == 'panorama-get-url-filter':
            panorama_get_url_filter_command()

        elif demisto.command() == 'panorama-create-url-filter':
            panorama_create_url_filter_command()

        elif demisto.command() == 'panorama-edit-url-filter':
            panorama_edit_url_filter_command()

        elif demisto.command() == 'panorama-delete-url-filter':
            panorama_delete_url_filter_command()

        # EDL
        elif demisto.command() == 'panorama-list-edls':
            panorama_list_edls_command()

        elif demisto.command() == 'panorama-get-edl':
            panorama_get_edl_command()

        elif demisto.command() == 'panorama-create-edl':
            panorama_create_edl_command()

        elif demisto.command() == 'panorama-edit-edl':
            panorama_edit_edl_command()

        elif demisto.command() == 'panorama-delete-edl':
            panorama_delete_edl_command()

        elif demisto.command() == 'panorama-refresh-edl':
            panorama_refresh_edl_command()

        # Registered IPs
        elif demisto.command() == 'panorama-register-ip-tag':
            panorama_register_ip_tag_command()

        elif demisto.command() == 'panorama-unregister-ip-tag':
            panorama_unregister_ip_tag_command()

        # Security Rules Managing
        elif demisto.command() == 'panorama-move-rule':
            panorama_move_rule_command()

        # Security Rules Configuration
        elif demisto.command() == 'panorama-create-rule':
            panorama_create_rule_command()

        elif demisto.command() == 'panorama-custom-block-rule':
            panorama_custom_block_rule_command()

        elif demisto.command() == 'panorama-edit-rule':
            panorama_edit_rule_command()

        elif demisto.command() == 'panorama-delete-rule':
            panorama_delete_rule_command()

        # Pcaps
        elif demisto.command() == 'panorama-list-pcaps':
            panorama_list_pcaps_command()

        elif demisto.command() == 'panorama-get-pcap':
            panorama_get_pcap_command()

        # Application
        elif demisto.command() == 'panorama-list-applications':
            panorama_list_applications_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
  type: python
  commands:
  - name: panorama
    arguments:
    - name: action
      auto: PREDEFINED
      predefined:
      - set
      - edit
      - delete
      - rename
      - clone
      - move
      - override
      - muti-move
      - multi-clone
      - complete
      - show
      - get
      description: Choose an available  action(show, get, set, edit, delete, rename,
        clone, move, override)
    - name: category
      description: Category parameter. e.g. when exporting a configuration file use
        category=configuration
    - name: cmd
      description: Used for operations commands cmd specifies the xml struct that
        defines the command.
    - name: command
      description: Run a command. e.g. command =<show><arp><entry name='all'/></arp></show>
    - name: dst
      description: Specifies destination
    - name: element
      description: Used to define a new value for an object
    - name: to
      description: To parameter (used in specifying time and when cloning an object)
    - name: from
      description: From parameter (used in specifying time and when cloning an object)
    - name: key
      description: Sets a key value
    - name: log-type
      description: Used for retrieving logs. e.g. log-type=threat for threat logs
    - name: where
      description: Specifies the type of a move operation (e.g. where=after, where=before,
        where=top, where=bottom)
    - name: period
      description: Describe a time period. E.g. period=last-24-hrs
    - name: xpath
      description: Defines a location e.g. xpath=/config/predefined/application/entry[@name='hotmail']
    - name: pcap-id
      description: The threat pcap ID in the threat log
    - name: serialno
      description: Specifies the device serial number
    - name: reporttype
      description: Choose dynamic, predefined or custom report
    - name: reportname
      description: The report name
    - name: type
      description: The request type (e.g. export, import, log, config)
      defaultValue: keygen,config,commit,op,report,log,import,export,user-id,version
    - name: search-time
      description: Used for threat PCAPs, the time that the PCAP was received on the
        firewall.
    - name: target
      description: target number of the firewall. use only on Panorama instance
    description: Run any command supported in the API
  - name: panorama-commit
    arguments: []
    outputs:
    - contextPath: Panorama.Commit.JobID
      description: Job ID of the configuration to be committed
      type: number
    - contextPath: Panorama.Commit.Status
      description: Commit status
      type: string
    description: Commits a configuration to Palo Alto Firewall or Panorama, but does
      not validate if the commit was successful. Commiting to Panorama will not push
      the configuration to the Firewalls. To push the configuration, run the panorama-push-to-device-group
      command.
  - name: panorama-push-to-device-group
    arguments: []
    outputs:
    - contextPath: Panorama.Push.DeviceGroup
      description: Device group the policies were pushed into
      type: string
    - contextPath: Panorama.Push.JobID
      description: Job ID of the configuration to be pushed
      type: number
    - contextPath: Panorama.Push.Status
      description: Push status
      type: string
    description: Pushes rules from Palo Alto Panorama to the configured device group
  - name: panorama-list-addresses
    arguments: []
    outputs:
    - contextPath: Panorama.Addresses.Name
      description: Address name
      type: string
    - contextPath: Panorama.Addresses.Description
      description: Address description
      type: string
    - contextPath: Panorama.Addresses.FQDN
      description: Address fqdn
      type: string
    - contextPath: Panorama.Addresses.IP_Netmask
      description: Address IP netmask
      type: string
    - contextPath: Panorama.Addresses.IP_Range
      description: Address IP range
      type: string
    description: Returns a list of addresses
  - name: panorama-get-address
    arguments:
    - name: name
      required: true
      description: Address name
    outputs:
    - contextPath: Panorama.Addresses.Name
      description: Address name
      type: string
    - contextPath: Panorama.Addresses.Description
      description: Address description
      type: string
    - contextPath: Panorama.Addresses.FQDN
      description: Address fqdn
      type: string
    - contextPath: Panorama.Addresses.IP_Netmask
      description: Address IP netmask
      type: string
    - contextPath: Panorama.Addresses.IP_Range
      description: Address IP range
      type: string
    description: Returns address details for the supplied address name
  - name: panorama-create-address
    arguments:
    - name: name
      required: true
      description: Name for the new address
    - name: description
      description: A description of the new address
    - name: fqdn
      description: FQDN of the new address
    - name: ip_netmask
      description: IP netmask of the new address, e.g., 10.10.10.10/24
    - name: ip_range
      description: IP range of the new address, e.g., 10.10.10.0-10.10.10.255
    outputs:
    - contextPath: Panorama.Addresses.Name
      description: Address name
      type: string
    - contextPath: Panorama.Addresses.Description
      description: Address description
      type: string
    - contextPath: Panorama.Addresses.FQDN
      description: Address fqdn
      type: string
    - contextPath: Panorama.Addresses.IP_Netmask
      description: Address IP netmask
      type: string
    - contextPath: Panorama.Addresses.IP_Range
      description: Address IP range
      type: string
    description: Creates an address object
  - name: panorama-delete-address
    arguments:
    - name: name
      required: true
      description: Name of the address to delete
    outputs:
    - contextPath: Panorama.Addresses.Name
      description: Name of the address that was deleted
      type: string
    description: Delete an address object
  - name: panorama-list-address-groups
    arguments: []
    outputs:
    - contextPath: Panorama.AddressGroups.Name
      description: Address group name
      type: string
    - contextPath: Panorama.AddressGroups.Type
      description: Address group type
      type: string
    - contextPath: Panorama.AddressGroups.Match
      description: Dynamic Address group match
      type: string
    - contextPath: Panorama.AddressGroups.Description
      description: Address group description
      type: string
    - contextPath: Panorama.AddressGroups.Addresses
      description: Static Address group addresses
      type: string
    description: Returns a list of address groups
  - name: panorama-get-address-group
    arguments:
    - name: name
      required: true
      description: Address group name
    outputs:
    - contextPath: Panorama.AddressGroups.Name
      description: Address group name
      type: string
    - contextPath: Panorama.AddressGroups.Type
      description: Address group type
      type: string
    - contextPath: Panorama.AddressGroups.Match
      description: Dynamic Address group match
      type: string
    - contextPath: Panorama.AddressGroups.Description
      description: Address group description
      type: string
    - contextPath: Panorama.AddressGroups.Addresses
      description: Static Address group addresses
      type: string
    description: Get details for the specified address group
  - name: panorama-create-address-group
    arguments:
    - name: name
      required: true
      description: Address group name
    - name: type
      required: true
      auto: PREDEFINED
      predefined:
      - dynamic
      - static
      description: Address group type
    - name: match
      description: 'Dynamic Address group match. e.g: "1.1.1.1 or 2.2.2.2"'
    - name: addresses
      description: Static address group list of addresses
      isArray: true
    - name: description
      description: Address group description
    outputs:
    - contextPath: Panorama.AddressGroups.Name
      description: Address group name
      type: string
    - contextPath: Panorama.AddressGroups.Type
      description: Address group type
      type: string
    - contextPath: Panorama.AddressGroups.Match
      description: Dynamic Address group match
      type: string
    - contextPath: Panorama.AddressGroups.Addresses
      description: Static Address group list
      type: string
    - contextPath: Panorama.AddressGroups.Description
      description: Address group description
      type: string
    description: Creates an address group; "static" or "dynamic"
  - name: panorama-delete-address-group
    arguments:
    - name: name
      required: true
      description: Name of address group to delete
    outputs:
    - contextPath: Panorama.AddressGroups.Name
      description: Name of address group that was deleted
      type: string
    description: Deletes an address group
  - name: panorama-edit-address-group
    arguments:
    - name: name
      required: true
      description: Name of the address group to edit
    - name: type
      required: true
      auto: PREDEFINED
      predefined:
      - static
      - dynamic
      description: Address group type
    - name: match
      description: 'Address group new match. e.g: "1.1.1.1 and 2.2.2.2"'
    - name: element_to_add
      description: Element to add to the list of the static address group. only existing
        Address objects can be added
    - name: element_to_remove
      description: Element to remove to the list of the static address group. only
        existing Address objects can be removed
    - name: description
      description: Address group new description
    outputs:
    - contextPath: Panorama.AddressGroups.Name
      description: Address group name
      type: string
    - contextPath: Panorama.AddressGroups.Type
      description: Address group type
      type: string
    - contextPath: Panorama.AddressGroups.Filter
      description: Dynamic Address group match
      type: string
    - contextPath: Panorama.AddressGroups.Description
      description: Address group description
      type: string
    - contextPath: Panorama.AddressGroups.Addresses
      description: Static Address group addresses
      type: string
    description: Edit an address group; "static" or "dynamic"
  - name: panorama-list-services
    arguments: []
    outputs:
    - contextPath: Panorama.Services.Name
      description: Service name
      type: string
    - contextPath: Panorama.Services.Protocol
      description: Service protocol
      type: string
    - contextPath: Panorama.Services.Description
      description: Service description
      type: string
    - contextPath: Panorama.Services.DestinationPort
      description: Service destination port
      type: string
    - contextPath: Panorama.Services.SourcePort
      description: Service source port
      type: string
    description: Returns a list of addresses
  - name: panorama-get-service
    arguments:
    - name: name
      description: Service name
    outputs:
    - contextPath: Panorama.Services.Name
      description: Service name
      type: string
    - contextPath: Panorama.Services.Protocol
      description: Service protocol
      type: string
    - contextPath: Panorama.Services.Description
      description: Service description
      type: string
    - contextPath: Panorama.Services.DestinationPort
      description: Service destination port
      type: string
    - contextPath: Panorama.Services.SourcePort
      description: Service source port
      type: string
    description: Returns service details for the supplied service name
  - name: panorama-create-service
    arguments:
    - name: name
      required: true
      description: Name for the new service
    - name: protocol
      required: true
      auto: PREDEFINED
      predefined:
      - tcp
      - udp
      - sctp
      description: Protocol for the new service
    - name: destination_port
      required: true
      description: Destination port  for the new service
    - name: source_port
      description: Source port  for the new service
    - name: description
      description: Description for the new service
    outputs:
    - contextPath: Panorama.Services.Name
      description: Service name
      type: string
    - contextPath: Panorama.Services.Protocol
      description: Service protocol
      type: string
    - contextPath: Panorama.Services.Descritpion
      description: Service description
      type: string
    - contextPath: Panorama.Services.DestinationPort
      description: Service destination port
      type: string
    - contextPath: Panorama.Services.SourcePort
      description: Service source port
      type: string
    description: Creates a service object
  - name: panorama-delete-service
    arguments:
    - name: name
      required: true
      description: Name of the service to delete
    outputs:
    - contextPath: Panorama.Services.Name
      description: Name of the service that was deleted
      type: string
    description: Deletes a service object
  - name: panorama-list-service-groups
    arguments: []
    outputs:
    - contextPath: Panorama.ServiceGroups.Name
      description: Service group name
      type: string
    - contextPath: Panorama.ServiceGroups.Services
      description: Service group related services
      type: string
    description: Returns a list of service groups
  - name: panorama-get-service-group
    arguments:
    - name: name
      required: true
      description: Service group name
    outputs:
    - contextPath: Panorama.ServiceGroups.Name
      description: Service group name
      type: string
    - contextPath: Panorama.ServiceGroups.Services
      description: Service group related services
      type: string
    description: Get details for the specified service group
  - name: panorama-create-service-group
    arguments:
    - name: name
      required: true
      description: Service group name
    - name: services
      required: true
      description: Service group related services
      isArray: true
    outputs:
    - contextPath: Panorama.ServiceGroups.Name
      description: Service group name
      type: string
    - contextPath: Panorama.ServiceGroups.Services
      description: Service group related services
      type: string
    description: Creates a service group
  - name: panorama-delete-service-group
    arguments:
    - name: name
      required: true
      description: Name of service group to delete
    outputs:
    - contextPath: Panorama.ServiceGroups.Name
      description: Name of service group that was deleted
      type: string
    description: Deletes a service group
  - name: panorama-edit-service-group
    arguments:
    - name: name
      required: true
      description: Name of the service group to edit
    - name: services_to_add
      description: Services to add to the service group. only existing Services objects
        can be added
      isArray: true
    - name: services_to_remove
      description: Services to remove from the service group. only existing Services
        objects can be removed
    outputs:
    - contextPath: Panorama.ServiceGroups.Name
      description: Service group name
      type: string
    - contextPath: Panorama.ServiceGroups.Services
      description: Service group related services
      type: string
    description: Edit a service group
  - name: panorama-get-custom-url-category
    arguments:
    - name: name
      required: true
      description: Custom URL category name
    outputs:
    - contextPath: Panorama.CustomURLCategory.Name
      description: Custom URL category name
      type: string
    - contextPath: Panorama.CustomURLCategory.Description
      description: Custom URL category description
      type: string
    - contextPath: Panorama.CustomURLCategory.Sites
      description: Custom URL category list of sites
      type: string
    description: Returns information for a custom URL category
  - name: panorama-create-custom-url-category
    arguments:
    - name: name
      required: true
      description: Name for the custom URL category to create
    - name: description
      description: Description of the custom URL category to create
    - name: sites
      description: List of sites for the custom URL category
      isArray: true
    outputs:
    - contextPath: Panorama.CustomURLCategory.Name
      description: Custom URL category name
      type: string
    - contextPath: Panorama.CustomURLCategory.Description
      description: Custom URL category description
      type: string
    - contextPath: Panorama.CustomURLCategory.Sites
      description: Custom URL category list of sites
      type: string
    description: Creates a custom URL category
  - name: panorama-delete-custom-url-category
    arguments:
    - name: name
      description: Name of the custom URL category to delete
    outputs:
    - contextPath: Panorama.CustomURLCategory.Name
      description: Name of the custom URL category to delete
      type: string
    description: Delete a custom URL category
  - name: panorama-edit-custom-url-category
    arguments:
    - name: name
      required: true
      description: Name of the custom URL category to add or remove sites to
    - name: sites
      required: true
      description: CSV list of sites to add to the custom URL category
      isArray: true
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - add
      - remove
      description: Add or remove sites; "add" or "remove"
      isArray: true
    outputs:
    - contextPath: Panorama.CustomURLCategory.Name
      description: Custom URL category name
      type: string
    - contextPath: Panorama.CustomURLCategory.Description
      description: Custom URL category description
      type: string
    - contextPath: Panorama.CustomURLCategory.Sites
      description: Custom URL category list of sites
      type: string
    description: Add sites to, or remove sites from a custom URL category
  - name: panorama-get-url-category
    arguments:
    - name: url
      required: true
      description: URL to check
    outputs:
    - contextPath: Panorama.URLFilter.URL
      description: URL
      type: string
    - contextPath: Panorama.URLFilter.Category
      description: URL category
      type: string
    description: Get a URL category from URL Filtering
  - name: panorama-get-url-filter
    arguments:
    - name: name
      required: true
      description: URL Filter name
    outputs:
    - contextPath: Panorama.URLFilter.Name
      description: URL Filter name
      type: string
    - contextPath: Panorama.URLFilter.Category.Name
      description: URL Filter category name
      type: string
    - contextPath: Panorama.URLFilter.Category.Action
      description: Action for the URL category
      type: string
    - contextPath: Panorama.URLFilter.OverrideBlockList
      description: URL Filter override block list
      type: string
    - contextPath: Panorama.URLFilter.OverrideAllowList
      description: URL Filter override allow list
      type: string
    - contextPath: Panorama.URLFilter.Description
      description: URL Filter description
      type: string
    description: Get information for a URL filtering rule
  - name: panorama-create-url-filter
    arguments:
    - name: name
      required: true
      description: Name of the URL filter to create
    - name: url_category
      required: true
      description: One or more URL categories
      isArray: true
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - allow
      - block
      - alert
      - continue
      - override
      description: Action for the URL categories; "allow", "block", "alert", "continue",
        "override"
    - name: override_allow_list
      description: CSV list of URLs to exclude from the allow list
      isArray: true
    - name: override_block_list
      description: CSV list of URLs to exclude from the block list
      isArray: true
    - name: description
      description: URL Filter description
    outputs:
    - contextPath: Panorama.URLFilter.Name
      description: URL Filter name
      type: string
    - contextPath: Panorama.URLFilter.Category.Name
      description: URL Filter category name
      type: string
    - contextPath: Panorama.URLFilter.Category.Action
      description: Action for the URL category
      type: string
    - contextPath: Panorama.URLFilter.OverrideBlockList
      description: URL Filter override allow list
      type: string
    - contextPath: Panorama.URLFilter.OverrideBlockList
      description: URL Filter override block list
      type: string
    - contextPath: Panorama.URLFilter.Description
      description: URL Filter description
      type: string
    description: Creates a URL filtering rule
  - name: panorama-edit-url-filter
    arguments:
    - name: name
      required: true
      description: Name of the URL filter to edit
    - name: element_to_change
      required: true
      auto: PREDEFINED
      predefined:
      - override_allow_list
      - override_block_list
      - description
      description: Element to change; "ovveride_allow_list", "ovveride_block_list"
    - name: element_value
      required: true
      description: Element value, limited to one value
    - name: add_remove_element
      auto: PREDEFINED
      predefined:
      - add
      - remove
      description: Add or remove an element from the Allow List field or Block List
        field, default is "add" the element_value to the list.
      defaultValue: add
    outputs:
    - contextPath: Panorama.URLFilter.Name
      description: URL Filter name
      type: string
    - contextPath: Panorama.URLFilter.Description
      description: URL Filter description
      type: string
    - contextPath: Panorama.URLFilter.Category.Name
      description: URL Filter category
      type: string
    - contextPath: Panorama.URLFilter.Action
      description: Action for the URL category
      type: string
    - contextPath: Panorama.URLFilter.OverrideAllowList
      description: Allow Overrides for the url category
      type: string
    - contextPath: Panorama.URLFilter.OverrideBlockList
      description: Block Overrides for the url category
      type: string
    description: Edit a URL filtering rule
  - name: panorama-delete-url-filter
    arguments:
    - name: name
      required: true
      description: Name of the URL filter rule to delete
    outputs:
    - contextPath: Panorama.URLFilter.Name
      description: URL filter rule name
      type: string
    description: Deletes a URL filtering rule
  - name: panorama-list-edls
    arguments: []
    outputs:
    - contextPath: Panorama.EDL.Name
      description: Name of the EDL
      type: string
    - contextPath: Panorama.EDL.Type
      description: The type of EDL
      type: string
    - contextPath: Panorama.EDL.URL
      description: URL in which the EDL is stored
      type: string
    - contextPath: Panorama.EDL.Description
      description: Description of the EDL
      type: string
    - contextPath: Panorama.EDL.CertificateProfile
      description: EDL certificate profile
      type: string
    - contextPath: Panorama.EDL.Recurring
      description: Time interval that the EDL was pulled and updated
      type: string
    description: Returns a list of external dynamic lists
  - name: panorama-get-edl
    arguments:
    - name: name
      required: true
      description: Name of the EDL
    outputs:
    - contextPath: Panorama.EDL.Name
      description: Name of the EDL
      type: string
    - contextPath: Panorama.EDL.Type
      description: The type of EDL
      type: string
    - contextPath: Panorama.EDL.URL
      description: URL in which the EDL is stored
      type: string
    - contextPath: Panorama.EDL.Description
      description: Description of the EDL
      type: string
    - contextPath: Panorama.EDL.CertificateProfile
      description: EDL certificate profile
      type: string
    - contextPath: Panorama.EDL.Recurring
      description: Time interval that the EDL was pulled and updated
      type: string
    description: Returns information for an external dynamic list
  - name: panorama-create-edl
    arguments:
    - name: name
      required: true
      description: Name of the EDL
    - name: url
      required: true
      description: URL from which to pull the EDL
    - name: type
      required: true
      auto: PREDEFINED
      predefined:
      - ip
      - url
      - domain
      description: The type of EDL
    - name: recurring
      required: true
      auto: PREDEFINED
      predefined:
      - five-minute
      - hourly
      description: Time interval for pulling and updating the EDL
    - name: certificate_profile
      description: Certificate Profile name for the URL that was previously uploaded
        to PAN OS.
    - name: description
      description: Description of the EDL
    outputs:
    - contextPath: Panorama.EDL.Name
      description: Name of theEDL
      type: string
    - contextPath: Panorama.EDL.Type
      description: Type of the EDL
      type: string
    - contextPath: Panorama.EDL.URL
      description: URL in which the EDL is stored
      type: string
    - contextPath: Panorama.EDL.Description
      description: Description of the EDL
      type: string
    - contextPath: Panorama.EDL.CertificateProfile
      description: EDL certificate profile
      type: string
    - contextPath: Panorama.EDL.Recurring
      description: Time interval that the EDL was pulled and updated
      type: string
    description: Creates an external dynamic list
  - name: panorama-edit-edl
    arguments:
    - name: name
      required: true
      description: Name of the external dynamic list to edit
    - name: element_to_change
      required: true
      auto: PREDEFINED
      predefined:
      - url
      - recurring
      - certificate_profile
      - description
      description: The element to change (url, recurring, certificate_profile,
        description)
    - name: element_value
      required: true
      description: The element value
    outputs:
    - contextPath: Panorama.EDL.Name
      description: Name of the EDL
      type: string
    - contextPath: Panorama.EDL.URL
      description: URL in which the EDL is stored
      type: string
    - contextPath: Panorama.EDL.Description
      description: Description of the EDL
      type: string
    - contextPath: Panorama.EDL.CertificateProfile
      description: EDL certificate profile
      type: string
    - contextPath: Panorama.EDL.Recurring
      description: Time interval that the EDL was pulled and updated
      type: string
    description: Modifies an element of an external dynamic list
  - name: panorama-delete-edl
    arguments:
    - name: name
      required: true
      description: Name of the EDL to delete
    outputs:
    - contextPath: Panorama.EDL.Name
      description: Name of the EDL that was deleted
      type: string
    description: Deletes an external dynamic list
  - name: panorama-refresh-edl
    arguments:
    - name: name
      required: true
      description: Name of the EDL
    description: Refreshes the specified external dynamic list
  - name: panorama-create-rule
    arguments:
    - name: rulename
      description: Name of the rule to create
    - name: description
      description: Description of the rule to create
    - name: action
      required: true
      auto: PREDEFINED
      predefined:
      - allow
      - deny
      - drop
      description: Action for the rule; "allow", "deny", "drop"
    - name: source
      description: Source address; "address", "address group"
    - name: destination
      description: Destination address; "address", "address group"
    - name: negate_source
      auto: PREDEFINED
      predefined:
      - "Yes"
      - "No"
      description: Whether to negate the source (address, address group); "Yes" or
        "No"
    - name: negate_destination
      auto: PREDEFINED
      predefined:
      - "Yes"
      - "No"
      description: Whether to negate the destination (address, address group); "Yes"
        or "No"
    - name: service
      description: Service for the rule (service object) to create
    - name: disable
      auto: PREDEFINED
      predefined:
      - "Yes"
      - "No"
      description: Whether to disable the rule; "Yes" or "No" (default is "No")
      defaultValue: "No"
    - name: application
      description: Application for the rule to create
    - name: source_user
      description: Source user for the rule to create
      defaultValue: any
    - name: pre_post
      auto: PREDEFINED
      predefined:
      - pre-rulebase
      - post-rulebase
      description: Pre rule or Post rule (Panorama instances)
    - name: target
      description: Specify a target firewall for the rule (Panorama instances)
    outputs:
    - contextPath: Panorama.SecurityRule.Name
      description: Rule name
      type: string
    - contextPath: Panorama.SecurityRule.Description
      description: Rule description
      type: string
    - contextPath: Panorama.SecurityRule.Action
      description: Action for the rule
      type: string
    - contextPath: Panorama.SecurityRule.Source
      description: Source address
      type: string
    - contextPath: Panorama.SecurityRule.Destination
      description: Destination address
      type: string
    - contextPath: Panorama.SecurityRule.NegateSource
      description: Is the source negated (address, address group)
      type: boolean
    - contextPath: Panorama.SecurityRule.NegateDestination
      description: Is the destination negated (address, address group)
      type: boolean
    - contextPath: Panorama.SecurityRule.Service
      description: Service for the rule
      type: string
    - contextPath: Panorama.SecurityRule.Disabled
      description: Is the rule disabled
      type: string
    - contextPath: Panorama.SecurityRule.Application
      description: Application for the rule
      type: string
    - contextPath: Panorama.SecurityRule.Target
      description: Target firewall (Panorama instances)
      type: string
    description: Creates a policy rule
    execution: true
  - name: panorama-custom-block-rule
    arguments:
    - name: rulename
      description: Name of the custom block policy rule to create
    - name: object_type
      required: true
      auto: PREDEFINED
      predefined:
      - ip
      - address-group
      - application
      - url-category
      description: Object type to block in the policy rule
    - name: object_value
      required: true
      description: Object value
    - name: direction
      auto: PREDEFINED
      predefined:
      - to
      - from
      - both
      description: Direction to block (relevant only for "ip", "address-group" block),
        default is "both"
      defaultValue: both
    - name: pre_post
      auto: PREDEFINED
      predefined:
      - pre-rulebase
      - post-rulebase
      description: Pre rule or Post rule (Panorama instances)
    - name: target
      description: Specify a target firewall for the rule (Panorama instances)
    outputs:
    - contextPath: Panorama.SecurityRule.Name
      description: Rule name
      type: string
    - contextPath: Panorama.SecurityRule.Object
      description: Blocked object
      type: string
    - contextPath: Panorama.SecurityRule.Direction
      description: Direction blocked
      type: string
    - contextPath: Panorama.SecurityRule.Target
      description: Target firewall (Panorama instances)
      type: string
    description: Creates a custom block policy rule
    execution: true
  - name: panorama-move-rule
    arguments:
    - name: rulename
      required: true
      description: Name of the rule to move
    - name: where
      required: true
      auto: PREDEFINED
      predefined:
      - before
      - after
      - top
      - bottom
      description: Where to move the rule to; "before", "after", "top", or "bottom".
        If you specify "up" or "down", you need to supply the "dst" argument.
    - name: dst
      description: Destination rule relative to the rule you are moving. Only supply
        this argument if you specified "up" or "down" for the "where" argument.
    - name: pre_post
      auto: PREDEFINED
      predefined:
      - pre-rulebase
      - post-rulebase
      description: Rule location. Mandatory for Panorama instances.
    outputs:
    - contextPath: Panorama.SecurityRule.Name
      description: Rule name
      type: string
    description: Change the location of a policy rule
    execution: true
  - name: panorama-edit-rule
    arguments:
    - name: rulename
      required: true
      description: Name of the rule to edit
    - name: element_to_change
      required: true
      auto: PREDEFINED
      predefined:
      - source
      - destination
      - application
      - action
      - category
      - description
      - disabled
      - target
      description: Parameter in the security rule to change; "source", "destination",
        "application", "action", "category", "description", "disabled", "target"
    - name: element_value
      required: true
      description: New value for the parameter
    - name: pre_post
      auto: PREDEFINED
      predefined:
      - pre-rulebase
      - post-rulebase
      description: Pre rule or Post rule (Panorama instances)
    outputs:
    - contextPath: Panorama.SecurityRule.Name
      description: Rule name
      type: string
    - contextPath: Panorama.SecurityRule.Description
      description: Rule description
      type: string
    - contextPath: Panorama.SecurityRule.Action
      description: Action for the rule
      type: string
    - contextPath: Panorama.SecurityRule.Source
      description: Source address
      type: string
    - contextPath: Panorama.SecurityRule.Destination
      description: Destination address
      type: string
    - contextPath: Panorama.SecurityRule.NegateSource
      description: Is the source negated (address, address group)
      type: boolean
    - contextPath: Panorama.SecurityRule.NegateDestination
      description: Is the destination negated (address, address group)
      type: boolean
    - contextPath: Panorama.SecurityRule.Service
      description: Service for the rule
      type: string
    - contextPath: Panorama.SecurityRule.Disabled
      description: Is the rule disabled
      type: string
    - contextPath: Panorama.SecurityRule.Application
      description: Application for the rule
      type: string
    - contextPath: Panorama.SecurityRule.Target
      description: Target firewall (Panorama instances)
      type: string
    description: Edit a policy rule
    execution: true
  - name: panorama-delete-rule
    arguments:
    - name: rulename
      required: true
      description: Name of the rule to delete
    - name: pre_post
      auto: PREDEFINED
      predefined:
      - pre-rulebase
      - post-rulebase
      description: Pre rule or Post rule (Panorama instances)
    outputs:
    - contextPath: Panorama.SecurityRule.Name
      description: Rule name
      type: string
    description: Deletes a policy rule
    execution: true
  - name: panorama-list-applications
    arguments: []
    outputs:
    - contextPath: Panorama.Applications.Name
      description: Application name
      type: string
    - contextPath: Panorama.Applications.Id
      description: Application id
      type: number
    - contextPath: Panorama.Applications.Category
      description: Application category
      type: string
    - contextPath: Panorama.Applications.SubCategory
      description: Application sub category
      type: string
    - contextPath: Panorama.Applications.Technology
      description: Application technology
      type: string
    - contextPath: Panorama.Applications.Risk
      description: Application risk (1 to 5)
      type: number
    - contextPath: Panorama.Applications.Description
      description: Application description
      type: string
    description: Returns a list of predefined applications
  - name: panorama-commit-status
    arguments:
    - name: job_id
      required: true
      description: Job ID to check
    outputs:
    - contextPath: Panorama.Commit.JobID
      description: Job ID of the configuration to be committed
      type: number
    - contextPath: Panorama.Commit.Status
      description: Commit status
      type: string
    - contextPath: Panorama.Commit.Details
      description: Job ID details
      type: string
    description: Get commit status for a configuration
  - name: panorama-push-status
    arguments:
    - name: job_id
      required: true
      description: Job ID to check
    outputs:
    - contextPath: Panorama.Push.DeviceGroup
      description: Device group the policies were pushed into
      type: string
    - contextPath: Panorama.Push.JobID
      description: Job ID of the configuration to be pushed
      type: number
    - contextPath: Panorama.Push.Status
      description: Push status
      type: string
    - contextPath: Panorama.Push.Details
      description: Job ID details
      type: string
    description: Get push status for a configuration
  - name: panorama-get-pcap
    arguments:
    - name: pcapType
      required: true
      auto: PREDEFINED
      predefined:
      - application-pcap
      - filter-pcap
      - threat-pcap
      - dlp-pcap
      description: Type of Packet Capture
    - name: from
      description: Filename for dlp-pcap, filters-pcap, application-pcap. <yyyymmdd>
        for application-pcap as well
    - name: localName
      description: The new name for the PCAP file after downloading. If this argument
        is not specified, the file name will be the PCAP file name that was set in
        the firewall.
    - name: serialNo
      description: Serial number for the request. For further information, see the
        Panorama XML API Documentation.
    - name: searchTime
      description: Search time for the request. For further information, see the Panorama
        XML API Documentation.
    - name: pcapID
      description: ID of the Pcap for the request. For further information, see the
        Panorama XML API Documentation.
    - name: password
      description: Password for Panorama, needed for dlp-pcap only.
    outputs:
    - contextPath: File.Size
      description: File size
      type: number
    - contextPath: File.Name
      description: File name
      type: string
    - contextPath: File.Type
      description: File type
      type: string
    - contextPath: File.Info
      description: File info
      type: string
    - contextPath: File.Extenstion
      description: File extenstion
      type: string
    - contextPath: File.EntryID
      description: FIle entryID
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    description: Get panorama pcaps
  - name: panorama-list-pcaps
    arguments:
    - name: pcapType
      required: true
      auto: PREDEFINED
      predefined:
      - application-pcap
      - filter-pcap
      - threat-pcap
      - dlp-pcap
      description: Type of Packet Capture
    - name: password
      description: Password for Panorama, needed for dlp-pcap only.
    description: Returns a list of pcap names
  - name: panorama-register-ip-tag
    arguments:
    - name: tag
      required: true
      description: Tag to register IP addresses to
    - name: IPs
      required: true
      description: IP addresses to register
      isArray: true
    - name: persistent
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether the IP addresses remain registered to the tag after device
        reboots. "false":non-persistent, "true":persistent. Default is "true"
      defaultValue: "true"
    outputs:
    - contextPath: Panorama.DynamicTags.Tag
      description: Name for the tag
      type: string
    - contextPath: Panorama.DynamicTags.IPs
      description: Registered IP addresses
      type: string
    description: Registers IP addresses to a tag
  - name: panorama-unregister-ip-tag
    arguments:
    - name: tag
      required: true
      description: Tag from which to unregister IP addresses
    - name: IPs
      required: true
      description: IP addresses to unregister
      isArray: true
    description: Unregisters IP addresses from a tag
  runonce: false
tests:
- palo_alto_firewall_test_pb
- palo_alto_panorama_test_pb
releaseNotes: Add support for panorama-list/get/create/edit/delete/refresh-edl, panorama-register/unregister-ip-tag commands. Handle errors gracefully.