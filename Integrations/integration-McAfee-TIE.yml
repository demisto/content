commonfields:
  id: McAfee Threat Intelligence Exchange
  version: -1
name: McAfee Threat Intelligence Exchange
display: McAfee Threat Intelligence Exchange
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Connect to TIE using its DXL client
releaseNotes: "-"
detaileddescription: |-
  ### Prerequisites - Connect to McAfee Threat Intelligence Exchange (TIE) using the DXL TIE client.
  [Create certificates & configure dxl](https://opendxl.github.io/opendxl-client-python/pydoc/index.html). After this phase you must have:
   * Broker CA certificates ('brokercerts.crt'  file)
   * Client certificate ('client.crt' file)
   * Client private key ('client.key' file)
   * Broker list properties file ('brokerlist.properties' file)

   To use 'tie-set-file-reputation' - you must have an appropriate permission. Follow [this insructions](https://opendxl.github.io/opendxl-client-python/pydoc/marsendauth.html), and ** with the exception of swapping the 'Active Response Server API' in 'TIE Server Set Enterprise Reputation'**

  ### Dependencies (Python packages) - No need to install, already installed in docker image :
  dxlclient [docs](https://opendxl.github.io/opendxl-client-python/pydoc/index.html)
  dxltieclient [docs](https://opendxl.github.io/opendxl-tie-client-python/pydoc/)
configuration:
- display: Broker CA certificates content (see `brokercerts.crt` in instructions)
  name: broker_ca_bundle
  defaultvalue: ""
  type: 12
  required: true
- display: Client certificates content (see `client.crt` in instructions)
  name: cert_file
  defaultvalue: ""
  type: 12
  required: true
- display: Client private key path (e.g. /usr/config/client.key)
  name: private_key
  defaultvalue: ""
  type: 14
  required: true
- display: Brokers urls (comma separated list in the form of - [ssl://]<hostname>[:port])
    - get hostname & port from `brokerlist.properties` file in instructions. Note
    that the broker should be reachable from demisto server
  name: broker_urls
  defaultvalue: ""
  type: 0
  required: true
script:
  script: |
    from dxlclient.client_config import DxlClientConfig
    from dxlclient.client import DxlClient
    from dxlclient.broker import Broker
    from dxltieclient import TieClient
    from dxltieclient.constants import HashType
    from datetime import datetime

    VENDOR_NAME = 'McAfee Threat Intelligence Exchange'

    broker_ca_bundle = './brokercerts.crt'
    with open(broker_ca_bundle, "w") as text_file:
        text_file.write(demisto.params()['broker_ca_bundle'])

    cert_file = './cert_file.crt'
    with open(cert_file, "w") as text_file:
        text_file.write(demisto.params()['cert_file'])

    private_key = './private_key.key'
    with open(private_key, "w") as text_file:
        text_file.write(demisto.params()['private_key'])

    broker_urls = demisto.params()['broker_urls'].split(',')

    HASH_TYPE_KEYS = {
        'md5': HashType.MD5,
        'sha1': HashType.SHA1,
        'sha256': HashType.SHA256
    }

    TRUST_LEVELS = {
        '0': 'NOT_SET',
        '1': 'KNOWN_MALICIOUS',
        '15': 'MOST_LIKELY_MALICIOUS',
        '30': 'MIGHT_BE_MALICIOUS',
        '50': 'UNKNOWN',
        '70': 'MIGHT_BE_TRUSTED',
        '85': 'MOST_LIKELY_TRUSTED',
        '99': 'KNOWN_TRUSTED',
        '100': 'KNOWN_TRUSTED_INSTALLER'
    }

    POVIDER = {
        '1': 'Global Threat Intelligence (GTI)',
        '3': 'Enterprise reputation',
        '5': 'Advanced Threat Defense (ATD)',
        '7': 'Web Gateway (MWG)'
    }

    def create_error_entry(contents):
        return { 'ContentsFormat': formats['text'], 'Type': entryTypes['error'], 'Contents': contents };

    def get_client_config():
        config = DxlClientConfig(
            broker_ca_bundle=broker_ca_bundle,
            cert_file=cert_file,
            private_key=private_key,
            brokers=[Broker.parse(url) for url in broker_urls]
        )

        config.connect_retries = 1
        config.reconnect_delay = 1
        config.reconnect_delay_max = 10

        return config

    def get_provider(provider_id):
        provider_id_str = str(provider_id)
        return POVIDER.get(provider_id_str, provider_id_str)

    def parse_reputation(rep):
        # get trust level
        trust_level = str(rep.get('trustLevel'))
        verbose_trust_level = TRUST_LEVELS.get(trust_level, trust_level)

        # get provider
        provider_id = rep.get('providerId')
        provider = get_provider(provider_id)

        # get date
        create_date = rep.get('createDate')
        create_date_str = str(datetime.fromtimestamp(create_date))

        res = {
            'Trust level': trust_level,
            'Trust level (verbose)': verbose_trust_level,
            'Provider ID': provider_id,
            'Provider (verbose)': provider,
            'Created date': create_date_str
        }

        return res

    def parse_reference(reference):
        agent_guid = reference.get('agentGuid')
        return {
            'Date': str(datetime.fromtimestamp(reference.get('date'))),
            'AgentGuid': agent_guid.replace('{', '').replace('}', '') # remove brackets if exist
        }

    def reputations_to_table(reputations):
        return [parse_reputation(rep) for rep in reputations]

    def references_to_table(references):
        return [parse_reference(ref) for ref in references]

    def trust_level_to_score(trust_level):
        if (trust_level >= 70):
            return 1
        elif (trust_level >= 30):
            return 2
        elif (trust_level >= 30):
            return 3
        else:
            return 0

    def get_thrust_level_and_score(reputations):
        trust_level = 101 # more than the highst possible trust level
        vendor = VENDOR_NAME

        for rep in reputations:
            rep_trust_level = rep.get('trustLevel', 0)
            if  rep_trust_level != 0 and rep_trust_level < trust_level:
                trust_level = rep.get('trustLevel')
                vendor = get_provider(rep.get('providerId'))

        if trust_level == 101:
            # no trust_level found
            return {
                'trust_level': 0,
                'score': 0,
                'vendor': vendor
            }

        score = trust_level_to_score(trust_level)

        if (vendor == 'Enterprise reputation'):
            vendor = VENDOR_NAME
        return {
            'trust_level': trust_level,
            'score': score,
            'vendor': vendor
            }

    def test():
        config = get_client_config()
        with DxlClient(config) as client:
            client.connect()
            client.disconnect()

    def file(hash):
        config = get_client_config()
        with DxlClient(config) as client:
            client.connect()
            # Create the McAfee Threat Intelligence Exchange (TIE) client
            tie_client = TieClient(client)

            hash_type = get_hash_type(hash)
            hash_type_key = HASH_TYPE_KEYS.get(hash_type)
            if not hash_type_key:
                return create_error_entry('file argument must be sha1(40 charecters) or sha256(64 charecters) or md5(32 charecters)')

            hash_param = {}
            hash_param[hash_type_key] = hash

            res = tie_client.get_file_reputation(hash_param)
            reputations = res.values()

            table = reputations_to_table(reputations)

            # creaet context
            context_file = {}
            hash_type_uppercase = hash_type.upper()
            tl_score = get_thrust_level_and_score(reputations)

            context_file[hash_type_uppercase] = hash
            context_file['TrustLevel'] = tl_score['trust_level']
            context_file['Vendor'] = tl_score['vendor']

            dbot_score = {'Indicator': hash, 'Type': 'hash', 'Vendor': tl_score['vendor'], 'Score': tl_score['score']};
            if tl_score['score'] >= 2:
                context_file['Malicious'] = {
                   'Vendor': tl_score['vendor'],
                   'Score': tl_score['score'],
                   'Description': 'Trust level is ' + str(tl_score['trust_level'])
               }
            ec = {
                'DBotScore': dbot_score
            }
            ec[outputPaths['file']] = context_file

            return {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': reputations,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('McAfee TIE Hash Reputations For %s:' % (hash,), table),
                'EntryContext': ec
            }

    def file_references(hash):
        config = get_client_config()
        with DxlClient(config) as client:
            client.connect()
            # Create the McAfee Threat Intelligence Exchange (TIE) client
            tie_client = TieClient(client)

            hash_type = get_hash_type(hash)
            hash_type_key = HASH_TYPE_KEYS.get(hash_type)
            if not hash_type_key:
                return create_error_entry('file argument must be sha1(40 charecters) or sha256(64 charecters) or md5(32 charecters)')

            hash_param = {}
            hash_param[hash_type_key] = hash

            references = tie_client.get_file_first_references(hash_param)

            table = references_to_table(references)

            # creaet context
            context_file = {}
            hash_type_uppercase = hash_type.upper()

            context_file[hash_type_uppercase] = hash
            context_file['References'] = table
            ec = {}
            ec[outputPaths['file']] = context_file
            return {
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': references,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('References for hash %s' % (hash,), table),
                'EntryContext': ec
            }

            return res

    def set_file_reputation(hash, trust_level, filename, comment):
        config = get_client_config()

        # find trust_level key
        trust_level_key = None
        for k, v in TRUST_LEVELS.iteritems():
            if v == trust_level:
                trust_level_key = k

        if not trust_level_key:
            return create_error_entry('illigale argument trust_level %s. Choose value from predefined values' % (trust_level, ))


        with DxlClient(config) as client:
            client.connect()
            tie_client = TieClient(client)

            hash_type = get_hash_type(hash)
            hash_type_key = HASH_TYPE_KEYS.get(hash_type)
            if not hash_type_key:
                return create_error_entry('file argument must be sha1(40 charecters) or sha256(64 charecters) or md5(32 charecters)')

            hash_param = {}
            hash_param[hash_type_key] = hash

            try:
                tie_client.set_file_reputation(trust_level_key, hash_param, filename, comment)
                return 'Successfully set file repuation'
            except Exception as ex:
                return create_error_entry(str(ex))


    args = demisto.args()
    if demisto.command() == 'test-module':
        test()
        demisto.results('ok')
        sys.exit(0)
    elif demisto.command() == 'file':
        results = file(args.get('file'))
        demisto.results(results)
        sys.exit(0)
    elif demisto.command() == 'tie-file-references':
        results = file_references(args.get('file'))
        demisto.results(results)
        sys.exit(0)
    elif demisto.command() == 'tie-set-file-reputation':
        results = set_file_reputation(
            args.get('file'),
            args.get('trust_level'),
            args.get('filename'),
            args.get('comment')
        )
        demisto.results(results)
        sys.exit(0)
  type: python
  commands:
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: '  Hash of the file to query. Supports MD5 SHA1 & SHA256'
    outputs:
    - contextPath: File.MD5
      description: file's hash MD5 (if supplied)
    - contextPath: File.SHA1
      description: file's hash SHA1 (if supplied)
    - contextPath: File.SHA256
      description: file's hash MD5 (if supplied)
    - contextPath: File.TrustLevel
      description: File lowest trust level
    - contextPath: File.Vendor
      description: File lowest trust level's vendor
    - contextPath: DBotScore.Score
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Vendor
      description: The actual score
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Indicator
      description: The given file's hash
    important:
    - contextPath: File(val.Malicious)
      description: Malicious Files
      related: ""
    description: Retrieves the reputations for the specified hash ( Supports MD5 SHA1
      & SHA256)
  - name: tie-set-file-reputation
    arguments:
    - name: file
      required: true
      default: true
      description: '  Hash of the file to set. Supports MD5 SHA1 & SHA256'
    - name: trust_level
      required: true
      auto: PREDEFINED
      predefined:
      - NOT_SET
      - KNOWN_MALICIOUS
      - MOST_LIKELY_MALICIOUS
      - MIGHT_BE_MALICIOUS
      - UNKNOWN
      - MIGHT_BE_TRUSTED
      - MOST_LIKELY_TRUSTED
      - KNOWN_TRUSTED
      - KNOWN_TRUSTED_INSTALLER
      description: The new trust level for the file
    - name: filename
      description: A file name to associate with the file
    - name: comment
      description: A comment to associate with the file
    description: Sets the “Enterprise” reputation (trust level) of a specified file.
      NOTE - invoking this method must have permissions - 'How-to' in instance instruction)
  - name: tie-file-references
    arguments:
    - name: file
      required: true
      default: true
      description: '  Hash of the file to search on. Supports MD5 SHA1 & SHA256'
    outputs:
    - contextPath: File.MD5
      description: file's hash MD5 (if supplied)
    - contextPath: File.SHA1
      description: file's hash SHA1 (if supplied)
    - contextPath: File.SHA256
      description: file's hash SHA256 (if supplied)
    - contextPath: File.References.AgentGuid
      description: The GUID of the system that referenced the file
    - contextPath: File.References.Date
      description: The time the system first referenced the file
    description: Retrieves the set of systems which have referenced (typically executed)
      the specified file
  dockerimage: demisto/dxl
