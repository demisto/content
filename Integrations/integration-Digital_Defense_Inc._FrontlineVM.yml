commonfields:
  id: Digital Defense Inc. FrontlineVM
  version: -1
name: Digital Defense Inc. FrontlineVM
display: Digital Defense Inc. FrontlineVM
category: Vulnerability Management
image: data:image/png;base64,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
description: Digital Defense Inc.'s Frontline Vulnerability Management solution comprehensively
  identifies and evaluates the security and business risk postures of network devices
  and applications deployed as premise, cloud, or hybrid network-based implementations.
  Now residing entirely in Amazon Web Services (AWS), Frontline VM easily addresses
  the security compliance requirements of organizations around the globe.
detaileddescription: No help here because this is a simple integration.
configuration:
- display: API Token to access Frontline.Cloud
  name: apiToken
  defaultvalue: ""
  type: 0
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Min vulnerability severity for fetching incidents.
  name: incidentSeverity
  defaultvalue: critical
  type: 15
  required: false
  options:
  - critical
  - high
  - medium
  - low
  - trivial
  - info
- display: Rate at which to check vulnerability events when fetching incidents.
  name: incidentFrequency
  defaultvalue: 3 hr
  type: 15
  required: true
  options:
  - 5 min
  - 15 min
  - 30 min
  - 1 hr
  - 3 hr
  - 8 hr
  - 12 hr
  - 24 hr
script:
  script: |
    ''' IMPORTS '''
    import requests
    import json
    import sys
    import socket
    import struct
    from datetime import datetime, tzinfo, timedelta

    ''' GLOBAL VARS '''
    API_TOKEN = demisto.params().get('apiToken')
    INCIDENT_VULN_SEVERITY = demisto.params().get('incidentSeverity')
    INCIDENT_FREQUENCY = demisto.params().get('incidentFrequency')
    FVM_URL = "https://vm.frontline.cloud"
    VULN_ENDPOINT = FVM_URL + "/api/scanresults/active/vulnerabilities/"
    HOST_ENDPOINT = FVM_URL + "/api/scanresults/active/hosts/"
    SCAN_ENDPOINT = FVM_URL + "/api/scans/"

    ''' HELPER FUNCTIONS '''
    def get_fvm_data(request_url, api_token, **kwargs):
        data = []
        current_data = {}
        resp = requests.get(request_url, headers={'Authorization': 'Token ' + str(API_TOKEN)}, timeout=30, **kwargs)
        resp.raise_for_status()
        current_data = json.loads(resp.text)
        data.extend(current_data.get('results', []))
        while current_data.get('next', None):
            resp = requests.get(url=current_data.get('next'), headers={'Authorization': 'Token ' + str(API_TOKEN)}, timeout=30)
            if not resp.ok:
                demisto.debug("FrontlineVM get_fvm_data -- response error (status code: "+str(resp.status_code)+")")
            current_data = {}
            resp.raise_for_status()
            current_data = json.loads(resp.text)
            data.extend(current_data.get('results', []))
        return data

    def parse_params(param_dict):
        param_index = 0
        new_param_dict = {}
        for key in param_dict:
            new_key = "_"+str(param_index)+"_"+key
            new_param_dict[new_key] = param_dict[key]
            param_index += 1
        return new_param_dict


    def get_fetch_frequency_td():
        ''' Returns the INCIDENT_FREQUENCY as a datetime.timedelta object    '''
        fetch_frequency = INCIDENT_FREQUENCY.split()
        demisto.debug("FrontlineVM get_fetch_incident_td -- using frequency: " + str(fetch_frequency))
        if "min" in str(fetch_frequency[1]):
            return timedelta(minutes=int(fetch_frequency[0]))
        else:
            return timedelta(hours=int(fetch_frequency[0]))


    def get_vuln_incidents(vulns, start_time_dt):
        incidents = []
        for vuln in vulns:
            av_date_created_str = vuln.get('active_view_date_created')
            av_date_created_dt = datetime.strptime(av_date_created_str, "%Y-%m-%dT%H:%M:%S.%fZ")

            # Skip if vuln created before current start_time:
            if (av_date_created_dt < start_time_dt):
                continue
            vuln_event = {}
            vuln_event['vuln-id'] = vuln.get('id')
            vuln_event['hostname'] = vuln.get('hostname')
            vuln_event['ip-address'] = vuln.get('ip_address')
            vuln_event['port'] = vuln.get("port")
            vuln_event['scan-id'] = vuln.get('scan_id')
            vuln_event['vuln-title'] = vuln.get('title')
            vuln_event['date-created'] = vuln.get('active_view_date_created')
            vuln_event['ddi-severity'] = vuln['severities']['ddi']
            vuln_event['vuln-info'] = vuln.get('data')

            incident = {
                'name': vuln.get('title'),
                'occurred': vuln.get('active_view_date_created'),
                'details': vuln.get('data'),
                'rawJSON': json.dumps(vuln_event)
            }
            incidents.append(incident)
        return incidents


    def fetch_incidents():
        try:
            last_run = demisto.getLastRun()
            # Check if last_run exists and has a start_time, else create new start_time timestamp:
            if last_run and last_run.get('start_time', False):
                start_time = last_run.get('start_time')
                # Check if user selected fetch frequency is within last_run[start_time]:
                fetch_frequency_td = get_fetch_frequency_td()
                if ((datetime.utcnow() - datetime.utcfromtimestamp(int(start_time))) < fetch_frequency_td):
                    demisto.debug("FrontlineVM fetch_incident -- frequency (" + str(fetch_frequency_td) +") within last start_time, sending empty incidents.")
                    demisto.setLastRun({'start_time': last_run.get('start_time')})
                    demisto.incidents([])
                    return
                else:
                    demisto.debug("FrontlineVM fetch_incident -- frequency (" + str(fetch_frequency_td) +") exceeds last start_time, continuing to fetch incident events.")
            else:
                now = datetime.utcnow()
                start_time = now.strftime("%s")
            start_time_dt = datetime.utcfromtimestamp(int(start_time))
            start_time_str = start_time_dt.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
            demisto.debug("FrontlineVM fetch_incident -- continuing with start_time of " + str(start_time_str))

            # Fetch vulnerabilities:
            req_params = {}
            req_params['lte_vuln_severity_ddi'] = str(INCIDENT_VULN_SEVERITY)
            req_params['gte_vuln_date_created'] = start_time_str
            req_params = parse_params(req_params)
            vulns = get_fvm_data(VULN_ENDPOINT, API_TOKEN, params=req_params)

            # Create incidents
            if vulns:
                demisto.debug("FrontlineVM fetch_incidents -- getting all incidents.")
                incidents = get_vuln_incidents(vulns, start_time_dt)
            else:
                demisto.debug("FrontlineVM fetch_incidents -- no new vulnerabilities found, no incidents created.")
                incidents = []

            now = datetime.utcnow()
            start_time = now.strftime("%s")
            demisto.info("FrontlineVM fetch_incident -- creating new start_time of " + str(now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")))
            demisto.setLastRun({'start_time': start_time})
            demisto.incidents(incidents)
            #return
        except Exception as err:
            return_error("ERROR FrontlineVM fetching_incidents -- " + str(err.message))


    ''' COMMAND FUNCTIONS   '''
    def get_assets(ip_address, hostname, label_name, scanned_within_last):
        ''' Returns a list of assets from Frontline.Cloud based on user input from Arguments    '''
        # Prepare parameters for Frontline API request:
        req_params = {}
        if ip_address:
            req_params['eq_host_ip_address'] = str(ip_address)
        if hostname:
            req_params['iexact_host_hostname'] = str(hostname)
        if label_name:
            req_params['eq_host_labels'] = str(label_name)
        if scanned_within_last:
            now = datetime.utcnow()
            query_date = (now - timedelta(days=int(scanned_within_last))).replace(hour=0, minute=0, second=0, microsecond=0)
            query_date = datetime.strftime(query_date, "%Y-%m-%dT%H:%M:%SZ")
            req_params['gte_host_date_created'] = str(query_date)
        req_params = parse_params(req_params)
        hosts = get_fvm_data(HOST_ENDPOINT, API_TOKEN, params=req_params)
        return hosts


    def get_assets_command():
        ''' Pulls host information from FrontlineVM '''
        # Get Arguments:
        ip_address = demisto.args().get('ip_address', None)
        hostname = demisto.args().get('hostname', None)
        label_name = demisto.args().get('label_name', None)
        scanned_within_last = demisto.args().get('scanned_within_last', None)

        hosts = get_assets(ip_address, hostname, label_name, scanned_within_last)

        # Condensing Host data for HumanReadable and EntryContext:
        host_headers = ['host-id', 'hostname', 'ip-address', 'dns-hostname', 'mac-address', 'os', 'os-type', 'ddi-critical-count']
        get_asset_output = {}
        host_list = []
        ip_list = []
        host_id_list = []
        for host in hosts:
            host_obj = {}
            host_obj['host-id'] = host.get('id', None)
            host_obj['hostname'] = host.get('hostname', '')
            host_obj['ip-address'] = host.get('ip_address', '')
            host_obj['dns-hostname'] = host.get('dns_name', '')
            host_obj['mac-address'] = host.get('mac_address', '')
            host_obj['os'] = host.get('os')
            host_obj['os-type'] = host.get('os_type')
            host_obj['ddi-critical-count'] = host['active_view_vulnerability_severity_counts']['weighted']['ddi']['counts']['critical']
            host_list.append(host_obj)
            ip_list.append(host.get('ip_address'))
            host_id_list.append(host.get('id'))

        # Linking Context:
        get_asset_output['Hosts'] = host_list
        get_asset_output['HostId'] = host_id_list
        get_asset_output['IPList'] = ip_list

        ec = {'FrontlineVM(val.Hosts && val.Hosts == obj.Hosts)': get_asset_output}

        output = {
            'Type': entryTypes['note'],         # indicates entry type to the War room
            'Contents': hosts,                  # raw data callable from War Room CLI with "raw-response=true"
            'ContentsFormat': formats['json'],  # format of the content from the Contents field
            'HumanReadable': tableToMarkdown('FrontlineVM: Assets Found', host_list, headers=host_headers, removeNull=True),    # content that displays in the War Room
            'ReadableContentsFormat': formats['markdown'],      # Format of the content from the HumanReadable field
            'EntryContext': ec  # Data added to the investigation context (Output Context), which you can use in playbooks
        }
        return output

    def get_vulns(severity, min_severity, days_older_than, days_newer_than, host_id):
        # Prepare parameters for Frontline API request:
        req_params = {}
        if min_severity and severity:
            demisto.log("FrontlineVM get_vulns_command -- Selecting both \'min_severity\' and \'severity\' arguments will yield to selecting the minimum severity of vulnerabilities to pull.")
        if min_severity:
            req_params['lte_vuln_severity_ddi'] = str(min_severity)
        elif severity:
            req_params['eq_vuln_severity_ddi'] = str(severity)
        if days_older_than:
            now = datetime.utcnow()
            query_date = (now - timedelta(days=int(days_older_than))).replace(hour=0, minute=0, second=0, microsecond=0)
            query_date = datetime.strftime(query_date, "%Y-%m-%dT%H:%M:%SZ")
            req_params['lte_vuln_active_view_date_first_created']=str(query_date)
        if days_newer_than:
            now = datetime.utcnow()
            query_date = (now - timedelta(days=int(days_newer_than))).replace(hour=0, minute=0, second=0, microsecond=0)
            query_date = datetime.strftime(query_date, "%Y-%m-%dT%H:%M:%SZ")
            req_params['gte_vuln_date_created'] = str(query_date)
        if host_id:
            VulnEndpoint = HOST_ENDPOINT + str(host_id) + "/vulnerabilities/"
        else:
            VulnEndpoint = VULN_ENDPOINT
        req_params = parse_params(req_params)
        vulns = get_fvm_data(VulnEndpoint, API_TOKEN, params=req_params)
        return vulns


    def get_vuln_outputs(vuln_list):
        output = []
        vuln_data_output = {}
        vuln_stat_output = {}

        vuln_severity_count = {
            'critical':0,
            'high':0,
            'medium':0,
            'low':0,
            'trivial':0,
            'info':0
        }

        vuln_data_obj = {}
        vuln_stat_obj = {}
        vuln_stat_obj['vulnerability-count'] = len(vuln_list)
        vuln_data_list = []
        ip_list = []

        if len(vuln_list) > 0:
            demisto.debug('FrontlineVM get_vuln_outputs -- interating through vulns')
        else:
            demisto.debug('FrontlineVM get_vuln_outputs -- get vulns request returned empty')
        # Condensing Vuln data for HumanReadable and EntryContext:
        for vuln in vuln_list:
            vuln_obj = {}
            vuln_obj['vuln-id'] = vuln.get('id')
            vuln_obj['hostname'] = vuln.get('hostname')
            vuln_obj['ip-address'] = vuln.get('ip_address')
            vuln_obj['vuln-title'] = vuln.get('title')
            vuln_obj['date-created'] = vuln.get('active_view_date_created')
            vuln_obj['ddi-severity'] = vuln['severities']['ddi']
            vuln_obj['vuln-info'] = vuln.get('data')
            vuln_severity_count[str(vuln['severities']['ddi'])] += 1
            vuln_data_list.append(vuln_obj)
            ip_list.append(vuln.get('ip_address'))

        vuln_data_headers = ['vuln-id', 'hostname', 'ip-address', 'vuln-title', 'date-created', 'ddi-severity', 'vuln-info']
        vuln_stat_headers = ['vulnerability-count']
        for k, v in vuln_severity_count.items():
            if v > 0:
                vuln_stat_headers.append(str(k) + "-severity-count")
                vuln_stat_obj[str(k)+"-severity-count"] = v

        vuln_data_output['Vulns'] = vuln_data_list
        vuln_data_output['IPList'] = ip_list
        vuln_stat_output = vuln_stat_obj

        vuln_data_ec = {
            'FrontlineVM(val.Vulns && val.Vulns == obj.Vulns)': vuln_data_output
        }

        data_output = {
            'Type': entryTypes['note'],
            'Contents': vuln_list,
            'ContentsFormat': formats['json'],
            'HumanReadable': tableToMarkdown('FrontlineVM: Vulnerabilities Found', vuln_data_list, headers=vuln_data_headers, removeNull=True),
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext':vuln_data_ec
        }
        output.append(data_output)

        vuln_stat_ec = {
            'FrontlineVM(val.Object && val.Object == obj.Object)': vuln_stat_output
        }

        stat_output = {
            'Type': entryTypes['note'],
            'Contents': vuln_stat_output,
            'ContentsFormat': formats['json'],
            'HumanReadable': tableToMarkdown('FrontlineVM: Vulnerability Statisctics', vuln_stat_output, headers=vuln_stat_headers),
            'EntryContext': vuln_stat_ec

        }
        output.append(stat_output)
        return output


    def get_vulns_command():
        ''' Pulls vulnerability information from FrontlineVM    '''
        # Get Arugments:
        severity = demisto.args().get('severity')
        min_severity = demisto.args().get('min_severity')
        days_older_than = demisto.args().get('days_older_than')
        days_newer_than = demisto.args().get('days_newer_than')
        host_id = demisto.args().get('host_id')
        ip_address = demisto.args().get('ip_address')

        vulns = []
        if ip_address:
            host = get_fvm_data(HOST_ENDPOINT, API_TOKEN, params={'_0_eq_host_ip_address': str(ip_address)})
            if len(host) >= 1:
                host_id = host[0].get('id')
            else:
                demisto.debug('Frontline.Cloud get_vuln_command -- Host not found within Frontline.Cloud given host IP Address.')
        vulns = get_vulns(severity, min_severity, days_older_than, days_newer_than, host_id)
        return get_vuln_outputs(vulns)


    #########################
    # CREATING SCAN METHODS:
    #########################
    class _tz_UTC(tzinfo):
        ''' UTC '''
        def utcoffset(self, dt):
            return timedelta(0)

        def tzname(self, dt):
            return 'UTC'

        def dst(self, dt):
            return timedelta(0)


    def ip2long(ip_address):
        ''' Converts IP from string to number. '''
        return struct.unpack("!L", socket.inet_aton(ip_address))[0]


    def long2ip(ip_address):
        ''' Converts IP from number to string. '''
        return socket.inet_ntoa(struct.pack("!L", ip_address))


    def get_network_data():
        try:
            url = FVM_URL + "/api/networkprofiles/?_0_eq_networkprofile_internal=True"
            resp = requests.get(url, headers={'Authorization': 'Token ' + str(API_TOKEN)})
            resp.raise_for_status()
            return json.loads(resp.text)
        except Exception as err:
            print('ERROR getting network data: ' + str(err))
        return None


    def get_scan_data(network_data, low_ip, high_ip):
        for profile in network_data:
            #If there is no scanner using this profile, then continue to the next profile
            if len(profile.get('scanner_names', "")) == 0:
                continue
            status_url = FVM_URL + "/api/scanners/" + str(profile.get('scanner_ids')[0]) + "/"
            status_resp = requests.get(status_url, headers={'Authorization': 'Token ' + str(API_TOKEN)})
            status_resp.raise_for_status()
            status = json.loads(status_resp.text)
            if status.get('status', '') == 'online':
                url = FVM_URL + "/api/networkprofiles/" + str(profile['id']) + "/rules/"
                profile_data = []
                current_data = None
                have_all_data = False
                while not have_all_data:
                    resp = requests.get(url, headers={'Authorization': 'Token ' + str(API_TOKEN)})
                    resp.raise_for_status()
                    current_data = json.loads(resp.text)
                    profile_data.extend(current_data.get('results', []))
                    if (current_data.get('next', None)):
                        url = current_data.get('next')
                    else:
                        have_all_data = True
                for rule in profile_data:
                    if rule.get('ip_address_range', None):
                        if (rule['ip_address_range']['high_ip_number'] >= high_ip) and (rule['ip_address_range']['low_ip_number'] <= low_ip):
                            return json.dumps({
                                'scanner_name': profile['scanner_names'][0],
                                'scanner_id': profile['scanner_ids'][0],
                                'profile_name': profile['name'],
                                'profile_id': profile['id']
                            })
        return_error("Error: no scan data found.")


    def get_business_group():
        url = FVM_URL + "/api/session/"
        resp = requests.get(url, headers={'Authorization': 'Token ' + str(API_TOKEN)})
        resp.raise_for_status()
        data = json.loads(resp.text)
        if data.get('account_allow_businessgroups_setting', None):
            bus_url = FVM_URL + "/api/businessgroups/?_0_eq_businessgroup_name=Enterprise Admins"
            bus_resp = requests.get(bus_url, headers={'Authorization': 'Token ' + str(API_TOKEN)})
            bus_data = json.loads(bus_resp.text)
            for grp in bus_data:
                return grp
        return None


    def build_scan(low_ip_address, high_ip_address, scan_policy):
        low_ip_number = ip2long(low_ip_address)
        high_ip_number = ip2long(high_ip_address)

        # Check IP address order if range provided:
        if (low_ip_address != high_ip_address) and (low_ip_number > high_ip_number):
            temp_ip_number = low_ip_number
            low_ip_number = high_ip_number
            high_ip_number = temp_ip_number
            temp_ip_address = low_ip_address
            low_ip_address = high_ip_address
            high_ip_address = temp_ip_address

        scan_policy = str(scan_policy)
        network_data = get_network_data()
        scanner_data = json.loads(get_scan_data(network_data, low_ip_number, high_ip_number))
        now = datetime.now(_tz_UTC())
        tz = "UTC"
        tzoffset = 0
        scan = {}
        if low_ip_address == high_ip_address:
            scan['name'] = ("Demisto Scan "+" ["+str(low_ip_address)+"]")
        elif low_ip_address != high_ip_address:
            scan['name'] = ("Demisto Scan "+"["+str(low_ip_address)+"-"+str(high_ip_address)+"]")
        else:
            scan['name'] = ("Demisto Scan")
        scan['description'] = "New network device auto scan launch from Demisto."
        scan['schedule'] = {
            "id": None,
            "end_date": None,
            "start_date":now.strftime("%Y-%m-%dT%H:%M:%S%z"),
            "recurring": False,
            "recurrence_rules": [],
            "timezone": tz,
            "timezone_offset": tzoffset
        }
        scan['workflow'] = "va_workflow"
        scan['exclude_from_active_view'] = False
        scan['notify'] = False
        scan['internal'] = True
        scan['recipients'] = []
        scan['scan_policy'] = scan_policy
        scan['scan_speed'] = "normal"
        scan['asset_groups'] = []
        scan['asset_filter'] = {}

        business_group = get_business_group()
        if business_group:
            scan['businessgroups'] = [{"id": business_group['id']}]
        scan['adhoc_targets'] = []
        scan['adhoc_targets'].append({
            "rule_action": "include",
            "network_profile_id": int(scanner_data['profile_id']),
            "inclusion": "full",
            "ip_address_range": {
                "low_ip_address": low_ip_address,
                "high_ip_address": high_ip_address,
                "low_ip_number": low_ip_number,
                "high_ip_number": high_ip_number,
                "ipv6": False,
                "dhcp": False,
                "fragile": False,
                "cidr_block": None
            }
        })
        return scan


    def scan_asset(ip_address, scan_policy):
        if "-" in ip_address:
            low_ip_address = ip_address.split("-")[0].strip()
            high_ip_address = ip_address.split("-")[1].strip()
        else:
            low_ip_address = ip_address
            high_ip_address = ip_address
        scan_payload = build_scan(low_ip_address, high_ip_address, scan_policy)
        header = {}
        header['Authorization'] = 'Token ' + str(API_TOKEN)
        header['Content-Type'] = "application/json;charset=utf-8"
        resp = requests.post(SCAN_ENDPOINT, data=json.dumps(scan_payload), headers=header)
        resp.raise_for_status()
        scan_response = json.loads(resp.text)
        return scan_response


    def scan_policy_exists(policy_selected):
        policy_url = SCAN_ENDPOINT + "policies/"
        demisto.debug("FrontlineVM scan_policy_exists -- checking if user defined policy exists within Frontline.Cloud")
        try:
            resp = requests.get(policy_url, headers={'Authorization': 'Token ' + str(API_TOKEN)})
            resp.raise_for_status()
            data = json.loads(resp.text)
            for policy in data:
                if str(policy_selected) == policy.get('name', ""):
                    return True
            return False
        except Exception as err:
            demisto.error("FrontlineVM scan_policy_exists -- Exception: " + str(err.message))
            return_error(err.message)


    def scan_asset_command():
        ip_address = demisto.args().get('ip_address')
        scan_policy = str(demisto.args().get('scan_policy'))
        if scan_policy != "Default" and not scan_policy_exists(scan_policy):
            return_error("Scan Policy entered '" + str(scan_policy) + "' does not exist.")

        try:
            scan_response = scan_asset(ip_address, scan_policy)

            # Condense Scan data for HumanReadable and EntryContext:
            scan_output = {}
            low_ip = str(scan_response['adhoc_targets'][0]['ip_address_range']['low_ip_address'])
            high_ip = str(scan_response['adhoc_targets'][0]['ip_address_range']['high_ip_address'])
            if low_ip == high_ip:
                scan_headers = ['scan-id', 'name', 'ip-address', 'policy']
                scan_output['ip-address'] = scan_response['adhoc_targets'][0]['ip_address_range']['low_ip_address']
            else:
                scan_headers = ['scan-id', 'name', 'ip-address-range', 'Policy']
                scan_output['ip-address-range'] = low_ip + "-" + high_ip

            scan_output['scan-id'] = scan_response.get('id')
            scan_output['name'] = scan_response.get('name')
            scan_output['policy'] = scan_response.get('scan_policy')

            # Linking Context
            ec = {
                'FrontlineVM(val.Scan && val.Scan == obj.Scan)':{
                    'Scan':scan_output
                }
            }
            output = {
                'Type': entryTypes['note'], # War room
                'Contents':scan_response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('FrontlineVM: Performing Scan', scan_output, headers=scan_headers, removeNull=True),
                'EntryContext': ec
            }
            return output
        except Exception as err:
            return_error('Error performing scan. Exception: ' + str(err))


    def test_module():
        try:
            session_url = FVM_URL + "/api/session/"
            resp = requests.get(session_url, headers={'Authorization':'Token '+str(API_TOKEN)})
            if resp.status_code == 200:
                demisto.results('ok')
            else:
                demisto.error("Test method failed. User has invalid API Token.")
                demisto.results('Test failed, invalid API Token.')
            resp.raise_for_status()
        except Exception as err:
            demisto.results('Test Failed: ' + str(err))


    ''' EXECUTION CODE  '''
    def main():
        LOG('command is %s' % (demisto.command(), ))
        try:
            if demisto.command() == 'test-module':
                test_module()
            if demisto.command() == 'frontline-get-assets':
                demisto.results(get_assets_command())
            if demisto.command() == 'frontline-get-vulns':
                demisto.results(get_vulns_command())
            if demisto.command() == 'frontline-scan-asset':
                demisto.results(scan_asset_command())
            if demisto.command() == 'fetch-incidents':
                fetch_incidents()
        except Exception as e:
            LOG(e)
            LOG.print_log(verbose=False)
            return_error(e.message)


    # python2 uses __builtin__ python3 uses builtins
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  type: python
  commands:
  - name: frontline-get-assets
    arguments:
    - name: ip_address
      description: Get assets for given IP Address
    - name: label_name
      description: Get assets with given label name (put name in quotes if spaces
        are required).
    - name: scanned_within_last
      auto: PREDEFINED
      predefined:
      - "1"
      - "7"
      - "30"
      - "60"
      - "90"
      - "180"
      description: Get hosts scanned within the given range (in days)
    - name: hostname
      description: Get asset for given hostname
    outputs:
    - contextPath: FrontlineVM.Hosts
      description: Returned host data pulled from Frontline.Cloud
      type: unknown
    - contextPath: FrontlineVM.IPList
      description: IP address list of found hosts.
      type: unknown
    - contextPath: FrontlineVM.HostId
      description: ID number of Host pulled
    description: Pull asset information from FrontlineVM
  - name: frontline-get-vulns
    arguments:
    - name: min_severity
      auto: PREDEFINED
      predefined:
      - critical
      - high
      - medium
      - low
      - trivial
      - info
      description: Select a minimum severity level of vulnerabilities to pull from
        Frontline. E.g. setting the min_severity=medium will pull all vulnerabilities
        with severity levels of medium, high, and critical.
    - name: severity
      auto: PREDEFINED
      predefined:
      - critical
      - high
      - medium
      - low
      - trivial
      - info
      description: Will pull all vulnerabilities from Frontline with this severity.
    - name: days_older_than
      auto: PREDEFINED
      predefined:
      - "30"
      - "60"
      - "90"
      - "180"
      - "365"
      description: Will pull vulnerabilities first found older than the given input
        (in days from now).
    - name: days_newer_than
      auto: PREDEFINED
      predefined:
      - "1"
      - "7"
      - "30"
      - "60"
      - "90"
      description: Will pull vulnerabilities first found to be newer than the given
        input (in days from now).
    - name: host_id
      description: Pull vulnerabilities from specific host given the host ID.
    - name: ip_address
      description: IP address of host to pull vulnerability data from.
    outputs:
    - contextPath: FrontlineVM.Vulns
      description: Returned vulnerability data pulled from Frontline.Cloud
      type: unknown
    - contextPath: FrontlineVM.IPList
      description: IP address list of found vulnerabilities.
      type: unknown
    - contextPath: FrontlineVM.Stat
      description: Statistic overview of vulnerabilities pulled.
    description: Pull vulnerability information from FrontlineVM
  - name: frontline-scan-asset
    arguments:
    - name: ip_address
      required: true
      description: IP address of asset to perform scan. To scan a range of ip addresses,
        first enter the low ip address and then a high ip address separated by a hyphen.
        E.g. 192.168.1.1-192.168.1.10
    - name: scan_policy
      description: Policy of scan (case sensitive)
      defaultValue: Default
    outputs:
    - contextPath: FrontlineVM.Scan
      description: The response output of requested scan to perform.
    description: Performs a scan on a given asset.
  isfetch: true
  runonce: false
