commonfields:
  id: ThreatX
  version: -1
name: ThreatX
display: ThreatX
category: Network Security
image: data:image/jpeg;base64,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
description: The ThreatX integration allows automated enforcement and intel gathering
  actions.
detaileddescription: |-
  Please enter your Customer Name and API Key provided by the ThreatX SOC. You can request your Customer Name and API Key by opening a support ticket via support@threatx.com.

  Set the DBot Score Threshold to a number between 1 and 100 (default is 70). Any IP addresses associated with an Entity queried with a ThreatX score greater than or equal to the DBot Score Threshold will be assigned a DBot Score of 3 (Malicious).
configuration:
- display: Customer Name
  name: customer_name
  defaultvalue: ""
  type: 0
  required: true
- display: API Key
  name: api_key
  defaultvalue: ""
  type: 4
  required: true
- display: URL
  name: url
  defaultvalue: https://provision.threatx.io
  type: 0
  required: true
- display: DBot Score Threshold
  name: dbot_threshold
  defaultvalue: "70"
  type: 0
  required: true
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |
    ''' IMPORTS '''
    import time
    from operator import itemgetter
    import requests

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    CUSTOMER_NAME = demisto.params().get('customer_name', None)
    API_KEY = demisto.params().get('api_key', None)
    URL = demisto.params().get('url', None)

    if URL[-1] != '/':
        URL += '/'

    BASE_URL = URL + 'tx_api/v1'
    DBOT_THRESHOLD = int(demisto.params().get('dbot_threshold', 70))
    USE_SSL = not demisto.params().get('insecure')

    ''' HELPER FUNCTIONS '''
    def http_request(url_suffix, commands=None):
        state = demisto.getIntegrationContext()

        if not state.get('session_token'):
            session_token = None
            token_expires = None
        else:
            session_token = state.get('session_token')
            token_expires = state.get('token_expires')

        if url_suffix != '/login':
            demisto.info('running request with url=%s with commands=%s' % (BASE_URL + url_suffix, commands))
            data = {
                'token': session_token,
                'customer_name': CUSTOMER_NAME
            }
        else:
            demisto.info('running request with url=%s' % (BASE_URL + url_suffix))
            data = {}

        if commands is not None:
            data.update(commands)

        res = requests.request('POST',
                               BASE_URL + url_suffix,
                               verify=USE_SSL,
                               json=data)

        if res.status_code != requests.codes.ok:
            if url_suffix == '/login':
                demisto.setIntegrationContext({'session_token': None,
                                               'token_expires': None
                                               })
                demisto.info(str(res.status_code) + ' from server during login. Clearing session token cache.')

            return_error('HTTP %s Error in API call to ThreatX service - %s' % (res.status_code, res.text))

        if not res.text:
            resp_json = {}

        resp_json = res.json()

        if 'Ok' not in resp_json:
            if url_suffix == '/login':
                demisto.setIntegrationContext({'session_token': None,
                                               'token_expires': None
                                               })
                return_error('Login response error - %s. Clearing session token cache.' % (res.text))

            return_error(res.text)

        if url_suffix == '/login':
            if 'status' in resp_json['Ok']:
                if resp_json['Ok']['status'] is not True:
                    demisto.setIntegrationContext({'session_token': None,
                                                   'token_expires': None
                                                   })
                    return_error('Invalid credentials. Clearing session token cache.')

        return resp_json['Ok']

    @logger
    def initialize():
        endpoint = '/login'
        commands = {
            'command': 'login',
            'api_token': API_KEY
        }

        state = demisto.getIntegrationContext()

        if not state.get('session_token'):
            session_token = None
            token_expires = None
        else:
            session_token = state.get('session_token')
            token_expires = state.get('token_expires')

        demisto.info('Initializing request...')

        if session_token is None or token_expires < int(time.time()):
            if session_token is None:
                demisto.info('Session token missing - getting new session token...')
            elif token_expires < int(time.time()):
                demisto.info('Session token expired - getting new session token...')

            r = http_request(endpoint, commands)
            demisto.setIntegrationContext({'session_token': r['token'],
                                           'token_expires': int(time.time() + (10 * 60))
                                           })
            return

        demisto.info('Cached session token not expired.')
        return

    def pretty_ip(decimal_ip):
        """Convert decimal ip to dotted quad notation"""
        return '.'.join([str(decimal_ip >> (i << 3) & 0xFF) for i in range(4)[::-1]])

    def pretty_time(input_time):
        """Convert unix epoch time to human readable format"""
        return time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(input_time))

    def set_dbot_score(threatx_score):
        """Set the DBot Score based on the ThreatX risk score"""
        if threatx_score >= DBOT_THRESHOLD:
            return 3
        elif threatx_score > 10:
            return 2
        else:
            return 0

    ''' FUNCTIONS '''
    @logger
    def block_ip(ip):
        commands = {
            'command': 'new_blocklist',
            'entry': {
                'ip': ip,
                'description': 'Added by ThreatX Demisto Integration',
                'created': int(time.time())
            }
        }

        return http_request('/lists', commands)

    @logger
    def block_ip_command():
        ip = demisto.args().get('ip', None)
        results = block_ip(ip)

        md = tableToMarkdown('Block IP',
                             results,
                             ['Result'],
                             removeNull=True)

        ec = {
            'IP.Address(val.Id == obj.Id)': ip
        }

        return_outputs(md, ec, results)

    @logger
    def unblock_ip(ip):
        commands = {
            'command': 'delete_blocklist',
            'ip': ip
        }

        return http_request('/lists', commands)

    @logger
    def unblock_ip_command():
        ip = demisto.args().get('ip', None)
        results = unblock_ip(ip)

        md = tableToMarkdown('Unblock IP',
                             results,
                             ['Result'],
                             removeNull=True)

        ec = {
            'IP.Address(val.Id == obj.Id)': ip
        }

        return_outputs(md, ec, results)

    @logger
    def blacklist_ip(ip):
        commands = {
            'command': 'new_blacklist',
            'entry': {
                'ip': ip,
                'description': 'Added by ThreatX Demisto Integration',
                'created': int(time.time())
            }
        }

        return http_request('/lists', commands)

    @logger
    def blacklist_ip_command():
        ip = demisto.args().get('ip', None)
        results = blacklist_ip(ip)

        md = tableToMarkdown('Blacklist IP',
                             results,
                             ['Result'],
                             removeNull=True)

        ec = {
            'IP.Address(val.Id == obj.Id)': ip
        }

        return_outputs(md, ec, results)

    @logger
    def unblacklist_ip(ip):
        commands = {
            'command': 'delete_blacklist',
            'ip': ip
        }

        return http_request('/lists', commands)

    @logger
    def unblacklist_ip_command():
        ip = demisto.args().get('ip', None)
        results = unblacklist_ip(ip)

        md = tableToMarkdown('Unblacklist IP',
                             results,
                             ['Result'],
                             removeNull=True)

        ec = {
            'IP.Address(val.Id == obj.Id)': ip
        }

        return_outputs(md, ec, results)

    @logger
    def whitelist_ip(ip):
        commands = {
            'command': 'new_whitelist',
            'entry': {
                'ip': ip,
                'description': 'Added by ThreatX Demisto Integration',
                'created': int(time.time())
            }
        }

        return http_request('/lists', commands)

    @logger
    def whitelist_ip_command():
        ip = demisto.args().get('ip', None)
        results = whitelist_ip(ip)

        md = tableToMarkdown('Whitelist IP',
                             results,
                             ['Result'],
                             removeNull=True)

        ec = {
            'IP.Address(val.Id == obj.Id)': ip
        }

        return_outputs(md, ec, results)

    @logger
    def unwhitelist_ip(ip):
        commands = {
            'command': 'delete_whitelist',
            'ip': ip
        }

        return http_request('/lists', commands)

    @logger
    def unwhitelist_ip_command():
        ip = demisto.args().get('ip', None)
        results = unwhitelist_ip(ip)

        md = tableToMarkdown('Unwhitelist IP',
                             results,
                             ['Result'],
                             removeNull=True)

        ec = {
            'IP.Address(val.Id == obj.Id)': ip
        }

        return_outputs(md, ec, results)

    @logger
    def get_entities(entity_name, entity_id, entity_ip):
        commands = {
            'command': 'list',
            'query': {}
        }

        if entity_name is not None:
            entity_names = entity_name.split(',')
            my_entity_name = {'codenames': entity_names}
            commands['query'].update(my_entity_name)

        if entity_id is not None:
            entity_ids = entity_id.split(',')
            my_entity_id = {'entity_ids': entity_ids}
            commands['query'].update(my_entity_id)

        if entity_ip is not None:
            entity_ips = entity_ip.split(',')
            my_entity_ip = {'ip_addresses': entity_ips}
            commands['query'].update(my_entity_ip)

        return http_request('/entities', commands)

    @logger
    def get_entity_risk(entity_id):
        commands = {
            'command': 'risk_changes',
            'id': entity_id
        }

        return http_request('/entities', commands)

    @logger
    def get_entities_command():
        entity_name = demisto.args().get('entity_name', None)
        entity_id = demisto.args().get('entity_id', None)
        entity_ip = demisto.args().get('entity_ip', None)
        results = get_entities(entity_name, entity_id, entity_ip)
        md = []
        dbot_scores = []
        ip_enrich = []
        output = []

        for entity in results:
            # Grab the entity risk so we can set the Dbot score for the Actor IPs
            e_id = entity['id']
            e_risk = get_entity_risk(e_id)

            if isinstance(e_risk, list):
                if 'risk' in e_risk[-1]:
                    e_risk = e_risk[-1]['risk']
                else:
                    e_risk = 0
            else:
                e_risk = 0

            entity['risk'] = e_risk

            iplist = []

            if 'actors' in entity:
                for actor in entity['actors']:
                    # Convert decimal IP to dotted quad
                    if 'ip_address' in actor:
                        ipdot = pretty_ip(actor['ip_address'])
                        iplist.append(ipdot)
                        actor['ip_address'] = ipdot

                    # Convert interval_time_start, interval_time_stop, fingerprint.last_seen to pretty time format
                    try:
                        actor['interval_time_start'] = pretty_time(actor['interval_time_start'])
                    except:
                        pass

                    try:
                        actor['interval_time_stop'] = pretty_time(actor['interval_time_stop'])
                    except:
                        pass

                    try:
                        actor['fingerprint']['last_seen'] = pretty_time(actor['fingerprint']['last_seen'])
                    except:
                        pass

                    # Set Dbot score
                    dbscore = set_dbot_score(e_risk)

                    dbot_scores.append({
                        'Vendor' : 'ThreatX',
                        'Indicator' : ipdot,
                        'Type' : 'ip',
                        'Score' : dbscore
                    })

                    if dbscore == 3:
                        ip_enrich.append({
                            'Malicious': {
                                'Data': ipdot,
                                'Vendor': 'ThreatX',
                                'Description': 'ThreatX risk score is ' + str(e_risk)
                            }
                        })

            md.append({'Name': entity['codename'],
                       'ID': entity['id'],
                       'IP Addresses': str(", ".join(iplist)),
                       'ThreatX Risk Score': e_risk,
                       'DBot Score': dbscore
                       })

            ec = {
                'Threatx.Entity(val.ID && val.ID == obj.ID)': {
                    'ID': entity['id'],
                    'Name': entity['codename'],
                    'IP': iplist,
                    'Risk': e_risk
                },
                'DBotScore': dbot_scores,
                'IP': ip_enrich
            }

            output.append({
                'Type': entryTypes['note'],
                "HumanReadable": tableToMarkdown('Entities', md),
                'ContentsFormat': formats['json'],
                'Contents': entity,
                'EntryContext': ec})

        if output:
            demisto.results(output)
        else:
            return_outputs('No Entities Returned', None)

    @logger
    def get_entity_notes(entity_id):
        commands = {
            'command': 'notes',
            'id': entity_id
        }

        return http_request('/entities', commands)

    @logger
    def get_entity_notes_command():
        entity_id = demisto.args().get('entity_id', None)
        results = get_entity_notes(entity_id)

        # Reverse sort the list by timestamp
        sorted_results = sorted(results, key=itemgetter('timestamp'), reverse=True)

        # Replace dates with pretty format
        for note in sorted_results:
            if 'timestamp' in note:
                note['timestamp'] = pretty_time(note['timestamp'])

        md = tableToMarkdown('Entity Notes',
                             sorted_results,
                             headerTransform=string_to_table_header)

        ec = {
            'Threatx.Entity(val.ID && val.ID == obj.ID)': {
                'ID': entity_id,
                'Note': sorted_results
            }
        }

        return_outputs(md, ec, sorted_results)

    @logger
    def add_entity_note(entity_id, message):
        commands = {
            'command': 'new_note',
            'note': {
                'entity_id': entity_id,
                'content': message
            }
        }

        return http_request('/entities', commands)

    @logger
    def add_entity_note_command():
        entity_id = demisto.args().get('entity_id', None)
        message = demisto.args().get('message', None)
        results = add_entity_note(entity_id, message)

        md = tableToMarkdown('New Entity Note',
                             results,
                             ['Result'],
                             removeNull=True)

        return_outputs(md, None, results)

    @logger
    def test_module():
        commands = {
            'command': 'list'
        }

        return http_request('/users', commands)

    @logger
    def test_module_command():
        results = test_module()

        if isinstance(results, list):
            if 'username' in results[0]:
                demisto.results('ok')
        else:
            return_error('Unable to parse the List Users response.')

    ''' EXECUTION CODE '''
    handle_proxy()
    initialize()
    demisto.info('command is %s' % (demisto.command(),))
    try:
        if demisto.command() == 'test-module':
            test_module_command()
        elif demisto.command() == 'threatx-block-ip':
            block_ip_command()
        elif demisto.command() == 'threatx-unblock-ip':
            unblock_ip_command()
        elif demisto.command() == 'threatx-blacklist-ip':
            blacklist_ip_command()
        elif demisto.command() == 'threatx-unblacklist-ip':
            unblacklist_ip_command()
        elif demisto.command() == 'threatx-whitelist-ip':
            whitelist_ip_command()
        elif demisto.command() == 'threatx-unwhitelist-ip':
            unwhitelist_ip_command()
        elif demisto.command() == 'threatx-get-entities':
            get_entities_command()
        elif demisto.command() == 'threatx-get-entity-notes':
            get_entity_notes_command()
        elif demisto.command() == 'threatx-add-entity-note':
            add_entity_note_command()

    except Exception as e:
        return_error(e.message)
  type: python
  commands:
  - name: threatx-block-ip
    arguments:
    - name: ip
      required: true
      description: IP address or CIDR (e.g. 10.1.1.1 or 10.1.1.0/24)
    outputs:
    - contextPath: IP.Address
      description: IP address or CIDR blocked
      type: string
    description: Temporarily block an IP or CIDR
    execution: true
  - name: threatx-unblock-ip
    arguments:
    - name: ip
      required: true
      description: IP address or CIDR (e.g. 10.1.1.1 or 10.1.1.0/24)
    outputs:
    - contextPath: IP.Address
      description: IP address or CIDR unblocked
    description: Unblock a blocked IP or CIDR
    execution: true
  - name: threatx-blacklist-ip
    arguments:
    - name: ip
      required: true
      description: IP address or CIDR (e.g. 10.1.1.1 or 10.1.1.0/24)
    outputs:
    - contextPath: IP.Address
      description: IP address or CIDR blacklisted
      type: string
    description: Add an IP or CIDR to the Blacklist
    execution: true
  - name: threatx-unblacklist-ip
    arguments:
    - name: ip
      required: true
      description: IP address or CIDR (e.g. 10.1.1.1 or 10.1.1.0/24)
    outputs:
    - contextPath: IP.Address
      description: IP address or CIDR unblacklisted
      type: string
    description: Remove an IP or CIDR from the Blacklist
    execution: true
  - name: threatx-whitelist-ip
    arguments:
    - name: ip
      required: true
      description: IP address or CIDR (e.g. 10.1.1.1 or 10.1.1.0/24)
    outputs:
    - contextPath: IP.Address
      description: IP address or CIDR whitelisted
      type: string
    description: Add an IP or CIDR to the Whitelist
    execution: true
  - name: threatx-unwhitelist-ip
    arguments:
    - name: ip
      required: true
      description: IP address or CIDR (e.g. 10.1.1.1 or 10.1.1.0/24)
    outputs:
    - contextPath: IP.Address
      description: IP address or CIDR unwhitelisted
      type: string
    description: Remove an IP or CIDR from the Whitelist
    execution: true
  - name: threatx-get-entities
    arguments:
    - name: entity_name
      description: One or more comma separated Entity names
    - name: entity_id
      description: One or more comma separated Entity ID hashes
    - name: entity_ip
      description: One or more comma separated Entity IP addresses
    outputs:
    - contextPath: Threatx.Entity.ID
      description: ID hash of the Entity
      type: string
    - contextPath: Threatx.Entity.Name
      description: Name of the Entity
      type: string
    - contextPath: Threatx.Entity.IP
      description: IP address of the Entity
      type: string
    description: 'Get high-level Entity information via the Entity ID, Entity Name,
      or Entity IP. Example: !threatx-get-entities entity_name=CynicalGraaf,MJ12Bot
      entity_id= 566056709675514809 entity_ip=12.12.12.12,14.14.14.14'
  - name: threatx-get-entity-notes
    arguments:
    - name: entity_id
      required: true
      description: ID hash of the Entity
    outputs:
    - contextPath: Threatx.Entity.Notes
      description: Notes attached to the Entity
      type: number
    description: Get the notes attached to an Entity by Entity ID
  - name: threatx-add-entity-note
    arguments:
    - name: entity_id
      required: true
      description: ID hash of the Entity
    - name: message
      required: true
      description: Contents of the note
    description: 'Add a new note to the Entity. Example: !threatx-add-entity-note
      entity_id=566056709695514809 message="test note"'
    execution: true
  runonce: false
