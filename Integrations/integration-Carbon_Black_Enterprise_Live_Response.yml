commonfields:
  id: carbonblackliveresponse
  version: -1
name: carbonblackliveresponse
display: Carbon Black Enterprise Live Response
category: Endpoint
image: data:image/png;base64,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/GMzLdsAAHfXaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmlsbHVzdHJhdG9yPSJodHRwOi8vbnMuYWRvYmUuY29tL2lsbHVzdHJhdG9yLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcFRQZz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3QvcGcvIgogICAgICAgICAgICB4bWxuczpzdERpbT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL0RpbWVuc2lvbnMjIgogICAgICAgICAgICB4bWxuczp4bXBHPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvZy8iCiAgICAgICAgICAgIHhtbG5zOnBkZj0iaHR0cDovL25zLmFkb2JlLmNvbS9wZGYvMS4zLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8ZGM6dGl0bGU+CiAgICAgICAgICAgIDxyZGY6QWx0PgogICAgICAgICAgICAgICA8cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPmNvbG9yIHdvcmtfcG1zLWNteWs8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6QWx0PgogICAgICAgICA8L2RjOnRpdGxlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE1LTA0LTE2VDEwOjAwOjU3LTA0OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNS0wNC0xNlQxMDowMDo1Ny0wNDowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTA1LTA4VDEzOjUxOjUzLTA0OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmJjZTg0MTNiLTg1N2YtNGE1Ny1iZDBlLTc4MWZhOTYxYWI4ZTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjVjZDJmZWUwLTI0NDQtMTE3OC1iNjhhLTg5ZGUyMjA5MTFhZjwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD51dWlkOjVEMjA4OTI0OTNCRkRCMTE5MTRBODU5MEQzMTUwOEM4PC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpSZW5kaXRpb25DbGFzcz5wcm9vZjpwZGY8L3htcE1NOlJlbmRpdGlvbkNsYXNzPgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjQwMjE3Y2YyLWQ2NmQtNDVjNC1iN2IwLWE5ZTU2NTRhM2NkNjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDo0MDIxN2NmMi1kNjZkLTQ1YzQtYjdiMC1hOWU1NjU0YTNjZDY8L3N0UmVmOmRvY3VtZW50SUQ+CiAgICAgICAgICAgIDxzdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+dXVpZDo1RDIwODkyNDkzQkZEQjExOTE0QTg1OTBEMzE1MDhDODwvc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICAgICA8c3RSZWY6cmVuZGl0aW9uQ2xhc3M+cHJvb2Y6cGRmPC9zdFJlZjpyZW5kaXRpb25DbGFzcz4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOkY3N0YxMTc0MDcyMDY4MTE4MjJBRjgwN0MzN0NGOUFFPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTA1LTA3VDExOjU1OjEyLTA0OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBJbGx1c3RyYXRvciBDUzU8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOkY4N0YxMTc0MDcyMDY4MTE4MjJBQjc1ODJGQzc0OUI2PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTA1LTA4VDExOjE0OjI1LTA0OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBJbGx1c3RyYXRvciBDUzU8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE4MjJBQjc1ODJGQzc0OUI2PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTA1LTA4VDEzOjUxOjUzLTA0OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBJbGx1c3RyYXRvciBDUzU8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi9wb3N0c2NyaXB0IHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5pbGx1c3RyYXRvcjwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNvbnZlcnRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6cGFyYW1ldGVycz5mcm9tIGFwcGxpY2F0aW9uL3Bvc3RzY3JpcHQgdG8gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcDwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NDAyMTdjZjItZDY2ZC00NWM0LWI3YjAtYTllNTY1NGEzY2Q2PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE1LTA0LTE2VDEwOjAwOjU3LTA0OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNvbnZlcnRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6cGFyYW1ldGVycz5mcm9tIGFwcGxpY2F0aW9uL3Bvc3RzY3JpcHQgdG8gaW1hZ2UvcG5nPC9zdEV2dDpwYXJhbWV0ZXJzPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+ZGVyaXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6cGFyYW1ldGVycz5jb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6YmNlODQxM2ItODU3Zi00YTU3LWJkMGUtNzgxZmE5NjFhYjhlPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE1LTA0LTE2VDEwOjAwOjU3LTA0OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8aWxsdXN0cmF0b3I6U3RhcnR1cFByb2ZpbGU+UHJpbnQ8L2lsbHVzdHJhdG9yOlN0YXJ0dXBQcm9maWxlPgogICAgICAgICA8eG1wVFBnOkhhc1Zpc2libGVPdmVycHJpbnQ+VHJ1ZTwveG1wVFBnOkhhc1Zpc2libGVPdmVycHJpbnQ+CiAgICAgICAgIDx4bXBUUGc6SGFzVmlzaWJsZVRyYW5zcGFyZW5jeT5GYWxzZTwveG1wVFBnOkhhc1Zpc2libGVUcmFuc3BhcmVuY3k+CiAgICAgICAgIDx4bXBUUGc6TlBhZ2VzPjE8L3htcFRQZzpOUGFnZXM+CiAgICAgICAgIDx4bXBUUGc6TWF4UGFnZVNpemUgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3REaW06dz4xMS4wMDAwMDA8L3N0RGltOnc+CiAgICAgICAgICAgIDxzdERpbTpoPjguNTAwMDAwPC9zdERpbTpoPgogICAgICAgICAgICA8c3REaW06dW5pdD5JbmNoZXM8L3N0RGltOnVuaXQ+CiAgICAgICAgIDwveG1wVFBnOk1heFBhZ2VTaXplPgogICAgICAgICA8eG1wVFBnOlBsYXRlTmFtZXM+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpPkN5YW48L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT5NYWdlbnRhPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+QmxhY2s8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcFRQZzpQbGF0ZU5hbWVzPgogICAgICAgICA8eG1wVFBnOlN3YXRjaEdyb3Vwcz4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8eG1wRzpncm91cE5hbWU+RGVmYXVsdCBTd2F0Y2ggR3JvdXA8L3htcEc6Z3JvdXBOYW1lPgogICAgICAgICAgICAgICAgICA8eG1wRzpncm91cFR5cGU+MDwveG1wRzpncm91cFR5cGU+CiAgICAgICAgICAgICAgICAgIDx4bXBHOkNvbG9yYW50cz4KICAgICAgICAgICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpzd2F0Y2hOYW1lPldoaXRlPC94bXBHOnN3YXRjaE5hbWU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1vZGU+Q01ZSzwveG1wRzptb2RlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp0eXBlPlBST0NFU1M8L3htcEc6dHlwZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj4wLjAwMDAwMDwveG1wRzpjeWFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptYWdlbnRhPjAuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjAuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+Qz0wIE09MCBZPTAgSz03MCAxPC94bXBHOnN3YXRjaE5hbWU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1vZGU+Q01ZSzwveG1wRzptb2RlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp0eXBlPlBST0NFU1M8L3htcEc6dHlwZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj4wLjAwMDAwMDwveG1wRzpjeWFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptYWdlbnRhPjAuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjcwLjAwMDAwMDwveG1wRzpibGFjaz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpzd2F0Y2hOYW1lPkJsYWNrPC94bXBHOnN3YXRjaE5hbWU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1vZGU+Q01ZSzwveG1wRzptb2RlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp0eXBlPlBST0NFU1M8L3htcEc6dHlwZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj4wLjAwMDAwMDwveG1wRzpjeWFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptYWdlbnRhPjAuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjEwMC4wMDAwMDA8L3htcEc6YmxhY2s+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgICAgICAgICAgIDwveG1wRzpDb2xvcmFudHM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHhtcEc6Z3JvdXBOYW1lPlBNUyBjb2xvcnM8L3htcEc6Z3JvdXBOYW1lPgogICAgICAgICAgICAgICAgICA8eG1wRzpncm91cFR5cGU+MTwveG1wRzpncm91cFR5cGU+CiAgICAgICAgICAgICAgICAgIDx4bXBHOkNvbG9yYW50cz4KICAgICAgICAgICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpzd2F0Y2hOYW1lPkM9NjcgTT0yIFk9MCBLPTAgMTwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5QUk9DRVNTPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+NjcuMDAwMDAwPC94bXBHOmN5YW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1hZ2VudGE+MS45OTk5OTg8L3htcEc6bWFnZW50YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6eWVsbG93PjAuMDAwMDAwPC94bXBHOnllbGxvdz4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6YmxhY2s+MC4wMDAwMDA8L3htcEc6YmxhY2s+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6c3dhdGNoTmFtZT5DPTg2IE09OCBZPTAgSz0wIDE8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bW9kZT5DTVlLPC94bXBHOm1vZGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnR5cGU+UFJPQ0VTUzwveG1wRzp0eXBlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpjeWFuPjg1Ljk5OTk5MjwveG1wRzpjeWFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptYWdlbnRhPjcuOTk5OTk4PC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjAuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+Qz01MSBNPTc5IFk9MCBLPTAgMTwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5QUk9DRVNTPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+NTEuMDAwMDAwPC94bXBHOmN5YW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1hZ2VudGE+NzkuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjAuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+Qz03MiBNPTk5IFk9MCBLPTMgMTwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5QUk9DRVNTPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+NzIuMDAwMDAwPC94bXBHOmN5YW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1hZ2VudGE+OTguOTk5OTkyPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjIuOTk5OTk3PC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+Qz0wIE09NjEgWT05NyBLPTAgMTwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5QUk9DRVNTPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+MC4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT42MS4wMDAwMDA8L3htcEc6bWFnZW50YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6eWVsbG93Pjk3LjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjAuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+Qz0wIE09ODIgWT05NCBLPTIgMTwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5QUk9DRVNTPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+MC4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT44Mi4wMDAwMDA8L3htcEc6bWFnZW50YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6eWVsbG93Pjk0LjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjEuOTk5OTk4PC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+Qz0wIE09MzIgWT0xMDAgSz0wIDE8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bW9kZT5DTVlLPC94bXBHOm1vZGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnR5cGU+UFJPQ0VTUzwveG1wRzp0eXBlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpjeWFuPjAuMDAwMDAwPC94bXBHOmN5YW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1hZ2VudGE+MzIuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4xMDAuMDAwMDAwPC94bXBHOnllbGxvdz4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6YmxhY2s+MC4wMDAwMDA8L3htcEc6YmxhY2s+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6c3dhdGNoTmFtZT5DPTAgTT01MSBZPTEwMCBLPTAgMTwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5QUk9DRVNTPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+MC4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT41MS4wMDAwMDA8L3htcEc6bWFnZW50YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6eWVsbG93PjEwMC4wMDAwMDA8L3htcEc6eWVsbG93PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpibGFjaz4wLjAwMDAwMDwveG1wRzpibGFjaz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgICAgICAgICAgPC94bXBHOkNvbG9yYW50cz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8eG1wRzpncm91cE5hbWU+Q01ZSyBjb2xvcnM8L3htcEc6Z3JvdXBOYW1lPgogICAgICAgICAgICAgICAgICA8eG1wRzpncm91cFR5cGU+MTwveG1wRzpncm91cFR5cGU+CiAgICAgICAgICAgICAgICAgIDx4bXBHOkNvbG9yYW50cz4KICAgICAgICAgICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpzd2F0Y2hOYW1lPlBBTlRPTkUgMjk4IEM8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5TUE9UPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnRpbnQ+MTAwLjAwMDAwMDwveG1wRzp0aW50PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj42OS4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT43LjAwMDAwMDwveG1wRzptYWdlbnRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp5ZWxsb3c+MC4wMDAwMDA8L3htcEc6eWVsbG93PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpibGFjaz4wLjAwMDAwMDwveG1wRzpibGFjaz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpzd2F0Y2hOYW1lPlBBTlRPTkUgMjk5IEM8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5TUE9UPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnRpbnQ+MTAwLjAwMDAwMDwveG1wRzp0aW50PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj44NS4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT4xOS4wMDAwMDA8L3htcEc6bWFnZW50YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6eWVsbG93PjAuMDAwMDAwPC94bXBHOnllbGxvdz4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6YmxhY2s+MC4wMDAwMDA8L3htcEc6YmxhY2s+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6c3dhdGNoTmFtZT5QQU5UT05FIDI1OCBDPC94bXBHOnN3YXRjaE5hbWU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnR5cGU+U1BPVDwveG1wRzp0eXBlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp0aW50PjEwMC4wMDAwMDA8L3htcEc6dGludD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bW9kZT5DTVlLPC94bXBHOm1vZGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+NDIuOTk5OTk2PC94bXBHOmN5YW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1hZ2VudGE+NzYuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjAuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+UEFOVE9ORSAyNjAzIEM8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5TUE9UPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnRpbnQ+MTAwLjAwMDAwMDwveG1wRzp0aW50PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj42OS4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT4xMDAuMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4wLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjIuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+UEFOVE9ORSAxNTg1IEM8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5TUE9UPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnRpbnQ+MTAwLjAwMDAwMDwveG1wRzp0aW50PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj4wLjAwMDAwMDwveG1wRzpjeWFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptYWdlbnRhPjU2LjAwMDAwMDwveG1wRzptYWdlbnRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp5ZWxsb3c+OTAuMDAwMDAwPC94bXBHOnllbGxvdz4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6YmxhY2s+MC4wMDAwMDA8L3htcEc6YmxhY2s+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6c3dhdGNoTmFtZT5QQU5UT05FIDE3MyBDPC94bXBHOnN3YXRjaE5hbWU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnR5cGU+U1BPVDwveG1wRzp0eXBlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp0aW50PjEwMC4wMDAwMDA8L3htcEc6dGludD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bW9kZT5DTVlLPC94bXBHOm1vZGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmN5YW4+MC4wMDAwMDA8L3htcEc6Y3lhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6bWFnZW50YT42OS4wMDAwMDA8L3htcEc6bWFnZW50YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6eWVsbG93PjEwMC4wMDAwMDA8L3htcEc6eWVsbG93PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpibGFjaz40LjAwMDAwMDwveG1wRzpibGFjaz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpzd2F0Y2hOYW1lPlBBTlRPTkUgMTMwIEM8L3htcEc6c3dhdGNoTmFtZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dHlwZT5TUE9UPC94bXBHOnR5cGU+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnRpbnQ+MTAwLjAwMDAwMDwveG1wRzp0aW50PgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptb2RlPkNNWUs8L3htcEc6bW9kZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6Y3lhbj4wLjAwMDAwMDwveG1wRzpjeWFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzptYWdlbnRhPjMwLjAwMDAwMjwveG1wRzptYWdlbnRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp5ZWxsb3c+MTAwLjAwMDAwMDwveG1wRzp5ZWxsb3c+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOmJsYWNrPjAuMDAwMDAwPC94bXBHOmJsYWNrPgogICAgICAgICAgICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnN3YXRjaE5hbWU+UEFOVE9ORSAxNDQgQzwveG1wRzpzd2F0Y2hOYW1lPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzp0eXBlPlNQT1Q8L3htcEc6dHlwZT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6dGludD4xMDAuMDAwMDAwPC94bXBHOnRpbnQ+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1vZGU+Q01ZSzwveG1wRzptb2RlPgogICAgICAgICAgICAgICAgICAgICAgICAgICA8eG1wRzpjeWFuPjAuMDAwMDAwPC94bXBHOmN5YW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOm1hZ2VudGE+NDguMDAwMDAwPC94bXBHOm1hZ2VudGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4bXBHOnllbGxvdz4xMDAuMDAwMDAwPC94bXBHOnllbGxvdz4KICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhtcEc6YmxhY2s+MC4wMDAwMDA8L3htcEc6YmxhY2s+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgICAgICAgICAgIDwveG1wRzpDb2xvcmFudHM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wVFBnOlN3YXRjaEdyb3Vwcz4KICAgICAgICAgPHBkZjpQcm9kdWNlcj5BZG9iZSBQREYgbGlicmFyeSA5LjkwPC9wZGY6UHJvZHVjZXI+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjE1MDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjE1MDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MTUwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI1PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg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
description: Collect information and take action on remote endpoints in real time
  with Carbon Black Enterprise Live Response.
detaileddescription: "Use Live Response for Cb Defense or Cb Response.\n\nFor Cb Defense:\nProvide
  server URL,  'Live Response' API key and connector. \n\nFor Cb Response:\nProvide
  server URL and API Token.\n\n\nWhen running Live Response commands (e.g. 'cb-process-kill'),
  it is possible to pass 'wait-timeout' argument to determine the number of seconds
  to wait for the command to be executed on Live Response side. Once the command has
  been executed or wait-time has expired - the command information will be returned
  to the war room. \nDefault 'wait-time' is 20 seconds.\n"
configuration:
- display: Server URL
  name: serverurl
  defaultvalue: ""
  type: 0
  required: true
- display: API Token (CB Response)
  name: apitoken
  defaultvalue: ""
  type: 4
  required: false
- display: API Key (CB Defense)
  name: apikey
  defaultvalue: ""
  type: 4
  required: false
- display: Connector ID (CB Defense)
  name: connector
  defaultvalue: ""
  type: 0
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |-
    "use strict";

    /// Global Vars
    let CB_PRODUCT;
    let BASE_URL;
    let AUTH;
    let COMMAND_DATA;
    let SLEEP_BETWEEN_RETRIES = 1000 * 5;
    let DEFAULT_WAIT_TIMEOUT = 1000 * 60 * 2;
    let ERROR_MESSAGE = 'Use Live Response for Cb Defense or Cb Response.\nFor Cb Defense: Provide \'Live Response\' API key and connector.\nFor Cb Response: Provide API Token.';
    //validate the credentials are provided to match only one of the products
    if (params.apitoken && (params.apikey || params.connector) ) {
        throw ERROR_MESSAGE;
    }
    //determain Cb product
    if (params.apitoken) {
        CB_PRODUCT = 'Response';
        BASE_URL = `${params.serverurl}/api/v1/cblr`;
        AUTH = params.apitoken;
        COMMAND_DATA = [
            {to: 'CbSensorID', from: 'sensor_id'},
            {to: 'CbSessionID', from: 'session_id'},
            {to: 'CbCommandID', from: 'id'},
            {to: 'CommandName', from: 'name'},
            {to: 'Status', from: 'status'},
            {to: 'CreateTime', from: 'create_time'},
            {to: 'CommandCompletionTime', from: 'completion'},
            {to: 'OperandObject', from: 'object'},
            {to: 'Result.Desc', from: 'result_desc'},
            {to: 'Result.Type', from: 'result_type'},
            {to: 'Result.Code', from: 'result_code'}
        ];
    } else if (params.apikey && params.connector){
        CB_PRODUCT = 'Defense';
        BASE_URL = `${params.serverurl}/integrationServices/v3/cblr`
        AUTH = params.apikey + '/' + params.connector;
        COMMAND_DATA = [
            {to: 'CbSensorID', from: 'sensor_id'},
            {to: 'CbSessionID', from: 'session_id'},
            {to: 'CbCommandID', from: 'id'},
            {to: 'CommandName', from: 'name'},
            {to: 'Status', from: 'status'},
            {to: 'CreateTime', from: 'create_time'},
            {to: 'CommandCompletionTime', from: 'completion_time'},
            {to: 'OperandObject', from: 'obj.object'},
            {to: 'Result.Desc', from: 'result_desc'},
            {to: 'Result.Type', from: 'result_type'},
            {to: 'Result.Code', from: 'result_code'}
        ];
    } else {
        throw ERROR_MESSAGE;
    }

    /// Base Functions

    function splitCamelCase(str) {
        return str
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace('.', ' ');
    }

    function sendRequest(path, method, requestParams, headers, ignoredStatusCodes) {

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [AUTH];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: method,
            Headers: headers
        };
        let querystring = '';
        if (requestParams) {
            if (typeof requestParams === 'string') {
                querystring = requestParams;
            } else {
                request.Body = JSON.stringify(requestParams);
            }
        }
        let result = http(BASE_URL + path + querystring, request, params.insecure, params.proxy);

        if (!ignoredStatusCodes || ignoredStatusCodes.indexOf(result.StatusCode) === -1) {
            if (result.StatusCode < 200 || result.StatusCode >= 300) {
                if (result.StatusCode === 404) {
                    throw `Cannot find the requested resource\nError message: ${result.Body}\nStatus Code: 404`;
                }
                throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${result.Body}.`;
            }
        }
        return result;
    }

    function sendFileRequest(path, fileId, requestParams, headers, ignoredStatusCodes) {

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [AUTH];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: 'POST',
            Headers: headers
        };

        let result = httpMultipart(BASE_URL + path, fileId, request, requestParams, params.insecure, params.proxy);

        if (result.StatusCode < 200 || result.StatusCode >= 300) {
            if (result.StatusCode === 404) {
                throw `${result.Body} (Status Code: 404)`;
            }
            throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${JSON.stringify(result.Body)}`;
        }
        return result;
    }

    function createEntry(title, data, dataMap, contextKeys, headerTransformer) {
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(data);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, headerTransformer);
        let contextData = createContext(translatedData);
        let context = {};
        for (let i = 0 ; i < contextKeys.length; i++) {
            let key = contextKeys[i];
            context[key] = contextData;
        }
        return {
            Type: entryTypes.note,
            Contents: data,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }

    /// Cb Live Response Session

    function testModule() {
        let res = sendRequest('/session', 'GET');
        if (res.StatusCode === 200) {
            return 'ok';
        }
        // 405 - Method Not Allowed.
        // This error can raise when using CB Defence; This URL (which is used to list sessions) is theoretically not available for CB Defence. In practice it works for some cases.
        // 401 is the status code used for 'UNAUTHORIZED' error
        if (CB_PRODUCT === 'Defense' && res.StatusCode === 405) {
            return 'ok';
        }
        return `Test failed. Status Code: ${res.StatusCode}`
    }

    const sessionData = [
        {to: 'CbSensorID', from: 'sensor_id'},
        {to: 'CbSessionID', from: 'id'},
        {to: 'Hostname', from: 'hostname'},
        {to: 'Status', from: 'status'},
        {to: 'WaitTimeout', from: 'sensor_wait_timeout'},
        {to: 'SessionTimeout', from: 'session_timeout'},
        {to: 'SupportedCommands', from: 'supported_commands'}
    ];

    function getSessionsRequest(sessionId, sensorId, status) {
        let path = `/session`;
        if (sessionId) {
            path += '/' + sessionId;
        }

        let response = sendRequest(path, 'GET').Body;
        let result;
        try {
            result = JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }

        // If optional sensor argument is given, filter the results by it.
        if (!sessionId && sensorId) {
            sensorId = parseInt(sensorId);
            result = result.filter(session => (parseInt(session.sensor_id) === sensorId));
        }
        if (!sessionId && status) {
            result = result.filter(session => (status.indexOf(session.status) > -1));
        }

        return result;
    }

    function getSessions() {
        let result = getSessionsRequest(args.session, args.sensor, args.status);

        let title = `Cb ${CB_PRODUCT} - Get Sessions`;
        let dataMap = sessionData;
            //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    function createSessionRequest(sensorId, commandTimeout, keepaliveTimeout) {
        let queryParams = {
            sensor_id: parseInt(sensorId)
        };
        if (commandTimeout) {
            queryParams.session_timeout = keepaliveTimeout;
        }
        if (keepaliveTimeout) {
            queryParams.sensor_wait_timeout = commandTimeout;
        }
        let path = CB_PRODUCT === 'Response' ?  '/session' : `/session/${sensorId}`;
        let response = sendRequest(path, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function createSession() {
        let result = createSessionRequest(args.sensor, args['command-timeout'], args['keepalive-timeout']);

        let title = `CB ${CB_PRODUCT} - Create Session`;
        let dataMap = sessionData;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    function createSessionAndWait() {
        let result = createSessionRequest(args.sensor, args['command-timeout'], args['keepalive-timeout']);
        sleep(1000);
        let sessionId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT ;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getSessionsRequest(sessionId, args.sensor);
            let status = result.status.toLowerCase()
            if (status === 'active' ) {
                let title = `CB ${CB_PRODUCT} - Create Session And Wait`;
                let dataMap = sessionData;
                //keep CbResponse context for backward competability
                let contextKeys = [
                    'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
                    'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
                ];
                return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
            } else if (status !== 'pending') {
                throw `Executing session ${sessionId} failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Exceeded timeout.\nNew session for sensor ${args.sensor} was created with ID: ${sessionId}.\nSession status remains '${result.status}'. Wait for session to become active (you may query for session staus with 'cb-session-info').\nIt is recomended to increase wait-timeout for this command.`;
    }

    function closeSessionRequest(sessionId) {
        let queryParams = {
            session_id: sessionId
        };
        queryParams.status = CB_PRODUCT === 'Response' ? 'close' : 'CLOSE';
        let path = CB_PRODUCT === 'Response' ? `/session/${sessionId}` : '/session';
        let response = sendRequest(path, 'PUT', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function closeSession() {
        let result = closeSessionRequest(args.session);
        let title = `CB ${CB_PRODUCT} - Session Closed`;
        let dataMap = sessionData;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
        ];
        // cb response - session will have 'active' value for 'status' field although status is 'closed'
        if (CB_PRODUCT === 'Response') {
            // retrieving closed session info returns inconsistent results (expected to return the updated info with correct status, but in practice this may return an error)
            // do not try to retrieve updated session info, simply change the session status in the result to avoid confusion
            // see https://developer.carbonblack.com/reference/enterprise-response/6.1/live-response-api/#close-sessions
            result.status = 'close'
        }
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    function sessionKeepaliveRequest(sessionId) {
        let response = sendRequest(`/session/${sessionId}/keepalive`, 'GET', undefined, undefined, [404]);

        if (response.StatusCode === 404) {
            throw `Session ${sessionId} has expired and is now closed. Create a new session to continue working.`;
        }

        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }

    function sessionKeepAlive() {
        let result = sessionKeepaliveRequest(args.session);

        let translatedData = mapObjFunction(sessionData)(result);
        let contextData = createContext(translatedData);
        //keep CbResponse context for backward competability
        let context = {
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': contextData,
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)': contextData
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: `Keepalive successful for session ${args.session}`,
            EntryContext: context,
        };
    }

    function archiveSessionRequest(sessionId) {
        let response = sendRequest(`/session/${sessionId}/archive`, 'GET', undefined, undefined, [500]);
        if (response.StatusCode === 500) {  // Current bug in CBResponse returns 500 for empty sessions
            throw `Session ${sessionId} is empty and so it has no archive.`;
        }
        return response;
    }

    function archiveSession() {
        let response = archiveSessionRequest(args.session);
        let fileEntryId = saveFile(response.Bytes);
        let fileName = `session-${args.session}-archive.zip`;
        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: fileName,
            Contents: fileName
        };
    }
    /// Cb Live Response file operations

    const fileData = [
        {to: 'CbFileID', from: 'id'},
        {to: 'Filename', from: 'file_name'},
        {to: 'Size', from: 'size'},
        {to: 'SizeUploaded', from: 'size_uploaded'},
        {to: 'Status', from: 'status'},
        {to: 'Delete', from: 'delete'}
    ];

    function listFilesRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        let path = `/session/${sessionId}/file`;
        if (fileId) {
            path += '/' + fileId;
        }

        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function listFiles() {
        let result = listFilesRequest(args.session, args['file-id']);

        let title = `CB ${CB_PRODUCT} - List Files`;
        let dataMap = fileData;
        //keep CbResponse context for backward competability
         let contextKeys = [
            'CbResponse.Files(val.CbFileID==obj.CbFileID)',
            'CbLiveResponse.Files(val.CbFileID==obj.CbFileID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    function downloadFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let path = `/session/${sessionId}/file/${fileId}/content`;
        return sendRequest(path, 'GET');
    }

    function downloadFileEntry(sessionId, fileId) {
        let fileInfo = listFilesRequest(sessionId, fileId);
        let fileContentResponse = downloadFileRequest(sessionId, fileId);
        let fileEntryId = saveFile(fileContentResponse.Body);
        let fileName = fileInfo.file_name.split('\\').pop();
        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: fileName,
            Contents: fileInfo.file_name
        };
    }

    function downloadFile() {
        return downloadFileEntry(args['session'], args['file-id']);
    }

    function uploadFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let response = sendFileRequest(`/session/${sessionId}/file`, fileId);
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function uploadFile() {
        let result = uploadFileRequest(args.session, args['file-id']);

        let title = `CB ${CB_PRODUCT} - Upload File`;
        let dataMap = fileData;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Files(val.CbFileID==obj.CbFileID)',
            'CbLiveResponse.Files(val.CbFileID==obj.CbFileID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    function deleteFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let path = `/session/${sessionId}/file/${fileId}`;
        let response = sendRequest(path, 'DELETE').Body;
    }

    function deleteFile() {
        deleteFileRequest(args.session, args['file-id']);
        return {
            Type: entryTypes.note,
            Contents: `File ${args['file-id']} deleted successfully`,
            ContentsType: formats.text
        };
    }

    /// Cb Live Response Commands

    //generic  function to create a new command
    function createCommandRequest(sessionId, name, timeout, object, compress, wait, workingDir, outputFile, valueData,
                                  valueType, overwrite, offset, getCount) {
        let queryParams = {
            name: name.split('-').join(' ')
        };
        if (timeout) {
            queryParams.timeout = timeout;
        }
        if (object) {
            queryParams.object = object;
        }
        if (compress) {
            queryParams.compress = compress;
        }
        queryParams.wait = true;
        if (wait !== undefined && wait === false) {
            queryParams = wait;
        }
        if (workingDir) {
            queryParams.working_directory = workingDir;
        }
        if (outputFile) {
            queryParams.output_file = outputFile;
        }
        if (valueData) {
            queryParams.value_data = valueData;
        }
        if (valueType) {
            queryParams.value_type = valueType;
        }
        if (overwrite) {
            queryParams.overwrite = overwrite;
        }
        if (offset) {
            queryParams.offset = offset;
        }
        if (getCount) {
            queryParams.get_count = getCount;
        }

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    //TODO: Spec for commands interface
    function createCommand() {
        let result = createCommandRequest(args.session, args.name, args.timeout, args.object, args.compress, args.wait,
            args['working-dir'], args['output-file'], args['value-data'], args['value-type'], args.overwrite, args.offset,
            args['get-count']);

        let title = `CB Response - Run Command ${args.name}`;
        let dataMap = COMMAND_DATA;
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)',
            'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'
        ];
        return createEntry(title, command, dataMap, contextKeys, splitCamelCase);
    }

    function getCommandRequest(sessionId, commandId) {
        let path = `/session/${sessionId}/command/${commandId}`;
        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function getCommandsRequest(sessionId) {
        let path = `/session/${sessionId}/command`;
        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function getCommands() {
        let result = getCommandsRequest(args.session);
        let title = `CB ${CB_PRODUCT} - Get Commands`;
        let dataMap = COMMAND_DATA;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)',
            'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    function createCommandAndWait() {
        let result = createCommandRequest(args.session, args.name, args.timeout, args.object, args.compress, args.wait,
            args['working-dir'], args['output-file'], args['value-data'], args['value-type'], args.overwrite, args.offset,
            args['get-count']);
        sleep(1000);
        let commandId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getCommandRequest(args.session, commandId);

            if (result.status === 'complete') {
                let entries = [];
                let title = 'CB Response - Execute Command And Wait';
                let dataMap = COMMAND_DATA;
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
                };
                entries.push({
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context
                });

                // If we have the command in args then we get info for the command,
                // in this case we want to parse the result:
                let contents = result;
                switch (result.name) {
                    case "directory list":
                        contents = result.files;
                        break;
                    case "process list":
                        contents = result.processes;
                        break;
                }
                logInfo("Here2");
                entries.push({
                    Type: entryTypes.note,
                    Contents: contents,
                    ContentsType: formats.json,
                    // TODO: Add human readable and context for specific commands
                });

                return entries;

            } else if (result.status !== 'pending') {
                throw `Executing command ${commandId} failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Executing command ${commandId} timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }

    function cancelCommandRequest(sessionId, commandId) {
        let queryParams = {cmdid: commandId};
        let response = sendRequest(`/session/${sessionId}/command/${commandId}`, 'PUT', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function cancelCommand() {
        let result = cancelCommandRequest(args.session, args.command);

        let title = `CB ${CB_PRODUCT} - Cancel Command`;
        let dataMap = COMMAND_DATA;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)',
            'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }

    /// Explicit Commands

    const directoryData = [
        {to: 'FileAttributes', from: 'attributes'},
        {to: 'CreateTime', from: 'create_time'},
        {to: 'LastAccessTime', from: 'last_access_time'},
        {to: 'LastWriteTime', from: 'last_write_time'},
        {to: 'FileSize', from: 'size'},
        {to: 'FileName', from: 'filename'},
        {to: 'AlternativeName', from:'alt_name'}
    ];

    const processesData = [
        {to: 'ProcessID', from: 'pid'},
        {to: 'CreateTime', from: 'create_time'},
        {to: 'ProcessGuid', from: 'proc_guid'},
        {to: 'Path', from: 'path'},
        {to: 'CommandLine', from: 'command_line'},
        {to: 'SecurityIdentifier', from: 'sid'},
        {to: 'Username', from: 'username'},
        {to: 'Parent', from: 'parent'},
        {to: 'ParentGuid', from: 'parent_guid'}
    ];

    const processData = [
        {to: 'ProcessID', from: 'pid'},
        {to: 'ReturnCode', from: 'return_code'}
    ];

    const memdumpData = [
        {to: 'ReturnCode', from: 'return_code'},
        {to: 'CompressingEnabled', from: 'compressing'},
        {to: 'Complete', from: 'complete'},
        {to: 'PercentDone', from: 'percentdone'},
        {to: 'DumpingInProgress', from: 'dumping'}
    ];

    const regKeysData = [
        {to: 'RegKeyType', from: 'value_type'},
        {to: 'RegKeyName', from: 'value_name'},
        {to: 'RegKeyData', from: 'value_data'}
    ];

    const regKeyData = [
        {to: 'RegKeyType', from: 'value.value_type'},
        {to: 'RegKeyName', from: 'value.value_name'},
        {to: 'RegKeyData', from: 'value.value_data'}
    ];

    function collectRegistryDataToGeneralContext(data) {
        let regKey = CB_PRODUCT === 'Response' ?  data.object : data.obj.object;
        let RegistryKeys = [];
        for (let value of data.values) {
            let entry = {
                Path: regKey,
                Name: value.value_name,
                Value: value.value_data
            };
            RegistryKeys.push(entry);
        }
        return RegistryKeys;
    };

    const commandEntries = {
        'directory list' : function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Directory Listing: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            if (data.status !== 'complete') {
                return commandInfoEntry;
            }
            //create entry to hold directory data
            dataMap = directoryData;
            title = `CB ${CB_PRODUCT} - Directory Listing`;
            contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID).Files'];
            let directoryListEntry = createEntry(
                title,
                data.files,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return [commandInfoEntry, directoryListEntry];
        },
        'put file': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Push File: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'get file': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Get File From Path ${args.path}: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            if (data.status === 'complete') {
                dataMap.push({to: 'FileID', from: 'file_id'});
            }
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'kill': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Kill Process ${args.pid}: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'create process' : function(data) {
            let dataMap = COMMAND_DATA;
            if (data.status === 'complete') {
                dataMap = dataMap.concat(processData);
            }
            let title = `CB ${CB_PRODUCT} - Execute Process: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'memdump': function(data) {
            let dataMap = COMMAND_DATA;
            if (data.status === 'complete') {
                dataMap = dataMap.concat(memdumpData);
            }
            let title = `CB ${CB_PRODUCT} - Memdump: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'delete file': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Delete File From Endpoint: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg enum key': function(data) {
            let dataMap =  COMMAND_DATA;
            if (data.status === 'complete'){
                dataMap.push({to: 'SubKeys', from: 'sub_keys'});
            }
            let commandData = mapObjFunction(dataMap)(data);
            let commandMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - Registry Keys: Command Status`,
                commandData,
                dataMap.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            if (data.status !== 'complete' || !data.values) {
                return {
                    Type: entryTypes.note,
                    Contents: data,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: commandMD,
                    EntryContext: {
                        'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)': commandData
                    }
                };
            }

            let registryEntry = mapObjFunction(regKeysData)(data.values);
            let registryMD = tableToMarkdown(
                `Registry Values`,
                registryEntry,
                regKeysData.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            //collect registry data for general context
            let generalConetxt = collectRegistryDataToGeneralContext(data);

            return {
                Type: entryTypes.note,
                Contents: data,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: commandMD + '\n\n' + registryMD,
                EntryContext: {
                    'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)': commandEntry,
                    'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID).Values': registryEntry,
                    'RegistryKey': generalConetxt
                }
            };
        },
         'reg query value': function(data) {
            let dataMap = COMMAND_DATA;
            if (data.status === 'complete') {
                dataMap = dataMap.concat(regKeyData);
            }
            let commandData = mapObjFunction(dataMap)(data);
            let commandMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - Query Registry Value: Command Status`,
                commandData,
                dataMap.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            let context = {
                'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)': commandData
            };
            if (data.status !== 'complete') {
                context.RegistryKey = collectRegistryDataToGeneralContext(data);
            }
            return {
                Type: entryTypes.note,
                Contents: data,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: commandMD,
                EntryContext: context
            };
        },
         'reg create key': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Create Registry Key: Command Status`;;
            let contextKeys = ['CbLiveResponse(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg delete key': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Create Registry Key: Command Status`;;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg delete values': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Delete Registry Value: Command Status`;;
            let contextKeys =  ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg set values': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Delete Registry Value: Command Status`;;
            let contextKeys =  ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'process list' : function(data) {
            let commandData = mapObjFunction(COMMAND_DATA)(data);
            let commandMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - List Processes: Command Status`,
                commandData,
                COMMAND_DATA.map(cn => cn.to),
                undefined,
                splitCamelCase
            );
            if (data.status !== 'complete') {
                return {
                    Type: entryTypes.note,
                    Contents: data,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: commandMD,
                    EntryContext: {
                       'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)': commandData
                    }
                };
            }
            let processes = mapObjFunction(processesData)(data.processes);
            let processesMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - Processes`,
                processes,
                processesData.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            // collect processes data for general context
            let processesCollection = [];
            for (let process of data.processes) {
                processesCollection.push({
                    'PID': process.pid,
                    'CommandLine': process.command_line,
                    'Path': process.path,
                    'Start Time': process.create_time,
                    'Parent': process.parent
                });
            }

            return {
                Type: entryTypes.note,
                Contents: data,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: commandMD + '\n\n' + processesMD,
                EntryContext: {
                    'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)': commandData,
                    'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID).Process': processes,
                    'Process': processesCollection
                }
            };
        }
    };

    function getCommand() {
        let command = getCommandRequest(args.session, args.command);
        if (commandEntries[command.name]){
            return commandEntries[command.name](command);
        }
        //create generic entry
        let title = `CB ${CB_PRODUCT} - Get Command`;
        let dataMap = COMMAND_DATA;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)',
            'CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID)'
        ];
        return createEntry(
            title,
            result,
            dataMap,
            contextKeys,
            splitCamelCase
        );
    }

    function getCommandInfo(sessionId, commandId, timeout, timeInterval, cancelOnPending) {
        let retries = timeout ? Math.ceil(timeout / timeInterval) : 1;
        //loop to get command info. Stop when command status is no longer 'pending' or when exeeded wait-time.
        let result;
        let curTry = 0;
        while (curTry < retries) {
            result = getCommandRequest(sessionId, commandId);
            if (result.status !== 'pending') {
                return result;
            }
            curTry++;
            sleep(timeInterval);
        }
        if (cancelOnPending && cancelOnPending === 'yes') {
            cancelCommandRequest(sessionId, commandId);
            throw 'Wait-time expired. Canceled command';
        }
        return result;
    }

    function terminateProcess() {
        let result = createCommandRequest(args.session, 'kill', undefined, args.pid, undefined, args.wait);
        sleep(1000);
        let commandId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getCommandRequest(args.session, commandId);
            if (result.status === 'complete') {
                let title = `CB Response - Terminate Process ${args.pid}`;
                let dataMap = COMMAND_DATA;
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Commands(val.CbCommandID==obj.CbCommandID)': createContext(translatedData)
                };
                return {
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context,
                };
            } else if (result.status !== 'pending') {
                throw `Terminating process failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Terminating process timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }

    function putFileRequest(sessionId, fileId, path) {
        let queryParams = {
            name: 'put file',
            object: path,
            file_id: fileId
        };

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function putFile() {
        let fileInfo = uploadFileRequest(args['session'], args['entry-id']);
        let result = putFileRequest(args['session'], fileInfo.id, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES);
        let commandEntry = commandEntries['put file'](command);
        //add entry to hold gile information
        let title = `CB ${CB_PRODUCT} - File Info`;
        let dataMap = fileData;
        let contextKeys = ['CbLiveResponse.Files(val.CbFileID==obj.CbFileID)'];
        let fileInfoEntry = createEntry(
            title,
            fileInfo,
            dataMap,
            contextKeys,
            splitCamelCase
        );
        return [commandEntry, fileInfoEntry];
    }

    function getFileRequest(sessionId, path, offset, bytes)   {
        let queryParams = {
            name: 'get file',
            object: path,
            offset: offset,
            get_count: bytes
        };

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function getFile() {
        let command = directoryListRequest(args.session, args.path);
        let commandId = command.id;
        try {
            command = getCommandInfo(args.session, commandId, DEFAULT_WAIT_TIMEOUT, SLEEP_BETWEEN_RETRIES);
        }
        catch(err) {
            throw "Failed to get information on the file";
        }
        //throw JSON.stringify(fileInfo,null,'\t');
        if (command.status === 'error') {
            throw 'File not found on the endpoint';
        }
        let file = command.files[0];
        let result = getFileRequest(args.session, args.path, 0, file.size);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        let commandEntry = commandEntries['get file'](command);

        if (command.status !== 'complete') {
            return commandEntry;
        }
        //download the file from Cb server and add file entry to the war room
        let fileEntry = downloadFileEntry(args['session'], command['file_id']);
        return [commandEntry, fileEntry];
    }

    function directoryListRequest(sessionId, path)   {
        let queryParams = {
            name: 'directory list',
            object: path
        };

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function directoryList() {
        let result = directoryListRequest(args['session'], args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = args['wait-timeout'] ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['directory list'](command);
    }

    function processKillRequest(sessionId, pid) {
        let queryParams = {
            name: 'kill',
            object: pid
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    //equivalent to 'terminateProcess' function
    function processKill() {
        let result = processKillRequest(args['session'], args.pid);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['kill'](command);
    }

    function processExecRequeste(sessionId, path, wait, workingDirectory, outputFile) {
        let queryParams = {
            name: 'create process',
            object: path
        };
        if (wait !== undefined) {
            queryParams.wait = wait;
        }
        if (workingDirectory) {
            queryParams.working_directory = workingDirectory;
        }
        if (outputFile) {
            queryParams.output_file = outputFile;
        }

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function processExec() {
        if (args.wait) {
            args.wait = args.wait === 'yes';
        }
        let result = processExecRequeste(args['session'], args.path, args['working-directory'], args['output-file']);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['create process'](command);
    }

    function memdumpRequest(sessionId, path, commpress) {
        let queryParams = {
            name: 'memdump',
            object: path
        };
        if (commpress) {
            queryParams.commpress = commpress;
        }
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function memedump() {
        if (commpress) {
            args.commpress = args.commpress === 'yes';
        }
        let result = memdumpRequest(args['session'], args.path, args.commpress);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['memedump'](command);
    }

    function deleteFileFromEndpointRequest(sessionId, path){
        let queryParams = {
            name: 'delete file',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function deleteFileFromEndpoint() {
        let result = deleteFileFromEndpointRequest(args['session'], args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['delete file'](command);
    }

    function regEnumKeyRequest(sessionId, path){
        let queryParams = {
            name: 'reg enum key',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function regEnumKey() {
        let result = regEnumKeyRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg enum key'](command);
    }

    function regQueryValueRequest(sessionId, path){
        let queryParams = {
            name: 'reg query value',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function regQueryValue() {
        let result = regQueryValueRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg query value'](command);
    }

    function regCreateRequest(sessionId, path){
        let queryParams = {
            name: 'reg create key',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function regCreate() {
        let result = regCreateRequest(args.session, args.path, args.timeout);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg create key'](command);
    }

    function regDeleteKeyRequest(sessionId, path){
        let queryParams = {
            name: 'reg delete key',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function regDeleteKey() {
        let result = regDeleteKeyRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg delete key'](command);
    }

    function regDeleteValueRequest(sessionId, path){
        let queryParams = {
            name: 'reg delete value',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function regDeleteValue() {
        let result = regDeleteValueRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg delete value'](command);
    }

    function regSetValueRequest(sessionId, path, data, type, overwrite){
        let queryParams = {
            name: 'reg set value',
            object: path,
            value_data: data,
            value_type: type
        }
        if (overwrite) {
            queryParams.overwrite = true;
        }
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function regSetValue() {
        if (args.type = 'REG_MULTI_SZ') {
            args.data = args.data.split(',');
        }
        if (args.overwrite) {
            args.overwrite = args.overwrite === 'yes';
        }
        let result = regSetValueRequest(args.session, args.path, args.data, args.type, args.overwrite);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg set value'](command);
    }

    function listProcessesRequest(sessionId, path){
        let queryParams = {
            name: 'process list'
        }
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }

    function listProcesses() {
        let result = listProcessesRequest(args['session'], args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['process list'](command);
    }

    /// Execution

    try {
        switch (command) {
            case 'test-module':
                return testModule();
            case 'cb-list-sessions':
                if (CB_PRODUCT == 'Defense') {
                    throw '\'cb-list-sessions\' is not available for Cb Defense.';
                }
                return getSessions();
            case 'cb-session-info':
                return getSessions();
            case 'cb-session-create':
                return createSession();
            case 'cb-session-create-and-wait':
                return createSessionAndWait();
            case 'cb-session-close':
                return closeSession();
            case 'cb-keepalive':
                return sessionKeepAlive();
            case 'cb-archive':
                if (CB_PRODUCT == 'Defense') {
                    throw '\'cb-archive\' is not available for Cb Defense.';
                }
                return archiveSession();
            case 'cb-list-commands':
                return getCommands();
            case 'cb-command-info':
                return getCommand();
            case 'cb-terminate-process':
                return terminateProcess();
            case 'cb-command-create':
                return createCommand();
            case 'cb-command-create-and-wait':
                return createCommandAndWait();
            case 'cb-command-cancel':
                return cancelCommand();
            case 'cb-file-get':
                return downloadFile();
            case 'cb-list-files':
            case 'cb-file-info':
                return listFiles();
            case 'cb-file-upload':
                return uploadFile();
            case 'cb-file-delete':
                return deleteFile();
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: err.message
        };
    }

    // execute Cb commands
    let closeSessionAfterExecution = false;
    try {
        //validate either sensor or session was passed
        if ((!args.session && !args.sensor) || (args.session && args.sensor)) {
            throw 'Provide either the session ID or the sensor ID';
        }
        if (args.sensor) {
            let session = createSessionRequest(args.sensor);
            let wait = 3 * 1000;
            while (session.status === 'pending' || session.status === 'PENDING') {
                sleep(wait);
                session = getSessionsRequest(session.id);
            }
            if (session.status !== 'active' && session.status !== 'ACTIVE') {
                throw 'Failed to start a new session';
            }
            closeSessionAfterExecution = true;
            args.session = session.id;
        }
        switch (command) {
            case 'cb-process-kill':
                return processKill();
            case 'cb-directory-listing':
                return directoryList();
            case 'cb-process-execute':
                return processExec();
            case 'cb-memdeump':
                return memdump();
            case 'cb-file-delete-from-endpoint':
                return deleteFileFromEndpoint();
            case 'cb-registry-get-values':
                return regEnumKey();
            case 'cb-registry-query-value':
                return regQueryValue();
            case 'cb-registry-create-key':
                return regCreate();
            case 'cb-registry-delete-key':
                return regDeleteKey();
            case 'cb-registry-delete-value':
                return regDeleteValue();
            case 'cb-registry-set-value':
                return regSetValue();
            case 'cb-process-list':
                return listProcesses();
            case 'cb-get-file-from-endpoint':
                return getFile();
            case 'cb-push-file-to-endpoint':
                return putFile();
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: err.message
        };
    } finally {
        if (closeSessionAfterExecution) {
            closeSessionRequest(args.session);
        }
    }

    /// Util methods

    function sleep(ms) {
        var start = new Date().getTime();
        var expire = start + ms;
        while (new Date().getTime() < expire) {
            /*Do nothing*/
        }
        return;
    }
  type: javascript
  commands:
  - name: cb-archive
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID to return the archive of
    description: Archive the given session (If the session has no content it will
      fail)
  - name: cb-command-cancel
    arguments:
    - name: session
      required: true
      description: Session ID of command to cancel
    - name: command
      required: true
      description: Command ID to cancel
    outputs:
    - contextPath: CbLiveResponse.Commands.Status
      description: The Command Status
    - contextPath: CbLiveResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbLiveResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbLiveResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory
        list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbLiveResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The time the command completed or 0 if still in progres.
    - contextPath: CbLiveResponse.Commands.Result.Desc
      description: Result description
    - contextPath: CbLiveResponse.Commands.esult.Type
      description: Result type
    - contextPath: CbLiveResponse.Commands.Result.Code
      description: Result code
    description: Cancel the given command. Only pending commands can be canceled.
  - name: cb-command-info
    arguments:
    - name: session
      required: true
      description: Session ID of the command
    - name: command
      required: true
      description: Command ID
    description: Display information on command
  - name: cb-file-delete
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    - name: file-id
      required: true
      description: File ID
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Delete a given file in the session from Cb server.
  - name: cb-file-get
    deprecated: true
    arguments:
    - name: session
      required: true
      description: Session ID
    - name: file-id
      required: true
      description: File ID
    description: Download a file from Cb server in a given session. Use cb-command-create with name=get-file to push the file from a path on the endpint to Cb server before executing cb-file-get.
  - name: cb-file-info
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    - name: file-id
      description: File ID
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Get file info for a given file in a session
  - name: cb-file-upload
    deprecated: true
    arguments:
    - name: session
      required: true
      description: Session ID to upload the file through
    - name: file-id
      required: true
      description: File entry id of an attachment to upload.
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Uploads the file to the Cb server. Use cb-command-create with name=put-file to push the file from Cb server to a path on the endpoint.
  - name: cb-keepalive
    arguments:
    - name: session
      required: true
      default: true
      description: The session ID to keepalive
    description: Keep the session alive to avoid closing due to timeout
  - name: cb-list-commands
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    description: List the CarbonBlack existing commands for a given session
  - name: cb-list-files
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-file-get.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: List files in a given session
  - name: cb-list-sessions
    arguments:
    - name: sensor
      description: Sensor ID to filter sessions by
    - name: status
      auto: PREDEFINED
      predefined:
      - active
      - pending
      - timeout
      - inactive
      - close
      description: 'Status to filter by (One of: active, pending, timeout, inactive,
        close)'
      isArray: true
    outputs:
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    description: List the CarbonBlack sessions
  - name: cb-session-close
    arguments:
    - name: session
      required: true
      description: The session ID to close
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Close the given session
  - name: cb-session-create
    arguments:
    - name: sensor
      required: true
      default: true
      description: Sensor ID to create session for
    - name: command-timeout
      description: Session timeout (If a command will not be issued after this time
        the session will be closed)
    - name: keepalive-timeout
      description: ' the timeout (in seconds) that a device should wait between commands.
        If no command is issued over this timeout the device will quit.'
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Create a new CarbonBlack session for a given sensor
  - name: cb-session-create-and-wait
    arguments:
    - name: sensor
      required: true
      default: true
      description: Sensor ID to create session for
    - name: command-timeout
      description: Session timeout (If a command will not be issued after this time
        the session will be closed)
    - name: keepalive-timeout
      description: Session keepalive timeout (If a keepalive is not issued after this
        time, the session will close)
    - name: wait-timeout
      description: Time in seconds to wait for session to be active
      defaultValue: "20"
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Create a new CarbonBlack session for a given sensor and wait for
      it to be active
  - name: cb-session-info
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID to get info for
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Display session info
  - name: cb-process-kill
    arguments:
    - name: session
      description: 'Session ID. Provide the session ID to run the command with an
        existing session. '
    - name: pid
      required: true
      description: Process ID to terminate
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The process ID.
    description: Terminates a process at the sensor/endpoint
  - name: cb-directory-listing
    arguments:
    - name: session
      description: The session ID.
    - name: path
      required: true
      description: Path for the directory (e.g. "c:\\Users\\"). Note to end with double
        backslash.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.DirectoryList.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: the directory listing filter (or path).
    - contextPath: CbLiveResponse.Commands.Files.FileAttributes
      description: List of file attributes.
    - contextPath: CbLiveResponse.Commands.Files.CreateTime
      description: Create time in unix time format.
    - contextPath: CbLiveResponse.Commands.Files.LastAccessTime
      description: Last access time in unix time format.
    - contextPath: CbLiveResponse.Commands.Files.LastWriteTime
      description: Last write time in unix time format.
    - contextPath: CbLiveResponse.Commands.Files.FileSize
      description: The file size.
    - contextPath: CbLiveResponse.Commands.Files.FileName
      description: The file name.
    description: List directories on the endpoint.
  - name: cb-process-execute
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: the path and command line of the executable
    - name: wait
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: An optional parameter to specify whether to wait for the process
        to complete execution before reporting the result.
    - name: working-directory
      description: An optional parameter to specify the working directory of the executable.
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path and command line of the executable.
    - contextPath: CbLiveResponse.Commands.ReturnCode
      description: the return code of the process (if wait was set to true).
    - contextPath: CbLiveResponse.Commands.ProcessID
      description: The pid of the executed process.
    description: Run executable on the endpoint.
  - name: cb-memdeump
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: the path to save the resulting memory dump (on the endpoint).
    - name: compress
      description: An optional parameter to specify whether to compress resulting
        memory dump.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path to save the resulting memory dump (on the endpoint).
    - contextPath: CbLiveResponse.Commands.ReturnCode
      description: Return code of the memory dump process.
    - contextPath: CbLiveResponse.Commands.CompressingEnabled
      description: Boolean flag indicating if compression is enabled.
    - contextPath: CbLiveResponse.Commands.Complete
      description: Boolean flag indicating if memory dump is completed.
    - contextPath: CbLiveResponse.Commands.PercentDone
      description: Percent of the process completed
    - contextPath: CbLiveResponse.Commands.DumpingInProgress
      description: Boolean flag indicating if memory dump is in progress.
    description: Endpoint memory dump.
  - name: cb-command-create
    arguments:
    - name: name
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - put-file
      - get-file
      - delete-file
      - directory-list
      - reg-enum-key
      - reg-query-value
      - reg-create-key
      - reg-delete-key
      - reg-delete-value
      - reg-set-value
      - process-list
      - kill
      - create-process
      - memdump
      description: Command name
    - name: timeout
      description: Command timeout
    - name: object
      description: the object the command operates on. This is specific to the command
        but has meaning in a generic way for logging, and display purposes
    - name: compress
      description: '"true" or "false" - an optional parameter to specify whether to
        compress resulting memory dump'
    - name: working-dir
      description: An optional parameter to specify the working directory of the executable
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: value-data
      description: the data associated with the registry value
    - name: value-type
      description: the string representation of the registry value type (ie REG_DWORD,
        REG_QWORD, .)
    - name: overwrite
      description: true or false. An optional parameter to specify whether to
        overwrite the value if it already exists (default value is false)
    - name: offset
      description: a byte offset to start getting the file. Supports a partial get.
    - name: get-count
      description: the number of bytes to grab
    - name: session
      required: true
      description: Session ID to create command for
    outputs:
    - contextPath: CbLiveResponse.Commands.Status
      description: The Command Status
    - contextPath: CbLiveResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbLiveResponse.Commands.CbLiveResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbLiveResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory
        list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbLiveResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The time the command completed or 0 if still in progres.
    - contextPath: CbLiveResponse.Commands.Result.Desc
      description: Result description
    - contextPath: CbLiveResponse.Commands.Result.Type
      description: Result type
    - contextPath: CbLiveResponse.Commands.Result.Code
      description: Result code
    description: Create a live response command
  - name: cb-command-create-and-wait
    arguments:
    - name: name
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - put-file
      - get-file
      - delete-file
      - directory-list
      - reg-enum-key
      - reg-query-value
      - reg-create-key
      - reg-delete-key
      - reg-delete-value
      - reg-set-value
      - process-list
      - kill
      - create-process
      - memdump
      description: Command name
    - name: timeout
      description: Command timeout
    - name: object
      description: the object the command operates on. This is specific to the command
        but has meaning in a generic way for logging, and display purposes
    - name: compress
      description: '"true" or "false" - an optional parameter to specify whether to
        compress resulting memory dump'
    - name: working-dir
      description: An optional parameter to specify the working directory of the executable
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: value-data
      description: the data associated with the registry value
    - name: value-type
      description: the string representation of the registry value type (ie REG_DWORD,
        REG_QWORD, .)
    - name: overwrite
      description: true or false. An optional parameter to specify whether to
        overwrite the value if it already exists (default value is false)
    - name: offset
      description: a byte offset to start getting the file. Supports a partial get.
    - name: get-count
      description: the number of bytes to grab
    - name: session
      required: true
      description: Session ID to create command for
    - name: wait-timeout
      description: Time to wait in seconds to wait for command to finish executing
      defaultValue: "20"
    description: Create a live response command and wait for it to finish executing
  - name: cb-terminate-process
    deprecated: true
    arguments:
    - name: session
      required: true
      description: Session ID
    - name: pid
      required: true
      description: Process ID to terminate
    - name: wait-timeout
      description: Time to wait in seconds for process to complete termination
      defaultValue: "20"
    description: Terminates a process at the sensor/endpoint
  - name: cb-file-delete-from-endpoint
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The source path of the object to delete.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The source path of the object to delete.
    description: Delete a file from the endpoint.
  - name: cb-registry-get-values
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key to query
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path of the key to queried.
    - contextPath: CbLiveResponse.Commands.Values.RegKeyType
      description: Registry value type.
    - contextPath: CbLiveResponse.Commands.Values.RegKeyName
      description: the name of the registry value.
    - contextPath: CbLiveResponse.Commands.Values.RegKeyData
      description: The data associated with the registry value.
    - contextPath: CbLiveResponse.Commands.SubKeys
      description: List of subkey names.
    description: Enumerate registry values
  - name: cb-registry-query-value
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key + the path of the value (e.g. HKEY_LOCAL_MACHINE\blah\key\value).
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: the path of the key + the path of the value (ie HKEY_LOCAL_MACHINE\blah\key\value).
    - contextPath: CbLiveResponse.Commands.Registry.QueryValue.Values.RegKeyType
      description: Registry value type.
    - contextPath: CbLiveResponse.Commands.RegKeyName
      description: the name of the registry value.
    - contextPath: CbLiveResponse.Commands.RegKeyData
      description: The data associated with the registry value.
    - contextPath: CbLiveResponse.Commands.SubKeys
      description: List of subkey names.
    description: Query for registry value.
  - name: cb-registry-create-key
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The key path to create.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The key path.
    description: Create a new registry key.
  - name: cb-registry-delete-key
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The key path to delete.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: the key path.
    description: Delete registry key.
  - name: cb-registry-delete-value
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key + the path of the value.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The key path.
    description: Delete registry value.
  - name: cb-registry-set-value
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key + the path of the value.
    - name: data
      required: true
      description: The data to set for the value. Note if the value type REG_MULTI_SZ
        then multiple values should be separated by a comma (e.g. value1, value2,
        value3).
    - name: type
      required: true
      description: One of common registry value types (REG_DWORD, REG_QWORD, REG_SZ
        etc).
    - name: overwrite
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: An optional parameter to specify whether to overwrite the value
        if it already exists (default value is no).
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The key path.
    description: Set registry value.
  - name: cb-process-list
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.Processes.ProcessID
      description: Process ID.
    - contextPath: CbLiveResponse.Commands.Processes.CreateTime
      description: The creation time of the process in unix time.
    - contextPath: CbLiveResponse.Commands.Processes.ProcessGuid
      description: The process guid of the process.
    - contextPath: CbLiveResponse.Commands.Processes.Path
      description: The execution path of the process.
    - contextPath: CbLiveResponse.Commands.Processes.SecurityIdentifier
      description: The Security Identifier (SID) of the default process token.
    - contextPath: CbLiveResponse.Commands.Processes.Username
      description: The username of the default process token.
    - contextPath: CbLiveResponse.Commands.Processes.Parent
      description: The pid (process id ) of the parent.
    - contextPath: CbLiveResponse.Commands.Processes.ParentGuid
      description: The process guid of the parent process.
    description: 'List processes running on the endpoint. '
  - name: cb-get-file-from-endpoint
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The source path of the file.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The source path of the file.
    - contextPath: CbLiveResponse.Commands.FileID
      description: Unique file ID.
    - contextPath: CbLiveResponse.File.Size
      description: File size.
    - contextPath: CbLiveResponse.File.SHA1
      description: File SHA1.
    - contextPath: CbLiveResponse.File.SHA256
      description: File SHA256.
    - contextPath: CbLiveResponse.File.Name
      description: File name.
    - contextPath: CbLiveResponse.File.SSDeep
      description: File SSDeep.
    - contextPath: CbLiveResponse.File.EntryID
      description: File EntryID.
    - contextPath: CbLiveResponse.File.Info
      description: File info.
    - contextPath: CbLiveResponse.File.Type
      description: File type.
    - contextPath: CbLiveResponse.File.MD5
      description: File MD5.
    - contextPath: CbLiveResponse.File.Extension
      description: File extension.
    description: Retrieve a file from a path on the endpoint.
  - name: cb-push-file-to-endpoint
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with
        a new session. The session will be created and closed automatically.
    - name: entry-id
      required: true
      description: The file entry ID.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change
        status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: path
      required: true
      description: The destination path of the file. Include file name and type (e.g.
        "c:\\Users\\USER\\Desktop\\log.txt").
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error',
        'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The destination path of the file.
    description: Save a file to a specific path on the endpoint.
  runonce: false
releaseNotes: "update 'session-create-and-wait' to include more information on failure. fix 'cb-session-close' results to reflect the actual session status for CB Response case "
tests:
  - CarbonBlackLiveResponseTest
