commonfields:
  id: Tanium
  version: -1
name: Tanium
display: Tanium
category: Endpoint
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAiCAYAAACUcR1DAAAEMElEQVR4Ae3aQ5QkaReA4b/Ltusf27Zt27aNzdi2bds227Ztu++8i7u4556KmMyOPFP6Fk/jU0bFW878n4h0YIEbaDVBCByEwEEIHAIHIfDoNdZcAyfgHjyNW3Aw6t3aVhakG7YWN2EQxFmEP3E2cnRPKwvSiXsMJkBS0BWbhhvc+lKNeyEkTbOxW7jJrSuVuPtDltMUrBRudOv5t7ilGAlJ4B1/bkXDyhWoT0OxP8PN19k5t64w7jy3tsisqdKxXDNWiyx0Qa0Zz4s4L8uty9HxGtQbtXEdmK/yby+yEwUmTB7OgyS0bMwaa27iLvg9zEnDtW7/mW5+Ng6LuDmn+vMwAE0trD3brPlWxzY3Y+NQjUIMMeO7xoQZZdZtgGwMctczE7tFnLEGJrv107FG0sA74ldIBjzsLvonSBpuM3vLMRbiDEBBCzfoLAi875Dl1l4IUX/o2FYQNRs1GngiRO0ZEadaY4jaWAOPgzi/I6uFM16AOEuxVtLA12AGxJmAd9N0o7voi/CUehLvQdRCvKzjT6kDzN7rIWoCpkLUebrOf7SLWgYxbnFrL4Co33RsS4iaYQLbSHvEBJ4CURtp4DEQeIe7/ZtiCcRZlInAj2MZxPnQrU2Mi10HoqahKGJdM2ZC1DG4GKKGoyQm8J94H2Ic0YqB5+ELiOqKbLP/E/cZZ1wmAz8J+Y8CbwFR01Efse5eiBqKHFRhBkRdGhP4V1RjuIu2RisFXoJ93FlH6N4dIWqu/n9sJgPfiLkQpweOc3Zze/d083smDcxYkwm5DEebuSsgaiJqIgJ3M483H6L+1PFzljPw7jHfZE2OCqxWde9YfZCLzyHqLuRjWiYDH4BekBT86vZ2dfMvZyDwIxC1GI/iLvUUltobEhG4qxk/DWLcipPTCDw+hcAVusd/kzXGRc/FEIh6AwvMY1ajItOBy3EjJAVfu70/ufndkwTWr9ELISmah9XjAuvc8+4bsK4pBK5FDkZB1KtoRqVRi0vdN3brIccF3lQf5ygIvBt0vi6jgTVUM2YmDPwbshIGftN9E/Z9hBkQ9UwKgQtdVBUbuF7HP4N/p5pmzHLzU1CCwojAXfALxBiNsowHdrEuShB4CbbW8Sj+Z81FaDBzO0CMU2POuRBirIZTIapfC3vWxkyI00Pnt3ZfGhp1fDuNKim6VPeVmlCCzc217A8xzjZz9e6z2BqoxQ5YN+mTDU+mGfgPCM5L8bvo1fGeehkVZu5cvK9zzyAv5pxSvKhrP8Dx2N6cfU/Evv3xnnOHzq1hxl5x17YBHsYP+BPeL3gBe5s9BXjGnLmq/0lBx59Cnhkvx8s69zbqUYYDsWvSwF1wZ1xgszYLn+MsHQva0RP+2+EzLIIYv7nApeHmtu+X7KyNk3ErHsCpOhe078BBCByEwEEIHITAQQgctOvAQQgc/AOlTKJJMlW1twAAAABJRU5ErkJggg==
description: Tanium endpoint security and systems management
configuration:
- display: Host URL (e.g. 1.2.3.4)
  name: host
  defaultvalue: ""
  type: 0
  required: true
- display: Port
  name: port
  defaultvalue: "443"
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    import os
    import sys
    import tempfile
    import pprint
    import traceback
    import json
    import io
    import csv
    from cStringIO import StringIO

    if not demisto.params()['proxy']:
      del os.environ['HTTP_PROXY']
      del os.environ['HTTPS_PROXY']
      del os.environ['http_proxy']
      del os.environ['https_proxy']

    # disable python from generating a .pyc file
    sys.dont_write_bytecode = True

    # change me to the path of pytan
    pytan_loc =  "/pytan-2.2.2"
    pytan_static_path = os.path.join(os.path.expanduser(pytan_loc), 'lib')

    # Determine our script name, script dir
    my_file = os.path.abspath(sys.argv[0])
    my_dir = os.path.dirname(my_file)

    # try to automatically determine the pytan lib directory by assuming it is in '../../lib/'
    parent_dir = os.path.dirname(my_dir)
    pytan_root_dir = os.path.dirname(parent_dir)
    lib_dir = os.path.join(pytan_root_dir, 'lib')

    # add pytan_loc and lib_dir to the PYTHONPATH variable
    path_adds = [lib_dir, pytan_static_path]
    [sys.path.append(aa) for aa in path_adds if aa not in sys.path]

    try:
        import pytan
        import pytan.binsupport
        import taniumpy
    except Exception:
        raise

    def csvstr_to_list(str):
        lines = str.splitlines()
        if len(lines) < 2:
            return []
        else:
            headers = lines[0].split(',')
            return [ dict(zip(headers, line.split(','))) for line in lines[1:] ]

    def parseToJson(handler, response):
        LOG("exporting tanium response")
        export_kwargs = {}
        export_kwargs['obj'] = response
        export_kwargs['export_format'] = 'json'
        out = handler.export_obj(**export_kwargs)
        return json.loads(out)

    def create_error_entry(contents):
        return {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['error'],
            'Contents': "Error - " + contents
        }

    def create_entry(header, table, context = {}, headers = None):
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': table,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(header, table, headers) if table else '### '+ header + '\nNo results were found',
            'EntryContext': context
        }

    def filter_list(lst, keys):
        res = []
        for i in range(len(lst)):
            tmp = {}
            for key in keys:
                tmp[key] = lst[i].get(key)
            res.append(tmp)
        return res

    def getHandler():
        handler_args = {}

        handler_args['username'] = demisto.params()['credentials']['identifier']
        handler_args['password'] = demisto.params()['credentials']['password']
        handler_args['host'] = demisto.params()['host']
        handler_args['port'] = demisto.params()['port']

        handler_args['loglevel'] = 1
        handler_args['debugformat'] = False
        handler_args['record_all_requests'] = True

        return pytan.Handler(**handler_args)

    def getAllObjects(handler, objtype):
        LOG("getting all tanium objects of type %s" % objtype)
        kwargs = {}
        kwargs["objtype"] = objtype
        response = handler.get_all(**kwargs)
        return parseToJson(handler, response)

    def getAllObjectsWithEntry(handler, objtype):
        response = getAllObjects(handler, unicode(objtype))
        parsed = response[objtype]
        return create_entry('Tanium '+objtype+'s', parsed)

    def getAllSensors(handler):
        response = getAllObjects(handler, u'sensor')
        parsed = response.get('sensor')
        return create_entry('Tanium Sensors', parsed, {'Tanium.Sensors' : parsed})

    def getAllSavedActions(handler):
        response = getAllObjects(handler, u'saved_action')
        parsed = response.get('saved_action')
        return create_entry('Tanium Saved Actions', parsed, {'Tanium.SavedActions' : parsed}, ['id', 'name', 'creation_time', 'action_group_id', 'approved_flag'])

    def getAllPendingActions(handler):
        response = getAllObjects(handler, u'saved_action')
        parsed = response.get('saved_action')
        filterNonPending = filter(lambda x: x['approved_flag'] == 0 ,parsed)
        return create_entry('Tanium Pending Actions', filterNonPending, {'Tanium.PendingActions' : filterNonPending}, ['id', 'name', 'creation_time', 'action_group_id', 'approved_flag'])

    def getAllPackages(handler):
        response = getAllObjects(handler, u'package')
        parsed = response.get('package_spec')
        return create_entry('Tanium Packages', parsed, {'Tanium.Packages' : parsed}, ['id', 'name', 'creation_time', 'command', 'last_modified_by'])

    def getAllSavedQuestions(handler):
        response = getAllObjects(handler, u'saved_question')
        parsed = response.get('saved_question')
        return create_entry('Tanium Saved Questions', parsed, {'Tanium.SavedQuestions' : parsed}, ['query_text', 'name', 'id'])

    def getObject(handler, objtype, name=None, id=None):
        LOG("getting Tanium %s - %s" % (objtype, name if name != None else id))
        kwargs = {}
        kwargs["objtype"] = objtype
        kwargs["id"] = id
        kwargs["name"] = name

        response = handler.get(**kwargs)
        return parseToJson(handler, response)

    def parameterTableBuilder(data, header, object_type):
        if not data.get('parameter_definition'):
            return 'No arguments needed for this ' + object_type
        param_data = json.loads(data['parameter_definition']).get('parameters', [])
        parsed_params = []
        parsed_param = {}
        for param in param_data:
            parsed_param['Description'] = param.get('helpString', 'No description')
            parsed_param['Name'] = param.get('label', 'No argument name')
            parsed_param['Values'] = ','.join(param['values']) if param.get('values') else 'Any value'
            parsed_param['Key'] = param.get('key', 'No key')
            parsed_param['Type'] = param['parameterType'].split('::')[-1] if param.get('parameterType') else 'Type not specified'
            parsed_params.append(parsed_param)
            parsed_param = {}
        data['parameters'] = parsed_params
        del data['parameter_definition']
        return tableToMarkdown(header, parsed_params, ['Key','Name', 'Values', 'Description', 'Type'])

    def getSensorVariable(parsed):
        if len(parsed) > 0 and parsed[0].get('command'):
            command = parsed[0].get('command')
            if command:
                idx1 = command.find("||")
                if idx1 > -1:
                    idx2 = command.find("||", idx1+2)
                    if idx2 > -1:
                        return command[idx1:idx2+2]
        return None

    def getPackage(handler):
        response = getObject(handler, u'package', demisto.args().get('name'), demisto.args().get('id'))
        parsed = response.get('package_spec')
        sensor_var = getSensorVariable(parsed)
        res = parsed[0]
        res['sensor_variable'] = sensor_var
        parameters = parameterTableBuilder(res, 'Package Arguments Details', 'package')
        final_result = create_entry(
            'Tanium Package',
            res,
            {'Tanium.Packages(val.id && val.id == obj.id)' : filter_list([res], ['name','id','display_name','command','command_timeout','deleted_flag','files', 'parameters', 'sensor_variable'])},
            ['id', 'name', 'creation_time', 'command', 'last_modified_by']
        )
        final_result['HumanReadable'] += parameters
        if sensor_var is not None:
            final_result['HumanReadable'] += '\n### Sensor Variables Type\n' + sensor_var
        return final_result

    def getSavedQuestion(handler):
        response = getObject(handler, u'saved_question', demisto.args().get('name'), demisto.args().get('id'))
        parsed = response.get('saved_question')
        return create_entry(
            'Tanium Saved Question',
            parsed,
            {'Tanium.SavedQuestions(val.id && val.id == obj.id)' : filter_list(parsed, ['query_text','mod_time','user','name','expire_seconds','id','issue_seconds'])},
            ['query_text', 'name', 'id']
        )

    def getSensor(handler):
        response = getObject(handler, u'sensor', demisto.args().get('name'), demisto.args().get('id'))
        parsed = response.get('sensor', None)
        parameters = parameterTableBuilder(parsed[0], 'Sensor Parameters Details', 'sensor')
        final_result = create_entry(
            'Tanium Sensor - ' + demisto.args()['name'],
            parsed,
            {'Tanium.Sensors(val.id && val.id == obj.id)' : filter_list(parsed, ['id','name','max_age_seconds','description','parameters'])},
            ['id', 'name', 'category', 'description'])
        final_result['HumanReadable'] += '\n' +parameters
        return final_result

    def getAction(handler):
        response = getObject(handler, u'action', demisto.args().get('name'), demisto.args().get('id'))
        parsed = response.get('action', None)
        if 'saved_action' in parsed[0]:
            parsed[0]['saved_action_id'] = parsed[0]['saved_action']['id']
            del parsed[0]['saved_action']

        return create_entry(
            'Tanium Action - ' + parsed[0]['name'],
            parsed,
            {'Tanium.Actions(val.id && val.id == obj.id)' : filter_list(parsed, ['name','id','status','start_time','approver','creation_time','package_spec'])},
            ['id', 'name', 'status', 'saved_action_id', 'stopped_flag'])

    def handle_cgs(handler, obj, kwargs):
        """Example PreAddAction callback that modifies the target_group of an Action if computer group names are supplied.
        callbacks = {}
        callbacks["PreAddAction"] = handle_cgs
        deploy_action(package="blah", cg_names=["ip has 192.168", "has tanium app"], action_filters=["Computer Name, that contains:a"], callbacks=callbacks)
        """
        cgs = kwargs.get("cg_names", [])
        LOG("handling cgs %s" % cgs)
        cg_objs = [handler.get("group", name=x)[0] for x in cgs]
        cg_listobj = taniumpy.GroupList()
        [cg_listobj.append(x) for x in cg_objs]

        if cg_objs:
            tg_obj = taniumpy.Group()
            tg_obj.sub_groups = cg_listobj
            tg_obj.and_flag = 0
            if obj.target_group is not None:
                tg_obj.sub_groups.append(obj.target_group)
            obj.target_group = tg_obj
        return obj

    def parseDeployActionRawResp(handler, response):
        saved_action_object = response.get('saved_action_object')
        action_object = response.get('action_object')
        package_object = response.get('package_object')

        return {
            'saved_action_object' : parseToJson(handler, saved_action_object),
            'action_object' : parseToJson(handler, action_object),
            'package_object' : parseToJson(handler, package_object)
        }

    def deployAction(handler):
        formatted_args = ''

        kwargs = {}
        kwargs["run"] = True

        for key, value in demisto.args().items():
            kwargs[key] = value
        callbacks = {}
        callbacks['PreAddAction'] = handle_cgs
        kwargs['callbacks'] = callbacks
        kwargs['action_options'] = ['or']
        if demisto.get(demisto.args(), 'action_options'):
            kwargs['action_options'] = demisto.args()['action_options'].split(',')
        if demisto.get(demisto.args(), 'action_filters'):
            kwargs['action_filters'] = demisto.args()['action_filters'].split(';')
        if demisto.get(demisto.args(), 'action_filters_groups'):
            kwargs['cg_names'] = demisto.args()['action_filters_groups'].split(',')

        ## Building the package query
        package = demisto.args()['package']
        package_with_args = [package]

        formatted_args = ''
        if demisto.args().get('package_args'):
            package_args = demisto.args().get('package_args', '').split(",")
            for i in range(0, len(package_args)):
                formatted_args = formatted_args + '$'+str(i+1)+'='+package_args[i]+','
            formatted_args = formatted_args[:-1]

        replaceStr = getSensorVariable(getObject(handler, u'package', package).get('package_spec'))
        sensor_var = demisto.args().get('sensor_variables')

        if replaceStr is None and sensor_var:
            return create_error_entry("Package \"" + package + "\" does not have a sensor variable.")
        if replaceStr and sensor_var is None:
            return create_error_entry("Package \"" + package + "\" requires a sensor variable.")

        if sensor_var:
            sensor_vars = demisto.args().get('sensor_variables', '').split(";")
            package_with_args = []
            if formatted_args != '':
                formatted_args+=','
            for var in sensor_vars:
                package_with_args.append(package + '{' + formatted_args + replaceStr +'='+ var+ '}')

        elif formatted_args != '':
            package_with_args = [package + '{' +formatted_args+'}']

        response = []
        for pack in package_with_args:
            kwargs['package'] = pack
            LOG("deploying Tanium package %s" % pack)
            response.append(handler.deploy_action(**kwargs))

        ec = {'Tanium.SavedActions(val.Id && val.Id == obj.Id)':[], 'Tanium.Actions(val.id && val.id == obj.id)':[]}
        contents = []
        tbl = []

        for res in response:
            ec['Tanium.SavedActions(val.Id && val.Id == obj.Id)'].append({
                'Name': res['saved_action_object'].name,
                'Id':res['saved_action_object'].id
            })
            parsed = parseDeployActionRawResp(handler, res)
            ec['Tanium.Actions(val.id && val.id == obj.id)'] += filter_list([parsed['action_object']], ['name','id','status','start_time','approver','creation_time','package_spec'])
            contents.append(parsed)
            tbl.append({
                'Action ID': parsed['action_object']['id'],
                'Saved Action ID': parsed['saved_action_object']['id'],
                'Name': parsed['action_object']['name'],
                'Package Name': parsed['package_object']['name'],
                'Command': parsed['package_object']['command']
            })

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Tanium Deployed Actions', tbl) if tbl else '### '+ header + '\nNo results were found',
            'EntryContext': ec
        }

    def approveSavedAction(handler, action_id, saved_action_id):
        LOG("approving saved action with id %s %s" % (action_id, saved_action_id))
        kwargs = {}
        if not saved_action_id and not action_id:
            raise Exception('Missing action ID')
        if not saved_action_id:
            action = getObject(handler, u'action', id=action_id)
            parsed = action.get('action', None)
            saved_action_id = parsed[0]['saved_action']['id']
        kwargs['id'] = saved_action_id
        response = handler.approve_saved_action(**kwargs)
        parsed = {'Id' : response.id, 'Name': response.name, 'ApprovedFlag': response.approved_flag}
        final_result = create_entry('Action Approval', [parsed], {'Tanium.ActionApproval' : parsed})
        return final_result

    def askQuestion(handler, kwargs):
        response = handler.ask(**kwargs)

        if isinstance(response, str):
            return reponse

        query_text = response['question_object'].query_text
        if response.get('question_results'):
            export_kwargs = {}
            export_kwargs['obj'] = response['question_results']
            export_kwargs['export_format'] = 'csv'
            LOG("exporting tanium question response")
            out = handler.export_obj(**export_kwargs)

            result = csvstr_to_list(out)

            ec = { 'Tanium.QuestionResults' : result }
            return create_entry(
                    'Result for parsed query - %s' % (query_text,),
                    result,
                    ec)
        else:
            return 'Parsed query - %s\nNo results were found' % (query_text,)

    def getParseQueryOptions(handler , question):
        LOG("parsing query options")
        parse_job_results = handler.parse_query(question)
        jsonable = parse_job_results.to_jsonable()

        ans = jsonable["parse_result_group"]
        res = []
        i = 0
        while i < len(ans):
            res.append({"index" : i+1, "question" : ans[i]["question_text"]})
            i = i+1
        return create_entry('Tanium Questions', res, {}, ['index', 'question'])

    def getAskManualHelp():
        desc = '# Tanium Ask Manual Question - Help\n' + \
        'The _tn-ask-manual-question_ command corresponds directly with the Tanium Question Builder.\n' + \
        'Each command argument can be mapped to a field in the Tanium Question Builder.\n' + \
        '## Sensors\n---\n' + \
        'The _sensors_ argument correlates with the **"Get all ____ from..."** part of a the Tanium Question.\n' + \
        'All sensor types share the same filters and sensor options, but each sensor has its own parameters.\n' + \
        '\n' + \
        '**Example** (simple sensor list):\n' + \
        '`!tn-ask-manual-question sensors="Computer Name;IP Address"`\n' + \
        '### Sensor filters\n' + \
        'You can only apply a single filter to a sensor, and should be passed using this format:\n' + \
        '_<sensor1>,that <filter type>:<filter value>;<sensor2>,that <filter type>:<filter value>_\n' + \
        '\n' + \
        '**Example #1** (2 sensors, 2 filters):\n' + \
        '`!tn-ask-manual-question sensors="Computer Name,that starts with:D;IP Address,that does not contain:192"`\n' + \
        '**Example #2** (2 sensors, 1 filter):\n' + \
        '`!tn-ask-manual-question sensors="Computer Name,that starts with:D;IP Address"`\n' + \
        '### Sensor parameters\n' + \
        'Each sensor has its own unique parameters. To get a complete list of sensor parameters, run the _!tn-get-sensor_ command.\n' + \
        'Parameters are passed in curly brackets, after the sensor name, and before the filter.\n' + \
        '**Example** (1 sensor, 1 filter, 1 parameter):\n' + \
        '`!tn-ask-manual-question sensors="Index Query File Exists{fileMD5Hash=4F83C01E8F7507D23C67AB085BF79E97},that contains:yes"`\n' + \
        '### Sensor options\n' + \
        'All sensors have the same options: _ignore_case_, _match_case_, _match_any_value_, _match_all_values_, _max_data_age_, _value_type_\n' + \
        'Options are passed directly after filters.\n' + \
        '\n' + \
        '**Example** (1 sensor, 1 filter, 1 parameter):\n' + \
        '`!tn-ask-manual-question sensors="Index Query File Exists{fileMD5Hash=4F83C01E8F7507D23C67AB085BF79E97},that contains:yes,opt:match_all_values, opt:ignore_case, opt:max_data_age:3600"`\n' + \
        '## Question Filters\n---\n' + \
        'The _question_filters_ argument is a semicolon-separated list of sensors, with filters and parameters, that correlates to the **"... from all computers with ___"** part of a the Tanium Question.\n' + \
        'Question filters can have an ***and*** or an ***or*** relation. You set the relation by using the _question_options_ argument.\n' + \
        '\n' + \
        '**Example** (2 question filters):\n`!tn-ask-manual-question sensors="Computer Name" question_filters="Index Query File Exists{fileMD5Hash=4F83C01E8F7507D23C67AB085BF79E97},that contains:yes;Index Query File Exists{fileMD5Hash=4F83C01E8F7507D23C67AB085BF79E98},that contains:yes"`\n' + \
        '\n' + \
        '## Question Options\n---\n' + \
        'Question options are a semicolon-separated list of options that apply to the entire question. They are generally used to define the relation of the different filter statements.\n' + \
            '**Example** (1 question option):\n`!tn-ask-manual-question sensors="Computer Name" question_options="or" question_filters="Index Query File Exists{fileMD5Hash=4F83C01E8F7507D23C67AB085BF79E97},that contains:yes"`\n'

        return {
            'ContentsFormat': formats['markdown'],
            'Type': entryTypes['note'],
            'Contents': desc,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': desc
        }

    def askManualQuestion(handler, args):
        if args.get('help') == 'True':
            return getAskManualHelp()

        kwargs = {}
        kwargs["qtype"] = u'manual'
        kwargs["sensors_help"] = True if args.get('sensors_help') == 'True' else False
        kwargs["filters_help"] = True if args.get('filters_help') == 'True' else False
        kwargs["options_help"] = True if args.get('options_help') == 'True' else False

        if kwargs["filters_help"] or kwargs["sensors_help"] or kwargs["options_help"]:
            try:
                response = handler.ask(**kwargs)
                # should always throw an exception
                return response
            except Exception as ex:
                return str(ex)

        kwargs["question_options"] = args.get('question_options', '').split(';') if args.get('question_options', '') != '' else None
        kwargs["question_filters"] = args.get('question_filters', '').split(';') if args.get('question_filters', '') != '' else None
        kwargs["sensors"] = args.get('sensors', '').split(';') if args.get('sensors', '') != '' else None
        kwargs["polling_secs"] = int(args.get('polling_secs', '5'))
        kwargs["complete_pct"] = int(args.get('complete_pct', '99'))

        LOG("asking Tanium question")
        return askQuestion(handler, kwargs)

    def askParsedQuestion(handler , question, index):
        kwargs = {
            'picker': int(index),
            'question_text': question,
            'qtype': u'parsed',
            'get_results' : True
        }

        LOG("asking Tanium question %s" % (question))
        return askQuestion(handler, kwargs)

    def createPackage(handler):
        kwargs = {}
        dArgs = demisto.args()
        for key, value in dArgs.items():
            kwargs[key] = value
        if demisto.get(dArgs, 'file_urls'):
            kwargs['file_urls'] = dArgs['file_urls'].split(",")
        LOG("creating Tanium package")
        response = handler.create_package(**kwargs)
        parsed = parseToJson(handler, response)
        final_result = create_entry('Tanium Package', [parsed], {'Tanium.Packages' : parsed}, ['id', 'name', 'creation_time', 'command'])
        return final_result

    def restoreSoutAndExit(final_result):
        sys.stdout = sout
        LOG.print_log()
        demisto.results(final_result)
        sys.exit(0)

    # Dealing with Broken Pipe issues raised by some commands
    sout = sys.stdout
    sys.stdout = StringIO()

    try:
        handler = getHandler()
        LOG("successfully logged into Tanium")
        response = ''
        d_args = demisto.args()

        if demisto.command() == 'test-module':
            test_question = 'get Computer Name from all machines with Computer Name contains "this is a test"'
            final_result = askParsedQuestion(handler, test_question, '1')
            restoreSoutAndExit('ok')
        if demisto.command() == 'tn-get-package':
            final_result = getPackage(handler)
        if demisto.command() == 'tn-get-saved-question':
            final_result = getSavedQuestion(handler)
        if demisto.command() == 'tn-get-object':
            final_result = getObject(handler, unicode(d_args['object_type']), d_args.get('name'), d_args.get('id'))
        if demisto.command() == 'tn-get-all-objects':
            final_result = getAllObjects(handler, unicode(d_args['object_type']))
        if demisto.command() == 'tn-get-all-packages':
            final_result = getAllPackages(handler)
        if demisto.command() == 'tn-get-all-sensors':
            final_result = getAllSensors(handler)
        if demisto.command() == 'tn-get-all-saved-questions':
            final_result = getAllSavedQuestions(handler)
        if demisto.command() == 'tn-get-all-saved-actions':
            final_result = getAllSavedActions(handler)
        if demisto.command() == 'tn-get-all-pending-actions':
            final_result = getAllPendingActions(handler)
        if demisto.command() == 'tn-deploy-package':
            final_result = deployAction(handler)
        if demisto.command() == 'tn-ask-system':
            final_result = askParsedQuestion(handler, 'Get Computer Name from all machines with Computer Name matching \"'+ demisto.args()['hostname'] + '\"', '1')
        if demisto.command() == 'tn-ask-question':
            final_result = askParsedQuestion(handler, d_args['question'], d_args.get('index', '1'))
        if demisto.command() == 'tn-create-package':
            final_result = createPackage(handler)
        if demisto.command() == 'tn-approve-pending-action':
            final_result = approveSavedAction(handler, d_args.get('id'), d_args.get('saved_action_id', d_args.get('action_id')))
        if demisto.command() == 'tn-ask-manual-question':
            final_result = askManualQuestion(handler, d_args)
        if demisto.command() == 'tn-parse-query':
            final_result = getParseQueryOptions(handler, d_args['question'])
        if demisto.command() == 'tn-get-sensor':
            final_result = getSensor(handler)
        if demisto.command() == 'tn-get-action':
            final_result = getAction(handler)

    except Exception as ex:
        sys.stdout = sout
        LOG.print_log()
        raise

    restoreSoutAndExit(final_result)
  type: python
  commands:
  - name: tn-get-package
    arguments:
    - name: name
      description: Name of package
    - name: id
      description: Tanium id of package (to be used instead of name)
    outputs:
    - contextPath: Tanium.Packages.display_name
      description: Display name of package
      type: string
    - contextPath: Tanium.Packages.name
      description: Name of created package
      type: string
    - contextPath: Tanium.Packages.command
      description: Command to execute
      type: string
    - contextPath: Tanium.Packages.command_timeout
      description: Timeout for command execution in seconds
      type: number
    - contextPath: Tanium.Packages.deleted_flag
      description: Is the package deleted
      type: boolean
    - contextPath: Tanium.Packages.id
      description: Tanium unique package id
      type: string
    - contextPath: Tanium.Packages.files
      description: Packge files
    - contextPath: Tanium.Packages.parameters.Description
      description: Description of the package parameter
      type: string
    - contextPath: Tanium.Packages.parameters.Key
      description: Key of the package parameter as it appears in the command
      type: string
    - contextPath: Tanium.Packages.parameters.Name
      description: Name of the package parameter
      type: string
    - contextPath: Tanium.Packages.parameters.Type
      description: Type of package parameter
      type: string
    - contextPath: Tanium.Packages.parameters.Values
      description: Possible values of the package parameter
      type: string
    - contextPath: Tanium.Packages.sensor_variable
      description: The type of sensor that this package requires as a variable
      type: string
    description: Get a package object based on name or ID.
  - name: tn-get-all-packages
    arguments: []
    outputs:
    - contextPath: Tanium.Packages.verify_expire_seconds
      description: Timeout for verify action expiry in seconds
      type: number
    - contextPath: Tanium.Packages.display_name
      description: Display name of package
      type: string
    - contextPath: Tanium.Packages.name
      description: Name of created package
      type: string
    - contextPath: Tanium.Packages.command
      description: Command to execute
      type: string
    - contextPath: Tanium.Packages.creation_time
      description: Pacakge creation time
      type: date
    - contextPath: Tanium.Packages.command_timeout
      description: Timeout for command execution in seconds
      type: number
    - contextPath: Tanium.Packages.modification_time
      description: Package modification time
      type: date
    - contextPath: Tanium.Packages.last_modified_by
      description: User who last modified packge
      type: string
    - contextPath: Tanium.Packages.last_update
      description: Time when package was last updated
      type: date
    - contextPath: Tanium.Packages.deleted_flag
      description: Is the package deleted
      type: boolean
    - contextPath: Tanium.Packages.id
      description: Tanium unique package id
      type: string
    - contextPath: Tanium.Packages.expire_seconds
      description: Timeout for action expiry in seconds
      type: number
    - contextPath: Tanium.Packages.files
      description: Packge files
    description: Get all Tanium package objects
  - name: tn-get-object
    arguments:
    - name: name
      description: Name of object
    - name: id
      description: Tanium id of object (to be used instead of name)
    - name: object_type
      required: true
      auto: PREDEFINED
      predefined:
      - user
      - package
      - saved_question
      - sensor
      - saved_action
      - action
      description: Type of object to get
    description: Send a generic Get Object request
  - name: tn-get-all-saved-questions
    arguments: []
    outputs:
    - contextPath: Tanium.SavedQuestions.query_text
      description: Question query text
      type: string
    - contextPath: Tanium.SavedQuestions.mod_time
      description: Question modification time
      type: date
    - contextPath: Tanium.SavedQuestions.user.id
      description: Unique id of user who saved question
      type: string
    - contextPath: Tanium.SavedQuestions.user.name
      description: Name of user who saved question
      type: string
    - contextPath: Tanium.SavedQuestions.name
      description: Name of saved question
      type: string
    - contextPath: Tanium.SavedQuestions.expire_seconds
      description: Question expire time in seconds
      type: number
    - contextPath: Tanium.SavedQuestions.id
      description: Saved question unique id
      type: string
    - contextPath: Tanium.SavedQuestions.issue_seconds
      description: Issue time in seconds
      type: number
    description: Gets all saved questions
  - name: tn-deploy-package
    arguments:
    - name: package
      required: true
      default: true
      description: Name of package to deploy with this action
    - name: package_args
      description: Comma separated list of arguments needed to execute the package
        command. Please run 'tn-get-package' for a detailed list of arguments
    - name: action_filters
      description: Semicolon separated list of strings. Each string must describe
        a sensor and a filter which limits which computers the action will deploy
        package to (e.g. Operating System, that contains:Windows; Computer Name, that
        contains:WIN)
    - name: action_options
      description: Comma separated list of options to apply to action_filters (e.g.  "max_data_age:3600,and").
        Default is "or".
    - name: sensor_variables
      description: Semicolon separated list of sensor results that apply to the package.
        A separate action will be issued for each given variable .
    - name: get_results
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Specifies whether to wait for result completion after deploying
        action
    - name: action_filters_groups
      description: Comma separated list of computer group names to filter by
    - name: action_group
      description: Name of action group
    outputs:
    - contextPath: Tanium.SavedActions.Id
      description: Saved action id
      type: string
    - contextPath: Tanium.SavedActions.Name
      description: Saved action name
      type: string
    - contextPath: Tanium.Actions.id
      description: ID of deployed action
      type: string
    - contextPath: Tanium.Actions.name
      description: Name of deployed action
      type: string
    - contextPath: Tanium.Actions.creation_time
      description: Time when action was created
      type: date
    - contextPath: Tanium.Actions.status
      description: Action status (Close, Pending, etc.)
      type: string
    - contextPath: Tanium.Actions.package_spec.command
      description: The command that will run once action is approved
      type: string
    - contextPath: Tanium.Actions.package_spec.name
      description: The name of the package associated with the action
      type: string
    - contextPath: Tanium.Actions.user.name
      description: Name of user that created the action
      type: string
    description: Deploy a package and get the results back
  - name: tn-ask-question
    arguments:
    - name: question
      required: true
      default: true
      description: The question text
    - name: index
      description: The index of the parsed question to be asked (as returned by tn-parse-query)
      defaultValue: "1"
    outputs:
    - contextPath: Tanium.QuestionResults
      description: Results of requested question. May be a complex object
    description: Ask the server to parse the question text and choose the first parsed
      result as the question to run
  - name: tn-ask-system
    arguments:
    - name: hostname
      required: true
      default: true
      description: Name of host
    outputs:
    - contextPath: Tanium.QuestionResults
      description: Results of requested computer name. May be a complex object
    description: Ask a question about a specific endpoint
  - name: tn-get-saved-question
    arguments:
    - name: name
      description: Name of saved question
    - name: id
      description: Tanium unique id of saved question to be used instead of name
    outputs:
    - contextPath: Tanium.SavedQuestions.query_text
      description: Question query text
      type: string
    - contextPath: Tanium.SavedQuestions.mod_time
      description: Question modification time
      type: date
    - contextPath: Tanium.SavedQuestions.user.id
      description: Unique id of user who saved question
      type: string
    - contextPath: Tanium.SavedQuestions.user.name
      description: Name of user who saved question
      type: string
    - contextPath: Tanium.SavedQuestions.name
      description: Name of saved question
      type: string
    - contextPath: Tanium.SavedQuestions.expire_seconds
      description: Question expire time in seconds
      type: number
    - contextPath: Tanium.SavedQuestions.id
      description: Saved question unique id
      type: string
    - contextPath: Tanium.SavedQuestions.issue_seconds
      description: Issue time in seconds
      type: number
    description: Get a saved question by name or id
  - name: tn-create-package
    arguments:
    - name: name
      required: true
      description: Name of package to create
    - name: command
      required: true
      description: Command to execute
    - name: display_name
      description: Display name of package
    - name: file_urls
      description: Comma separated list of URLs of files to add to package
    - name: command_timeout_seconds
      description: Timeout for command execution in seconds
    - name: expire_seconds
      description: Timeout for action expiry in seconds
    outputs:
    - contextPath: Tanium.Packages.verify_expire_seconds
      description: Timeout for verify action expiry in seconds
      type: string
    - contextPath: Tanium.Packages.display_name
      description: Display name of package
      type: string
    - contextPath: Tanium.Packages.name
      description: Name of created package
      type: string
    - contextPath: Tanium.Packages.command
      description: Command to execute
      type: string
    - contextPath: Tanium.Packages.creation_time
      description: Pacakge creation time
      type: date
    - contextPath: Tanium.Packages.command_timeout
      description: Timeout for command execution in seconds
      type: number
    - contextPath: Tanium.Packages.modification_time
      description: Package modification time
      type: date
    - contextPath: Tanium.Packages.last_update
      description: Time when package was last updated
      type: date
    - contextPath: Tanium.Packages.deleted_flag
      description: Is the package deleted
      type: boolean
    - contextPath: Tanium.Packages.id
      description: Tanium unique package id
      type: string
    - contextPath: Tanium.Packages.expire_seconds
      description: Timeout for action expiry in seconds
      type: number
    description: Create a package object
  - name: tn-approve-pending-action
    arguments:
    - name: saved_action_id
      description: Saved action ID to be approved
    - name: id
      default: true
      description: Action ID to be approved
    - name: action_id
      description: (deprecated) Id of saved action to approve
    outputs:
    - contextPath: Tanium.ActionApproval.ApprovedFlag
      description: Approval status
      type: boolean
    - contextPath: Tanium.ActionApproval.Id
      description: Saved action id
      type: string
    - contextPath: Tanium.ActionApproval.Name
      description: Saved action name
      type: string
    description: Approve saved actions
  - name: tn-get-all-objects
    arguments:
    - name: object_type
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - user
      - package
      - saved_question
      - sensor
      - saved_action
      - group
      description: Type of object to get
    description: Gets all objects of the specified type
  - name: tn-get-all-saved-actions
    arguments: []
    outputs:
    - contextPath: Tanium.SavedActions.distribute_seconds
      description: Distribute seconds of action
      type: number
    - contextPath: Tanium.SavedActions.public_flag
      description: Whether action is public or not
      type: boolean
    - contextPath: Tanium.SavedActions.action_group_id
      description: Group id of action
      type: string
    - contextPath: Tanium.SavedActions.approver.id
      description: Id of user who approved the action
      type: string
    - contextPath: Tanium.SavedActions.start_time
      description: Action start time
      type: date
    - contextPath: Tanium.SavedActions.name
      description: Action name
      type: string
    - contextPath: Tanium.SavedActions.user.id
      description: Id of user who created the action
      type: string
    - contextPath: Tanium.SavedActions.creation_time
      description: Time when action was created
      type: date
    - contextPath: Tanium.SavedActions.end_time
      description: Time when action ended
      type: date
    - contextPath: Tanium.SavedActions.status
      description: Action status
      type: string
    - contextPath: Tanium.SavedActions.last_start_time
      description: Last time action started
      type: date
    - contextPath: Tanium.SavedActions.id
      description: Id of action
      type: string
    - contextPath: Tanium.SavedActions.package_spec.id
      description: The package associated with the action
      type: string
    - contextPath: Tanium.SavedActions.approved_flag
      description: Whether action was approved or not
      type: boolean
    description: Gets all saved actions
  - name: tn-get-all-pending-actions
    arguments: []
    outputs:
    - contextPath: Tanium.PendingActions.distribute_seconds
      description: Distribute seconds of action
      type: number
    - contextPath: Tanium.PendingActions.public_flag
      description: Whether action is public or not
      type: boolean
    - contextPath: Tanium.PendingActions.action_group_id
      description: Group id of action
      type: string
    - contextPath: Tanium.PendingActions.approver.id
      description: Id of user who approved the action
      type: string
    - contextPath: Tanium.PendingActions.start_time
      description: Action start time
      type: date
    - contextPath: Tanium.PendingActions.name
      description: Action name
      type: string
    - contextPath: Tanium.PendingActions.user.id
      description: Id of user who created the action
      type: string
    - contextPath: Tanium.PendingActions.creation_time
      description: Time when action was created
      type: date
    - contextPath: Tanium.PendingActions.end_time
      description: Time when action ended
      type: date
    - contextPath: Tanium.PendingActions.status
      description: Action status
      type: string
    - contextPath: Tanium.PendingActions.last_start_time
      description: Last time action started
      type: date
    - contextPath: Tanium.PendingActions.id
      description: Id of action
      type: string
    - contextPath: Tanium.PendingActions.package_spec.id
      description: The package associated with the action
      type: string
    - contextPath: Tanium.PendingActions.approved_flag
      description: Whether action was approved or not
      type: boolean
    description: Gets all pending actions
  - name: tn-get-all-sensors
    arguments: []
    description: Gets all sensors
  - name: tn-parse-query
    arguments:
    - name: question
      description: The question text to be parsed
    description: Ask the server to parse the question text and return all parsing
      options
  - name: tn-ask-manual-question
    arguments:
    - name: sensors
      description: A semicolon separated list of sensors (columns) to include in a
        question. For detailed information please use !tn-get-sensor
    - name: question_filters
      description: A semicolon separated list of filters that apply to the whole question
    - name: question_options
      description: A semicolon separated list of options that apply to the whole question.
        Options are ignore_case, match_case, match_any_value, match_all_values, max_data_age,
        value_type, and, or
    - name: filters_help
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Print the help string for filters and exit
      defaultValue: "False"
    - name: sensors_help
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Print the help string for sensors and exit
      defaultValue: "False"
    - name: options_help
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Print the help string for options and exit
      defaultValue: "False"
    - name: polling_secs
      description: Number of seconds to wait in between result fetching attempts
      defaultValue: "5"
    - name: complete_pct
      description: Percentage of mr_tested out of estimated_total to consider the
        question
      defaultValue: "99"
    - name: help
      description: Print an extended command usage description to the War Room. Default is False.
      predefined:
      - "True"
      - "False"
    outputs:
    - contextPath: Tanium.QuestionResults
      description: Results of requested question. May be a complex object
    description: Ask a manual question using human strings and get the results back
  - name: tn-get-sensor
    arguments:
    - name: name
      required: true
      default: true
      description: Name of sensor
    outputs:
    - contextPath: Tanium.Sensors.max_age_seconds
      description: Sensor max age in seconds
      type: number
    - contextPath: Tanium.Sensors.description
      description: Description of the sensor
      type: string
    - contextPath: Tanium.Sensors.name
      description: Name of the sensor
      type: string
    - contextPath: Tanium.Sensors.id
      description: Id of the sensor
      type: string
    - contextPath: Tanium.Sensors.parameters.Description
      description: Description of the sensor parameter
      type: string
    - contextPath: Tanium.Sensors.parameters.Key
      description: Key of the sensor parameter as it appears in the command string
      type: string
    - contextPath: Tanium.Sensors.parameters.Name
      description: Name of the sensor parameter
      type: string
    - contextPath: Tanium.Sensors.parameters.Type
      description: Type of the sensor parameter
      type: string
    - contextPath: Tanium.Sensors.parameters.Values
      description: Possible values of the sensor parameter
      type: string
    description: Get detailed information about a given sensor.
  - name: tn-get-action
    arguments:
    - name: id
      description: ID of action of retrieve
    outputs:
    - contextPath: Tanium.Actions.name
      description: Name of the actions
      type: string
    - contextPath: Tanium.Actions.id
      description: ID of the action
      type: number
    - contextPath: Tanium.Actions.status
      description: Status of the action - Closed, Pending, etc.
      type: string
    - contextPath: Tanium.Actions.start_time
      description: Time when the action started running
      type: date
    - contextPath: Tanium.Actions.approver.name
      description: Name of Tanium user who approved the action
      type: string
    - contextPath: Tanium.Actions.creation_time
      description: Time when the action was created
      type: date
    - contextPath: Tanium.Actions.package_spec.command
      description: The command that is issued by the action
      type: string
    - contextPath: Tanium.Actions.package_spec.name
      description: Name of the package that was deployed
      type: string
    description: Get detailed information about a given action.
  dockerimage: demisto/pytan
