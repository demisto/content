commonfields:
  id: Tanium
  version: -1
name: Tanium
display: Tanium
category: Endpoint
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAiCAYAAACUcR1DAAAEMElEQVR4Ae3aQ5QkaReA4b/Ltusf27Zt27aNzdi2bds227Ztu++8i7u4556KmMyOPFP6Fk/jU0bFW878n4h0YIEbaDVBCByEwEEIHAIHIfDoNdZcAyfgHjyNW3Aw6t3aVhakG7YWN2EQxFmEP3E2cnRPKwvSiXsMJkBS0BWbhhvc+lKNeyEkTbOxW7jJrSuVuPtDltMUrBRudOv5t7ilGAlJ4B1/bkXDyhWoT0OxP8PN19k5t64w7jy3tsisqdKxXDNWiyx0Qa0Zz4s4L8uty9HxGtQbtXEdmK/yby+yEwUmTB7OgyS0bMwaa27iLvg9zEnDtW7/mW5+Ng6LuDmn+vMwAE0trD3brPlWxzY3Y+NQjUIMMeO7xoQZZdZtgGwMctczE7tFnLEGJrv107FG0sA74ldIBjzsLvonSBpuM3vLMRbiDEBBCzfoLAi875Dl1l4IUX/o2FYQNRs1GngiRO0ZEadaY4jaWAOPgzi/I6uFM16AOEuxVtLA12AGxJmAd9N0o7voi/CUehLvQdRCvKzjT6kDzN7rIWoCpkLUebrOf7SLWgYxbnFrL4Co33RsS4iaYQLbSHvEBJ4CURtp4DEQeIe7/ZtiCcRZlInAj2MZxPnQrU2Mi10HoqahKGJdM2ZC1DG4GKKGoyQm8J94H2Ic0YqB5+ELiOqKbLP/E/cZZ1wmAz8J+Y8CbwFR01Efse5eiBqKHFRhBkRdGhP4V1RjuIu2RisFXoJ93FlH6N4dIWqu/n9sJgPfiLkQpweOc3Zze/d083smDcxYkwm5DEebuSsgaiJqIgJ3M483H6L+1PFzljPw7jHfZE2OCqxWde9YfZCLzyHqLuRjWiYDH4BekBT86vZ2dfMvZyDwIxC1GI/iLvUUltobEhG4qxk/DWLcipPTCDw+hcAVusd/kzXGRc/FEIh6AwvMY1ajItOBy3EjJAVfu70/ufndkwTWr9ELISmah9XjAuvc8+4bsK4pBK5FDkZB1KtoRqVRi0vdN3brIccF3lQf5ygIvBt0vi6jgTVUM2YmDPwbshIGftN9E/Z9hBkQ9UwKgQtdVBUbuF7HP4N/p5pmzHLzU1CCwojAXfALxBiNsowHdrEuShB4CbbW8Sj+Z81FaDBzO0CMU2POuRBirIZTIapfC3vWxkyI00Pnt3ZfGhp1fDuNKim6VPeVmlCCzc217A8xzjZz9e6z2BqoxQ5YN+mTDU+mGfgPCM5L8bvo1fGeehkVZu5cvK9zzyAv5pxSvKhrP8Dx2N6cfU/Evv3xnnOHzq1hxl5x17YBHsYP+BPeL3gBe5s9BXjGnLmq/0lBx59Cnhkvx8s69zbqUYYDsWvSwF1wZ1xgszYLn+MsHQva0RP+2+EzLIIYv7nApeHmtu+X7KyNk3ErHsCpOhe078BBCByEwEEIHITAQQgctOvAQQgc/AOlTKJJMlW1twAAAABJRU5ErkJggg==
description: Tanium endpoint security and systems management
configuration:
- display: Host URL (e.g. 1.2.3.4)
  name: host
  defaultvalue: ""
  type: 0
  required: true
- display: Port
  name: port
  defaultvalue: "443"
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    from collections import OrderedDict
    from itertools import chain
    import os
    import sys
    import tempfile
    import pprint
    import traceback
    import json
    import io
    import csv
    from cStringIO import StringIO
    import xml.etree.ElementTree as ET

    if not demisto.params()['proxy']:
      del os.environ['HTTP_PROXY']
      del os.environ['HTTPS_PROXY']
      del os.environ['http_proxy']
      del os.environ['https_proxy']

    # disable python from generating a .pyc file
    sys.dont_write_bytecode = True

    # change me to the path of pytan
    pytan_loc =  "/pytan-2.2.2"
    pytan_static_path = os.path.join(os.path.expanduser(pytan_loc), 'lib')

    # Determine our script name, script dir
    my_file = os.path.abspath(sys.argv[0])
    my_dir = os.path.dirname(my_file)

    # try to automatically determine the pytan lib directory by assuming it is in '../../lib/'
    parent_dir = os.path.dirname(my_dir)
    pytan_root_dir = os.path.dirname(parent_dir)
    lib_dir = os.path.join(pytan_root_dir, 'lib')

    # add pytan_loc and lib_dir to the PYTHONPATH variable
    path_adds = [lib_dir, pytan_static_path]
    [sys.path.append(aa) for aa in path_adds if aa not in sys.path]

    try:
        import pytan
        import pytan.binsupport
        import taniumpy
    except Exception:
        raise

    def parse_xml_to_csv(instring):
        output = StringIO()
        root = ET.fromstring(instring)
        columns = []
        for column in root.findall('./result_set/cs/c/dn'):
            columns.append(column.text)
        rows =[]
        rows.append(columns)
        for record in root.findall('./result_set/rs/r'):
            values = record.findall('c/v')
            # todo bug with count > 2 use limit=1 for  now in index file query
            row = [i.text for i in values]
            rows.append(row)
        writer = csv.writer(output)
        writer.writerows(rows)
        return_string = output.getvalue()
        return return_string

    def csvstr_to_list(string):
        lines = string.splitlines()
        if len(lines) < 2:
            return []
        else:
            headers = lines[0].split(',')
            new_headers= []
            counter={}
            for header_name in headers:
                if header_name in counter:
                    new_headers.append(header_name+str(counter[header_name]))
                    counter[header_name]+=1
                else:
                    new_headers.append(header_name)
                    counter[header_name]=0
            return_dict = [ OrderedDict(zip(new_headers, line.split(','))) for line in lines[1:] ]
            return return_dict

    def parseToJson(handler, response):
        export_kwargs = {}
        export_kwargs['obj'] = response
        export_kwargs['export_format'] = 'json'
        out = handler.export_obj(**export_kwargs)
        return json.loads(out)

    def create_error_entry(contents):
        return {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['error'],
            'Contents': "Error - " + contents
        }

    def create_entry(header, table, context = {}, headers = None):
        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': table,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(header, table, headers) if table else 'No result were found',
            'EntryContext': context
        }

    def getHandler():
        handler_args = {}

        handler_args['username'] = demisto.params()['credentials']['identifier']
        handler_args['password'] = demisto.params()['credentials']['password']
        handler_args['host'] = demisto.params()['host']
        handler_args['port'] = demisto.params()['port']

        handler_args['loglevel'] = 1
        handler_args['debugformat'] = False
        handler_args['record_all_requests'] = True

        handler = pytan.Handler(**handler_args)
        return handler

    def getAllObjects(handler, objtype):
        kwargs = {}
        kwargs["objtype"] = objtype
        response = handler.get_all(**kwargs)
        parsed = parseToJson(handler, response)
        return parsed

    def getAllObjectsWithEntry(handler, objtype):
        response = getAllObjects(handler, unicode(objtype))
        parsed = response[objtype]
        final_result = create_entry('Tanium '+objtype+'s', parsed)
        return final_result

    def getAllSensors(handler):
        response = getAllObjects(handler, u'sensor')
        parsed = response.get('sensor')
        final_result = create_entry('Tanium Sensors', parsed, {'Tanium.Sensors' : parsed})
        return final_result

    def getAllSavedActions(handler):
        response = getAllObjects(handler, u'saved_action')
        parsed = response.get('saved_action')
        final_result = create_entry('Tanium Saved Actions', parsed, {'Tanium.SavedActions' : parsed}, ['id', 'name', 'creation_time', 'action_group_id', 'approved_flag'])
        return final_result

    def getAllPendingActions(handler):
        response = getAllObjects(handler, u'saved_action')
        parsed = response.get('saved_action')
        filterNonPending = filter(lambda x: x['approved_flag'] == 0 ,parsed)
        final_result = create_entry('Tanium Pending Actions', filterNonPending, {'Tanium.PendingActions' : filterNonPending}, ['id', 'name', 'creation_time', 'action_group_id', 'approved_flag'])
        return final_result

    def getAllPackages(handler):
        response = getAllObjects(handler, u'package')
        parsed = response.get('package_spec')
        final_result = create_entry('Tanium Packages', parsed, {'Tanium.Packages' : parsed}, ['id', 'name', 'creation_time', 'command', 'last_modified_by'])
        return final_result

    def getAllSavedQuestions(handler):
        response = getAllObjects(handler, u'saved_question')
        parsed = response.get('saved_question')
        final_result = create_entry('Tanium Saved Questions', parsed, {'Tanium.SavedQuestions' : parsed}, ['query_text', 'name', 'id'])
        return final_result

    def getObject(handler, objtype):
        kwargs = {}
        kwargs["objtype"] = objtype
        kwargs["id"] = demisto.args()['id'] if demisto.get(demisto.args(),'id') else None
        kwargs["name"] = demisto.args()['name'] if demisto.get(demisto.args(),'name') else None

        response = handler.get(**kwargs)
        parsed = parseToJson(handler, response)
        return parsed

    def parameterTableBuilder(data):
        if not data.get('parameter_definition'):
            return 'No arguments needed for this package'
        param_data = json.loads(data['parameter_definition']).get('parameters', [])
        parsed_params = []
        parsed_param = {}
        for param in param_data:
            parsed_param['Description'] = param.get('helpString', 'No description')
            parsed_param['Name'] = param.get('label', 'No argument name')
            parsed_param['Values'] = ','.join(param['values']) if param.get('values') else 'Any value'
            parsed_param['Key'] = param.get('key', 'No key')
            parsed_param['Type'] = param['parameterType'].split('::')[-1] if param.get('parameterType') else 'Type not specified'
            parsed_params.append(parsed_param)
            parsed_param = {}
        return tableToMarkdown('Package Arguments Details', parsed_params, ['Key','Name', 'Values', 'Description', 'Type'])

    def getPackage(handler):
        response = getObject(handler, u'package')
        parsed = response.get('package_spec')
        final_result = create_entry('Tanium Package', parsed, {'Tanium.Packages' : parsed}, ['id', 'name', 'creation_time', 'command', 'last_modified_by'])
        final_result['HumanReadable'] += parameterTableBuilder(parsed[0])
        return final_result

    def getSavedQuestion(handler):
        response = getObject(handler, u'saved_question')
        parsed = response.get('saved_question')
        final_result = create_entry('Tanium Saved Question', parsed, {'Tanium.SavedQuestions' : parsed}, ['query_text', 'name', 'id'])
        return final_result

    def handle_cgs(handler, obj, kwargs):
        """Example PreAddAction callback that modifies the target_group of an Action if computer group names are supplied.
        callbacks = {}
        callbacks["PreAddAction"] = handle_cgs
        deploy_action(package="blah", cg_names=["ip has 192.168", "has tanium app"], action_filters=["Computer Name, that contains:a"], callbacks=callbacks)
        """
        cgs = kwargs.get("cg_names", [])
        cg_objs = [handler.get("group", name=x)[0] for x in cgs]
        cg_listobj = taniumpy.GroupList()
        [cg_listobj.append(x) for x in cg_objs]

        if cg_objs:
            tg_obj = taniumpy.Group()
            tg_obj.sub_groups = cg_listobj
            tg_obj.and_flag = 0
            if obj.target_group is not None:
                tg_obj.sub_groups.append(obj.target_group)
            obj.target_group = tg_obj
        return obj

    def parseDeployActionRawResp(response):
        saved_action_object = response.get('saved_action_object')
        action_object = response.get('action_object')
        package_object = response.get('package_object')

        retVal = {}
        if saved_action_object is not None:
            retVal['saved_action_object'] = {
                'id': saved_action_object.id,
                'name': saved_action_object.name,
                'action_group_id': saved_action_object.action_group_id,
                'last_start_time': saved_action_object.last_start_time,
                'target_group_id': saved_action_object.target_group.id
            }
        if action_object is not None:
            retVal['action_object'] = {
                'id': action_object.id,
                'name': action_object.name
            }
        if package_object is not None:
            retVal['package_object'] = {
                'id': package_object.id,
                'name': package_object.name
            }

        return retVal


    def deployAction(handler):
        package = demisto.args()['package']
        if demisto.args().get('package_args'):
            formatted_args = ''
            package_args = demisto.args().get('package_args', '').split(",")
            for i in range(0, len(package_args)):
                formatted_args = formatted_args + '$'+str(i+1)+'='+package_args[i]+','
            formatted_args = formatted_args[:-1]
            demisto.args()['package'] = package+'{'+formatted_args+'}'

        kwargs = {}
        kwargs["run"] = True

        for key, value in demisto.args().items():
            kwargs[key] = value
        callbacks = {}
        callbacks['PreAddAction'] = handle_cgs
        kwargs['callbacks'] = callbacks
        kwargs['action_options'] = ['or']
        if demisto.get(demisto.args(), 'action_options'):
            kwargs['action_options'] = demisto.args()['action_options'].split(',')
        if demisto.get(demisto.args(), 'action_filters'):
            kwargs['action_filters'] = demisto.args()['action_filters'].split(';')
        if demisto.get(demisto.args(), 'action_filters_groups'):
            kwargs['cg_names'] = demisto.args()['action_filters_groups'].split(',')

        response = handler.deploy_action(**kwargs)

        ec = { 'Tanium.SavedActions' : {'Name': response['saved_action_object'].name, 'Id':response['saved_action_object'].id} }

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': parseDeployActionRawResp(response),
            'HumanReadable': 'Id of saved action is %s' % (response['saved_action_object'].id,),
            'HumanReadableFormat': formats['text'],
            'EntryContext': ec
        }

    def approveSavedAction(handler):
        kwargs = {}
        kwargs['id'] = demisto.args()['action_id']
        response = handler.approve_saved_action(**kwargs)
        parsed = {'Id' : response.id, 'Name': response.name, 'ApprovedFlag': response.approved_flag}
        final_result = create_entry('Action Approval', [parsed], {'Tanium.ActionApproval' : parsed})
        return final_result

    def askQuestion(kwargs):
        response = handler.ask(**kwargs)

        if isinstance(response, str):
            return reponse

        query_text = response['question_object'].query_text
        if response.get('question_results'):
            export_kwargs = {}
            export_kwargs['obj'] = response['question_results']
            export_kwargs['export_format'] = 'xml'
            export_kwargs['header_sort']=False
            out = handler.export_obj(**export_kwargs)


            #tanium built in csv output is broken for Multiple columns with the same name.
            csv_string = parse_xml_to_csv(out)
            result = csvstr_to_list(csv_string)
            flat_length = len(list(chain.from_iterable(result)))
            ttlrecords = len(result)
            query_text = query_text.replace(r"[",r"\[").replace(r"]","\]")
            MAX_ENTRIES=1000
            if flat_length > MAX_ENTRIES:
                entries_per_row = len(result[0])
                max_rows = MAX_ENTRIES / entries_per_row
                resultdisplay = result[:max_rows]
                ec = { 'Tanium.QuestionResults' : resultdisplay}
                return create_entry(
                    'First '+ str(len(resultdisplay)) + ' Results of total {} for parsed query - {}'.format(ttlrecords,query_text),
                    resultdisplay,
                    ec)
            else:
                ec = { 'Tanium.QuestionResults' : result }
                return create_entry(
                    'Result for parsed query - {}'.format(query_text),
                    result,
                    ec)

            # debugging change to csv_string or out (xml) as needed
            #return {
            #    'ContentsFormat': formats['text'],
            #    'Type': entryTypes['note'],
            #    'Contents': "xml: " + str(out)
            #}
        else:
            return 'Parsed query - %s\nNo results were found' % (query_text,)

    def getParseQueryOptions(handler , question):
        parse_job_results = handler.parse_query(question)
        jsonable = parse_job_results.to_jsonable()

        ans = jsonable["parse_result_group"]
        res = []
        i = 0
        while i < len(ans):
            res.append({"index" : i+1, "question" : ans[i]["question_text"]})
            i = i+1
        return create_entry('Tanium Questions', res, {}, ['index', 'question'])


    def askManualQuestion(handler, args):
        kwargs = {}
        kwargs["qtype"] = u'manual'
        kwargs["sensors_help"] = True if args.get('sensors_help') == 'True' else False
        kwargs["filters_help"] = True if args.get('filters_help') == 'True' else False
        kwargs["options_help"] = True if args.get('options_help') == 'True' else False

        if kwargs["filters_help"] or kwargs["sensors_help"] or kwargs["options_help"]:
            try:
                response = handler.ask(**kwargs)
                # should always throw an exception
                return response
            except Exception as ex:
                return str(ex)

        kwargs["question_options"] = args.get('question_options', '').split(';') if args.get('question_options', '') != '' else None
        kwargs["question_filters"] = args.get('question_filters', '').split(';') if args.get('question_filters', '') != '' else None
        kwargs["sensors"] = args.get('sensors', '').split(';') if args.get('sensors', '') != '' else None
        kwargs["polling_secs"] = int(args.get('polling_secs', '5'))
        kwargs["complete_pct"] = int(args.get('complete_pct', '99'))
        return askQuestion(kwargs)

    def askParsedQuestion(handler , question, index):
        kwargs = {
            'picker': int(index),
            'question_text': question,
            'qtype': u'parsed',
            'get_results' : True
        }
        return askQuestion(kwargs)

    def createPackage(handler):
        kwargs = {}
        dArgs = demisto.args()
        for key, value in dArgs.items():
            kwargs[key] = value
        if demisto.get(dArgs, 'file_urls'):
            kwargs['file_urls'] = dArgs['file_urls'].split(",")
        response = handler.create_package(**kwargs)
        parsed = parseToJson(handler, response)
        final_result = create_entry('Tanium Package', [parsed], {'Tanium.Packages' : parsed}, ['id', 'name', 'creation_time', 'command'])
        return final_result

    def restoreSoutAndExit(final_result):
        sys.stdout = sout
        demisto.results(final_result)
        sys.exit(0)

    # Dealing with Broken Pipe issues raised by some commands
    sout = sys.stdout
    sys.stdout = StringIO()

    try:
        handler = getHandler()
        response = ''

        if demisto.command() == 'test-module':
            final_result = getAllPackages(handler)
            restoreSoutAndExit('ok')
        if demisto.command() == 'tn-get-package':
            final_result = getPackage(handler)
        if demisto.command() == 'tn-get-saved-question':
            final_result = getSavedQuestion(handler)
        if demisto.command() == 'tn-get-object':
            final_result = getObject(handler, unicode(demisto.args()['object_type']))
        if demisto.command() == 'tn-get-all-objects':
            final_result = getAllObjects(handler, unicode(demisto.args()['object_type']))
        if demisto.command() == 'tn-get-all-packages':
            final_result = getAllPackages(handler)
        if demisto.command() == 'tn-get-all-sensors':
            final_result = getAllSensors(handler)
        if demisto.command() == 'tn-get-all-saved-questions':
            final_result = getAllSavedQuestions(handler)
        if demisto.command() == 'tn-get-all-saved-actions':
            final_result = getAllSavedActions(handler)
        if demisto.command() == 'tn-get-all-pending-actions':
            final_result = getAllPendingActions(handler)
        if demisto.command() == 'tn-deploy-package':
            final_result = deployAction(handler)
        if demisto.command() == 'tn-ask-system':
            final_result = askParsedQuestion(handler, 'Get Computer Name from all machines with Computer Name matching \"'+ demisto.args()['hostname'] + '\"', '1')
        if demisto.command() == 'tn-ask-question':
            final_result = askParsedQuestion(handler, demisto.args()['question'], demisto.args().get('index', '1'))
        if demisto.command() == 'tn-create-package':
            final_result = createPackage(handler)
        if demisto.command() == 'tn-approve-pending-action':
            final_result = approveSavedAction(handler)
        if demisto.command() == 'tn-ask-manual-question':
            final_result = askManualQuestion(handler, demisto.args())
        if demisto.command() == 'tn-parse-query':
            final_result = getParseQueryOptions(handler, demisto.args()['question'])
    except Exception as ex:
        sys.stdout = sout
        raise

    restoreSoutAndExit(final_result)
  type: python
  commands:
  - name: tn-get-package
    arguments:
    - name: name
      description: Name of package
    - name: id
      description: Tanium id of package (to be used instead of name)
    outputs:
    - contextPath: Tanium.Packages.verify_expire_seconds
      description: Timeout for verify action expiry in seconds
    - contextPath: Tanium.Packages.display_name
      description: Display name of package
    - contextPath: Tanium.Packages.name
      description: Name of created package
    - contextPath: Tanium.Packages.command
      description: Command to execute
    - contextPath: Tanium.Packages.creation_time
      description: Pacakge creation time
    - contextPath: Tanium.Packages.command_timeout
      description: Timeout for command execution in seconds
    - contextPath: Tanium.Packages.modification_time
      description: Package modification time
    - contextPath: Tanium.Packages.last_modified_by
      description: User who last modified packge
    - contextPath: Tanium.Packages.last_update
      description: Time when package was last updated
    - contextPath: Tanium.Packages.deleted_flag
      description: Is the package deleted
    - contextPath: Tanium.Packages.id
      description: Tanium unique package id
    - contextPath: Tanium.Packages.expire_seconds
      description: Timeout for action expiry in seconds
    - contextPath: Tanium.Packages.files
      description: Packge files
    description: Get a package object based on name or ID.
  - name: tn-get-all-packages
    arguments: []
    outputs:
    - contextPath: Tanium.Packages.verify_expire_seconds
      description: Timeout for verify action expiry in seconds
    - contextPath: Tanium.Packages.display_name
      description: Display name of package
    - contextPath: Tanium.Packages.name
      description: Name of created package
    - contextPath: Tanium.Packages.command
      description: Command to execute
    - contextPath: Tanium.Packages.creation_time
      description: Pacakge creation time
    - contextPath: Tanium.Packages.command_timeout
      description: Timeout for command execution in seconds
    - contextPath: Tanium.Packages.modification_time
      description: Package modification time
    - contextPath: Tanium.Packages.last_modified_by
      description: User who last modified packge
    - contextPath: Tanium.Packages.last_update
      description: Time when package was last updated
    - contextPath: Tanium.Packages.deleted_flag
      description: Is the package deleted
    - contextPath: Tanium.Packages.id
      description: Tanium unique package id
    - contextPath: Tanium.Packages.expire_seconds
      description: Timeout for action expiry in seconds
    - contextPath: Tanium.Packages.files
      description: Packge files
    description: Get all Tanium package objects
  - name: tn-get-object
    arguments:
    - name: name
      description: Name of object
    - name: id
      description: Tanium id of object (to be used instead of name)
    - name: object_type
      required: true
      auto: PREDEFINED
      predefined:
      - user
      - package
      - saved_question
      - sensor
      - saved_action
      description: Type of object to get
    description: Send a generic Get Object request
  - name: tn-get-all-saved-questions
    arguments: []
    outputs:
    - contextPath: Tanium.SavedQuestions.query_text
      description: Question query text
    - contextPath: Tanium.SavedQuestions.mod_time
      description: Question modification time
    - contextPath: Tanium.SavedQuestions.user.id
      description: Unique id of user who saved question
    - contextPath: Tanium.SavedQuestions.user.name
      description: Name of user who saved question
    - contextPath: Tanium.SavedQuestions.name
      description: Name of saved question
    - contextPath: Tanium.SavedQuestions.expire_seconds
      description: Question expire time in seconds
    - contextPath: Tanium.SavedQuestions.id
      description: Saved question unique id
    - contextPath: Tanium.SavedQuestions.issue_seconds
      description: Issue time in seconds
    description: Gets all saved questions
  - name: tn-deploy-package
    arguments:
    - name: package
      required: true
      default: true
      description: Name of package to deploy with this action
    - name: action_filters
      description: Semicolon separated list of strings. Each string must describe
        a sensor and a filter which limits which computers the action will deploy
        package to (e.g. Operating System, that contains:Windows; Computer Name, that
        contains:WIN)
    - name: action_options
      description: Comma separated list of options to apply to action_filters (e.g.  "max_data_age:3600,and").
        Default is "or".
    - name: get_results
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Specifies whether to wait for result completion after deploying
        action
    - name: package_args
      description: Comma separated list of arguments needed to execute the package
        command. Please run 'tn-get-package' for a detailed list of arguments
    - name: action_filters_groups
      description: Comma separated list of computer group names to filter by
    - name: action_group
      description: Name of action group
    outputs:
    - contextPath: Tanium.SavedActions.Id
      description: Saved action id
    - contextPath: Tanium.SavedActions.Name
      description: Saved action name
    description: Deploy a package and get the results back
  - name: tn-ask-question
    arguments:
    - name: question
      required: true
      default: true
      description: The question text
    - name: index
      description: The index of the parsed question to be asked (as returned by tn-parse-query)
      defaultValue: "1"
    outputs:
    - contextPath: Tanium.QuestionResults
      description: Results of requested question. May be a complex object
    description: Ask the server to parse the question text and choose the first parsed
      result as the question to run
  - name: tn-ask-system
    arguments:
    - name: hostname
      required: true
      default: true
      description: Name of host
    outputs:
    - contextPath: Tanium.QuestionResults
      description: Results of requested computer name. May be a complex object
    description: Ask a question about a specific endpoint
  - name: tn-get-saved-question
    arguments:
    - name: name
      description: Name of saved question
    - name: id
      description: Tanium unique id of saved question to be used instead of name
    outputs:
    - contextPath: Tanium.SavedQuestions.query_text
      description: Question query text
    - contextPath: Tanium.SavedQuestions.mod_time
      description: Question modification time
    - contextPath: Tanium.SavedQuestions.user.id
      description: Unique id of user who saved question
    - contextPath: Tanium.SavedQuestions.user.name
      description: Name of user who saved question
    - contextPath: Tanium.SavedQuestions.name
      description: Name of saved question
    - contextPath: Tanium.SavedQuestions.expire_seconds
      description: Question expire time in seconds
    - contextPath: Tanium.SavedQuestions.id
      description: Saved question unique id
    - contextPath: Tanium.SavedQuestions.issue_seconds
      description: Issue time in seconds
    description: Get a saved question by name or id
  - name: tn-create-package
    arguments:
    - name: name
      required: true
      description: Name of package to create
    - name: command
      required: true
      description: Command to execute
    - name: display_name
      description: Display name of package
    - name: file_urls
      description: Comma separated list of URLs of files to add to package
    - name: command_timeout_seconds
      description: Timeout for command execution in seconds
    - name: expire_seconds
      description: Timeout for action expiry in seconds
    outputs:
    - contextPath: Tanium.Packages.verify_expire_seconds
      description: Timeout for verify action expiry in seconds
    - contextPath: Tanium.Packages.display_name
      description: Display name of package
    - contextPath: Tanium.Packages.name
      description: Name of created package
    - contextPath: Tanium.Packages.command
      description: Command to execute
    - contextPath: Tanium.Packages.creation_time
      description: Pacakge creation time
    - contextPath: Tanium.Packages.command_timeout
      description: Timeout for command execution in seconds
    - contextPath: Tanium.Packages.modification_time
      description: Package modification time
    - contextPath: Tanium.Packages.last_update
      description: Time when package was last updated
    - contextPath: Tanium.Packages.deleted_flag
      description: Is the package deleted
    - contextPath: Tanium.Packages.id
      description: Tanium unique package id
    - contextPath: Tanium.Packages.expire_seconds
      description: Timeout for action expiry in seconds
    description: Create a package object
  - name: tn-approve-pending-action
    arguments:
    - name: action_id
      required: true
      default: true
      description: Id of saved action to approve
    outputs:
    - contextPath: Tanium.ActionApproval.ApprovedFlag
      description: Approval status
    - contextPath: Tanium.ActionApproval.Id
      description: Saved action id
    - contextPath: Tanium.ActionApproval.Name
      description: Saved action name
    description: Approve saved actions
  - name: tn-get-all-objects
    arguments:
    - name: object_type
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - user
      - package
      - saved_question
      - sensor
      - saved_action
      - group
      description: Type of object to get
    description: Gets all objects of the specified type
  - name: tn-get-all-saved-actions
    arguments: []
    outputs:
    - contextPath: Tanium.SavedActions.distribute_seconds
      description: Distribute seconds of action
    - contextPath: Tanium.SavedActions.public_flag
      description: Whether action is public or not
    - contextPath: Tanium.SavedActions.action_group_id
      description: Group id of action
    - contextPath: Tanium.SavedActions.approver.id
      description: Id of user who approved the action
    - contextPath: Tanium.SavedActions.start_time
      description: Action start time
    - contextPath: Tanium.SavedActions.name
      description: Action name
    - contextPath: Tanium.SavedActions.user.id
      description: Id of user who created the action
    - contextPath: Tanium.SavedActions.creation_time
      description: Time when action was created
    - contextPath: Tanium.SavedActions.end_time
      description: Time when action ended
    - contextPath: Tanium.SavedActions.status
      description: Action status
    - contextPath: Tanium.SavedActions.last_start_time
      description: Last time action started
    - contextPath: Tanium.SavedActions.id
      description: Id of action
    - contextPath: Tanium.SavedActions.package_spec.id
      description: The package associated with the action
    - contextPath: Tanium.SavedActions.approved_flag
      description: Whether action was approved or not
    description: Gets all saved actions
  - name: tn-get-all-pending-actions
    arguments: []
    outputs:
    - contextPath: Tanium.PendingActions.distribute_seconds
      description: Distribute seconds of action
    - contextPath: Tanium.PendingActions.public_flag
      description: Whether action is public or not
    - contextPath: Tanium.PendingActions.action_group_id
      description: Group id of action
    - contextPath: Tanium.PendingActions.approver.id
      description: Id of user who approved the action
    - contextPath: Tanium.PendingActions.start_time
      description: Action start time
    - contextPath: Tanium.PendingActions.name
      description: Action name
    - contextPath: Tanium.PendingActions.user.id
      description: Id of user who created the action
    - contextPath: Tanium.PendingActions.creation_time
      description: Time when action was created
    - contextPath: Tanium.PendingActions.end_time
      description: Time when action ended
    - contextPath: Tanium.PendingActions.status
      description: Action status
    - contextPath: Tanium.PendingActions.last_start_time
      description: Last time action started
    - contextPath: Tanium.PendingActions.id
      description: Id of action
    - contextPath: Tanium.PendingActions.package_spec.id
      description: The package associated with the action
    - contextPath: Tanium.PendingActions.approved_flag
      description: Whether action was approved or not
    description: Gets all pending actions
  - name: tn-get-all-sensors
    arguments: []
    description: Gets all sensors
  - name: tn-parse-query
    arguments:
    - name: question
      description: The question text to be parsed
    description: Ask the server to parse the question text and return all parsing
      options
  - name: tn-ask-manual-question
    arguments:
    - name: sensors
      description: A semicolon separated list of sensors (columns) to include in question
    - name: question_filters
      description: A semicolon separated list of filters that apply to the whole question
    - name: question_options
      description: A semicolon separated list of options that apply to the whole question.
        Options are ignore_case, match_case, match_any_value, match_all_values, max_data_age,
        value_type, and, or
    - name: filters_help
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Print the help string for filters and exit
      defaultValue: "False"
    - name: sensors_help
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Print the help string for sensors and exit
      defaultValue: "False"
    - name: options_help
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Print the help string for options and exit
      defaultValue: "False"
    - name: polling_secs
      description: Number of seconds to wait in between result fetching attempts
      defaultValue: "5"
    - name: complete_pct
      description: Percentage of mr_tested out of estimated_total to consider the
        question
      defaultValue: "99"
    description: Ask a manual question using human strings and get the results back
  dockerimage: demisto/pytan
  runonce: true
