commonfields:
  id: Recorded Future
  version: -1
name: Recorded Future
display: Recorded Future
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Unique threat intel technology that automatically serves up relevant
  insights in real time and at unparalleled scale.
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: 'API Token '
  name: token
  defaultvalue: ""
  type: 4
  required: true
- display: File Threshold. Minimum risk score from RF to consider the file malicious.
  name: file_threshold
  defaultvalue: "65"
  type: 0
  required: false
- display: IP Threshold. Minimum risk score from RF to consider the IP malicious.
  name: ip_threshold
  defaultvalue: "65"
  type: 0
  required: false
- display: Domain Threshold. Minimum risk score from RF to consider the domain malicious.
  name: domain_threshold
  defaultvalue: "65"
  type: 0
  required: false
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    ''' IMPORTS '''
    import requests
    import os
    import json

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    TOKEN = demisto.params()['token']
    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/') else demisto.params()['server']
    BASE_URL = SERVER + '/v2/'
    USE_SSL = not demisto.params().get('unsecure', False)
    HEADERS = {
        'X-RFToken': TOKEN,
        'X-RF-User-Agent': 'DemistoIntegrations+v1.0'
    }
    FILE_THRESHOLD = int(demisto.params()['file_threshold'])
    IP_THRESHOLD = int(demisto.params()['ip_threshold'])
    DOMAIN_THRESHOLD = int(demisto.params()['domain_threshold'])

    ''' HELPER FUNCTIONS '''
    def http_request(method, url_suffix):
        LOG('running request with url=%s' % (BASE_URL + url_suffix))
        try:
            res = requests.request(
                method,
                BASE_URL + url_suffix,
                headers=HEADERS,
                verify=USE_SSL
            )
            if res.status_code not in {200, 404}:
                return_error('Your request failed with the following error: ' + error_reason + ' - ' + str(res.status_code))
        except Exception, e:
            LOG(e)
            raise
        return res.text

    def translate_score(score, threshold):
        '''
        Translates Recorded Future score to DBot score
        '''
        if score >= threshold: # Bad
            return 3
        elif score >= 5: # Suspicious
            return 2
        else: return 0 # Unknown

    def determine_hash(hash):
        '''
        Determines hash type by length
        '''
        if len(hash) == 128:
            return 'SHA512'
        elif len(hash) == 64:
            return 'SHA256'
        elif len(hash) == 40:
            return 'SHA1'
        elif len(hash) == 32:
            return 'MD5'
        elif len(hash) == 8:
            return 'CRC32'
        else: return 'CTPH'

    ''' FUNCTIONS '''
    def domain_command():
        domain = demisto.args().get('domain')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(domain_lookup(domain))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            hr = '### Recorded Future domain reputation for ' + domain + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/idn:' + domain + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table, ['Evidence Summary', 'Rule Criticality', 'Rule Triggered', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this hash', sightings_table, ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['domain']] = {
                'Name': domain,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, DOMAIN_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': domain,
                'Type': 'domain',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['domain']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }
        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': domain,
                    'Type': 'domain',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })

    def domain_lookup(domain):
        cmd_url = 'domain/' + domain + '?fields=sightings%2Ctimestamps%2Crisk'
        response = http_request('get', cmd_url)
        return response

    def ip_command():
        ip = demisto.args().get('ip')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(ip_lookup(ip))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            hr = '### Recorded Future IP address reputation for ' + ip + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/ip:' + ip + ')' + '\n'
            evidence_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    evidence_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', evidence_table, ['Evidence Summary', 'Rule Criticality', 'Rule Triggered', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this hash', sightings_table, ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            ec = {}
            ec[outputPaths['ip']] = {
                'Address': ip,
                'RecordedFuture': {
                    'Criticality': risk.get('criticalityLabel'),
                    'FirstSeen': timestamps.get('firstSeen'),
                    'LastSeen': timestamps.get('lastSeen')
                }
            }
            dbot_score = translate_score(rf_score, IP_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': ip,
                'Type': 'ip',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['ip']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': ip,
                    'Type': 'ip',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })

    def ip_lookup(ip):
        cmd_url = 'ip/' + ip + '?fields=sightings%2Ctimestamps%2Crisk'
        response = http_request('get', cmd_url)
        return response

    def file_command():
        file = demisto.args().get('file')
        detailed = False if demisto.args().get('detailed') == 'false' else True
        response = json.loads(file_lookup(file))
        if response and ('error' not in response):
            data = response['data']
            timestamps = data['timestamps']
            risk = data['risk']
            rf_score = risk['score']
            sightings = data['sightings']
            hr = '### Recorded Future file reputation for ' + file + '\n'
            hr += 'Risk score: ' + str(rf_score) + ' out of 99\n'
            hr += 'Criticality label: ' + risk.get('criticalityLabel') + '\n'
            hr += 'Summary: ' + risk.get('riskSummary') + '\n'
            hr += 'Total references to this entity: ' + str(len(sightings)) + '\n'
            hr += 'First reference collected on: ' + timestamps.get('firstSeen') + '\n'
            hr += 'Latest reference collected on: ' + timestamps.get('lastSeen') + '\n'
            hr += '[Intelligence Card](https://app.recordedfuture.com/live/sc/entity/hash:' + file + ')' + '\n'
            hr_table = []
            if detailed:
                evidence_details = risk['evidenceDetails']
                for detail in evidence_details:
                    hr_table.append({
                        'Rule Criticality': detail.get('criticalityLabel'),
                        'Evidence Summary': detail.get('evidenceString'),
                        'Rule Triggered': detail.get('rule'),
                        'Rule Triggered Time': detail.get('timestamp')
                    })
                hr += tableToMarkdown('Triggered Risk Rules', hr_table, ['Rule Triggered', 'Rule Criticality', 'Evidence Summary', 'Rule Triggered Time'])
            sightings_table = []
            for raw_sighting in sightings:
                sighting = {
                    'Published': raw_sighting.get('published'),
                    'Type': raw_sighting.get('type'),
                    'Fragment': raw_sighting.get('fragment'),
                    'Source': raw_sighting.get('source'),
                    'Title': raw_sighting.get('title')
                }
                if raw_sighting['url']:
                    sighting['URL'] = '[{}]({})'.format(raw_sighting['url'], raw_sighting['url'])
                sightings_table.append(sighting)
            if sightings_table:
                hr += tableToMarkdown('References collected for this hash', sightings_table, ['Title', 'Source', 'Type', 'URL', 'Fragment', 'Published'])
            hash_type = determine_hash(file)
            ec = {}
            ec[outputPaths['file']] = {
                hash_type: file,
                'RecordedFuture': {
                    'Criticality': risk['criticalityLabel'],
                    'FirstSeen': timestamps['firstSeen'],
                    'LastSeen': timestamps['lastSeen']
                }
            }
            dbot_score = translate_score(rf_score, FILE_THRESHOLD)
            ec['DBotScore'] = {
                'Indicator': file,
                'Type': 'file',
                'Vendor': 'Recorded Future',
                'Score': dbot_score
            }
            if (dbot_score == 3):
                ec[outputPaths['file']]['Malicious'] = {
                    'Vendor': 'Recorded Future',
                    'Description': 'Score above ' + str(rf_score)
                }

        else:
            hr = 'No records found'
            ec = {
                'DBotScore': {
                    'Indicator': file,
                    'Type': 'file',
                    'Vendor': 'Recorded Future',
                    'Score': 0
                }
            }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })

    def file_lookup(file):
        cmd_url = 'hash/' + file + '?fields=sightings%2Ctimestamps%2Crisk'
        response = http_request('get', cmd_url)
        return response

    def get_related_entities_command():
        entity_value = demisto.args().get('entityValue')
        entity_result_type = demisto.args().get('resultEntityType')
        entity_type = demisto.args().get('entityType').lower()
        if entity_type == 'file':
            entity_type = 'hash'
        response = json.loads(get_related_entities(entity_value, entity_type))
        ec = {}
        if response and ('error' not in response):
            hr = []
            entity_result_type = entity_result_type.split(',')
            entity_types = []
            if 'All' in entity_result_type:
                entity_types = ['RelatedIpAddress', 'RelatedInternetDomainName', 'RelatedHash', 'RelatedMalware', 'RelatedAttackVector']
            else:
                if 'IP' in entity_result_type:
                    entity_types.append('RelatedIpAddress')
                if 'Hash' in entity_result_type:
                    entity_types.append('RelatedHash')
                if 'Domain' in entity_result_type:
                    entity_types.append('RelatedInternetDomainName')
                if 'Attacker' in entity_result_type:
                    entity_types.append('RelatedAttackVector')
                if 'Malware' in entity_result_type:
                    entity_types.append('RelatedMalware')
            ip_outputs = []
            hash_outputs = []
            domain_outputs = []
            attacker_outputs = []
            malware_outputs = []
            output_map = {
                'RelatedIpAddress': ip_outputs,
                'RelatedHash': hash_outputs,
                'RelatedInternetDomainName': domain_outputs,
                'RelatedAttackVector': attacker_outputs,
                'RelatedMalware': malware_outputs,
            }
            related_entities = response['data']['relatedEntities']
            for related_entity in related_entities:
                if related_entity['type'] in entity_types:
                    entities = related_entity['entities']
                    for entity in entities:
                        hr_entity = {
                            'Count': entity['count'],
                            'ID': entity['entity']['id'],
                            'Name': entity['entity']['name']
                        }
                        output_map[related_entity['type']].append(hr_entity)
            hr = ''

            related_entities_ec = {}
            if ip_outputs:
                hr += tableToMarkdown('IP Address', ip_outputs)
                related_entities_ec['IPAddress'] = ip_outputs
            if hash_outputs:
                hr += tableToMarkdown('Hash', hash_outputs)
                related_entities_ec['Hash'] = hash_outputs
            if domain_outputs:
                hr += tableToMarkdown('Domain', domain_outputs)
                related_entities_ec['Domain'] = domain_outputs
            if attacker_outputs:
                hr += tableToMarkdown('Attacker', attacker_outputs)
                related_entities_ec['Attacker'] = attacker_outputs
            if malware_outputs:
                hr += tableToMarkdown('Malware', malware_outputs)
                related_entities_ec['Malware'] = malware_outputs

            if hr:
                hr = '### Recorded Future related entities to ' + entity_value + '\n' + hr
                if entity_type == 'ip':
                    ec[outputPaths['ip']] = {
                        'Address': entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
                elif entity_type == 'domain':
                    ec[outputPaths['domain']] = {
                        'Name': entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
                elif entity_type == 'hash':
                    ec[outputPaths['file']] = {
                        determine_hash(entity_value): entity_value,
                        'RecordedFuture': {
                            'RelatedEntities': related_entities_ec
                        }
                    }
        else:
            hr = 'No results found'
        demisto.results({
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        })

    def get_related_entities(entity_value, entity_type):
        cmd_url = entity_type + '/' + entity_value + '?fields=relatedEntities'
        response = http_request('get', cmd_url)
        return response


    ''' EXECUTION CODE '''
    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            ip_lookup('8.8.8.8')
            demisto.results('ok')

        elif demisto.command() == 'domain':
            domain_command()

        elif demisto.command() == 'ip':
            ip_command()

        elif demisto.command() == 'file':
            file_command()

        elif demisto.command() == 'recorded-future-get-related-entities':
            get_related_entities_command()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
  commands:
  - name: domain
    arguments:
    - name: domain
      required: true
      default: true
      description: Domain to get reputation of
    - name: detailed
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Fetching evidence details if true. Evidence is a record that gets
        generated if any of the risk rules on Recorded Future is triggered.
      defaultValue: "false"
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.RecordedFuture.Criticality
      description: Domain criticality label
      type: string
    - contextPath: Domain.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: Domain.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
    description: Look up threat intel information for a domain or DNS in Recorded
      Future.
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check reputation of
    - name: detailed
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Fetching evidence details if true. Evidence is a record that gets
        generated if any of the risk rules on Recorded Future is triggered.
      defaultValue: "false"
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason for the vendor to make the
        decision
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.RecordedFuture.Criticality
      description: Risk criticality label
      type: string
    - contextPath: IP.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: IP.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
    description: Look up threat intel information for an IP in Recorded Future.
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: 'File hash to check reputation of. (Hash types supported: MD5,
        SHA-1, SHA-256, SHA-512, CRC-32, CTPH)'
    - name: detailed
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Fetching evidence details if true. Evidence is a record that gets
        generated if any of the risk rules on Recorded Future is triggered.
      defaultValue: "false"
    outputs:
    - contextPath: File.SHA256
      description: File SHA-256
      type: string
    - contextPath: File.SHA512
      description: File SHA-512
      type: string
    - contextPath: File.SHA1
      description: File SHA-1
      type: string
    - contextPath: File.MD5
      description: File MD-5
      type: string
    - contextPath: File.CRC32
      description: File CRC-32
      type: string
    - contextPath: File.CTPH
      description: File CTPH
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.Criticality
      description: Risk criticality label
      type: string
    - contextPath: File.RecordedFuture.FirstSeen
      description: Risk first seen timestamp
      type: date
    - contextPath: File.RecordedFuture.LastSeen
      description: Risk last seen timestamp
      type: date
    description: Look up threat intel information for a file in Recorded Future.
  - name: recorded-future-get-related-entities
    arguments:
    - name: entityType
      required: true
      auto: PREDEFINED
      predefined:
      - domain
      - ip
      - file
      description: The type of entity to fetch context for. (Should be provided with
        its value in entityValue argument)
    - name: entityValue
      required: true
      description: 'The value of entity to fetch context for. (Should be provided
        with its type in entityType argument, Hash types supported: MD5, SHA-1, SHA-256,
        SHA-512, CRC-32, CTPH)'
    - name: resultEntityType
      auto: PREDEFINED
      predefined:
      - All
      - Hash
      - IP
      - Domain
      - Attacker
      - Malware
      description: The type of related entities to be returned in the result (Can
        be given as comma separated values, e.g. Hash,IP,Domain)
      defaultValue: All
    outputs:
    - contextPath: File.SHA256
      description: File SHA-256
      type: string
    - contextPath: File.SHA512
      description: File SHA-512
      type: string
    - contextPath: File.SHA1
      description: File SHA-1
      type: string
    - contextPath: File.MD5
      description: File MD-5
      type: string
    - contextPath: File.CRC32
      description: File CRC-32
      type: string
    - contextPath: File.CTPH
      description: File CTPH
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.IPAddress.Count
      description: File related entity count (IP)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.IPAddress.ID
      description: File related entity ID (IP)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.IPAddress.Name
      description: File related entity name (IP)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Hash.Count
      description: File related entity count (Hash)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Hash.ID
      description: File related entity ID (Hash)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Hash.Name
      description: File related entity name (Hash)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Domain.Count
      description: File related entity count (Domain)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Domain.ID
      description: File related entity ID (Domain)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Domain.Name
      description: File related entity name (Domain)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Attacker.Count
      description: File related entity count (Attacker)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Attacker.ID
      description: File related entity ID (Attacker)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Attacker.Name
      description: File related entity name (Attacker)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Malware.Count
      description: File related entity count (Malware)
      type: number
    - contextPath: File.RecordedFuture.RelatedEntities.Malware.ID
      description: File related entity ID (Malware)
      type: string
    - contextPath: File.RecordedFuture.RelatedEntities.Malware.Name
      description: File related entity name (Malware)
      type: string
    - contextPath: IP.Address
      description: IP address
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.IPAddress.Count
      description: IP related entity count (IP)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.IPAddress.ID
      description: IP related entity ID (IP)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.IPAddress.Name
      description: IP related entity name (IP)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Hash.Count
      description: IP related entity count (Hash)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Hash.ID
      description: IP related entity ID (Hash)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Hash.Name
      description: IP related entity name (Hash)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Domain.Count
      description: IP related entity count (Domain)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Domain.ID
      description: IP related entity ID (Domain)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Domain.Name
      description: IP related entity name (Domain)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Attacker.Count
      description: IP related entity count (Attacker)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Attacker.ID
      description: IP related entity ID (Attacker)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Attacker.Name
      description: IP related entity name (Attacker)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Malware.Count
      description: IP related entity count (Malware)
      type: number
    - contextPath: IP.RecordedFuture.RelatedEntities.Malware.ID
      description: IP related entity ID (Malware)
      type: string
    - contextPath: IP.RecordedFuture.RelatedEntities.Malware.Name
      description: IP related entity name (Malware)
      type: string
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.IPAddress.Count
      description: Domain related entity count (IP)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.IPAddress.ID
      description: Domain related entity ID (IP)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.IPAddress.Name
      description: Domain related entity name (IP)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Hash.Count
      description: Domain related entity count (Hash)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Hash.ID
      description: Domain related entity ID (Hash)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Hash.Name
      description: Domain related entity name (Hash)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Domain.Count
      description: Domain related entity count (Domain)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Domain.ID
      description: Domain related entity ID (Domain)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Domain.Name
      description: Domain related entity name (Domain)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Attacker.Count
      description: Domain related entity count (Attacker)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Attacker.ID
      description: Domain related entity ID (Attacker)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Attacker.Name
      description: Domain related entity name (Attacker)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Malware.Count
      description: Domain related entity count (Malware)
      type: number
    - contextPath: Domain.RecordedFuture.RelatedEntities.Malware.ID
      description: Domain related entity ID (Malware)
      type: string
    - contextPath: Domain.RecordedFuture.RelatedEntities.Malware.Name
      description: Domain related entity name (Malware)
      type: string
    description: Look up threat intel context for an indicator in Recorded Future.
  runonce: false
