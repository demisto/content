commonfields:
  id: Tenable.io
  version: -1
name: Tenable.io
display: Tenable.io
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: A comprehensive asset centric solution to accurately track resources
  while accommodating dynamic assets such as cloud, mobile devices, containers and
  web applications.
detaileddescription: A comprehensive asset centric solution to accurately track resources
  while accommodating dynamic assets such as cloud, mobile devices, containers and
  web applications.
configuration:
- display: URL
  name: url
  defaultvalue: https://cloud.tenable.com/
  type: 0
  required: true
- display: Access Key
  name: access-key
  defaultvalue: ""
  type: 4
  required: true
- display: Secret Key
  name: secret-key
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    import sys, os, requests, traceback, time
    from datetime import datetime
    from requests.exceptions import HTTPError

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # Header names transformation maps
    # Format: {'OldName': 'NewName'}
    FIELD_NAMES_MAP = {'ScanType': 'Type', 'ScanStart': 'StartTime', 'ScanEnd': 'EndTime', 'ScannerName': 'Scanner', 'SeenLast': 'LastSeen', 'SeenFirst': 'FirstSeen', 'PluginId': 'Id', 'Count': 'VulnerabilityOccurences'}
    REMEDIATIONS_NAMES_MAP = {'Value': 'Id', 'Vulns': 'AssociatedVulnerabilities', 'Hosts': 'AffectedHosts', 'Remediation': 'Description'}
    ASSET_VULNS_NAMES_MAP = {'PluginId': 'Id', 'PluginFamily': 'Family', 'PluginName': 'Name', 'Count': 'VulnerabilityOccurences'}

    # Output Headers / Context Keys
    GET_SCANS_HEADERS = ['FolderId', 'Id', 'Name', 'Targets', 'Status', 'StartTime', 'EndTime', 'Enabled', 'Type', 'Owner', 'Scanner', 'Policy', 'CreationDate', 'LastModificationDate']
    LAUNCH_SCAN_HEADERS = ['Id', 'Targets', 'Status']
    SCAN_REPORT_INFO_HEADERS = ['Id', 'Name', 'Targets', 'Status', 'StartTime', 'EndTime', 'Scanner', 'Policy']
    SCAN_REPORT_VULNERABILITIES_HEADERS = ['Id', 'Name', 'Severity', 'Description', 'Synopsis', 'Solution', 'FirstSeen', 'LastSeen', 'VulnerabilityOccurences']
    SCAN_REPORT_HOSTS_HEADERS = ['Hostname', 'Score', 'Critical', 'High', 'Medium', 'Low']
    SCAN_REPORT_REMEDIATIONS_HEADERS = ['Id', 'Description', 'AffectedHosts', 'AssociatedVulnerabilities']
    VULNERABILITY_DETAILS_HEADERS = ['Name', 'Severity', 'Type', 'Family', 'Description', 'Synopsis', 'Solution', 'FirstSeen', 'LastSeen', 'PublicationDate', 'ModificationDate', 'VulnerabilityOccurences', 'CvssVector', 'CvssBaseScore', 'Cvss3Vector', 'Cvss3BaseScore']
    ASSET_VULNS_HEADERS = ['Id', 'Name', 'Severity', 'Family', 'VulnerabilityOccurences', 'VulnerabilityState']

    severity_to_text = ['None', 'Low', 'Medium', 'High', 'Critical']

    # Read integration parameters
    BASE_URL = demisto.params()['url']
    ACCESS_KEY = demisto.params()['access-key']
    SECRET_KEY = demisto.params()['secret-key']
    AUTH_HEADERS = {'X-ApiKeys': 'accessKey={}; secretKey={}'.format(ACCESS_KEY, SECRET_KEY)}
    USE_SSL = not demisto.params()['unsecure']

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    # Utility methods
    def flatten(d):
        r = {}
        for k, v in d.iteritems():
            if isinstance(v, dict):
                r.update(flatten(v))
        d.update(r)
        return d

    def filter_dict_null(d):
        if isinstance(d, dict):
            return dict((k, v) for k, v in d.items() if v is not None)
        return d

    def filter_dict_keys(d, keys):
        if isinstance(d, list):
            return map(lambda x: filter_dict_keys(x, keys), d)
        if isinstance(d, dict):
            return {k: v for k, v in d.iteritems() if k in keys}
        return d

    def convert_severity_values(d):
        if isinstance(d, list):
            return map(convert_severity_values, d)
        if isinstance(d, dict):
            return {k: (severity_to_text[v] if k == 'Severity' else v) for k, v in d.iteritems()}
        return d

    def convert_dict_context_dates(d):
        def convert_epoch_to_date(k, v):
            if any(s in k.lower() for s in ('date', 'time')):
                try:
                    return datetime.utcfromtimestamp(int(v)).strftime('%Y-%m-%dT%H:%M:%SZ')
                except:
                    pass
            return v

        if isinstance(d, list):
            return map(convert_dict_context_dates, d)
        if isinstance(d, dict):
            return {k: convert_dict_context_dates(convert_epoch_to_date(k, v)) for k, v in d.iteritems()}
        return d

    def convert_dict_readable_dates(d):
        def convert_epoch_to_date(k, v):
            return formatEpochDate(v) if isinstance(v, int) and any(s in k.lower() for s in ('date', 'time')) else v

        if isinstance(d, list):
            return map(convert_dict_readable_dates, d)
        if isinstance(d, dict):
            return {k: convert_dict_readable_dates(convert_epoch_to_date(k, v)) for k, v in d.iteritems()}
        return d

    def get_entry_for_object(title, context_key, obj, headers=None, remove_null=False):
        def intersection(lst1, lst2):
            return [value for value in lst1 if value in lst2]

        if len(obj) == 0:
            return "There is no output result"
        obj = filter_dict_null(obj)
        if isinstance(obj, list):
            obj = map(filter_dict_null, obj)
        if headers and isinstance(obj, dict):
            headers = intersection(headers, obj.keys())

        hr_obj = convert_dict_readable_dates(obj)
        context_obj = convert_dict_context_dates(filter_dict_keys(obj, headers) if headers else obj)

        return {
            'Type': entryTypes['note'],
            'Contents': context_obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr_obj, headers, removeNull=remove_null),
            'EntryContext': {
                context_key: context_obj
            }
        }

    # change the keys of a dictionary according to a conversion map
    # trans_map - { 'OldKey': 'NewKey', ...}
    # camelize - change all keys from snake_case to CamelCase
    def replace_keys(src, trans_map=FIELD_NAMES_MAP, camelize=True):
        def snake_to_camel(snake_str):
            components = snake_str.split('_')
            return ''.join(map(lambda x: x.decode('utf-8').title(), components))

        def replace(key, trans_map):
            if key in trans_map:
                return trans_map[key]
            return key

        if isinstance(src, list):
            return map(lambda x: replace_keys(x, trans_map, camelize), src)
        if camelize:
            src = {snake_to_camel(k): v for k,v in src.iteritems()}
        if trans_map:
            src = {replace(k, trans_map): v for k,v in src.iteritems()}
        return src

    def date_range_to_param(date_range):
        params = {}
        if date_range:
            try:
                date_range = int(date_range)
                params['date_range'] = date_range
            except ValueError, e:
                return_error("Invalid date range: {}".format(date_range))
        return params

    def get_scan_error_message(response, scan_id):
        code = response.status_code
        message = "Error processing request"
        if scan_id:
            message += " for scan with id {}".format(scan_id)
        message += ". Got response status code: {}".format(code)
        if code == 401:
            message += " - Scan is disabled."
        elif code == 403:
            message += " - {}".format(response.json()['error'])
        elif code == 404:
            message += " - Scan does not exist."
        elif code == 409:
            message += " - Scan cannot be launched in its current status."
        return message

    # Request/Response methods
    # kwargs: request parameters
    def send_scan_request(scan_id="", endpoint="", method='GET', ignore_license_error=False, **kwargs):
        if endpoint:
            endpoint = '/' + endpoint
        full_url = "{0}scans/{1!s}{2}".format(BASE_URL, scan_id, endpoint)
        try:
            res = requests.request(method, full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=kwargs)
            res.raise_for_status()
        except HTTPError, e:
            if ignore_license_error and res.status_code in (403, 500):
                return
            err_msg = get_scan_error_message(res, scan_id)
            if demisto.command() != 'test-module':
                return_error(err_msg)
            else:
                demisto.results(err_msg)
            demisto.error(traceback.format_exc())
            sys.exit(0)
        return res.json()

    def get_scan_info(scans_result_elem):
        response = send_scan_request(scans_result_elem['id'], ignore_license_error=True)
        if response:
            response['info'].update(scans_result_elem)
            return response['info']

    def send_vuln_details_request(plugin_id, date_range=None):
        full_url = "{}{}{}/{}".format(BASE_URL, "workbenches/vulnerabilities/", plugin_id, "info")
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=date_range_to_param(date_range))
        return res.json()

    def send_asset_vuln_request(asset_id, date_range):
        full_url = "{}workbenches/assets/{}/vulnerabilities/".format(BASE_URL, asset_id)
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=date_range_to_param(date_range))
        res.raise_for_status()
        return res.json()

    def get_vuln_info(vulns):
        vulns_info = {v['plugin_id']: v for v in vulns}
        infos = []
        errors = []
        for pid, info in vulns_info.iteritems():
            vuln_details = send_vuln_details_request(pid)
            if u'error' in vuln_details:
                errors.append(info)
            else:
                info.update(flatten(vuln_details['info']))
                infos.append(info)
        return infos, errors

    def get_assets():
        full_url = "{}{}".format(BASE_URL, "assets/")
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL)
        return res.json()

    def get_asset_id(hostname=None, ip=None):
        if all(s is None for s in (hostname, ip)):
            return_error("Please provide one of the following arguments: hostname, ip")
        assets = get_assets()
        if 'error' in assets:
            return_error(assets['error'])
        assets = assets['assets']
        if hostname:
            assets = filter(lambda x: hostname in x['fqdn'] + x['netbios_name'], assets)
            if not assets:
                return_error('No assets found for hostname: {}'.format(hostname))
            return assets[0]['id'], hostname
        if ip:
            assets = filter(lambda x: ip in x['ipv4'] + x['ipv6'], assets)
            if not assets:
                return_error('No assets found for ip: {}'.format(ip))
            return assets[0]['id'], ip
        return_error('No IP or Hostname found for asset.')

    # Command methods
    def test_module():
        send_scan_request()
        return 'ok'

    def get_scans_command():
        folder_id, last_modification_date = demisto.getArg('folderId'), demisto.getArg('lastModificationDate')
        if last_modification_date:
            last_modification_date = int(time.mktime(datetime.strptime(last_modification_date[0:len('YYYY-MM-DD')], "%Y-%m-%d").timetuple()))   # str(YYYY-MM-DD) to int(timestamp)
        response = send_scan_request(folder_id=folder_id, last_modification_date=last_modification_date)
        scan_entries = map(get_scan_info, response['scans'])
        valid_scans = filter(lambda x: x is not None, scan_entries)
        invalid_scans = [k for k,v in zip(response['scans'], scan_entries) if v is None]
        res = [get_entry_for_object('Tenable.io - List of Scans', 'TenableIO.Scan', replace_keys(valid_scans), GET_SCANS_HEADERS)]
        if invalid_scans:
            res.append(get_entry_for_object('Inactive Web Applications Scans - Renew WAS license to use these scans', 'TenableIO.Scan', replace_keys(invalid_scans), GET_SCANS_HEADERS, remove_null=True))
        return res

    def launch_scan_command():
        scan_id, targets = demisto.getArg('scanId'), demisto.getArg('scanTartgets')
        scan_info = send_scan_request(scan_id)['info']
        if not targets:
            targets = scan_info.get('targets', '')
        res = send_scan_request(scan_id, 'launch', 'POST', alt_targets=targets)
        res.update({
            'id': scan_id,
            'targets': targets,
            'status': 'pending'
        })

        return get_entry_for_object('The requested scan was launched successfully', 'TenableIO.Scan', replace_keys(res), LAUNCH_SCAN_HEADERS)

    def get_report_command():
        scan_id, info, detailed = demisto.getArg('scanId'), demisto.getArg('info'), demisto.getArg('detailed')
        results = []
        scan_details = send_scan_request(scan_id)

        if info == 'yes':
            scan_details['info']['id'] = scan_id
            scan_details['info'] = replace_keys(scan_details['info'])
            results.append(get_entry_for_object('Scan basic info', 'TenableIO.Scan', scan_details['info'], SCAN_REPORT_INFO_HEADERS))

        if 'vulnerabilities' not in scan_details:
            return "No vulnerabilities found."
        vuln_info, vulns_not_found = get_vuln_info(scan_details['vulnerabilities'])
        vuln_info = convert_severity_values(replace_keys(vuln_info))
        results.append(get_entry_for_object('Vulnerabilities', 'TenableIO.Vulnerabilities', vuln_info, SCAN_REPORT_VULNERABILITIES_HEADERS))
        if len(vulns_not_found) > 0:
            vulns_not_found = replace_keys(vulns_not_found)
            results.append(get_entry_for_object('Vulnerabilities - Missing From Workbench', 'TenableIO.Vulnerabilities', vulns_not_found, SCAN_REPORT_VULNERABILITIES_HEADERS, True))

        if detailed == 'yes':
            assets = replace_keys(scan_details['hosts'] + scan_details['comphosts'])
            results.append(get_entry_for_object('Assets', 'TenableIO.Assets', assets, SCAN_REPORT_HOSTS_HEADERS))
            if 'remediations' in scan_details and 'remediations' in scan_details['remediations'] and len(scan_details['remediations']['remediations']) > 0:
                remediations = replace_keys(scan_details['remediations']['remediations'], REMEDIATIONS_NAMES_MAP)
                results.append(get_entry_for_object('Remediations', 'TenableIO.Remediations', remediations, SCAN_REPORT_REMEDIATIONS_HEADERS))
        return results

    def get_vulnerability_details_command():
        plugin_id, date_range = demisto.getArg('vulnerabilityId'), demisto.getArg('dateRange')
        info = send_vuln_details_request(plugin_id, date_range)
        if 'error' in info:
            return_error(info['error'])
        return get_entry_for_object('Vulnerability details - {}'.format(plugin_id), 'TenableIO.Vulnerabilities', convert_severity_values(replace_keys(flatten(info['info']))), VULNERABILITY_DETAILS_HEADERS)

    def get_vulnerabilities_by_asset_command():
        hostname, ip, date_range = demisto.getArg('hostname'), demisto.getArg('ip'), demisto.getArg('dateRange')
        asset_id, indicator = get_asset_id(hostname, ip)
        info = send_asset_vuln_request(asset_id, date_range)
        if 'error' in info:
            return_error(info['error'])
        vulns = convert_severity_values(replace_keys(info['vulnerabilities'], ASSET_VULNS_NAMES_MAP))
        entry = get_entry_for_object('Vulnerabilities for asset {}'.format(indicator), 'TenableIO.Vulnerabilities', vulns, ASSET_VULNS_HEADERS)
        entry['EntryContext']['TenableIO.Assets(val.Hostname === obj.Hostname)'] = {
            'Vulnerabilities': map(lambda x: x['plugin_id'], info['vulnerabilities']),
            'Hostname': indicator
        }
        return entry

    def get_scan_status_command():
        scan_id = demisto.getArg('scanId')
        scan_details = send_scan_request(scan_id)
        scan_status = {
            'Id': scan_id,
            'Status': scan_details['info']['status']
        }
        return get_entry_for_object('Scan status for {}'.format(scan_id), 'TenableIO.Scan(val.Id === obj.Id)', scan_status)



    # Command selector
    if demisto.command() == 'test-module':
        demisto.results(test_module())
    elif demisto.command() == 'tenable-io-list-scans':
        demisto.results(get_scans_command())
    elif demisto.command() == 'tenable-io-launch-scan':
        demisto.results(launch_scan_command())
    elif demisto.command() == 'tenable-io-get-scan-report':
        demisto.results(get_report_command())
    elif demisto.command() == 'tenable-io-get-vulnerability-details':
        demisto.results(get_vulnerability_details_command())
    elif demisto.command() == 'tenable-io-get-vulnerabilities-by-asset':
        demisto.results(get_vulnerabilities_by_asset_command())
    elif demisto.command() == 'tenable-io-get-scan-status':
        demisto.results(get_scan_status_command())
  type: python
  commands:
  - name: tenable-io-list-scans
    arguments:
    - name: folderId
      description: 'The ID of the folder whose scans should be listed. Scans are stored
        in specific folders on Tenable. e.g : folderId=8'
    - name: lastModificationDate
      description: 'Limit the results to those that have only changed since this time.
        Format: YYYY-MM-DD'
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique id of the scan.
      type: number
    - contextPath: TenableIO.Scan.Name
      description: The name of the scan.
      type: string
    - contextPath: TenableIO.Scan.Target
      description: The targets to be scanned.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
    - contextPath: TenableIO.Scan.StartTime
      description: The scheduled start time for the scan.
      type: date
    - contextPath: TenableIO.Scan.EndTime
      description: The scan end time for the scan.
      type: date
    - contextPath: TenableIO.Scan.Enabled
      description: If true, the schedule for the scan is enabled.
      type: boolean
    - contextPath: TenableIO.Scan.Type
      description: The type of scan (local, remote, or agent).
      type: string
    - contextPath: TenableIO.Scan.Owner
      description: The owner of the scan.
      type: string
    - contextPath: TenableIO.Scan.Scanner
      description: The scanner assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.Policy
      description: The policy assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.CreationDate
      description: The creation date for the scan in Unix time.
      type: date
    - contextPath: TenableIO.Scan.LastModificationDate
      description: The last modification date for the scan in Unix time.
      type: date
    - contextPath: TenableIO.Scan.FolderId
      description: The unique id of the folder where the scan has been stored.
      type: number
    description: Retrive scans from the Tenable platform.
  - name: tenable-io-launch-scan
    arguments:
    - name: scanId
      required: true
      default: true
      description: The id of the scan to launch.
    - name: scanTargets
      description: If specified, these targets will be scanned instead of the default.
        Value can be an array where each index is a target, or an array with a single
        index of comma separated targets.
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique id of the scan.
      type: number
    - contextPath: TenableIO.Scan.Targets
      description: The targets to be scanned.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
    description: Lauch a scan with existing or custom targets. (You can specify custom
      targets in the arguements of this command.)
  - name: tenable-io-get-scan-report
    arguments:
    - name: scanId
      required: true
      default: true
      description: The id of the scan to retrieve.
    - name: detailed
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: If detailed is true, the report will contain remediations and hosts
        information as well for the given scan. Otherwise the report will only have
        vulnerabilities.
      defaultValue: "no"
    - name: info
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Return the basic details of the given scan.
      defaultValue: "no"
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique id of the scan.
      type: number
    - contextPath: TenableIO.Scan.Name
      description: The name of the scan.
      type: string
    - contextPath: TenableIO.Scan.Targets
      description: The targets to be scanned.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
    - contextPath: TenableIO.Scan.StartTime
      description: The scheduled start time for the scan.
      type: string
    - contextPath: TenableIO.Scan.EndTime
      description: The scan end time for the scan.
      type: string
    - contextPath: TenableIO.Scan.Scanner
      description: The scanner assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.Policy
      description: The policy assigned for the scan.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Id
      description: The unique ID of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: The severity level of the vulnerability.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Description
      description: The description of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Synopsis
      description: A brief summary of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Solution
      description: Information on how to fix the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.FirstSeen
      description: When the vulnerability was first seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.LastSeen
      description: When the vulnerability was last seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: A count of the vulnerability occurrences.
      type: number
    - contextPath: TenableIO.Assets.Hostname
      description: The name of the host.
      type: string
    - contextPath: TenableIO.Assets.Score
      description: The overall score for the host.
      type: number
    - contextPath: TenableIO.Assets.Critical
      description: The percentage of critical findings on the host.
      type: number
    - contextPath: TenableIO.Assets.High
      description: The number of high findings on the host.
      type: number
    - contextPath: TenableIO.Assets.Medium
      description: The number of medium findings on the host.
      type: number
    - contextPath: TenableIO.Assets.Low
      description: The number of low findings on the host.
      type: number
    - contextPath: TenableIO.Remediations.Id
      description: The unique id of the remediation.
      type: string
    - contextPath: TenableIO.Remediations.Description
      description: Specific information related to the vulnerability and steps to
        remedy.
      type: string
    - contextPath: TenableIO.Remediations.AffectedHosts
      description: The number of hosts affected.
      type: number
    - contextPath: TenableIO.Remediations.AssociatedVulnerabilities
      description: The number of vulnerabilities associated with the remedy.
      type: number
    description: Retrive scan-report for the given scan.
  - name: tenable-io-get-vulnerability-details
    arguments:
    - name: vulnerabilityId
      required: true
      default: true
      description: The unique ID of the vulnerability.
    outputs:
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: Integer [0-4] indicating how severe the vulnerability is, where
        0 is info only.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Type
      description: The type of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Family
      description: Object containing plugin information such as family, type, and
        publication and modification dates.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Description
      description: The description of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Synopsis
      description: A brief summary of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Solution
      description: Information on how to fix the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.FirstSeen
      description: When the vulnerability was first seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.LastSeen
      description: When the vulnerability was last seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.PublicationDate
      description: The publication date of the vulnerability.
      type: date
    - contextPath: TenableIO.Vulnerabilities.ModificationDate
      description: The last modification date for the vulnerability in Unix time.
      type: date
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: A count of the vulnerability occurrences.
      type: number
    - contextPath: TenableIO.Vulnerabilities.CvssVector
      description: The Common Vulnerability Scoring System vector.
      type: string
    - contextPath: TenableIO.Vulnerabilities.CvssBaseScore
      description: The Common Vulnerability Scoring System allotted base score.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Cvss3Vector
      description: The Common Vulnerability Scoring System version 3 vector.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Cvss3BaseScore
      description: The Common Vulnerability Scoring System version 3 allotted base
        score.
      type: string
    description: Retrieve details for the given vulnerability.
  - name: tenable-io-get-vulnerabilities-by-asset
    arguments:
    - name: hostname
      description: Hostname of the asset.
    - name: ip
      description: IP of the asset.
    - name: dateRange
      description: The number of days of data prior to and including today that should
        be returned.
    outputs:
    - contextPath: TenableIO.Assets.Hostname
      description: Hostname of the asset.
      type: number
    - contextPath: TenableIO.Assets.Vulnerabilities
      description: A list of all the vuulnerability IDs associated with the asset.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Id
      description: The unique vulnerability's ID.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability's.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: Integer [0-4] indicating how severe the vulnerability is, where
        0 is info only.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Family
      description: The vulnerability's family.
      type: string
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: The number of times the vulnerability was found.
      type: number
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityState
      description: The current state of the reported vulnerability (Active, Fixed,
        New, etc.)
      type: string
    description: Get a list of up to 5000 of the vulnerabilities recorded for a given
      asset.
  - name: tenable-io-get-scan-status
    arguments:
    - name: scanId
      required: true
      default: true
      description: The unique ID of the Scan.
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan specified.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan specified.
      type: string
    description: 'Check the status of a specific scan using its ID. The status can
      hold following possible values : Running, Completed and Empty (Ready to run).'
  runonce: false
tests:
  - Tenable.io test
