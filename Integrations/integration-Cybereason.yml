versionedfields: {}
commonfields:
  id: Cybereason
  version: -1
name: Cybereason
display: Cybereason
category: Endpoint
image: data:image/png;base64,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
description: Gets processes/connections using the Cybereason API.
detaileddescription: |-
  The Cybereason API enables:
  * Check if a machine has an active Cybereason probe
  * Query for processes
  * Query for connections

  Connect using credentials (username, password). A cookie is returned, which is used for future connections.
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Do not validate server certificate (insecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: true
  type: 8
  required: false
script:
  script: |
    var username = params.credentials.identifier;
    var password = params.credentials.password;
    var server = params.server;
    var proxy = params.proxy;
    var insecure = params.insecure;

    if (server[server.length - 1] === '/') {
        server = server.substring(0, server.length - 1);
    }

    var urlDict = {
        'login': 'login.html',
        'query': 'rest/visualsearch/query/simple',
    }

    var headersDict = {
        'login': {'Content-Type': ['application/x-www-form-urlencoded']},
        'query': {'Content-Type': ['application/json']},
    };

    var processInfo = [
        {field: 'elementDisplayName', header: 'Name', type: 'filterData'},
        {field: 'imageFile.maliciousClassificationType', header: 'Malicious', type: 'simple'},
        {field: 'creationTime', header: 'Creation Time', type: 'time'},
        {field: 'endTime', header: 'End Time', type: 'time'},
        {field: 'commandLine', header: 'Command Line', type: 'simple'},
        {field: 'isImageFileSignedAndVerified', header: 'Signed and Verified', type: 'simple'},
        {field: 'productType', header: 'Product Type', type: 'simple'},
        {field: 'children', header: 'Children', type: 'simple'},
        {field: 'parentProcess', header: 'Parent', type: 'element'},
        {field: 'ownerMachine', header: 'Owner Machine', type: 'element'},
        {field: 'calculatedUser', header: 'User', type: 'element'},
        {field: 'imageFile', header: 'Image File', type: 'element'},
        {field: 'imageFile.sha1String', header: 'SHA1', type: 'simple'},
        {field: 'imageFile.md5String', header: 'MD5', type: 'simple'},
        {field: 'imageFile.companyName', header: 'Company Name', type: 'simple'},
        {field: 'imageFile.productName', header: 'Product Name', type: 'simple'}
    ];

    var processFields = [];
    processInfo.forEach(function(element) {
        processFields.push(element.field);
    });

    var processHeaders = [];
    processInfo.forEach(function(element) {
        processHeaders.push(element.header);
    });

    var connectionInfo = [
        {field: 'elementDisplayName', header: 'Name', type: 'simple'},
        {field: 'direction', header: 'Direction', type: 'simple'},
        {field: 'serverAddress', header: 'Server Address', type: 'simple'},
        {field: 'serverPort', header: 'Server Port', type: 'simple'},
        {field: 'portType', header: 'Port Type', type: 'simple'},
        {field: 'aggregatedReceivedBytesCount', header: 'Received Bytes', type: 'simple'},
        {field: 'aggregatedTransmittedBytesCount', header: 'Transmitted Bytes', type: 'simple'},
        {field: 'remoteAddressCountryName', header: 'Remote Country', type: 'simple'},
        {field: 'ownerMachine', header: 'Owner Machine', type: 'element'},
        {field: 'ownerProcess', header: 'Owner Process', type: 'element'},
        {field: 'calculatedCreationTime', header: 'Creation Time', type: 'time'},
        {field: 'endTime', header: 'End Time', type: 'time'}
    ];

    var connectionFields = [];
    connectionInfo.forEach(function(element) {
        connectionFields.push(element.field);
    });

    var connectionHeaders = [];
    connectionInfo.forEach(function(element) {
        connectionHeaders.push(element.header);
    });

    var saveCookies = function(cookies) {
        setIntegrationContext({'cookies': cookies});
    }

    var checkCookies = function() {
        var contextData = getIntegrationContext();
        var cookies = contextData ? contextData.cookies : {};
        var shouldRequestCookies = true;
        if (cookies && (cookies.length == 2)) {
            var currentTime = new Date();
            var cookiesTime = new Date(cookies[1].Expires);
            var timeDifferenceInDays = Math.abs((currentTime.getTime() - cookiesTime.getTime()) / (1000 * 60 * 60 * 24));
            if (timeDifferenceInDays < 2) {
                shouldRequestCookies = false;
            }
        }

        return {'shouldRequestCookies': shouldRequestCookies, 'cookies': cookies};
    }

    var buildEmptyEntryContext = function() {
        return {Type: entryTypes.note, Contents: null, ContentsFormat: formats.json, EntryContext: {}};
    }

    var updateContext = function(entry, outputs, contextPath) {
        if (args.saveToContext == 'true') {
            var contexts = [];
            for (var i = 0; i < outputs.length; i++) {
                contexts.push(convertKeysToPascalCase(outputs[i]));
            }
            entry.EntryContext[contextPath] = contexts;
        }
    }

    var updateOutput = function(output, simpleValues, elementValues, infoDict) {
        for (var i = 0; i < infoDict.length; i++) {
            switch (infoDict[i].type) {
                case 'simple':
                    if (simpleValues[infoDict[i].field]) {
                        output[infoDict[i].header] = simpleValues[infoDict[i].field].values[0];
                    }
                    break;

                case 'element':
                    if (elementValues[infoDict[i].field]) {
                        output[infoDict[i].header] = elementValues[infoDict[i].field].elementValues[0].name;
                    }
                    break;

                case 'time':
                    if (simpleValues[infoDict[i].field]) {
                        output[infoDict[i].header] = convertTimestampToString(simpleValues[infoDict[i].field].values[0]);
                    }
                    break;
            }
        }
    }

    var login = function() {
        var url = urlDict['login'];
        var headers = headersDict['login'];
        var body = 'username=' + username + '&password=' + password;
        var completeUrl = server + '/' + url;

        var res = http(
            completeUrl,
            {
                Method: 'POST',
                Body: body,
                Headers: headers
            },
            insecure,
            proxy,
            true // no redirection
        );

        if ((res.StatusCode < 200 || res.StatusCode >= 300) && (res.StatusCode != 302)) {
            throw 'Failed to login, request status code: ' + res.StatusCode + ' and Body: ' + res.Body + '.';
        }

        return res;
    }

    var sendRequest = function(url, headers, body, cookies) {
        var completeUrl = server + '/' + url;
        var res = http(
            completeUrl,
            {
                Method: 'POST',
                Body: body,
                Headers: headers,
                Cookies: cookies
            },
            insecure,
            proxy
        );

        if (res.StatusCode < 200 || res.StatusCode >= 300) {
            throw 'Action failed, request status code: ' + res.StatusCode + ' and Body: ' + res.Body + '.';
        }

        if (res.Headers['Content-Type'][0] != 'application/json') {
            throw 'Response Content-Type is not application/json.';
        }

        return JSON.parse(res.Body);
    }

    var buildQuery = function(queryFields, path) {
        var resultsLimit = args.limit ? parseInt(args.limit) : 10000;

        var query = {
            customFields: queryFields,
            perFeatureLimit: 100,
            perGroupLimit: 100,
            queryPath: path,
            queryTimeout: 120000,
            templateContext: 'SPECIFIC',
            totalResultLimit: resultsLimit
        };

        return query;
    }

    var isProbeConnected = function(cookies) {
        var queryFields = ['elementDisplayName'];
        var path = [
            {
                requestedType: 'Machine',
                filters: [
                    {facetName: 'elementDisplayName', values: [args.machine]},
                    {facetName: 'isActiveProbeConnected', values: [true]}
                ],
                isResult: true
            }
        ];

        var body = buildQuery(queryFields, path);
        res = sendRequest(urlDict['query'], headersDict['query'], JSON.stringify(body), cookies);
        var elements = res.data.resultIdToElementDataMap;
        for (var key in elements) {
            if (elements[key].simpleValues.elementDisplayName.values[0] == args.machine) {
                return true;
            }
        }

        return false;
    }

    var queryProcesses = function(cookies) {
        var machineFilters = [];
        var processFilters = [];

        if (args.machine) {
            machineFilters.push({facetName: 'elementDisplayName', values: [args.machine]});
        }

        if (args.processName) {
            processFilters.push({facetName: 'elementDisplayName', values: [args.processName]});
        }

        if (args.onlySuspicious && (args.onlySuspicious == 'true')) {
            processFilters.push({facetName: 'hasSuspicions', values: [true]});
        }

        if (args.hasIncomingConnection == 'true') {
            processFilters.push({facetName: 'hasIncomingConnection', values: [true]});
        }

        if (args.hasOutgoingConnection == 'true') {
            processFilters.push({facetName: 'hasOutgoingConnection', values: [true]});
        }

        var path = [
            {
                requestedType: 'Machine',
                filters: machineFilters,
                connectionFeature: {elementInstanceType: 'Machine', featureName: 'processes'}
            },
            {
                requestedType: 'Process',
                filters: processFilters,
                isResult: true
            }
        ];

        var body = buildQuery(processFields, path);

        res = sendRequest(urlDict['query'], headersDict['query'], JSON.stringify(body), cookies);

        var elements = res.data.resultIdToElementDataMap;
        var outputs = [];
        for (var key in elements) {
            var simpleValues = elements[key].simpleValues;
            var elementValues = elements[key].elementValues;

            var output = {};
            for (var i = 0; i < processInfo.length; i++) {
                switch (processInfo[i].type) {
                    case 'filterData':
                        output[processInfo[i].header] = elements[key].filterData.groupByValue;
                        break;
                }
            }

            updateOutput(output, simpleValues, elementValues, processInfo);
            outputs.push(output);
        }

        var entry = buildEmptyEntryContext();
        entry.HumanReadable = tableToMarkdown('Cybereason Processes', outputs, processHeaders);
        updateContext(entry, outputs, 'Process');
        entry.Contents = res;
        entry.ContentsFormat = formats.json;

        return entry;
    }

    var queryConnections = function(cookies) {
        queryFilters = [];
        if (args.ip) {
            queryFilters.push({facetName: 'elementDisplayName', values: [args.ip]});
        }
        var path = [
            {
                requestedType: 'Connection',
                filters: queryFilters,
                isResult: true
            }
        ];

        var body = buildQuery(connectionFields, path);

        res = sendRequest(urlDict['query'], headersDict['query'], JSON.stringify(body), cookies);

        var elements = res.data.resultIdToElementDataMap;
        var outputs = [];
        for (var key in elements) {
            var simpleValues = elements[key].simpleValues;
            var elementValues = elements[key].elementValues;

            if (
                args.machine &&
                elementValues.ownerMachine.elementValues &&
                (args.machine != elementValues.ownerMachine.elementValues[0].name)
            ) {
                continue;
            }

            var output = {};
            updateOutput(output, simpleValues, elementValues, connectionInfo);
            outputs.push(output);
        }

        var entry = buildEmptyEntryContext();
        entry.HumanReadable = tableToMarkdown('Cybereason Connections', outputs, connectionHeaders);
        updateContext(entry, outputs, 'Connection');
        entry.Contents = res;
        entry.ContentsFormat = formats.json;

        return entry;
    }

    if (command != 'test-module') {
        var cookiesInfo = checkCookies();
        var shouldLogin = cookiesInfo.shouldRequestCookies;

        var cookies;
        if (shouldLogin) {
            var loginRes = login();
            cookies = loginRes.Cookies;
            saveCookies(cookies);
        } else {
            cookies = cookiesInfo.cookies;
        }
    }

    var res;
    switch (command) {
        case 'test-module':
            res = login();
            if (res.Cookies) {
                return 'ok';
            }
            break;

        case 'cybereason-is-probe-connected':
            res = isProbeConnected(cookies);
            break;

        case 'cybereason-query-processes':
            res = queryProcesses(cookies);
            break;

        case 'cybereason-query-connections':
            res = queryConnections(cookies);
            break;

        case 'cybereason-login':
            res = login();
            saveCookies(res.Cookies);
        default:
            break;
    }

    return res;
  type: javascript
  commands:
  - name: cybereason-query-processes
    arguments:
    - name: machine
      description: The hostname of the machine.
    - name: onlySuspicious
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Show only suspicious processes.
      defaultValue: "false"
    - name: limit
      description: Maximum number of results to retrieve.
      defaultValue: "10000"
    - name: processName
      description: Process name to filter by.
    - name: saveToContext
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true, save the result to the context.
      defaultValue: "false"
    - name: hasIncomingConnection
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Filter only processes with incoming connections.
      defaultValue: "false"
    - name: hasOutgoingConnection
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Filter only processes with outgoing connections.
      defaultValue: "false"
    outputs:
    - contextPath: Process.Name
      description: The process name
    - contextPath: Process.Malicious
      description: Malicious status of the process
    - contextPath: Process.CreationTime
      description: The process creation time
    - contextPath: Process.EndTime
      description: The process end time
    - contextPath: Process.CommandLine
      description: The command line of the process
    - contextPath: Process.SignedAndVerified
      description: Is the process signed and verified
    - contextPath: Process.ProductType
      description: The product type
    - contextPath: Process.Children
      description: Children of the process
    - contextPath: Process.Parent
      description: The parent process
    - contextPath: Process.OwnerMachine
      description: The machine's hostname
    - contextPath: Process.User
      description: The user who ran the process
    - contextPath: Process.ImageFile
      description: Image file of the process
    - contextPath: Process.SHA1
      description: SHA1 of the process file
    - contextPath: Process.MD5
      description: MD5 of the process file
    - contextPath: Process.CompanyName
      description: The company's name
    - contextPath: Process.ProductName
      description: The product's name
    description: Searches for processes with various filters.
  - name: cybereason-login
    arguments: []
    description: Logs in and updates the cookies.
  - name: cybereason-is-probe-connected
    arguments:
    - name: machine
      required: true
      description: The hostname of the machine to check.
    description: Checks if the given hostname exists in Cybereason.
  - name: cybereason-query-connections
    arguments:
    - name: ip
      description: Filter connections which contain this IP (in or out).
    - name: machine
      description: Filter connections on the given machine.
    - name: saveToContext
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true, save the result to the context.
      defaultValue: "false"
    outputs:
    - contextPath: Connection.Name
      description: The connection's name
    - contextPath: Connection.Direction
      description: OUTGOING/INCOMING
    - contextPath: Connection.ServerAddress
      description: Address of the Cybereason machine
    - contextPath: Connection.ServerPort
      description: Port of the Cybereason machine
    - contextPath: Connection.PortType
      description: Type of the connection
    - contextPath: Connection.ReceivedBytes
      description: Received bytes count
    - contextPath: Connection.TransmittedBytes
      description: Transmitted bytes count
    - contextPath: Connection.RemoteCountry
      description: The connection's remote country
    - contextPath: Connection.OwnerMachine
      description: The machine's hostname
    - contextPath: Connection.OwnerProcess
      description: The process which performed the connection
    - contextPath: Connection.CreationTime
      description: Creation time of the connection
    - contextPath: Connection.EndTime
      description: End time of the connection
    description: Searches for connections.
hidden: false
