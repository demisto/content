commonfields:
  id: WildFire
  version: -1
name: WildFire
fromversion: 4.0.0
display: Palo Alto Networks WildFire
category: Forensics & Malware Analysis
image: data:image/png;base64,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
description: Perform malware dynamic analysis
detaileddescription: |-
  Don’t have a WildFire API key?
  Go to your WildFire account,
  Login to: https://wildfire.paloaltonetworks.com/wildfire/account
  Select the “Account” tab
  Copy your API Key
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: https://wildfire.paloaltonetworks.com/publicapi
  type: 0
  required: true
- display: API Key
  name: token
  defaultvalue: ""
  type: 4
  required: true
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |+
    //DICTIONARIES//
    var URL_DICT = {
        verdict: '/get/verdict',
        verdicts: '/get/verdicts',
        upload: '/submit/file',
        uploadUrl: '/submit/link',
        report: '/get/report',
        remoteFile: '/submit/url'
    };

    var ERROR_DICT = {
        401 : 'Unauthorized, API key invalid',
        404 : 'Not Found, The report was not found',
        405 : 'Method Not Allowed, Method other than POST used',
        413 : 'Request Entity Too Large, Sample file size over max limit',
        415 : 'Unsupported Media Type',
        418 : 'Unsupported File Type Sample, file type is not supported',
        419 : 'Request quota exceeded',
        420 : 'Insufficient arguments',
        421 : 'Invalid arguments',
        500 : 'Internal error',
        502 : 'Bad Gateway',
        513 : 'File upload failed'
    };

    var VERDICTS_DICT = {
        '0': 'benign',
        '1': 'malware',
        '2': 'grayware',
        '4': 'phishing',
        '-100': 'pending, the sample exists, but there is currently no verdict',
        '-101': 'error',
        '-102': 'unknown, cannot find sample record in the database',
        '-103': 'invalid hash value'
    };

    var VERDICTS_TO_DBOTSCORE = {
        '0': 1,
        '1': 3,
        '2': 2,
        '4': 3,
        '-100': 0,
        '-101': 0,
        '-102': 0,
        '-103': 0
    };

    //GLOBALS//
    var URL = params.server.replace(/[\/]+$/, '');
    var DEFAULT_HEADERS = {'Content-Type': ['application/x-www-form-urlencoded']};
    var TOKEN = params.token;

    var MD5_REGEX = /\b[a-fA-F\d]{32}\b/m;
    var SHA1_REGEX = /\b[a-fA-F\d]{40}\b/m;
    var SHA256_REGEX = /\b[a-fA-F\d]{64}\b/m;

    //HELPERS//
    function sendRequest(url, body, headers) {
        url.replace(/[\/]+$/, '');
        var res = http(
            url,
            {
                Method: 'POST',
                Body: body,
                Headers: headers
            },
            params.insecure,
            params.proxy
        );

        if (res.StatusCode !== 200) {
            if (res.StatusCode === 404) {
                return undefined;
            } else if (ERROR_DICT[res.StatusCode]) {
                throw 'Request Failed.\nStatus code: ' + res.StatusCode + ' ' + ERROR_DICT[res.StatusCode];
            } else {
                throw 'Request Failed.\nStatus code: ' + res.StatusCode + '.\nBody: ' + JSON.stringify(res) + '.';
            }
        }
        return res;
    }


    function sendMultipartRequest(url, headers, file, body) {
        var res = httpMultipart(
          url,
          file,
          {
            Method: 'POST',
            Headers: headers,
          },
          body,
          params.insecure,
          params.proxy
        );

        if (res.StatusCode !== 200) {
            if (ERROR_DICT[res.StatusCode]) {
                throw 'Request Failed.\nStatus code: ' + res.StatusCode + ' ' + ERROR_DICT[res.StatusCode];
            } else {
                throw 'Request Failed.\nStatus code: ' + res.StatusCode + '.\nBody: ' + JSON.stringify(res) + '.';
            }
        }
        return JSON.parse(x2j(res.Body));
    }


    function prettifyUploadBody(body) {
        var prettyUploadBody = {
            'MD5': body.md5,
            'SHA256': body.sha256,
            'Status': 'Pending'
        };
        if (body.filetype) {
            prettyUploadBody.FileType = body.filetype;
        }
        if (body.size) {
            prettyUploadBody.Size = body.size;
        }
        if (body.url) {
            prettyUploadBody.URL = body.url;
        }
        return prettyUploadBody;
    }


    function prettifyVerdict(verdictData) {
        var prettyVerdict = {};
        if (verdictData.md5) {
            prettyVerdict.MD5 = verdictData.md5;
        }
        if (verdictData.sha256) {
            prettyVerdict.SHA256 = verdictData.sha256;
        }
        prettyVerdict.Verdict = Number(verdictData.verdict);
        prettyVerdict.VerdictDescription = VERDICTS_DICT[verdictData.verdict];

        return prettyVerdict;
    }


    function createDBotScoreFromVerdict(prettyVerdict) {
        if (!prettyVerdict.SHA256 && !prettyVerdict.MD5) {
            throw 'Hash is missing in WildFire verdict.';
        }
        if (VERDICTS_TO_DBOTSCORE[prettyVerdict.Verdict] === undefined) {
            throw 'This hash verdict is not mapped to a DBotScore. Contact Demisto support for more information.';
        }
        var DbotScore = {
            'Indicator': prettyVerdict.SHA256? prettyVerdict.SHA256 : prettyVerdict.MD5,
            'Type': 'hash',
            'Vendor': 'WildFire',
            'Score': VERDICTS_TO_DBOTSCORE[prettyVerdict.Verdict]
        };
        return DbotScore;
    }


    function prettifyVerdicts(verdictsData) {
        var prettyVerdictsArr = [];
        for (var i = 0; i < verdictsData.length; i++) {
            var prettyVerdict = {};
            if (verdictsData[i].md5) {
                prettyVerdict.MD5 = verdictsData[i].md5;
            }
            if (verdictsData[i].sha256) {
                prettyVerdict.SHA256 = verdictsData[i].sha256;
            }
            prettyVerdict.Verdict = Number(verdictsData[i].verdict);
            prettyVerdict.VerdictDescription = VERDICTS_DICT[verdictsData[i].verdict];

            prettyVerdictsArr.push(prettyVerdict);
        }
        return prettyVerdictsArr;
    }


    function createDBotScoreFromVerdicts(prettyVerdicts) {
        var DbotScoreArr = [];
        for (var i = 0; i < prettyVerdicts.length; i++) {
            if (!prettyVerdicts[i].SHA256 && !prettyVerdicts[i].MD5) {
                throw 'Hash is missing in WildFire verdict.';
            }
            if (VERDICTS_TO_DBOTSCORE[prettyVerdicts[i].Verdict] === undefined) {
                throw 'This hash verdict is not mapped to a DBotScore. Contact Demisto support for more information.';
            }
            var DbotScore = {
                'Indicator': prettyVerdicts[i].SHA256? prettyVerdicts[i].SHA256 : prettyVerdicts[i].MD5,
                'Type': 'hash',
                'Vendor': 'WildFire',
                'Score': VERDICTS_TO_DBOTSCORE[prettyVerdicts[i].Verdict]
            };
        DbotScoreArr.push(DbotScore);
        }
        return DbotScoreArr;
    }


    function createUploadEntry(body, title, result) {
        var md = tableToMarkdown(title, body);
        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsFormat: formats.json,
            HumanReadable: md,
            ReadableContentsFormat: formats.markdown,
            EntryContext: {
                "WildFire.Report(val.SHA256 === obj.SHA256 || val.MD5 === obj.MD5)": prettifyUploadBody(body)
            }
        };
    }


    function createEntry(body, title, result, verbose, report, ec) {
        var md = tableToMarkdown(title, body, Object.keys(body));
        if (verbose) {
            for (var i = 0; i < report.length; i++) {
                md += tableToMarkdown('Report ' + i, report[i], Object.keys(report[i]));
            }
        }
        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsFormat: formats.json,
            HumanReadable: md,
            ReadableContentsFormat: formats.markdown,
            EntryContext: ec
        };
    }


    function hashArgsHandler(sha256, md5) {
        // sha256, md5 arguments are used in wildfire-report, wildfire-verdict commands
        var inputs = sha256? argToList(sha256) : argToList(md5);
        for (i = 0; i < inputs.length; i++) {
            if (SHA256_REGEX.test(inputs[i]) || MD5_REGEX.test(inputs[i])) {
                continue;
            } else {
                throw 'Invalid hash. Only SHA256 and MD5 are supported.';
            }
        }
        return inputs;
    }

    function fileArgsHandler(file, sha256, md5) {
        var inputs;
        // file/md5/sha256 are used in file command
        if ((file && !md5 && !sha256) || (!file && md5 && !sha256) || (!file && md5 && !sha256)) {
            if (file) {
                inputs = argToList(file);
            } else if (md5) {
                inputs = argToList(md5);
            } else {
                inputs = argToList(sha256);
            }
            for (i = 0; i < inputs.length; i++) {
                if (SHA1_REGEX.test(inputs[i])) { // validate hash is not sha1
                    inputs[i] = 'SHA1';
                }
                else if (SHA256_REGEX.test(inputs[i]) || MD5_REGEX.test(inputs[i])) {
                    continue;
                } else {
                    throw 'Invalid hash. Only SHA256 and MD5 are supported.';
                }
            }
        } else {
            throw 'Specify exactly 1 of the following arguments: file, sha256, md5';
        }

        return inputs;
    }


    //COMMANDS//
    function uploadFile(upload) {
        uri = URL + URL_DICT.upload;
        var body = {
            'apikey': TOKEN,
            'file' : upload
        };
        var result = sendMultipartRequest(uri, DEFAULT_HEADERS, upload, body);
        var uploadData = dq(result, 'wildfire.upload-file-info');
        var returnObj = {
            res: result,
            data: uploadData
        };
        return returnObj;
    }


    function getVerdicts(EntryID) {
        uri = URL + URL_DICT.verdicts;
        var body = {'apikey': TOKEN};
        var result = sendMultipartRequest(uri, DEFAULT_HEADERS, EntryID, body);

        var verdictsData = dq(result, 'wildfire.get-verdict-info');

        var prettyVerdicts = prettifyVerdicts(verdictsData);
        var md = tableToMarkdown('WildFire Verdicts', prettyVerdicts);

        var dbotScore = createDBotScoreFromVerdicts(prettyVerdicts);
        var ec = {
            "WildFire.Verdicts(val.SHA256 === obj.SHA256 || val.MD5 === obj.MD5)": prettyVerdicts,
            "DBotScore(val.Indicator === obj.Indicator)": dbotScore
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsFormat: formats.json,
            HumanReadable: md,
            ReadableContentsFormat: formats.markdown,
            EntryContext: ec
        };
    }


    function getVerdict(hash) {
        var uri = URL + URL_DICT.verdict;

        var body = 'apikey='+TOKEN+'&hash='+hash;
        var result = sendRequest(uri, body, DEFAULT_HEADERS);
        var jres = JSON.parse(x2j(result.Body));

        var verdictData = dq(jres, 'wildfire.get-verdict-info');

        var prettyVerdict = prettifyVerdict(verdictData);
        var md = tableToMarkdown('WildFire Verdict', prettyVerdict);

        var dbotScore = createDBotScoreFromVerdict(prettyVerdict);
        var ec = {
            "WildFire.Verdicts(val.SHA256 === obj.SHA256 || val.MD5 === obj.MD5)": prettyVerdict,
            "DBotScore(val.Indicator === obj.Indicator)": dbotScore
        };

        return {
            Type: entryTypes.note,
            Contents: jres,
            ContentsFormat: formats.json,
            HumanReadable: md,
            ReadableContentsFormat: formats.markdown,
            EntryContext: ec
        };
    }


    function uploadFileRemote(upload) {
        var uri = URL + URL_DICT.remoteFile;

        var body = {
            apikey: TOKEN,
            url: upload
        };
        var result = sendMultipartRequest(uri, DEFAULT_HEADERS, '', body);

        var uploadData = dq(result, 'wildfire.upload-file-info');

        var returnObj = {
            res: result,
            data: uploadData
        };
        return returnObj;
    }


    function uploadUrl(upload) {
       var uri = URL + URL_DICT.uploadUrl;

        var body = {
            apikey: TOKEN,
            link: upload
        };
        var result = sendMultipartRequest(uri, DEFAULT_HEADERS, '', body);

        var uploadData = dq(result, 'wildfire.submit-link-info');

        var returnObj = {
            res: result,
            data: uploadData
        };
        return returnObj;
    }


    function getReport(hash) {
        var reportUrl = URL + URL_DICT.report;

        var bodyXML = 'apikey='+TOKEN+'&format=xml&hash='+hash;
        var resXML = sendRequest(reportUrl, bodyXML, DEFAULT_HEADERS);

        if(!resXML){
          return {error: 'Report not found'};
        }
        var resXMLBody = resXML.Body;
        if(!resXMLBody){
          return {error: 'No results yet'};
        }

        var result = JSON.parse(x2j(resXMLBody));
        var report =  dq(result, 'wildfire.task_info.report');
        var file_info = dq(result, 'wildfire.file_info');
        if (!report || !file_info) {
            return {error: 'No results yet'};
        }

        var returnObj = {
            hash: hash,
            result: result,
            report: report,
            info: file_info
        };
        return returnObj;
    }


    function createReport(reportResponse, format, verbose) {
        var reportUrl = URL + URL_DICT.report;
        var result = reportResponse.result;
        var report = reportResponse.report;
        var file_info = reportResponse.info;
        var hash = reportResponse.hash;

        udp_ip = [];
        udp_port = [];
        tcp_ip = [];
        tcp_port = [];
        dns_query = [];
        dns_response = [];
        evidence_md5 = [];
        evidence_text = [];

        for (var i = 0; i < report.length; i++) {
            if ('network' in report[i]) {
                if (report[i].network) {
                    if ('UDP' in report[i].network) {
                        if ('-ip' in report[i].network.UDP) {
                            udp_ip.push(report[i].network.UDP['-ip']);
                        }
                        if ('-port' in report[i].network.UDP) {
                            udp_port.push(report[i].network.UDP['-port']);
                        }
                    }
                    if ('TCP' in report[i].network) {
                        if ('-ip' in report[i].network.TCP) {
                            tcp_ip.push(report[i].network.TCP['-ip']);
                        }
                        if ('-port' in report[i].network.TCP) {
                            tcp_port.push(report[i].network.TCP['-port']);
                        }
                    }
                    if ('dns' in report[i].network) {
                        for (var j = 0; j < report[i].network.dns.length; j++) {
                            if ('-query' in report[i].network.dns[j]) {
                                dns_query.push(report[i].network.dns[j]['-query']);
                            }
                            if ('-response' in report[i].network.dns[j]) {
                                dns_response.push(report[i].network.dns[j]['-response']);
                            }
                        }
                    }
                }
            }
            if ('evidence' in report[i]) {
                if ('file' in report[i].evidence) {
                    if (typeof report[i].evidence.file == 'object' && 'entry' in report[i].evidence.file) {
                        if ('-md5' in report[i].evidence.file.entry) {
                            evidence_md5.push(report[i].evidence.file.entry['-md5']);
                        }
                        if (typeof report[i].evidence.file == 'object' && '-text' in report[i].evidence.file.entry) {
                            evidence_text.push(report[i].evidence.file.entry['-text']);
                        }
                    }
                }
            }
        }

        var context = {
            DBotScore: {Indicator: hash, Type: 'hash', Vendor: 'WildFire', Score: 0 }
        };

        var outputs = {
            'Status': 'Success',
            'SHA256': reportResponse.info.sha256,
        };

        if (udp_ip.length || udp_port.length || tcp_ip.length || tcp_port.length || dns_query || dns_response) {

            outputs.Network = {};

            if (udp_ip.length || udp_port.length) {
                outputs.Network.UDP = {};
                if (udp_ip.length) {
                    outputs.Network.UDP.IP = udp_ip;
                }
                if (udp_port.length) {
                    outputs.Network.UDP.Port = udp_port;
                }
            }
            if (tcp_ip.length || tcp_port.length) {
                outputs.Network.TCP = {};
                if (tcp_ip.length) {
                    outputs.Network.TCP.IP = tcp_ip;
                }
                if (tcp_port.length) {
                    outputs.Network.TCP.Port = tcp_port;
                }
            }
            if (dns_query.length || dns_response.length) {
                outputs.Network.DNS = {};
                if (dns_query.length) {
                    outputs.Network.DNS.Query = dns_query;
                }
                if (dns_response.length) {
                    outputs.Network.DNS.Response = dns_response;
                }
            }
        }

        if (evidence_md5.length || evidence_text.length) {
            outputs.Evidence = {};
            if (evidence_md5.length) {
                outputs.Evidence.md5 = evidence_md5;
            }
            if (evidence_text.length) {
                outputs.Evidence.Text = evidence_text;
            }
        }

        context["WildFire.Report(val.SHA256 === obj.SHA256)"] = outputs;

        if (file_info) {
            if (file_info.malware === 'yes') {
                context.DBotScore.Score = 3;
                addMalicious(context, outputPaths.file, {
                    Type : file_info.filetype,
                    MD5 : file_info.md5,
                    SHA1 : file_info.sha1,
                    SHA256 : file_info.sha256,
                    Size : file_info.size,
                    Name : file_info.filename,
                    Malicious: {Vendor: 'WildFire'}
                });
            } else {
                context.DBotScore.Score = 1;
            }
        }
        if(format === 'pdf'){
            var bodyPDF = 'apikey=' + TOKEN + '&format=pdf&hash=' + hash;
            var resPDF = sendRequest(reportUrl, bodyPDF, DEFAULT_HEADERS).Bytes;
            var currentTime = new Date();
            var fileName = command + '_at_' + currentTime.getTime();
            return {
                Type: 9,
                FileID: saveFile(resPDF),
                File: fileName,
                Contents: fileName,
                EntryContext: context
            };
        }
        else{
            return createEntry(file_info, 'WildFire Report', result, verbose, report, context);
        }
    }


    function doReports(inputs) {
        var entries = [];
        for (i=0; i < inputs.length; i++) {
            if (inputs[i] == 'SHA1') {
                entries.push({
                    Type: 11, // warning type
                    Contents: 'WildFire file hash reputation supports only MD5, SHA256 hashes',
                    ContentsFormat: formats.markdown
                });
            } else {
                var reportResponse = getReport(inputs[i]);
                if (reportResponse.error) {
                    return reportResponse.error;
                }
                entries.push(createReport(reportResponse, args.format, args.verbose));
            }
        }
        return entries;
    }


    function detonate(type, upload, format, delay, timeout, verbose) {
        var uploadData;
        if (type === 'file') {
            uploadData = uploadFile(upload).data;
        } else { //type is remote file
            uploadData = uploadFileRemote(upload).data;
        }
        var sha = uploadData.sha256;
        delayTime = parseInt(delay);
        timeOut = parseInt(timeout);
        var waitTime = delayTime;
        wait(delayTime);

        while (waitTime<timeOut) {
            var reportResponse = getReport(undefined, sha);
            if (reportResponse.result) {
                return createReport(reportResponse, format, verbose);
            } else {
                waitTime = waitTime + delayTime;
                wait(delayTime);
            }
        }
        throw ('Timeout due to no answer after ' + timeOut + ' seconds.');
    }

    try {
        switch (command) {
            case 'test-module': // This is the call made when pressing the integration test button.
                testUrl = URL + URL_DICT.report;
                var res = http(
                    testUrl,
                    {
                        Method: 'POST',
                        Body: 'apikey=' + TOKEN + '&format=xml&hash=7f638f13d0797ef9b1a393808dc93b94',
                        Headers: DEFAULT_HEADERS
                    },
                    params.insecure,
                    params.proxy
                    );
                if (res.StatusCode === 200) {
                    return 'ok';
                }
                else {
                    return 'Something went wrong.\n Status code: ' + res.StatusCode + '\nBody: '+ JSON.stringify(res) + '.';
                }
                break;

            case 'file':
                var inputs = fileArgsHandler(args.file, args.md5, sha256);
                return doReports(inputs);

            case 'wildfire-upload':
                inputs = argToList(args.upload);
                entries = [];
                for (i=0; i < inputs.length; i++) {
                    var response = uploadFile(inputs[i]);
                    var uploadData = response.data;
                    var result = response.res;
                    entries.push(createUploadEntry(uploadData, 'WildFire Upload File', result));
                }
                return entries;

            case 'wildfire-upload-file-remote': //deprecated
            case 'wildfire-upload-file-url':
                var response = uploadFileRemote(args.upload);
                var uploadData = response.data;
                var result = response.res;
                return createUploadEntry(uploadData, 'WildFire Upload File URL', result);

            // case 'wildfire-upload-url':
            //     inputs = argToList(args.upload);
            //     entries = [];
            //     for (i=0; i < inputs.length; i++) {
            //         var response = uploadUrl(inputs[i]);
            //         var uploadData = response.data;
            //         var result = response.res;
            //         entries.push(createUploadEntry(uploadData, 'WildFire Upload URL', result));
            //     }
            //     return entries;

            case 'wildfire-report':
                var sha256 = args.sha256? args.sha256 : args.hash;
                var inputs = hashArgsHandler(sha256, args.md5);
                return doReports(inputs);

            case 'wildfire-get-verdict':
                var inputs = hashArgsHandler(args.hash, undefined);
                var entries = [];
                for (i=0; i < inputs.length; i++) {
                    var entry = getVerdict(inputs[i]);
                    entries.push(entry);
                }
                return entries;

            case 'wildfire-get-verdicts':
                var inputs = argToList(args.EntryID);
                var entries = [];
                for (i=0; i < inputs.length; i++) {
                    var entry = getVerdicts(inputs[i]);
                    entries.push(entry);
                }
                return entries;

            case 'detonate-file': //deprecated, please use WildFire Detonate playbook
                return detonate('file', args.upload, args.format, args.delay, args.timeout, args.verbose);

            case 'detonate-file-remote': //deprecated, please use WildFire Detonate playbook
                return detonate('remoteFile', args.upload, args.format, args.delay, args.timeout);
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            HumanReadable: err,
            ReadableContentsFormat: formats.text,
        };
    }

  type: javascript
  commands:
  - name: file
    arguments:
    - name: file
      default: true
      description: file hash to check
      isArray: true
    - name: md5
      description: md5 hash to check
      isArray: true
    - name: sha256
      description: sha256 hash to check
      isArray: true
    outputs:
    - contextPath: File.Name
      description: Filename
      type: string
    - contextPath: File.Type
      description: File type e.g. "PE"
      type: string
    - contextPath: File.Size
      description: File size
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submission
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 of the submission
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the report file
    - contextPath: InfoFile.Extension
      description: The extension of the report file
      type: string
    - contextPath: InfoFile.Name
      description: The name of the report file
      type: string
    - contextPath: InfoFile.Info
      description: The info of the report file
      type: string
    - contextPath: InfoFile.Size
      description: The size of the report file
      type: number
    - contextPath: InfoFile.Type
      description: The type of the report file
      type: string
    description: Retrieve results for a file hash using WildFire
  - name: wildfire-upload
    arguments:
    - name: upload
      required: true
      description: ID of the entry containing the file to upload
      isArray: true
    outputs:
    - contextPath: WildFire.Report.MD5
      description: MD5 of the submission
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 of the submission
      type: string
    - contextPath: WildFire.Report.FileType
      description: The type of the submission
      type: string
    - contextPath: WildFire.Report.Size
      description: The size of the submission
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submission
      type: string
    description: Upload file to WildFire for analysis
  - name: wildfire-upload-file-url
    arguments:
    - name: upload
      required: true
      description: URL of remote file to be uploaded
    outputs:
    - contextPath: WildFire.Report.MD5
      description: MD5 of the submission
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 of the submission
      type: string
    description: URL of remote file to be uploaded
  - name: wildfire-report
    arguments:
    - name: md5
      description: MD5 hash to check
      isArray: true
    - name: sha256
      description: SHA256 hash to check
      isArray: true
    - name: hash
      deprecated: true
      description: Deprecated - use sha256 argument
      isArray: true
    - name: format
      auto: PREDEFINED
      predefined:
      - xml
      - pdf
      description: Optional - request a structured report (formatted as XML/PDF)
      defaultValue: pdf
    - name: verbose
      description: Receive extended information from WildFire
    outputs:
    - contextPath: File.Name
      description: Filename
      type: string
    - contextPath: File.Type
      description: File type e.g. "PE"
      type: string
    - contextPath: File.Size
      description: File size
      type: number
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submissiom
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 of the submission
      type: string
    - contextPath: InfoFile.EntryID
      description: The EntryID of the report file
      type: string
    - contextPath: InfoFile.Extension
      description: The extension of the report file
      type: string
    - contextPath: InfoFile.Name
      description: The name of the report file
      type: string
    - contextPath: InfoFile.Info
      description: The info of the report file
      type: string
    - contextPath: InfoFile.Size
      description: The size of the report file
      type: number
    - contextPath: InfoFile.Type
      description: The type of the report file
      type: string
    - contextPath: WildFire.Report.Network.UDP.IP
      description: Submission related IPs in UDP protocol
      type: string
    - contextPath: WildFire.Report.Network.UDP.Port
      description: Submission related ports in UDP protocol
      type: string
    - contextPath: WildFire.Report.Network.TCP.IP
      description: Submission related IPs in TCP protocol
      type: string
    - contextPath: WildFire.Report.Network.TCP.Port
      description: Submission related ports in TCP protocol
      type: string
    - contextPath: WildFire.Report.Network.DNS.Query
      description: Submission DNS queries
      type: string
    - contextPath: WildFire.Report.Network.DNS.Response
      description: Submission DNS responses
      type: string
    - contextPath: WildFire.Report.Evidence.md5
      description: Submission evidence md5
      type: string
    - contextPath: WildFire.Report.Evidence.Text
      description: Submission evidence text
      type: string
    description: Retrieve results for a file hash using WildFire
  - name: wildfire-get-verdict
    arguments:
    - name: hash
      required: true
      description: Hash to get verdict for
      isArray: true
    outputs:
    - contextPath: WildFire.Verdicts.MD5
      description: File MD5
      type: string
    - contextPath: WildFire.Verdicts.SHA256
      description: File SHA256
      type: string
    - contextPath: WildFire.Verdicts.Verdict
      description: File verdict
      type: number
    - contextPath: WildFire.Verdicts.VerdictDescription
      description: File verdict description
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Get a verdict regarding a hash
  - name: wildfire-get-verdicts
    arguments:
    - name: EntryID
      required: true
      description: EntryID of the text file that contains multiple hashes. Limit is
        500 hashes.
      isArray: true
    outputs:
    - contextPath: WildFire.Verdicts.MD5
      description: File MD5
      type: string
    - contextPath: WildFire.Verdicts.SHA256
      description: File SHA256
      type: string
    - contextPath: WildFire.Verdicts.Verdict
      description: File verdict
      type: number
    - contextPath: WildFire.Verdicts.VerdictDescription
      description: File verdict description
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Get a verdict regarding multiple hashes, stored in a txt file
  - name: wildfire-upload-file-remote
    arguments:
    - name: upload
      required: true
      description: URL of remote file to be uploaded
    outputs:
    - contextPath: WildFire.Report.MD5
      description: MD5 of the submission
      type: string
    - contextPath: WildFire.Report.SHA256
      description: SHA256 of the submission
      type: string
    - contextPath: WildFire.Report.FileType
      description: The type of the submission
      type: string
    - contextPath: WildFire.Report.Size
      description: The size of the submission
      type: number
    - contextPath: WildFire.Report.Status
      description: The status of the submission
      type: string
    description: Deprecated, use wildfire-upload-file-url instead
  - name: detonate-file
    deprecated: true
    arguments:
    - name: upload
      required: true
      description: ID of the entry containing the file to upload
    - name: delay
      description: Delay wait time between calls (in seconds)
      defaultValue: "7"
    - name: timeout
      description: Total wait time (in seconds)
      defaultValue: "60"
    - name: format
      auto: PREDEFINED
      predefined:
      - xml
      - pdf
      description: Optional - request a structured report (formatted as XML/PDF)
    outputs:
    - contextPath: File.Name
      description: Filename
    - contextPath: File.Type
      description: File type e.g. "PE"
    - contextPath: File.Size
      description: File size
    - contextPath: File.MD5
      description: MD5 hash of the file
    - contextPath: File.SHA1
      description: SHA1 hash of the file
    - contextPath: File.SHA256
      description: SHA256 hash of the file
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Deprecated, use detonate playbook instead.
  - name: detonate-file-remote
    deprecated: true
    arguments:
    - name: upload
      required: true
      description: URL of remote file to be uploaded
    - name: delay
      description: Delay wait time between calls (in seconds)
      defaultValue: "7"
    - name: timeout
      description: Total wait time (in seconds)
      defaultValue: "60"
    - name: format
      auto: PREDEFINED
      predefined:
      - xml
      - pdf
      description: Optional - request a structured report (formatted as XML/PDF)
    description: Deprecated, use detonate playbook instead
  runonce: false
tests:
- Wildfire Test
releaseNotes: Added md5,sha256 arguments options to !file command, regard non valid hash in the !file command as a warning. add sha256 argument and deprecate hash argument for wildfire-report.