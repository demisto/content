commonfields:
  id: ThreatConnect_v2
  version: -1
name: ThreatConnect_v2
display: ThreatConnect v2
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Threat intelligence platform.
configuration:
- display: Access ID
  name: accessId
  defaultvalue: ""
  type: 0
  required: true
- display: Secret Key
  name: secretKey
  defaultvalue: ""
  type: 4
  required: true
- display: baseUrl
  name: baseUrl
  defaultvalue: https://api.threatconnect.com
  type: 0
  required: true
- display: Default Organization
  name: defaultOrg
  defaultvalue: ""
  type: 0
  required: false
- display: ProxyIP  (or http://${ip} )
  name: proxyIp
  defaultvalue: ""
  type: 0
  required: false
- display: ProxyPort
  name: proxyPort
  defaultvalue: ""
  type: 0
  required: false
- display: Rating threshold for Malicious Indicators
  name: rating
  defaultvalue: "3"
  type: 0
  required: false
- display: Confidence threshold for Malicious Indicators
  name: confidence
  defaultvalue: "50"
  type: 0
  required: false
- display: Indicator Reputation Freshness (in days)
  name: freshness
  defaultvalue: "7"
  type: 0
  required: false
script:
  script: |2-




    ''' IMPORTS '''
    from urllib.parse import urlparse, quote
    from datetime import timedelta
    from distutils.util import strtobool
    from threatconnect import ThreatConnect
    from threatconnect.RequestObject import RequestObject
    from threatconnect.Config.ResourceType import ResourceType
    from threatconnect.Config.FilterOperator import FilterOperator
    from threatconnect.Config.IndicatorType import IndicatorType
    import time
    import copy
    import traceback
    import sys


    '''GLOBAL VARS'''
    FRESHNESS = int(demisto.params()['freshness'])
    MAX_CONTEXT = 100

    ''' HELPER FUNCTIONS '''


    def get_client():
        params = demisto.params()
        access = params['accessId']
        secret = params['secretKey']
        default_org = params.get('defaultOrg')
        url = params['baseUrl']
        proxy_ip = params['proxyIp']
        proxy_port = params['proxyPort']

        tc = ThreatConnect(access, secret, default_org, url)
        if proxy_ip and proxy_port and len(proxy_ip) > 0 and len(proxy_port) > 0:
            tc.set_proxies(proxy_ip, int(proxy_port))

        return tc


    def calculate_freshness_time(freshness):
        t = datetime.now() - timedelta(days=freshness)
        return t.strftime('%Y-%m-%dT00:00:00Z')


    def create_context(indicators, include_dbot_score=False):
        context = {
            'DBotScore': [],
            outputPaths['ip']: [],
            outputPaths['url']: [],
            outputPaths['domain']: [],
            outputPaths['file']: [],
            'TC.Indicator(val.ID && val.ID === obj.ID)': [],
        }  # type: dict
        tc_type_to_demisto_type = {
            'Address': 'ip',
            'URL': 'url',
            'Host': 'domain',
            'File': 'file'
        }
        type_to_value_field = {
            'Address': 'ip',
            'URL': 'text',
            'Host': 'hostName',
            'File': 'md5'
        }

        for ind in indicators:
            indicator_type = tc_type_to_demisto_type.get(ind['type'], ind['type'])
            value_field = type_to_value_field.get(ind['type'], 'summary')
            value = ind.get(value_field, ind.get('summary', ''))

            if ind.get('confidence') is not None:  # returned in specific indicator request - SDK
                confidence = int(ind['confidence'])
            else:
                # returned in general indicator request - REST API
                confidence = int(ind.get('threatAssessConfidence', 0))

            if ind.get('rating') is not None:  # returned in specific indicator request - SDK
                rating = int(ind['rating'])
            else:
                # returned in general indicator request - REST API
                rating = int(ind.get('threatAssessRating', 0))

            if confidence >= int(demisto.params()['rating']) and rating >= int(demisto.params()['confidence']):
                dbot_score = 3
                desc = ''
                if hasattr(ind, 'description'):
                    desc = ind.description
                mal = {
                    'Malicious': {
                        'Vendor': 'ThreatConnect',
                        'Description': desc,
                    }
                }
                if indicator_type == 'ip':
                    mal['Address'] = value

                elif indicator_type == 'file':
                    mal['MD5'] = value
                    mal['SHA1'] = ind.get('sha1')
                    mal['SHA256'] = ind.get('sha256')

                elif indicator_type == 'url':
                    mal['Data'] = value

                elif indicator_type == 'domain':
                    mal['Name'] = value

                context_path = outputPaths.get(indicator_type)
                if context_path is not None:
                    context[context_path].append(mal)

            elif int(rating) >= 1:
                dbot_score = 2
            else:
                dbot_score = 1

            if include_dbot_score:
                context['DBotScore'].append({
                    'Indicator': value,
                    'Score': dbot_score,
                    'Type': indicator_type,
                    'Vendor': 'ThreatConnect'
                })

            context['TC.Indicator(val.ID && val.ID === obj.ID)'].append({
                'ID': ind['id'],
                'Name': value,
                'Type': ind['type'],
                'Owner': ind['ownerName'],
                'Description': ind.get('description'),
                'CreateDate': ind['dateAdded'],
                'LastModified': ind['lastModified'],
                'Rating': rating,
                'Confidence': confidence,

                # relevant for domain
                'Active': ind.get('whoisActive'),

                # relevant for file
                'File.MD5': ind.get('md5'),
                'File.SHA1': ind.get('sha1'),
                'File.SHA256': ind.get('sha256'),
            })

            if 'group_associations' in ind:
                if len(ind['group_associations']) >= 0:
                    context['TC.Indicator(val.ID && val.ID === obj.ID)'][0]['IndicatorGroups'] = ind['group_associations']

            if 'indicator_associations' in ind:
                if len(ind['indicator_associations']) >= 0:
                    context['TC.Indicator(val.ID && val.ID === obj.ID)'][0]['IndicatorAssociations'] = ind['indicator_associations']

            if 'indicator_tags' in ind:
                if len(ind['indicator_tags']) >= 0:
                    context['TC.Indicator(val.ID && val.ID === obj.ID)'][0]['IndicatorTags'] = ind['indicator_tags']

            if 'indicator_observations' in ind:
                if len(ind['indicator_observations']) >= 0:
                    context['TC.Indicator(val.ID && val.ID === obj.ID)'][0]['IndicatorsObservations'] = ind['indicator_observations']

        context = {k: createContext(v, removeNull=True)[:MAX_CONTEXT] for k, v in context.items() if len(v) > 0}
        return context, context.get('TC.Indicator(val.ID && val.ID === obj.ID)', [])




    # pylint: disable=E1101
    def get_indicators(indicator_value=None, indicator_type=None, owners=None, rating_threshold=-1, confidence_threshold=-1,
                       freshness=None, associated_groups=False, associated_indicators=False,include_observations=False,include_tags=False):
        custom=False
        tc = get_client()

        indicators_obj = tc.indicators()
        if indicator_type is not None:
            types = tc_get_indicator_types_request()['data']['indicatorType']
            for item in types:
                if item['apiEntity'] == indicator_type.lower():
                    if 'value1Label' in item:
                        value1Label = item['value1Label']
                    apiEntity = item['apiEntity']
                    custom = json.loads(item['custom'])
            if custom is not False:
                _filter = indicators_obj.add_filter(IndicatorType.CUSTOM_INDICATORS, api_entity=apiEntity)
            else:
                _filter = indicators_obj.add_filter()
        else:
            _filter = indicators_obj.add_filter()

        if indicator_type is None:
            if indicator_value is not None:
                _filter.add_indicator(indicator_value)

        if custom is False:
            if indicator_type is not None:
                _filter.add_pf_type(indicator_type, FilterOperator.EQ)
            elif indicator_value.find("http://") > -1 and indicator_value.find("https://") > -1:
                _filter.add_pf_type("URL", FilterOperator.EQ)


        if owners is not None:
            _filter.add_owner(owners)

        if rating_threshold != -1:
            _filter.add_pf_rating(rating_threshold, FilterOperator.GE)
        if confidence_threshold != -1:
            _filter.add_pf_confidence(confidence_threshold, FilterOperator.GE)
        if freshness is not None:
            _filter.add_pf_last_modified(calculate_freshness_time(freshness), FilterOperator.GE)

        raw_indicators = indicators_obj.retrieve()
        indicators = [indicator.json for indicator in raw_indicators]
        if indicator_type is not None and custom is not False:
            for item in indicators:
                if item[value1Label] == indicator_value:
                    indicators = [item]
                    indicators[0]["summary"] = indicator_value

        groupIndicators = []
        associatedIndicators = []
        indicator_observations= []
        indicator_tags = []

        if associated_groups:
            indicators[0]['group_associations'] = tc_associated_groups(tc, owners,indicator_value, indicators[0]['type'])

        if include_tags:
            indicators[0]['indicator_tags'] = tc_indicator_get_tags(tc, owners,indicator_value, indicators[0]['type'])

        if include_observations:
            try:
                for indicator in raw_indicators:
                    for observation in indicator.observations:
                        indicator_observations.append({"count":observation.count,"date_observed":observation.date_observed})
                indicators[0]['indicator_observations'] = indicator_observations
            except Exception as e:
                indicators[0]['indicator_observations'] = indicator_observations
                pass

        if associated_indicators:
            try:
                for indicator in raw_indicators:
                    for associated_indicator in indicator.indicator_associations:
                        associatedIndicators.append({"id": associated_indicator.id,"indicator":associated_indicator.indicator,"type":associated_indicator.type,"description":associated_indicator.description,"owner_name":associated_indicator.owner_name,"rating":associated_indicator.rating,"confidence":associated_indicator.confidence,"date_added":associated_indicator.date_added,"last_modified":associated_indicator.last_modified,"weblink":associated_indicator.weblink})
                indicators[0]['indicator_associations'] = associatedIndicators
            except Exception as e:
                indicators[0]['indicator_associations'] = associatedIndicators
                pass

        return indicators


    ''' FUNCTIONS '''


    def ip_command():
        args = demisto.args()
        owners = args.get('owners', demisto.params().get('defaultOrg'))
        if not owners:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')
        rating_threshold = int(args.get('ratingThreshold', -1))
        confidence_threshold = int(args.get('confidenceThreshold', -1))
        ip_addr = args['ip']

        ec, indicators = ip(ip_addr, owners, rating_threshold, confidence_threshold)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect IP Reputation for: {}'.format(ip_addr), indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    @logger
    def ip(ip_addr, owners, rating_threshold, confidence_threshold):
        indicators = get_indicators(ip_addr, 'Address', owners, rating_threshold, confidence_threshold)

        if not indicators:
            demisto.results('Make sure that the indicator exists in your ThreatConnect environment')
        ec, indicators = create_context(indicators, include_dbot_score=True)

        return ec, indicators


    def url_command():
        args = demisto.args()
        owners = args.get('owners', demisto.params().get('defaultOrg'))
        if not owners:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')
        url_addr = args['url']
        parsed_url = urlparse(url_addr)
        if not parsed_url.scheme:
            return_error('Please provide a valid URL including a protocol (http/https)')
        rating_threshold = int(args.get('ratingThreshold', -1))
        confidence_threshold = int(args.get('confidenceThreshold', -1))

        ec, indicators = url(url_addr, owners, rating_threshold, confidence_threshold)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect URL Reputation for: {}'.format(url_addr), indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    @logger
    def url(url_addr, owners, rating_threshold, confidence_threshold):
        indicators = get_indicators(url_addr, 'URL', owners, rating_threshold, confidence_threshold)
        if not indicators:
            demisto.results('Make sure that the indicator exists in your ThreatConnect environment')
        ec, indicators = create_context(indicators, include_dbot_score=True)

        return ec, indicators


    def file_command():
        args = demisto.args()
        owners = args.get('owners', demisto.params().get('defaultOrg'))
        if not owners:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')
        file_name = args['file']
        rating_threshold = int(args.get('ratingThreshold', -1))
        confidence_threshold = int(args.get('confidenceThreshold', -1))

        ec, indicators = _file(file_name, owners, rating_threshold, confidence_threshold)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect File Report for: {}'.format(file_name), indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    #@logger
    def _file(url_addr, owners, rating_threshold, confidence_threshold):
        indicators = get_indicators(url_addr, 'File', owners, rating_threshold, confidence_threshold)
        if not indicators:
            demisto.results('Make sure that the indicator exists in your ThreatConnect environment')
        ec, indicators = create_context(indicators, include_dbot_score=True)

        return ec, indicators


    def domain_command():
        args = demisto.args()
        owners = args.get('owners', demisto.params().get('defaultOrg'))
        if not owners:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')
        rating_threshold = int(args.get('ratingThreshold', -1))
        confidence_threshold = int(args.get('confidenceThreshold', -1))
        domain_addr = args['domain']

        ec, indicators = domain(domain_addr, owners, rating_threshold, confidence_threshold)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect Domain Reputation for: {}'.format(domain_addr), indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    #@logger
    def domain(domain_addr, owners, rating_threshold, confidence_threshold):
        indicators = get_indicators(domain_addr, 'Host', owners, rating_threshold, confidence_threshold)
        ec, indicators = create_context(indicators, include_dbot_score=True)

        return ec, indicators


    def tc_owners_command():
        raw_owners = tc_owners()
        owners = []
        for owner in raw_owners['data']['owner']:
            owners.append({
                'ID': owner['id'],
                'Type': owner['type'],
                'Name': owner['name']
            })

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_owners,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect Owners:', owners),
            'EntryContext': {'TC.Owner(val.ID && val.ID === obj.ID)': owners}
        })


    #@logger
    def tc_owners():
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/owners')
        results = tc.api_request(ro)

        return results.json()

    def tc_associated_groups(tc, owners, indicator_value, indicator_type):
        group_associations = []
        types = tc_get_indicator_types_request()['data']['indicatorType']
        for item in types:
            if indicator_type is not None:
                if item['name'] == indicator_type:
                    apiBranch = item['apiBranch']
            else:
                # meaning we got an indicator but SDK returned a null type
                apiBranch = None

        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_owner(owners)
        if apiBranch is not None:
            ro.set_request_uri("/v2/indicators/"+ apiBranch + "/" + indicator_value + "/groups")
            results = tc.api_request(ro)
            if results.headers['content-type'] == 'application/json':
                if 'data' in results.json():
                    if 'group' in results.json()['data']:
                        group_associations = results.json()['data']['group']
                else:
                    group_associations = []
        else:
            try:
                for item in types:
                    ro.set_request_uri("/v2/indicators/"+ item['apiBranch'] + "/" + quote(indicator_value, safe='') + "/groups")
                    results = tc.api_request(ro)
                    if results.headers['content-type'] == 'application/json':
                        if 'data' in results.json():
                            if 'group' in results.json()['data']:
                                group_associations = results.json()['data']['group']
                                break
                        else:
                            group_associations = []
            except Exception as e:
                pass

        return group_associations

    def tc_indicator_get_tags(tc, owners, indicator_value, indicator_type):
        tags = []
        types = tc_get_indicator_types_request()['data']['indicatorType']
        for item in types:
            if indicator_type is not None:
                if item['name'] == indicator_type:
                    apiBranch = item['apiBranch']
            else:
                # meaning we got an indicator but SDK returned a null type
                apiBranch = None

        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_owner(owners)
        if apiBranch is not None:
            ro.set_request_uri("/v2/indicators/"+ apiBranch + "/" + indicator_value + "/tags")
            results = tc.api_request(ro)
            if results.headers['content-type'] == 'application/json':
                if 'data' in results.json():
                    if 'tag' in results.json()['data']:
                        tags = results.json()['data']['tag']
                else:
                    tags = []
        else:
            try:
                for item in types:
                    ro.set_request_uri("/v2/indicators/"+ item['apiBranch'] + "/" + quote(indicator_value, safe='') + "/tags")
                    results = tc.api_request(ro)
                    if results.headers['content-type'] == 'application/json':
                        if 'data' in results.json():
                            if 'tag' in results.json()['data']:
                                tags = results.json()['data']['tag']
                                break
                        else:
                            tags = []
            except Exception as e:
                pass

        return tags


    def tc_indicators_command():
        args = demisto.args()
        limit = int(args.get('limit', 500))
        owners = args.get('owners')
        ec, indicators, raw_response = tc_indicators(owners, limit)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect Indicators:', indicators, headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    #@logger
    def tc_indicators(owners, limit):
        tc = get_client()
        tc.set_api_result_limit(limit)
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/indicators?resultLimit={}'.format(limit))

        if owners is not None:
            ro.set_owner(owners)
            ro.set_owner_allowed(True)

        response = tc.api_request(ro).json()
        indicators = response['data']['indicator']
        ec, indicators = create_context(indicators, include_dbot_score=True)

        return ec, indicators, response


    def tc_get_tags_command():
        raw_response = tc_get_tags()
        tags = [t['name'] for t in raw_response['data']['tag']]

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect Tags:', tags, headers='Name'),
            'EntryContext': {'TC.Tags': tags}
        })


    #@logger
    def tc_get_tags():
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/tags')

        return tc.api_request(ro).json()


    def tc_tag_indicator_command():
        args = demisto.args()
        indicator = args['indicator']
        tag = args['tag']
        owners = args.get('owner')
        indicators = tc_tag_indicator(indicator, tag, owners)

        md = []
        for ind in indicators:
            md.append('Indicator {} with ID {}, was tagged with: {}'.format(indicator, ind.id, tag))

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': '\n'.join(md)
        })


    def tc_tag_indicator(indicator, tag, owners=None):
        tc = get_client()
        indicators = tc.indicators()
        filter1 = indicators.add_filter()
        filter1.add_indicator(indicator)

        if owners is not None:
            owners = owners.split(",")
            filter1.add_owner(owners)

        indicators = indicators.retrieve()
        for indicator in indicators:
            indicator.add_tag(tag)
            indicator.commit()

        return indicators




    def tc_get_indicator_command():
        args = demisto.args()
        owners = args.get('owners')
        if not owners:
            if 'defaultOrg' in demisto.params():
                owners = demisto.params().get('defaultOrg')
            else:
                return_error('You must specify an owner in the command, or by using the Organization parameter.')
        rating_threshold = int(args.get('ratingThreshold', -1))
        confidence_threshold = int(args.get('confidenceThreshold', -1))
        indicator = args['indicator']
        associated_groups = json.loads(args['group_associations'].lower())
        associated_indicators = json.loads(args['indicator_associations'].lower())
        include_tags = json.loads(args['indicator_tags'].lower())
        include_observations = json.loads(args['indicator_observations'].lower())
        if 'indicator_type' in args:
            indicator_type = args['indicator_type']
        else:
            indicator_type = None

        ec, indicators, raw_indicators,indicators_associations, indicator_groups, indicator_observations, indicator_tags = tc_get_indicator(indicator, owners, rating_threshold, confidence_threshold, associated_groups, associated_indicators,include_observations,include_tags,indicator_type)
        # remove extra items from the indicator markdown

        indicators = copy.deepcopy(ec)
        indicators = indicators['TC.Indicator(val.ID && val.ID === obj.ID)']

        if associated_groups:
            if 'IndicatorGroups' in indicators[0]:
                del indicators[0]['IndicatorGroups']
        if associated_indicators:
            if 'IndicatorAssociations' in indicators[0]:
                del indicators[0]['IndicatorAssociations']
        if include_tags:
            if 'IndicatorTags' in indicators[0]:
                del indicators[0]['IndicatorTags']
        if include_observations:
            if 'IndicatorsObservations' in indicators[0]:
                del indicators[0]['IndicatorsObservations']

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect indicator for: {}'.format(indicator), indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })

        if associated_groups:
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': indicator_groups,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('ThreatConnect Associated Groups for indicator: {}'.format(indicator), indicator_groups,
                                                 headerTransform=pascalToSpace)
        })


        if associated_indicators:
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': indicators_associations,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('ThreatConnect Associated Indicators for indicator: {}'.format(indicator), indicators_associations,
                                                 headerTransform=pascalToSpace)
        })

        if include_tags:
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': indicator_tags,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('ThreatConnect Tags for indicator: {}'.format(indicator), indicator_tags,
                                                 headerTransform=pascalToSpace)
        })


        if include_observations:
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': indicator_observations,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('ThreatConnect Observations for indicator: {}'.format(indicator), indicator_observations,
                                                 headerTransform=pascalToSpace)
        })

    @logger
    def tc_get_indicator(indicator, owners, rating_threshold, confidence_threshold,associated_groups,associated_indicators,include_observations,include_tags,indicator_type):
        raw_indicators = get_indicators(indicator, indicator_type=indicator_type, owners=owners, rating_threshold=rating_threshold,
                                        confidence_threshold=confidence_threshold,associated_groups=associated_groups,associated_indicators=associated_indicators,include_observations=include_observations,include_tags=include_tags)
        ec, indicators = create_context(raw_indicators, include_dbot_score=True)

        if 'group_associations' in raw_indicators[0]:
            indicator_groups = raw_indicators[0]['group_associations']
        else:
            indicator_groups = []

        if 'indicator_associations' in raw_indicators[0]:
            indicators_associations = raw_indicators[0]['indicator_associations']
        else:
            indicators_associations = []

        if 'indicator_tags' in raw_indicators[0]:
            indicator_tags = raw_indicators[0]['indicator_tags']
        else:
            indicator_tags = []

        if 'indicator_observations' in raw_indicators[0]:
            indicator_observations = raw_indicators[0]['indicator_observations']
        else:
            indicator_observations = []

        return ec, indicators, raw_indicators,indicators_associations,indicator_groups,indicator_observations, indicator_tags


    def tc_get_indicators_by_tag_command():
        args = demisto.args()
        tag = args['tag']
        owner = args.get('owner')
        response = tc_get_indicators_by_tag(tag, owner)
        raw_indicators = response['data']['indicator']
        ec, indicators = create_context(raw_indicators, include_dbot_score=True)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ThreatConnect Indicators with tag: {}'.format(tag), indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    #@logger
    def tc_get_indicators_by_tag(tag, owner):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        cmd = '/v2/tags/{}/indicators'.format(tag)
        if owner is not None:
            cmd += '?owner={}'.format(owner)

        ro.set_request_uri(cmd)

        return tc.api_request(ro).json()


    def tc_add_indicator_command():
        args = demisto.args()
        indicator = args['indicator']
        owner = args.get('owner', demisto.params().get('defaultOrg'))
        if not owner:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')

        rating = int(args.get('rating', 0))
        confidence = int(args.get('confidence', 0))

        tc_add_indicator(indicator, owner, rating, confidence)
        # get the indicator for full object data
        raw_indicators = get_indicators(indicator)
        ec, indicators = create_context(raw_indicators)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Created new indicator successfully:', indicators,
                                             headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    #@logger
    def tc_add_indicator(indicator, organization, rating=0, confidence=0):
        tc = get_client()
        indicators = tc.indicators()
        indicator = indicators.add(indicator, organization)
        indicator.set_rating(rating)
        indicator.set_confidence(confidence)

        return indicator.commit().json


    def tc_create_incident_command():
        args = demisto.args()
        incident_name = args['incidentName']
        owner = args.get('owner', demisto.params()['defaultOrg'])
        if not owner:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')

        event_date = args.get('eventDate', datetime.utcnow().isoformat().split('.')[0] + 'Z')
        tag = args.get('tag')
        security_label = args.get('securityLabel')
        description = args.get('description')

        raw_incident = tc_create_incident(incident_name, owner, event_date, tag, security_label, description)
        ec = {
            'ID': raw_incident['id'],
            'Name': raw_incident['name'],
            'Owner': raw_incident['ownerName'],
            'EventDate': raw_incident['eventDate'],
            'Tag': tag,
            'SecurityLabel': security_label
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_incident,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Incident {} Created Successfully'.format(incident_name),
            'EntryContext': {
                'TC.Incident(val.ID && val.ID === obj.ID)': createContext([ec], removeNull=True)
            }
        })


    #@logger
    def tc_create_incident(incident_name, owner, event_date, tag=None, security_label=None, description=None):
        tc = get_client()
        incidents = tc.incidents()
        incident = incidents.add(incident_name, owner)
        incident.set_event_date(event_date)
        if tag is not None:
            incident.add_tag(tag)
        if security_label is not None:
            incident.set_security_label(security_label)
        if description is not None:
            incident.add_attribute('Description', description)

        return incident.commit().json


    def tc_fetch_incidents_command():
        args = demisto.args()
        incident_id = args.get('incidentId')
        incident_name = args.get('incidentName')
        owner = args.get('owner')

        raw_incidents = tc_fetch_incidents(incident_id, incident_name, owner)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_incidents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Incidents:', raw_incidents, headerTransform=pascalToSpace),
            'EntryContext': {
                'TC.Incident(val.ID && val.ID === obj.ID)': createContext(raw_incidents, removeNull=True),
                'ThreatConnect.incidents': raw_incidents  # backward compatible
            }
        })


    #@logger
    def tc_fetch_incidents(incident_id, incident_name, owner):
        tc = get_client()
        incidents = tc.incidents()
        if any((incident_id, owner, incident_name)):
            filter1 = incidents.add_filter()
            if incident_id is not None:
                filter1.add_id(int(incident_id))
            if owner is not None:
                filter1.add_owner(owner)
            if incident_name is not None:
                filter1.add_pf_name(incident_name)

        incidents.retrieve()
        return [incident.json for incident in incidents]


    def tc_get_incident_associate_indicators_command():
        args = demisto.args()
        incident_id = int(args['incidentId'])
        owners = args.get('owner')
        if owners is not None:
            owners = owners.split(",")

        raw_indicators = tc_get_incident_associate_indicators(incident_id, owners)
        ec, indicators = create_context(raw_indicators, include_dbot_score=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Incident Associated Indicators:', indicators, headerTransform=pascalToSpace),
            'EntryContext': ec
        })


    #@logger
    def tc_get_incident_associate_indicators(incident_id, owners):
        tc = get_client()
        incidents = tc.incidents()
        _filter = incidents.add_filter()
        _filter.add_id(incident_id)

        incidents = incidents.retrieve()
        indicators = []
        for incident in incidents:
            for ind in incident.indicator_associations:
                if ind.type == 'File':
                    indicators.append(ind.indicator['md5'])
                else:
                    indicators.append(ind.indicator)
        if len(indicators) == 0:
            return []

        indicators_obj = tc.indicators()
        _filter = indicators_obj.add_filter()
        if owners is not None:
            _filter.add_owner(owners)
        for ind in indicators:
            _filter.add_indicator(ind)

        raw_indicators = indicators_obj.retrieve()
        return [indicator.json for indicator in raw_indicators]


    def tc_incident_associate_indicator_command():
        args = demisto.args()
        incident_id = int(args['incidentId'])
        indicator = args['indicator']
        types = {
            'ADDRESSES': ResourceType.ADDRESSES,
            'EMAIL_ADDRESSES': ResourceType.EMAIL_ADDRESSES,
            'FILES': ResourceType.FILES,
            'HOSTS': ResourceType.HOSTS,
            'URLS': ResourceType.URLS,
        }
        indicator_type = types.get(args['indicatorType'], args['indicatorType'])
        owners = args.get('owner')
        if owners is not None:
            owners = owners.split(",")

        incidents = tc_incident_associate_indicator(incident_id, indicator_type, indicator, owners)
        md = []
        for inc in incidents:
            md.append('Incident {} with ID {}, was tagged with: {}'.format(inc['name'], inc['id'], indicator))

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': incidents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '\n'.join(md),
            'EntryContext': {'TC.Incident(val.ID && val.ID === obj.ID)': createContext(incidents, removeNull=True)}
        })


    #@logger
    def tc_incident_associate_indicator(incident_id, indicator_type, indicator, owners):
        tc = get_client()
        incidents = tc.incidents()
        filter1 = incidents.add_filter()
        filter1.add_id(incident_id)
        if owners is not None:
            filter1.add_owner(owners)
        raw_incidents = incidents.retrieve()

        incidents = []
        for incident in raw_incidents:
            incident.associate_indicator(indicator_type, indicator)
            incidents.append(incident.commit().json)

        return incidents


    def tc_update_indicator_command():
        args = demisto.args()
        indicator = args['indicator']
        rating = args.get('rating')
        confidence = args.get('confidence')
        size = args.get('size')
        dns_active = args.get('dnsActive')
        whois_active = args.get('whoisActive')
        false_positive = args.get('falsePositive', 'False') == 'True'
        observations = int(args.get('observations', 0))
        security_label = args.get('securityLabel')
        threat_assess_confidence = int(args.get('threatAssessConfidence', -1))
        threat_assess_rating = int(args.get('threatAssessRating', -1))

        raw_indicators = tc_update_indicator(indicator, rating=rating, confidence=confidence, size=size,
                                             dns_active=dns_active, whois_active=whois_active,
                                             false_positive=false_positive, observations=observations,
                                             security_label=security_label,
                                             threat_assess_confidence=threat_assess_confidence,
                                             threat_assess_rating=threat_assess_rating)
        ec, indicators = create_context(raw_indicators)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '\n'.join('Indicator {} Updated Successfully'.format(ind['ID']) for ind in indicators),
            'EntryContext': ec
        })


    #@logger
    def tc_update_indicator(indicator, rating=None, confidence=None, size=None, dns_active=None, whois_active=None,
                            false_positive=False, observations=0, security_label=None, threat_assess_confidence=-1,
                            threat_assess_rating=-1):
        tc = get_client()
        indicators = tc.indicators()
        filter1 = indicators.add_filter()
        filter1.add_indicator(indicator)

        raw_indicators = []
        for ind in indicators.retrieve():
            if rating is not None:
                ind.set_rating(rating)
            if confidence is not None:
                ind.set_confidence(int(confidence))
            if false_positive:
                ind.add_false_positive()
            if observations != 0:
                ind.add_observation(observations)
            if security_label is not None:
                ind.add_security_label(security_label)
            if threat_assess_confidence != -1:
                ind.set_threat_assess_confidence(threat_assess_confidence)
            if threat_assess_rating != -1:
                ind.set_threat_assess_rating(threat_assess_rating)

            if ind.type == 'File' and size is not None:
                ind.add_size(size)
            if ind.type == 'Host' and dns_active is not None:
                ind.set_dns_active(dns_active)
            if ind.type == 'Host' and whois_active is not None:
                ind.set_whois_active(whois_active)

            raw_indicators.append(ind.commit().json)

        return raw_indicators


    def tc_delete_indicator_command():
        args = demisto.args()
        indicator = args['indicator']

        tc_delete_indicator(indicator)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': 'Indicator {} removed Successfully'.format(indicator)
        })


    #@logger
    def tc_delete_indicator(indicator):
        tc = get_client()
        indicators = tc.indicators()
        filter1 = indicators.add_filter()
        filter1.add_indicator(indicator)
        indicators = indicators.retrieve()
        for ind in indicators:
            ind.delete()


    def tc_delete_indicator_tag_command():
        args = demisto.args()
        indicator = args['indicator']
        tag = args['tag']

        indicators = tc_delete_indicator_tag(indicator, tag)
        raw_indicators = [ind.json for ind in indicators]
        ec, _ = create_context(raw_indicators)

        md = []
        for ind in indicators:
            md.append('Removed tag {} from indicator {}.'.format(tag, ind.indicator))
        if len(md) == 0:
            md.append('No indicators found')

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': raw_indicators,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '\n'.join(md),
            'EntryContext': ec
        })


    #@logger
    def tc_delete_indicator_tag(indicator, tag, owners=None):
        tc = get_client()
        indicators = tc.indicators()
        filter1 = indicators.add_filter()
        filter1.add_indicator(indicator)

        if owners is not None:
            owners = owners.split(",")
            filter1.add_owner(owners)

        indicators = indicators.retrieve()
        for indicator in indicators:
            indicator.delete_tag(tag)
            indicator.commit()

        return indicators


    def tc_create_campaign_command():
        args = demisto.args()
        name = args['name']
        owner = args.get('owner', demisto.params()['defaultOrg'])
        if owner == '':
            return_error('You must specify an owner in the command, or by using the Organization parameter.')

        first_seen = args.get('firstSeen', datetime.utcnow().isoformat().split('.')[0] + 'Z')
        tag = args.get('tag')
        security_label = args.get('securityLabel')
        description = args.get('description')

        raw_campaign = tc_create_campaign(name, owner, first_seen, tag, security_label, description)
        ec = {
            'ID': raw_campaign['id'],
            'Name': raw_campaign['name'],
            'Owner': raw_campaign['owner']['name'],
            'FirstSeen': raw_campaign['firstSeen'],
            'Tag': tag,
            'SecurityLabel': security_label
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_campaign,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Campaign {} Created Successfully'.format(name),
            'EntryContext': {
                'TC.Campaign(val.ID && val.ID === obj.ID)': createContext([ec], removeNull=True)
            }
        })


    #@logger
    def tc_create_campaign(name, owner, first_seen, tag=None, security_label=None, description=None):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/groups/campaigns')
        body = {
            'name': name,
            'firstSeen': first_seen,
        }
        ro.set_body(json.dumps(body))
        response = tc.api_request(ro).json()

        if response.get('status') == 'Success':
            output = response.get('data', {}).get('campaign', {})
            event_id = output['id']
            if description is not None:
                # Associate Attribute description
                ro = RequestObject()
                ro.set_http_method('POST')
                ro.set_request_uri('/v2/groups/events/{}/attributes'.format(event_id))
                body = {
                    'type': 'Description',
                    'value': description,
                    'displayed': 'true'
                }
                ro.set_body(json.dumps(body))
                tc.api_request(ro).json()

            return output
        else:
            return_error('Failed to create event')


    def tc_create_event_command():
        args = demisto.args()
        name = args['name']
        event_date = args.get('EventDate', datetime.utcnow().isoformat().split('.')[0] + 'Z')
        status = args.get('status')
        owner = args.get('owner', demisto.params()['defaultOrg'])
        if owner == '':
            return_error('You must specify an owner in the command, or by using the Organization parameter.')

        description = args.get('description')
        tag = args.get('tag')

        raw_event = tc_create_event(name, owner, event_date, tag, status, description)
        ec = {
            'ID': raw_event['id'],
            'Name': raw_event['name'],
            'Owner': raw_event['owner']['name'],
            'Date': raw_event['eventDate'],
            'Tag': tag,
            'Status': status
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_event,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Incident {} Created Successfully'.format(name),
            'EntryContext': {
                'TC.Event(val.ID && val.ID === obj.ID)': createContext([ec], removeNull=True)
            }
        })


    def tc_create_event(name, owner, event_date, tag=None, status=None, description=None):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/groups/events')
        body = {
            'name': name,
            'eventDate': event_date,
            'status': status
        }
        ro.set_body(json.dumps(body))
        response = tc.api_request(ro).json()

        if response.get('status') == 'Success':
            output = response.get('data', {}).get('event', {})
            event_id = output['id']
            if description is not None:
                # Associate Attribute description
                ro = RequestObject()
                ro.set_http_method('POST')
                ro.set_request_uri('/v2/groups/events/{}/attributes'.format(event_id))
                body = {
                    'type': 'Description',
                    'value': description,
                    'displayed': 'true'
                }
                ro.set_body(json.dumps(body))
                tc.api_request(ro).json()

            return output
        else:
            return_error('Failed to create event')


    def tc_create_threat_command():
        args = demisto.args()
        name = args['name']
        date = args.get('dateAdded', datetime.utcnow().isoformat().split('.')[0] + 'Z')
        owner = args.get('owner', demisto.params()['defaultOrg'])
        if owner == '':
            return_error('You must specify an owner in the command, or by using the Organization parameter.')

        raw_threat = tc_create_threat(name, owner, date)
        ec = {
            'ID': raw_threat['id'],
            'Name': raw_threat['name']
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw_threat,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Threat {} Created Successfully'.format(name),
            'EntryContext': {
                'TC.Threat(val.ID && val.ID === obj.ID)': createContext([ec], removeNull=True)
            }
        })


    def tc_create_threat(name, owner, date):
        tc = get_client()
        threats = tc.threats()
        threat = threats.add(name, owner)
        threat.set_date_added(date)

        return threat.commit().json


    def tc_delete_group_command():
        args = demisto.args()
        group_id = int(args['groupID'])
        group_type = args['type']

        success = tc_delete_group(group_id, group_type.lower())
        if success:
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['text'],
                'Contents': '{} {} deleted Successfully'.format(group_type.lower(), group_id)
            })
        else:
            return_error('Failed to delete {} {}'.format(group_type, group_id))


    def tc_delete_group(group_id, group_type):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('DELETE')
        ro.set_request_uri('/v2/groups/{}/{}'.format(group_type, group_id))
        response = tc.api_request(ro).json()

        return response['status'] == 'Success'


    def tc_add_group_attribute_request(group_type, group_id, attribute_type, attribute_value):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/groups/{}/{}/attributes'.format(group_type, group_id))
        body = {
            'type': attribute_type,
            'value': attribute_value,
            'displayed': 'true'
        }
        ro.set_body(json.dumps(body))
        response = tc.api_request(ro).json()

        return response


    def tc_add_group_attribute():
        group_id = int(demisto.args().get('group_id'))
        group_type = demisto.args().get('group_type')
        attribute_type = demisto.args().get('attribute_type')
        attribute_value = demisto.args().get('attribute_value')
        headers = ['Type', 'Value', 'ID', 'DateAdded', 'LastModified']
        attribute = tc_add_group_attribute_request(group_type, group_id, attribute_type, attribute_value)
        data = attribute.get('data').get('attribute')
        contents = {
            'Type': data.get('type'),
            'Value': data.get('value'),
            'ID': data.get('id'),
            'DateAdded': data.get('dateAdded'),
            'LastModified': data.get('lastModified')
        }
        context = {
            'TC.Group(val.ID && val.ID === obj.ID)': contents
        }

        return_outputs(
            tableToMarkdown('The attribute was added successfully to group {}'.format(group_id), contents, headers,
                            removeNull=True),
            context,
            attribute
        )


    def add_group_security_label_request(group_type, group_id, security_label):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/groups/{}/{}/securityLabels/{}'.format(group_type, group_id, security_label))

        response = tc.api_request(ro).json()

        return response.get('status') == 'Success'


    def add_group_security_label():
        group_id = int(demisto.args().get('group_id'))
        group_type = demisto.args().get('group_type')
        security_label = demisto.args().get('security_label_name')

        add_group_security_label_request(group_type, group_id, security_label)

        demisto.results('The security label {} was added successfully to {} {}'.format(security_label, group_type,
                                                                                       group_id))


    def add_group_tags_request(group_type, group_id, tag_name):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/groups/{}/{}/tags/{}'.format(group_type, group_id, tag_name))

        response = tc.api_request(ro).json()

        return response.get('status') == 'Success'


    def add_group_tag():
        group_id = int(demisto.args().get('group_id'))
        group_type = demisto.args().get('group_type')
        tag_name = demisto.args().get('tag_name')

        add_group_tags_request(group_type, group_id, tag_name)

        demisto.results('The tag {} was added successfully to group {} {}'.format(tag_name, group_type, group_id))


    def get_events_request():
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/events')

        return tc.api_request(ro).json()


    def tc_get_events():
        raw_response = get_events_request()
        data = raw_response.get('data', {}).get('event', [])
        content = []
        headers = ['ID', 'Name', 'OwnerName', 'EventDate', 'DateAdded', 'Status']

        for event in data:
            content.append({
                'ID': event.get('id'),
                'Name': event.get('name'),
                'OwnerName': event.get('ownerName'),
                'DateAdded': event.get('dateAdded'),
                'EventDate': event.get('eventDate'),
                'Status': event.get('status')
            })
        context = {
            'TC.Event(val.ID && val.ID === obj.ID)': content
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Events', content, headers, removeNull=True),
            context,
            raw_response
        )


    def tc_get_indicator_types_request():
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/types/indicatorTypes')

        return tc.api_request(ro).json()


    def tc_get_indicator_types():
        raw_response = tc_get_indicator_types_request()
        data = raw_response.get('data', {}).get('indicatorType', [])
        content = []
        headers = ['Name', 'Custom', 'Parsable', 'ApiBranch', 'CasePreference', 'value1Label', 'Value1Type']

        for type_ in data:
            content.append({
                'Custom': type_.get('custom'),
                'Name': type_.get('name'),
                'Parsable': type_.get('parsable'),
                'ApiBranch': type_.get('apiBranch'),
                'ApiEntity': type_.get('apiEntity'),
                'CasePreference': type_.get('casePreference'),
                'Value1Label': type_.get('value1Label'),
                'Value1Type': type_.get('value1Type')
            })
        context = {
            'TC.IndicatorType(val.Name && val.Name === obj.Name)': content
        }

        return_outputs(
            tableToMarkdown('ThreatConnect indicator types', content, headers, removeNull=True),
            context,
            raw_response
        )


    def associate_indicator_request(indicator_type, indicator, group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/indicators/{}/{}/groups/{}/{}'.format(indicator_type, indicator, group_type, group_id))
        response = tc.api_request(ro).json()

        return response


    def associate_indicator():
        group_id = int(demisto.args().get('group_id'))
        group_type = demisto.args().get('group_type')
        indicator_type = demisto.args().get('indicator_type')
        indicator = demisto.args().get('indicator')

        response = associate_indicator_request(indicator_type, indicator, group_type, group_id)

        if response.get('status') == 'Success':
            contents = {
                'IndicatorType': indicator_type,
                'Indicator': indicator,
                'GroupType': group_type,
                'GroupID': group_id
            }
        else:
            return_error(response.get('message'))

        context = {
            'TC.Group(val.Indicator && val.Indicator === obj.Indicator)': contents
        }

        return_outputs(
            tableToMarkdown('The indicator was associated successfully', contents, removeNull=True),
            context
        )


    def get_groups_request(group_type):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}'.format(group_type))

        return tc.api_request(ro).json()


    def tc_get_groups():
        group_type = demisto.args().get('group_type')
        raw_response = get_groups_request(group_type)
        headers = ['ID', 'Name', 'OwnerName', 'EventDate', 'DateAdded', 'Status']
        if group_type == 'adversaries':
            data = raw_response.get('data', {}).get('adversarie', {})
        if group_type == 'campaigns':
            data = raw_response.get('data', {}).get('campaign', {})
        if group_type == 'documents':
            data = raw_response.get('data', {}).get('document', {})
        if group_type == 'emails':
            data = raw_response.get('data', {}).get('email', {})
        if group_type == 'events':
            data = raw_response.get('data', {}).get('event', {})
        if group_type == 'incidents':
            data = raw_response.get('data', {}).get('incident', {})
        if group_type == 'intrusionSets':
            data = raw_response.get('data', {}).get('intrusionSet', {})
        if group_type == 'reports':
            data = raw_response.get('data', {}).get('report', {})
        if group_type == 'signatures':
            data = raw_response.get('data', {}).get('signature', {})
        if group_type == 'threats':
            data = raw_response.get('data', {}).get('threat', {})

        content = []

        for group in data:
            content.append({
                'ID': group.get('id'),
                'Name': group.get('name'),
                'OwnerName': group.get('ownerName'),
                'DateAdded': group.get('dateAdded'),
                'EventDate': group.get('eventDate'),
                'Status': group.get('status')
            })
        context = {
            'TC.Group(val.ID && val.ID === obj.ID)': content
        }

        return_outputs(
            tableToMarkdown('ThreatConnect {}'.format(group_type), content, headers, removeNull=True),
            context,
            raw_response
        )


    def get_group_request(group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}/{}'.format(group_type, group_id))

        return tc.api_request(ro).json()


    def get_group():
        """
        Retrieve a single Group
        """
        group_type = demisto.args().get('group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)

        response = get_group_request(group_type, group_id).get('data', {})
        if group_type == 'adversaries':
            data = response.get('adversarie', {})
        if group_type == 'campaigns':
            data = response.get('campaign', {})
        if group_type == 'documents':
            data = response.get('document', {})
        if group_type == 'emails':
            data = response.get('email', {})
        if group_type == 'events':
            data = response.get('event', {})
        if group_type == 'incidents':
            data = response.get('incident', {})
        if group_type == 'intrusionSets':
            data = response.get('intrusionSet', {})
        if group_type == 'reports':
            data = response.get('report', {})
        if group_type == 'signatures':
            data = response.get('signature', {})
        if group_type == 'threats':
            data = response.get('threat', {})

        owner = {
            'Name': data.get('owner').get('name'),
            'ID': data.get('owner').get('id'),
            'Type': data.get('owner').get('type')
        }
        contents = {
            'ID': data.get('id'),
            'Name': data.get('name'),
            'Owner': owner,
            'DateAdded': data.get('dateAdded'),
            'EventDate': data.get('eventDate'),
            'Status': data.get('status')
        }

        context = {
            'TC.Group(val.ID && val.ID === obj.ID)': contents
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Group information', contents, removeNull=True),
            context,
            response
        )


    def get_group_attributes_request(group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}/{}/attributes'.format(group_type, group_id))

        return tc.api_request(ro).json()


    def get_group_attributes():
        """
        Retrieve a Group's Attributes
        """
        group_type = demisto.args().get('group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)
        contents = []
        headers = ['AttributeID', 'Type', 'Value', 'DateAdded', 'LastModified', 'Displayed']
        response = get_group_attributes_request(group_type, group_id)
        data = response.get('data', {}).get('attribute', [])

        if response.get('status') == 'Success':
            for attribute in data:
                contents.append({
                    'GroupID': group_id,
                    'AttributeID': attribute.get('id'),
                    'Type': attribute.get('type'),
                    'Value': attribute.get('value'),
                    'DateAdded': attribute.get('dateAdded'),
                    'LastModified': attribute.get('lastModified'),
                    'Displayed': attribute.get('displayed')
                })

        else:
            return_error(response.get('message'))

        context = {
            'TC.Group.Attribute(val.GroupID && val.GroupID === obj.GroupID && val.AttributeID && val.AttributeID ==='
            ' obj.AttributeID)': contents
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Group Attributes', contents, headers, removeNull=True),
            context,
            response
        )


    def get_group_security_labels_request(group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}/{}/securityLabels'.format(group_type, group_id))

        return tc.api_request(ro).json()


    def get_group_security_labels():
        """
        Retrieve a Group's Security Labels
        """
        group_type = demisto.args().get('group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)
        contents = []
        headers = ['Name', 'Description', 'DateAdded']
        response = get_group_security_labels_request(group_type, group_id)
        data = response.get('data', {}).get('securityLabel', [])

        if response.get('status') == 'Success':
            for security_label in data:
                contents.append({
                    'GroupID': group_id,
                    'Name': security_label.get('name'),
                    'Description': security_label.get('description'),
                    'DateAdded': security_label.get('dateAdded')
                })

        else:
            return_error(response.get('message'))

        context = {
            'TC.Group.SecurityLabel(val.GroupID && val.GroupID === obj.GroupID && val.Name && val.Name === '
            'obj.Name)': contents
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Group Security Labels', contents, headers, removeNull=True),
            context
        )


    def get_group_tags_request(group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}/{}/tags'.format(group_type, group_id))

        return tc.api_request(ro).json()


    def get_group_tags():
        """
        Retrieve the Tags for a Group
        """
        group_type = demisto.args().get('group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)
        contents = []
        context_entries = []
        response = get_group_tags_request(group_type, group_id)
        data = response.get('data', {}).get('tag', [])

        if response.get('status') == 'Success':
            for tags in data:
                contents.append({
                    'Name': tags.get('name')
                })

                context_entries.append({
                    'GroupID': group_id,
                    'Name': tags.get('name')
                })
        else:
            return_error(response.get('message'))

        context = {
            'TC.Group.Tag(val.GroupID && val.GroupID === obj.GroupID && val.Name && val.Name === obj.Name)': context_entries
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Group Tags', contents, removeNull=True),
            context,
            response
        )


    def get_group_indicator_request(group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}/{}/indicators'.format(group_type, group_id))

        return tc.api_request(ro).json()


    def get_group_indicator():
        """
        View Indicators associated with a given Group
        """
        group_type = demisto.args().get('group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)
        contents = []
        response = get_group_indicator_request(group_type, group_id)
        data = response.get('data', {}).get('indicator', [])

        if response.get('status') == 'Success':
            for indicator in data:
                contents.append({
                    'GroupID': group_id,
                    'IndicatorID': indicator.get('id'),
                    'OwnerName': indicator.get('ownerName'),
                    'Type': indicator.get('type'),
                    'DateAdded': indicator.get('dateAdded'),
                    'LastModified': indicator.get('lastModified'),
                    'Rating': indicator.get('rating'),
                    'Confidence': indicator.get('confidence'),
                    'ThreatAssertRating': indicator.get('threatAssessRating'),
                    'ThreatAssessConfidence': indicator.get('threatAssessConfidence'),
                    'Summary': indicator.get('summary')
                })

        else:
            return_error(response.get('message'))

        context = {
            'TC.Group.Indicator(val.GroupID && val.GroupID === obj.GroupID && val.IndicatorID && val.IndicatorID === '
            'obj.IndicatorID)': contents
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Group Indicators', contents, removeNull=True),
            context,
            response
        )


    def get_group_associated_request(group_type, group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('GET')
        ro.set_request_uri('/v2/groups/{}/{}/groups'.format(group_type, group_id))

        return tc.api_request(ro).json()


    def get_group_associated():
        """
        View Indicators associated with a given Group
        """
        group_type = demisto.args().get('group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)
        contents = []
        headers = ['GroupID', 'Name', 'Type', 'OwnerName', 'DateAdded']
        response = get_group_associated_request(group_type, group_id)
        data = response.get('data', {}).get('group', [])

        if response.get('status') == 'Success':
            for group in data:
                contents.append({
                    'GroupID': group.get('id'),
                    'Name': group.get('name'),
                    'Type': group.get('type'),
                    'DateAdded': group.get('dateAdded'),
                    'OwnerName': group.get('ownerName')
                })

        else:
            return_error(response.get('message'))

        context = {
            'TC.Group.AssociatedGroup(val.GroupID && val.GroupID === obj.GroupID)': contents
        }

        return_outputs(
            tableToMarkdown('ThreatConnect Associated Groups', contents, headers, removeNull=True),
            context,
            response
        )


    def associate_group_to_group_request(group_type, group_id, associated_group_type, associated_group_id):
        tc = get_client()
        ro = RequestObject()
        ro.set_http_method('POST')
        ro.set_request_uri('/v2/groups/{}/{}/groups/{}/{}'.format(group_type, group_id, associated_group_type,
                                                                  associated_group_id))

        return tc.api_request(ro).json()


    def associate_group_to_group():
        """
        Associate one Group with another
        """

        group_type = demisto.args().get('group_type')
        associated_group_type = demisto.args().get('associated_group_type')
        try:
            group_id = int(demisto.args().get('group_id'))
        except TypeError as t:
            return_error('group_id must be a number', t)
        try:
            associated_group_id = int(demisto.args().get('associated_group_id'))
        except TypeError as t:
            return_error('associated_group_id must be a number', t)

        response = associate_group_to_group_request(group_type, group_id, associated_group_type, associated_group_id)

        if response.get('status') == 'Success':
            context_entries = {
                'GroupID': group_id,
                'GroupType': group_type,
                'AssociatedGroupID': associated_group_id,
                'AssociatedGroupType': associated_group_type
            }
            context = {
                'TC.Group.AssociatedGroup(val.GroupID && val.GroupID === obj.GroupID)': context_entries
            }
            return_outputs('The group {} was associated successfully.'.format(associated_group_id),
                           context,
                           response)
        else:
            return_error(response.get('message'))


    def create_document_group_request(contents, file_name, name, owner, res, malware, password, security_label,
                                      description):
        tc = get_client()
        documents = tc.documents()

        document = documents.add(name, owner)
        document.set_file_name(file_name)

        # upload the contents of the file into the Document
        document.upload(contents)
        if malware:
            document.set_malware(True)
            document.set_password(password)
        if security_label:
            document.set_security_label(security_label)
        if description:
            document.add_attribute('Description', description)

        return document.commit().json


    def create_document_group():
        file_name = demisto.args().get('file_name')
        name = demisto.args().get('name')
        malware = bool(strtobool(demisto.args().get('malware', False)))
        password = demisto.args().get('password')
        res = demisto.getFilePath(demisto.args()['entry_id'])
        owner = demisto.args().get('owner', demisto.params().get('defaultOrg'))
        if not owner:
            return_error('You must specify an owner in the command, or by using the Organization parameter.')

        security_label = demisto.args().get('securityLabel')
        description = demisto.args().get('description')

        # open a file handle for a local file and read the contents thereof
        f = open(res['path'], 'rb')
        contents = f.read()

        raw_document = create_document_group_request(contents, file_name, name, owner, res, malware, password,
                                                     security_label, description)
        content = {
            'ID': raw_document.get('id'),
            'Name': raw_document.get('name'),
            'Owner': raw_document.get('ownerName'),
            'EventDate': raw_document.get('eventDate'),
            'Description': description,
            'SecurityLabel': security_label
        }
        context = {
            'TC.Group(val.ID && val.ID === obj.ID)': content
        }
        return_outputs(tableToMarkdown('ThreatConnect document group was created successfully', content, removeNull=True),
                       context,
                       raw_document)


    def get_document_request(document_id):

        tc = get_client()
        documents = tc.documents()
        # set a filter to retrieve only the Document with ID: 123456
        filter1 = documents.add_filter()
        filter1.add_id(document_id)
        try:
            # retrieve the Document
            documents.retrieve()
        except RuntimeError as e:
            return_error('Error: {0}'.format(str(e)))

        # iterate through the retrieved Documents (in this case there should only be one) and print its properties
        for document in documents:
            document.download()
            if document.contents is not None:
                return document
            else:
                return_error('No document was found.')


    def download_document():
        """
        Download the contents of a Document
        """
        try:
            document_id = int(demisto.args().get('document_id'))
        except TypeError as t:
            return_error('document_id must be a number', t)
        document = get_document_request(document_id)

        file_name = document.file_name
        file_content = document.contents
        demisto.results(fileResult(file_name, file_content))


    def test_integration():
        tc = get_client()
        owners = tc.owners()
        owners.retrieve()
        demisto.results('ok')


    ''' EXECUTION CODE '''
    COMMANDS = {
        'test-module': test_integration,
        'ip': ip_command,
        'url': url_command,
        'file': file_command,
        'domain': domain_command,

        'tc-owners': tc_owners_command,
        'tc-indicators': tc_indicators_command,
        'tc-get-tags': tc_get_tags_command,
        'tc-tag-indicator': tc_tag_indicator_command,
        'tc-get-indicator': tc_get_indicator_command,
        'tc-get-indicators-by-tag': tc_get_indicators_by_tag_command,
        'tc-add-indicator': tc_add_indicator_command,

        'tc-create-incident': tc_create_incident_command,
        'tc-fetch-incidents': tc_fetch_incidents_command,
        'tc-get-incident-associate-indicators': tc_get_incident_associate_indicators_command,
        'tc-incident-associate-indicator': tc_incident_associate_indicator_command,
        'tc-update-indicator': tc_update_indicator_command,
        'tc-delete-indicator': tc_delete_indicator_command,
        'tc-delete-indicator-tag': tc_delete_indicator_tag_command,
        'tc-create-campaign': tc_create_campaign_command,
        'tc-create-event': tc_create_event_command,
        'tc-get-events': tc_get_events,
        'tc-add-group-attribute': tc_add_group_attribute,
        'tc-create-threat': tc_create_threat_command,
        'tc-delete-group': tc_delete_group_command,
        'tc-get-groups': tc_get_groups,
        'tc-add-group-security-label': add_group_security_label,
        'tc-add-group-tag': add_group_tag,
        'tc-get-indicator-types': tc_get_indicator_types,
        'tc-group-associate-indicator': associate_indicator,
        'tc-create-document-group': create_document_group,
        'tc-get-group': get_group,
        'tc-get-group-attributes': get_group_attributes,
        'tc-get-group-security-labels': get_group_security_labels,
        'tc-get-group-tags': get_group_tags,
        'tc-download-document': download_document,
        'tc-get-group-indicators': get_group_indicator,
        'tc-get-associated-groups': get_group_associated,
        'tc-associate-group-to-group': associate_group_to_group
    }

    try:
        command_func = demisto.command()
        LOG('command is %s' % (demisto.command(),))
        if command_func in COMMANDS.keys():
            COMMANDS[command_func]()

    except Exception as e:
        LOG(str(e))
        LOG.print_log()
        var = traceback.format_exc()
        return_error('error has occurred: {}'.format(str(var), ))
  type: python
  commands:
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: The IPv4 or IPv6 address.
    - name: owners
      description: A CSV list of a client's organizations, sources, or communities
        to which a user has permissions. For example, users with admin permissions
        can search for indicators belonging to all owners.
    - name: ratingThreshold
      description: A list of results filtered by indicators whose threat rating is
        greater than the specified value. Can be "0" - "Unknown", "1" - "Suspicious",
        "2" - "Low", "3" - Moderate, "4" - High, or "5" - "Critical".
    - name: confidenceThreshold
      description: A list of results filtered by indicators whose confidence rating
        is greater than the specified value. Can be "0%" - "Unknown," "1% " - "Discredited",
        "2-29%" - "Improbable," "30-49%" - "Doubtful," "50-69%" - "Possible", "70-89%"
        - "Probable," or "90-100%" - "Confirmed".
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The date on which the indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    description: Searches for an indicator of type IP address.
  - name: url
    arguments:
    - name: url
      required: true
      default: true
      description: The URL for which to search. For example, "www.demisto.com".
    - name: owners
      description: A CSV list of a client's organizations, sources, or communities
        to which a clients API user has been granted permission. For example, "owner1",
        "owner2", or "owner3".
    - name: ratingThreshold
      description: A list of results filtered by indicators whose threat rating is
        greater than the specified value. Can be "0" - "Unknown", "1" - "Suspicious",
        "2" - "Low", "3" - Moderate, "4" - High, or "5" - "Critical".
    - name: confidenceThreshold
      description: A list of results filtered by indicators whose confidence rating
        is greater than the specified value. Can be "0%" - "Unknown," "1% " - "Discredited",
        "2-29%" - "Improbable," "30-49%" - "Doubtful," "50-69%" - "Possible", "70-89%"
        - "Probable," or "90-100%" - "Confirmed".
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The date on which the indicator was last modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: URL.Data
      description: The data of the URL indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    description: Searches for an indicator of type URL.
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: The hash of the file. Can be "MD5", "SHA-1", or "SHA-256".
    - name: owners
      description: A CSV list of a client's organizations, sources, or communities
        to which a user has permissions. For example, users with admin permissions
        can search for indicators belonging to all owners.
    - name: ratingThreshold
      description: A list of results filtered by indicators whose threat rating is
        greater than the specified value. Can be "0" - "Unknown", "1" - "Suspicious",
        "2" - "Low", "3" - Moderate, "4" - High, or "5" - "Critical".
    - name: confidenceThreshold
      description: A list of results filtered by indicators whose confidence rating
        is greater than the specified value. Can be "0%" - "Unknown," "1% " - "Discredited",
        "2-29%" - "Improbable," "30-49%" - "Doubtful," "50-69%" - "Possible", "70-89%"
        - "Probable," or "90-100%" - "Confirmed".
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator.
      type: string
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the indicator.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the indicator.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the indicator.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Searches for an indicator of type file.
  - name: tc-owners
    arguments: []
    outputs:
    - contextPath: TC.Owner.Name
      description: The name of the owner.
      type: string
    - contextPath: TC.Owner.ID
      description: The ID of the owner.
      type: string
    - contextPath: TC.Owner.Type
      description: The type of the owner.
      type: string
    description: Retrieves all owners for the current account.
  - name: tc-indicators
    arguments:
    - name: owner
      description: A list of results filtered by the owner of the indicator.
    - name: limit
      description: The maximum number of results that can be returned. The default
        is 500.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The name of the domain.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Retrieves a list of all indicators.
  - name: tc-get-tags
    arguments: []
    outputs:
    - contextPath: TC.Tags
      description: A list of tags.
      type: Unknown
    description: Returns a list of all ThreatConnect tags.
  - name: tc-tag-indicator
    arguments:
    - name: tag
      required: true
      description: The name of the tag.
    - name: indicator
      required: true
      description: The indicator to tag. For example, for an IP indicator, "8.8.8.8".
    - name: owner
      description: A list of indicators filtered by the owner.
    description: Adds a tag to an existing indicator.
  - name: tc-get-indicator
    arguments:
    - name: indicator
      required: true
      default: true
      description: The name of the indicator by which to search. The command retrieves
        information from all owners. Can be an IP address, a URL, or a file hash.
    - name: indicator_type
      description: Only for custom. Leave empty for standard ones
    - name: owners
      description: Indicator Owner(s)
    - name: ratingThreshold
      description: A list of results filtered by indicators whose threat rating is
        greater than the specified value. Can be "0" - "Unknown", "1" - "Suspicious",
        "2" - "Low", "3" - Moderate, "4" - High, or "5" - "Critical".
    - name: confidenceThreshold
      description: A list of results filtered by indicators whose confidence rating
        is greater than the specified value. Can be "0%" - "Unknown," "1% " - "Discredited",
        "2-29%" - "Improbable," "30-49%" - "Doubtful," "50-69%" - "Possible", "70-89%"
        - "Probable," or "90-100%" - "Confirmed".
    - name: group_associations
      required: true
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Retrieve Indicator Group Associations
      defaultValue: "false"
    - name: indicator_associations
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Retrieve Indicator Associations
      defaultValue: "false"
    - name: indicator_observations
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Retrieve Indicator Observations
      defaultValue: "false"
    - name: indicator_tags
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Retrieve Indicator Tags
      defaultValue: "false"
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the indicator of the URL.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The domain name of the indicator.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Retrieves information about an indicator.
  - name: tc-get-indicators-by-tag
    arguments:
    - name: tag
      required: true
      default: true
      description: The name of the tag by which to filter.
    - name: owner
      description: A list of indicators filtered by the owner.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the tagged indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the tagged indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the tagged indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the tagged indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the tagged indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the tagged indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the tagged indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the tagged indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the tagged indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the tagged indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the tagged indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the tagged indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: IP.Address
      description: The IP address of the tagged indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the tagged indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The domain name of the tagged indicator.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Fetches all indicators that have a tag.
  - name: tc-add-indicator
    arguments:
    - name: indicator
      required: true
      description: The indicator to add.
    - name: rating
      description: The threat rating of the indicator. Can be "0" - "Unknown", "1"
        - "Suspicious", "2" - "Low", "3" - Moderate, "4" - High, or "5" - "Critical".
    - name: confidence
      description: The confidence rating of the indicator. Can be "0%" - "Unknown,"
        "1% " - "Discredited", "2-29%" - "Improbable," "30-49%" - "Doubtful," "50-69%"
        - "Possible", "70-89%" - "Probable," or "90-100%" - "Confirmed".
    - name: owner
      description: The owner of the new indicator. The default is the "defaultOrg"
        parameter.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the added indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the added indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The name of the added indicator of the domain.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Adds a new indicator to ThreatConnect.
  - name: tc-create-incident
    arguments:
    - name: owner
      description: The owner of the new incident. The default is the "defaultOrg"
        parameter.
    - name: incidentName
      required: true
      default: true
      description: The name of the incident group.
    - name: eventDate
      description: The creation time of an incident in the "2017-03-21T00:00:00Z"
        format.
    - name: tag
      description: The tag applied to the incident.
    - name: securityLabel
      auto: PREDEFINED
      predefined:
      - TLP:RED
      - TLP:GREEN
      - TLP:AMBER
      - TLP:WHITE
      description: The security label applied to the incident. Can be "TLP:RED", "TLP:GREEN",
        "TLP:AMBER", or "TLP:WHITE".
    - name: description
      description: The description of the incident.
    outputs:
    - contextPath: TC.Incident.Name
      description: The name of the new incident group.
      type: string
    - contextPath: TC.Incident.Owner
      description: The owner of the new incident.
      type: string
    - contextPath: TC.Incident.EventDate
      description: The date on which the event that indicates an incident occurred.
      type: date
    - contextPath: TC.Incident.Tag
      description: The name of the tag of the new incident.
      type: string
    - contextPath: TC.Incident.SecurityLabel
      description: The security label of the new incident.
      type: string
    - contextPath: TC.Incident.ID
      description: The ID of the new incident.
      type: Unknown
    description: Creates a new incident group.
  - name: tc-fetch-incidents
    arguments:
    - name: incidentId
      default: true
      description: The fetched incidents filtered by ID.
    - name: owner
      description: The fetched incidents filtered by owner.
    - name: incidentName
      description: The fetched incidents filtered by incident name.
    outputs:
    - contextPath: TC.Incident
      description: The name of the group of fetched incidents.
      type: string
    - contextPath: TC.Incident.ID
      description: The ID of the fetched incidents.
      type: string
    - contextPath: TC.Incident.Owner
      description: The owner of the fetched incidents.
      type: string
    description: Fetches incidents from ThreatConnect.
  - name: tc-incident-associate-indicator
    arguments:
    - name: indicatorType
      required: true
      auto: PREDEFINED
      predefined:
      - ADDRESSES
      - EMAIL_ADDRESSES
      - URLS
      - HOSTS
      - FILES
      - CUSTOM_INDICATORS
      description: The type of the indicator. Can be "ADDRESSES", "EMAIL_ADDRESSES",
        "URLS", "HOSTS", "FILES", or "CUSTOM_INDICATORS".
    - name: incidentId
      required: true
      description: The ID of the incident to which the indicator is associated.
    - name: indicator
      required: true
      default: true
      description: The name of the indicator.
    - name: owner
      description: A list of indicators filtered by the owner.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator associated was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator associated was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: IP.Address
      description: IP address of the associated indicator of the file.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the associated indicator of the file.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The name of the indicator of the domain.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Associates an indicator with an existing incident. The indicator
      must exist before running this command. To add an indicator, run the tc-add-indicator
      command.
  - name: domain
    arguments:
    - name: domain
      required: true
      default: true
      description: The name of the domain.
    - name: owners
      description: A CSV list of a client's organizations, sources, or communities
        to which a user has permissions. For example, users with admin permissions
        can search for indicators belonging to all owners.
    - name: ratingThreshold
      description: A list of results filtered by indicators whose threat rating is
        greater than the specified value. Can be "0" - "Unknown", "1" - "Suspicious",
        "2" - "Low", "3" - Moderate, "4" - High, or "5" - "Critical".
    - name: confidenceThreshold
      description: A list of results filtered by indicators whose confidence rating
        is greater than the specified value. Can be "0%" - "Unknown," "1% " - "Discredited",
        "2-29%" - "Improbable," "30-49%" - "Doubtful," "50-69%" - "Possible", "70-89%"
        - "Probable," or "90-100%" - "Confirmed".
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the domain.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the domain.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the domain.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the domain.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator of the domain was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator of the domain was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the domain.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the domain.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: Domain.Name
      description: The name of the domain.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    description: Searches for an indicator of type domain.
  - name: tc-get-incident-associate-indicators
    arguments:
    - name: incidentId
      required: true
      default: true
      description: The ID of the incident.
    - name: owner
      description: A list of indicators filtered by the owner.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the returned indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the returned indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the returned indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the returned indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the returned indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the returned indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the returned indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the returned indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the returned indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: DBotScore.Indicator
      description: The value assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Type
      description: The type assigned by DBot for the indicator.
      type: string
    - contextPath: DBotScore.Score
      description: The score assigned by DBot for the indicator.
      type: number
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: IP.Address
      description: The IP address of the returned indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the returned indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The name of the domain.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Returns indicators that are related to a specific incident.
  - name: tc-update-indicator
    arguments:
    - name: indicator
      required: true
      description: The name of the updated indicator.
    - name: rating
      description: The threat rating of the updated indicator.
    - name: confidence
      description: The confidence rating of the updated indicator.
    - name: size
      description: The size of the file of the updated indicator.
    - name: dnsActive
      description: The active DNS indicator (only for hosts).
    - name: whoisActive
      description: The active indicator (only for hosts).
    - name: updatedValues
      description: A CSV list of field:value pairs to update. For example, "rating=3",
        "confidence=42", and "description=helloWorld".
    - name: falsePositive
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: The updated indicator set as a false positive. Can be "True" or
        "False".
    - name: observations
      description: The number observations on the updated indicator.
    - name: securityLabel
      auto: PREDEFINED
      predefined:
      - TLP:RED
      - TLP:GREEN
      - TLP:AMBER
      - TLP:WHITE
      description: The security label applied to the incident. Can be "TLP:RED", "TLP:GREEN",
        "TLP:AMBER", or "TLP:WHITE".
    - name: threatAssessConfidence
      description: Assesses the confidence rating of the indicator.
    - name: threatAssessRating
      description: Assesses the threat rating of the indicator.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The domain name of the indicator.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Updates the indicator in ThreatConnect.
  - name: tc-delete-indicator-tag
    arguments:
    - name: indicator
      required: true
      description: The name of the indicator from which to remove a tag.
    - name: tag
      required: true
      description: The name of the tag to remove from the indicator.
    outputs:
    - contextPath: TC.Indicator.Name
      description: The name of the indicator.
      type: string
    - contextPath: TC.Indicator.Type
      description: The type of the indicator.
      type: string
    - contextPath: TC.Indicator.ID
      description: The ID of the indicator.
      type: string
    - contextPath: TC.Indicator.Description
      description: The description of the indicator.
      type: string
    - contextPath: TC.Indicator.Owner
      description: The owner of the indicator.
      type: string
    - contextPath: TC.Indicator.CreateDate
      description: The date on which the indicator was created.
      type: date
    - contextPath: TC.Indicator.LastModified
      description: The last date on which the indicator was modified.
      type: date
    - contextPath: TC.Indicator.Rating
      description: The threat rating of the indicator.
      type: number
    - contextPath: TC.Indicator.Confidence
      description: The confidence rating of the indicator.
      type: number
    - contextPath: TC.Indicator.WhoisActive
      description: The active indicator (for domains only).
      type: string
    - contextPath: TC.Indicator.File.MD5
      description: The MD5 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA1
      description: The SHA1 hash of the indicator of the file.
      type: string
    - contextPath: TC.Indicator.File.SHA256
      description: The SHA256 hash of the indicator of the file.
      type: string
    - contextPath: IP.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the full description.
      type: string
    - contextPath: URL.Data
      description: The data of the URL of the indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the full description.
      type: string
    - contextPath: Domain.Name
      description: The domain name of the indicator.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the full description.
      type: string
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the full description.
      type: string
    description: Removes a tag from a specified indicator.
  - name: tc-delete-indicator
    arguments:
    - name: indicator
      required: true
      description: The name of the indicator to delete.
    description: Deletes an indicator from ThreatConnect.
  - name: tc-create-campaign
    arguments:
    - name: name
      required: true
      description: The name of the campaign group.
    - name: firstSeen
      description: The earliest date on which the campaign was seen.
    - name: owner
      description: The owner of the new incident. The default is the "defaultOrg"
        parameter.
    - name: description
      description: The description of the campaign.
    - name: tag
      description: The name of the tag to apply to the campaign.
    - name: securityLabel
      description: The security label of the campaign. For example, "TLP:Green".
    outputs:
    - contextPath: TC.Campaign.Name
      description: The name of the campaign.
      type: string
    - contextPath: TC.Campaign.Owner
      description: The owner of the campaign.
      type: string
    - contextPath: TC.Campaign.FirstSeen
      description: The earliest date on which the campaign was seen.
      type: date
    - contextPath: TC.Campaign.Tag
      description: The tag of the campaign.
      type: string
    - contextPath: TC.Campaign.SecurityLevel
      description: The security label of the campaign.
      type: string
    - contextPath: TC.Campaign.ID
      description: The ID of the campaign.
      type: string
    description: Creates a group based on the "Campaign" type.
  - name: tc-create-event
    arguments:
    - name: name
      required: true
      description: The name of the event group.
    - name: eventDate
      description: The date on which the event occurred. If the date is not specified,
        the current date is used.
    - name: status
      auto: PREDEFINED
      predefined:
      - Needs Review
      - False Positive
      - No Further Action
      - Escalated
      description: The status of the event. Can be "Needs Review", "False Positive",
        "No Further Action", or "Escalated".
    - name: owner
      description: The owner of the event.
    - name: description
      description: The description of the event.
    - name: tag
      description: The tag of the event.
    outputs:
    - contextPath: TC.Event.Name
      description: The name of the event.
      type: string
    - contextPath: TC.Event.Date
      description: The date of the event.
      type: date
    - contextPath: TC.Event.Status
      description: The status of the event.
      type: string
    - contextPath: TC.Event.Owner
      description: The owner of the event.
      type: string
    - contextPath: TC.Event.Tag
      description: The tag of the event.
      type: string
    - contextPath: TC.Event.ID
      description: The ID of the event.
      type: string
    description: Creates a group based on the "Event" type.
  - name: tc-create-threat
    arguments:
    - name: name
      required: true
      description: The name of the threat group.
    outputs:
    - contextPath: TC.Threat.Name
      description: The name of the threat.
      type: string
    - contextPath: TC.Threat.ID
      description: The ID of the threat.
      type: string
    description: Creates a group based on the "Threats" type.
  - name: tc-delete-group
    arguments:
    - name: groupID
      required: true
      description: The ID of the group to delete.
    - name: type
      required: true
      auto: PREDEFINED
      predefined:
      - Incidents
      - Events
      - Campaigns
      - Threats
      description: The type of the group to delete. Can be "Incidents", "Events",
        "Campaigns", or "Threats".
    description: Deletes a group.
  - name: tc-add-group-attribute
    arguments:
    - name: group_id
      required: true
      description: The ID of the group to which to add attributes. To get the ID of
        the group, run the tc-get-groups command.
    - name: attribute_type
      required: true
      description: The type of attribute to add to the group. The type is located
        in the UI in a specific group or under Org Config.
    - name: attribute_value
      required: true
      description: The value of the attribute.
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group. Can be "adversaries", "campaigns", "documents",
        "emails", "events", "incidents", "intrusionSets", "reports", "signatures",
        or "threats".
    outputs:
    - contextPath: TC.Group.DateAdded
      description: The date on which the attribute was added.
      type: Date
    - contextPath: TC.Group.LastModified
      description: The date on which the added attribute was last modified.
      type: Date
    - contextPath: TC.Group.Type
      description: The type of the group to which the attribute was added.
      type: String
    - contextPath: TC.Group.Value
      description: The value of the attribute added to the group.
      type: String
    - contextPath: TC.Group.ID
      description: The group ID to which the attribute was added.
      type: Number
    description: Adds an attribute to a specified group.
  - name: tc-get-events
    arguments: []
    outputs:
    - contextPath: TC.Event.DateAdded
      description: The date on which the event was added.
      type: Date
    - contextPath: TC.Event.EventDate
      description: The date on which the event occurred.
      type: Date
    - contextPath: TC.Event.ID
      description: The ID of the event.
      type: Number
    - contextPath: TC.Event.OwnerName
      description: The name of the owner of the event.
      type: String
    - contextPath: TC.Event.Status
      description: The status of the event.
      type: String
    description: Returns a list of events.
  - name: tc-get-groups
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group. Can be "adversaries", "campaigns", "documents",
        "emails", "events", "incidents", "intrusionSets", "reports", "signatures",
        or "threats".
    outputs:
    - contextPath: TC.Group.DateAdded
      description: The date on which the group was added.
      type: Date
    - contextPath: TC.Group.EventDate
      description: The date on which the event occurred.
      type: Date
    - contextPath: TC.Group.Name
      description: The name of the group.
      type: String
    - contextPath: TC.Group.OwnerName
      description: The name of the owner of the group.
      type: String
    - contextPath: TC.Group.Status
      description: The status of the group.
      type: String
    - contextPath: TC.Group.ID
      description: The ID of the group.
      type: Number
    description: Returns all groups, filtered by the group type.
  - name: tc-add-group-security-label
    arguments:
    - name: group_id
      required: true
      description: The ID of the group to which to add the security label. To get
        the ID, run the tc-get-groups command.
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group to which to add the security label. Can be
        "adversaries", "campaigns", "documents", "emails", "events", "incidents",
        "intrusionSets", "reports", "signatures", or "threats".
    - name: security_label_name
      required: true
      description: The name of the security label to add to the group. For example,
        "TLP:GREEN".
    description: Adds a security label to a group.
  - name: tc-add-group-tag
    arguments:
    - name: group_id
      required: true
      description: The ID of the group to which to add the tag. To get the ID, run
        the tc-get-groups command.
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group to which to add the tag. Can be "adversaries",
        "campaigns", "documents", "emails", "events", "incidents", "intrusionSets",
        "reports", "signatures", or "threats".
    - name: tag_name
      required: true
      description: The name of the tag to add to the group.
    description: Adds tags to a specified group.
  - name: tc-get-indicator-types
    arguments: []
    outputs:
    - contextPath: TC.IndicatorType.ApiBranch
      description: The branch of the API.
      type: String
    - contextPath: TC.IndicatorType.ApiEntity
      description: The entity of the API.
      type: String
    - contextPath: TC.IndicatorType.CasePreference
      description: The case preference of the indicator. For example, "sensitive",
        "upper", or "lower".
      type: String
    - contextPath: TC.IndicatorType.Custom
      description: Whether the indicator is a custom indicator.
      type: Boolean
    - contextPath: TC.IndicatorType.Parsable
      description: Whether the indicator can be parsed.
      type: Boolean
    - contextPath: TC.IndicatorType.Value1Type
      description: The name of the indicator.
      type: String
    - contextPath: TC.IndicatorType.Value1Label
      description: The value label of the indicator.
      type: String
    description: Returns all indicator types available.
  - name: tc-group-associate-indicator
    arguments:
    - name: indicator_type
      required: true
      description: The type of the indicator. To get the available types, run the
        tc-get-indicator-types command. The indicator must be spelled as displayed
        in the ApiBranch column of the UI.
    - name: indicator
      required: true
      description: The name of the indicator. For example, "indicator_type=emailAddresses"
        where "indicator=a@a.co.il".
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group. Can be "adversaries", "campaigns", "documents",
        "emails", "events", "incidents", "intrusionSets", "reports", "signatures",
        or "threats".
    - name: group_id
      required: true
      description: The ID of the group. To get the ID of the group, run the tc-get-groups
        command.
    outputs:
    - contextPath: TC.Group.GroupID
      description: The ID of the group.
      type: Number
    - contextPath: TC.Group.GroupType
      description: The type of the group.
      type: String
    - contextPath: TC.Group.Indicator
      description: The name of the indicator.
      type: String
    - contextPath: TC.Group.IndicatorType
      description: The type of the indicator.
      type: String
    description: Associates an indicator with a group.
  - name: tc-create-document-group
    arguments:
    - name: file_name
      required: true
      description: The name of the file to display in the UI.
    - name: name
      required: true
      description: The name of the file.
    - name: malware
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether the file is malware. If "true", ThreatConnect creates a
        password-protected ZIP file on your local machine that contains the sample
        and uploads the ZIP file.
    - name: password
      description: The password of the ZIP file.
    - name: security_label
      description: The security label of the group.
    - name: description
      description: A description of the group.
    - name: entry_id
      required: true
      description: The file of the ID of the entry, as displayed in the War Room.
    outputs:
    - contextPath: TC.Group.Name
      description: The name of the group.
      type: String
    - contextPath: TC.Group.Owner
      description: The owner of the group.
      type: String
    - contextPath: TC.Group.EventDate
      description: The date on which the group was created.
      type: Date
    - contextPath: TC.Group.Description
      description: The description of the group.
      type: String
    - contextPath: TC.Group.SecurityLabel
      description: The security label of the group.
      type: String
    - contextPath: TC.Group.ID
      description: The ID of the group to which the attribute was added.
      type: Number
    description: Creates a document group.
  - name: tc-get-group
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of group for which to return the ID. Can be "adversaries",
        "campaigns", "documents", "emails", "events", "incidents", "intrusionSets",
        "reports", "signatures", or "threats".
    - name: group_id
      required: true
      description: The ID of the group to retrieve. To get the ID, run the tc-get-groups
        command.
    outputs:
    - contextPath: TC.Group.DateAdded
      description: The date on which the group was added.
      type: Date
    - contextPath: TC.Group.EventDate
      description: The date on which the event occurred.
      type: Date
    - contextPath: TC.Group.Name
      description: The name of the group.
      type: String
    - contextPath: TC.Group.Owner.ID
      description: The ID of the group owner.
      type: Number
    - contextPath: TC.Group.Owner.Name
      description: The name of the group owner.
      type: String
    - contextPath: TC.Group.Owner.Type
      description: The type of the owner.
      type: String
    - contextPath: TC.Group.Status
      description: The status of the group.
      type: String
    description: Retrieves a single group.
  - name: tc-get-group-attributes
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of group for which to return the attribute. Can be "adversaries",
        "campaigns", "documents", "emails", "events", "incidents", "intrusionSets",
        "reports", "signatures", or "threats".
    - name: group_id
      required: true
      description: The ID of the group for which to return the attribute. To get the
        ID, run the tc-get-groups command.
    outputs:
    - contextPath: TC.Group.Attribute.DateAdded
      description: The date on which the group was added.
      type: Date
    - contextPath: TC.Group.Attribute.Displayed
      description: Whether the attribute is displayed on the UI.
      type: Boolean
    - contextPath: TC.Group.Attribute.AttributeID
      description: The ID of the attribute.
      type: Number
    - contextPath: TC.Group.Attribute.LastModified
      description: The date on which the attribute was last modified.
      type: Date
    - contextPath: TC.Group.Attribute.Type
      description: The type of the attribute.
      type: String
    - contextPath: TC.Group.Attribute.Value
      description: The value of the attribute.
      type: String
    description: Retrieves the attribute of a group.
  - name: tc-get-group-security-labels
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of group for which to return the security labels. Can
        be "adversaries", "campaigns", "documents", "emails", "events", "incidents",
        "intrusionSets", "reports", "signatures", or "threats".
    - name: group_id
      required: true
      description: The ID of the group for which to return the security labels. To
        get the ID, run the tc-get-groups command.
    outputs:
    - contextPath: TC.Group.SecurityLabel.Name
      description: The name of the security label.
      type: String
    - contextPath: TC.Group.SecurityLabel.Description
      description: The description of the security label.
      type: String
    - contextPath: TC.Group.SecurityLabel.DateAdded
      description: The date on which the security label was added.
      type: Date
    description: Retrieves the security labels of a group.
  - name: tc-get-group-tags
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of group for which to return the tags. Can be "adversaries",
        "campaigns", "documents", "emails", "events", "incidents", "intrusionSets",
        "reports", "signatures", or "threats".
    - name: group_id
      required: true
      description: The ID of the group for which to return the tags. To get the ID,
        run the tc-get-groups command.
    outputs:
    - contextPath: TC.Group.Tag.Name
      description: The name of the tag.
      type: String
    description: Retrieves the tags of a group.
  - name: tc-download-document
    arguments:
    - name: document_id
      required: true
      description: The ID of the document.
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: Number
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The ssdeep hash of the file (same as displayed in file entries).
      type: String
    - contextPath: File.EntryID
      description: The entry ID of the file.
      type: String
    - contextPath: File.Info
      description: The information of the file.
      type: String
    - contextPath: File.Type
      description: The type of the file.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
    description: Downloads the contents of a document.
  - name: tc-get-group-indicators
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group for which to return the indicators. Can be
        "adversaries", "campaigns", "documents", "emails", "events", "incidents",
        "intrusionSets", "reports", "signatures", or "threats".
    - name: group_id
      required: true
      description: The ID of the group for which to return the indicators. To get
        the ID, run the tc-get-groups command.
    outputs:
    - contextPath: TC.Group.Indicator.Summary
      description: The summary of the indicator.
      type: String
    - contextPath: TC.Group.Indicator.ThreatAssessConfidence
      description: The confidence rating of the indicator.
      type: String
    - contextPath: TC.Group.Indicator.IndicatorID
      description: The ID of the indicator.
      type: Number
    - contextPath: TC.Group.Indicator.DateAdded
      description: The date on which the indicator was added.
      type: Date
    - contextPath: TC.Group.Indicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: TC.Group.Indicator.Rating
      description: The threat rating of the indicator.
      type: Number
    - contextPath: TC.Group.Indicator.ThreatAssertRating
      description: The rating of the threat assert.
      type: Number
    - contextPath: TC.Group.Indicator.OwnerName
      description: The name of the owner of the indicator.
      type: String
    - contextPath: TC.Group.Indicator.LastModified
      description: The date that the indicator was last modified.
      type: Date
    description: Returns indicators associated with a group.
  - name: tc-get-associated-groups
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of group. Can be "adversaries", "campaigns", "documents",
        "emails", "events", "incidents", "intrusionSets", "reports", "signatures",
        or "threats".
    - name: group_id
      required: true
      description: The ID of the group. To get the ID, run the tc-get-groups command.
    outputs:
    - contextPath: TC.Group.AssociatedGroup.DateAdded
      description: The date on which group was added.
      type: Date
    - contextPath: TC.Group.AssociatedGroup.GroupID
      description: The ID of the group.
      type: Number
    - contextPath: TC.Group.AssociatedGroup.Name
      description: The name of the group.
      type: String
    - contextPath: TC.Group.AssociatedGroup.OwnerName
      description: The name of the owner of the group.
      type: String
    - contextPath: TC.Group.AssociatedGroup.Type
      description: The type of the group.
      type: String
    description: Returns indicators associated with a specified group.
  - name: tc-associate-group-to-group
    arguments:
    - name: group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of the group. Can be "adversaries", "campaigns", "documents",
        "emails", "events", "incidents", "intrusionSets", "reports", "signatures",
        or "threats".
    - name: group_id
      required: true
      description: The ID of the group. To get the ID of the group, run the tc-get-groups
        command.
    - name: associated_group_type
      required: true
      auto: PREDEFINED
      predefined:
      - adversaries
      - campaigns
      - documents
      - emails
      - events
      - incidents
      - intrusionSets
      - reports
      - signatures
      - threats
      description: The type of group to associate. Can be "adversaries", "campaigns",
        "documents", "emails", "events", "incidents", "intrusionSets", "reports",
        "signatures", or "threats".
    - name: associated_group_id
      required: true
      description: The ID of the group to associate.
    outputs:
    - contextPath: TC.Group.AssociatedGroup.AssociatedGroupID
      description: The ID of the associated group.
      type: Number
    - contextPath: TC.Group.AssociatedGroup.AssociatedGroupType
      description: The type of the associated group.
      type: String
    - contextPath: TC.Group.AssociatedGroup.GroupID
      description: The ID of the group to associate to.
      type: Number
    - contextPath: TC.Group.AssociatedGroup.GroupType
      description: The type of the group to associate to.
      type: String
    description: Associates one group with another group.
  dockerimage: demisto/threatconnect-py3-sdk:latest
  runonce: false
  subtype: python3
sourcemoduleid: ThreatConnect
