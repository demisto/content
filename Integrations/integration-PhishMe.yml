commonfields:
  id: Phishme Intelligence
  version: -1
name: Phishme Intelligence
display: Phishme Intelligence
category: Data Enrichment
image: data:image/png;base64,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
description: Human-vetted, Phishing-specific Threat Intelligence from Phishme.
detaileddescription: |-
  Human-vetted, Phishing-specific Threat Intelligence from PhishMe.
  How to get the API key:
  Log in to your PhishMe account.
  Go to Settings
  API Tokens tab.
  Click on "Add a new api token"
configuration:
- display: Server URL (e.g https://www.threathq.com/apiv1)
  name: url
  defaultvalue: https://www.threathq.com/apiv1
  type: 0
  required: true
- display: API username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Use system proxy settings
  name: proxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Do not validate server certificate (insecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |
    var auth = 'Basic ' + Base64.encode(params.credentials.identifier + ':' + params.credentials.password);

    var sendRequest = function(method,api,urlargs) {

        var url = params.url;
        if (url[url.length - 1] === '/') {
            url = url.substring(0, url.length - 1);
        }

        var requestUrl = url + '/' + api + encodeToURLQuery(urlargs);
        var res = http(
            requestUrl,
            {
                Method: method,
                Headers: {
                    'Authorization': [auth]
                }
            },
            params.insecure,
            params.proxy
        );

        if ((res.StatusCode < 200 || res.StatusCode >= 300) && res.success === false) {
            throw 'PhishMe Request Failed.\nStatus code: ' + res.StatusCode + '.\nBody: ' + JSON.stringify(res) + '.';
        }

        try{
            return JSON.parse(res.Body);
        }
        catch(exc){
            throw "PhishMe Error: JSON parse error\n" + res;
        }
    };

    var addMD = function(threats, k) {
        var md = "";
        md += '### Threat ID ' + (k+1) + ': ' + threats[k].id + '\n';

        if (threats[k].label !== undefined) {
            md += "Name of the campaign: **" + threats[0].label + "**\n";
        }
        if (threats[k].blockSet[0].ipDetail !== undefined) {
            md += "ASN: **" + threats[k].blockSet[0].ipDetail.asn + " " + threats[k].blockSet[0].ipDetail.asnOrganization+"**\n";
        }
        if (threats[k].blockSet[0].ipDetail !== undefined) {
            md += "Country: **" + threats[k].blockSet[0].ipDetail.countryName + "**\n";
        }
        if (threats[k].executiveSummary !== undefined) {
            md += "#### Executive Summary: \n";
        }
        if (threats[k].executiveSummary !== undefined) {
            md += threats[k].executiveSummary + "\n";
        }

        md += "#### Threat Types:\n";
        for (var j = 0; j < threats[k].malwareFamilySet.length; j++){
            md += "* " + threats[k].malwareFamilySet[j].description + "\n";
        }
        md += '##### Last published: ' + new Date(threats[k].lastPublished) +'\n';
        return md;
    };

    var searchUrl = function(url) {
        var tmpargs = {};
        tmpargs.urlSearch = url;
        var res = sendRequest("POST","threat/search",tmpargs);
        var threats = res.data.threats;
        var ec = {};
        var md = "## PhishMe URL Reputation for: "+url+"\n";
        var dbotScore = 0;
        var threatArray = [];
        if (threats.length !== 0) {
            ec.URL = {
                        Data: url,
                        Malicious: {Vendor: 'PhishMe', Description: 'Match found in PhishMe database'}
                      };
            for (var k = 0; k < threats.length; k++) {
                for (var i = 0; i < threats[0].blockSet.length; i++){
                    if (threats[0].blockSet[i]['data'].indexOf(url) !== -1) {
                        var severityLevel = threats[0].blockSet[i]['impact'];
                        break;
                    }
                }
                dbotScore = calcScore(severityLevel);
                md += 'Verdict: ' + calcVerdict(dbotScore) +'\n';
                md += addMD(threats, k);
                threatArray[k] = threats[k].id;
            }
            ec.URL['PhishMe'] = {};
            ec.URL.PhishMe['ThreatIDs'] = threatArray;
        } else {
            md += "No information found for this url";
        }

        ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'PhishMe', Score: dbotScore};

        return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
    };

    var extractedString = function(str,limit) {
        var tmpargs = {};
        tmpargs.extractedString = str;
        var res = sendRequest("POST","threat/search",tmpargs);
        var threats = res.data.threats;
        var countThreats = 0;
        var acThreats = [];
        var md = "## PhishMe Search Reputation for: "+str+"\n";
        var ec = {};

        if (threats.length !== 0) {
            if(limit === undefined){
                limit = 10;
            }

            for(var i = 0; i < threats.length; i++){
                if (threats[i].hasReport === true){
                    countThreats += 1;
                    if (countThreats<limit+1){
                        acThreats.push(threats[i].threatDetailURL);
                    }
                }
            }

            md += "There are " + countThreats + " threats regarding your string search.\n";
            md += "### Details from the last campaign\n";

            md += addMD(threats);

            ec = {"PhishMe" : {}};
            ec.PhishMe = {"String": str, "NumOfThreats": countThreats};

        } else {
            md += "There are no results for this search\n";
            ec = {"PhishMe" : {}};
            ec.PhishMe = {"String": str, "NumOfThreats": 0};
        }

        return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
    };

    var checkEmail = function(sender_name) {
        var tmpargs = {};
        tmpargs.watchListEmail = sender_name;
        var res = sendRequest("POST","threat/search",tmpargs);
        var threats = res.data.threats;
        var ec = {};
        var md = "## PhishMe email Reputation for: " + sender_name + "\n";
        var dbotScore = 0;
        var threatArray = [];
        if (threats.length !== 0) {
            ec.Email = {
                          Data: sender_name,
                          Malicious: {Vendor: 'PhishMe', Description: 'Match found in PhishMe database'}
                        };
            for (var k = 0; k < threats.length; k++) {
                for (var i = 0; i < threats[0].blockSet.length; i++){
                    if (threats[0].blockSet[i]['data'].indexOf(sender_name) !== -1) {
                        var severityLevel = threats[0].blockSet[i]['impact'];
                        break;
                    }
                }
                dbotScore = calcScore(severityLevel);
                md += 'Verdict: ' + calcVerdict(dbotScore) +'\n';
                md += addMD(threats, k);
                threatArray[k] = threats[k].id;
            }
            ec.Email['PhishMe'] = {};
            ec.Email.PhishMe['ThreatIDs'] = threatArray;
        } else {
            md += "No infomation found for this email";
        }

        ec.DBotScore = {Indicator: sender_name, Type: 'email', Vendor: 'PhishMe', Score: dbotScore};

        return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
    };

    var checkMD5 = function(str) {
        var tmpargs = {};
        tmpargs.allMD5 = str;
        var res = sendRequest("POST","threat/search",tmpargs);
        var threats = res.data.threats;
        var ec = {};
        var md = "## PhishMe IP Reputation for: "+str+"\n";
        var dbotScore = 0;
        var threatArray = [];
        if (threats.length !== 0) {
            ec.File = {
                        MD5: str,
                        Malicious: {Vendor: 'PhishMe', Description: 'Match found in PhishMe database'}
                        };
            for (var k = 0; k < threats.length; k++) {
                for (var i = 0; i < threats[0].executableSet.length; i++){
                    if (threats[0].executableSet[i]['md5Hex'] === str) {
                        var severityLevel = threats[0].executableSet[i]['severityLevel'];
                        break;
                    }
                }
                dbotScore = calcScore(severityLevel);
                md += 'Verdict: ' + calcVerdict(dbotScore) +'\n';
                md += addMD(threats, k);
                threatArray[k] = threats[k].id;
            }
            ec.File['PhishMe'] = {};
            ec.File.PhishMe['ThreatIDs'] = threatArray;
        } else {
            md += "No information found for this hash";
        }

        ec.DBotScore = {Indicator: str, Type: 'file', Vendor: 'PhishMe', Score: dbotScore};

        return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
    }

    var checkIP = function(ip) {
        var tmpargs = {};
        tmpargs.ip = ip;
        var res = sendRequest("POST","threat/search",tmpargs);
        var threats = res.data.threats;
        var ec = {};
        var md = "## PhishMe IP Reputation for: "+ip+"\n";
        var dbotScore = 0;
        var threatArray = [];
        if (threats.length !== 0) {
            ec.IP = {
                      Data: ip,
                      Malicious: {Vendor: 'PhishMe', Description: 'Match found in PhishMe database'}
                    };
            for (var k = 0; k < threats.length; k++) {
                for (var i = 0; i < threats[0].blockSet.length; i++){
                    if (threats[0].blockSet[i]['ipDetail'] && threats[0].blockSet[i]['ipDetail']['ip']===ip) {
                        var severityLevel = threats[0].blockSet[i]['impact'];
                        break;
                    }
                }
                dbotScore = calcScore(severityLevel);
                md += 'Verdict: ' + calcVerdict(dbotScore) +'\n';
                md += addMD(threats,k);
                threatArray[k] = threats[k].id;
            }
            ec.IP['PhishMe'] = {};
            ec.IP.PhishMe['ThreatIDs'] = threatArray;

        } else {
            md += "No information found for this ip";
        }

        ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'PhishMe', Score: dbotScore};

        return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note, 'Contents': res, "HumanReadable": md, "EntryContext": ec} );
    }

    var calcVerdict = function (dbotScore) {
        switch (dbotScore){
            case 0:
                return 'Unknown';
            case 2:
                return 'Suspicious';
            case 3:
                return 'Bad';
        }
    }

    var calcScore = function (severityLevel) {
        switch (severityLevel){
            case 'None':
                return 0;
            case 'Minor':
                return 2;
            case 'Moderate':
                return 2;
            case 'Major':
                return 3;
        }
    }


    function addDays(theDate, days) {
        return theDate.getTime() - days*24*60*60*1000;
    }

    var updates = function(){
        var newDate = addDays(new Date(), 50);
        var tmpargs = {};
        tmpargs.timestamp = newDate;
        var res = sendRequest("POST","threat/updates", tmpargs);
        var ec = {};
        var md = "";

        return res;
    }

    switch (command) {
        // This is the call made when pressing the integration test button.
        case 'test-module':
            res = updates();
            if (res.success === true){
                return 'ok';
            }else {
                return JSON.stringify(res);
            }

        case "url":
            return searchUrl(args.url);

        case "phishme-search":
            return extractedString(args.str, args.limit);

        case "email":
            return checkEmail(args.email)

        case "file":
            return checkMD5(args.file);

        case "ip":
            return checkIP(args.ip);
        default:
    }
  type: javascript
  commands:
  - name: url
    arguments:
    - name: url
      required: true
      default: true
      description: Url to check
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check URL Reputation
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to query. Supports MD5, SHA1 and SHA256. Notice
        that you can pass comma-separated multiple values to efficiently retrieve
        multiple responses.
    outputs:
    - contextPath: File.MD5
      description: File MD5
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check if file MD5 is malicious
  - name: ip
    arguments:
    - name: ip
      required: true
      default: true
      description: IP address to check
    outputs:
    - contextPath: IP.Address
      description: Bad IP Address found
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check IP Reputation
  - name: phishme-search
    arguments:
    - name: str
      required: true
      default: true
      description: String to search
    - name: limit
      description: Limit of strings to search
      defaultValue: "10"
    outputs:
    - contextPath: PhishMe.NumOfThreats
      description: Number of threats
    - contextPath: PhishMe.String
      description: String to search
    description: 'Search for extracted strings discovered within malware campaigns.'
  - name: email
    arguments:
    - name: email
      required: true
      default: true
      description: Sender address
    outputs:
    - contextPath: Email.From
      description: Sender address to check
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
    - contextPath: DBotScore.Type
      description: The type of the indicator
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    description: Check if sender address is malicious
hidden: false
releaseNotes: 'Added Threat IDs and last published date to output'
