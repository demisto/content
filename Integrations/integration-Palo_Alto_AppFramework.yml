commonfields:
  id: Palo Alto AppFramework
  version: -1
name: Palo Alto AppFramework
display: Palo Alto AppFramework
category: Analytics & SIEM
image: data:image/png;base64,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
description: This framework manages all PA's cloud managed products
configuration:
- display: API url provided by Palo Alto. (e.g. https://apigw-stg4.us.paloaltonetworks.com)
  name: apiUrl
  defaultvalue: ""
  type: 0
  required: true
- display: Accept any certificate
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Client ID from Palo Alto cloud
  name: clientId
  defaultvalue: ""
  type: 0
  required: true
- display: Client Secret from Palo Alto cloud
  name: clientSecret
  defaultvalue: ""
  type: 4
  required: true
- display: Refresh token
  name: refreshToken
  defaultvalue: ""
  type: 4
  required: true
- display: 'PAN application to fetch from (for example: Wildfire)'
  name: application
  defaultvalue: ""
  type: 0
  required: false
- display: Severity to filter fetch results by (Informational, Low, Medium, High,
    Critical)
  name: severity
  defaultvalue: ""
  type: 0
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |
    ''' IMPORTS '''
    import os
    import datetime
    import requests
    import json
    from time import strftime
    from time import localtime
    import pancloud
    from pancloud.logging import LoggingService
    from pancloud.event import EventService
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''

    API_URL=demisto.params()['apiUrl']
    REFRESH_TOKEN=demisto.params()['refreshToken']
    USE_SSL = not demisto.params().get('insecure', False)

    DEFAULT_HEADERS = {
        'Accept': 'application/json',
        'Content-Type': (
            'application/x-www-form-urlencoded;charset=UTF-8'
        )
    }

    THREAT_TABLE_HEADERS = ['id', 'score', 'risk-of-app','type', 'action', 'app', 'pcap_id', 'proto', 'dst', 'reportid', 'rule', 'category-of-threatid', 'characteristic-of-app', 'device_name',
                            'subtype', 'time_received', 'pcap', 'name-of-threatid', 'severity', 'nat', 'natdport', 'natdst', 'natsrc', 'src', 'category-of-app', 'srcloc', 'dstloc', 'category', 'SHA256', 'filetype', 'filename']

    TRAFFIC_TABLE_HEADERS = ['id', 'score', 'aggregations.size', 'action', 'app', 'proto', 'dst', 'rule', 'characteristic-of-app', 'device_name', 'risk-of-app', 'natsport', 'start', 'subcategory-of-app'
                             'time_received', 'nat', 'natdport', 'natdst', 'natsrc', 'src', 'category-of-app', 'srcloc', 'dstloc' ]

    COMMON_HEADERS = ['id', 'score', 'action', 'app', 'proto', 'dst', 'rule', 'characteristic-of-app', 'device_name', 'nat', 'natdport', 'natdst', 'natsrc', 'src', 'category-of-app', 'srcloc', 'dstloc','filetype', 'SHA256', 'filename']

    API_TOKEN_URL = 'https://api.paloaltonetworks.com/api/oauth2/RequestToken'

    def refresh_access_token(refresh_token):
        """ Refresh an Access-Token

            Args:
                refresh_token (str): a valid Refresh-Token
            Returns:
                str: new Access-Token

            Code is modified from the following gist - https://gist.github.com/jtschichold/df349bcf2a9ca16a0ac69c4ff1d5edd1
        """
        client_id = demisto.params()['clientId']
        client_secret = demisto.params()['clientSecret']

        # grant_type should refreshToken per OAuth2 std
        # refresh_token should be a valid <refreshToken> per OAuth2
        request_params = [('grant_type', 'refresh_token')]
        request_params.append((unicode('refresh_token'), refresh_token))
        request_params.append((unicode('client_id'), client_id))
        request_params.append((unicode('client_secret'), client_secret))

        # POST the request
        response = requests.post(
            API_TOKEN_URL,
            data=request_params,
            timeout=20,
            headers=DEFAULT_HEADERS,
            verify=USE_SSL,
        )
        response.raise_for_status()

        # load the JSON response
        response_json = response.json()
        # and check for errors
        if 'error' in response_json:
            LOG('Error: {!r} Description: {!r}'.format(response_json['error'], response_json['error_description']))
            raise Exception('Error refreshing token. Error: {!r} Description: {!r}'.format(response_json['error'], response_json['error_description']))
        # if all good, just return the new access token
        try:
            return response_json['access_token']
        except KeyError:
            raise Exception("Problem with refreshing token in Palo Alto. Response from server was: " + json.dumps(response_json))

    def update_context_data(access_token):
        new_data = {
            'access_token': access_token,
            'timestamp': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        demisto.setIntegrationContext(new_data)

    def refresh_needed(saved_data):
        '''
        This function returns whether or not we need to refresh our access token
        '''
        if ((saved_data is None) or ('access_token' not in saved_data) or ('timestamp' not in saved_data)):
            return True

        current_time = datetime.datetime.now()
        saved_time = datetime.datetime.strptime(saved_data['timestamp'], "%Y-%m-%d %H:%M:%S")
        # access token is valid for one hour

        if ((current_time - saved_time).total_seconds() >= 3600):
            return True

        return False

    def get_access_token(refresh_token):
        '''
        This function checks if we need to refresh our authentication token and if we do it
        refreshes the token and returns the new one
        '''
        access_token = None
        saved_data = demisto.getIntegrationContext()

        if (refresh_needed(saved_data)):
            access_token = refresh_access_token(refresh_token)
            update_context_data(access_token)
        else:
            access_token = saved_data['access_token']

        return access_token

    try:
        ACCESS_TOKEN=get_access_token(REFRESH_TOKEN)
    except AttributeError:
        # if we are using a Demisto version which doesn't support integrationContext (Demisto <= 3.6)
        ACCESS_TOKEN=refresh_access_token(REFRESH_TOKEN)


    # setting the access token as env variable for the pancloud sdk
    os.environ['ACCESS_TOKEN'] = ACCESS_TOKEN;

    ''' HELPER FUNCTIONS '''

    def ack_event_channel(channel_id):
        '''
        Event Service always begins reading from the beginning of the channel whenever it starts up.
        This means that if the service restarts, the app will be reading events that it has already seen
        and, presumably, has already processed. To avoid this, we ack the channel. An ack causes the
        beginning of the channel to move to the current read point. Mechanically, the Event Service simply
        deletes all events from the channel that existed prior to the current read point.
        '''
        event_service = EventService(
            url=API_URL,
            headers={
                'Authorization': 'Bearer {}'.format(ACCESS_TOKEN),
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        )

        # ack event channel
        event_service.ack(channel_id)

    def query_loggings(query_data):
        '''
        This function handles all the querying of Appframework Logging service
        '''

        logging_service = LoggingService(
            url=API_URL,
            headers={
                'Authorization': 'Bearer {}'.format(ACCESS_TOKEN),
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        )

        query_result= logging_service.query(query_data).json()

        try:
            query_id = query_result['queryId']  # access 'queryId' from 'query' response
        except Exception, e:
            raise Exception('Received error %s when querying logs. Please check if your authentication token is valid' % e)
        poll_params = {  # Prepare 'poll' params
            "maxWaitTime": 1000 # waiting for resposnse up to 1000ms
        }

        # we poll the logging service until we have a complete response
        full_response = logging_service.poll_all(query_id, 0, poll_params)

        # delete the query from the service
        logging_service.delete(query_id)

        return full_response

    def poll_events(channel_id):
        '''
        This function handles polling events from Appframework's Events service
        '''

        event_service = EventService(
            url=API_URL,
            headers={
                'Authorization': 'Bearer {}'.format(ACCESS_TOKEN),
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        )
        # Poll event channel
        return event_service.poll(channel_id)

    def transform_row_keys(row):
        transformed_row = {}
        for metric, value in row.iteritems():
            if (metric == 'filedigest'):
                transformed_row['SHA256'] = value
            elif (metric == 'misc'):
                transformed_row['filename'] = value
            elif (metric == 'category' and str(value) == '1'):
                transformed_row['category'] = 'malicious'
            else:
                transformed_row[metric] = value
        return transformed_row

    def results_screener(table_name, full_results):
        '''
        This function is used to make sure we include only pre-defined metrics in the human readable
        '''
        screened_results = []

        if(table_name == "traffic"):
            for row in full_results:
                screened_row = {metric:value for metric, value in row.iteritems() if metric in TRAFFIC_TABLE_HEADERS}
                screened_results.append(screened_row)
        elif (table_name == "threat"):
            for row in full_results:
                screened_row = {metric:value for metric, value in row.iteritems() if metric in THREAT_TABLE_HEADERS}
                screened_results.append(screened_row)
        elif (table_name == "common"):
            for row in full_results:
                screened_row = {metric:value for metric, value in row.iteritems() if metric in COMMON_HEADERS}
                screened_results.append(screened_row)
        else:
            return full_results

        return screened_results

    def get_start_time(date_type, time_value):
        current_date = datetime.datetime.now()
        if (date_type == 'minutes'):
            return current_date - datetime.timedelta(minutes=time_value)
        elif (date_type == 'days'):
            return current_date - datetime.timedelta(days=time_value)
        elif (date_type == 'weeks'):
            return current_date - datetime.timedelta(weeks=time_value)

    def convert_log_to_incident(log):
        log_contents = log['_source']
        log_contents['id'] = log['_id']
        log_contents['score'] = log['_score']
        occured = datetime.datetime.utcfromtimestamp(log_contents['time_received']).isoformat() + 'Z'
        # stringifying dictionary values for fetching. (json.dumps() doesn't stringify dictionary values)
        for key, value in log_contents.iteritems():
            log_contents[key] = str(value)
        incident = {
            'name': 'Wildfire file detected ' + str(log_contents.get('filedigest', None)),
            'rawJSON': json.dumps(log_contents, ensure_ascii=False),
            'labels':[
                {
                    'type': 'id',
                    'value': log.get('_id', None)
                },
                {
                    'type': 'score',
                    'value': str(log.get('_score', None))
                },
                {
                    'type': 'srcuser',
                    'value': log_contents.get('srcuser', None)
                },
                {
                    'type': 'threatid',
                    'value': str(log_contents.get('threatid', None))
                },
                {
                    'type': 'sport',
                    'value': str(log_contents.get('sport', None))
                },
                {
                    'type': 'dport',
                    'value': str(log_contents.get('dport', None))
                },
                {
                    'type': 'src',
                    'value': log_contents.get('src', None)
                },
                {
                    'type': 'subtype',
                    'value': log_contents.get('subtype', None)
                },
                {
                    'type': 'reportid',
                    'value': str(log_contents.get('reportid', None))
                },
                {
                    'type': 'SHA256',
                    'value': str(log_contents.get('filedigest', None))
                }
            ],
            'occurred': occured
        }
        return incident

    def severity_name_to_number(severity):
        severity_to_check = severity
        if not severity_to_check:
            return None
        else:
            severity_to_check = severity.lower()

        severity_number_dic = {
            'informational': 1,
            'low': 2,
            'medium': 3,
            'high': 4,
            'critical': 5
        }

        if severity_to_check in severity_number_dic:
            return severity_number_dic[severity_to_check]
        else:
            raise Exception('''Severity parameter of the integration should be one of the
                following: Informational, Low, Medium, High, Critical''')

    def app_to_table(app):
        app_to_check = app
        if not app_to_check:
            return None
        else:
            app_to_check = app.lower()
        app_to_table_dic = {
            'wildfire': 'wildfire'
        }
        if app_to_check in app_to_table_dic:
            return app_to_table_dic[app_to_check]
        else:
            raise Exception('''Application to fetch from parameter of the integration should be one of the
                following: Wildfire''')

    ''' COMMANDS FUNCTIONS '''

    def query_logs_command():
        '''
        Corresponds to 'pan-appframework-query-logs' command. Return the result of querying the Logging service
        '''
        args = demisto.args()
        start_time = args.get('startTime')
        end_time = args.get('endTime')
        time_range = args.get('timeRange')
        time_value = args.get('rangeValue')

        if (time_range):
            if (time_value):
                service_end_date = datetime.datetime.now()
                service_start_date = get_start_time(time_range, int(time_value))
            else:
                raise 'Please enter timeRange and timeValue, or startTime and endTime'
        else:
            # parses user input to datetime object
            service_start_date = datetime.datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S")
            service_end_date = datetime.datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S")

        # transforms datetime object to epoch time
        service_start_date_epoch = int(service_start_date.strftime("%s"))
        service_end_date_epoch = int(service_end_date.strftime("%s"))

        query = args.get('query')

        if ("limit" not in query.lower()):
            query += " LIMIT 100"

        query_data = {
            "query": query,
            "startTime": service_start_date_epoch,
            "endTime": service_end_date_epoch,
        }

        pages = query_loggings(query_data)
        results = []
        table_name = None
        for page in pages:
            current_page = page.json()
            table_name = current_page['result']['esQuery']['table'][0].split('.')[1]
            table_rows = current_page['result']['esResult']['hits']['hits']

            for row in table_rows:
                row_id = row['_id']
                row_contents = row['_source']
                row_contents['id'] = row_id
                row_contents['score'] = row['_score']
                transformed_row = transform_row_keys(row_contents)
                results.append(transformed_row)

        screened_results = results_screener('common', results)

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Logs ' + table_name + ' table',  screened_results),
            'EntryContext': {
                  'Appframework.Logging(val.id==obj.id)': results
            }
        }

        return entry

    def poll_events_command():
        '''
        corresponds to 'pan-appframework-poll-events' command. Polls events from Appframework
        '''

        channel_id = 'EventFilter'

        # brings the reading point to date
        ack_event_channel(channel_id)

        # returns the events from the channel
        return poll_events(channel_id).json()

    def get_critical_logs_command():
        '''
        corresponds to 'pan-appframework-get-critical-threat-logs' command. Queries Appframework Logging according to a pre-set query
        '''

        args = demisto.args()

        start_time = args.get('startTime')
        end_time = args.get('endTime')
        value = args.get('logsAmount')
        time_range = args.get('timeRange')
        time_value = args.get('rangeValue')

        if (time_range):
            if (time_value):
                service_end_date = datetime.datetime.now()
                service_start_date = get_start_time(time_range, int(time_value))
            else:
                raise 'Please enter timeRange and timeValue, or startTime and endTime'
        else:
            # parses user input to datetime object
            service_start_date = datetime.datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S")
            service_end_date = datetime.datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S")

        # transforms datetime object to epoch time
        service_start_date_epoch = int(service_start_date.strftime("%s"))
        service_end_date_epoch = int(service_end_date.strftime("%s"))

        api_query = "SELECT * FROM panw.threat WHERE severity = '5' LIMIT " + value

        query_data = {
            "query": api_query,
            "startTime": service_start_date_epoch,
            "endTime": service_end_date_epoch,
        }
        pages = query_loggings(query_data)

        results = []
        table_name = None
        for page in pages:
            current_page = page.json()
            table_name = current_page['result']['esQuery']['table'][0].split('.')[1]
            table_rows = current_page['result']['esResult']['hits']['hits']

            for row in table_rows:
                row_id = row['_id']
                row_contents = row['_source']
                row_contents['id'] = row_id
                row_contents['score'] = row['_score']
                transformed_row = transform_row_keys(row_contents)
                results.append(transformed_row)

        screened_results = results_screener('threat', results)

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Logs ' + table_name + ' table',  screened_results),
            'EntryContext': {
                  'Appframework.Logging(val.id==obj.id)': results
            }
        }
        return entry

    def get_social_applications_command():
        ''' corresponds to 'pan-appframework-get-social-applications' command. Queries Appframework Logging according to a pre-set query '''

        args = demisto.args()

        start_time = args.get('startTime')
        end_time = args.get('endTime')
        value = args.get('logsAmount')
        time_range = args.get('timeRange')
        time_value = args.get('rangeValue')

        if (time_range):
            if (time_value):
                service_end_date = datetime.datetime.now()
                service_start_date = get_start_time(time_range, int(time_value))
            else:
                raise 'Please enter timeRange and timeValue, or startTime and endTime'
        else:
            # parses user input to datetime object
            service_start_date = datetime.datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S")
            service_end_date = datetime.datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S")

        # transforms datetime object to epoch time
        service_start_date_epoch = int(service_start_date.strftime("%s"))
        service_end_date_epoch = int(service_end_date.strftime("%s"))

        api_query = "SELECT * FROM panw.traffic WHERE subcategory-of-app = 'social-networking' LIMIT " + value

        query_data = {
            "query": api_query,
            "startTime": service_start_date_epoch,
            "endTime": service_end_date_epoch,
        }

        pages = query_loggings(query_data)

        results = []
        table_name = None
        for page in pages:
            current_page = page.json()
            table_name = current_page['result']['esQuery']['table'][0].split('.')[1]
            table_rows = current_page['result']['esResult']['hits']['hits']

            for row in table_rows:
                row_id = row['_id']
                row_contents = row['_source']
                row_contents['id'] = row_id
                row_contents['score'] = row['_score']
                results.append(row_contents)

        screened_results = results_screener('traffic', results)

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Logs ' + table_name + ' table',  screened_results),
            'EntryContext': {
                  'Appframework.Logging(val.id==obj.id)': results
            }
        }
        return entry

    def search_by_file_hash_command():
        '''
        corresponds to 'pan-appframework-search-by-file-hash' command. Queries Appframework Logging according to a pre-set query
        '''

        args = demisto.args()

        start_time = args.get('startTime')
        end_time = args.get('endTime')
        value = args.get('logsAmount')
        time_range = args.get('timeRange')
        time_value = args.get('rangeValue')
        filehash = args.get('SHA256')

        if (time_range):
            if (time_value):
                service_end_date = datetime.datetime.now()
                service_start_date = get_start_time(time_range, int(time_value))
            else:
                raise 'Please enter timeRange and timeValue, or startTime and endTime'
        else:
            # parses user input to datetime object
            service_start_date = datetime.datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S")
            service_end_date = datetime.datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S")

        # transforms datetime object to epoch time
        service_start_date_epoch = int(service_start_date.strftime("%s"))
        service_end_date_epoch = int(service_end_date.strftime("%s"))

        api_query = "SELECT * FROM panw.threat WHERE filedigest='" + filehash + "' LIMIT " + value

        query_data = {
            "query": api_query,
            "startTime": service_start_date_epoch,
            "endTime": service_end_date_epoch,
        }
        pages = query_loggings(query_data)

        results = []
        table_name = None
        for page in pages:
            current_page = page.json()
            table_name = current_page['result']['esQuery']['table'][0].split('.')[1]
            table_rows = current_page['result']['esResult']['hits']['hits']

            for row in table_rows:
                row_id = row['_id']
                row_contents = row['_source']
                row_contents['id'] = row_id
                row_contents['score'] = row['_score']
                transformed_row = transform_row_keys(row_contents)
                results.append(transformed_row)

        screened_results = results_screener('threat', results)

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Logs ' + table_name + ' table',  screened_results),
            'EntryContext': {
                  'Appframework.Logging(val.id==obj.id)': results
            }
        }
        return entry

    def fetch_incidents():

        last_run = demisto.getLastRun().get('lastRun', None)
        if (last_run is not None):
            last_run = datetime.datetime.strptime(last_run, "%Y-%m-%dT%H:%M:%S")
        else:
            last_run = datetime.datetime.now() - datetime.timedelta(days=1)
        if not (demisto.params()['application']):
            raise Exception('Please enter the name of application that you want to fetch from')

        table = app_to_table(demisto.params()['application'])
        severity = severity_name_to_number(demisto.params()['severity'])

        query =  "SELECT * FROM panw.threat WHERE subtype='%s'" %table

        if (severity):
            query += " AND severity='%d'" %severity

        LOG('Fetching Palo Alto Appframeword incidents with query: %s' %query)

        service_start_date_epoch = int(last_run.strftime("%s"))
        service_end_date_epoch = int(datetime.datetime.now().strftime("%s"))

        query_data = {
            "query": query,
            "startTime": service_start_date_epoch,
            "endTime": service_end_date_epoch,
        }

        pages = query_loggings(query_data)
        incidents = []
        table_name = None

        for page in pages:
            current_page = page.json()
            page_logs = current_page['result']['esResult']['hits']['hits']

            for log in page_logs:
                incident = convert_log_to_incident(log)
                incidents.append(incident)

        demisto.setLastRun({
            'lastRun': last_run.strftime("%Y-%m-%dT%H:%M:%S")
        })
        demisto.incidents(incidents)

    ''' EXECUTION CODE '''
    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_args = {
                "query": "SELECT * FROM panw.threat LIMIT 1",
                "startTime": 0,
                "endTime": 1609459200,
            }
            if query_loggings(test_args):
                demisto.results('ok')
            else:
                demisto.results('test failed')
        elif demisto.command() == 'pan-appframework-query-logs':
            demisto.results(query_logs_command())
        elif demisto.command() == 'pan-appframework-poll-events':
            demisto.results(poll_events_command())
        elif demisto.command() == 'pan-appframework-get-critical-threat-logs':
            demisto.results(get_critical_logs_command())
        elif demisto.command() == 'pan-appframework-get-social-applications':
            demisto.results(get_social_applications_command())
        elif demisto.command() == 'pan-appframework-search-by-file-hash':
            demisto.results(search_by_file_hash_command())
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
  commands:
  - name: pan-appframework-query-logs
    arguments:
    - name: startTime
      description: Query start time. For example, startTime="2018-04-26 00:00:00"
      defaultValue: 1970-01-01 00:00:00
    - name: endTime
      default: true
      description: Query end time. For example, endTime="2018-04-26 00:00:00"
      defaultValue: 2020-01-01 00:00:00
    - name: query
      description: 'Free text SQL query. For example, query="select * from panw.traffic
        limit 5". There are multiple tables in Loggings, such as: threat, traffic.
        Refer to Appframework Logging service schema reference for the full list.
        Our documentation has more queries samples.'
      defaultValue: select * from panw.traffic limit 5
    - name: timeRange
      auto: PREDEFINED
      predefined:
      - minutes
      - days
      - weeks
      description: Time range for the query, used with rangeValue. For example, timeRange="weeks"
        timeValue="1" would run the query on the last week.
    - name: rangeValue
      description: Time value for the query,  used with timeRange. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    outputs:
    - contextPath: Appframework.Logging.id
      description: The id of the log
      type: string
    - contextPath: Appframework.Logging.score
      description: The score of the log
      type: number
    - contextPath: Appframework.Logging.action
      description: The action of the log
    - contextPath: Appframework.Logging.app
      description: The app of the log
    - contextPath: Appframework.Logging.proto
      description: The protocol used
      type: string
    - contextPath: Appframework.Logging.dst
      description: Destination ip
      type: string
    - contextPath: Appframework.Logging.rule
      description: Rule used
    - contextPath: Appframework.Logging.src
      description: The source of the action
    - contextPath: Appframework.Logging.category-of-app
      description: Application's category
      type: string
    - contextPath: Appframework.Logging.srcloc
      description: Source location
      type: string
    - contextPath: Appframework.Logging.dstloc
      description: Destination location
      type: string
    - contextPath: Appframework.Logging.characteristic-of-app
      description: Application's characteristics
    - contextPath: Appframework.Logging.device_name
      description: The name of the device
      type: string
    - contextPath: Appframework.Logging.nat
      description: Whether NAT was used or not
      type: number
    - contextPath: Appframework.Logging.natdport
      description: NAT port
    - contextPath: Appframework.Logging.natdst
      description: NAT destination
    - contextPath: Appframework.Logging.natsrc
      description: NAT source
    description: Query Appframework Logging service
  - name: pan-appframework-get-critical-threat-logs
    arguments:
    - name: startTime
      description: Query start time. For example, startTime="2018-04-26 00:00:00"
      defaultValue: 1970-01-01 00:00:00
    - name: endTime
      description: Query end time. For example, endTime="2018-04-26 00:00:00"
      defaultValue: 2020-01-01 00:00:00
    - name: logsAmount
      description: Amount of logs. Default is 10
      defaultValue: "10"
    - name: timeRange
      auto: PREDEFINED
      predefined:
      - minutes
      - days
      - weeks
      description: Time range for the query, used with rangeValue. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    - name: rangeValue
      description: Time value for the query,  used with timeRange. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    outputs:
    - contextPath: Appframework.Logging.id
      description: The id of the log
      type: string
    - contextPath: Appframework.Logging.score
      description: The score of the log
      type: number
    - contextPath: Appframework.Logging.action
      description: The action of the log
    - contextPath: Appframework.Logging.app
      description: The app of the log
    - contextPath: Appframework.Logging.proto
      description: The protocol used
      type: string
    - contextPath: Appframework.Logging.dst
      description: Destination ip
      type: string
    - contextPath: Appframework.Logging.rule
      description: Rule used
    - contextPath: Appframework.Logging.src
      description: The source of the action
    - contextPath: Appframework.Logging.category-of-app
      description: Application's category
      type: string
    - contextPath: Appframework.Logging.srcloc
      description: Source location
      type: string
    - contextPath: Appframework.Logging.dstloc
      description: Destination location
      type: string
    - contextPath: Appframework.Logging.characteristic-of-app
      description: Application's characteristics
    - contextPath: Appframework.Logging.device_name
      description: The name of the device
      type: string
    - contextPath: Appframework.Logging.nat
      description: Whether NAT was used or not
      type: number
    - contextPath: Appframework.Logging.natdport
      description: NAT port
    - contextPath: Appframework.Logging.natdst
      description: NAT destination
    - contextPath: Appframework.Logging.natsrc
      description: NAT source
    - contextPath: Appframework.Logging.risk-of-app
      description: Risk of application
    - contextPath: Appframework.Logging.type
      description: Threat type
    - contextPath: Appframework.Logging.pcad_id
      description: Pcap id
    - contextPath: Appframework.Logging.reportid
      description: Report id
      type: number
    - contextPath: Appframework.Logging.category-of-threatid
      description: Category of threat id
    - contextPath: Appframework.Logging.subtype
      description: Threat sub type
    - contextPath: Appframework.Logging.time_received
      description: Time received
    - contextPath: Appframework.Logging.pcap
      description: Pcap
    - contextPath: Appframework.Logging.name-of-threatid
      description: Name of threat id
      type: string
    - contextPath: Appframework.Logging.severity
      description: Threat Severity
    description: Query Appframework Logging service according to pre-set queries
  - name: pan-appframework-get-social-applications
    arguments:
    - name: startTime
      description: Query start time. For example, startTime="2018-04-26 00:00:00"
      defaultValue: 1970-01-01 00:00:00
    - name: endTime
      description: Query end time. For example, endTime="2018-04-26 00:00:00"
      defaultValue: 2020-01-01 00:00:00
    - name: logsAmount
      description: Amount of logs. Default is 10
      defaultValue: "10"
    - name: timeRange
      auto: PREDEFINED
      predefined:
      - minutes
      - days
      - weeks
      description: Time range for the query, used with rangeValue. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    - name: rangeValue
      description: Time value for the query,  used with timeRange. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    outputs:
    - contextPath: Appframework.Logging.id
      description: The id of the log
      type: string
    - contextPath: Appframework.Logging.score
      description: The score of the log
      type: number
    - contextPath: Appframework.Logging.action
      description: The action of the log
    - contextPath: Appframework.Logging.app
      description: The app of the log
    - contextPath: Appframework.Logging.proto
      description: The protocol used
      type: string
    - contextPath: Appframework.Logging.dst
      description: Destination ip
      type: string
    - contextPath: Appframework.Logging.rule
      description: Rule used
    - contextPath: Appframework.Logging.src
      description: The source of the action
    - contextPath: Appframework.Logging.category-of-app
      description: Application's category
      type: string
    - contextPath: Appframework.Logging.srcloc
      description: Source location
      type: string
    - contextPath: Appframework.Logging.dstloc
      description: Destination location
      type: string
    - contextPath: Appframework.Logging.characteristic-of-app
      description: Application's characteristics
    - contextPath: Appframework.Logging.device_name
      description: The name of the device
      type: string
    - contextPath: Appframework.Logging.nat
      description: Whether NAT was used or not
      type: number
    - contextPath: Appframework.Logging.natdport
      description: NAT port
    - contextPath: Appframework.Logging.natdst
      description: NAT destination
    - contextPath: Appframework.Logging.natsrc
      description: NAT source
    - contextPath: Appframework.Logging.risk-of-app
      description: Risk of application
    - contextPath: Appframework.Logging.aggregations.size
      description: Aggregations size
    - contextPath: Appframework.Logging.natsport
      description: NAT s port
    - contextPath: Appframework.Logging.start
      description: Traffic start
    - contextPath: Appframework.Logging.subcategory-of-apptime_received
      description: Sub-category of application time
    description: Query Appframework Logging service according to pre-set queries
  - name: pan-appframework-search-by-file-hash
    arguments:
    - name: startTime
      description: Query start time. For example, startTime="2018-04-26 00:00:00"
      defaultValue: 1970-01-01 00:00:00
    - name: endTime
      description: Query end time. For example, endTime="2018-04-26 00:00:00"
      defaultValue: 2020-01-01 00:00:00
    - name: logsAmount
      description: Amount of logs. Default is 10
      defaultValue: "10"
    - name: timeRange
      auto: PREDEFINED
      predefined:
      - minutes
      - days
      - weeks
      description: Time range for the query, used with rangeValue. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    - name: rangeValue
      description: Time value for the query,  used with timeRange. For example, timeRange="weeks"
        rangeValue="1" would run the query on the last week.
    - name: SHA256
      required: true
      description: File hash for the query. For example, SHA256="503ca1a4fc0d48b18c0336f544ba0f0abf305ae3a3f49b3c2b86b8645d6572dc"
        would return all logs related to this file.
    outputs:
    - contextPath: Appframework.Logging.id
      description: The id of the log
      type: string
    - contextPath: Appframework.Logging.score
      description: The score of the log
      type: number
    - contextPath: Appframework.Logging.action
      description: The action of the log
    - contextPath: Appframework.Logging.app
      description: The app of the log
    - contextPath: Appframework.Logging.proto
      description: The protocol used
      type: string
    - contextPath: Appframework.Logging.dst
      description: Destination ip
      type: string
    - contextPath: Appframework.Logging.rule
      description: Rule used
    - contextPath: Appframework.Logging.src
      description: The source of the action
    - contextPath: Appframework.Logging.category-of-app
      description: Application's category
      type: string
    - contextPath: Appframework.Logging.srcloc
      description: Source location
      type: string
    - contextPath: Appframework.Logging.dstloc
      description: Destination location
      type: string
    - contextPath: Appframework.Logging.characteristic-of-app
      description: Application's characteristics
    - contextPath: Appframework.Logging.device_name
      description: The name of the device
      type: string
    - contextPath: Appframework.Logging.nat
      description: Whether NAT was used or not
      type: number
    - contextPath: Appframework.Logging.natdport
      description: NAT port
    - contextPath: Appframework.Logging.natdst
      description: NAT destination
    - contextPath: Appframework.Logging.natsrc
      description: NAT source
    - contextPath: Appframework.Logging.risk-of-app
      description: Risk of application
    - contextPath: Appframework.Logging.type
      description: Threat type
    - contextPath: Appframework.Logging.pcad_id
      description: Pcap id
    - contextPath: Appframework.Logging.reportid
      description: Report id
      type: number
    - contextPath: Appframework.Logging.category-of-threatid
      description: Category of threat id
    - contextPath: Appframework.Logging.subtype
      description: Threat sub type
    - contextPath: Appframework.Logging.time_received
      description: Time received
    - contextPath: Appframework.Logging.pcap
      description: Pcap
    - contextPath: Appframework.Logging.name-of-threatid
      description: Name of threat id
      type: string
    - contextPath: Appframework.Logging.severity
      description: Threat Severity
    description: Query Appframework Logging service according to pre-set queries
  dockerimage: demisto/python_pancloud
  isfetch: true
  runonce: false
