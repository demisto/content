commonfields:
  id: Intezer
  version: -1
name: Intezer
display: Intezer
category: Forensics & Malware Analysis
image: data:image/png;base64,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
description: Malware detection and analysis based on code reuse
detaileddescription: |
  Intezerâ€™s cloud-based malware detection and analysis provides a fast, in-depth understanding of any file by mapping its code DNA.
  See [https://analyze.intezer.com](https://analyze.intezer.com) for creating API key and more details.
configuration:
- display: API Key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: useproxy
  defaultvalue: "true"
  type: 8
  required: false
script:
  script: |2

    import time

    import requests

    API_KEY = demisto.getParam('APIKey')
    SERVER_URL = 'https://analyze.intezer.com/api'
    API_VERSION = 'v2-0'
    IS_AVAILABLE_URL = 'is-available'
    ERROR_PREFIX = 'Error from Intezer:'
    ACCEPTABLE_HTTP_CODES = {200, 201, 202}

    http_status_to_error_massage = {
        400: '400 Bad Request - Wrong or invalid parameters',
        401: '401 Unauthorized - Wrong or invalid api key',
        403: '403 Forbidden - The account is not allowed to preform this task',
        404: '404 Not Found - Analysis was not found',
        410: '410 Gone - Analysis no longer exists in the service',
        500: '500 Internal Server Error - Internal error',
        503: '503 Service Unavailable'
    }
    dbot_score_by_verdict = {'malicious': 3,
                             'suspicious': 2,
                             'trusted': 1,
                             'neutral': 1,
                             'no_threats': 1
                             }


    def handle_response(response, acceptable_http_status_codes):
        if response.status_code not in acceptable_http_status_codes:
            raise Exception('{} {}'.format(ERROR_PREFIX, http_status_to_error_massage.get(response.status_code,
                                                                                          'Failed to perform request')))

        return response.json()


    def get_session():
        response = requests.post(SERVER_URL + '/v2-0/get-access-token', json={'api_key': API_KEY})
        response = handle_response(response, {200})
        session = requests.session()
        session.headers['Authorization'] = 'Bearer {}'.format(response['result'])

        return session


    def check_is_available():
        session = get_session()
        url = '{}/{}'.format(SERVER_URL, IS_AVAILABLE_URL)
        result = session.get(url)

        return 'ok' if result.json()['is_available'] else None


    def _get_analysis_result(result_url=None, analysis_id=None, analysis_type='File', session=None, delay=5,
                             max_retries=60):
        result_url = _get_result_url(analysis_type, result_url, analysis_id)
        session = session or get_session()
        response = session.get(result_url)
        handle_response(response, ACCEPTABLE_HTTP_CODES)
        tries = 0
        max_retries = int(max_retries)
        while response.status_code != 200 and tries < max_retries:
            tries += 1
            time.sleep(float(delay))
            response = session.get(result_url)
            handle_response(response, ACCEPTABLE_HTTP_CODES)

        if response.status_code != 200:
            raise Exception('{} {}'.format(ERROR_PREFIX, 'Failed to analyze, Try to change maxRetries or delay arguments'))

        return response.json()['result']


    def _get_result_url(analysis_type, result_url=None, analysis_id=None):
        if result_url:
            result_url = '{}/{}{}'.format(SERVER_URL, API_VERSION, result_url)
        else:
            result_url = '{}/{}/{}{}'.format(SERVER_URL, API_VERSION,
                                             'endpoint-analyses/' if analysis_type == 'Endpoint' else 'analyses/',
                                             analysis_id)

        return result_url


    def analyze_by_hash(file_hash, delay, max_retries):
        session = get_session()
        data = {'hash': file_hash}
        response = session.post(SERVER_URL + '/v2-0/analyze-by-hash', json=data)
        if response.status_code == 404:
            dbot = {
                'Vendor': 'Intezer',
                'Type': 'hash',
                'Indicator': file_hash,
                'Score': 0
            }

            demisto.results({
                'Type': entryTypes['note'],
                'EntryContext': {'DBotScore': [dbot]},
                'HumanReadable': 'Hash {} does not exist on Intezer genome database'.format(file_hash),
                'ContentsFormat': formats['json'],
                'Contents': ''
            })
            return

        elif response.status_code == 400:
            demisto.results({
                'Type': entryTypes['note'],
                'HumanReadable': 'File hash is not valid. \nIntezer file hash reputation supports only sha256, sha1 and md5 hash formats.\n',
                'ContentsFormat': formats['json'],
                'Contents': ''
            })
            return

        response = handle_response(response, ACCEPTABLE_HTTP_CODES)

        analysis_result = _get_analysis_result(result_url=response['result_url'],
                                               session=session,
                                               delay=delay,
                                               max_retries=max_retries)
        enrich_dbot_and_display_file_analysis_results(analysis_result)


    def get_analysis_result(analysis_id, analysis_type, delay, max_retries, indicator_name=None):
        result = _get_analysis_result(analysis_id=analysis_id,
                                      analysis_type=analysis_type,
                                      delay=delay,
                                      max_retries=max_retries)
        if analysis_type == 'Endpoint':
            enrich_dbot_and_display_endpoint_analysis_results(result, indicator_name)
        else:
            enrich_dbot_and_display_file_analysis_results(result)


    def analyze_by_uploaded_file(file_id, delay, max_retries):
        session = get_session()
        file_data = demisto.getFilePath(file_id)
        with open(file_data['path'], 'rb') as file_to_upload:
            files = {'file': (file_data['name'], file_to_upload)}
            response = session.post(SERVER_URL + '/v2-0/analyze', files=files)

        response = handle_response(response, ACCEPTABLE_HTTP_CODES)
        analysis_result = _get_analysis_result(result_url=response['result_url'], session=session, delay=delay,
                                               max_retries=max_retries)
        enrich_dbot_and_display_file_analysis_results(analysis_result)


    def enrich_dbot_and_display_file_analysis_results(result):
        verdict = result['verdict']
        sha256 = result['sha256']

        dbot = {
            'Vendor': 'Intezer',
            'Type': 'hash',
            'Indicator': sha256,
            'Score': dbot_score_by_verdict.get(verdict, 0)
        }

        file = {'SHA256':sha256, 'Metadata': result, 'ExistsInIntezer': True}

        if verdict == 'malicious':
            file['Malicious'] = {'Vendor': 'Intezer'}

        presentable_result = '## Intezer File analysis result\n'
        presentable_result += ' SHA256: {}\n'.format(sha256)
        presentable_result += ' Verdict: **{}** ({})\n'.format(verdict, result['sub_verdict'])
        if 'family_name' in result:
            presentable_result += 'Family: **{}**\n'.format(result['family_name'])
        presentable_result += '[Analysis Link]({})\n'.format(result['analysis_url'])

        demisto.results({
            'Type': entryTypes['note'],
            'EntryContext': {outputPaths['dbotscore']: [dbot], outputPaths['file']: [file]},
            'HumanReadable': presentable_result,
            'ContentsFormat': formats['json'],
            'Contents': result
        })


    def enrich_dbot_and_display_endpoint_analysis_results(result, indicator_name):
        verdict = result['verdict']
        computer_name = result['computer_name']

        dbot = {
            'Vendor': 'Intezer',
            'Type': 'Hostname',
            'Indicator': indicator_name if indicator_name else computer_name,
            'Score': dbot_score_by_verdict.get(verdict, 0)
        }

        endpoint = {'Metadata': result}

        presentable_result = '## Intezer Endpoint analysis result\n'
        presentable_result += 'Host Name: {}\n'.format(computer_name)
        presentable_result += ' Verdict: **{}**\n'.format(verdict)
        if 'families' in result and result['families'] != None:
            presentable_result += 'Families: **{}**\n'.format(result['families'])
        presentable_result += ' Scan Time: {}\n'.format(result['scan_start_time'])
        presentable_result += '[Analysis Link]({})\n'.format(result['analysis_url'])

        demisto.results({
            'Type': entryTypes['note'],
            'EntryContext': {'DBotScore': [dbot], 'Endpoint': [endpoint]},
            'HumanReadable': presentable_result,
            'ContentsFormat': formats['json'],
            'Contents': result
        })


    ''' EXECUTION CODE '''
    try:
        if demisto.command() == 'test-module':
            demisto.results(check_is_available())
        elif demisto.command() == 'file':
            analyze_by_hash(demisto.getArg('file'), demisto.getArg('delay'), demisto.getArg('maxRetries'))
        elif demisto.command() == 'intezer-upload':
            analyze_by_uploaded_file(demisto.getArg('fileEntryId'), demisto.getArg('delay'), demisto.getArg('maxRetries'))
        elif demisto.command() == 'intezer-get-analysis-result':
            get_analysis_result(demisto.getArg('analysisId'), demisto.getArg('analysisType'), demisto.getArg('delay'),
                                demisto.getArg('maxRetries'), demisto.getArg('indicatorName'))


    except Exception as e:
        LOG(e)
        LOG.print_log(False)
        return_error(e.message)
  type: python
  commands:
  - name: file
    arguments:
    - name: file
      required: true
      default: true
      description: Hash of the file to query. Supports SHA256, MD5 and SHA1
    - name: codeItemType
      auto: PREDEFINED
      predefined:
      - file
      - memory_module
      - fileless_code
      description: Item type - File (file), Memory Module (memory_module) or Memory
        Fileless Code (fileless_code)
      defaultValue: file
    - name: maxRetries
      description: Number of retries for polling the analysis report
      defaultValue: "60"
    - name: delay
      description: Delay in seconds between polling of analysis results
      defaultValue: "5"
    outputs:
    - contextPath: File.SHA256
      description: Hash SHA256
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.ExistsInIntezer
      description: 'File exists in Intezer genome database (in case file does not
        exist, consider upload the file) '
      type: boolean
    - contextPath: File.Metadata
      description: Metadata returned from Intezer analysis (analysis id, analysis
        url, family, family type, sha256, verdict, sub_verdict). Metedata will be
        retuned only for supported files.
      type: unknown
    description: Checks file reputation of the given hash, supports SHA256, SHA1 and
      MD5
  - name: intezer-upload
    arguments:
    - name: fileEntryId
      required: true
      default: true
      description: The file entry id to upload
    - name: codeItemType
      auto: PREDEFINED
      predefined:
      - file
      - memory_module
      - fileless_code
      description: Item type - File (file), Memory Module (memory_module) or Memory
        Fileless Code (fileless_code)
      defaultValue: file
    - name: maxRetries
      description: Number of retries for polling the analysis report
      defaultValue: "60"
    - name: delay
      description: Delay in seconds between polling of analysis results
      defaultValue: "5"
    outputs:
    - contextPath: File.SHA256
      description: Hash SHA256
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.Metadata
      description: Metadata returned from Intezer analysis (analysis id, analysis
        url, family, family type, sha256, verdict, sub_verdict). Metedata will be
        retuned only for supported files.
    description: Checks file reputation for uploaded file (up to 20MB)
  - name: intezer-get-analysis-result
    arguments:
    - name: analysisId
      required: true
      default: true
      description: The analysis ID we want to get results for
    - name: analysisType
      auto: PREDEFINED
      predefined:
      - File
      - Endpoint
      description: The type of the analysis
      defaultValue: File
    - name: maxRetries
      description: Number of retries for polling the analysis report
      defaultValue: "60"
    - name: delay
      description: Delay in seconds between polling of analysis results
      defaultValue: "5"
    - name: indicatorName
      description: indicator to classify
    outputs:
    - contextPath: File.SHA256
      description: Hash SHA256
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: File.Metadata
      description: Metadata returned from Intezer analysis (analysis id, analysis
        url, family, family type, sha256, verdict, sub_verdict). Metedata will be
        retuned only for supported files.
    - contextPath: Endpoint.Metadata
      description: Metadata returned from Intezer analysis (endpoint analysis id,
        endpoint analysis url, families,  verdict, host_name)
    description: Wait and get analysis result, support file and endpoint analysis
  dockerimage: demisto/python3:3.7.2.200
  runonce: false
