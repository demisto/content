category: Data Enrichment & Threat Intelligence
commonfields:
  id: SlashNext Phishing Incident Response
  version: -1
configuration:
- defaultvalue: https://oti.slashnext.cloud/api
  display: SlashNext API Base URL
  name: apiurl
  required: true
  type: 0
- defaultvalue: ""
  display: API Key
  name: apikey
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: SlashNext Phishing Incident Response integration allows Demisto users
  to fully automate analysis of suspicious URLs. For example, IR teams responsible
  for abuse inbox management can extract links or domains out of suspicious emails
  and automatically analyze them with the SlashNext SEER threat detection cloud to
  get definitive, binary verdicts (malicious or benign) along with IOCs, screen shots,
  and more. Automating URL analysis can save IR teams hundreds of hours versus manually
  triaging these emails or checking URLs and domains against less accurate phishing
  databases and domain reputation services.
detaileddescription: "The **SlashNext Phishing Incident Response** integration app
  enables **Demisto** users to fully automate the analysis of suspicious URLs in phishing
  emails, network logs, and more. Playbooks that require URL or Domain analysis can
  automatically analyze them with the SlashNext SEER threat detection cloud to get
  definitive, binary verdicts (malicious or benign) along with IOCs, screenshots,
  and more.\n\nSlashNext threat detection uses browsers in a purpose-built cloud to
  dynamically inspect page contents and site behavior in real-time. This method enables
  SlashNext to follow URL re-directs and multi-stage attacks to more thoroughly analyze
  the final page(s) and made a much more accurate, binary determination with near-zero
  false positives. It also detects all six major categories of phishing and social
  engineering sites. These include credential stealing, rogue software / malware sites,
  scareware, phishing exploits (sites hosting weaponized documents, etc.), and social
  engineering scams (fake deals, giveaways, etc.).\n\nUse cases include abuse inbox
  management where SOC teams can automate URL analysis in phishing emails to save
  hundreds of hours versus more manual methods. Playbooks that mine and analyze network
  logs can also leverage SlashNext URL analysis on demand.\n\nSlashNext not only provides
  accurate, binary verdicts (rather than threat scores), it provides IOC metadata
  and screen shots of detected phishing pages. These enables easier classification
  and reporting. Screen shots can be used as an aid in on-going employee phishing
  awareness training and testing.\n\nThe SlashNext Phishing Incident Response integration
  app uses an API key to authenticate with SlashNext cloud. If you don't have a valid
  API key, contact the SlashNext team: support@slashnext.com \n"
display: SlashNext Phishing Incident Response
image: data:image/png;base64,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
name: SlashNext Phishing Incident Response
script:
  commands:
  - arguments:
    - description: IPv4 address to look up in the SlashNext Threat Intelligence database.
      name: ip
      required: true
    description: Looks up an IP address indicator in the SlashNext Threat Intelligence
      database.
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: IP.Address
      description: The IP address.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision.
      type: string
    - contextPath: SlashNext.IP.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.IP.Type
      description: Type of the IoC.
      type: string
    - contextPath: SlashNext.IP.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.IP.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.IP.LastSeen
      description: Time when the IoC was last observed.
      type: date
  - arguments:
    - description: The FQDN to look up in the SlashNext Threat Intelligence database.
      name: domain
      required: true
    description: Looks up a Fully Qualified Domain Name (FQDN) indicator in the SlashNext
      Threat Intelligence database.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: Domain.Name
      description: Domain name.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domain names, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domain names, the reason that the vendor made the
        decision.
      type: string
    - contextPath: SlashNext.Domain.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.Domain.Type
      description: Type of the IoC.
      type: string
    - contextPath: SlashNext.Domain.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.Domain.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.Domain.LastSeen
      description: Time when the IoC was last observed.
      type: date
  - arguments:
    - description: The host to look up in the SlashNext Threat Intelligence database.
        Can be either a domain name or an IPv4 address.
      name: host
      required: true
    description: Queries the SlashNext Cloud database and retrieves the reputation
      of a host.
    name: slashnext-host-reputation
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: IP.Address
      description: IP address.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision.
      type: string
    - contextPath: SlashNext.IP.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.IP.Type
      description: Type of the IoC.
      type: string
    - contextPath: SlashNext.IP.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.IP.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.IP.LastSeen
      description: Time when the IoC was last observed.
      type: date
    - contextPath: Domain.Name
      description: Domain name.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domain names, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domain names, the reason that the vendor made the
        decision.
      type: string
    - contextPath: SlashNext.Domain.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.Domain.Type
      description: Type of IoC.
      type: string
    - contextPath: SlashNext.Domain.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.Domain.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.Domain.LastSeen
      description: Time when the IoC was last observed.
      type: date
  - arguments:
    - description: The host to look up in the SlashNext Threat Intelligence database.
        Can be either a domain name or an IPv4 address.
      name: host
      required: true
    description: Queries the SlashNext Cloud database and retrieves a detailed report
      for a host and associated URL.
    name: slashnext-host-report
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: IP.Address
      description: IP address.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision.
      type: string
    - contextPath: SlashNext.IP.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.IP.Type
      description: Type of the IoC.
      type: string
    - contextPath: SlashNext.IP.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.IP.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.IP.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.IP.LastSeen
      description: Time when the IoC was last observed.
      type: date
    - contextPath: Domain.Name
      description: Domain name.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domain names, the vendor that made the decision.
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domain names, the reason that the vendor made the
        decision.
      type: string
    - contextPath: SlashNext.Domain.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.Domain.Type
      description: Type of the IoC.
      type: string
    - contextPath: SlashNext.Domain.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.Domain.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.Domain.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.Domain.LastSeen
      description: Time when the IoC was last observed.
      type: date
  - arguments:
    - description: The host to look up in the SlashNext Threat Intelligence database,
        for which to return a list of associated URLs. Can be either a domain name
        or an IPv4 address.
      name: host
      required: true
    - defaultValue: "10"
      description: The maximum number of URL records to fetch. Default is "10".
      name: limit
    description: Queries the SlashNext Cloud database and retrieves a list of all
      URLs associated with the specified host.
    name: slashnext-host-urls
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: URL.Data
      description: URL reported.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
      type: string
    - contextPath: SlashNext.URL.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.URL.Type
      description: Type of IoC.
      type: string
    - contextPath: SlashNext.URL.ScanID
      description: Scan ID to be used to get the IoC forensics data for further investigation.
      type: string
    - contextPath: SlashNext.URL.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.LastSeen
      description: Time when the IoC was last observed.
      type: date
    - contextPath: SlashNext.URL.Final.Value
      description: Final IoC value (in case original IoC is a redirector to the same
        domain).
      type: string
    - contextPath: SlashNext.URL.Final.Type
      description: Type of the final IoC.
      type: string
    - contextPath: SlashNext.URL.Final.Verdict
      description: SlashNext Phishing Incident Response verdict on the final IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.Value
      description: Landing IoC value (in case original IoC is a redirector to a different
        domain).
      type: string
    - contextPath: SlashNext.URL.Landing.Type
      description: Type of landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ScanID
      description: Scan ID to be used to get the landing IoC forensics data for further
        investigation.
      type: string
    - contextPath: SlashNext.URL.Landing.Verdict
      description: SlashNext Phishing Incident Response verdict on the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatStatus
      description: Threat status of the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatName
      description: Name of the threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatType
      description: Type of threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.FirstSeen
      description: Time when the landing IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.Landing.LastSeen
      description: Time when the landing IoC was last observed.
      type: date
  - arguments:
    - description: The URL to scan.
      name: url
      required: true
    - defaultValue: "false"
      description: Whether to download forensics data, such as screenshot, HTML, and
        rendered text. If "true", forensics data will be returned. If "false" (or
        empty) forensics data will not be returned. Default is "false".
      name: extended_info
    description: Performs a real-time URL reputation scan with SlashNext cloud-based
      SEER Engine. If the specified URL already exists in the cloud database, scan
      results will be returned immediately. If not, this command will submit a URL
      scan request and return with the message "check back later" and include a unique
      Scan ID. You can check the results of this scan using the "slashnext-scan-report"
      command anytime after 60 seconds using the returned Scan ID.
    name: slashnext-url-scan
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: URL.Data
      description: URL reported.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
      type: string
    - contextPath: SlashNext.URL.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.URL.Type
      description: Type of IoC.
      type: string
    - contextPath: SlashNext.URL.ScanID
      description: Scan ID to be used to get the IoC forensics data for further investigation.
      type: string
    - contextPath: SlashNext.URL.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.LastSeen
      description: Time when the IoC was last observed.
      type: date
    - contextPath: SlashNext.URL.Final.Value
      description: Final IoC value (in case original IoC is a redirector to the same
        domain).
      type: string
    - contextPath: SlashNext.URL.Final.Type
      description: Type of the final IoC.
      type: string
    - contextPath: SlashNext.URL.Final.Verdict
      description: SlashNext Phishing Incident Response verdict on the final IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.Value
      description: Landing IoC value (in case original IoC is a redirector to a different
        domain).
      type: string
    - contextPath: SlashNext.URL.Landing.Type
      description: Type of landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ScanID
      description: Scan ID to be used to get the landing IoC forensics data for further
        investigation.
      type: string
    - contextPath: SlashNext.URL.Landing.Verdict
      description: SlashNext Phishing Incident Response verdict on the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatStatus
      description: Threat status of the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatName
      description: Name of the threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatType
      description: Type of the threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.FirstSeen
      description: Time when the landing IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.Landing.LastSeen
      description: Time when the landing IoC was last observed.
      type: date
  - arguments:
    - description: The URL to scan.
      name: url
      required: true
    - defaultValue: "60"
      description: A timeout value in seconds. If the system is unable to complete
        a scan within the specified timeout, a timeout error will be returned. You
        can run the command again with a different timeout. If no timeout value is
        specified, a default timeout value is 60 seconds.
      name: timeout
    - defaultValue: "false"
      description: Whether to download forensics data, such as screenshot, HTML, and
        rendered text. If "true", forensics data will be returned. If "false" (or
        empty) forensics data will not be returned. Default is "false".
      name: extended_info
    description: Performs a real-time URL scan with SlashNext cloud-based SEER Engine
      in a blocking mode. If the specified URL already exists in the cloud database,
      scan result will be returned immediately. If not, this command will submit a
      URL scan request and wait for the scan to finish. The scan may take up to 60
      seconds to finish.
    name: slashnext-url-scan-sync
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: URL.Data
      description: URL reported.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
      type: string
    - contextPath: SlashNext.URL.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.URL.Type
      description: Type of IoC.
      type: string
    - contextPath: SlashNext.URL.ScanID
      description: Scan ID to be used to get the IoC forensics data for further investigation.
      type: string
    - contextPath: SlashNext.URL.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.LastSeen
      description: Time when the IoC was last observed.
      type: date
    - contextPath: SlashNext.URL.Final.Value
      description: Final IoC value (in case original IoC is a redirector to the same
        domain).
      type: string
    - contextPath: SlashNext.URL.Final.Type
      description: Type of the final IoC.
      type: string
    - contextPath: SlashNext.URL.Final.Verdict
      description: SlashNext Phishing Incident Response verdict on the final IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.Value
      description: Landing IoC value (in case original IoC is a redirector to a different
        domain).
      type: string
    - contextPath: SlashNext.URL.Landing.Type
      description: Type of landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ScanID
      description: Scan ID to be used to get the landing IoC forensics data for further
        investigation.
      type: string
    - contextPath: SlashNext.URL.Landing.Verdict
      description: SlashNext Phishing Incident Response verdict on the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatStatus
      description: Threat status of the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatName
      description: Name of the threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatType
      description: Type of threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.FirstSeen
      description: Time when the landing IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.Landing.LastSeen
      description: Time when the landing IoC was last observed.
      type: date
  - arguments:
    - description: Scan ID of the scan for which to get the report. Can be retrieved
        from the "slashnext-url-scan" command or "slashnext-url-scan-sync" command.
      name: scanid
      required: true
    - defaultValue: "false"
      description: Whether to download forensics data, such as screenshot, HTML, and
        rendered text. If "true", forensics data will be returned. If "false" (or
        empty) forensics data will not be returned. Default is "false".
      name: extended_info
    description: Retrieves the results of a URL scan against a previous scan request.
      If the scan is finished, results will be returned immediately; otherwise the
      message "check back later" will be returned.
    name: slashnext-scan-report
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: Indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: URL.Data
      description: URL reported.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
      type: string
    - contextPath: SlashNext.URL.Value
      description: Value of the IoC.
      type: string
    - contextPath: SlashNext.URL.Type
      description: Type of IoC.
      type: string
    - contextPath: SlashNext.URL.ScanID
      description: Scan ID to be used to get the IoC forensics data for further investigation.
      type: string
    - contextPath: SlashNext.URL.Verdict
      description: SlashNext Phishing Incident Response verdict on the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatStatus
      description: Threat status of the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatName
      description: Name of the threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.ThreatType
      description: Type of threat posed by the IoC.
      type: string
    - contextPath: SlashNext.URL.FirstSeen
      description: Time when the IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.LastSeen
      description: Time when the IoC was last observed.
      type: date
    - contextPath: SlashNext.URL.Final.Value
      description: Final IoC value (in case original IoC is a redirector to same the
        domain).
      type: string
    - contextPath: SlashNext.URL.Final.Type
      description: Type of the final IoC.
      type: string
    - contextPath: SlashNext.URL.Final.Verdict
      description: SlashNext Phishing Incident Response verdict on the final IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.Value
      description: Landing IoC value (in case original IoC is a redirector to a different
        domain).
      type: string
    - contextPath: SlashNext.URL.Landing.Type
      description: Type of landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ScanID
      description: Scan ID to be used to get the landing IoC forensics data for further
        investigation.
      type: string
    - contextPath: SlashNext.URL.Landing.Verdict
      description: SlashNext Phishing Incident Response verdict on the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatStatus
      description: Threat status of the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatName
      description: Name of the threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.ThreatType
      description: Type of threat posed by the landing IoC.
      type: string
    - contextPath: SlashNext.URL.Landing.FirstSeen
      description: Time when the landing IoC was first observed.
      type: date
    - contextPath: SlashNext.URL.Landing.LastSeen
      description: Time when the landing IoC was last observed.
      type: date
  - arguments:
    - description: Scan ID. Can be retrieved from the "slashnext-url-scan" command
        or the "slashnext-url-scan-sync" command.
      name: scanid
      required: true
    - defaultValue: high
      description: Resolution of the web page screenshot. Can be "high" or "medium".
        Default is "high".
      name: resolution
    description: Downloads a screenshot of a web page against a previous URL scan
      request.
    name: slashnext-download-screenshot
  - arguments:
    - description: Scan ID. Can be retrieved from the "slashnext-url-scan" command
        or the "slashnext-url-scan-sync" command.
      name: scanid
      required: true
    description: Downloads a web page HTML against a previous URL scan request.
    name: slashnext-download-html
  - arguments:
    - description: Scan ID. Can be retrieved from the "slashnext-url-scan" command
        or the "slashnext-url-scan-sync" command.
      name: scanid
      required: true
    description: Downloads the text of a web page against a previous URL scan request.
    name: slashnext-download-text
  dockerimage: demisto/python3:3.7.3.260
  runonce: false
  script: |2-



    ''' IMPORTS '''
    from typing import List, Dict
    import requests
    import base64

    requests.packages.urllib3.disable_warnings()

    """
    Created on August 1, 2019

    @author: Saadat Abid
    """


    ''' GLOBAL VARS '''
    AUTH_KEY = demisto.params().get('apikey')
    BASE_API = demisto.params().get('apiurl', 'https://oti.slashnext.cloud/api')
    if BASE_API.endswith('/'):
        BASE_API = BASE_API.strip('/')
    VERIFY = not demisto.params().get('unsecure', False)

    HOST_REPUTE_API = '/oti/v1/host/reputation'
    URL_SCAN_API = '/oti/v1/url/scan'
    URL_SCANSYNC_API = '/oti/v1/url/scansync'
    HOST_REPORT_API = '/oti/v1/host/report'
    DL_SC_API = '/oti/v1/download/screenshot'
    DL_HTML_API = '/oti/v1/download/html'
    DL_TEXT_API = '/oti/v1/download/text'


    ''' HELPERS FUNCTIONS '''


    @logger
    def http_request(endpoint, data, method='POST'):
        """
        Make the http request to SlashNext cloud API endpoint with the given API args
        :param endpoint: Corresponds to SlashNext cloud API to be invoked
        :param data: Parameter dictionary as part of data
        :param method: HTTP method to be used for API i.e. GET or POST
        :return: Response of the SlashNext web API in json format
        """
        url = BASE_API + endpoint
        data['authkey'] = AUTH_KEY

        response = requests.request(method, url=url, data=data, timeout=300, verify=VERIFY)
        if response.status_code == 200:
            try:
                return response.json()
            except Exception as e:
                return_error('Response JSON decoding failed due to {}'.format(str(e)))

        else:
            return_error('API Returned, {}:{}'.format(response.status_code, response.reason))


    def get_dbot_score(verdict):
        """
        Evaluate the dbot (Demisto) score as per verdict from SlashNext cloud API
        :param verdict: SlashNext verdict on a certain IoC
        :return: Dbot score
        """
        if verdict == 'Malicious':
            return 3
        elif verdict == 'Suspicious':
            return 2
        elif verdict == 'Benign' or verdict == 'Redirector':
            return 1
        else:
            return 0


    def get_dbot_std_context(indicator, ioc_type, verdict, threat_type):
        """
        Makes the dictionary for dbot score and standard Demisto contexts
        :param indicator: IoC value
        :param ioc_type: IoC type, ip, domain or url
        :param verdict: Verdict by SlashNext OTI cloud
        :param threat_type: Threat type reported by SlashNext OTI cloud
        :return: Dbot score context dictionary, dbot standard context dictionary
        """
        dbot_score = get_dbot_score(verdict)

        dbot_score_cont = {
            'Indicator': indicator,
            'Type': ioc_type.lower(),
            'Vendor': 'SlashNext Phishing Incident Response',
            'Score': dbot_score
        }

        if ioc_type.lower() == 'ip':
            standard_cont = {
                'Address': indicator
            }
        elif ioc_type.lower() == 'domain':
            standard_cont = {
                'Name': indicator
            }
        else:
            standard_cont = {
                'Data': indicator
            }

        if dbot_score == 3:
            standard_cont['Malicious'] = {
                'Vendor': 'SlashNext Phishing Incident Response',
                'Description': 'Detected "{}" Activity'.format(threat_type)
            }

        return dbot_score_cont, standard_cont


    def get_snx_host_ioc_context(indicator, ioc_type, threat_data):
        """
        Make the dictionary for SlashNext IoC contexts for hosts
        :param indicator: IoC value
        :param ioc_type: IoC type
        :param threat_data: Threat data by SlashNext OTI cloud
        :return: SlashNext IoC context dictionary
        """
        snx_ioc_cont = {
            'Value': indicator,
            'Type': ioc_type,
            'Verdict': threat_data.get('verdict'),
            'ThreatStatus': threat_data.get('threatStatus'),
            'ThreatType': threat_data.get('threatType'),
            'ThreatName': threat_data.get('threatName'),
            'FirstSeen': threat_data.get('firstSeen'),
            'LastSeen': threat_data.get('lastSeen')
        }

        return snx_ioc_cont


    def get_snx_url_ioc_context(url_data, is_scan=False):
        """
        Make the dictionary for SlashNext URL IoC contexts for URLs
        :param url_data: URL data received in json format
        :param is_scan: Is Scan ID to be included
        :return: List of SlashNext IoC context dictionaries, Entry context dictionary
        """
        snx_ioc_cont_list = []
        dbot_score_cont_list = []
        url_cont_list = []

        url_threat_data = url_data.get('threatData')
        snx_ioc_cont = {
            'Value': url_data.get('url'),
            'Type': 'Scanned URL',
            'Verdict': url_threat_data.get('verdict'),
            'ThreatStatus': url_threat_data.get('threatStatus'),
            'ThreatType': url_threat_data.get('threatType'),
            'ThreatName': url_threat_data.get('threatName'),
            'FirstSeen': url_threat_data.get('firstSeen'),
            'LastSeen': url_threat_data.get('lastSeen')
        }
        if is_scan is True:
            snx_ioc_cont['ScanID'] = url_data.get('scanId')

        dbot_score_cont, url_cont = get_dbot_std_context(
            url_data.get('url'), 'url',
            url_threat_data.get('verdict'),
            url_threat_data.get('threatType'))
        dbot_score_cont_list.append(dbot_score_cont)
        if url_cont is not None:
            url_cont_list.append(url_cont)

        if url_data.get('landingUrl') is None:
            if url_data.get('finalUrl') is not None and url_data.get('finalUrl') != 'N/A':
                dbot_final_score_cont, final_url_cont = get_dbot_std_context(
                    url_data.get('finalUrl'), 'url',
                    url_threat_data.get('verdict'),
                    url_threat_data.get('threatType'))
                dbot_score_cont_list.append(dbot_final_score_cont)
                if final_url_cont is not None:
                    url_cont_list.append(final_url_cont)

                snx_final_ioc_cont = {
                    'Value': url_data.get('finalUrl'),
                    'Type': 'Final URL',
                    'Verdict': url_threat_data.get('verdict')
                }

                snx_ioc_cont['Final'] = snx_final_ioc_cont.copy()
                snx_ioc_cont_list.append(snx_ioc_cont)

                snx_final_ioc_cont['Value'] = '--------> {}'.format(url_data.get('finalUrl'))
                snx_ioc_cont_list.append(snx_final_ioc_cont)

            else:
                snx_ioc_cont_list.append(snx_ioc_cont)

        else:
            landing = url_data.get('landingUrl')
            landing_threat_data = landing.get('threatData')

            dbot_landing_score_cont, landing_url_cont = get_dbot_std_context(
                landing.get('url'), 'url',
                landing_threat_data.get('verdict'),
                landing_threat_data.get('threatType'))
            dbot_score_cont_list.append(dbot_landing_score_cont)
            if landing_url_cont is not None:
                url_cont_list.append(landing_url_cont)

            snx_landing_ioc_cont = {
                'Value': landing.get('url'),
                'Type': 'Redirected URL',
                'Verdict': landing_threat_data.get('verdict'),
                'ThreatStatus': landing_threat_data.get('threatStatus'),
                'ThreatType': landing_threat_data.get('threatType'),
                'ThreatName': landing_threat_data.get('threatName'),
                'FirstSeen': landing_threat_data.get('firstSeen'),
                'LastSeen': landing_threat_data.get('lastSeen')
            }
            if is_scan is True:
                snx_landing_ioc_cont['ScanID'] = landing.get('scanId')

            snx_ioc_cont['Landing'] = snx_landing_ioc_cont.copy()
            snx_ioc_cont_list.append(snx_ioc_cont)

            snx_landing_ioc_cont['Value'] = '--------> {}'.format(landing.get('url'))
            snx_ioc_cont_list.append(snx_landing_ioc_cont)

        return snx_ioc_cont_list, dbot_score_cont_list, url_cont_list


    def download_forensics_data(scanid, tag, screenshot=False, html=False, txt=False):
        """
        Download the selected forensics data from SlashNext cloud
        :param scanid: Scan ID for which foresics data to download
        :param tag: String to tag the corresponding forensics data file
        :param screenshot: Holds true if screenshot is to be downloaded
        :param html: Holds true if the HTML is to be downloaded
        :param txt: Holds true if the text is to be downloaded
        :return: None
        """
        error_no = 0
        error_msg = 'Success'
        show_error_msg = True
        if screenshot is True:
            # Host Screenshot Section
            api_data = {
                'scanid': scanid,
                'resolution': 'medium'
            }
            response = http_request(endpoint=DL_SC_API, data=api_data)

            if response.get('errorNo') != 0:
                error_no = response.get('errorNo')
                error_msg = response.get('errorMsg')
            else:
                show_error_msg = False

                sc_base64 = response.get('scData').get('scBase64')
                sc_data = base64.b64decode(sc_base64)

                sc_file = fileResult('slashnext_{}.jpg'.format(scanid), sc_data, entryTypes['image'])

                demisto.results({
                    'Type': entryTypes['image'],
                    'ContentsFormat': formats['text'],
                    'Contents': 'Forensics: Webpage Screenshot for the ' + tag,
                    'File': sc_file.get('File'),
                    'FileID': sc_file.get('FileID')
                })

        if html is True:
            # Host HTML Section
            api_data = {
                'scanid': scanid
            }
            response = http_request(endpoint=DL_HTML_API, data=api_data)

            if response.get('errorNo') == 0:
                show_error_msg = False

                html_base64 = response.get('htmlData').get('htmlBase64')
                html_data = base64.b64decode(html_base64)

                html_file = fileResult('slashnext_{}.html'.format(scanid), html_data, entryTypes['file'])

                demisto.results({
                    'Type': entryTypes['file'],
                    'ContentsFormat': formats['text'],
                    'Contents': 'Forensics: Webpage HTML for the ' + tag,
                    'File': html_file.get('File'),
                    'FileID': html_file.get('FileID')
                })

        if txt is True:
            # Host Text Section
            api_data = {
                'scanid': scanid
            }
            response = http_request(endpoint=DL_TEXT_API, data=api_data)

            if response.get('errorNo') == 0:
                show_error_msg = False

                text_base64 = response.get('textData').get('textBase64')
                text_data = base64.b64decode(text_base64)

                text_file = fileResult('slashnext_{}.txt'.format(scanid), text_data, entryTypes['file'])

                demisto.results({
                    'Type': entryTypes['file'],
                    'ContentsFormat': formats['text'],
                    'Contents': 'Forensics: Webpage Rendered Text for the ' + tag,
                    'File': text_file.get('File'),
                    'FileID': text_file.get('FileID')
                })

        # Show Error Message
        if show_error_msg is True and (screenshot is True or html is True or txt is True):
            demisto.results('API Returned, {}:{}'.format(error_no, error_msg))


    ''' COMMAND FUNCTIONS '''


    def validate_snx_api_key():
        """
        Validate the provided SlashNext cloud API key and test connection, in case of any error exit the program
        @:return: None
        """
        api_data = {
            'host': 'www.google.com'
        }
        response = http_request(endpoint=HOST_REPUTE_API, data=api_data)

        if response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return 'ok'


    def ip_lookup(ip):
        """
        Execute SlashNext's host/reputation API against the requested IP address with the given parameters
        :param ip: IP address whose reputation needs to be fetched
        :return: Response of the SlashNext host/reputation API
        """
        # Create the required data dictionary for Host/Reputation
        api_data = {
            'host': ip
        }
        response = http_request(endpoint=HOST_REPUTE_API, data=api_data)

        if response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def ip_command():
        """
        Execute SlashNext's host/reputation API against the requested IP reputation command with the given parameters
        @:return: None
        """
        # 1. Get input host from Demisto
        ip = demisto.args().get('ip')
        if not is_ip_valid(ip):
            return_error('Invalid IP address, Please retry with a valid IP address')
        # 2. Get the host reputation from SlashNext API
        response = ip_lookup(ip=ip)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        dbot_score_cont, ip_cont = get_dbot_std_context(
            ip, 'IP', response.get('threatData').get('verdict'), response.get('threatData').get('threatType'))

        snx_ioc_cont = get_snx_host_ioc_context(ip, 'IP', response.get('threatData'))

        ec = {
            'SlashNext.IP(val.Value === obj.Value)': snx_ioc_cont,
            'DBotScore': dbot_score_cont,
            'IP': ip_cont
        }

        title = 'SlashNext Phishing Incident Response - IP Lookup\n' \
                '##### ip = {}'.format(ip)

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)


    def domain_lookup(domain):
        """
        Execute SlashNext's host/reputation API against the requested domain with the given parameters
        :param domain: Domain whose reputation needs to be fetched
        :return: Response of the SlashNext host/reputation API
        """
        # Create the required data dictionary for Host/Reputation
        api_data = {
            'host': domain
        }
        response = http_request(endpoint=HOST_REPUTE_API, data=api_data)

        if response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def domain_command():
        """
        Execute SlashNext's host/reputation API against the requested domain reputation command with the given parameters
        @:return: None
        """
        # 1. Get input host from Demisto
        domain = demisto.args().get('domain')
        # 2. Get the host reputation from SlashNext API
        response = domain_lookup(domain=domain)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        dbot_score_cont, domain_cont = get_dbot_std_context(
            domain, 'Domain', response.get('threatData').get('verdict'), response.get('threatData').get('threatType'))

        snx_ioc_cont = get_snx_host_ioc_context(domain, 'Domain', response.get('threatData'))

        ec = {
            'SlashNext.Domain(val.Value === obj.Value)': snx_ioc_cont,
            'DBotScore': dbot_score_cont,
            'Domain': domain_cont
        }

        domain = domain.encode('idna')

        title = 'SlashNext Phishing Incident Response - Domain Lookup\n' \
                '##### domain = {}'.format(domain.decode())

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)


    def host_reputation(host):
        """
        Execute SlashNext's host/reputation API against the requested host with the given parameters
        :param host: Host whose reputation needs to be fetched
        :return: Response of the SlashNext host/reputation API
        """
        # Create the required data dictionary for Host/Reputation
        api_data = {
            'host': host
        }
        response = http_request(endpoint=HOST_REPUTE_API, data=api_data)

        if response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def host_reputation_command():
        """
        Execute SlashNext's host/reputation API against the requested host reputation command with the given parameters
        @:return: None
        """
        # 1. Get input host from Demisto
        host = demisto.args().get('host')
        # 2. Get the host reputation from SlashNext API
        response = host_reputation(host=host)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        ioc_type = 'IP' if is_ip_valid(host) else 'Domain'

        dbot_score_cont, host_cont = get_dbot_std_context(
            host, ioc_type, response.get('threatData').get('verdict'), response.get('threatData').get('threatType'))

        snx_ioc_cont = get_snx_host_ioc_context(host, ioc_type, response.get('threatData'))

        ec = {
            'SlashNext.{}(val.Value === obj.Value)'.format(ioc_type): snx_ioc_cont,
            'DBotScore': dbot_score_cont,
            ioc_type: host_cont
        }

        host = host.encode('idna')

        title = 'SlashNext Phishing Incident Response - Host Reputation\n' \
                '##### host = {}'.format(host.decode())

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)


    def host_report_command():
        """
        Execute SlashNext's host/reputation, host/report, url/scansync, download/screenshot, download/html and download/text
        APIs against the requested host report command with given parameters
        @:return: None
        """
        # 1. Get input host from Demisto
        host = demisto.args().get('host')
        # 2(i). Get the host reputation from SlashNext API
        response = host_reputation(host=host)
        if response.get('errorNo') != 0:
            return
        # 3(i). Parse and format the response
        ioc_type = 'IP' if is_ip_valid(host) else 'Domain'

        dbot_score_cont, host_cont = get_dbot_std_context(
            host, ioc_type, response.get('threatData').get('verdict'), response.get('threatData').get('threatType'))

        snx_ioc_cont = get_snx_host_ioc_context(host, ioc_type, response.get('threatData'))

        ec = {
            'SlashNext.{}(val.Value === obj.Value)'.format(ioc_type): snx_ioc_cont,
            'DBotScore': dbot_score_cont,
            ioc_type: host_cont
        }

        enc_host = host.encode('idna')

        title = 'SlashNext Phishing Incident Response - Host Report\n'\
                '##### host = {}'.format(enc_host.decode())

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)

        # In case host is Unrated, the command execution is completed else continue with host report
        if response.get('threatData').get('verdict').startswith('Unrated'):
            return

        # 2(ii). Get the host report from SlashNext API
        response = host_urls(host=host, limit=1)
        if response.get('errorNo') != 0:
            return
        # 3(ii). Parse and format the response
        url_data = response.get('urlDataList')[0]
        scanid = url_data.get('scanId')

        if scanid == 'N/A':
            # 2(iii). Get the url scan sync from SlashNext API
            response = url_scan_sync(url=url_data.get('url'), timeout=60)
            if response.get('errorNo') != 0:
                return
            # 3(iii). Parse and format the response
            url_data = response.get('urlData')
            scanid = url_data.get('scanId')

            snx_ioc_cont, dbot_score_cont, url_cont = get_snx_url_ioc_context(url_data, is_scan=True)
        else:
            snx_ioc_cont, dbot_score_cont, url_cont = get_snx_url_ioc_context(url_data, is_scan=True)

        ec = {
            'SlashNext.URL(val.Value === obj.Value)': snx_ioc_cont[0],
            'DBotScore': dbot_score_cont,
            'URL': url_cont
        }

        enc_host = host.encode('idna')

        title = 'SlashNext Phishing Incident Response - Latest Scanned URL\n' \
                '##### host = {}'.format(enc_host.decode())

        if response.get('normalizeData').get('normalizeStatus') == 1:
            title += ' *\n*' + response.get('normalizeData').get('normalizeMessage')

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ScanID',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)

        # Download Screenshot, HTML and Text Section
        if url_data.get('landingUrl') is None:
            if url_data.get('finalUrl') is not None and url_data.get('finalUrl') != 'N/A':
                tag = 'Final URL = {}'.format(url_data.get('finalUrl'))
            else:
                tag = 'Scanned URL = {}'.format(url_data.get('url'))
        else:
            tag = 'Redirected URL = {}'.format(url_data.get('landingUrl').get('url'))

        if response.get('swlData') is None:
            download_forensics_data(scanid=scanid, tag=tag, screenshot=True, html=True, txt=True)


    def host_urls(host, limit):
        """
        Execute SlashNext's host/report API against the requested host urls with the given parameters
        :param host: Host whose related/associated URLs to be fetched
        :param limit: Number of related URLs to be fetched
        :return: Response of the SlashNext host/report API
        """
        # Create the required data dictionary for Host/Report
        api_data = {
            'host': host,
            'page': 1,
            'rpp': limit
        }
        response = http_request(endpoint=HOST_REPORT_API, data=api_data)

        if response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def host_urls_command():
        """
        Execute SlashNext's host/report API against the requested host urls command with the given parameters
        @:return: None
        """
        # 1. Get input host and limit from Demisto
        host = demisto.args().get('host')
        limit = demisto.args().get('limit')
        # 2. Get the host report from SlashNext API
        response = host_urls(host=host, limit=limit)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        snx_ioc_cont_list = []       # type: List[Dict[str, str]]
        dbot_score_cont_list = []    # type: List[Dict[str, str]]
        url_cont_list = []           # type: List[Dict[str, str]]
        snx_ec_cont_list = []        # type: List[Dict[str, str]]
        for url_data in response.get('urlDataList'):
            if url_data.get('threatData').get('verdict').startswith('Unrated') is False:
                snx_ioc_cont, dbot_score_cont, url_cont = get_snx_url_ioc_context(url_data, is_scan=True)
                snx_ioc_cont_list.extend(snx_ioc_cont)
                dbot_score_cont_list.extend(dbot_score_cont)
                url_cont_list.extend(url_cont)
                snx_ec_cont_list.append(snx_ioc_cont[0])

        ec = {}    # type: Dict[str, List[Dict[str, str]]]
        if response.get('urlDataList')[0].get('threatData').get('verdict').startswith('Unrated') is False:
            ec = {
                'SlashNext.URL(val.Value === obj.Value)': snx_ec_cont_list,
                'DBotScore': dbot_score_cont_list,
                'URL': url_cont_list
            }

        host = host.encode('idna')

        title = 'SlashNext Phishing Incident Response - Host URLs\n' \
                '##### host = {}'.format(host.decode())

        if response.get('normalizeData').get('normalizeStatus') == 1:
            title += ' *\n*' + response.get('normalizeData').get('normalizeMessage')

        md = tableToMarkdown(
            title,
            snx_ioc_cont_list,
            ['Value',
             'Type',
             'Verdict',
             'ScanID',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont_list)


    def url_scan(url):
        """
        Execute SlashNext's url/scan API against the requested URL scan with the given parameters
        :param url: URL to be scanned
        :return: Response of the SlashNext url/scan API
        """
        # Create the required data dictionary for URL/Scan
        api_data = {
            'url': url
        }
        response = http_request(endpoint=URL_SCAN_API, data=api_data)

        if response.get('errorNo') == 1:
            url_threat_data = response.get('urlData').get('threatData')
            snx_ioc_cont = {
                'Value': url,
                'Type': 'Scanned URL',
                'Verdict': url_threat_data.get('verdict'),
                'ThreatStatus': url_threat_data.get('threatStatus'),
                'ThreatType': url_threat_data.get('threatType'),
                'ThreatName': url_threat_data.get('threatName'),
                'FirstSeen': url_threat_data.get('firstSeen'),
                'LastSeen': url_threat_data.get('lastSeen'),
                'ScanID': response.get('urlData').get('scanId')
            }
            ec = {
                'SlashNext.URL(val.Value === obj.Value)': snx_ioc_cont
            }
            md = '### SlashNext Phishing Incident Response - URL Scan\n' \
                 '##### url = {}\n' \
                 'Your Url Scan request is submitted to the cloud and may take up-to 60 seconds to complete.\n'\
                 'Please check back later using "slashnext-scan-report" command with Scan ID = {} or running the same ' \
                 '"slashnext-url-scan" command one more time.'.format(url, response.get('urlData').get('scanId'))
            return_outputs(md, ec, response)
        elif response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def url_scan_command():
        """
        Execute SlashNext's URL/scan API against the requested URL scan command with the given parameters
        @:return: None
        """
        # 1. Get input url and extended_info from Demisto
        url = demisto.args().get('url')
        extended_info = demisto.args().get('extended_info')
        # 2. Get the url scan from SlashNext API
        response = url_scan(url=url)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        url_data = response.get('urlData')
        scanid = url_data.get('scanId')

        snx_ioc_cont, dbot_score_cont, url_cont = get_snx_url_ioc_context(url_data, is_scan=True)

        ec = {
            'SlashNext.URL(val.Value === obj.Value)': snx_ioc_cont[0],
            'DBotScore': dbot_score_cont,
            'URL': url_cont
        }

        title = 'SlashNext Phishing Incident Response - URL Scan\n'\
                '##### url = {}'.format(url_data.get('url'))

        if response.get('normalizeData').get('normalizeStatus') == 1:
            title += ' *\n*' + response.get('normalizeData').get('normalizeMessage')

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ScanID',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)

        if extended_info == 'true' and response.get('swlData') is None:
            # Download Screenshot, HTML and Text Section
            if url_data.get('landingUrl') is None:
                if url_data.get('finalUrl') is not None and url_data.get('finalUrl') != 'N/A':
                    tag = 'Final URL = {}'.format(url_data.get('finalUrl'))
                else:
                    tag = 'Scanned URL = {}'.format(url_data.get('url'))
            else:
                tag = 'Redirected URL = {}'.format(url_data.get('landingUrl').get('url'))

            download_forensics_data(scanid=scanid, tag=tag, screenshot=True, html=True, txt=True)


    def url_scan_sync(url, timeout):
        """
        Execute SlashNext's url/scansync API against the requested URL scan sync with the given parameters
        :param url: URL to be scanned
        :param timeout: Timeout value in seconds
        :return: Response of the SlashNext url/scansync API
        """
        # Create the required data dictionary for URL/ScanSync
        api_data = {
            'url': url,
            'timeout': timeout
        }
        response = http_request(endpoint=URL_SCANSYNC_API, data=api_data)

        if response.get('errorNo') == 1:
            url_threat_data = response.get('urlData').get('threatData')
            snx_ioc_cont = {
                'Value': url,
                'Type': 'Scanned URL',
                'Verdict': url_threat_data.get('verdict'),
                'ThreatStatus': url_threat_data.get('threatStatus'),
                'ThreatType': url_threat_data.get('threatType'),
                'ThreatName': url_threat_data.get('threatName'),
                'FirstSeen': url_threat_data.get('firstSeen'),
                'LastSeen': url_threat_data.get('lastSeen'),
                'ScanID': response.get('urlData').get('scanId')
            }
            ec = {
                'SlashNext.URL(val.Value === obj.Value)': snx_ioc_cont
            }
            md = '### SlashNext Phishing Incident Response - URL Scan Sync\n' \
                 '##### url = {}\n' \
                 'Your Url Scan request is submitted to the cloud and is taking longer than expected to complete.\n' \
                 'Please check back later using "slashnext-scan-report" command with Scan ID = {} or running the same ' \
                 '"slashnext-url-scan-sync" command one more time.'.format(url, response.get('urlData').get('scanId'))
            return_outputs(md, ec, response)
        elif response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def url_scan_sync_command():
        """
        Execute SlashNext's url/scansync API against the requested URL scan sync command with the given parameters
        @:return: None
        """
        # 1. Get input url, extended_info and timeout from Demisto
        url = demisto.args().get('url')
        timeout = demisto.args().get('timeout')
        extended_info = demisto.args().get('extended_info')
        # 2. Get the url scan sync from SlashNext API
        response = url_scan_sync(url=url, timeout=timeout)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        url_data = response.get('urlData')
        scanid = url_data.get('scanId')

        snx_ioc_cont, dbot_score_cont, url_cont = get_snx_url_ioc_context(url_data, is_scan=True)

        ec = {
            'SlashNext.URL(val.Value === obj.Value)': snx_ioc_cont[0],
            'DBotScore': dbot_score_cont,
            'URL': url_cont
        }

        title = 'SlashNext Phishing Incident Response - URL Scan Sync\n'\
                '##### url = {}'.format(url_data.get('url'))

        if response.get('normalizeData').get('normalizeStatus') == 1:
            title += ' *\n*' + response.get('normalizeData').get('normalizeMessage')

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ScanID',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)

        if extended_info == 'true' and response.get('swlData') is None:
            # Download Screenshot, HTML and Text Section
            if url_data.get('landingUrl') is None:
                if url_data.get('finalUrl') is not None and url_data.get('finalUrl') != 'N/A':
                    tag = 'Final URL = {}'.format(url_data.get('finalUrl'))
                else:
                    tag = 'Scanned URL = {}'.format(url_data.get('url'))
            else:
                tag = 'Redirected URL = {}'.format(url_data.get('landingUrl').get('url'))

            download_forensics_data(scanid=scanid, tag=tag, screenshot=True, html=True, txt=True)


    def scan_report(scanid):
        """
        Execute SlashNext's url/scan API against the already requested URL scan with the given parameters
        :param scanid: Scan ID returned by a SlashNext API earlier as a result of a scan request
        :return: Response of the SlashNext url/scan API
        """
        # Create the required data dictionary for URL/Scan
        api_data = {
            'scanid': scanid
        }
        response = http_request(endpoint=URL_SCAN_API, data=api_data)

        if response.get('errorNo') == 1:
            md = '### SlashNext Phishing Incident Response - Scan Report\n' \
                 '##### scanid = {}\n' \
                 'Your Url Scan request is submitted to the cloud and may take up-to 60 seconds to complete.\n' \
                 'Please check back later using "slashnext-scan-report" command with Scan ID = {}'.format(scanid, scanid)

            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['text'],
                'Contents': response,
                'HumanReadable': md,
                'ReadableContentsFormat': formats['markdown']
            })
        elif response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def scan_report_command():
        """
        Execute SlashNext's url/scan API against the already requested URL scan command with the given parameters
        @:return: None
        """
        # 1. Get input scan id and extended_info flag from Demisto
        scanid = demisto.args().get('scanid')
        extended_info = demisto.args().get('extended_info')
        # 2. Get the scan report from SlashNext API
        response = scan_report(scanid=scanid)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        url_data = response.get('urlData')
        scanid = url_data.get('scanId')

        snx_ioc_cont, dbot_score_cont, url_cont = get_snx_url_ioc_context(url_data, is_scan=True)

        ec = {
            'SlashNext.URL(val.Value === obj.Value)': snx_ioc_cont[0],
            'DBotScore': dbot_score_cont,
            'URL': url_cont
        }

        title = 'SlashNext Phishing Incident Response - Scan Report\n'\
                '##### url = {}'.format(url_data.get('url'))

        if response.get('normalizeData').get('normalizeStatus') == 1:
            title += ' *\n*' + response.get('normalizeData').get('normalizeMessage')

        md = tableToMarkdown(
            title,
            snx_ioc_cont,
            ['Value',
             'Type',
             'Verdict',
             'ScanID',
             'ThreatStatus',
             'ThreatName',
             'ThreatType',
             'FirstSeen',
             'LastSeen']
        )

        return_outputs(md, ec, snx_ioc_cont)

        if extended_info == 'true' and response.get('swlData') is None:
            # Download Screenshot, HTML and Text Section
            if url_data.get('landingUrl') is None:
                if url_data.get('finalUrl') is not None and url_data.get('finalUrl') != 'N/A':
                    tag = 'Final URL = {}'.format(url_data.get('finalUrl'))
                else:
                    tag = 'Scanned URL = {}'.format(url_data.get('url'))
            else:
                tag = 'Redirected URL = {}'.format(url_data.get('landingUrl').get('url'))

            download_forensics_data(scanid=scanid, tag=tag, screenshot=True, html=True, txt=True)


    def download_screenshot(scanid, resolution='high'):
        """
        Execute SlashNext's download/screenshot API against the already requested URL scan with the given parameters
        :param scanid: Scan ID returned by a SlashNext API earlier as a result of a scan request
        :param resolution: Desired resolution of the screenshot. Currently supported values are 'high' and 'medium'
        :return: Response of the SlashNext download/screenshot API
        """
        # Create the required data dictionary for Download/Screenshot
        api_data = {
            'scanid': scanid,
            'resolution': resolution
        }
        response = http_request(endpoint=DL_SC_API, data=api_data)

        if response.get('errorNo') == 1:
            demisto.results(
                'Your Url Scan request is submitted to the cloud and may take up-to 60 seconds to complete.\n'
                'Please check back later using "slashnext-download-screenshot" command with Scan ID = {}'.format(scanid))
        elif response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def download_screenshot_command():
        """
        Execute SlashNext's download/screenshot API against the already requested URL scan command with the given parameters
        @:return: None
        """
        # 1. Get input scan id and resolution from Demisto
        scanid = demisto.args().get('scanid')
        resolution = demisto.args().get('resolution')
        # 2. Get the forensic webpage screenshot from SlashNext API
        response = download_screenshot(scanid=scanid, resolution=resolution)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        sc_base64 = response.get('scData').get('scBase64')
        sc_data = base64.b64decode(sc_base64)

        sc_file = fileResult('slashnext_{}.jpg'.format(scanid), sc_data, entryTypes['image'])

        demisto.results({
            'Type': entryTypes['image'],
            'ContentsFormat': formats['text'],
            'Contents': 'Forensics: Webpage Screenshot for URL Scan ID = {}'.format(scanid),
            'File': sc_file.get('File'),
            'FileID': sc_file.get('FileID')
        })


    def download_html(scanid):
        """
        Execute SlashNext's download/html API against the already requested URL scan with the given parameters
        :param scanid: Scan ID returned by a SlashNext API earlier as a result of a scan request
        :return: Response of the SlashNext download/html API
        """
        # Create the required data dictionary for Download/HTML
        api_data = {
            'scanid': scanid
        }
        response = http_request(endpoint=DL_HTML_API, data=api_data)

        if response.get('errorNo') == 1:
            demisto.results(
                'Your Url Scan request is submitted to the cloud and may take up-to 60 seconds to complete.\n'
                'Please check back later using "slashnext-download-html" command with Scan ID = {}'.format(scanid))
        elif response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def download_html_command():
        """
        Execute SlashNext's download/HTML API against the already requested URL scan command with the given parameters
        @:return: None
        """
        # 1. Get input scan id from Demisto
        scanid = demisto.args().get('scanid')
        # 2. Get the forensic webpage HTML from SlashNext API
        response = download_html(scanid=scanid)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        html_base64 = response.get('htmlData').get('htmlBase64')
        html_data = base64.b64decode(html_base64)

        html_file = fileResult('slashnext_{}.html'.format(scanid), html_data, entryTypes['file'])

        demisto.results({
            'Type': entryTypes['file'],
            'ContentsFormat': formats['text'],
            'Contents': 'Forensics: Webpage HTML for URL Scan ID = {}'.format(scanid),
            'File': html_file.get('File'),
            'FileID': html_file.get('FileID')
        })


    def download_text(scanid):
        """
        Execute SlashNext's download/text API against the already requested URL scan with the given parameters
        :param scanid: Scan ID returned by a SlashNext API earlier as a result of a scan request
        :return: Response of the SlashNext download/text API
        """
        # Create the required data dictionary for Download/Text
        api_data = {
            'scanid': scanid
        }
        response = http_request(endpoint=DL_TEXT_API, data=api_data)

        if response.get('errorNo') == 1:
            demisto.results(
                'Your Url Scan request is submitted to the cloud and may take up-to 60 seconds to complete.\n'
                'Please check back later using "slashnext-download-text" command with Scan ID = {}'.format(scanid))
        elif response.get('errorNo') != 0:
            return_error('API Returned, {}:{}'.format(response.get('errorNo'), response.get('errorMsg')))

        return response


    def download_text_command():
        """
        Execute SlashNext's download/text API against the already requested URL scan command with the given parameters
        @:return: None
        """
        # 1. Get input scan id from Demisto
        scanid = demisto.args().get('scanid')
        # 2. Get the forensic webpage text from SlashNext API
        response = download_text(scanid=scanid)
        if response.get('errorNo') != 0:
            return
        # 3. Parse and format the response
        text_base64 = response.get('textData').get('textBase64')
        text_data = base64.b64decode(text_base64)

        text_file = fileResult('slashnext_{}.txt'.format(scanid), text_data, entryTypes['file'])

        demisto.results({
            'Type': entryTypes['file'],
            'ContentsFormat': formats['text'],
            'Contents': 'Forensics: Webpage Rendered Text for URL Scan ID = {}'.format(scanid),
            'File': text_file.get('File'),
            'FileID': text_file.get('FileID')
        })


    ''' EXECUTION '''


    def main():
        LOG('Command to be executed is {}.'.format(demisto.command()))
        handle_proxy()
        try:
            if demisto.command() == 'test-module':
                demisto.results(validate_snx_api_key())

            if demisto.command() == 'ip':
                ip_command()
            elif demisto.command() == 'domain':
                domain_command()
            elif demisto.command() == 'slashnext-host-reputation':
                host_reputation_command()
            elif demisto.command() == 'slashnext-host-report':
                host_report_command()
            elif demisto.command() == 'slashnext-host-urls':
                host_urls_command()
            elif demisto.command() == 'slashnext-url-scan':
                url_scan_command()
            elif demisto.command() == 'slashnext-url-scan-sync':
                url_scan_sync_command()
            elif demisto.command() == 'slashnext-scan-report':
                scan_report_command()
            elif demisto.command() == 'slashnext-download-screenshot':
                download_screenshot_command()
            elif demisto.command() == 'slashnext-download-html':
                download_html_command()
            elif demisto.command() == 'slashnext-download-text':
                download_text_command()

        except Exception as e:
            return_error(str(e))


    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  subtype: python3
  type: python
system: true
