import sys
import argparse
import requests
import urllib3
from utils import timestamped_print

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
print = timestamped_print

SKIP_LABEL = "skip-ai-review"
BOT_USERNAME = "content-bot"
REQUIRED_TEXT = "please review and approve the results generated by the AI Reviewer by responding üëç on this comment."
REPO_OWNER = "demisto"
REPO_NAME = "content"


def arguments_handler():
    """Validates and parses script arguments.
    Return
        Namespace: Parsed arguments object.
    """
    parser = argparse.ArgumentParser(description="Check if AI review is approved.")
    parser.add_argument("-p", "--pr_number", help="The PR number to check.")
    parser.add_argument("-g", "--github_token", help="The GitHub token to authenticate the GitHub client.")
    return parser.parse_args()


def get_pr_query_string():
    """Returns the GraphQL query string with pagination support."""
    return """
    query($owner: String!, $repo: String!, $pr_number: Int!, $cursor: String) {
      repository(owner: $owner, name: $repo) {
        pullRequest(number: $pr_number) {
          labels(first: 20) {
            nodes { name }
          }
          reviews(first: 50, after: $cursor) {
            pageInfo {
              hasNextPage
              endCursor
            }
            nodes {
              databaseId
              body
              author { login }
              reactions(first: 10) {
                nodes {
                  content
                  user { login }
                }
              }
            }
          }
        }
      }
    }
    """

def fetch_pr_data(owner: str, repo: str, pr_number: int, token: str) -> dict:
    """Executes the GraphQL query with pagination and returns the aggregated PR data."""
    url = "https://api.github.com/graphql"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
    }
    
    # Initial variables
    variables = {
        "owner": owner, 
        "repo": repo, 
        "pr_number": int(pr_number), 
        "cursor": None
    }
    
    all_reviews = []
    final_pr_data = {"reviews": {"nodes": {}}}
    has_next_page = True

    try:
        while has_next_page:
            response = requests.post(
                url, 
                json={"query": get_pr_query_string(), "variables": variables}, 
                headers=headers, 
                verify=False
            )
            response.raise_for_status()
            data = response.json()

            # Navigate the response structure
            repository = data.get("data", {}).get("repository", {})
            if not repository:
                raise ValueError(f"Repository {owner}/{repo} not found or access denied.")
                
            pr_data = repository.get("pullRequest", {})
            if not pr_data:
                raise ValueError(f"Could not find PR {pr_number} in {owner}/{repo}")

            # On the first pass, capture the base PR data (like labels)
            if final_pr_data is None:
                final_pr_data = pr_data

            # Extract reviews and pagination info
            reviews_data = pr_data.get("reviews", {})
            new_reviews = reviews_data.get("nodes", [])
            all_reviews.extend(new_reviews)

            page_info = reviews_data.get("pageInfo", {})
            has_next_page = page_info.get("hasNextPage", False)
            
            # Update cursor for the next iteration
            variables["cursor"] = page_info.get("endCursor")

        # Overwrite the reviews in the final object with the complete list
        # We perform a shallow copy or direct assignment to structurally match the original return format
        final_pr_data["reviews"]["nodes"] = all_reviews
        
        # Clean up pagination info from the final output if you want it to look like the original non-paginated structure
        # (Optional) final_pr_data["reviews"].pop("pageInfo", None)

        return final_pr_data

    except requests.exceptions.RequestException as e:
        print(f"Network error fetching PR data: {e}")
        raise


def has_skip_label(pr_data: dict, label_to_check: str) -> bool:
    """Checks if the PR has the specified bypass label."""
    labels = [node["name"] for node in pr_data.get("labels", {}).get("nodes", [])]
    print(f"The PR has the following labels: {', '.join(labels)}")
    return label_to_check in labels


def check_reviews_for_approval(pr_data: dict, bot_username: str, required_text: str) -> tuple[bool, str | None]:
    """
    Scans reviews to find one from the bot with the required text
    that also has a THUMBS_UP reaction.

    Returns:
        (found_bot_comment: bool, approver_username: str | None)
    """
    reviews = pr_data.get("reviews", {}).get("nodes", [])
    bot_review_found = False

    for review in reviews:
        author_login = review.get("author", {}).get("login")
        body = review.get("body", "")
        print(f"Current comment body: {body}")

        if (author_login == bot_username) and (required_text in body):
            bot_review_found = True
            print(f"   Found AI Review (ID: {review.get('databaseId')})")

            reactions = review.get("reactions", {}).get("nodes", [])
            for reaction in reactions:
                if reaction["content"] == "THUMBS_UP":
                    approver = reaction["user"]["login"]
                    return True, approver

    return bot_review_found, None


def main():
    options = arguments_handler()
    pr_number = options.pr_number
    github_token = options.github_token
    print(f"Checking PR {pr_number} via GraphQL...")

    pr_data = fetch_pr_data(REPO_OWNER, REPO_NAME, pr_number, github_token)

    if has_skip_label(pr_data, SKIP_LABEL):
        print(f'‚úÖ Found "{SKIP_LABEL}" label. Skipping AI review check.')
        sys.exit(0)

    found_bot_comment, approver = check_reviews_for_approval(pr_data, BOT_USERNAME, REQUIRED_TEXT)

    if approver:
        print(f"Found üëç reaction from user: {approver}")
        print("‚úÖ AI Review approved.")
        sys.exit(0)
    elif found_bot_comment:
        print("‚ùå AI Review found, but no üëç reaction detected.")
        sys.exit(1)
    else:
        print("‚ùå AI Review check failed. No AI Review comment found.")
        sys.exit(1)


if __name__ == "__main__":
    main()
