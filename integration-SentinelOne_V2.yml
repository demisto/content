category: Endpoint
commonfields:
  id: SentinelOne V2
  version: -1
configuration:
- defaultvalue: ""
  display: Server URL (e.g., https://usea1.sentinelone.net)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: API Token
  name: token
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3
    months, 1 year)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: "5"
  display: Minimum risk score for importing incidents (0-10), where 0 is low risk
    and 10 is high risk
  name: fetch_threat_rank
  required: false
  type: 0
- defaultvalue: "10"
  display: 'Fetch limit: the maximum number of incidents to fetch'
  name: fetch_limit
  required: false
  type: 0
description: End point protection
detaileddescription: |
  1. To get your API token, log in to your SentinelOne console.
  2. Click your user name in the upper-right corner, and select *My User*.
  3. Click the *Generate* link, located near the *API Token* field.
  4. Save your API token in a safe place because you will not be able to access it anymore.
display: SentinelOne V2
image: data:image/png;base64,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
name: SentinelOne V2
script:
  commands:
  - arguments:
    - description: Filter by computer name.
      name: computer_name
    - auto: PREDEFINED
      description: 'CSV list of scan statuses by which to filter the results, for
        example: "started,aborted".'
      name: scan_status
      predefined:
      - started
      - none
      - finished
      - aborted
    - auto: PREDEFINED
      description: 'Included OS types, for example: "windows".'
      isArray: true
      name: os_type
      predefined:
      - windows
      - windows_legacy
      - macos
      - linux
    - description: 'Endpoint created at timestamp, for example: "2018-02-27T04:49:26.257525Z".'
      name: created_at
    - description: Minimum number of threats for an agent.
      name: min_active_threats
    description: Returns all agents that match the specified criteria.
    name: sentinelone-list-agents
    outputs:
    - contextPath: SentinelOne.Agents.NetworkStatus
      description: The agent network status.
      type: string
    - contextPath: SentinelOne.Agents.ID
      description: The agent ID.
      type: string
    - contextPath: SentinelOne.Agents.AgentVersion
      description: The agent software version.
      type: string
    - contextPath: SentinelOne.Agents.IsDecomissioned
      description: Whether the agent is decommissioned.
      type: boolean
    - contextPath: SentinelOne.Agents.IsActive
      description: Whether the agent is active.
      type: boolean
    - contextPath: SentinelOne.Agents.LastActiveDate
      description: The last active date of the agent
      type: date
    - contextPath: SentinelOne.Agents.RegisteredAt
      description: The registration date of the agent.
      type: date
    - contextPath: SentinelOne.Agents.ExternalIP
      description: The agent IP address.
      type: string
    - contextPath: SentinelOne.Agents.ThreatCount
      description: Number of active threats.
      type: number
    - contextPath: SentinelOne.Agents.EncryptedApplications
      description: Whether disk encryption is enabled.
      type: boolean
    - contextPath: SentinelOne.Agents.OSName
      description: Name of operating system.
      type: string
    - contextPath: SentinelOne.Agents.ComputerName
      description: Name of agent computer.
      type: string
    - contextPath: SentinelOne.Agents.Domain
      description: Domain name of the agent.
      type: string
    - contextPath: SentinelOne.Agents.CreatedAt
      description: Creation time of the agent.
      type: date
    - contextPath: SentinelOne.Agents.SiteName
      description: Site name associated with the agent.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: Exclusion item type. Can be "file_type", "path", "white_hash",
        "certificate", or "browser".
      name: exclusion_type
      predefined:
      - file_type
      - path
      - white_hash
      - certificate
      - browser
      required: true
    - description: Value of the exclusion item for the exclusion list.
      name: exclusion_value
      required: true
    - auto: PREDEFINED
      description: OS type. Can be "windows", "windows_legacy", "macos", or "linux".
        OS type is required for hash exclusions.
      name: os_type
      predefined:
      - windows
      - windows_legacy.macos
      - linux
      required: true
    - description: Description for adding the item.
      name: description
    - auto: PREDEFINED
      description: Exclusion mode (path exclusion only). Can be "suppress", "disable_in_process_monitor_deep",
        "disable_in_process_monitor", "disable_all_monitors", or "disable_all_monitors_deep".
      name: exclusion_mode
      predefined:
      - suppress
      - disable_in_process_monitor_deep
      - disable_in_process_monitor
      - disable_all_monitors
      - disable_all_monitors_deep
    - description: Excluded path for a path exclusion list.
      name: path_exclusion_type
    - description: CSV list of group IDs by which to filter. Can be "site_ids" or
        "group_ids".
      isArray: true
      name: group_ids
    description: Creates an exclusion item that matches the specified input filter.
    name: sentinelone-create-white-list-item
    outputs:
    - contextPath: SentinelOne.Exclusions.ID
      description: The whitelisted entity ID.
      type: string
    - contextPath: SentinelOne.Exclusions.Type
      description: The whitelisted item type.
      type: string
    - contextPath: SentinelOne.Exclusions.CreatedAt
      description: Time when the whitelist item was created.
      type: date
  - arguments:
    - description: 'List of IDs by which to filter, for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: item_ids
    - auto: PREDEFINED
      description: 'CSV list of OS types by which to filter, for example: "windows,
        linux".'
      isArray: true
      name: os_types
      predefined:
      - windows
      - windows_legacy
      - macos
      - linux
    - auto: PREDEFINED
      description: Exclusion type. Can be "file_type", "path", "white_hash", "certificate",
        "browser".
      name: exclusion_type
      predefined:
      - file_type
      - path
      - white_hash
      - certificate
      - browser
    - defaultValue: "10"
      description: The maximum number of items to return.
      name: limit
    description: Lists all exclusion items that match the specified input filter.
    name: sentinelone-get-white-list
    outputs:
    - contextPath: SentinelOne.Exclusions.ID
      description: The item ID.
      type: string
    - contextPath: SentinelOne.Exclusions.Type
      description: The exclusion item type.
      type: string
    - contextPath: SentinelOne.Exclusions.CreatedAt
      description: Timestamp when the item was added.
      type: date
    - contextPath: SentinelOne.Exclusions.Value
      description: Value of the added item.
      type: string
    - contextPath: SentinelOne.Exclusions.Source
      description: Source of the added item.
      type: string
    - contextPath: SentinelOne.Exclusions.UserID
      description: User ID of the user that added the item.
      type: string
    - contextPath: SentinelOne.Exclusions.UpdatedAt
      description: Timestamp when the item was updated
      type: date
    - contextPath: SentinelOne.Exclusions.OsType
      description: OS type.
      type: string
    - contextPath: SentinelOne.Exclusions.UserName
      description: User name of the user that added the item.
      type: string
    - contextPath: SentinelOne.Exclusions.Mode
      description: 'CSV list of modes by which to filter (ath exclusions only), for
        example: "suppress".'
      type: string
  - arguments:
    - description: The content hash.
      name: hash
      required: true
    description: Gets the reputation of a hash.
    name: sentinelone-get-hash
    outputs:
    - contextPath: SentinelOne.Hash.Rank
      description: The hash reputation (1-10).
      type: Number
    - contextPath: SentinelOne.Hash.Hash
      description: The content hash.
      type: String
    - contextPath: SentinelOne.Hash.Classification
      description: The hash classification.
      type: String
    - contextPath: SentinelOne.Hash.Classification Source
      description: The hash classification source.
      type: String
  - arguments:
    - description: The content hash of the threat.
      name: content_hash
    - auto: PREDEFINED
      description: CSV list of mitigation statuses. Can be "mitigated", "active",
        "blocked", "suspicious", "pending", or "suspicious_resolved".
      isArray: true
      name: mitigation_status
      predefined:
      - mitigated
      - active
      - blocked
      - suspicious
      - pending
      - suspicious_resolved
    - description: 'Searches for threats created before this date, for example: "2018-02-27T04:49:26.257525Z".'
      name: created_before
    - description: 'Searches for threats created after this date, for example: "2018-02-27T04:49:26.257525Z".'
      name: created_after
    - description: 'Searches for threats created on or before this date, for example:
        "2018-02-27T04:49:26.257525Z".'
      name: created_until
    - description: 'Search for threats created on or after this date, for example:
        "2018-02-27T04:49:26.257525Z".'
      name: created_from
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to only return resolved threats.
      name: resolved
      predefined:
      - "false"
      - "true"
    - description: Threat display name. Can be a partial display name, not an exact
        match.
      name: display_name
    - defaultValue: "20"
      description: The maximum number of threats to return. Default is 20.
      name: limit
    - description: Full free-text search for fields. Can be "content_hash", "file_display_name",
        "file_path", "computer_name", or "uuid".
      name: query
    - description: 'CSV list of threat IDs, for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: threat_ids
    - auto: PREDEFINED
      description: ' CSV list of threat classifications to search, for example: "Malware",
        "Network", "Benign".'
      name: classifications
      predefined:
      - Engine
      - Static
      - Cloud
      - Behavioral
    - description: Risk level threshold to retrieve (1-10).
      name: rank
    description: Returns threats according to specified filters.
    name: sentinelone-get-threats
    outputs:
    - contextPath: SentinelOne.Threat.ID
      description: The threat ID.
      type: String
    - contextPath: SentinelOne.Threat.AgentComputerName
      description: The agent computer name.
      type: String
    - contextPath: SentinelOne.Threat.CreatedDate
      description: File created date.
      type: Date
    - contextPath: SentinelOne.Threat.SiteID
      description: The site ID.
      type: String
    - contextPath: SentinelOne.Threat.Classification
      description: Classification name.
      type: string
    - contextPath: SentinelOne.Threat.MitigationStatus
      description: The agent status.
      type: String
    - contextPath: SentinelOne.Threat.AgentID
      description: The agent ID.
      type: String
    - contextPath: SentinelOne.Threat.Rank
      description: Number representing cloud reputation (1-10).
      type: Number
    - contextPath: SentinelOne.Threat.MarkedAsBenign
      description: Whether the threat is marked as benign.
      type: Boolean
  - arguments:
    - description: 'CSV list of group IDs by which to filter, for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: group_ids
    description: Returns a dashboard threat summary.
    name: sentinelone-threat-summary
    outputs:
    - contextPath: SentinelOne.Threat.Active
      description: Number of active threats in the system.
      type: Number
    - contextPath: SentinelOne.Threat.Total
      description: Total number of threats in the system.
      type: Number
    - contextPath: SentinelOne.Threat.Mitigated
      description: Number of mitigated threats in the system.
      type: Number
    - contextPath: SentinelOne.Threat.Suspicious
      description: Number of suspicious threats in the system.
      type: Number
    - contextPath: SentinelOne.Threat.Blocked
      description: Number of blocked threats in the system.
      type: Number
  - arguments:
    - description: CSV list of threat IDs.
      isArray: true
      name: threat_ids
    - auto: PREDEFINED
      description: Scope to use for exclusions. Can be "site" or "tenant".
      name: target_scope
      predefined:
      - site
      - tenant
      required: true
    description: Mark suspicious threats as threats
    name: sentinelone-mark-as-threat
    outputs:
    - contextPath: SentinelOne.Threat.ID
      description: The threat ID.
      type: String
    - contextPath: SentinelOne.Threat.MarkedAsThreat
      description: Whether the suspicious threat was successfully marked as a threat.
      type: Boolean
  - arguments:
    - auto: PREDEFINED
      description: Mitigation action. Can be "kill", "quarantine", "un-quarantine",
        "remediate", or "rollback-remediation".
      name: action
      predefined:
      - kill
      - quarantine
      - un-quarantine
      - remediate
      - rollback-remediation
      required: true
    - description: CSV list of threat IDs.
      isArray: true
      name: threat_ids
      required: true
    description: Applies a mitigation action to a group of threats that match the
      specified input filter.
    name: sentinelone-mitigate-threat
    outputs:
    - contextPath: SentinelOne.Threat.ID
      description: The threat ID.
      type: String
    - contextPath: SentinelOne.Threat.Mitigated
      description: Whether the threat was successfully mitigated.
      type: Boolean
    - contextPath: SentinelOne.Threat.Mitigation.Action
      description: Number of threats affected.
      type: Number
  - arguments:
    - description: CSV list of threat IDs.
      isArray: true
      name: threat_ids
      required: true
    description: Resolves threat using the threat ID.
    name: sentinelone-resolve-threat
    outputs:
    - contextPath: SentinelOne.Threat.ID
      description: The threat ID.
      type: String
    - contextPath: SentinelOne.Threat.Resolved
      description: Whether the threat was successfully resolved.
      type: Boolean
  - arguments:
    - description: The agent ID.
      name: agent_id
      required: true
    description: Returns details of an agent, by agent ID.
    name: sentinelone-get-agent
    outputs:
    - contextPath: SentinelOne.Agent.NetworkStatus
      description: The agent network status.
      type: string
    - contextPath: SentinelOne.Agent.ID
      description: The agent ID.
      type: string
    - contextPath: SentinelOne.Agent.AgentVersion
      description: The agent software version.
      type: string
    - contextPath: SentinelOne.Agent.IsDecomissioned
      description: Whether the agent is decommissioned.
      type: boolean
    - contextPath: SentinelOne.Agent.IsActive
      description: Whether the agent is active.
      type: boolean
    - contextPath: SentinelOne.Agent.LastActiveDate
      description: The last active date of the agent.
      type: date
    - contextPath: SentinelOne.Agent.RegisteredAt
      description: The registration date of the agent.
      type: date
    - contextPath: SentinelOne.Agent.ExternalIP
      description: The agent IP address.
      type: string
    - contextPath: SentinelOne.Agent.ThreatCount
      description: Number of active threats.
      type: number
    - contextPath: SentinelOne.Agent.EncryptedApplications
      description: Whether disk encryption is enabled.
      type: boolean
    - contextPath: SentinelOne.Agent.OSName
      description: Name of the operating system.
      type: string
    - contextPath: SentinelOne.Agent.ComputerName
      description: Name of the agent computer.
      type: string
    - contextPath: SentinelOne.Agent.Domain
      description: Domain name of the agent.
      type: string
    - contextPath: SentinelOne.Agent.CreatedAt
      description: Agent creation time.
      type: date
    - contextPath: SentinelOne.Agent.SiteName
      description: Site name associated with the agent.
      type: string
  - arguments:
    - description: 'Timestamp of last update, for example: "2018-02-27T04:49:26.257525Z".'
      name: updated_at
    - description: 'Full-text search for fields: name, account_name.'
      name: query
    - auto: PREDEFINED
      description: Site type. Can be "Trial", "Paid", "POC", "DEV", or "NFR".
      name: site_type
      predefined:
      - Trial
      - Paid
      - POC
      - DEV
      - NFR
    - auto: PREDEFINED
      description: Returns sites that support the specified features. Can be "firewall-control",
        "device-control", or "ioc".
      name: features
      predefined:
      - firewall-control
      - device-control
      - ioc
    - auto: PREDEFINED
      description: Site state. Can be "active", "deleted", or "expired".
      name: state
      predefined:
      - active
      - deleted
      - expired
    - auto: PREDEFINED
      description: The suite of product features active for this site. Can be "Core"
        or "Complete".
      name: suite
      predefined:
      - Core
      - Complete
    - auto: PREDEFINED
      description: Sites to which the user has Admin privileges.
      name: admin_only
      predefined:
      - "true"
      - "false"
    - description: 'Account ID, for example: "225494730938493804".'
      name: account_id
    - description: 'Site name, for example: "My Site".'
      name: site_name
    - description: 'Timestamp of site creation, for example: "2018-02-27T04:49:26.257525Z".'
      name: created_at
    - defaultValue: "50"
      description: Maximum number of results to return.
      name: limit
    description: Returns all sites that match the specified criteria.
    name: sentinelone-get-sites
    outputs:
    - contextPath: SentinelOne.Site.Creator
      description: The creator name.
      type: string
    - contextPath: SentinelOne.Site.Name
      description: The site name.
      type: string
    - contextPath: SentinelOne.Site.Type
      description: The site type.
      type: string
    - contextPath: SentinelOne.Site.AccountName
      description: The account name.
      type: string
    - contextPath: SentinelOne.Site.State
      description: The site state.
      type: string
    - contextPath: SentinelOne.Site.HealthStatus
      description: The health status of the site.
      type: boolean
    - contextPath: SentinelOne.Site.Suite
      description: The suite to which the site belongs.
      type: string
    - contextPath: SentinelOne.Site.ActiveLicenses
      description: Number of active licenses on the site.
      type: number
    - contextPath: SentinelOne.Site.ID
      description: ID of the site.
      type: string
    - contextPath: SentinelOne.Site.TotalLicenses
      description: Number of total licenses on the site.
      type: number
    - contextPath: SentinelOne.Site.CreatedAt
      description: Timestamp when the site was created.
      type: date
    - contextPath: SentinelOne.Site.Expiration
      description: Timestamp when the site will expire.
      type: string
    - contextPath: SentinelOne.Site.UnlimitedLicenses
      description: Whether the site has unlimited licenses.
      type: boolean
  - arguments:
    - description: ID of the site.
      name: site_id
      required: true
    description: Returns a site, by site ID.
    name: sentinelone-get-site
    outputs:
    - contextPath: SentinelOne.Site.Creator
      description: The creator name.
      type: string
    - contextPath: SentinelOne.Site.Name
      description: The site name.
      type: string
    - contextPath: SentinelOne.Site.Type
      description: The site type.
      type: string
    - contextPath: SentinelOne.Site.AccountName
      description: The account name.
      type: string
    - contextPath: SentinelOne.Site.State
      description: The site state.
      type: string
    - contextPath: SentinelOne.Site.HealthStatus
      description: The health status of the site.
      type: boolean
    - contextPath: SentinelOne.Site.Suite
      description: The suite to which the site belongs.
      type: string
    - contextPath: SentinelOne.Site.ActiveLicenses
      description: Number of active licenses on the site.
      type: number
    - contextPath: SentinelOne.Site.ID
      description: ID of the site.
      type: string
    - contextPath: SentinelOne.Site.TotalLicenses
      description: Number of total licenses on the site.
      type: number
    - contextPath: SentinelOne.Site.CreatedAt
      description: Timestamp when the site was created.
      type: date
    - contextPath: SentinelOne.Site.Expiration
      description: Timestamp when the site will expire.
      type: string
    - contextPath: SentinelOne.Site.UnlimitedLicenses
      description: Unlimited licenses boolean.
      type: boolean
    - contextPath: SentinelOne.Site.AccountID
      description: Account ID.
      type: string
    - contextPath: SentinelOne.Site.IsDefault
      description: Whether the site is the default site.
      type: boolean
  - arguments:
    - description: 'Site ID. Example: "225494730938493804".'
      name: site_id
      required: true
    description: Reactivates an expired site.
    name: sentinelone-reactivate-site
    outputs:
    - contextPath: SentinelOne.Site.ID
      description: Site ID.
      type: string
    - contextPath: SentinelOne.Site.Reactivated
      description: Whether the site was reactivated.
      type: boolean
  - arguments:
    - description: 'Site ID of the site to expire, for example: "225494730938493804".'
      name: site_id
      required: true
    description: Expires a site.
    name: sentinelone-expire-site
    outputs:
    - contextPath: SentinelOne.Site.ID
      description: ID of the site.
      type: String
    - contextPath: SentinelOne.Site.Expired
      description: A boolean to check if the site was expired or not.
      type: Boolean
  - arguments:
    - description: 'Return activities created after this timestamp, for example: "2018-02-27T04:49:26.257525Z".'
      name: created_after
    - description: Email address of the user who invoked the activity (if applicable).
      name: user_emails
    - description: 'List of Group IDs by which to filter, for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: group_ids
    - description: 'Return activities created on or before this timestamp, for example:
        "2018-02-27T04:49:26.257525Z".'
      name: created_until
    - auto: PREDEFINED
      description: 'Include internal activities hidden from display, for example:
        "False".'
      name: include_hidden
      predefined:
      - "true"
      - "false"
    - description: 'CSV list of activity IDs by which to filter, for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: activities_ids
    - description: 'Return activities created before this timestamp, for example:
        "2018-02-27T04:49:26.257525Z".'
      name: created_before
    - description: 'CSV list of threat IDs for which to return activities, for example:
        "225494730938493804,225494730938493915".'
      isArray: true
      name: threats_ids
    - description: 'CSV of activity codes to return, for example: "52,53,71,72".'
      isArray: true
      name: activity_types
    - description: 'CSV list of user IDs for users that invoked the activity (if applicable),
        for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: user_ids
    - description: 'Return activities created on or after this timestamp, for example:
        "2018-02-27T04:49:26.257525Z".'
      name: created_from
    - description: 'Return activities created within this range (inclusive), for example:
        "1514978764288-1514978999999".'
      name: created_between
    - description: 'Return activities related to specified agents. Example: "225494730938493804,225494730938493915".'
      isArray: true
      name: agent_ids
    - description: Maximum number of items to return (1-100).
      name: limit
    description: Returns a list of activities.
    name: sentinelone-get-activities
    outputs:
    - contextPath: SentinelOne.Activity.AgentID
      description: Related agent (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.AgentUpdatedVersion
      description: Agent's new version (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.SiteID
      description: Related site (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.UserID
      description: The user who invoked the activity (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.SecondaryDescription
      description: Secondary description.
      type: String
    - contextPath: SentinelOne.Activity.OsFamily
      description: Agent's OS type (if applicable). Can be "linux", "macos", "windows",
        or "windows_legacy".
      type: String
    - contextPath: SentinelOne.Activity.ActivityType
      description: Activity type.
      type: Number
    - contextPath: SentinelOne.Activity.data.SiteID
      description: The site ID.
      type: String
    - contextPath: SentinelOne.Activity.data.SiteName
      description: The site name.
      type: String
    - contextPath: SentinelOne.Activity.data.username
      description: The name of the site creator.
      type: String
    - contextPath: SentinelOne.Activity.Hash
      description: Threat file hash (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.UpdatedAt
      description: Activity last updated time (UTC).
      type: Date
    - contextPath: SentinelOne.Activity.Comments
      description: Comments for the activity.
      type: String
    - contextPath: SentinelOne.Activity.ThreatID
      description: Related threat (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.PrimaryDescription
      description: Primary description for the activity.
      type: String
    - contextPath: SentinelOne.Activity.GroupID
      description: Related group (if applicable).
      type: String
    - contextPath: SentinelOne.Activity.ID
      description: Activity ID.
      type: String
    - contextPath: SentinelOne.Activity.CreatedAt
      description: Activity creation time (UTC).
      type: Date
    - contextPath: SentinelOne.Activity.Description
      description: Extra activity information.
      type: String
  - arguments:
    - description: 'Group type, for example: "static".'
      name: group_type
    - description: 'CSV list of group IDs by which to filter, for example: "225494730938493804,225494730938493915".'
      isArray: true
      name: group_ids
    - description: 'Group ID by which to filter, for example: "225494730938493804".'
      name: group_id
    - auto: PREDEFINED
      description: Whether this is the default group.
      name: is_default
      predefined:
      - "true"
      - "false"
    - description: The name of the group.
      name: name
    - description: Free-text search on fields name.
      name: query
    - description: The rank sets the priority of a dynamic group over others, for
        example, "1", which is the highest priority.
      name: rank
    - description: Maximum number of items to return (1-200).
      name: limit
    description: Returns data for the specified group.
    name: sentinelone-get-groups
    outputs:
    - contextPath: SentinelOne.Group.siteId
      description: The ID of the site of which this group is a member.
      type: String
    - contextPath: SentinelOne.Group.filterName
      description: If the group is dynamic, the name of the filter which is used to
        associate agents.
      type: String
    - contextPath: SentinelOne.Group.creatorId
      description: The ID of the user that created the group.
      type: String
    - contextPath: SentinelOne.Group.name
      description: The name of the group.
      type: String
    - contextPath: SentinelOne.Group.creator
      description: The user that created the group.
      type: String
    - contextPath: SentinelOne.Group.rank
      description: The rank, which sets the priority of a dynamic group over others.
      type: Number
    - contextPath: SentinelOne.Group.updatedAt
      description: Timestamp of the last update.
      type: Date
    - contextPath: SentinelOne.Group.totalAgents
      description: Number of agents in the group.
      type: Number
    - contextPath: SentinelOne.Group.filterId
      description: If the group is dynamic, the group ID of the filter that is used
        to associate agents.
      type: String
    - contextPath: SentinelOne.Group.isDefault
      description: Whether the groups is the default group of the site.
      type: Boolean
    - contextPath: SentinelOne.Group.inherits
      description: Whether the policy is inherited from a site. "False" if the group
        has its own edited policy.
      type: Boolean
    - contextPath: SentinelOne.Group.type
      description: Group type. Can be static or dynamic
      type: String
    - contextPath: SentinelOne.Group.id
      description: The ID of the group.
      type: String
    - contextPath: SentinelOne.Group.createdAt
      description: Timestamp of group creation.
      type: Date
  - arguments:
    - description: The ID of the group to move the agent to.
      name: group_id
      required: true
    - description: Agents IDs.
      isArray: true
      name: agents_ids
    description: Moves agents to a new group.
    name: sentinelone-move-agent
    outputs:
    - contextPath: SentinelOne.Agent.AgentsMoved
      description: The number of agents that were moved to another group.
      type: Number
  - arguments:
    - description: The ID of the group to delete.
      name: group_id
      required: true
    description: Deletes a group, by the group ID.
    name: sentinelone-delete-group
  - arguments:
    - description: The ID of the agent from which to retrieve the processes.
      name: agents_ids
      required: true
    description: Retrieves running processes for a specific agent.
    name: sentinelone-agent-processes
    outputs:
    - contextPath: SentinelOne.Agent.memoryUsage
      description: Memory usage (MB).
      type: Number
    - contextPath: SentinelOne.Agent.startTime
      description: The process start time.
      type: Date
    - contextPath: SentinelOne.Agent.pid
      description: The process ID.
      type: Number
    - contextPath: SentinelOne.Agent.processName
      description: The name of the process.
      type: String
    - contextPath: SentinelOne.Agent.cpuUsage
      description: CPU usage (%).
      type: Number
    - contextPath: SentinelOne.Agent.executablePath
      description: Executable path.
      type: String
  - arguments:
    - description: A CSV list of agent IDs to connect to the network. Run the list-agents
        command to get a list of agent IDs.
      name: agent_id
      required: true
    description: Connects agents to network.
    name: sentinelone-connect-agent
    outputs:
    - contextPath: SentinelOne.Agent.AgentsAffected
      description: The number of affected agents.
      type: Number
    - contextPath: SentinelOne.Agent.ID
      description: The IDs of the affected agents.
      type: String
  - arguments:
    - description: A CSV list of agent IDs to disconnect from the network. Run the
        list-agents command to get a list of agent IDs.
      name: agent_id
      required: true
    description: Disconnects agents from network.
    name: sentinelone-disconnect-agent
    outputs:
    - contextPath: SentinelOne.Agent.NetworkStatus
      description: Agent network status.
      type: String
    - contextPath: SentinelOne.Agent.ID
      description: The IDs of the affected agents.
      type: String
  - arguments:
    - description: The Message to broadcast to agents.
      name: message
      required: true
    - auto: PREDEFINED
      description: Whether to only include active agents. Default is "false".
      name: active_agent
      predefined:
      - "true"
      - "false"
    - description: List of Group IDs by which to filter the results.
      name: group_id
    - description: A list of Agent IDs by which to filter the results.
      name: agent_id
    - description: Included network domains.
      name: domain
    description: Broadcasts a message to all agents that match the input filters.
    name: sentinelone-broadcast-message
  - arguments:
    - defaultValue: "50"
      description: Maximum number of items to return (1-100). Default is "50".
      name: limit
    - description: 'QueryId obtained when creating a query in the sentinelone-create-query
        command. Example: "q1xx2xx3".'
      name: query_id
      required: true
    description: Returns all Deep Visibility events that match the query.
    name: sentinelone-get-events
    outputs:
    - contextPath: SentinelOne.Event.ProcessUID
      description: Process unique identifier.
      type: String
    - contextPath: SentinelOne.Event.SHA256
      description: SHA256 hash of the file.
      type: String
    - contextPath: SentinelOne.Event.AgentOS
      description: OS type. Can be "windows", "linux", "macos", or "windows_legac".
      type: String
    - contextPath: SentinelOne.Event.ProcessID
      description: The process ID.
      type: Number
    - contextPath: SentinelOne.Event.User
      description: User assigned to the event.
      type: String
    - contextPath: SentinelOne.Event.Time
      description: Process start time.
      type: Date
    - contextPath: SentinelOne.Event.Endpoint
      description: The agent name.
      type: String
    - contextPath: SentinelOne.Event.SiteName
      description: Site name.
      type: String
    - contextPath: SentinelOne.Event.EventType
      description: Event type. Can be "events", "file", "ip", "url", "dns", "process",
        "registry", "scheduled_task", or "logins".
      type: String
    - contextPath: SentinelOne.Event.ProcessName
      description: The name of the process.
      type: String
    - contextPath: SentinelOne.Event.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: Event.ID
      description: Event process ID.
      type: String
    - contextPath: Event.Name
      description: Event name.
      type: String
    - contextPath: Event.Type
      description: Event type.
      type: String
  - arguments:
    - description: The query string for which to return events.
      name: query
      required: true
    - description: Query start date, for example, "2019-08-03T04:49:26.257525Z".
      name: from_date
      required: true
    - description: Query end date, for example, "2019-08-03T04:49:26.257525Z".
      name: to_date
      required: true
    description: Runs a Deep Visibility Query and returns the queryId. You can use
      the queryId for all other commands, such as the sentinelone-get-events command.
    name: sentinelone-create-query
    outputs:
    - contextPath: SentinelOne.Query.FromDate
      description: Query start date.
      type: Date
    - contextPath: SentinelOne.Query.Query
      description: The search query string.
      type: String
    - contextPath: SentinelOne.Query.QueryID
      description: The query ID.
      type: String
    - contextPath: SentinelOne.Query.ToDate
      description: Query end date.
      type: Date
  - arguments:
    - description: 'The queryId that is returned when creating a query under Create
        Query. Example: "q1xx2xx3". Get the query_id from the "get-query-id" command.'
      name: query_id
      required: true
    - defaultValue: "50"
      description: Maximum number of items to return (1-100). Default is "50".
      name: limit
    description: Returns a list of Deep Visibility events from query by event type
      - process.
    name: sentinelone-get-processes
    outputs:
    - contextPath: SentinelOne.Event.ParentProcessID
      description: Parent process ID.
      type: Number
    - contextPath: SentinelOne.Event.ProcessUID
      description: The process unique identifier.
      type: String
    - contextPath: SentinelOne.Event.SHA1
      description: SHA1 hash of the process image.
      type: String
    - contextPath: SentinelOne.Event.SubsystemType
      description: Process sub-system.
      type: String
    - contextPath: SentinelOne.Event.ParentProcessStartTime
      description: The parent process start time.
      type: Date
    - contextPath: SentinelOne.Event.ProcessID
      description: The process ID.
      type: Number
    - contextPath: SentinelOne.Event.ParentProcessUID
      description: Parent process unique identifier.
      type: String
    - contextPath: SentinelOne.Event.User
      description: User assigned to the event.
      type: String
    - contextPath: SentinelOne.Event.Time
      description: Start time of the process.
      type: Date
    - contextPath: SentinelOne.Event.ParentProcessName
      description: Parent process name.
      type: String
    - contextPath: SentinelOne.Event.SiteName
      description: Site name.
      type: String
    - contextPath: SentinelOne.Event.EventType
      description: The event type.
      type: String
    - contextPath: SentinelOne.Event.Endpoint
      description: The agent name (endpoint).
      type: String
    - contextPath: SentinelOne.Event.IntegrityLevel
      description: Process integrity level.
      type: String
    - contextPath: SentinelOne.Event.CMD
      description: Process CMD.
      type: String
    - contextPath: SentinelOne.Event.ProcessName
      description: Process name.
      type: String
    - contextPath: SentinelOne.Event.ProcessDisplayName
      description: Process display name.
      type: String
  - arguments:
    - description: 'A free-text search term, will match applicable attributes (sub-string
        match). Note: A device''s physical addresses will only be matched if they
        start with the search term  (not if they contain the search term).'
      name: query
    - description: A CSV list of agents IDs to shutdown.
      name: agent_id
    - description: The ID of the network group.
      name: group_id
    description: Sends a shutdown command to all agents that match the input filter.
    name: sentinelone-shutdown-agent
    outputs:
    - contextPath: SentinelOne.Agent.ID
      description: The ID of the agent that was shutdown.
      type: String
  - arguments:
    - description: 'A free-text search term, will match applicable attributes (sub-string
        match). Note: A device''s physical addresses will only be matched if they
        start with the search term  (not if they contain the search term).'
      name: query
    - description: A CSV list of agents IDs to shutdown.
      name: agent_id
    - description: The ID of the network group.
      name: group_id
    description: Sends an uninstall command to all agents that match the input filter.
    name: sentinelone-uninstall-agent
  dockerimage: demisto/python3:3.7.3.286
  isfetch: true
  runonce: false
  script: |2-




    ''' IMPORTS '''

    import json
    import requests
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS '''

    TOKEN: str
    SERVER: str
    FETCH_TIME: str
    BASE_URL: str
    FETCH_THREAT_RANK: int
    FETCH_LIMIT: int
    USE_SSL: bool
    HEADERS: dict

    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, params={}, data=None):
        LOG(f'Attempting {method} request to {BASE_URL + url_suffix}\nWith params:{params}\nWith body:\n{data}')
        res = requests.request(
            method,
            BASE_URL + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=HEADERS
        )
        if res.status_code not in {200}:
            try:
                errors = ''
                for error in res.json().get('errors'):
                    errors = '\n' + errors + error.get('detail')
                raise ValueError(
                    f'Error in API call to Sentinel One [{res.status_code}] - [{res.reason}] \n'
                    f'Error details: [{errors}]'
                )
            except Exception:
                raise ValueError(f'Error in API call to Sentinel One [{res.status_code}] - [{res.reason}]')
        try:
            return res.json()
        except ValueError:
            return None


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Performs basic get request to get activities types.
        """
        http_request('GET', 'activities/types')
        return True


    def get_activities_request(created_after=None, user_emails=None, group_ids=None, created_until=None,
                               activities_ids=None, include_hidden=None, created_before=None, threats_ids=None,
                               activity_types=None, user_ids=None, created_from=None, created_between=None, agent_ids=None,
                               limit=None):
        endpoint_url = 'activities'

        params = {
            'created_at__gt': created_after,
            'userEmails': user_emails,
            'groupIds': group_ids,
            'created_at__lte': created_until,
            'ids': activities_ids,
            'includeHidden': include_hidden,
            'created_at__lt': created_before,
            'threatIds': threats_ids,
            'activityTypes': activity_types,
            'userIds': user_ids,
            'created_at__gte': created_from,
            'createdAt_between': created_between,
            'agentIds': agent_ids,
            'limit': limit
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_activities_command():
        """
        Get a list of activities.
        """
        context = {}
        context_entries = []
        contents = []
        headers = ['ID', 'Primary description', 'Data', 'User ID', 'Created at', 'Updated at', 'Threat ID']

        created_after = demisto.args().get('created_after')
        user_emails = demisto.args().get('user_emails')
        group_ids = argToList(demisto.args().get('group_ids', []))
        created_until = demisto.args().get('created_until')
        activities_ids = argToList(demisto.args().get('activities_ids', []))
        include_hidden = demisto.args().get('include_hidden')
        created_before = demisto.args().get('created_before')
        threats_ids = argToList(demisto.args().get('threats_ids', []))
        activity_types = argToList(demisto.args().get('activity_types', []))
        user_ids = argToList(demisto.args().get('user_ids', []))
        created_from = demisto.args().get('created_from')
        created_between = demisto.args().get('created_between')
        agent_ids = argToList(demisto.args().get('agent_ids', []))
        limit = int(demisto.args().get('limit', 50))

        activities = get_activities_request(created_after, user_emails, group_ids, created_until, activities_ids,
                                            include_hidden, created_before, threats_ids,
                                            activity_types, user_ids, created_from, created_between, agent_ids, limit)
        if activities:
            for activity in activities:
                contents.append({
                    'ID': activity.get('id'),
                    'Created at': activity.get('createdAt'),
                    'Primary description': activity.get('primaryDescription'),
                    'User ID': activity.get('userId'),
                    'Data': activity.get('data'),
                    'Threat ID': activity.get('threatId'),
                    'Updated at': activity.get('updatedAt')
                })

                context_entries.append({
                    'Hash': activity.get('hash'),
                    'ActivityType': activity.get('activityType'),
                    'OsFamily': activity.get('osFamily'),
                    'PrimaryDescription': activity.get('primaryDescription'),
                    'Comments': activity.get('comments'),
                    'AgentUpdatedVersion': activity.get('agentUpdatedVersion'),
                    'UserID': activity.get('userId'),
                    'ID': activity.get('id'),
                    'Data': activity.get('data'),
                    'CreatedAt': activity.get('createdAt'),
                    'SecondaryDescription': activity.get('secondaryDescription'),
                    'ThreatID': activity.get('threatId'),
                    'GroupID': activity.get('groupId'),
                    'UpdatedAt': activity.get('updatedAt'),
                    'Description': activity.get('description'),
                    'AgentID': activity.get('agentId'),
                    'SiteID': activity.get('siteId')
                })

            context['SentinelOne.Activity(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One Activities', contents, headers, removeNull=True),
            'EntryContext': context
        })


    def get_groups_request(group_type=None, group_ids=None, group_id=None, is_default=None, name=None, query=None,
                           rank=None, limit=None):
        endpoint_url = 'groups'

        params = {
            'type': group_type,
            'groupIds': group_ids,
            'id': group_id,
            'isDefault': is_default,
            'name': name,
            'query': query,
            'rank': rank,
            'limit': limit
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_groups_command():
        """
        Gets the group data.
        """

        context = {}
        contents = []
        headers = ['ID', 'Name', 'Type', 'Creator', 'Creator ID', 'Created at', 'Rank']

        group_type = demisto.args().get('type')
        group_id = demisto.args().get('id')
        group_ids = argToList(demisto.args().get('group_ids', []))
        is_default = demisto.args().get('is_default')
        name = demisto.args().get('name')
        query = demisto.args().get('query')
        rank = demisto.args().get('rank')
        limit = int(demisto.args().get('limit', 50))

        groups = get_groups_request(group_type, group_id, group_ids, is_default, name, query, rank, limit)
        if groups:
            for group in groups:
                contents.append({
                    'ID': group.get('id'),
                    'Type': group.get('type'),
                    'Name': group.get('name'),
                    'Creator ID': group.get('creatorId'),
                    'Creator': group.get('creator'),
                    'Created at': group.get('createdAt'),
                    'Rank': group.get('rank')
                })

            context['SentinelOne.Group(val.ID && val.ID === obj.ID)'] = groups

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One Groups', contents, headers, removeNull=True),
            'EntryContext': context
        })


    def delete_group_request(group_id=None):
        endpoint_url = f'groups/{group_id}'

        response = http_request('DELETE', endpoint_url)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def delete_group():
        """
        Deletes a group by ID.
        """
        group_id = demisto.args().get('group_id')

        delete_group_request(group_id)
        demisto.results('The group was deleted successfully')


    def move_agent_request(group_id, agents_id):
        endpoint_url = f'groups/{group_id}/move-agents'

        payload = {
            "filter": {
                "agentIds": agents_id
            }
        }

        response = http_request('PUT', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def move_agent_to_group_command():
        """
        Move agents to a new group.
        """
        group_id = demisto.args().get('group_id')
        agents_id = argToList(demisto.args().get('agents_ids', []))
        context = {}

        agents_groups = move_agent_request(group_id, agents_id)

        # Parse response into context & content entries
        if agents_groups.get('agentsMoved') and int(agents_groups.get('agentsMoved')) > 0:
            agents_moved = True
        else:
            agents_moved = False
        date_time_utc = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')
        context_entries = contents = {
            'Date': date_time_utc,
            'AgentsMoved': agents_groups.get('agentsMoved'),
            'AffectedAgents': agents_moved
        }

        context['SentinelOne.Agent(val.Date && val.Date === obj.Date)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Moved Agents \n' + 'Total of: ' + str(
                agents_groups.get('AgentsMoved')) + ' agents were Moved successfully', contents, removeNull=True),
            'EntryContext': context
        })


    def get_agent_processes_request(agents_ids=None):
        endpoint_url = 'agents/processes'

        params = {
            'ids': agents_ids
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_agent_processes():
        """
        Retrieve running processes for a specific agent.
        Note: This feature is obsolete and an empty array will always be returned
        """
        headers = ['ProcessName', 'StartTime', 'Pid', 'MemoryUsage', 'CpuUsage', 'ExecutablePath']
        contents = []
        context = {}
        agents_ids = demisto.args().get('agents_ids')

        processes = get_agent_processes_request(agents_ids)

        if processes:
            for process in processes:
                contents.append({
                    'ProcessName': process.get('processName'),
                    'CpuUsage': process.get('cpuUsage'),
                    'MemoryUsage': process.get('memoryUsage'),
                    'StartTime': process.get('startTime'),
                    'ExecutablePath': process.get('executablePath'),
                    'Pid': process.get('pid')
                })
            context['SentinelOne.Agent(val.Pid && val.Pid === obj.Pid)'] = processes

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One Agent Processes', contents, headers, removeNull=True),
            'EntryContext': context
        })


    def get_threats_command():
        """
        Gets a list of threats.
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        content_hash = demisto.args().get('content_hash')
        mitigation_status = argToList(demisto.args().get('mitigation_status'))
        created_before = demisto.args().get('created_before')
        created_after = demisto.args().get('created_after')
        created_until = demisto.args().get('created_until')
        created_from = demisto.args().get('created_from')
        resolved = bool(strtobool(demisto.args().get('resolved', 'false')))
        display_name = demisto.args().get('display_name_like')
        query = demisto.args().get('query', '')
        threat_ids = argToList(demisto.args().get('threat_ids', []))
        limit = int(demisto.args().get('limit', 20))
        classifications = argToList(demisto.args().get('classifications', []))
        rank = int(demisto.args().get('rank', 0))

        # Make request and get raw response
        threats = get_threats_request(content_hash, mitigation_status, created_before, created_after, created_until,
                                      created_from, resolved, display_name, query, threat_ids, limit, classifications)

        # Parse response into context & content entries
        if threats:
            for threat in threats:
                threat_rank = threat.get('rank')
                try:
                    threat_rank = int(threat_rank)
                except TypeError:
                    threat_rank = 0
                if not rank or (rank and threat_rank >= rank):
                    contents.append({
                        'ID': threat.get('id'),
                        'Agent Computer Name': threat.get('agentComputerName'),
                        'Created Date': threat.get('createdDate'),
                        'Site ID': threat.get('siteId'),
                        'Classification': threat.get('classification'),
                        'Mitigation Status': threat.get('mitigationStatus'),
                        'Agent ID': threat.get('agentId'),
                        'Site Name': threat.get('siteName'),
                        'Rank': threat.get('rank'),
                        'Marked As Benign': threat.get('markedAsBenign'),
                        'File Content Hash': threat.get('fileContentHash')
                    })
                    context_entries.append({
                        'ID': threat.get('id'),
                        'AgentComputerName': threat.get('agentComputerName'),
                        'CreatedDate': threat.get('createdDate'),
                        'SiteID': threat.get('siteId'),
                        'Classification': threat.get('classification'),
                        'MitigationStatus': threat.get('mitigationStatus'),
                        'AgentID': threat.get('agentId'),
                        'Rank': threat.get('rank'),
                        'MarkedAsBenign': threat.get('markedAsBenign'),
                        'FileContentHash': threat.get('fileContentHash'),
                        'InQuarantine': threat.get('inQuarantine'),
                        'FileMaliciousContent': threat.get('fileMaliciousContent'),
                        'ThreatName': threat.get('threatName'),
                        'FileSha256': threat.get('fileSha256'),
                        'AgentOsType': threat.get('agentOsType'),
                        'Description': threat.get('description'),
                        'FileDisplayName': threat.get('fileDisplayName'),
                        'FilePath': threat.get('filePath'),
                        'Username': threat.get('username')

                    })

            context['SentinelOne.Threat(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': threats,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Getting Threat List \n' + 'Provides summary information and '
                                                                                       'details for all the threats that '
                                                                                       'matched your search criteria.',
                                             contents, removeNull=True),
            'EntryContext': context
        })


    def get_threats_request(content_hash=None, mitigation_status=None, created_before=None, created_after=None,
                            created_until=None, created_from=None, resolved=None, display_name=None, query=None,
                            threat_ids=None, limit=None, classifications=None):
        endpoint_url = 'threats'

        params = {
            'contentHash': content_hash,
            'mitigationStatuses': mitigation_status,
            'createdAt__lt': created_before,
            'createdAt__gt': created_after,
            'createdAt__lte': created_until,
            'createdAt__gte': created_from,
            'resolved': resolved,
            'displayName__like': display_name,
            'query': query,
            'ids': threat_ids,
            'limit': limit,
            'classifications': classifications,
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_hash_command():
        """
        Get hash reputation and classification.
        """
        # Init main vars
        headers = ['Hash', 'Rank', 'ClassificationSource', 'Classification']
        # Get arguments
        hash_ = demisto.args().get('hash')
        type_ = get_hash_type(hash_)
        if type_ == 'Unknown':
            return_error('Enter a valid hash format.')
        # Make request and get raw response
        hash_reputation = get_hash_reputation_request(hash_)
        reputation = hash_reputation.get('data', {})
        contents = {
            'Rank': reputation.get('rank'),
            'Hash': hash_
        }
        # try get classification - might return 404 (classification is not mandatory)
        try:
            hash_classification = get_hash_classification_request(hash_)
            classification = hash_classification.get('data', {})
            contents['ClassificationSource'] = classification.get('classificationSource')
            contents['Classification'] = classification.get('classification')
        except ValueError as e:
            if '404' in str(e):  # handling case classification not found for the specific hash
                contents['Classification'] = 'No classification was found.'
            else:
                raise e

        # Parse response into context & content entries
        title = 'Sentinel One - Hash Reputation and Classification \n' + \
                'Provides hash reputation (rank from 0 to 10):'

        context = {
            'SentinelOne.Hash(val.Hash && val.Hash === obj.Hash)': contents
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers, removeNull=True),
            'EntryContext': context
        })


    def get_hash_reputation_request(hash_):
        endpoint_url = f'hashes/{hash_}/reputation'

        response = http_request('GET', endpoint_url)
        return response


    def get_hash_classification_request(hash_):
        endpoint_url = f'hashes/{hash_}/classification'

        response = http_request('GET', endpoint_url)
        return response


    def mark_as_threat_command():
        """
        Mark suspicious threats as threats
        """
        # Init main vars
        headers = ['ID', 'Marked As Threat']
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        threat_ids = argToList(demisto.args().get('threat_ids'))
        target_scope = demisto.args().get('target_scope')

        # Make request and get raw response
        affected_threats = mark_as_threat_request(threat_ids, target_scope)

        # Parse response into context & content entries
        if affected_threats.get('affected') and int(affected_threats.get('affected')) > 0:
            title = 'Total of ' + str(affected_threats.get('affected')) + ' provided threats were marked successfully'
            affected = True
        else:
            affected = False
            title = 'No threats were marked'
        for threat_id in threat_ids:
            contents.append({
                'Marked As Threat': affected,
                'ID': threat_id,
            })
            context_entries.append({
                'MarkedAsThreat': affected,
                'ID': threat_id,
            })

        context['SentinelOne.Threat(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Marking suspicious threats as threats \n' + title, contents,
                                             headers, removeNull=True),
            'EntryContext': context
        })


    def mark_as_threat_request(threat_ids, target_scope):
        endpoint_url = 'threats/mark-as-threat'

        payload = {
            "filter": {
                "ids": threat_ids
            },
            "data": {
                "targetScope": target_scope
            }
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def mitigate_threat_command():
        """
        Apply a mitigation action to a group of threats
        """
        # Init main vars
        headers = ['ID', 'Mitigation Action', 'Mitigated']
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        threat_ids = argToList(demisto.args().get('threat_ids'))
        action = demisto.args().get('action')

        # Make request and get raw response
        mitigated_threats = mitigate_threat_request(threat_ids, action)

        # Parse response into context & content entries
        if mitigated_threats.get('affected') and int(mitigated_threats.get('affected')) > 0:
            mitigated = True
            title = 'Total of ' + str(mitigated_threats.get('affected')) + ' provided threats were mitigated successfully'
        else:
            mitigated = False
            title = 'No threats were mitigated'
        for threat_id in threat_ids:
            contents.append({
                'Mitigated': mitigated,
                'ID': threat_id,
                'Mitigation Action': action
            })
            context_entries.append({
                'Mitigated': mitigated,
                'ID': threat_id,
                'Mitigation': {
                    'Action': action
                }
            })

        context['SentinelOne.Threat(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Mitigating threats \n' + title, contents, headers,
                                             removeNull=True),
            'EntryContext': context
        })


    def mitigate_threat_request(threat_ids, action):
        endpoint_url = f'threats/mitigate/{action}'

        payload = {
            "filter": {
                "ids": threat_ids
            }
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def resolve_threat_command():
        """
        Mark threats as resolved
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        threat_ids = argToList(demisto.args().get('threat_ids'))

        # Make request and get raw response
        resolved_threats = resolve_threat_request(threat_ids)

        # Parse response into context & content entries
        if resolved_threats.get('affected') and int(resolved_threats.get('affected')) > 0:
            resolved = True
            title = 'Total of ' + str(resolved_threats.get('affected')) + ' provided threats were resolved successfully'
        else:
            resolved = False
            title = 'No threats were resolved'

        for threat_id in threat_ids:
            contents.append({
                'Resolved': resolved,
                'ID': threat_id
            })
            context_entries.append({
                'Resolved': resolved,
                'ID': threat_id
            })

        context['SentinelOne.Threat(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Resolving threats \n' + title, contents, removeNull=True),
            'EntryContext': context
        })


    def resolve_threat_request(threat_ids):
        endpoint_url = 'threats/mark-as-resolved'

        payload = {
            "filter": {
                "ids": threat_ids
            }
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_white_list_command():
        """
        List all white items matching the input filter
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        item_ids = argToList(demisto.args().get('item_ids', []))
        os_types = argToList(demisto.args().get('os_types', []))
        exclusion_type = demisto.args().get('exclusion_type')
        limit = int(demisto.args().get('limit', 10))

        # Make request and get raw response
        exclusion_items = get_white_list_request(item_ids, os_types, exclusion_type, limit)

        # Parse response into context & content entries
        if exclusion_items:
            for exclusion_item in exclusion_items:
                contents.append({
                    'ID': exclusion_item.get('id'),
                    'Type': exclusion_item.get('type'),
                    'CreatedAt': exclusion_item.get('createdAt'),
                    'Value': exclusion_item.get('value'),
                    'Source': exclusion_item.get('source'),
                    'UserID': exclusion_item.get('userId'),
                    'UpdatedAt': exclusion_item.get('updatedAt'),
                    'OsType': exclusion_item.get('osType'),
                    'UserName': exclusion_item.get('userName'),
                    'Mode': exclusion_item.get('mode')
                })
                context_entries.append({
                    'ID': exclusion_item.get('id'),
                    'Type': exclusion_item.get('type'),
                    'CreatedAt': exclusion_item.get('createdAt'),
                    'Value': exclusion_item.get('value'),
                    'Source': exclusion_item.get('source'),
                    'UserID': exclusion_item.get('userId'),
                    'UpdatedAt': exclusion_item.get('updatedAt'),
                    'OsType': exclusion_item.get('osType'),
                    'UserName': exclusion_item.get('userName'),
                    'Mode': exclusion_item.get('mode')
                })

            context['SentinelOne.Exclusions(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Listing exclusion items \n'
                                             + 'provides summary information and details for all the exclusion items that '
                                               'matched your search criteria.', contents, removeNull=True),
            'EntryContext': context
        })


    def get_white_list_request(item_ids, os_types, exclusion_type, limit):
        endpoint_url = 'exclusions'

        params = {
            "ids": item_ids,
            "osTypes": os_types,
            "type": exclusion_type,
            "limit": limit
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def create_white_item_command():
        """
        Create white item.
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []
        title = ''

        # Get arguments
        group_ids = argToList(demisto.args().get('group_ids', []))
        site_ids = argToList(demisto.args().get('site_ids', []))
        exclusion_type = demisto.args().get('exclusion_type')
        exclusion_value = demisto.args().get('exclusion_value')
        os_type = demisto.args().get('os_type')
        description = demisto.args().get('description')
        exclusion_mode = demisto.args().get('exclusion_mode')
        path_exclusion_type = demisto.args().get('path_exclusion_type')

        # Make request and get raw response
        new_item = create_exclusion_item_request(exclusion_type, exclusion_value, os_type, description, exclusion_mode,
                                                 path_exclusion_type, group_ids, site_ids)

        # Parse response into context & content entries
        if new_item:
            title = 'Sentinel One - Adding an exclusion item \n' + \
                    'The provided item was successfully added to the exclusion list'
            contents.append({
                'ID': new_item.get('id'),
                'Type': new_item.get('type'),
                'Created At': new_item.get('createdAt')
            })
            context_entries.append({
                'ID': new_item.get('id'),
                'Type': new_item.get('type'),
                'CreatedAt': new_item.get('createdAt')
            })

            context['SentinelOne.Exclusion(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, removeNull=True),
            'EntryContext': context
        })


    def create_exclusion_item_request(exclusion_type, exclusion_value, os_type, description, exclusion_mode,
                                      path_exclusion_type, group_ids, site_ids):
        endpoint_url = 'exclusions'

        payload = {
            "filter": {
                "groupIds": group_ids,
                "siteIds": site_ids
            },
            "data": {
                "type": exclusion_type,
                "value": exclusion_value,
                "osType": os_type,
                "description": description,
                "mode": exclusion_mode
            }
        }

        if path_exclusion_type:
            payload['data']['pathExclusionType'] = path_exclusion_type

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')[0]
        return {}


    def get_sites_command():
        """
        List all sites with filtering options
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        updated_at = demisto.args().get('updated_at')
        query = demisto.args().get('query')
        site_type = demisto.args().get('site_type')
        features = demisto.args().get('features')
        state = demisto.args().get('state')
        suite = demisto.args().get('suite')
        admin_only = bool(strtobool(demisto.args().get('admin_only', 'false')))
        account_id = demisto.args().get('account_id')
        site_name = demisto.args().get('site_name')
        created_at = demisto.args().get('created_at')
        limit = int(demisto.args().get('limit', 50))
        site_ids = argToList(demisto.args().get('site_ids', []))

        # Make request and get raw response
        sites, all_sites = get_sites_request(updated_at, query, site_type, features, state, suite, admin_only, account_id,
                                             site_name, created_at, limit, site_ids)

        # Parse response into context & content entries
        if sites:
            for site in sites:
                contents.append({
                    'ID': site.get('id'),
                    'Creator': site.get('creator'),
                    'Name': site.get('name'),
                    'Type': site.get('siteType'),
                    'Account Name': site.get('accountName'),
                    'State': site.get('state'),
                    'Health Status': site.get('healthStatus'),
                    'Suite': site.get('suite'),
                    'Created At': site.get('createdAt'),
                    'Expiration': site.get('expiration'),
                    'Unlimited Licenses': site.get('unlimitedLicenses'),
                    'Total Licenses': all_sites.get('totalLicenses'),
                    'Active Licenses': all_sites.get('activeLicenses')
                })
                context_entries.append({
                    'ID': site.get('id'),
                    'Creator': site.get('creator'),
                    'Name': site.get('name'),
                    'Type': site.get('siteType'),
                    'AccountName': site.get('accountName'),
                    'State': site.get('state'),
                    'HealthStatus': site.get('healthStatus'),
                    'Suite': site.get('suite'),
                    'CreatedAt': site.get('createdAt'),
                    'Expiration': site.get('expiration'),
                    'UnlimitedLicenses': site.get('unlimitedLicenses'),
                    'TotalLicenses': all_sites.get('totalLicenses'),
                    'ActiveLicenses': all_sites.get('activeLicenses')
                })

            context['SentinelOne.Site(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - Gettin List of Sites \n' + 'Provides summary information and '
                                                                                        'details for all sites that matched'
                                                                                        ' your search criteria.', contents,
                                             removeNull=True),
            'EntryContext': context
        })


    def get_sites_request(updated_at, query, site_type, features, state, suite, admin_only, account_id, site_name,
                          created_at, limit, site_ids):
        endpoint_url = 'sites'

        params = {
            "updatedAt": updated_at,
            "query": query,
            "siteType": site_type,
            "features": features,
            "state": state,
            "suite": suite,
            "adminOnly": admin_only,
            "accountId": account_id,
            "name": site_name,
            "createdAt": created_at,
            "limit": limit,
            "siteIds": site_ids
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data').get('sites'), response.get('data').get('allSites')
        return {}


    def get_site_command():
        """
        Get a specific site by ID
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []
        title = ''

        # Get arguments
        site_id = demisto.args().get('site_id')

        # Make request and get raw response
        site = get_site_request(site_id)

        # Parse response into context & content entries
        if site:
            title = 'Sentinel One - Summary About Site: ' + site_id + '\n' + \
                    'Provides summary information and details for specific site ID'
            contents.append({
                'ID': site.get('id'),
                'Creator': site.get('creator'),
                'Name': site.get('name'),
                'Type': site.get('siteType'),
                'Account Name': site.get('accountName'),
                'State': site.get('state'),
                'Health Status': site.get('healthStatus'),
                'Suite': site.get('suite'),
                'Created At': site.get('createdAt'),
                'Expiration': site.get('expiration'),
                'Unlimited Licenses': site.get('unlimitedLicenses'),
                'Total Licenses': site.get('totalLicenses'),
                'Active Licenses': site.get('activeLicenses'),
                'AccountID': site.get('accountId'),
                'IsDefault': site.get('isDefault')
            })
            context_entries.append({
                'ID': site.get('id'),
                'Creator': site.get('creator'),
                'Name': site.get('name'),
                'Type': site.get('siteType'),
                'AccountName': site.get('accountName'),
                'State': site.get('state'),
                'HealthStatus': site.get('healthStatus'),
                'Suite': site.get('suite'),
                'CreatedAt': site.get('createdAt'),
                'Expiration': site.get('expiration'),
                'UnlimitedLicenses': site.get('unlimitedLicenses'),
                'TotalLicenses': site.get('totalLicenses'),
                'ActiveLicenses': site.get('activeLicenses'),
                'AccountID': site.get('accountId'),
                'IsDefault': site.get('isDefault')
            })

            context['SentinelOne.Site(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, removeNull=True),
            'EntryContext': context
        })


    def get_site_request(site_id):
        endpoint_url = f'sites/{site_id}'

        response = http_request('GET', endpoint_url)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def reactivate_site_command():
        """
        Reactivate specific site by ID
        """
        # Init main vars
        context = {}
        title = ''

        # Get arguments
        site_id = demisto.args().get('site_id')

        # Make request and get raw response
        site = reactivate_site_request(site_id)

        # Parse response into context & content entries
        if site:
            title = 'Sentinel One - Reactivated Site: ' + site_id + '\n' + 'Site has been reactivated successfully'
            contents = {
                'ID': site.get('id'),
                'Reactivated': site.get('success')
            }
            context_entries = {
                'ID': site.get('id'),
                'Reactivated': site.get('success')
            }

            context['SentinelOne.Site(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, removeNull=True),
            'EntryContext': context
        })


    def reactivate_site_request(site_id):
        endpoint_url = f'sites/{site_id}/reactivate'

        response = http_request('PUT', endpoint_url)
        if response.get('errors'):
            return_error(response.get('errors'))
        if response.get('data'):
            return response.get('data')
        return {}


    def get_threat_summary_command():
        """
        Get dashboard threat summary
        """
        # Init main vars
        context = {}
        title = ''

        # Get arguments
        site_ids = argToList(demisto.args().get('site_ids', []))
        group_ids = argToList(demisto.args().get('group_ids', []))

        # Make request and get raw response
        threat_summary = get_threat_summary_request(site_ids, group_ids)

        # Parse response into context & content entries
        if threat_summary:
            title = 'Sentinel One - Dashboard Threat Summary'
            contents = {
                'Active': threat_summary.get('active'),
                'Total': threat_summary.get('total'),
                'Mitigated': threat_summary.get('mitigated'),
                'Suspicious': threat_summary.get('suspicious'),
                'Blocked': threat_summary.get('blocked')
            }

            context_entries = {
                'Active': threat_summary.get('active'),
                'Total': threat_summary.get('total'),
                'Mitigated': threat_summary.get('mitigated'),
                'Suspicious': threat_summary.get('suspicious'),
                'Blocked': threat_summary.get('blocked')
            }

            context['SentinelOne.Threat(val && val === obj)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, removeNull=True),
            'EntryContext': context
        })


    def get_threat_summary_request(site_ids, group_ids):
        endpoint_url = 'private/threats/summary'

        params = {
            "siteIds": site_ids,
            "groupIds": group_ids
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    # Agents Commands


    def list_agents_command():
        """
        List all agents matching the input filter
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []

        # Get arguments
        active_threats = demisto.args().get('min_active_threats')
        computer_name = demisto.args().get('computer_name')
        scan_status = demisto.args().get('scan_status')
        os_type = demisto.args().get('os_type')
        created_at = demisto.args().get('created_at')

        # Make request and get raw response
        agents = list_agents_request(active_threats, computer_name, scan_status, os_type, created_at)

        # Parse response into context & content entries
        if agents:
            for agent in agents:
                contents.append({
                    'ID': agent.get('id'),
                    'Network Status': agent.get('networkStatus'),
                    'Agent Version': agent.get('agentVersion'),
                    'Is Decomissioned': agent.get('isDecommissioned'),
                    'Is Active': agent.get('isActive'),
                    'Last ActiveDate': agent.get('lastActiveDate'),
                    'Registered At': agent.get('registeredAt'),
                    'External IP': agent.get('externalIp'),
                    'Threat Count': agent.get('activeThreats'),
                    'Encrypted Applications': agent.get('encryptedApplications'),
                    'OS Name': agent.get('osName'),
                    'Computer Name': agent.get('computerName'),
                    'Domain': agent.get('domain'),
                    'Created At': agent.get('createdAt'),
                    'Site Name': agent.get('siteName')
                })
                context_entries.append({
                    'ID': agent.get('id'),
                    'NetworkStatus': agent.get('networkStatus'),
                    'AgentVersion': agent.get('agentVersion'),
                    'IsDecomissioned': agent.get('isDecommissioned'),
                    'IsActive': agent.get('isActive'),
                    'LastActiveDate': agent.get('lastActiveDate'),
                    'RegisteredAt': agent.get('registeredAt'),
                    'ExternalIP': agent.get('externalIp'),
                    'ThreatCount': agent.get('activeThreats'),
                    'EncryptedApplications': agent.get('encryptedApplications'),
                    'OSName': agent.get('osName'),
                    'ComputerName': agent.get('computerName'),
                    'Domain': agent.get('domain'),
                    'CreatedAt': agent.get('createdAt'),
                    'SiteName': agent.get('siteName')
                })

            context['SentinelOne.Agents(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Sentinel One - List of Agents \n Provides summary information and details for'
                                             ' all the agents that matched your search criteria',
                                             contents, removeNull=True),
            'EntryContext': context
        })


    def list_agents_request(active_threats, computer_name, scan_status, os_type, created_at):
        endpoint_url = 'agents'

        params = {
            "activeThreats__gt": active_threats,
            "computerName": computer_name,
            "scanStatus": scan_status,
            "osType": os_type,
            "createdAt__gte": created_at
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_agent_command():
        """
        Get single agent via ID
        """
        # Init main vars
        contents = []
        context = {}
        context_entries = []
        title = ''

        # Get arguments
        agent_id = demisto.args().get('agent_id')

        # Make request and get raw response
        agent = get_agent_request(agent_id)

        # Parse response into context & content entries
        if agent:
            title = 'Sentinel One - Get Agent Details \nProvides details for the following agent ID : ' + agent_id
            contents.append({
                'ID': agent.get('id'),
                'Network Status': agent.get('networkStatus'),
                'Agent Version': agent.get('agentVersion'),
                'Is Decomissioned': agent.get('isDecommissioned'),
                'Is Active': agent.get('isActive'),
                'Last ActiveDate': agent.get('lastActiveDate'),
                'Registered At': agent.get('registeredAt'),
                'External IP': agent.get('externalIp'),
                'Threat Count': agent.get('activeThreats'),
                'Encrypted Applications': agent.get('encryptedApplications'),
                'OS Name': agent.get('osName'),
                'Computer Name': agent.get('computerName'),
                'Domain': agent.get('domain'),
                'Created At': agent.get('createdAt'),
                'Site Name': agent.get('siteName')
            })
            context_entries.append({
                'ID': agent.get('id'),
                'NetworkStatus': agent.get('networkStatus'),
                'AgentVersion': agent.get('agentVersion'),
                'IsDecomissioned': agent.get('isDecommissioned'),
                'IsActive': agent.get('isActive'),
                'LastActiveDate': agent.get('lastActiveDate'),
                'RegisteredAt': agent.get('registeredAt'),
                'ExternalIP': agent.get('externalIp'),
                'ThreatCount': agent.get('activeThreats'),
                'EncryptedApplications': agent.get('encryptedApplications'),
                'OSName': agent.get('osName'),
                'ComputerName': agent.get('computerName'),
                'Domain': agent.get('domain'),
                'CreatedAt': agent.get('createdAt'),
                'SiteName': agent.get('siteName')
            })

            context['SentinelOne.Agent(val.ID && val.ID === obj.ID)'] = context_entries

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, removeNull=True),
            'EntryContext': context
        })


    def get_agent_request(agent_id):
        endpoint_url = 'agents'

        params = {
            "ids": [agent_id]
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')[0]
        return {}


    def connect_to_network_request(agents_id):
        endpoint_url = 'agents/actions/connect'

        payload = {
            'filter': {
                'ids': agents_id
            }
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response
        return {}


    def connect_agent_to_network():
        """
        Sends a "connect to network" command to all agents matching the input filter.
        """
        # Get arguments
        agents_id = demisto.args().get('agent_id')

        # Make request and get raw response
        agents = connect_to_network_request(agents_id)
        agents_affected = agents.get('data', {}).get('affected', 0)

        # Parse response into context & content entries
        if agents_affected > 0:
            network_status = get_agent_request(agents_id)
            contents = {
                'NetworkStatus': network_status.get('networkStatus'),
                'ID': agents_id
            }
        else:
            return_error('No agents were connected to the network.')

        context = {
            'SentinelOne.Agent(val.ID && val.ID === obj.ID)': contents
        }

        return_outputs(
            f'{agents_affected} agent(s) successfully connected to the network.',
            context,
            agents
        )


    def disconnect_from_network_request(agents_id):
        endpoint_url = 'agents/actions/disconnect'

        payload = {
            'filter': {
                'ids': agents_id
            }
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        else:
            return response


    def disconnect_agent_from_network():
        """
        Sends a "disconnect from network" command to all agents matching the input filter.
        """
        # Get arguments
        agents_id = demisto.args().get('agent_id')

        # Make request and get raw response
        agents = disconnect_from_network_request(agents_id)
        agents_affected = agents.get('data', {}).get('affected', 0)

        # Parse response into context & content entries
        if agents_affected > 0:
            network_status = get_agent_request(agents_id)
            contents = {
                'NetworkStatus': network_status.get('networkStatus'),
                'ID': agents_id
            }
        else:
            return_error('No agents were disconnected from the network.')

        context = {
            'SentinelOne.Agent(val.ID && val.ID === obj.ID)': contents
        }

        return_outputs(
            f'{agents_affected} agent(s) successfully disconnected from the network.',
            context,
            agents
        )


    def broadcast_message_request(message, is_active=None, group_id=None, agent_id=None, domain=None):
        filters = {}
        endpoint_url = 'agents/actions/broadcast'

        if is_active:
            filters['isActive'] = is_active
        if group_id:
            filters['groupIds'] = group_id
        if agent_id:
            filters['ids'] = agent_id
        if domain:
            filters['domains'] = domain

        payload = {
            'data': {
                'message': message
            },
            'filter': filters
        }
        response = http_request('POST', endpoint_url, data=json.dumps(payload))

        if response.get('errors'):
            return_error(response.get('errors'))
        else:
            return response


    def broadcast_message():
        """
        Broadcasts a message to all agents matching the input filter.
        """
        message = demisto.args().get('message')
        is_active = bool(demisto.args().get('active_agent'))
        group_id = demisto.args().get('group_id')
        agent_id = demisto.args().get('agent_id')
        domain = demisto.args().get('domain')

        broadcast_message = broadcast_message_request(message, is_active=is_active, group_id=group_id, agent_id=agent_id,
                                                      domain=domain)

        agents_affected = broadcast_message.get('data', {}).get('affected', 0)
        if agents_affected > 0:
            demisto.results('The message was successfully delivered to the agent(s)')
        else:
            return_error('No messages were sent. Verify that the inputs are correct.')


    def shutdown_agents_request(query, agent_id, group_id):
        endpoint_url = 'agents/actions/shutdown'
        filters = {}

        if query:
            filters['query'] = query
        if agent_id:
            filters['ids'] = agent_id
        if group_id:
            filters['groupIds'] = group_id

        payload = {
            'filter': filters
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        else:
            return response


    def shutdown_agents():
        """
        Sends a shutdown command to all agents matching the input filter
        """
        query = demisto.args().get('query', '')

        agent_id = argToList(demisto.args().get('agent_id'))
        group_id = argToList(demisto.args().get('group_id'))
        if not (agent_id or group_id):
            return_error('Expecting at least one of the following arguments to filter by: agent_id, group_id.')

        affected_agents = shutdown_agents_request(query, agent_id, group_id)
        agents = affected_agents.get('data', {}).get('affected', 0)
        if agents > 0:
            demisto.results(f'Shutting down {agents} agent(s).')
        else:
            return_error('No agents were shutdown.')


    def uninstall_agent_request(query=None, agent_id=None, group_id=None):
        endpoint_url = 'agents/actions/uninstall'
        filters = {}

        if query:
            filters['query'] = query
        if agent_id:
            filters['ids'] = agent_id
        if group_id:
            filters['groupIds'] = group_id

        payload = {
            'filter': filters
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        else:
            return response


    def uninstall_agent():
        """
        Sends an uninstall command to all agents matching the input filter.
        """
        query = demisto.args().get('query', '')

        agent_id = argToList(demisto.args().get('agent_id'))
        group_id = argToList(demisto.args().get('group_id'))
        if not (agent_id or group_id):
            return_error('Expecting at least one of the following arguments to filter by: agent_id, group_id.')

        affected_agents = shutdown_agents_request(query, agent_id, group_id)
        agents = affected_agents.get('data', {}).get('affected', 0)
        if agents > 0:
            demisto.results(f' Uninstall was sent to {agents} agent(s).')
        else:
            return_error('No agents were affected.')


    # Event Commands

    def create_query_request(query, from_date, to_date):
        endpoint_url = 'dv/init-query'
        payload = {
            'query': query,
            'fromDate': from_date,
            'toDate': to_date
        }

        response = http_request('POST', endpoint_url, data=json.dumps(payload))
        if response.get('errors'):
            return_error(response.get('errors'))
        else:
            return response.get('data', {}).get('queryId')


    def create_query():
        query = demisto.args().get('query')
        from_date = demisto.args().get('from_date')
        to_date = demisto.args().get('to_date')

        query_id = create_query_request(query, from_date, to_date)

        context_entries = {
            'Query': query,
            'FromDate': from_date,
            'ToDate': to_date,
            'QueryID': query_id
        }

        context = {
            'SentinelOne.Query(val.QueryID && val.QueryID === obj.QueryID)': context_entries
        }
        return_outputs('The query ID is ' + str(query_id), context, query_id)


    def get_events_request(query_id=None, limit=None):
        endpoint_url = 'dv/events'

        params = {
            'query_id': query_id,
            'limit': limit
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_events():
        """
        Get all Deep Visibility events from query
        """
        contents = []
        event_standards = []
        headers = ['EventType', 'AgentName', 'SiteName', 'User', 'Time', 'AgentOS', 'ProcessID', 'ProcessUID',
                   'ProcessName', 'MD5', 'SHA256']
        query_id = demisto.args().get('query_id')
        limit = int(demisto.args().get('limit'))

        events = get_events_request(query_id, limit)
        if events:
            for event in events:
                contents.append({
                    'EventType': event.get('eventType'),
                    'Endpoint': event.get('agentName'),
                    'SiteName': event.get('siteName'),
                    'User': event.get('user'),
                    'Time': event.get('processStartTime'),
                    'AgentOS': event.get('agentOs'),
                    'ProcessID': event.get('pid'),
                    'ProcessUID': event.get('processUniqueKey'),
                    'ProcessName': event.get('processName'),
                    'MD5': event.get('md5'),
                    'SHA256': event.get('sha256')
                })

                event_standards.append({
                    'Type': event.get('eventType'),
                    'Name': event.get('processName'),
                    'ID': event.get('pid'),
                })

            context = {
                'SentinelOne.Event(val.ProcessID && val.ProcessID === obj.ProcessID)': contents,
                'Event': event_standards
            }

            return_outputs(tableToMarkdown('SentinelOne Events', contents, headers, removeNull=True), context, events)
        else:
            demisto.results('No events were found.')


    def get_processes_request(query_id=None, limit=None):
        endpoint_url = 'dv/events/process'

        params = {
            'query_id': query_id,
            'limit': limit
        }

        response = http_request('GET', endpoint_url, params)
        if response.get('errors'):
            return_error(response.get('errors'))
        if 'data' in response:
            return response.get('data')
        return {}


    def get_processes():
        """
        Get Deep Visibility events from query by event type - process
        """
        contents = []
        headers = ['EventType', 'AgentName', 'SiteName', 'User', 'Time', 'ParentProcessID', 'ParentProcessUID',
                   'ProcessName', 'ParentProcessName', 'ProcessDisplayName', 'ProcessID', 'ProcessUID',
                   'SHA1', 'CMD', 'SubsystemType', 'IntegrityLevel', 'ParentProcessStartTime']
        query_id = demisto.args().get('query_id')
        limit = int(demisto.args().get('limit'))

        processes = get_events_request(query_id, limit)
        if processes:
            for process in processes:
                contents.append({
                    'EventType': process.get('eventType'),
                    'Endpoint': process.get('agentName'),
                    'SiteName': process.get('siteName'),
                    'User': process.get('user'),
                    'Time': process.get('processStartTime'),
                    'ParentProcessID': process.get('parentPid'),
                    'ParentProcessUID': process.get('parentProcessUniqueKey'),
                    'ParentProcessName': process.get('parentProcessName'),
                    'ProcessID': process.get('pid'),
                    'ProcessUID': process.get('processUniqueKey'),
                    'ProcessName': process.get('processName'),
                    'ProcessDisplayName': process.get('processDisplayName'),
                    'SHA1': process.get('processImageSha1Hash'),
                    'CMD': process.get('"processCmd'),
                    'SubsystemType': process.get('processSubSystem'),
                    'IntegrityLevel': process.get('processIntegrityLevel'),
                    'ParentProcessStartTime': process.get('parentProcessStartTime')
                })

            context = {
                'SentinelOne.Event(val.ProcessID && val.ProcessID === obj.ProcessID)': contents
            }

            return_outputs(tableToMarkdown('SentinelOne Processes', contents, headers, removeNull=True), context, processes)

        else:
            demisto.results('No processes were found.')


    def fetch_incidents():
        last_run = demisto.getLastRun()
        last_fetch = last_run.get('time')

        # handle first time fetch
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, to_timestamp=True)

        current_fetch = last_fetch
        incidents = []
        last_fetch_date_string = timestamp_to_datestring(last_fetch, '%Y-%m-%dT%H:%M:%S.%fZ')
        threats = get_threats_request(limit=FETCH_LIMIT, created_after=last_fetch_date_string)
        for threat in threats:
            rank = threat.get('rank')
            try:
                rank = int(rank)
            except TypeError:
                rank = 0
            # If no fetch threat rank is provided, bring everything, else only fetch above the threshold
            if rank >= FETCH_THREAT_RANK:
                incident = threat_to_incident(threat)
                incident_date = date_to_timestamp(incident['occurred'], '%Y-%m-%dT%H:%M:%S.%fZ')
                # update last run
                if incident_date > last_fetch:
                    incidents.append(incident)

                if incident_date > current_fetch:
                    current_fetch = incident_date

        demisto.setLastRun({'time': current_fetch})
        demisto.incidents(incidents)


    def threat_to_incident(threat):
        incident = {}
        incident['name'] = 'Sentinel One Threat: ' + threat.get('classification')
        incident['occurred'] = threat.get('createdDate')
        incident['rawJSON'] = json.dumps(threat)
        return incident


    def main():
        ''' PARSE INTEGRATION PARAMETERS '''

        global TOKEN, SERVER, USE_SSL, FETCH_TIME
        global FETCH_THREAT_RANK, FETCH_LIMIT, BASE_URL, HEADERS

        TOKEN = demisto.params().get('token')
        SERVER = demisto.params().get('url')[:-1] if (demisto.params().get('url')
                                                      and demisto.params().get('url').endswith('/')) \
            else demisto.params().get('url')
        USE_SSL = not demisto.params().get('insecure', False)
        FETCH_TIME = demisto.params().get('fetch_time', '3 days')
        FETCH_THREAT_RANK = int(demisto.params().get('fetch_threat_rank', 0))
        FETCH_LIMIT = int(demisto.params().get('fetch_limit', 10))
        BASE_URL = SERVER + '/web/api/v2.0/'
        HEADERS = {
            'Authorization': 'ApiToken ' + TOKEN if TOKEN else 'ApiToken',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }

        ''' COMMANDS MANAGER / SWITCH PANEL '''

        LOG('command is %s' % (demisto.command()))

        try:
            handle_proxy()
            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration test button.
                test_module()
                demisto.results('ok')
            elif demisto.command() == 'fetch-incidents':
                fetch_incidents()
            elif demisto.command() == 'sentinelone-get-activities':
                get_activities_command()
            elif demisto.command() == 'sentinelone-get-threats':
                get_threats_command()
            elif demisto.command() == 'sentinelone-mark-as-threat':
                mark_as_threat_command()
            elif demisto.command() == 'sentinelone-mitigate-threat':
                mitigate_threat_command()
            elif demisto.command() == 'sentinelone-resolve-threat':
                resolve_threat_command()
            elif demisto.command() == 'sentinelone-threat-summary':
                get_threat_summary_command()
            elif demisto.command() == 'sentinelone-get-hash':
                get_hash_command()
            elif demisto.command() == 'sentinelone-get-white-list':
                get_white_list_command()
            elif demisto.command() == 'sentinelone-create-white-list-item':
                create_white_item_command()
            elif demisto.command() == 'sentinelone-get-sites':
                get_sites_command()
            elif demisto.command() == 'sentinelone-get-site':
                get_site_command()
            elif demisto.command() == 'sentinelone-reactivate-site':
                reactivate_site_command()
            elif demisto.command() == 'sentinelone-list-agents':
                list_agents_command()
            elif demisto.command() == 'sentinelone-get-agent':
                get_agent_command()
            elif demisto.command() == 'sentinelone-get-groups':
                get_groups_command()
            elif demisto.command() == 'sentinelone-move-agent':
                move_agent_to_group_command()
            elif demisto.command() == 'sentinelone-delete-group':
                delete_group()
            elif demisto.command() == 'sentinelone-agent-processes':
                get_agent_processes()
            elif demisto.command() == 'sentinelone-connect-agent':
                connect_agent_to_network()
            elif demisto.command() == 'sentinelone-disconnect-agent':
                disconnect_agent_from_network()
            elif demisto.command() == 'sentinelone-broadcast-message':
                broadcast_message()
            elif demisto.command() == 'sentinelone-get-events':
                get_events()
            elif demisto.command() == 'sentinelone-create-query':
                create_query()
            elif demisto.command() == 'sentinelone-get-processes':
                get_processes()
            elif demisto.command() == 'sentinelone-shutdown-agent':
                shutdown_agents()
            elif demisto.command() == 'sentinelone-uninstall-agent':
                uninstall_agent()

        except Exception as e:
            if demisto.command() == 'fetch-incidents':
                LOG(str(e))
                raise
            else:
                return_error(e)


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
