category: Endpoint
commonfields:
  id: Windows Defender Advanced Threat Protection
  version: -1
configuration:
- defaultvalue: https://api.securitycenter.windows.com
  display: Host URL (e.g. https://api.securitycenter.windows.com)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions (?)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: tenant_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions (?)
  name: enc_key
  required: true
  type: 4
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: New
  display: 'Status to filter out alerts for fetching as incidents. The property values
    are: New,InProgress,Resolved (Comma separated values supported, e.g. New,Resolved)'
  name: fetch_status
  required: false
  type: 0
- defaultvalue: Informational,Low,Medium,High
  display: 'Severity to filter out alerts for fetching as incidents. The property
    values are: Informational,Low,Medium,High (Comma separated values supported, e.g.
    Medium,High)'
  name: fetch_severity
  required: false
  type: 0
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Windows Defender Advanced Threat Protection (ATP) is a unified platform
  for preventative protection, post-breach detection, automated investigation, and
  response.
detaileddescription: |
  To allow us access to Windows Defender, an admin has to approve our app using an admin consent flow, by clicking on the following [link](https://oproxy.demisto.ninja/ms-defender-atp).
  After authorizing the Demisto app, you will get an ID, Token, and Key, which should be inserted in the integration instance configuration's corresponding fields.
display: Windows Defender Advanced Threat Protection
image: data:image/png;base64,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
name: Windows Defender Advanced Threat Protection
script:
  commands:
  - arguments:
    - default: true
      description: Machine ID to be used for isolation. e.g. 0a3250e0693a109f1affc9217be9459028aa8426
      name: machine_id
      required: true
    - description: Comment to associate with the action.
      name: comment
      required: true
    - auto: PREDEFINED
      description: Full isolation or selective isolation (Restrict only limited set
        of applications from accessing the network)
      name: isolation_type
      predefined:
      - Full
      - Selective
    description: Isolates a machine from accessing external network.
    execution: true
    name: microsoft-atp-isolate-machine
    outputs:
    - contextPath: MicrosoftATP.Machine.Isolation.Requestor
      description: Machine isolation requestor
      type: string
    - contextPath: MicrosoftATP.Machine.Isolation.RequestorComment
      description: Machine isolation requestor comment
      type: string
    - contextPath: MicrosoftATP.Machine.ID
      description: Machine ID
      type: string
    - contextPath: MicrosoftATP.Machine.Isolation.Isolated
      description: True if machine is isolated, else false
      type: boolean
  - arguments:
    - description: Machine ID to be used to stop the isolation. e.g. 0a3250e0693a109f1affc9217be9459028aa8426
      name: machine_id
      required: true
    - description: Comment to associate with the action.
      name: comment
      required: true
    description: Undo an isolation of a machine
    name: microsoft-atp-unisolate-machine
    outputs:
    - contextPath: MicrosoftATP.Machine.Isolation.Requestor
      description: Machine un-isolation requestor
      type: string
    - contextPath: MicrosoftATP.Machine.Isolation.RequestorComment
      description: Machine un-isolation requestor comment
      type: string
    - contextPath: MicrosoftATP.Machine.ID
      description: Machine ID
      type: Unknown
  - arguments:
    - description: Computer DNS name
      name: hostname
    - description: Machine last external IP address
      name: ip
    - auto: PREDEFINED
      description: Machine risk score
      name: risk_score
      predefined:
      - Low
      - Medium
      - High
    - auto: PREDEFINED
      description: Machine health status
      name: health_status
      predefined:
      - Active
      - Inactive
    description: Retrieves a collection of machines that have communicated with WDATP
      cloud on the last 30 days
    name: microsoft-atp-get-machines
    outputs:
    - contextPath: MicrosoftATP.Machine.ID
      description: Machine ID
      type: string
    - contextPath: MicrosoftATP.Machine.ComputerDNSName
      description: Machine DNS name
      type: string
    - contextPath: MicrosoftATP.Machine.AgentVersion
      description: Machine agent version
      type: string
    - contextPath: MicrosoftATP.Machine.FirstSeen
      description: Machine first seen date
      type: date
    - contextPath: MicrosoftATP.Machine.LastSeen
      description: Machine last seen date
      type: string
    - contextPath: MicrosoftATP.Machine.HelathStatus
      description: Machine health status
      type: string
    - contextPath: MicrosoftATP.Machine.IsAADJoined
      description: True if machine is AAD joined, else false
      type: boolean
    - contextPath: MicrosoftATP.Machine.LastExternalIPAddress
      description: Machine last external IP address
      type: string
    - contextPath: MicrosoftATP.Machine.LastIPAddress
      description: Machine last IP address
      type: string
    - contextPath: MicrosoftATP.Machine.Tags
      description: Machine tags
      type: string
    - contextPath: MicrosoftATP.Machine.OSBuild
      description: Machine OS build
      type: number
    - contextPath: MicrosoftATP.Machine.OSPlatform
      description: Machine OS platform
      type: string
    - contextPath: MicrosoftATP.Machine.RBACGroupID
      description: Machine RBAC group ID
      type: string
    - contextPath: MicrosoftATP.Machine.RiskScore
      description: Machine risk score
      type: string
    - contextPath: MicrosoftATP.Machine.RBACGroupName
      description: Machine RBAC group name
      type: string
    - contextPath: MicrosoftATP.Machine.AADDeviceID
      description: Machine AAD device ID
      type: string
    - contextPath: MicrosoftATP.Machine.OSVersion
      description: Machine OS version
      type: string
    - contextPath: Endpoint.Hostname
      description: Machine DNS name
      type: string
    - contextPath: Endpoint.IPAddress
      description: Machine last IP address
      type: string
    - contextPath: Endpoint.OS
      description: Machine OS platform
      type: string
    - contextPath: Endpoint.OSVersion
      description: Machine OS version
      type: string
  - arguments:
    - description: File hash to get machines related to
      name: file
      required: true
    description: Get a collection of machines related to a given file hash.
    name: microsoft-atp-get-file-related-machines
    outputs:
    - contextPath: MicrosoftATP.Machine.ID
      description: Machine ID
      type: string
    - contextPath: MicrosoftATP.Machine.ComputerDNSName
      description: Machine DNS name
      type: string
    - contextPath: MicrosoftATP.Machine.AgentVersion
      description: Machine agent version
      type: string
    - contextPath: MicrosoftATP.Machine.FirstSeen
      description: Machine first seen date
      type: date
    - contextPath: MicrosoftATP.Machine.LastSeen
      description: Machine last seen date
      type: string
    - contextPath: MicrosoftATP.Machine.HelathStatus
      description: Machine health status
      type: string
    - contextPath: MicrosoftATP.Machine.IsAADJoined
      description: True if machine is AAD joined, else false
      type: boolean
    - contextPath: MicrosoftATP.Machine.LastExternalIPAddress
      description: Machine last external IP address
      type: string
    - contextPath: MicrosoftATP.Machine.LastIPAddress
      description: Machine last IP address
      type: string
    - contextPath: MicrosoftATP.Machine.Tags
      description: Machine tags
      type: string
    - contextPath: MicrosoftATP.Machine.OSBuild
      description: Machine OS build
      type: number
    - contextPath: MicrosoftATP.Machine.OSPlatform
      description: Machine OS platform
      type: string
    - contextPath: MicrosoftATP.Machine.RBACGroupID
      description: Machine RBAC group ID
      type: string
    - contextPath: MicrosoftATP.Machine.RiskScore
      description: Machine risk score
      type: string
    - contextPath: MicrosoftATP.Machine.RBACGroupName
      description: Machine RBAC group name
      type: string
    - contextPath: MicrosoftATP.Machine.AADDeviceID
      description: Machine AAD device ID
      type: string
    - contextPath: MicrosoftATP.Machine.OSVersion
      description: Machine OS version
      type: string
    - contextPath: Endpoint.Hostname
      description: Machine DNS name
      type: string
    - contextPath: Endpoint.IPAddress
      description: Machine last IP address
      type: string
    - contextPath: Endpoint.OS
      description: Machine OS platform
      type: string
    - contextPath: Endpoint.OSVersion
      description: Machine OS version
      type: string
    - contextPath: MicrosoftATP.Machine.RelatedFile
      description: Machine related file hash
      type: string
  - arguments:
    - default: true
      description: Machine id to be used for getting the machine details, e.g. 0a3250e0693a109f1affc9217be9459028aa8426
      name: machine_id
      required: true
    description: Get a machine details by its identity.
    name: microsoft-atp-get-machine-details
    outputs:
    - contextPath: MicrosoftATP.Machine.ID
      description: Machine ID
      type: string
    - contextPath: MicrosoftATP.Machine.ComputerDNSName
      description: Machine DNS name
      type: string
    - contextPath: MicrosoftATP.Machine.AgentVersion
      description: Machine agent version
      type: string
    - contextPath: MicrosoftATP.Machine.FirstSeen
      description: Machine first seen date
      type: date
    - contextPath: MicrosoftATP.Machine.LastSeen
      description: Machine last seen date
      type: string
    - contextPath: MicrosoftATP.Machine.HelathStatus
      description: Machine health status
      type: string
    - contextPath: MicrosoftATP.Machine.IsAADJoined
      description: True if machine is AAD joined, else false
      type: boolean
    - contextPath: MicrosoftATP.Machine.LastExternalIPAddress
      description: Machine last external IP address
      type: string
    - contextPath: MicrosoftATP.Machine.LastIPAddress
      description: Machine last IP address
      type: string
    - contextPath: MicrosoftATP.Machine.Tags
      description: Machine tags
      type: string
    - contextPath: MicrosoftATP.Machine.OSBuild
      description: Machine OS build
      type: number
    - contextPath: MicrosoftATP.Machine.OSPlatform
      description: Machine OS platform
      type: string
    - contextPath: MicrosoftATP.Machine.RBACGroupID
      description: Machine RBAC group ID
      type: string
    - contextPath: MicrosoftATP.Machine.RiskScore
      description: Machine risk score
      type: string
    - contextPath: MicrosoftATP.Machine.RBACGroupName
      description: Machine RBAC group name
      type: string
    - contextPath: MicrosoftATP.Machine.AADDeviceID
      description: Machine AAD device ID
      type: string
    - contextPath: MicrosoftATP.Machine.OSVersion
      description: Machine OS version
      type: string
    - contextPath: Endpoint.Hostname
      description: Machine DNS name
      type: string
    - contextPath: Endpoint.IPAddress
      description: Machine last IP address
      type: string
    - contextPath: Endpoint.OS
      description: Machine OS platform
      type: string
    - contextPath: Endpoint.OSVersion
      description: Machine OS version
      type: string
  - arguments:
    - description: Machine ID to run the scan on
      name: machine_id
      required: true
    - description: Comment to associate with the action
      name: comment
      required: true
    - auto: PREDEFINED
      description: Defines the type of the scan
      name: scan_type
      predefined:
      - Quick
      - Full
      required: true
    description: Initiate Windows Defender Antivirus scan on a machine
    name: microsoft-atp-run-antivirus-scan
  - arguments:
    - auto: PREDEFINED
      description: Alert severity
      name: severity
      predefined:
      - High
      - Medium
      - Low
      - Informational
    - auto: PREDEFINED
      description: Alert status
      name: status
      predefined:
      - New
      - InProgress
      - Resolved
    description: Get a list of alerts present on the system.
    name: microsoft-atp-list-alerts
    outputs:
    - contextPath: MicrosoftATP.Alert.DetectionSource
      description: Alert detection source
      type: string
    - contextPath: MicrosoftATP.Alert.MachineID
      description: Alert machine ID
      type: string
    - contextPath: MicrosoftATP.Alert.Classification
      description: Alert classification
      type: string
    - contextPath: MicrosoftATP.Alert.AlertCreationTime
      description: Alert creation time
      type: date
    - contextPath: MicrosoftATP.Alert.RecommendedAction
      description: Alert recommended action
      type: string
    - contextPath: MicrosoftATP.Alert.LastEventTime
      description: Alert last event time
      type: date
    - contextPath: MicrosoftATP.Alert.Status
      description: Alert status
      type: string
    - contextPath: MicrosoftATP.Alert.FirstEventTime
      description: Alert first event time
      type: string
    - contextPath: MicrosoftATP.Alert.Title
      description: Alert title
      type: string
    - contextPath: MicrosoftATP.Alert.ID
      description: Alert ID
      type: string
    - contextPath: MicrosoftATP.Alert.Description
      description: Alert description
      type: string
    - contextPath: MicrosoftATP.Alert.Severity
      description: Alert severity
      type: string
    - contextPath: MicrosoftATP.Alert.Category
      description: Alert category
      type: string
  - arguments:
    - description: Alert ID to update
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: Alert status to update
      name: status
      predefined:
      - New
      - InProgress
      - Resolved
    - description: Owner of the alert
      name: assigned_to
    - auto: PREDEFINED
      description: Specifies the specification of the alert
      name: classification
      predefined:
      - Unknown
      - FalsePositive
      - TruePositive
    - auto: PREDEFINED
      description: Specifies the determination of the alert
      name: determination
      predefined:
      - NotAvailable
      - Apt
      - Malware
      - SecurityPersonnel
      - SecurityTesting
      - UnwantedSoftware
      - Other
    description: Update the properties of an alert entity
    name: microsoft-atp-update-alert
    outputs:
    - contextPath: MicrosoftATP.Alert.ID
      description: Alert ID
      type: string
    - contextPath: MicrosoftATP.Alert.Status
      description: Alert status
      type: string
    - contextPath: MicrosoftATP.Alert.Classification
      description: Alert classification
      type: string
    - contextPath: MicrosoftATP.Alert.Determination
      description: Alert determination
      type: string
  - arguments:
    - default: true
      description: The query to run.
      name: query
      required: true
    description: 'Allows you to run programmatic queries like in Windows Defender
      ATP Portal (https://securitycenter.windows.com/hunting). Limitations: You can
      only run a query on data from the last 30 days, The results will include a maximum
      of 10,000 rows, The number of executions is limited (up to 15 calls per minute,
      15 minutes of running time every hour and 4 hours of running time a day)'
    name: microsoft-atp-advanced-hunting
    outputs:
    - contextPath: MicrosoftATP.Hunt.Result
      description: Results of the query.
      type: Unknown
  - arguments:
    - description: Id of the machine on which the event was identified. Required.
      name: machine_id
      required: true
    - auto: PREDEFINED
      description: Severity of the alert.
      name: severity
      predefined:
      - Low
      - Medium
      - High
      required: true
    - description: Title for the alert.
      name: title
      required: true
    - description: Description of the alert.
      name: description
      required: true
    - description: Action that is recommended to be taken by security officer when
        analyzing the alert.
      name: recommended_action
      required: true
    - description: The time of the event, as obtained from the advanced query.
      name: event_time
      required: true
    - description: The reportId, as obtained from the advanced query.
      name: report_id
      required: true
    - auto: PREDEFINED
      defaultValue: None
      description: Category of the alert.
      name: category
      predefined:
      - None
      - SuspiciousActivity
      - Malware
      - CredentialTheft
      - Exploit
      - WebExploit
      - DocumentExploit
      - PrivilegeEscalation
      - Persistence
      - RemoteAccessTool
      - CommandAndControl
      - SuspiciousNetworkTraffic
      - Ransomware
      - MalwareDownload
      - Reconnaissance
      - WebFingerprinting
      - Weaponization
      - Delivery
      - SocialEngineering
      - CredentialStealing
      - Installation
      - Backdoor
      - Trojan
      - TrojanDownloader
      - LateralMovement
      - ExplorationEnumeration
      - NetworkPropagation
      - Exfiltration
      - NotApplicable
      - EnterprisePolicy
      - General
    description: Create a new alert entity using event data, as obtained from the
      Advanced Hunting.
    name: microsoft-atp-create-alert
    outputs:
    - contextPath: MicrosoftATP.Alert.MachineID
      description: Alert machine ID
      type: string
    - contextPath: MicrosoftATP.Alert.RecommendedAction
      description: Alert recommended action
      type: string
    - contextPath: MicrosoftATP.Alert.Title
      description: Alert title
      type: string
    - contextPath: MicrosoftATP.Alert.Description
      description: Alert description
      type: string
    - contextPath: MicrosoftATP.Alert.Severity
      description: Alert severity
      type: string
    - contextPath: MicrosoftATP.Alert.Category
      description: Alert category
      type: string
    - contextPath: MicrosoftATP.Alert.ReportID
      description: Alert report ID
      type: string
    - contextPath: MicrosoftATP.Alert.EventTime
      description: Event time of the alert, as created by the user
      type: date
    - contextPath: MicrosoftATP.Alert.ID
      description: ID of the created alert.
      type: string
    - contextPath: MicrosoftATP.Alert.Status
      description: Status of the alert
      type: string
  - arguments:
    - description: ID of the alert.
      name: id
      required: true
    description: Retrieves the user associated to a specific alert.
    name: microsoft-atp-get-alert-related-user
    outputs:
    - contextPath: MicrosoftATP.User.ID
      description: ID of the related user.
      type: string
    - contextPath: MicrosoftATP.User.AlertID
      description: ID of the alert.
      type: string
    - contextPath: MicrosoftATP.User.FirstSeen
      description: First seen date of the related user.
      type: date
    - contextPath: MicrosoftATP.User.LastSeen
      description: Last seen date of the related user.
      type: date
    - contextPath: MicrosoftATP.User.MostPrevalentMachineID
      description: The most prevalent machine ID related to the user.
      type: string
    - contextPath: MicrosoftATP.User.LogonTypes
      description: Types of logon for the related user.
      type: string
    - contextPath: MicrosoftATP.User.LogonCount
      description: Log on machine count.
      type: string
    - contextPath: MicrosoftATP.User.DomainAdmin
      description: Flag for user domain admin - set to true if related user is domain
        admin.
      type: boolean
    - contextPath: MicrosoftATP.User.NetworkUser
      description: Flag for network user only - set to true if related user is only
        network user.
      type: boolean
  dockerimage: demisto/crypto:1.0.0.303
  isfetch: true
  runonce: false
  script: |2-



    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    requests.packages.urllib3.disable_warnings()

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' GLOBAL VARS '''

    SERVER = demisto.params()['url'][:-1] if demisto.params()['url'].endswith('/') else demisto.params()['url']
    BASE_URL = SERVER + '/api'
    TENANT_ID = demisto.params()['tenant_id']
    AUTH_AND_TOKEN_URL = demisto.params()['auth_id'].split('@')
    AUTH_ID = AUTH_AND_TOKEN_URL[0]
    ENC_KEY = demisto.params()['enc_key']
    USE_SSL = not demisto.params().get('insecure', False)
    FETCH_SEVERITY = demisto.params()['fetch_severity'].split(',')
    FETCH_STATUS = demisto.params().get('fetch_status').split(',')
    if len(AUTH_AND_TOKEN_URL) != 2:
        TOKEN_RETRIEVAL_URL = 'https://oproxy.demisto.ninja/obtain-token'  # disable-secrets-detection
    else:
        TOKEN_RETRIEVAL_URL = AUTH_AND_TOKEN_URL[1]
    APP_NAME = 'ms-defender-atp'

    ''' HELPER FUNCTIONS '''


    def epoch_seconds(d=None):
        """
        Return the number of seconds for given date. If no date, return current.
        """
        if not d:
            d = datetime.utcnow()
        return int((d - datetime.utcfromtimestamp(0)).total_seconds())


    def get_encrypted(content: str, key: str) -> str:
        """

        Args:
            content (str): content to encrypt. For a request to Demistobot for a new access token, content should be
                the tenant id
            key (str): encryption key from Demistobot

        Returns:
            encrypted timestamp:content
        """
        def create_nonce() -> bytes:
            return os.urandom(12)

        def encrypt(string: str, enc_key: str) -> bytes:
            """

            Args:
                enc_key (str):
                string (str):

            Returns:
                bytes:
            """
            # String to bytes
            enc_key = base64.b64decode(enc_key)
            # Create key
            aes_gcm = AESGCM(enc_key)
            # Create nonce
            nonce = create_nonce()
            # Create ciphered data
            data = string.encode()
            ct = aes_gcm.encrypt(nonce, data, None)
            return base64.b64encode(nonce + ct)
        now = epoch_seconds()
        encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
        return encrypted


    def get_access_token():
        integration_context = demisto.getIntegrationContext()
        access_token = integration_context.get('access_token')
        valid_until = integration_context.get('valid_until')
        if access_token and valid_until:
            if epoch_seconds() < valid_until:
                return access_token
        headers = {'Accept': 'application/json'}

        dbot_response = requests.post(
            TOKEN_RETRIEVAL_URL,
            headers=headers,
            data=json.dumps({
                'app_name': APP_NAME,
                'registration_id': AUTH_ID,
                'encrypted_token': get_encrypted(TENANT_ID, ENC_KEY)
            }),
            verify=USE_SSL
        )
        if dbot_response.status_code not in {200, 201}:
            msg = 'Error in authentication. Try checking the credentials you entered.'
            try:
                demisto.info('Authentication failure from server: {} {} {}'.format(
                    dbot_response.status_code, dbot_response.reason, dbot_response.text))
                err_response = dbot_response.json()
                server_msg = err_response.get('message')
                if not server_msg:
                    title = err_response.get('title')
                    detail = err_response.get('detail')
                    if title:
                        server_msg = f'{title}. {detail}'
                if server_msg:
                    msg += ' Server message: {}'.format(server_msg)
            except Exception as ex:
                demisto.error('Failed parsing error response - Exception: {}'.format(ex))
            raise Exception(msg)
        try:
            gcloud_function_exec_id = dbot_response.headers.get('Function-Execution-Id')
            demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
            parsed_response = dbot_response.json()
        except ValueError:
            raise Exception(
                'There was a problem in retrieving an updated access token.\n'
                'The response from the Demistobot server did not contain the expected content.'
            )
        access_token = parsed_response.get('access_token')
        expires_in = parsed_response.get('expires_in', 3595)
        time_now = epoch_seconds()
        time_buffer = 5  # seconds by which to shorten the validity period
        if expires_in - time_buffer > 0:
            # err on the side of caution with a slightly shorter access token validity period
            expires_in = expires_in - time_buffer

        demisto.setIntegrationContext({
            'access_token': access_token,
            'valid_until': time_now + expires_in
        })
        return access_token


    def http_request(method, url_suffix, json=None, params=None):

        token = get_access_token()
        r = requests.request(
            method,
            BASE_URL + url_suffix,
            json=json,
            headers={
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            },
            verify=USE_SSL
        )
        if r.status_code not in {200, 201}:
            try:
                error = r.json().get('error')
                msg = error['message'] if 'message' in error else r.reason
                return_error('Error in API call to ATP [%d] - %s' % (r.status_code, msg))
            except ValueError:
                msg = r.text if r.text else r.reason
                return_error('Error in API call to ATP [%d] - %s' % (r.status_code, msg))
        if not r.text:
            return {}
        try:
            return r.json()
        except ValueError:
            return {}


    def alert_to_incident(alert):
        incident = {}
        incident['rawJSON'] = json.dumps(alert)
        incident['name'] = 'Windows Defender ATP Alert ' + alert['id']
        return incident


    def capitalize_first_letter(string):
        return string[:1].upper() + string[1:]


    ''' FUNCTIONS '''


    def isolate_machine_command():

        machine_id = demisto.args().get('machine_id')
        comment = demisto.args().get('comment')
        isolation_type = demisto.args().get('isolation_type')
        response = isolate_machine(machine_id, comment, isolation_type)
        ec = {
            'MicrosoftATP.Machine(val.ID && val.ID === obj.ID)': {
                'ID': machine_id,
                'Isolation': {
                    'Isolated': True,
                    'Requestor': response.get('requestor'),
                    'RequestorComment': response.get('requestorComment')
                }
            }
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'The isolation request has been submitted successfully',
            'EntryContext': ec
        }
        demisto.results(entry)


    def isolate_machine(machine_id, comment, isolation_type):

        cmd_url = '/machines/{}/isolate'.format(machine_id)
        json = {
            'Comment': comment
        }
        if isolation_type:
            json['IsolationType'] = isolation_type
        response = http_request('POST', cmd_url, json=json)
        return response


    def unisolate_machine_command():

        machine_id = demisto.args().get('machine_id')
        comment = demisto.args().get('comment')
        response = unisolate_machine(machine_id, comment)
        ec = {
            'MicrosoftATP.Machine(val.ID && val.ID === obj.ID)': {
                'ID': machine_id,
                'Isolation': {
                    'Isolated': False,
                    'Requestor': response.get('requestor'),
                    'RequestorComment': response.get('requestorComment')
                }
            }
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'The request to stop the isolation has been submitted successfully',
            'EntryContext': ec
        }
        demisto.results(entry)


    def unisolate_machine(machine_id, comment):

        cmd_url = '/machines/{}/unisolate'.format(machine_id)
        json = {
            'Comment': comment
        }
        response = http_request('POST', cmd_url, json=json)
        return response


    def get_machines_command():

        machines = get_machines().get('value', [])

        hostname = demisto.args().get('hostname')
        ip = demisto.args().get('ip')
        risk_score = demisto.args().get('risk_score')
        health_status = demisto.args().get('health_status')

        output = []
        endpoint_context = []

        for machine in machines:
            computer_dns_name = machine.get('computerDnsName')
            last_external_ip = machine.get('lastExternalIpAddress')
            machine_risk_score = machine.get('riskScore')
            machine_health_status = machine.get('healthStatus')
            if (hostname and hostname != computer_dns_name) or (ip and ip != last_external_ip) or \
                    (risk_score and risk_score != machine_risk_score) or \
                    (health_status and health_status != machine_health_status):
                continue
            current_machine_output = {
                'ComputerDNSName': computer_dns_name,
                'ID': machine.get('id'),
                'AgentVersion': machine.get('agentVersion'),
                'FirstSeen': machine.get('firstSeen'),
                'LastSeen': machine.get('lastSeen'),
                'HealthStatus': machine_health_status,
                'IsAADJoined': machine.get('isAadJoined'),
                'LastExternalIPAddress': last_external_ip,
                'LastIPAddress': machine.get('lastIpAddress'),
                'Tags': machine.get('machineTags'),
                'OSBuild': machine.get('osBuild'),
                'OSPlatform': machine.get('osPlatform'),
                'RBACGroupID': machine.get('rbacGroupId'),
                'RiskScore': machine_risk_score
            }
            current_endpoint_output = {
                'Hostname': machine.get('computerDnsName'),
                'IPAddress': machine.get('lastExternalIpAddress'),
                'OS': machine.get('osPlatform')
            }
            rbac_group_name = machine.get('rbacGroupName')
            if rbac_group_name:
                current_machine_output['RBACGroupName'] = rbac_group_name
            aad_device_id = machine.get('aadDeviceId')
            if aad_device_id:
                current_machine_output['AADDeviceID'] = aad_device_id
            os_version = machine.get('osVersion')
            if os_version:
                current_machine_output['OSVersion'] = os_version
                current_endpoint_output['OSVersion'] = os_version
            output.append(current_machine_output)
            endpoint_context.append(current_endpoint_output)

        if output:
            ec = {
                'MicrosoftATP.Machine(val.ID && val.ID === obj.ID)': output,
                'Endpoint(val.Hostname && val.Hostname === obj.Hostname)': endpoint_context
            }

            entry = {
                'Type': entryTypes['note'],
                'Contents': machines,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('Windows Defender ATP machines', output, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found'  # type: ignore
        demisto.results(entry)


    def get_machines():

        cmd_url = '/machines'
        response = http_request('GET', cmd_url)
        return response


    def get_file_related_machines_command():

        file = demisto.args()['file']
        machines = get_file_related_machines(file).get('value', [])
        if machines:
            output = []
            endpoint_context = []
            for machine in machines:
                current_machine_output = {
                    'ComputerDNSName': machine.get('computerDnsName'),
                    'ID': machine.get('id'),
                    'AgentVersion': machine.get('agentVersion'),
                    'FirstSeen': machine.get('firstSeen'),
                    'LastSeen': machine.get('lastSeen'),
                    'HealthStatus': machine.get('healthStatus'),
                    'IsAADJoined': machine.get('isAadJoined'),
                    'LastExternalIPAddress': machine.get('lastExternalIpAddress'),
                    'LastIPAddress': machine.get('lastIpAddress'),
                    'Tags': machine.get('machineTags'),
                    'OSBuild': machine.get('osBuild'),
                    'OSPlatform': machine.get('osPlatform'),
                    'RBACGroupID': machine.get('rbacGroupId'),
                    'RiskScore': machine.get('riskScore'),
                    'RelatedFile': file
                }
                current_endpoint_output = {
                    'Hostname': machine.get('computerDnsName'),
                    'IPAddress': machine.get('lastExternalIpAddress'),
                    'OS': machine.get('osPlatform')
                }
                rbac_group_name = machine.get('rbacGroupName')
                if rbac_group_name:
                    current_machine_output['RBACGroupName'] = rbac_group_name
                aad_device_id = machine.get('aadDeviceId')
                if aad_device_id:
                    current_machine_output['AADDeviceID'] = aad_device_id
                os_version = machine.get('osVersion')
                if os_version:
                    current_machine_output['OSVersion'] = os_version
                    current_endpoint_output['OSVersion'] = os_version
                output.append(current_machine_output)
                endpoint_context.append(current_endpoint_output)

            ec = {
                'MicrosoftATP.Machine(val.ID && val.ID === obj.ID)': output,
                'Endpoint(val.Hostname && val.Hostname === obj.Hostname)': endpoint_context
            }

            title = 'Windows Defender ATP machines related to file {}'.format(file)
            entry = {
                'Type': entryTypes['note'],
                'Contents': machines,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, output, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found'  # type: ignore
        demisto.results(entry)


    def get_file_related_machines(file):

        cmd_url = '/files/{}/machines'.format(file)
        response = http_request('GET', cmd_url)
        return response


    def get_machine_details_command():

        machine_id = demisto.args()['machine_id']
        machine = get_machine_details(machine_id)
        if machine:
            output = []
            endpoint_context = []
            current_machine_output = {
                'ComputerDNSName': machine.get('computerDnsName'),
                'ID': machine.get('id'),
                'AgentVersion': machine.get('agentVersion'),
                'FirstSeen': machine.get('firstSeen'),
                'LastSeen': machine.get('lastSeen'),
                'HealthStatus': machine.get('healthStatus'),
                'IsAADJoined': machine.get('isAadJoined'),
                'LastExternalIPAddress': machine.get('lastExternalIpAddress'),
                'LastIPAddress': machine.get('lastIpAddress'),
                'Tags': machine.get('machineTags'),
                'OSBuild': machine.get('osBuild'),
                'OSPlatform': machine.get('osPlatform'),
                'RBACGroupID': machine.get('rbacGroupId'),
                'RiskScore': machine.get('riskScore')
            }
            current_endpoint_output = {
                'Hostname': machine.get('computerDnsName'),
                'IPAddress': machine.get('lastExternalIpAddress'),
                'OS': machine.get('osPlatform')
            }
            rbac_group_name = machine.get('rbacGroupName')
            if rbac_group_name:
                current_machine_output['RBACGroupName'] = rbac_group_name
            aad_device_id = machine.get('aadDeviceId')
            if aad_device_id:
                current_machine_output['AADDeviceID'] = aad_device_id
            os_version = machine.get('osVersion')
            if os_version:
                current_machine_output['OSVersion'] = os_version
                current_endpoint_output['OSVersion'] = os_version
            output.append(current_machine_output)
            endpoint_context.append(current_endpoint_output)
            ec = {
                'MicrosoftATP.Machine(val.ID && val.ID === obj.ID)': output,
                'Endpoint(val.Hostname && val.Hostname === obj.Hostname)': endpoint_context
            }

            title = 'Windows Defender ATP machine {} details'.format(machine_id)
            entry = {
                'Type': entryTypes['note'],
                'Contents': machine,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, output, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found'  # type: ignore
        demisto.results(entry)


    def get_machine_details(machine_id):

        cmd_url = '/machines/{}'.format(machine_id)
        response = http_request('GET', cmd_url)
        return response


    def block_file_command():

        file_sha1 = demisto.args().get('sha1')
        comment = demisto.args().get('comment')
        title = demisto.args().get('title')
        expiration_time = demisto.args().get('expiration_time')
        severity = demisto.args().get('severity')
        recommended_actions = demisto.args().get('recommended_actions')

        block_file(file_sha1, comment, title, expiration_time, severity, recommended_actions)


    def block_file(file_sha1, comment, title, expiration_time, severity, recommended_actions):

        cmd_url = '/tiindicators'
        json = {
            'indicator': file_sha1,
            'indicatorType': 'FileSha1',
            'action': 'AlertAndBlock',
            'title': title,
            'expirationTime': expiration_time,
            'severity': severity,
            'description': comment,
            'recommendedActions': recommended_actions
        }
        response = http_request('POST', cmd_url, json=json)
        return response


    def get_user_related_machines(user_id):

        cmd_url = '/users/{}/machines'.format(user_id)
        response = http_request('GET', cmd_url)
        return response


    def stop_and_quarantine_file_command():

        machine_id = demisto.args().get('machine_id')
        file_sha1 = demisto.args().get('file')
        comment = demisto.args().get('comment')

        stop_and_quarantine_file(machine_id, file_sha1, comment)


    def stop_and_quarantine_file(machine_id, file_sha1, comment):

        cmd_url = '/machines/{}/stopAndQuarantineFile'.format(machine_id)
        json = {
            'Comment': comment,
            'Sha1': file_sha1
        }
        response = http_request('POST', cmd_url, json=json)
        return response


    def run_antivirus_scan_command():

        machine_id = demisto.args().get('machine_id')
        scan_type = demisto.args().get('scan_type')
        comment = demisto.args().get('comment')

        run_antivirus_scan(machine_id, comment, scan_type)

        demisto.results('Antivirus scan successfully triggered')


    def run_antivirus_scan(machine_id, comment, scan_type):

        cmd_url = '/machines/{}/runAntiVirusScan'.format(machine_id)
        json = {
            'Comment': comment,
            'ScanType': scan_type
        }
        response = http_request('POST', cmd_url, json=json)
        return response


    def list_alerts_command():

        alerts = list_alerts().get('value', [])

        severity = demisto.args().get('severity')
        status = demisto.args().get('status')

        output = []
        for alert in alerts:
            alert_severity = alert.get('severity')
            alert_status = alert.get('status')
            if (severity and severity != alert_severity) or (status and status != alert_status):
                continue
            current_alert_output = {}
            for key, value in alert.items():
                if value or value is False:
                    current_alert_output[capitalize_first_letter(key).replace('Id', 'ID')] = value
            output.append(current_alert_output)

        if output:
            ec = {
                'MicrosoftATP.Alert(val.ID && val.ID === obj.ID)': output
            }

            title = 'Windows Defender ATP alerts'

            entry = {
                'Type': entryTypes['note'],
                'Contents': alerts,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown(title, output, removeNull=True),
                'EntryContext': ec
            }
        else:
            entry = 'No results found'  # type: ignore
        demisto.results(entry)


    def list_alerts():
        cmd_url = '/alerts'
        response = http_request('GET', cmd_url)
        return response


    def update_alert_command():

        alert_id = demisto.args()['alert_id']
        assigned_to = demisto.args().get('assigned_to')
        status = demisto.args().get('status')
        classification = demisto.args().get('classification')
        determination = demisto.args().get('determination')

        if all(v is None for v in [assigned_to, status, classification, determination]):
            return_error('No arguments were given to update the alert')

        json = {}
        context = {
            'ID': alert_id
        }
        if assigned_to:
            json['assignedTo'] = assigned_to
            context['AssignedTo'] = assigned_to
        if status:
            json['status'] = status
            context['Status'] = status
        if classification:
            json['classification'] = classification
            context['Classification'] = classification
        if determination:
            json['determination'] = determination
            context['Determination'] = determination

        update_alert(alert_id, json)

        ec = {
            'MicrosoftATP.Alert(val.ID && val.ID === obj.ID)': context
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': '',
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Alert {0} was updated successfully'.format(alert_id),
            'EntryContext': ec
        }

        demisto.results(entry)


    def update_alert(alert_id, json):
        cmd_url = '/alerts/' + alert_id
        response = http_request('PATCH', cmd_url, json=json)
        return response


    def get_alert_related_domains(alert_id):
        cmd_url = '/alerts/{}/domains'.format(alert_id)
        response = http_request('GET', cmd_url)
        return response


    def get_alert_related_files(alert_id):
        cmd_url = '/alerts/{}/files'.format(alert_id)
        response = http_request('GET', cmd_url)['value']
        return response


    def get_alert_related_ips(alert_id):
        cmd_url = '/alerts/{}/ips'.format(alert_id)
        response = http_request('GET', cmd_url)
        return response


    def get_advanced_hunting_command():
        query = demisto.args().get('query')
        response = get_advanced_hunting(query)
        results = response.get('Results')
        if isinstance(results, list) and len(results) == 1:
            report_id = results[0].get('ReportId')
            if report_id:
                results[0]['ReportId'] = str(report_id)
        ec = {
            'MicrosoftATP.Hunt.Result': results
        }
        hr = tableToMarkdown('Hunt results', results, removeNull=True)

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }

        demisto.results(entry)


    def get_advanced_hunting(query):
        cmd_url = '/advancedqueries/run'
        json = {
            'Query': query
        }
        response = http_request('POST', cmd_url, json=json)
        return response


    def create_alert_command():
        args = demisto.args()
        response = create_alert(
            args.get('machine_id'),
            args.get('severity'),
            args.get('title'),
            args.get('description'),
            args.get('event_time'),
            args.get('report_id'),
            args.get('recommended_action'),
            args.get('category')
        )
        output = {
            'MachineID': response.get('machineId'),
            'RecommendedAction': response.get('recommendedAction'),
            'Title': response.get('title'),
            'Description': response.get('description'),
            'Severity': response.get('severity'),
            'Category': response.get('Category'),
            'ReportID': response.get('reportId'),
            'ID': response.get('id'),
            'Status': response.get('status')
        }
        output = {k: v for k, v in output.items() if v is not None}
        ec = {
            'MicrosoftATP.Alert': output
        }
        hr = tableToMarkdown('Alert created:', output)

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }

        demisto.results(entry)


    def create_alert(machine_id, severity, title, description, event_time, report_id, rec_action, category):
        cmd_url = '/alerts/CreateAlertByReference'
        json = {
            'machineId': machine_id,
            'severity': severity,
            'title': title,
            'description': description,
            'eventTime': event_time,
            'reportId': report_id
        }
        if rec_action:
            json['recommendedAction'] = rec_action
        if category:
            json['category'] = category
        response = http_request('POST', cmd_url, json=json)
        return response


    def get_alert_related_user_command():
        alert_id = demisto.args().get('id')
        response = get_alert_related_user(alert_id)
        output = {
            'ID': response.get('id'),
            'AlertID': alert_id,
            'FirstSeen': response.get('firstSeen'),
            'LastSeen': response.get('lastSeen'),
            'MostPrevalentMachineID': response.get('mostPrevalentMachineId'),
            'LogonTypes': response.get('logonTypes'),
            'LogonCount': response.get('logOnMachinesCount'),
            'DomainAdmin': response.get('isDomainAdmin'),
            'NetworkUser': response.get('isOnlyNetworkUser')
        }
        ec = {
            'MicrosoftATP.User(val.AlertID === obj.AlertID && val.ID === obj.ID)': output
        }
        hr = tableToMarkdown('Alert Related User:', output, removeNull=True)

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }

        demisto.results(entry)


    def get_alert_related_user(alert_id):
        cmd_url = '/alerts/{}/user'.format(alert_id)
        response = http_request('GET', cmd_url)
        return response


    def fetch_incidents():
        last_run = demisto.getLastRun()

        if last_run and last_run['last_alert_fetched_time']:
            last_alert_fetched_time = datetime.strptime(last_run['last_alert_fetched_time'], '%Y-%m-%dT%H:%M:%S.%f')
        else:
            last_alert_fetched_time = datetime.now() - timedelta(days=300)

        previous_ids = last_run.get('last_ids', [])
        latest_creation_time = last_alert_fetched_time

        alerts = list_alerts()['value']
        incidents = []
        last_ids = []

        for alert in alerts:
            # Removing 'Z' from timestamp and converting to datetime
            alert_creation_time = datetime.strptime(alert['alertCreationTime'][:-2], '%Y-%m-%dT%H:%M:%S.%f')
            alert_status = alert['status']
            alert_severity = alert['severity']
            if alert_creation_time >= last_alert_fetched_time and alert_status in FETCH_STATUS and \
                    alert_severity in FETCH_SEVERITY and alert['id'] not in previous_ids:
                incident = alert_to_incident(alert)
                incidents.append(incident)
                if alert_creation_time == latest_creation_time:
                    last_ids.append(alert["id"])
                if alert_creation_time > latest_creation_time:
                    latest_creation_time = alert_creation_time
                    last_ids = [alert['id']]

        if not last_ids:
            last_ids = previous_ids

        demisto.setLastRun({
            'last_alert_fetched_time': datetime.strftime(latest_creation_time, '%Y-%m-%dT%H:%M:%S.%f'),
            "last_ids": last_ids

        })
        demisto.incidents(incidents)


    def test_function():
        token = get_access_token()
        response = requests.get(
            BASE_URL + '/alerts',
            headers={
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            params={'$top': '1'},
            verify=USE_SSL
        )
        try:
            _ = response.json() if response.text else {}
            if not response.ok:
                return_error(f'API call to Windows Advanced Threat Protection. '
                             f'Please check authentication related parameters. '
                             f'[{response.status_code}] - {response.reason}')

            demisto.results('ok')

        except TypeError as ex:
            demisto.debug(str(ex))
            return_error(f'API call to Windows Advanced Threat Protection failed, could not parse result. '
                         f'Please check authentication related parameters. [{response.status_code}]')


    ''' EXECUTION CODE '''

    LOG('command is %s' % (demisto.command(), ))

    try:
        if demisto.command() == 'test-module':
            test_function()

        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()

        elif demisto.command() == 'microsoft-atp-isolate-machine':
            isolate_machine_command()

        elif demisto.command() == 'microsoft-atp-unisolate-machine':
            unisolate_machine_command()

        elif demisto.command() == 'microsoft-atp-get-machines':
            get_machines_command()

        elif demisto.command() == 'microsoft-atp-get-file-related-machines':
            get_file_related_machines_command()

        elif demisto.command() == 'microsoft-atp-get-machine-details':
            get_machine_details_command()

        elif demisto.command() == 'microsoft-atp-block-file':
            block_file_command()

        elif demisto.command() == 'microsoft-atp-stop-and-quarantine-file':
            stop_and_quarantine_file_command()

        elif demisto.command() == 'microsoft-atp-run-antivirus-scan':
            run_antivirus_scan_command()

        elif demisto.command() == 'microsoft-atp-list-alerts':
            list_alerts_command()

        elif demisto.command() == 'microsoft-atp-update-alert':
            update_alert_command()

        elif demisto.command() == 'microsoft-atp-advanced-hunting':
            get_advanced_hunting_command()

        elif demisto.command() == 'microsoft-atp-create-alert':
            create_alert_command()

        elif demisto.command() == 'microsoft-atp-get-alert-related-user':
            get_alert_related_user_command()

    except Exception as e:
        return_error(str(e))
  subtype: python3
  type: python
system: true
