commonfields:
  id: 0d62193f-6d73-477d-8020-2261f7d885c3
  version: 17
name: AwsEC2GetPublicSGRules
script: |
  import json
  import copy

  def get_dict_value(data, key):
      ''' Returns dict value for a given key (case insensitive) '''
      for k in data.keys():
          if k.lower() == key.lower():
              return data[k]

      return None

  def raise_error(error):
      return {
          'Type' : entryTypes['error'],
          'ContentsFormat' : formats['text'],
          'Contents' : str(error)
      }


  def get_ec2_sg_public_rules(group_id, ip_permissions, checked_protocol=None, checked_from_port=None, checked_to_port=None, region=None, include_ipv6=False):
      '''
          Get the list of public
          which can be passed on to the following command:
          aws-ec2-revoke-security-group-ingress-rule
      '''
      public_rules = []
      for rule in ip_permissions:
          # Check protocol
          protocol = get_dict_value(rule, 'IpProtocol')
          if protocol != '-1':
              if checked_protocol.lower() != protocol.lower():
                  continue

          bad_rule = {
              'groupId': group_id,
              'ipProtocol' : protocol
          }

          if region:
              bad_rule.update(region=region)


          # Check the ports
          from_port = get_dict_value(rule, 'FromPort')
          to_port = get_dict_value(rule, 'ToPort')
          if from_port and to_port:
              # If checked_from_port or checked_to_port is not specified
              # it will default to 0-65535
              if not checked_from_port:
                  checked_from_port = 0

              if not checked_to_port:
                  checked_to_port = 65535

              if from_port < checked_from_port and to_port < checked_from_port:
                  continue
              elif from_port > checked_to_port and to_port > checked_to_port:
                  continue

              bad_rule.update({
                  'fromPort' : from_port,
                  'toPort': to_port
              })

          # Process IPV4
          ip_ranges = get_dict_value(rule, 'ipv4Ranges')
          if not ip_ranges:
              ip_ranges = get_dict_value(rule, 'IpRanges')

          if ip_ranges:
              for ip_range in ip_ranges:
                  cidr_ip = get_dict_value(ip_range, 'CidrIp')
                  if cidr_ip == '0.0.0.0/0':
                      tmp = copy.copy(bad_rule)
                      tmp['cidrIp'] = '0.0.0.0/0'
                      public_rules.append(tmp)

          # Process IPv6
          if include_ipv6 == 'yes':
              ip_ranges = get_dict_value(rule, 'Ipv6Ranges')
              if ip_ranges:
                  for ip_range in ip_ranges:
                      cidr_ip = get_dict_value(ip_range, 'CidrIpv6')
                      if cidr_ip == '::/0':
                          tmp = copy.copy(bad_rule)
                          tmp['cidrIp'] = '::/0'
                          public_rules.append(tmp)

      return public_rules


  args = demisto.args()
  ip_perms = args.get('ipPermissions')

  if isinstance(ip_perms, str):
      try:
          ip_perms = json.loads(ip_perms)
      except Exception as e:
          demisto.results(raise_error('Unable to parse ipPermissions. Invalid JSON string'))

  if args.get('fromPort'):
      from_port = int(args.get('fromPort'))
  else:
      from_port = None

  if args.get('toPort'):
      to_port = int(args.get('toPort'))
  else:
      to_port = None

  public_rules = get_ec2_sg_public_rules(
      group_id=args.get('groupId'),
      ip_permissions=ip_perms,
      checked_protocol=args.get('protocol'),
      checked_from_port=from_port,
      checked_to_port=to_port,
      region=args.get('region'),
      include_ipv6=args.get('includeIPv6')
  )


  demisto.results({
      'ContentsFormat': formats['json'],
      'Type': entryTypes['note'],
      'Contents': json.dumps(public_rules),
      'ReadableContentsFormat': formats['markdown'],
      'HumanReadable': tableToMarkdown('Public Security Group Rules', public_rules, ['groupId', 'ipProtocol', 'fromPort', 'toPort', 'cidrIp', 'region']),
      'EntryContext': {'AWS.EC2.SecurityGroup.PublicRules': public_rules}
  })
type: python
tags:
- Amazon Web Services
comment: 'Find Security Group rules which allows ::/0 (IPv4) or 0.0.0.0/0. '
enabled: true
args:
- name: groupId
  required: true
  description: Security Group ID (sg-xxxxxxxxx)
- name: ipPermissions
  required: true
  description: JSON string of the ipPermissions
  isArray: true
- name: protocol
  required: true
  auto: PREDEFINED
  predefined:
  - tcp
  - udp
  - "-1"
  description: Protocol to check. TCP/UDP/All(-1)
- name: fromPort
  description: Lower bound port range to be checked. If fromPort and toPort are not
    specified, all port will be included.
- name: toPort
  description: Upper bound port range to be checked. If fromPort and toPort are not
    specified, all port will be included.
- name: region
  description: Security group region
- name: includeIPv6
  default: true
  auto: PREDEFINED
  predefined:
  - "yes"
  - "no"
  description: Include IPv6 in the result. By default, IPv6 is not included
  defaultValue: "no"
outputs:
- contextPath: AWS.EC2.SecurityGroup.PublicRules
  description: List public Security Group rules
- contextPath: AWS.EC2.SecurityGroup.PublicRules.groupId
  description: Security Group ID
  type: string
- contextPath: AWS.EC2.SecurityGroup.PublicRules.ipProtocol
  description: IP Protocol (TCP/UDP/-1)
  type: string
- contextPath: AWS.EC2.SecurityGroup.PublicRules.fromPort
  description: Security Group rule's lower bound port range
  type: number
- contextPath: AWS.EC2.SecurityGroup.PublicRules.toPort
  description: Security Group rule's upper bound port range
- contextPath: AWS.EC2.SecurityGroup.PublicRules.cidrIp
  description: Security Group rule's CIDR range
- contextPath: AWS.EC2.SecurityGroup.PublicRules.region
  description: Region of the security group
scripttarget: 0
subtype: python3
runonce: false
dockerimage: demisto/python3:3.7.4.977
runas: DBotWeakRole
