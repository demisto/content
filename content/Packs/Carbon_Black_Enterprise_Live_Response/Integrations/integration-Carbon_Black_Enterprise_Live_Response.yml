commonfields:
  id: carbonblackliveresponse
  version: -1
name: carbonblackliveresponse
display: VMware Carbon Black EDR (Live Response API)
category: Endpoint
image: data:image/png;base64,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
description: Collect information and take action on remote endpoints in real time with VMware Carbon Black EDR (Live Response API) (formerly known as Carbon Black Enterprise Live Response).
detaileddescription: "Use Live Response for VMware Carbon Black Endpoint Standard or VMware Carbon Black EDR (previously known as Carbon Black Defense and Carbon Black Response respectively). \n\nFor VMware Carbon Black Endpoint Standard:\nProvide server URL,  'Live Response' API key and connector. \n\nFor VMware Carbon Black EDR:\nProvide server URL and API Token.\n\n\nWhen running Live Response commands (e.g. 'cb-process-kill'), it is possible to pass 'wait-timeout' argument to determine the number of seconds to wait for the command to be executed on Live Response side. Once the command has been executed or wait-time has expired - the command information will be returned to the war room. \nDefault 'wait-time' is 20 seconds.\n"
configuration:
- display: Server URL
  name: serverurl
  defaultvalue: ""
  type: 0
  required: true
- display: API Token (CB Response)
  name: apitoken
  defaultvalue: ""
  type: 4
  required: false
- display: API Key (CB Defense)
  name: apikey
  defaultvalue: ""
  type: 4
  required: false
- display: Connector ID (CB Defense)
  name: connector
  defaultvalue: ""
  type: 0
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: >-
    "use strict";


    /// Global Vars

    let CB_PRODUCT;

    let BASE_URL;

    let AUTH;

    let COMMAND_DATA;

    let SLEEP_BETWEEN_RETRIES = 1000 * 5;

    let DEFAULT_WAIT_TIMEOUT = 1000 * 60 * 2;

    let ERROR_MESSAGE = 'Use Live Response for Cb Defense or Cb Response.\nFor Cb Defense: Provide \'Live Response\' API key and connector.\nFor Cb Response: Provide API Token.';

    //validate the credentials are provided to match only one of the products

    if (params.apitoken && (params.apikey || params.connector) ) {
        throw ERROR_MESSAGE;
    }

    //determain Cb product

    if (params.apitoken) {
        CB_PRODUCT = 'Response';
        BASE_URL = `${params.serverurl}/api/v1/cblr`;
        AUTH = params.apitoken;
        COMMAND_DATA = [
            {to: 'CbSensorID', from: 'sensor_id'},
            {to: 'CbSessionID', from: 'session_id'},
            {to: 'CbCommandID', from: 'id'},
            {to: 'CommandName', from: 'name'},
            {to: 'Status', from: 'status'},
            {to: 'CreateTime', from: 'create_time'},
            {to: 'CommandCompletionTime', from: 'completion'},
            {to: 'OperandObject', from: 'object'},
            {to: 'Result.Desc', from: 'result_desc'},
            {to: 'Result.Type', from: 'result_type'},
            {to: 'Result.Code', from: 'result_code'}
        ];
    } else if (params.apikey && params.connector){
        CB_PRODUCT = 'Defense';
        BASE_URL = `${params.serverurl}/integrationServices/v3/cblr`
        AUTH = params.apikey + '/' + params.connector;
        COMMAND_DATA = [
            {to: 'CbSensorID', from: 'sensor_id'},
            {to: 'CbSessionID', from: 'session_id'},
            {to: 'CbCommandID', from: 'id'},
            {to: 'CommandName', from: 'name'},
            {to: 'Status', from: 'status'},
            {to: 'CreateTime', from: 'create_time'},
            {to: 'CommandCompletionTime', from: 'completion_time'},
            {to: 'OperandObject', from: 'obj.object'},
            {to: 'Result.Desc', from: 'result_desc'},
            {to: 'Result.Type', from: 'result_type'},
            {to: 'Result.Code', from: 'result_code'}
        ];
    } else {
        throw ERROR_MESSAGE;
    }


    /// Base Functions


    function splitCamelCase(str) {
        return str
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace('.', ' ');
    }


    function sendRequest(path, method, requestParams, headers, ignoredStatusCodes) {

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [AUTH];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: method,
            Headers: headers
        };
        let querystring = '';
        if (requestParams) {
            if (typeof requestParams === 'string') {
                querystring = requestParams;
            } else {
                request.Body = JSON.stringify(requestParams);
            }
        }
        let result = http(BASE_URL + path + querystring, request, params.insecure, params.proxy);
        if (!ignoredStatusCodes || ignoredStatusCodes.indexOf(result.StatusCode) === -1) {
            if (result.StatusCode < 200 || result.StatusCode >= 300) {
                if (result.StatusCode === 404) {
                    throw `Cannot find the requested resource\nError message: ${result.Body}\nStatus Code: 404`;
                }
                throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${result.Body}.`;
            }
        }
        return result;
    }


    function sendFileRequest(path, fileId, requestParams, headers, ignoredStatusCodes) {

        if (!headers) {
            headers = {};
        }
        if (!headers['X-Auth-Token']) {
            headers['X-Auth-Token'] = [AUTH];
        }
        if (!headers['Accept']) {
            headers['Accept'] = ['application/json'];
        }
        if (!headers['Content-Type']) {
            headers['Content-Type'] = ['application/json'];
        }

        let request = {
            Method: 'POST',
            Headers: headers
        };

        let result = httpMultipart(BASE_URL + path, fileId, request, requestParams, params.insecure, params.proxy);

        if (result.StatusCode < 200 || result.StatusCode >= 300) {
            if (result.StatusCode === 404) {
                throw `${result.Body} (Status Code: 404)`;
            }
            throw `Request Failed.\nStatus code: ${result.StatusCode}.\nMessage: ${JSON.stringify(result.Body)}`;
        }
        return result;
    }


    function createEntry(title, data, dataMap, contextKeys, headerTransformer) {
        let headers = dataMap.map(cn => cn.to);
        let translatedData = mapObjFunction(dataMap)(data);
        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, headerTransformer);
        let contextData = createContext(translatedData);
        let context = {};
        for (let i = 0 ; i < contextKeys.length; i++) {
            let key = contextKeys[i];
            context[key] = contextData;
        }
        return {
            Type: entryTypes.note,
            Contents: data,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.markdown,
            HumanReadable: humanReadable,
            EntryContext: context,
        };
    }


    /// Cb Live Response Session


    function testModule() {
        let res = sendRequest('/session', 'GET');
        if (res.StatusCode === 200) {
            return 'ok';
        }
        // 405 - Method Not Allowed.
        // This error can raise when using CB Defence; This URL (which is used to list sessions) is theoretically not available for CB Defence. In practice it works for some cases.
        // 401 is the status code used for 'UNAUTHORIZED' error
        if (CB_PRODUCT === 'Defense' && res.StatusCode === 405) {
            return 'ok';
        }
        return `Test failed. Status Code: ${res.StatusCode}`
    }


    const sessionData = [
        {to: 'CbSensorID', from: 'sensor_id'},
        {to: 'CbSessionID', from: 'id'},
        {to: 'Hostname', from: 'hostname'},
        {to: 'Status', from: 'status'},
        {to: 'WaitTimeout', from: 'sensor_wait_timeout'},
        {to: 'SessionTimeout', from: 'session_timeout'},
        {to: 'SupportedCommands', from: 'supported_commands'}
    ];


    function getSessionsRequest(sessionId, sensorId, status) {
        let path = `/session`;
        if (sessionId) {
            path += '/' + sessionId;
        }

        let response = sendRequest(path, 'GET').Body;
        let result;
        try {
            result = JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }

        // If optional sensor argument is given, filter the results by it.
        if (!sessionId && sensorId) {
            sensorId = parseInt(sensorId);
            result = result.filter(session => (parseInt(session.sensor_id) === sensorId));
        }
        if (!sessionId && status) {
            result = result.filter(session => (status.indexOf(session.status) > -1));
        }

        return result;
    }


    function getSessions() {
        let result = getSessionsRequest(args.session, args.sensor, args.status);

        let title = `Cb ${CB_PRODUCT} - Get Sessions`;
        let dataMap = sessionData;
            //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    function createSessionRequest(sensorId, commandTimeout, keepaliveTimeout) {
        let queryParams = {
            sensor_id: parseInt(sensorId)
        };
        if (commandTimeout) {
            queryParams.session_timeout = keepaliveTimeout;
        }
        if (keepaliveTimeout) {
            queryParams.sensor_wait_timeout = commandTimeout;
        }
        let path = CB_PRODUCT === 'Response' ?  '/session' : `/session/${sensorId}`;
        let response = sendRequest(path, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function createSession() {
        let result = createSessionRequest(args.sensor, args['command-timeout'], args['keepalive-timeout']);

        let title = `CB ${CB_PRODUCT} - Create Session`;
        let dataMap = sessionData;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    function createSessionAndWait() {
        let result = createSessionRequest(args.sensor, args['command-timeout'], args['keepalive-timeout']);
        sleep(1000);
        let sessionId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT ;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getSessionsRequest(sessionId, args.sensor);
            let status = result.status.toLowerCase()
            if (status === 'active' ) {
                let title = `CB ${CB_PRODUCT} - Create Session And Wait`;
                let dataMap = sessionData;
                //keep CbResponse context for backward competability
                let contextKeys = [
                    'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
                    'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
                ];
                return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
            } else if (status !== 'pending') {
                throw `Executing session ${sessionId} failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Exceeded timeout.\nNew session for sensor ${args.sensor} was created with ID: ${sessionId}.\nSession status remains '${result.status}'. Wait for session to become active (you may query for session staus with 'cb-session-info').\nIt is recomended to increase wait-timeout for this command.`;
    }


    function closeSessionRequest(sessionId) {
        let queryParams = {
            session_id: sessionId
        };
        queryParams.status = CB_PRODUCT === 'Response' ? 'close' : 'CLOSE';
        let path = CB_PRODUCT === 'Response' ? `/session/${sessionId}` : '/session';
        let response = sendRequest(path, 'PUT', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function closeSession() {
        let result = closeSessionRequest(args.session);
        let title = `CB ${CB_PRODUCT} - Session Closed`;
        let dataMap = sessionData;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)',
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)'
        ];
        // cb response - session will have 'active' value for 'status' field although status is 'closed'
        if (CB_PRODUCT === 'Response') {
            // retrieving closed session info returns inconsistent results (expected to return the updated info with correct status, but in practice this may return an error)
            // do not try to retrieve updated session info, simply change the session status in the result to avoid confusion
            // see https://developer.carbonblack.com/reference/enterprise-response/6.1/live-response-api/#close-sessions
            result.status = 'close'
        }
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    function sessionKeepaliveRequest(sessionId) {
        let response = sendRequest(`/session/${sessionId}/keepalive`, 'GET', undefined, undefined, [404]);

        if (response.StatusCode === 404) {
            throw `Session ${sessionId} has expired and is now closed. Create a new session to continue working.`;
        }

        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response.Body}`;
        }
    }


    function sessionKeepAlive() {
        let result = sessionKeepaliveRequest(args.session);

        let translatedData = mapObjFunction(sessionData)(result);
        let contextData = createContext(translatedData);
        //keep CbResponse context for backward competability
        let context = {
            'CbResponse.Sessions(val.CbSessionID==obj.CbSessionID)': contextData,
            'CbLiveResponse.Sessions(val.CbSessionID==obj.CbSessionID)': contextData
        };

        return {
            Type: entryTypes.note,
            Contents: result,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: `Keepalive successful for session ${args.session}`,
            EntryContext: context,
        };
    }


    function archiveSessionRequest(sessionId) {
        let response = sendRequest(`/session/${sessionId}/archive`, 'GET', undefined, undefined, [500]);
        if (response.StatusCode === 500) {  // Current bug in CBResponse returns 500 for empty sessions
            throw `Session ${sessionId} is empty and so it has no archive.`;
        }
        return response;
    }


    function archiveSession() {
        let response = archiveSessionRequest(args.session);
        let fileEntryId = saveFile(response.Bytes);
        let fileName = `session-${args.session}-archive.zip`;
        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: fileName,
            Contents: fileName
        };
    }

    /// Cb Live Response file operations


    const fileData = [
        {to: 'CbFileID', from: 'id'},
        {to: 'Filename', from: 'file_name'},
        {to: 'Size', from: 'size'},
        {to: 'SizeUploaded', from: 'size_uploaded'},
        {to: 'Status', from: 'status'},
        {to: 'Delete', from: 'delete'}
    ];


    function listFilesRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        let path = `/session/${sessionId}/file`;
        if (fileId) {
            path += '/' + fileId;
        }

        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function listFiles() {
        let result = listFilesRequest(args.session, args['file-id']);

        let title = `CB ${CB_PRODUCT} - List Files`;
        let dataMap = fileData;
        //keep CbResponse context for backward competability
         let contextKeys = [
            'CbResponse.Files(val.CbFileID==obj.CbFileID)',
            'CbLiveResponse.Files(val.CbFileID==obj.CbFileID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    function downloadFileRequest(sessionId, fileId) {
        var headers = {Accept: ['*/*']};
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let path = `/session/${sessionId}/file/${fileId}/content`;
        return sendRequest(path, 'GET', null, headers);
    }


    function downloadFileEntry(sessionId, fileId) {
        let fileInfo = listFilesRequest(sessionId, fileId);
        let fileContentResponse = downloadFileRequest(sessionId, fileId);
        let fileEntryId = saveFile(fileContentResponse.Bytes);
        let fileName = fileInfo.file_name.split('\\').pop();
        return {
            Type: entryTypes.file,
            FileID: fileEntryId,
            File: fileName,
            Contents: fileInfo.file_name
        };
    }


    function downloadFile() {
        return downloadFileEntry(args['session'], args['file-id']);
    }


    function uploadFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let response = sendFileRequest(`/session/${sessionId}/file`, fileId);
        try {
            return JSON.parse(response.Body);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function uploadFile() {
        let result = uploadFileRequest(args.session, args['file-id']);

        let title = `CB ${CB_PRODUCT} - Upload File`;
        let dataMap = fileData;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Files(val.CbFileID==obj.CbFileID)',
            'CbLiveResponse.Files(val.CbFileID==obj.CbFileID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    function deleteFileRequest(sessionId, fileId) {
        if (!sessionId) {
            throw 'Session ID is required';
        }
        if (!fileId) {
            throw 'File ID is required';
        }
        let path = `/session/${sessionId}/file/${fileId}`;
        let response = sendRequest(path, 'DELETE').Body;
    }


    function deleteFile() {
        deleteFileRequest(args.session, args['file-id']);
        return {
            Type: entryTypes.note,
            Contents: `File ${args['file-id']} deleted successfully`,
            ContentsType: formats.text
        };
    }


    /// Cb Live Response Commands


    //generic  function to create a new command

    function createCommandRequest(sessionId, name, timeout, object, compress, wait, workingDir, outputFile, valueData,
                                  valueType, overwrite, offset, getCount) {
        let queryParams = {
            name: name.split('-').join(' ')
        };
        if (timeout) {
            queryParams.timeout = timeout;
        }
        if (object) {
            queryParams.object = object;
        }
        if (compress) {
            queryParams.compress = compress;
        }
        queryParams.wait = true;
        if (wait !== undefined && wait === false) {
            queryParams = wait;
        }
        if (workingDir) {
            queryParams.working_directory = workingDir;
        }
        if (outputFile) {
            queryParams.output_file = outputFile;
        }
        if (valueData) {
            queryParams.value_data = valueData;
        }
        if (valueType) {
            queryParams.value_type = valueType;
        }
        if (overwrite) {
            queryParams.overwrite = overwrite;
        }
        if (offset) {
            queryParams.offset = offset;
        }
        if (getCount) {
            queryParams.get_count = getCount;
        }

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    //TODO: Spec for commands interface

    function createCommand() {
        let result = createCommandRequest(args.session, args.name, args.timeout, args.object, args.compress, args.wait,
            args['working-dir'], args['output-file'], args['value-data'], args['value-type'], args.overwrite, args.offset,
            args['get-count']);

        let title = `CB Response - Run Command ${args.name}`;
        let dataMap = COMMAND_DATA;
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)',
            'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'
        ];
        return createEntry(title, command, dataMap, contextKeys, splitCamelCase);
    }


    function getCommandRequest(sessionId, commandId) {
        let path = `/session/${sessionId}/command/${commandId}`;
        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function getCommandsRequest(sessionId) {
        let path = `/session/${sessionId}/command`;
        let response = sendRequest(path, 'GET').Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function getCommands() {
        let result = getCommandsRequest(args.session);
        let title = `CB ${CB_PRODUCT} - Get Commands`;
        let dataMap = COMMAND_DATA;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)',
            'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    function createCommandAndWait() {
        let result = createCommandRequest(args.session, args.name, args.timeout, args.object, args.compress, args.wait,
            args['working-dir'], args['output-file'], args['value-data'], args['value-type'], args.overwrite, args.offset,
            args['get-count']);
        sleep(1000);
        let commandId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getCommandRequest(args.session, commandId);

            if (result.status === 'complete') {
                let entries = [];
                let title = 'CB Response - Execute Command And Wait';
                let dataMap = COMMAND_DATA;
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': createContext(translatedData)
                };
                entries.push({
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context
                });

                // If we have the command in args then we get info for the command,
                // in this case we want to parse the result:
                let contents = result;
                switch (result.name) {
                    case "directory list":
                        contents = result.files;
                        break;
                    case "process list":
                        contents = result.processes;
                        break;
                }
                logInfo("Here2");
                entries.push({
                    Type: entryTypes.note,
                    Contents: contents,
                    ContentsType: formats.json,
                    // TODO: Add human readable and context for specific commands
                });

                return entries;

            } else if (result.status !== 'pending') {
                throw `Executing command ${commandId} failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Executing command ${commandId} timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }


    function cancelCommandRequest(sessionId, commandId) {
        let queryParams = {cmdid: commandId};
        let response = sendRequest(`/session/${sessionId}/command/${commandId}`, 'PUT', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function cancelCommand() {
        let result = cancelCommandRequest(args.session, args.command);

        let title = `CB ${CB_PRODUCT} - Cancel Command`;
        let dataMap = COMMAND_DATA;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)',
            'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'
        ];
        return createEntry(title, result, dataMap, contextKeys, splitCamelCase);
    }


    /// Explicit Commands


    const directoryData = [
        {to: 'FileAttributes', from: 'attributes'},
        {to: 'CreateTime', from: 'create_time'},
        {to: 'LastAccessTime', from: 'last_access_time'},
        {to: 'LastWriteTime', from: 'last_write_time'},
        {to: 'FileSize', from: 'size'},
        {to: 'FileName', from: 'filename'},
        {to: 'AlternativeName', from:'alt_name'}
    ];


    const processesData = [
        {to: 'ProcessID', from: 'pid'},
        {to: 'CreateTime', from: 'create_time'},
        {to: 'ProcessGuid', from: 'proc_guid'},
        {to: 'Path', from: 'path'},
        {to: 'CommandLine', from: 'command_line'},
        {to: 'SecurityIdentifier', from: 'sid'},
        {to: 'Username', from: 'username'},
        {to: 'Parent', from: 'parent'},
        {to: 'ParentGuid', from: 'parent_guid'}
    ];


    const processData = [
        {to: 'ProcessID', from: 'pid'},
        {to: 'ReturnCode', from: 'return_code'}
    ];


    const memdumpData = [
        {to: 'ReturnCode', from: 'return_code'},
        {to: 'CompressingEnabled', from: 'compressing'},
        {to: 'Complete', from: 'complete'},
        {to: 'PercentDone', from: 'percentdone'},
        {to: 'DumpingInProgress', from: 'dumping'}
    ];


    const regKeysData = [
        {to: 'RegKeyType', from: 'value_type'},
        {to: 'RegKeyName', from: 'value_name'},
        {to: 'RegKeyData', from: 'value_data'}
    ];


    const regKeyData = [
        {to: 'RegKeyType', from: 'value.value_type'},
        {to: 'RegKeyName', from: 'value.value_name'},
        {to: 'RegKeyData', from: 'value.value_data'}
    ];


    function collectRegistryDataToGeneralContext(data) {
        let regKey = CB_PRODUCT === 'Response' ?  data.object : data.obj.object;
        let RegistryKeys = [];
        for (let value of data.values) {
            let entry = {
                Path: regKey,
                Name: value.value_name,
                Value: value.value_data
            };
            RegistryKeys.push(entry);
        }
        return RegistryKeys;
    };


    const commandEntries = {
        'directory list' : function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Directory Listing: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            if (data.status !== 'complete') {
                return commandInfoEntry;
            }
            //create entry to hold directory data
            dataMap = directoryData;
            title = `CB ${CB_PRODUCT} - Directory Listing`;
            contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID).Files'];
            let directoryListEntry = createEntry(
                title,
                data.files,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return [commandInfoEntry, directoryListEntry];
        },
        'put file': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Push File: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'get file': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Get File From Path ${args.path}: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID==obj.CbCommandID&&val.CbSessionID==obj.CbSessionID)'];
            if (data.status === 'complete') {
                dataMap.push({to: 'FileID', from: 'file_id'});
            }
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'kill': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Kill Process ${args.pid}: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'create process' : function(data) {
            let dataMap = COMMAND_DATA;
            if (data.status === 'complete') {
                dataMap = dataMap.concat(processData);
            }
            let title = `CB ${CB_PRODUCT} - Execute Process: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'memdump': function(data) {
            let dataMap = COMMAND_DATA;
            if (data.status === 'complete') {
                dataMap = dataMap.concat(memdumpData);
            }
            let title = `CB ${CB_PRODUCT} - Memdump: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'delete file': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Delete File From Endpoint: Command Status`;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg enum key': function(data) {
            let dataMap =  COMMAND_DATA;
            if (data.status === 'complete'){
                dataMap.push({to: 'SubKeys', from: 'sub_keys'});
            }
            let commandData = mapObjFunction(dataMap)(data);
            let commandMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - Registry Keys: Command Status`,
                commandData,
                dataMap.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            if (data.status !== 'complete' || !data.values) {
                return {
                    Type: entryTypes.note,
                    Contents: data,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: commandMD,
                    EntryContext: {
                        'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': commandData
                    }
                };
            }

            let registryEntry = mapObjFunction(regKeysData)(data.values);
            let registryMD = tableToMarkdown(
                `Registry Values`,
                registryEntry,
                regKeysData.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            //collect registry data for general context
            let generalConetxt = collectRegistryDataToGeneralContext(data);

            return {
                Type: entryTypes.note,
                Contents: data,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: commandMD + '\n\n' + registryMD,
                EntryContext: {
                    'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': commandEntry,
                    'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID).Values': registryEntry,
                    'RegistryKey': generalConetxt
                }
            };
        },
         'reg query value': function(data) {
            let dataMap = COMMAND_DATA;
            if (data.status === 'complete') {
                dataMap = dataMap.concat(regKeyData);
            }
            let commandData = mapObjFunction(dataMap)(data);
            let commandMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - Query Registry Value: Command Status`,
                commandData,
                dataMap.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            let context = {
                'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': commandData
            };
            if (data.status !== 'complete') {
                context.RegistryKey = collectRegistryDataToGeneralContext(data);
            }
            return {
                Type: entryTypes.note,
                Contents: data,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: commandMD,
                EntryContext: context
            };
        },
         'reg create key': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Create Registry Key: Command Status`;;
            let contextKeys = ['CbLiveResponse(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg delete key': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Create Registry Key: Command Status`;;
            let contextKeys = ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg delete values': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Delete Registry Value: Command Status`;;
            let contextKeys =  ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
         'reg set values': function(data) {
            let dataMap = COMMAND_DATA;
            let title = `CB ${CB_PRODUCT} - Delete Registry Value: Command Status`;;
            let contextKeys =  ['CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'];
            let commandInfoEntry = createEntry(
                title,
                data,
                dataMap,
                contextKeys,
                splitCamelCase
            );
            return commandInfoEntry;
        },
        'process list' : function(data) {
            let commandData = mapObjFunction(COMMAND_DATA)(data);
            let commandMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - List Processes: Command Status`,
                commandData,
                COMMAND_DATA.map(cn => cn.to),
                undefined,
                splitCamelCase
            );
            if (data.status !== 'complete') {
                return {
                    Type: entryTypes.note,
                    Contents: data,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: commandMD,
                    EntryContext: {
                       'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': commandData
                    }
                };
            }
            let processes = mapObjFunction(processesData)(data.processes);
            let processesMD = tableToMarkdown(
                `CB ${CB_PRODUCT} - Processes`,
                processes,
                processesData.map(cn => cn.to),
                undefined,
                splitCamelCase
            );

            // collect processes data for general context
            let processesCollection = [];
            for (let process of data.processes) {
                processesCollection.push({
                    'PID': process.pid,
                    'CommandLine': process.command_line,
                    'Path': process.path,
                    'Start Time': process.create_time,
                    'Parent': process.parent
                });
            }

            return {
                Type: entryTypes.note,
                Contents: data,
                ContentsType: formats.json,
                ReadableContentsFormat: formats.markdown,
                HumanReadable: commandMD + '\n\n' + processesMD,
                EntryContext: {
                    'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': commandData,
                    'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID).Process': processes,
                    'Process': processesCollection
                }
            };
        }
    };


    function getCommand() {
        let command = getCommandRequest(args.session, args.command);
        if (commandEntries[command.name]){
            return commandEntries[command.name](command);
        }
        //create generic entry
        let title = `CB ${CB_PRODUCT} - Get Command`;
        let dataMap = COMMAND_DATA;
        //keep CbResponse context for backward competability
        let contextKeys = [
            'CbResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)',
            'CbLiveResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)'
        ];
        return createEntry(
            title,
            result,
            dataMap,
            contextKeys,
            splitCamelCase
        );
    }


    function getCommandInfo(sessionId, commandId, timeout, timeInterval, cancelOnPending) {
        let retries = timeout ? Math.ceil(timeout / timeInterval) : 1;
        //loop to get command info. Stop when command status is no longer 'pending' or when exeeded wait-time.
        let result;
        let curTry = 0;
        while (curTry < retries) {
            result = getCommandRequest(sessionId, commandId);
            if (result.status !== 'pending') {
                return result;
            }
            curTry++;
            sleep(timeInterval);
        }
        if (cancelOnPending && cancelOnPending === 'yes') {
            cancelCommandRequest(sessionId, commandId);
            throw 'Wait-time expired. Canceled command';
        }
        return result;
    }


    function terminateProcess() {
        let result = createCommandRequest(args.session, 'kill', undefined, args.pid, undefined, args.wait);
        sleep(1000);
        let commandId = result.id;
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let retries = Math.ceil(timeout / SLEEP_BETWEEN_RETRIES);

        let curTry = 0;
        while (curTry < retries) {
            let result = getCommandRequest(args.session, commandId);
            if (result.status === 'complete') {
                let title = `CB Response - Terminate Process ${args.pid}`;
                let dataMap = COMMAND_DATA;
                let headers = dataMap.map(cn => cn.to);
                let translatedData = mapObjFunction(dataMap)(result);
                let humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);
                let context = {
                    'CbResponse.Commands(val.CbCommandID == obj.CbCommandID && val.CbSessionID == obj.CbSessionID)': createContext(translatedData)
                };
                return {
                    Type: entryTypes.note,
                    Contents: result,
                    ContentsType: formats.json,
                    ReadableContentsFormat: formats.markdown,
                    HumanReadable: humanReadable,
                    EntryContext: context,
                };
            } else if (result.status !== 'pending') {
                throw `Terminating process failed, status: ${result.status}`;
            }
            sleep(SLEEP_BETWEEN_RETRIES);
            curTry++;
        }
        throw `Terminating process timedout (${timeout / 1000} seconds), increase wait-timeout and try again`;
    }


    function putFileRequest(sessionId, fileId, path) {
        let queryParams = {
            name: 'put file',
            object: path,
            file_id: fileId
        };

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function putFile() {
        let fileInfo = uploadFileRequest(args['session'], args['entry-id']);
        let result = putFileRequest(args['session'], fileInfo.id, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES);
        let commandEntry = commandEntries['put file'](command);
        //add entry to hold gile information
        let title = `CB ${CB_PRODUCT} - File Info`;
        let dataMap = fileData;
        let contextKeys = ['CbLiveResponse.Files(val.CbFileID==obj.CbFileID)'];
        let fileInfoEntry = createEntry(
            title,
            fileInfo,
            dataMap,
            contextKeys,
            splitCamelCase
        );
        return [commandEntry, fileInfoEntry];
    }


    function getFileRequest(sessionId, path, offset, bytes)   {
        let queryParams = {
            name: 'get file',
            object: path,
            offset: offset,
            get_count: bytes
        };

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function getFile() {
        let command = directoryListRequest(args.session, args.path);
        let commandId = command.id;
        try {
            command = getCommandInfo(args.session, commandId, DEFAULT_WAIT_TIMEOUT, SLEEP_BETWEEN_RETRIES);
        }
        catch(err) {
            throw "Failed to get information on the file";
        }
        if (command.status === 'error') {
            throw 'File not found on the endpoint';
        }
        let file = command.files[0];
        let result = getFileRequest(args.session, args.path, 0, file.size);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        let commandEntry = commandEntries['get file'](command);
        let fileEntry = {}
        if (args.download == 'true') {
          if (command.status !== 'complete') {
              return commandEntry;
          }
          //download the file from Cb server and add file entry to the war room
          fileEntry = downloadFileEntry(args['session'], command['file_id']);

          return [commandEntry, fileEntry];
        }

        return commandEntry;
    }


    function directoryListRequest(sessionId, path)   {
        let queryParams = {
            name: 'directory list',
            object: path
        };

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function directoryList() {
        let result = directoryListRequest(args['session'], args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = args['wait-timeout'] ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['directory list'](command);
    }


    function processKillRequest(sessionId, pid) {
        let queryParams = {
            name: 'kill',
            object: pid
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    //equivalent to 'terminateProcess' function

    function processKill() {
        let result = processKillRequest(args['session'], args.pid);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['kill'](command);
    }


    function processExecRequeste(sessionId, path, wait, workingDirectory, outputFile) {
        let queryParams = {
            name: 'create process',
            object: path
        };
        if (wait !== undefined) {
            queryParams.wait = wait;
        }
        if (workingDirectory) {
            queryParams.working_directory = workingDirectory;
        }
        if (outputFile) {
            queryParams.output_file = outputFile;
        }

        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function processExec() {
        if (args.wait) {
            args.wait = args.wait === 'yes';
        }
        let result = processExecRequeste(args['session'], args.path, args['working-directory'], args['output-file']);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['create process'](command);
    }


    function memdumpRequest(sessionId, path, compress) {
        let queryParams = {
            name: 'memdump',
            object: path,
            compress: false //in the API there is a typo that says this field is spelled 'commpress'
        };
        if (compress === 'true') {
            queryParams.compress = true;
        }
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function memdump() {
        let result = memdumpRequest(args['session'], args.path, args.compress);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['memdump'](command);
    }


    function deleteFileFromEndpointRequest(sessionId, path){
        let queryParams = {
            name: 'delete file',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function deleteFileFromEndpoint() {
        let result = deleteFileFromEndpointRequest(args['session'], args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['delete file'](command);
    }


    function regEnumKeyRequest(sessionId, path){
        let queryParams = {
            name: 'reg enum key',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function regEnumKey() {
        let result = regEnumKeyRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg enum key'](command);
    }


    function regQueryValueRequest(sessionId, path){
        let queryParams = {
            name: 'reg query value',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function regQueryValue() {
        let result = regQueryValueRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg query value'](command);
    }


    function regCreateRequest(sessionId, path){
        let queryParams = {
            name: 'reg create key',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function regCreate() {
        let result = regCreateRequest(args.session, args.path, args.timeout);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg create key'](command);
    }


    function regDeleteKeyRequest(sessionId, path){
        let queryParams = {
            name: 'reg delete key',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function regDeleteKey() {
        let result = regDeleteKeyRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg delete key'](command);
    }


    function regDeleteValueRequest(sessionId, path){
        let queryParams = {
            name: 'reg delete value',
            object: path
        };
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function regDeleteValue() {
        let result = regDeleteValueRequest(args.session, args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg delete value'](command);
    }


    function regSetValueRequest(sessionId, path, data, type, overwrite){
        let queryParams = {
            name: 'reg set value',
            object: path,
            value_data: data,
            value_type: type
        }
        if (overwrite) {
            queryParams.overwrite = true;
        }
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function regSetValue() {
        if (args.type = 'REG_MULTI_SZ') {
            args.data = args.data.split(',');
        }
        if (args.overwrite) {
            args.overwrite = args.overwrite === 'yes';
        }
        let result = regSetValueRequest(args.session, args.path, args.data, args.type, args.overwrite);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;

        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['reg set value'](command);
    }


    function listProcessesRequest(sessionId, path){
        let queryParams = {
            name: 'process list'
        }
        let response = sendRequest(`/session/${sessionId}/command`, 'POST', queryParams).Body;
        try {
            return JSON.parse(response);
        } catch (err) {
            throw `Could not parse response.\nError: ${err}.\nResponse: ${response}`;
        }
    }


    function listProcesses() {
        let result = listProcessesRequest(args['session'], args.path);
        //wait for 1 second before trying to get command information
        sleep(1000);
        let timeout = (args['wait-timeout']) ? parseInt(args['wait-timeout']) * 1000 : DEFAULT_WAIT_TIMEOUT;
        let command = getCommandInfo(args['session'], result.id, timeout, SLEEP_BETWEEN_RETRIES, args['cancel-on-timeout']);
        return commandEntries['process list'](command);
    }


    /// Execution


    try {
        switch (command) {
            case 'test-module':
                return testModule();
            case 'cb-list-sessions':
                if (CB_PRODUCT == 'Defense') {
                    throw '\'cb-list-sessions\' is not available for Cb Defense.';
                }
                return getSessions();
            case 'cb-session-info':
                return getSessions();
            case 'cb-session-create':
                return createSession();
            case 'cb-session-create-and-wait':
                return createSessionAndWait();
            case 'cb-session-close':
                return closeSession();
            case 'cb-keepalive':
                return sessionKeepAlive();
            case 'cb-archive':
                if (CB_PRODUCT == 'Defense') {
                    throw '\'cb-archive\' is not available for Cb Defense.';
                }
                return archiveSession();
            case 'cb-list-commands':
                return getCommands();
            case 'cb-command-info':
                return getCommand();
            case 'cb-terminate-process':
                return terminateProcess();
            case 'cb-command-create':
                return createCommand();
            case 'cb-command-create-and-wait':
                return createCommandAndWait();
            case 'cb-command-cancel':
                return cancelCommand();
            case 'cb-file-get':
                return downloadFile();
            case 'cb-list-files':
            case 'cb-file-info':
                return listFiles();
            case 'cb-file-upload':
                return uploadFile();
            case 'cb-file-delete':
                return deleteFile();
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: err.message
        };
    }


    // execute Cb commands

    let closeSessionAfterExecution = false;

    try {
        //validate either sensor or session was passed
        if ((!args.session && !args.sensor) || (args.session && args.sensor)) {
            throw 'Provide either the session ID or the sensor ID';
        }
        if (args.sensor) {
            let session = createSessionRequest(args.sensor);
            let wait = 3 * 1000;
            while (session.status === 'pending' || session.status === 'PENDING') {
                sleep(wait);
                session = getSessionsRequest(session.id);
            }
            if (session.status !== 'active' && session.status !== 'ACTIVE') {
                throw 'Failed to start a new session';
            }
            closeSessionAfterExecution = true;
            args.session = session.id;
        }
        switch (command) {
            case 'cb-process-kill':
                return processKill();
            case 'cb-directory-listing':
                return directoryList();
            case 'cb-process-execute':
                return processExec();
            case 'cb-memdeump':
                return memdump();
            case 'cb-memdump':
                return memdump();
            case 'cb-file-delete-from-endpoint':
                return deleteFileFromEndpoint();
            case 'cb-registry-get-values':
                return regEnumKey();
            case 'cb-registry-query-value':
                return regQueryValue();
            case 'cb-registry-create-key':
                return regCreate();
            case 'cb-registry-delete-key':
                return regDeleteKey();
            case 'cb-registry-delete-value':
                return regDeleteValue();
            case 'cb-registry-set-value':
                return regSetValue();
            case 'cb-process-list':
                return listProcesses();
            case 'cb-get-file-from-endpoint':
                return getFile();
            case 'cb-push-file-to-endpoint':
                return putFile();
        }
    } catch (err) {
        return {
            Type: entryTypes.error,
            Contents: err,
            ContentsType: formats.json,
            ReadableContentsFormat: formats.text,
            HumanReadable: err.message
        };
    } finally {
        if (closeSessionAfterExecution) {
            closeSessionRequest(args.session);
        }
    }


    /// Util methods


    function sleep(ms) {
        var start = new Date().getTime();
        var expire = start + ms;
        while (new Date().getTime() < expire) {
            /*Do nothing*/
        }
        return;
    }
  type: javascript
  commands:
  - name: cb-archive
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID to return the archive of
    description: Archive the given session (If the session has no content it will fail)
  - name: cb-command-cancel
    deprecated: true
    arguments:
    - name: session
      required: true
      description: Session ID of command to cancel
    - name: command
      required: true
      description: Command ID to cancel
    outputs:
    - contextPath: CbLiveResponse.Commands.Status
      description: The Command Status
    - contextPath: CbLiveResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbLiveResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbLiveResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbLiveResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The time the command completed or 0 if still in progres.
    - contextPath: CbLiveResponse.Commands.Result.Desc
      description: Result description
    - contextPath: CbLiveResponse.Commands.esult.Type
      description: Result type
    - contextPath: CbLiveResponse.Commands.Result.Code
      description: Result code
    description: Cancel the given command. Only pending commands can be canceled.
  - name: cb-command-info
    arguments:
    - name: session
      required: true
      description: Session ID of the command
    - name: command
      required: true
      description: Command ID
    description: Display information on command
  - name: cb-file-delete
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    - name: file-id
      required: true
      description: File ID
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Delete a given file in the session from Cb server.
  - name: cb-file-get
    deprecated: false
    arguments:
    - name: session
      required: true
      description: Session ID
    - name: file-id
      required: true
      description: File ID
    description: Download a file from Cb server in a given session.
    outputs:
    - contextPath: File.Size
      description: File size.
    - contextPath: File.SHA1
      description: File SHA1.
    - contextPath: File.SHA256
      description: File SHA256.
    - contextPath: File.Name
      description: File name.
    - contextPath: File.SSDeep
      description: File SSDeep.
    - contextPath: File.EntryID
      description: File EntryID.
    - contextPath: File.Info
      description: File info.
    - contextPath: File.Type
      description: File type.
    - contextPath: File.MD5
      description: File MD5.
    - contextPath: File.Extension
      description: File extension.
  - name: cb-file-info
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    - name: file-id
      description: File ID
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-get-file-from-endpoint.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Get file info for a given file in a session
  - name: cb-file-upload
    deprecated: true
    arguments:
    - name: session
      required: true
      description: Session ID to upload the file through
    - name: file-id
      required: true
      description: File entry id of an attachment to upload.
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-get-file-from-endpoint.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: Uploads the file to the Cb server. Use cb-push-file-to-endpoint instead.
  - name: cb-keepalive
    arguments:
    - name: session
      required: true
      default: true
      description: The session ID to keepalive
    description: Keep the session alive to avoid closing due to timeout
  - name: cb-list-commands
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    description: List the CarbonBlack existing commands for a given session
  - name: cb-list-files
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID
    outputs:
    - contextPath: CbLiveResponse.Files.Filename
      description: The Filename
    - contextPath: CbLiveResponse.Files.Size
      description: The File size
    - contextPath: CbLiveResponse.Files.CbFileID
      description: ID of the file within the Cb Session Storage - use with cb-get-file-from-endpoint.
    - contextPath: CbLiveResponse.Files.Status
      description: File status (0 if no error, another number otherwise)
    - contextPath: CbLiveResponse.Files.Delete
      description: Whether the file was deleted or not
    description: List files in a given session
  - name: cb-list-sessions
    arguments:
    - name: sensor
      description: Sensor ID to filter sessions by
    - name: status
      auto: PREDEFINED
      predefined:
      - active
      - pending
      - timeout
      - inactive
      - close
      description: 'Status to filter by (One of: active, pending, timeout, inactive, close)'
      isArray: true
    outputs:
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    description: List the CarbonBlack sessions
  - name: cb-session-close
    arguments:
    - name: session
      required: true
      description: The session ID to close
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Close the given session
  - name: cb-session-create
    arguments:
    - name: sensor
      required: true
      default: true
      description: Sensor ID to create session for
    - name: command-timeout
      description: Session timeout (If a command will not be issued after this time the session will be closed)
    - name: keepalive-timeout
      description: ' the timeout (in seconds) that a device should wait between commands. If no command is issued over this timeout the device will quit.'
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Create a new CarbonBlack session for a given sensor
  - name: cb-session-create-and-wait
    arguments:
    - name: sensor
      required: true
      default: true
      description: Sensor ID to create session for
    - name: command-timeout
      description: Session timeout (If a command will not be issued after this time the session will be closed)
    - name: keepalive-timeout
      description: Session keepalive timeout (If a keepalive is not issued after this time, the session will close)
    - name: wait-timeout
      description: Time in seconds to wait for session to be active
      defaultValue: "20"
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Create a new CarbonBlack session for a given sensor and wait for it to be active
  - name: cb-session-info
    arguments:
    - name: session
      required: true
      default: true
      description: Session ID to get info for
    outputs:
    - contextPath: CbLiveResponse.Sessions.Status
      description: Session Status
    - contextPath: CbLiveResponse.Sessions.Hostname
      description: Hostname
    - contextPath: CbLiveResponse.Sessions.CbSensorID
      description: Sensor ID
    - contextPath: CbLiveResponse.Sessions.CbSessionID
      description: Session ID
    - contextPath: CbLiveResponse.Sessions.SessionTimeout
      description: Session Timeout
    - contextPath: CbLiveResponse.Sessions.WaitTimeout
      description: Sensor wait timeout
    description: Display session info
  - name: cb-process-kill
    arguments:
    - name: session
      description: 'Session ID. Provide the session ID to run the command with an existing session. '
    - name: pid
      required: true
      description: Process ID to terminate
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The process ID.
    description: Terminates a process at the sensor/endpoint
  - name: cb-directory-listing
    arguments:
    - name: session
      description: The session ID.
    - name: path
      required: true
      description: Path for the directory (e.g. "c:\\Users\\"). Note to end with double backslash.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.DirectoryList.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: the directory listing filter (or path).
    - contextPath: CbLiveResponse.Commands.Files.FileAttributes
      description: List of file attributes.
    - contextPath: CbLiveResponse.Commands.Files.CreateTime
      description: Create time in unix time format.
    - contextPath: CbLiveResponse.Commands.Files.LastAccessTime
      description: Last access time in unix time format.
    - contextPath: CbLiveResponse.Commands.Files.LastWriteTime
      description: Last write time in unix time format.
    - contextPath: CbLiveResponse.Commands.Files.FileSize
      description: The file size.
    - contextPath: CbLiveResponse.Commands.Files.FileName
      description: The file name.
    description: List directories on the endpoint.
  - name: cb-process-execute
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: the path and command line of the executable
    - name: wait
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: An optional parameter to specify whether to wait for the process to complete execution before reporting the result.
    - name: working-directory
      description: An optional parameter to specify the working directory of the executable.
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path and command line of the executable.
    - contextPath: CbLiveResponse.Commands.ReturnCode
      description: the return code of the process (if wait was set to true).
    - contextPath: CbLiveResponse.Commands.ProcessID
      description: The pid of the executed process.
    description: Run executable on the endpoint.
  - name: cb-memdeump
    deprecated: true
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The full path, including file name, to save the resulting memory dump on the endpoint (example - c:\\temp\\dump_file.dmp).
    - name: compress
      description: An optional parameter to specify whether to compress resulting memory dump.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path to save the resulting memory dump (on the endpoint).
    - contextPath: CbLiveResponse.Commands.ReturnCode
      description: Return code of the memory dump process.
    - contextPath: CbLiveResponse.Commands.CompressingEnabled
      description: Boolean flag indicating if compression is enabled.
    - contextPath: CbLiveResponse.Commands.Complete
      description: Boolean flag indicating if memory dump is completed.
    - contextPath: CbLiveResponse.Commands.PercentDone
      description: Percent of the process completed
    - contextPath: CbLiveResponse.Commands.DumpingInProgress
      description: Boolean flag indicating if memory dump is in progress.
    description: Deprecated - use cb-memdump instead.
  - name: cb-command-create
    deprecated: true
    arguments:
    - name: name
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - put-file
      - get-file
      - delete-file
      - directory-list
      - reg-enum-key
      - reg-query-value
      - reg-create-key
      - reg-delete-key
      - reg-delete-value
      - reg-set-value
      - process-list
      - kill
      - create-process
      - memdump
      description: Command name
    - name: timeout
      description: Command timeout
    - name: object
      description: the object the command operates on. This is specific to the command but has meaning in a generic way for logging, and display purposes
    - name: compress
      description: '"true" or "false" - an optional parameter to specify whether to compress resulting memory dump'
    - name: working-dir
      description: An optional parameter to specify the working directory of the executable
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: value-data
      description: the data associated with the registry value
    - name: value-type
      description: the string representation of the registry value type (ie REG_DWORD, REG_QWORD, .)
    - name: overwrite
      description: true or false. An optional parameter to specify whether to overwrite the value if it already exists (default value is false)
    - name: offset
      description: a byte offset to start getting the file. Supports a partial get.
    - name: get-count
      description: the number of bytes to grab
    - name: session
      required: true
      description: Session ID to create command for
    outputs:
    - contextPath: CbLiveResponse.Commands.Status
      description: The Command Status
    - contextPath: CbLiveResponse.Commands.Hostname
      description: The Hostname running the command
    - contextPath: CbLiveResponse.Commands.CbLiveResponse.Commands.CbSensorID
      description: The Sensor ID
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The Command name
    - contextPath: CbLiveResponse.Commands.CbSessionID
      description: The Session ID
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: The Command ID
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: 'Object argument for the CbLive command - e.g. for ''directory list'' this is the path of the dir to list. Full docs: https://github.com/carbonblack/cbapi/tree/master/sensor_apis#command-objects'
    - contextPath: CbLiveResponse.Commands.CreateTime
      description: Command create time
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The time the command completed or 0 if still in progres.
    - contextPath: CbLiveResponse.Commands.Result.Desc
      description: Result description
    - contextPath: CbLiveResponse.Commands.Result.Type
      description: Result type
    - contextPath: CbLiveResponse.Commands.Result.Code
      description: Result code
    description: Create a live response command. Use cb-session-create instead.
  - name: cb-command-create-and-wait
    deprecated: true
    arguments:
    - name: name
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - put-file
      - get-file
      - delete-file
      - directory-list
      - reg-enum-key
      - reg-query-value
      - reg-create-key
      - reg-delete-key
      - reg-delete-value
      - reg-set-value
      - process-list
      - kill
      - create-process
      - memdump
      description: Command name
    - name: timeout
      description: Command timeout
    - name: object
      description: the object the command operates on. This is specific to the command but has meaning in a generic way for logging, and display purposes
    - name: compress
      description: '"true" or "false" - an optional parameter to specify whether to compress resulting memory dump'
    - name: working-dir
      description: An optional parameter to specify the working directory of the executable
    - name: output-file
      description: An option file that STDERR and STDOUT will be redirected to.
    - name: value-data
      description: the data associated with the registry value
    - name: value-type
      description: the string representation of the registry value type (ie REG_DWORD, REG_QWORD, .)
    - name: overwrite
      description: true or false. An optional parameter to specify whether to overwrite the value if it already exists (default value is false)
    - name: offset
      description: a byte offset to start getting the file. Supports a partial get.
    - name: get-count
      description: the number of bytes to grab
    - name: session
      required: true
      description: Session ID to create command for
    - name: wait-timeout
      description: Time to wait in seconds to wait for command to finish executing
      defaultValue: "20"
    description: Create a live response command and wait for it to finish executing
  - name: cb-terminate-process
    deprecated: true
    arguments:
    - name: session
      required: true
      description: Session ID
    - name: pid
      required: true
      description: Process ID to terminate
    - name: wait-timeout
      description: Time to wait in seconds for process to complete termination
      defaultValue: "20"
    description: Terminates a process at the sensor/endpoint
  - name: cb-file-delete-from-endpoint
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The source path of the object to delete.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The source path of the object to delete.
    description: Delete a file from the endpoint.
  - name: cb-registry-get-values
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key to query
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path of the key to queried.
    - contextPath: CbLiveResponse.Commands.Values.RegKeyType
      description: Registry value type.
    - contextPath: CbLiveResponse.Commands.Values.RegKeyName
      description: the name of the registry value.
    - contextPath: CbLiveResponse.Commands.Values.RegKeyData
      description: The data associated with the registry value.
    - contextPath: CbLiveResponse.Commands.SubKeys
      description: List of subkey names.
    description: Enumerate registry values
  - name: cb-registry-query-value
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key + the path of the value (e.g. HKEY_LOCAL_MACHINE\blah\key\value).
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: the path of the key + the path of the value (ie HKEY_LOCAL_MACHINE\blah\key\value).
    - contextPath: CbLiveResponse.Commands.Registry.QueryValue.Values.RegKeyType
      description: Registry value type.
    - contextPath: CbLiveResponse.Commands.RegKeyName
      description: the name of the registry value.
    - contextPath: CbLiveResponse.Commands.RegKeyData
      description: The data associated with the registry value.
    - contextPath: CbLiveResponse.Commands.SubKeys
      description: List of subkey names.
    description: Query for registry value.
  - name: cb-registry-create-key
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The key path to create.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The key path.
    description: Create a new registry key.
  - name: cb-registry-delete-key
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The key path to delete.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: the key path.
    description: Delete registry key.
  - name: cb-registry-delete-value
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key + the path of the value.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The key path.
    description: Delete registry value.
  - name: cb-registry-set-value
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The path of the key + the path of the value.
    - name: data
      required: true
      description: The data to set for the value. Note if the value type REG_MULTI_SZ then multiple values should be separated by a comma (e.g. value1, value2, value3).
    - name: type
      required: true
      description: One of common registry value types (REG_DWORD, REG_QWORD, REG_SZ etc).
    - name: overwrite
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: An optional parameter to specify whether to overwrite the value if it already exists (default value is no).
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The key path.
    description: Set registry value.
  - name: cb-process-list
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Cancel the command if still 'pending' after timeout.
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.Processes.ProcessID
      description: Process ID.
    - contextPath: CbLiveResponse.Commands.Processes.CreateTime
      description: The creation time of the process in unix time.
    - contextPath: CbLiveResponse.Commands.Processes.ProcessGuid
      description: The process guid of the process.
    - contextPath: CbLiveResponse.Commands.Processes.Path
      description: The execution path of the process.
    - contextPath: CbLiveResponse.Commands.Processes.SecurityIdentifier
      description: The Security Identifier (SID) of the default process token.
    - contextPath: CbLiveResponse.Commands.Processes.Username
      description: The username of the default process token.
    - contextPath: CbLiveResponse.Commands.Processes.Parent
      description: The pid (process id ) of the parent.
    - contextPath: CbLiveResponse.Commands.Processes.ParentGuid
      description: The process guid of the parent process.
    description: 'List processes running on the endpoint. '
  - name: cb-get-file-from-endpoint
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The source path of the file.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: download
      description: If "true" will download the file from the CarbonBlack server. Default is "true". Set to false for large files.
      defaultValue: 'true'
      auto: PREDEFINED
      predefined:
      - 'true'
      - 'false'
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The source path of the file.
    - contextPath: CbLiveResponse.Commands.FileID
      description: Unique file ID.
    - contextPath: CbLiveResponse.File.Size
      description: File size.
    - contextPath: CbLiveResponse.File.SHA1
      description: SHA1 hash.
    - contextPath: CbLiveResponse.File.SHA256
      description: SHA256 hash.
    - contextPath: CbLiveResponse.File.Name
      description: File name.
    - contextPath: CbLiveResponse.File.SSDeep
      description: SSDeep hash.
    - contextPath: CbLiveResponse.File.EntryID
      description: File EntryID.
    - contextPath: CbLiveResponse.File.Info
      description: File info.
    - contextPath: CbLiveResponse.File.Type
      description: File type.
    - contextPath: CbLiveResponse.File.MD5
      description: MD5 hash.
    - contextPath: CbLiveResponse.File.Extension
      description: File extension.
    description: |
      Retrieves a file from a path on the endpoint.
      For large files, set the "download" argument to "false". Verify that the command completed by using the !cb-command-info command.
      After the command completes, download the file using the !cb-file-get command.
  - name: cb-push-file-to-endpoint
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provided the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: entry-id
      required: true
      description: The file entry ID.
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from 'pending' to 'in-progress'/'complete').
      defaultValue: "20"
    - name: path
      required: true
      description: The destination path of the file. Include file name and type (e.g. "c:\\Users\\USER\\Desktop\\log.txt").
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command Status ('pending', 'in progress', 'complete', 'error', 'canceled').
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The destination path of the file.
    description: Save a file to a specific path on the endpoint.
  - name: cb-memdump
    arguments:
    - name: session
      description: The session ID.
    - name: sensor
      description: The sensor ID.  Provide the sensor ID to run the command with a new session. The session will be created and closed automatically.
    - name: path
      required: true
      description: The full path, including file name, to save the resulting memory dump on the endpoint, for example, c:\\temp\\dump_file.dmp).
    - name: compress
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Whether to compress resulting memory dump. Can be "rue" or "false".
    - name: wait-timeout
      description: Time to wait (in seconds) for Cb command to be executed (change status from "pending" to "in-progress" or "complete").
    - name: cancel-on-timeout
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Whether to cancel the command if still in "pending" status after timeout. Can be "yes" or "no".
    outputs:
    - contextPath: CbLiveResponse.Commands.CbCommandID
      description: Unique command identifier.
    - contextPath: CbLiveResponse.Commands.CommandName
      description: The command name.
    - contextPath: CbLiveResponse.Commands.Status
      description: The command status.
    - contextPath: CbLiveResponse.Commands.CommandCompletionTime
      description: The command completion time (0 if not complete).
    - contextPath: CbLiveResponse.Commands.OperandObject
      description: The path to save the resulting memory dump (on the endpoint).
    - contextPath: CbLiveResponse.Commands.ReturnCode
      description: Return code of the memory dump process.
    - contextPath: CbLiveResponse.Commands.CompressingEnabled
      description: Whether compression is enabled.
      type: boolean
    - contextPath: CbLiveResponse.Commands.Complete
      description: Whether the memory dump completed.
      type: boolean
    - contextPath: CbLiveResponse.Commands.PercentDone
      description: Percent of the process completed.
    - contextPath: CbLiveResponse.Commands.DumpingInProgress
      description: Whether the memory dump is in progress.
      type: boolean
    description: Executes an endpoint memory dump.
  runonce: false
tests:
- Carbon Black Live Response Test
fromversion: 5.0.0
