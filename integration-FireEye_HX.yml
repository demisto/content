category: Endpoint
commonfields:
  id: FireEye HX
  version: -1
configuration:
- defaultvalue: ""
  display: Server URL (e.g. https://192.168.0.1:3000)
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: Credentials
  name: credentials
  required: true
  type: 9
- defaultvalue: v3
  display: Version
  name: version
  required: true
  type: 0
- defaultvalue: "true"
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
description: FireEye Endpoint Security is an integrated solution that detects what
  others miss and protects endpoint against known and unknown threats. The HX Demisto
  integration provides access to information about endpoints, acquisitions, alerts,
  indicators, and containment. Customers can extract critical data and effectively
  operate security operations automated playbook
detaileddescription: |
  FireEye Endpoint Security is an integrated solution that detects what others miss and protects endpoint against known and unknown threats. The HX Demisto integration provides access to information about endpoints, acquisitions, alerts, indicators, and containment. Customers can extract critical data and effectively operate security operations automated playbook
display: FireEye HX
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADKFJREFUeAHtWntwVcUZ38c55948bgISiORFsAGBm4SHYBWnxQd1Oo5o61C1TuvoPzpKRQKooK2mUtRCgAAVWh06Ustoy3TG2s4UQQsDvlpAQpILoUASwqNAeCUhN/dxzm5/e/Hgzc29IcGBP+zuzM2es/vtt7u/77l7QoguGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI/BNRIBezqYkudVoKDg92jHEBOnQ6ymTQUHZtrLmuq1gKC+Hpx5zZRDol4B355cXmNx5SBJ6vySyzKTMUgzUzyEyFKZk3tjm+uWfFtycZlknrImNjW1XZtmaa18R6JOAPy8pycqIeCsYJU9YhObaMFJbQsRxs3BCYcxyj+W1b+aO4w1GvDMMn3zFHwhE4sj041VGwLjUfLuK/eOsCH3DonRSBELtIiI2RGkGhEog9JgFM1QOIUWhqHeo2WEfo145xe4kTSBbe6k5dP+VQwBySV3qikq/Z0n6gUHJpC4pCIUwvZQRCFsNCkHUTVEiPg9L+UGXoBukkJ9YMhLuMs8KWHc7E3ROYLA/M/UM/1c9tLKysle8k6EhpVRgxwBP1n+ptpQDdxeNuQMx9i8gyFZEym4htQYIbhMjcqvDWL3liRwdtW9fR+IknxYUpGXzAa9nEPZABxOPljXV/zmRxn0HP/7FMP+UNMkeF0QMxzzd1qReQINGcdxMM2eO2lfbtJkQI7uwdJzJ5POOKReMO7Bnl+IXKPBfIyhZZDA6NgpvE19iTCURnNFWPP++M8fzt4k7d0Zri4oGmsQ3XVL6mAo7qQrDCjglh2xClpYdqv/0qaeeLTAsOoMyPtWx0ZqiMK6CF/mXYPY7VPAykN2Efa6rrvr1h5SiJ0mBIhjnOoJ3Y8b7qBQfOg5pZCZ7GKTjBV5SFQbDQ+DcB0Gtrq5e/ImiS+qia4rG+A3K1nkIzYblYu9kAyT8WyfCPxp7orYz1QTx7ZgqhHcLhv8gdrEeoPbYzGbMv6fQf5eXsHeAQoMjyC7MpXTpYnEFjMFnBTMVT+KDvDMpGehQeguLkoEucUcwbGdmevajGzy6T6fesCbuSFpoULnScyo8HG3L9nT5ok6ac5wTE0rSfYzLV9VQaoQkdryTky8VmocBfjPWHVOueNr459hKuDwowuQk53Ib3ODtnPGXZs2dp6z5g3ha9aysHML9ASN8HhZcIwX9mFLhQSzcT+3U61NjhYqTghymlLWrd1Viin3h8cLf3bnlGczjbPExPrFTiK2w2oVlh+s3xtNc6llZcBbJrvZw9liXlEcjhpw8sTHQkjiuIed6XyTd+AhxPNzutN05+ciRrkSaZO87CDHTi8qmRKlYB619oKy5fksyumRtas5ourkAG78FBvsg9nYwGd2Vaps5c26p4bFeJELkwtv8srrqtX+6cyl3PGvOc9M45S9AlAFY4q+WLXut0e2/nLpHTGAe8YKHspLz0pnRNdgztb/CVYsoxA+Lz1T6ZsLSLMHGq/bEAiuKwmrWUGnM76twE3n09/38qX0hWOIXUCqLSTmov+O/Lv2KFVX1Ihp9BZH1LJP0+YqKZ77j8qyYO+/7nBrPAZP9ERl+7esKV/Ht5qJr8keNhA8fcV7KWya0BPaQQ+7U/avPRKOMWSRHHaQ4pTwqRTk4/DWRy3DSHCIt5Hdu+/6SEo/7nKwuOXAgAsvr1U/tuOEGM7utrYfiKn6toRDLMHJyHWnfK6Rstb1Wk2oHQ36gpMSAb++1DPN45JhAwMYaVBhRSRM/ffo073UQOsPhsMjLy3NAr8YRxMeap5+es5CZnpcoM1+YOXP2y5xb6QhP82HFR+xI9JXXVy79j8tXue1jQ4dyT3190n25dKpOnKubgIVFwzTIH5mAOFs3rHQydn5dWUv9H+MZ9OW508zxZFFSoNIB7B7hiymjTlqUuzWLy6cbQjwVisgCgA38ehYoy7G91437CWmsSSmHvfmjBtmnQr9xiHcSkiwrnhee7SxqRWxhD8CaDguDzZtwYFdrbVHZwL1SPEQi5Ol85AwAOen8sSQrSg7uHuZfQA4FNs+ePbvgXEdojuX13WXbdkrFZJwR08r85GxHaBl2td3d2fLlS7bPmjV3IWHsRW561iD/o0LQeuJEF65cuWSPS6fq9vbgjZmdzT+TVsbNQohuMouno5gr3UgPgH4x2jervm7EE5r2HlKN2MSTJqFVNhV2IM+/1X+sZ/xUdMlKJQTqIxSCkkUOghwyT4iMpiejvRBLSx9EXrUGeehGuK1/4JZM5Qo9Cq5D20OMnuvREdcgItyUhiy2JT0rKH3vKz4yDQKa7GFsYliI1abDV45pqT2ihspw0BSe9CGcyjQq5To0nY9jGfcokecYp5AxH1aNts29xBT5OArilEjeRkIMHUpSsCnBZRO3+fHE3urqqs9mzZq3GNl4JURxPhyNLlq5vKo2kQ5WnYV4nA+DO0AYErWYH0ikAsyOJA6jx6mgsTUqim4CVg21haO/a0i6wsGyLJx5Q4Z4Gc2PqL6+lLvJDZyx0E3IwjPDSKGVQX6ZUfcYnplzvRep6AwuyIaylsA9PQgup0GSKOL/9rGH6hfGD9+d+60hYcv7lmR06IijF4Sr+pGJQzBSOsiIDR9dhJu3M/Hjen2WMiKks2tF9aIFvdL13tlo285BINVJbN6UihSWG4TRbFyxdPHyVDTJ2r9S8ou9bKIHcVO51xAEZFL6cG2h/5GL3Zd6yPuvKQSZ5pJhAoQ72eq+x9fnLenhkgwSktXEt3+dZ0gLXlZFhu4leuIgrJotxdFmamBY+e1uL79wkQDrpLSzk1hue19qDIF2xC4ikuDYFw6xxSKESa5+jMGiUhe1L9WvfGKfSw+GaNiGo41KJGIFxyRqMLK8tqBsyqW4VmIBXjpwBOVkChKrGDnwg7ekKeMmiCCT/i06xriffyYSEsWQnVjV+4I4T+4uL89QLAzTi73KLoPQNJzHB/SVrRDASCJnYWxgRUVFyhjcV3690Qm4RPRjKjbgViR2vdEm9vVw0aWHA9tri0rXpFP2eBBCwlci+HGaxZl8t6bAf++4I4F/JzJx36cUF1uIAz+1CPepO2ulJCEiIoLw3i4DoJkxK3DZ9Ll2lTBhgGpO2lXWUtcWyPevloyspe3Oj0D31skjgfYhReU7cLv0KBK9qtriMW/i+NIOD9aNhwGnQG0S7PBF9n+7oeE0PGYr4QO2MSEWIJgtmVnxzPvwHWG8dx9nGMSm7AyJBpurq6tT5BDIEBhU74JNJGxHHTWdBpubDbDy6ePbQkfLZz97EPMow+heMBcygY50iza++uqrp1VnDwtWjUEr9CyseFPalx5DXeHh3Hitxcl7tUWjpyqaxFIJXtfa3hG49nr0QuyFn8QVDHKP+gyzs1tW6I7NQOaEVUYApbKufpUorpCw+JCq3YHqig3qHUaukfTuEMgLGiEHVTIHPH/8ReH4vNtUvhQmn+Pz2M/haQqZZOtx27UJer0x/iek2MgNscYb4pPUfKtWrTofFOH3pRBLoQvTkGn8HSvZhP0jWfzqh0RzIzD4NcTkd9cZX3Nu4K5Q4kqf4NtM8kvCqqqqk1jvaqznQ4SEJVCHDfFzuM+Q7kYgurqrS9zoztFN29xGVe8qHjfAFNE3kWhNj8CSlXIZytYkCQLTX5w8NHjFbWTLRSB35I3MsQzzXSjFHerDhCpplHcFqfPE2ObA2lhDwh9cUPPRhaXFUY/Zro4sCd29vgYGD86M+PKHsk5xzL0+3YwlZg8fne+RmWF/8/YeWavL8OOcHN9Ab24uyR583B/YcjFr3pGXl+7h1wyF2ieNxV5BIpGsnBPxY9QZ9dy5c1mMpQ0RwkniPi3i8UQ7z6alnXqjsjLorsGtMd46dSqYk5aGLK95Uuv69fer9CdpAa1x7GxXns9g6Y7jJJWdbYiQyMxsXVVZGdtXUiKX+2b858agota5OOo8b+L0oyxTDUDiBYVXHx3o/NEtdTsVfd2Q4bnSk77UZGQabop8sJJoyJF/MLLkk/qbsIvo1a97FbC7nNg3YUHnIx+6BxbtVXEZwoUflG1wS2ujjK4ub65rqISbvi9v5EjDssaCoq1rkPmR+mLj8tH11UegTwJ2l1VXUFrOGPkh4sCdCHxj8FluQDoiYQdxQpD5uzhdvd3mnPnsat0ru+vSdWoE+iXgeDb78f9ZjkFGOsQuFoRdx6icSh22CUnPn8Yerq2Pp9XPGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0Ah8cxH4H9aAFXVhrGASAAAAAElFTkSuQmCC
name: FireEye HX
script:
  commands:
  - arguments:
    - description: The host name to be contained. If the hostName is not specified,
        the agentId must be specified.
      name: hostName
    - description: The agent id running on the host to be contained. If the agentId
        is not specified, the hostName must be specified.
      name: agentId
    description: Apply containment for a specific host, so that it no longer has access
      to other systems.
    name: fireeye-hx-host-containment
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
  - arguments:
    - description: The host name to be contained. If the hostName is not specified,
        the agentId must be specified.
      name: hostName
    - description: The agent id running on the host to be contained. If the agentId
        is not specified, the hostName must be specified.
      name: agentId
    description: Release a specific host from containment.
    name: fireeye-hx-cancel-containment
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
  - arguments:
    - auto: PREDEFINED
      description: Identifies which alerts result from indicators with the specified
        share mode.
      name: hasShareMode
      predefined:
      - any
      - restricted
      - unrestricted
    - auto: PREDEFINED
      description: Sorts the results by the specified field.
      name: resolution
      predefined:
      - active_threat
      - alert
      - block
      - partial_block
    - description: Filter by the agent ID.
      name: agentId
    - description: Filter by condition ID.
      name: conditionId
    - description: Filter event occurred time. ISO-8601 timestamp..
      name: eventAt
    - description: Filter by alert ID.
      name: alertId
    - description: Filter by match detection time. ISO-8601 timestamp.
      name: matchedAt
    - description: Filter that returns only records with an AlertId field value great
        than the minId value
      name: minId
    - description: Filter by reported time. ISO-8601 timestamp.
      name: reportedAt
    - auto: PREDEFINED
      description: Source of alert- indicator of compromise
      name: IOCsource
      predefined:
      - "yes"
    - auto: PREDEFINED
      description: Source of alert - exploit detection
      name: EXDsource
      predefined:
      - "yes"
    - auto: PREDEFINED
      description: Source of alert - malware alert
      name: MALsource
      predefined:
      - "yes"
    - description: Return only records with id greater than minId
      name: minId
    - description: Limit the results returned
      name: limit
    - auto: PREDEFINED
      description: Sorts the results by the specified field in ascending order.
      name: sort
      predefined:
      - agentId
      - conditionId
      - eventAt
      - alertId
      - matchedAt
      - id
      - reportedAt
    - auto: PREDEFINED
      description: The sort order for the results.
      name: sortOrder
      predefined:
      - ascending
      - descending
    description: Get a list of alerts, use the different arguments to filter the results
      returned.
    name: fireeye-hx-get-alerts
    outputs:
    - contextPath: FireEyeHX.Alerts._id
      description: FireEye alert ID.
    - contextPath: FireEyeHX.Alerts.agent._id
      description: FireEye agent ID.
    - contextPath: FireEyeHX.Alerts.agent.containment_state
      description: Host containment state.
    - contextPath: FireEyeHX.Alerts.condition._id
      description: The condition unique ID.
    - contextPath: FireEyeHX.Alerts.event_at
      description: Time when the event occoured.
    - contextPath: FireEyeHX.Alerts.matched_at
      description: Time when the event was matched.
    - contextPath: FireEyeHX.Alerts.reported_at
      description: Time when the event was reported.
    - contextPath: FireEyeHX.Alerts.source
      description: Source of alert.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts._id
      description: Source alert ID.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.appliance_id
      description: Appliance ID
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.meta
      description: Source alert meta.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.indicator_id
      description: Indicator ID.
    - contextPath: FireEyeHX.Alerts.resolution
      description: Alert resulotion.
    - contextPath: FireEyeHX.Alerts.event_type
      description: Event type.
  - arguments:
    - description: The alert id. The alert id is listed in the output of 'get-alerts'
        command.
      name: alertId
    description: Suppress alert by ID
    name: fireeye-hx-suppress-alert
  - arguments:
    - description: The indicator category
      name: category
    - description: The searchTerm can be any name, category, signature, source, or
        condition value.
      name: searchTerm
    - auto: PREDEFINED
      description: Determines who can see the indicator. You must belong to the correct
        authorization group .
      name: shareMode
      predefined:
      - any
      - restricted
      - unrestricted
      - visible
    - auto: PREDEFINED
      description: Sorts the results by the specified field in ascending  order
      name: sort
      predefined:
      - category
      - activeSince
      - createdBy
      - alerted
    - description: Person who created the indicator
      name: createdBy
    - auto: PREDEFINED
      description: Whether the indicator resulted in alerts
      name: alerted
      predefined:
      - "yes"
      - "no"
    - description: Limit the number of results
      name: limit
    description: Get a list of indicators
    name: fireeye-hx-get-indicators
    outputs:
    - contextPath: FireEyeHX.Indicators._id
      description: FireEye unique indicator ID.
    - contextPath: FireEyeHX.Indicators.name
      description: The indicator name as displayed in the UI.
    - contextPath: FireEyeHX.Indicators.description
      description: Indicator description.
    - contextPath: FireEyeHX.Indicators.category.name
      description: Catagory name.
    - contextPath: FireEyeHX.Indicators.created_by
      description: The "Created By" field as displayed in UI
    - contextPath: FireEyeHX.Indicators.active_since
      description: Date indicator became active.
    - contextPath: FireEyeHX.Indicators.stats.source_alerts
      description: Total number of source alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.stats.alerted_agents
      description: Total number of agents with HX alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.platforms
      description: List of families of operating systems.
  - arguments:
    - description: Indicator category.
      name: category
      required: true
    - description: Indicator name.
      name: name
      required: true
    description: Get a specific indicator details
    name: fireeye-hx-get-indicator
    outputs:
    - contextPath: FireEyeHX.Indicators._id
      description: FireEye unique indicator ID.
    - contextPath: FireEyeHX.Indicators.name
      description: The indicator name as displayed in the UI.
    - contextPath: FireEyeHX.Indicators.description
      description: Indicator description.
    - contextPath: FireEyeHX.Indicators.category.name
      description: Catagory name.
    - contextPath: FireEyeHX.Indicators.created_by
      description: The "Created By" field as displayed in UI
    - contextPath: FireEyeHX.Indicators.active_since
      description: Date indicator became active.
    - contextPath: FireEyeHX.Indicators.stats.source_alerts
      description: Total number of source alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.stats.alerted_agents
      description: Total number of agents with HX alerts associated with this indicator.
    - contextPath: FireEyeHX.Indicators.platforms
      description: List of families of operating systems.
    - contextPath: FireEyeHX.Conditions._id
      description: FireEye unique condition ID.
    - contextPath: FireEyeHX.Conditions.event_type
      description: Event type.
    - contextPath: FireEyeHX.Conditions.enabled
      description: Indicates whether the condition is enabled.
  - arguments:
    - description: The agent ID. If the agent ID is not specified, the host Name must
        be specified.
      name: agentId
    - description: The host name. If the host name is not specified, the agent ID
        must be specified.
      name: hostName
    description: Get information on a host associated with an agent.
    name: fireeye-hx-get-host-information
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
  - arguments:
    - description: The alert ID.
      name: alertId
      required: true
    description: Get details of a specific alert
    name: fireeye-hx-get-alert
    outputs:
    - contextPath: FireEyeHX.Alerts._id
      description: FireEye alert ID.
    - contextPath: FireEyeHX.Alerts.agent._id
      description: FireEye agent ID.
    - contextPath: FireEyeHX.Alerts.agent.containment_state
      description: Host containment state.
    - contextPath: FireEyeHX.Alerts.condition._id
      description: The condition unique ID.
    - contextPath: FireEyeHX.Alerts.event_at
      description: Time when the event occoured.
    - contextPath: FireEyeHX.Alerts.matched_at
      description: Time when the event was matched.
    - contextPath: FireEyeHX.Alerts.reported_at
      description: Time when the event was reported.
    - contextPath: FireEyeHX.Alerts.source
      description: Source of alert.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts._id
      description: Source alert ID.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.appliance_id
      description: Appliance ID
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.meta
      description: Source alert meta.
    - contextPath: FireEyeHX.Alerts.matched_source_alerts.indicator_id
      description: Indicator ID.
    - contextPath: FireEyeHX.Alerts.resolution
      description: Alert resulotion.
    - contextPath: FireEyeHX.Alerts.event_type
      description: Event type.
  - arguments:
    - description: The file name.
      name: fileName
      required: true
    - description: The file path.
      name: filePath
      required: true
    - auto: PREDEFINED
      description: Whether to aqcuire the file using the API or RAW. By default, raw
        file will be acquired. Use API option when file is encrypted.
      name: acquireUsing
      predefined:
      - API
      - RAW
    - description: The agent ID associated with the host that holds the file. If the
        hostName is not specified, the agentId must be specified.
      name: agentId
    - description: The host that holds the file. If the agentId is not specified,
        hostName must be specified.
      name: hostName
    description: Aquire a specific file as a password protected zip file. The password
      for unlocking the zip file is 'unzip-me'.
    name: fireeye-hx-file-acquisition
    outputs:
    - contextPath: FireEyeHX.Acquisitions.Files._id
      description: The acquisition unique ID.
    - contextPath: FireEyeHX.Acquisitions.Files.state
      description: The acquisition state.
    - contextPath: FireEyeHX.Acquisitions.Files.md5
      description: File md5.
    - contextPath: FireEyeHX.Acquisitions.Files.req_filename
      description: The file name.
    - contextPath: FireEyeHX.Acquisitions.Files.req_path
      description: The file path.
    - contextPath: FireEyeHX.Acquisitions.Files.host._id
      description: FireEye HX agent ID.
  - arguments:
    - description: The acquisition ID.
      name: acquisitionId
      required: true
    description: Delete the file acquisition, by ID.
    name: fireeye-hx-delete-file-acquisition
  - arguments:
    - description: Acquisition script in JSON format.
      name: script
    - description: The script name. If the Acquisition script is specified, the script
        name must be specified as well.
      name: scriptName
    - auto: PREDEFINED
      description: Use default script. Select the host system.
      name: defaultSystemScript
      predefined:
      - osx
      - win
      - linux
    - description: The agent ID. If the host name is not specified, the agent ID must
        be specified.
      name: agentId
    - description: The host name. If the agent ID is not specified, the host name
        must be specified.
      name: hostName
    description: Start a data acquisition process to gather artifacts from the system
      disk and memory. The data is fetched as mans file.
    name: fireeye-hx-data-acquisition
    outputs:
    - contextPath: FireEyeHX.Acquisitions.Data._id
      description: The acquisition unique ID.
    - contextPath: FireEyeHX.Acquisitions.Data.state
      description: The acquisition state.
    - contextPath: FireEyeHX.Acquisitions.Data.md5
      description: File md5.
    - contextPath: FireEyeHX.Acquisitions.Data.host._id
      description: Time when the acquisition was finished.
  - arguments:
    - description: The acquisition ID.
      name: acquisitionId
      required: true
    description: Delete data acquisition.
    name: fireeye-hx-delete-data-acquisition
  - arguments:
    - description: IDs of agents to be searched
      name: agentsIds
    - description: Names of hosts to be searched
      name: hostsNames
    - description: Id of host set to be searched
      name: hostSet
    - description: Limit results count (once limit is reached, the search is stopped)
      name: limit
    - auto: PREDEFINED
      defaultValue: "yes"
      description: Should search be exhaustive or quick
      name: exhaustive
      predefined:
      - "yes"
      - "no"
    - description: A valid IPv4 address to search for
      name: ipAddress
    - auto: PREDEFINED
      description: Which operator to apply to the given IP address
      name: ipAddressOperator
      predefined:
      - equals
      - not equals
    - description: A 32-character MD5 hash value to search for
      name: fileMD5Hash
    - auto: PREDEFINED
      description: Which operator to apply to the given MD5 hash
      name: fileMD5HashOperator
      predefined:
      - equals
      - not equals
    - description: Full path of file to search
      name: fileFullPath
    - auto: PREDEFINED
      description: Which operator to apply to the given file path
      name: fileFullPathOperator
      predefined:
      - equals
      - not equals
      - contains
      - not contains
    - description: DNS value to search for
      name: dnsHostname
    - auto: PREDEFINED
      description: Which operator to apply to the given DNS
      name: dnsHostnameOperator
      predefined:
      - equals
      - not equals
      - contains
      - not contains
    - auto: PREDEFINED
      description: Method in which search should be stopped after finding <limit>
        number of results
      name: stopSearch
      predefined:
      - stopAndDelete
      - stop
    description: Search endpoints to check all hosts or a subset of hosts for a specific
      file or indicator.
    name: fireeye-hx-search
    outputs:
    - contextPath: FireEyeHX.Search.Results.Timestamp - Modified
      description: Time when the entry was last modified
      type: string
    - contextPath: FireEyeHX.Search.Results.File Text Written
      description: The file text content
      type: string
    - contextPath: FireEyeHX.Search.Results.File Name
      description: Name of the file
      type: string
    - contextPath: FireEyeHX.Search.Results.File Full Path
      description: The full path of the file
      type: string
    - contextPath: FireEyeHX.Search.Results.File Bytes Written
      description: Number of bytes written to the file
      type: string
    - contextPath: FireEyeHX.Search.Results.Size in bytes
      description: Size of the file in bytes
      type: string
    - contextPath: FireEyeHX.Search.Results.Browser Version
      description: Version of the browser
      type: string
    - contextPath: FireEyeHX.Search.Results.Browser Name
      description: Name of the browser
      type: string
    - contextPath: FireEyeHX.Search.Results.Cookie Name
      description: Name of the cookie
      type: string
    - contextPath: FireEyeHX.Search.Results.DNS Hostname
      description: Name of the DNS host
      type: string
    - contextPath: FireEyeHX.Search.Results.URL
      description: The event URL
      type: string
    - contextPath: FireEyeHX.Search.Results.Username
      description: The event username
      type: string
    - contextPath: FireEyeHX.Search.Results.File MD5 Hash
      description: MD5 hash of the file
      type: string
    - contextPath: FireEyeHX.Search.HostID
      description: ID of the host
      type: string
    - contextPath: FireEyeHX.Search.HostName
      description: Name of host
      type: string
    - contextPath: FireEyeHX.Search.HostUrl
      description: Inner FireEye host url
      type: string
    - contextPath: FireEyeHX.Search.SearchID
      description: ID of performed search
      type: string
    - contextPath: FireEyeHX.Search.Results.Timestamp - Accessed
      description: Last accessed time
      type: string
    - contextPath: FireEyeHX.Search.Results.Port
      description: Port
      type: number
    - contextPath: FireEyeHX.Search.Results.Process ID
      description: ID of the process
      type: string
    - contextPath: FireEyeHX.Search.Results.Local IP Address
      description: Local IP Address
      type: string
    - contextPath: FireEyeHX.Search.Results.Local IP Address
      description: Local IP Address
      type: string
    - contextPath: FireEyeHX.Search.Results.Local Port
      description: Local Port
      type: number
    - contextPath: FireEyeHX.Search.Results.Username
      description: Username
      type: string
    - contextPath: FireEyeHX.Search.Results.Remote Port
      description: Remote Port
      type: number
    - contextPath: FireEyeHX.Search.Results.IP Address
      description: IP Address
      type: string
    - contextPath: FireEyeHX.Search.Results.Process Name
      description: Process Name
      type: string
    - contextPath: FireEyeHX.Search.Results.Timestamp - Event
      description: Timestamp - Event
      type: string
    - contextPath: FireEyeHX.Search.Results.type
      description: The type of the event
      type: string
    - contextPath: FireEyeHX.Search.Results.id
      description: ID of the result
      type: string
  - arguments:
    - description: ID of a specific host set to get
      name: hostSetID
    - description: Specifies which record to start with in the response. The offset
        value must be an unsigned 32-bit integer. The default is 0.
      name: offset
    - description: Specifies how many records are returned. The limit value must be
        an unsigned 32-bit integer. The default is 50.
      name: limit
    - description: Searches the names of all host sets connected to the specified
        HX appliance.
      name: search
    - description: Sorts the results by the specified field in ascending or descending
        order. The default is sorting by name in ascending order. Sortable fields
        are _id (host set ID) and name (host set name).
      name: sort
    - description: Specifies the name of host set to look for
      name: name
    - description: Specifies the type of host sets to search for
      name: type
    description: Get a list of all host sets known to your HX Series appliance
    name: fireeye-hx-get-host-set-information
    outputs:
    - contextPath: FireEyeHX.HostSets._id
      description: host set id
      type: number
    - contextPath: FireEyeHX.HostSets._revision
      description: Revision number
      type: string
    - contextPath: FireEyeHX.HostSets.name
      description: Host set name
      type: string
    - contextPath: FireEyeHX.HostSets.type
      description: Host set type (static/dynamic/hidden)
      type: string
    - contextPath: FireEyeHX.HostSets.url
      description: Host set FireEye url
      type: string
  - arguments:
    - description: The indicator category
      name: category
      required: true
    description: Create new indicator
    name: fireeye-hx-create-indicator
    outputs:
    - contextPath: FireEyeHX.Indicators.active_since
      description: Date indicator became active.
      type: date
    - contextPath: FireEyeHX.Indicators.meta
      description: Meta data for new indicator
      type: string
    - contextPath: FireEyeHX.Indicators.display_name
      description: The indicator display name
      type: string
    - contextPath: FireEyeHX.Indicators.name
      description: The indicator name as displayed in the UI.
      type: string
    - contextPath: FireEyeHX.Indicators.created_by
      description: The "Created By" field as displayed in UI
      type: string
    - contextPath: FireEyeHX.Indicators.url
      description: The data URL
      type: string
    - contextPath: FireEyeHX.Indicators.create_text
      description: The indicator create text
    - contextPath: FireEyeHX.Indicators.platforms
      description: List of families of operating systems.
      type: string
    - contextPath: FireEyeHX.Indicators.create_actor._id
      description: The ID of the actor
      type: number
    - contextPath: FireEyeHX.Indicators.create_actor.username
      description: Actor user name
      type: string
    - contextPath: FireEyeHX.Indicators.signature
      description: 'Signature of indicator '
      type: string
    - contextPath: FireEyeHX.Indicators._revision
      description: Indicator revision
      type: string
    - contextPath: FireEyeHX.Indicators._id
      description: FireEye unique indicator ID.
      type: string
    - contextPath: FireEyeHX.Indicator.description
      description: Indicator description
      type: string
    - contextPath: FireEyeHX.Indicators.category._id
      description: Category ID
      type: number
    - contextPath: FireEyeHX.Indicators.category.name
      description: Category name
      type: string
    - contextPath: FireEyeHX.Indicators.category.share_mode
      description: Category share mode
      type: string
    - contextPath: FireEyeHX.Indicators.category.uri_name
      description: Category uri name
      type: string
    - contextPath: FireEyeHX.Indicators.category.url
      description: Category URL
      type: string
    - contextPath: FireEyeHX.Indicators.uri_name
      description: The indicator uri name
      type: string
    - contextPath: FireEyeHX.Indicators.stats.active_conditions
      description: Indicator active conditions
      type: number
    - contextPath: FireEyeHX.Indicators.stats.alerted_agents
      description: Total number of agents with HX alerts associated with this indicator.
      type: number
    - contextPath: FireEyeHX.Indicators.stats.source_alerts
      description: Total number of source alerts associated with this indicator.
      type: number
    - contextPath: FireEyeHX.Indicators.update_actor._id
      description: Update actor ID
      type: number
    - contextPath: FireEyeHX.Indicators.update_actor.username
      description: Update actor name
      type: string
  - arguments:
    - description: The indicator category
      name: category
      required: true
    - description: The name of the indicator
      name: name
      required: true
    - description: 'A list of conditions to add. The list can include a list of IPv4
        addresses, MD5 files, and domain names. For example: example.netexample.orgexample.lol'
      name: condition
      required: true
    description: 'Add conditions to an indicator. Conditions can be MD5, hash values,
      domain names and IP addresses. '
    name: fireeye-hx-append-conditions
  - arguments: []
    description: Get information on all hosts
    name: fireeye-hx-get-all-hosts-information
    outputs:
    - contextPath: FireEyeHX.Hosts._id
      description: FireEye HX Agent ID.
    - contextPath: FireEyeHX.Hosts.agent_version
      description: The agent version.
    - contextPath: FireEyeHX.Hosts.excluded_from_containment
      description: Determines whether the host is excluded from containment.
    - contextPath: FireEyeHX.Hosts.containment_missing_software
      description: Boolean value to indicate for containment missing software.
    - contextPath: FireEyeHX.Hosts.containment_queued
      description: Determines whether the host is queued for containment.
    - contextPath: FireEyeHX.Hosts.containment_state
      description: The containment state of the host. Possible values normal|contain|contain_fail|containing|contained|uncontain|uncontaining|wtfc|wtfu
    - contextPath: FireEyeHX.Hosts.stats.alerting_conditions
      description: The number of conditions that have alerted for the host.
    - contextPath: FireEyeHX.Hosts.stats.alerts
      description: Total number of alerts, including exploit-detection alerts.
    - contextPath: FireEyeHX.Hosts.stats.exploit_blocks
      description: The number of blocked exploits on the host.
    - contextPath: FireEyeHX.Hosts.stats.malware_alerts
      description: The number of malware alerts associated with the host.
    - contextPath: FireEyeHX.Hosts.hostname
      description: The host name.
    - contextPath: FireEyeHX.Hosts.domain
      description: Domain name.
    - contextPath: FireEyeHX.Hosts.timezone
      description: Host time zone.
    - contextPath: FireEyeHX.Hosts.primary_ip_address
      description: The host IP address.
    - contextPath: FireEyeHX.Hosts.last_poll_timestamp
      description: The timestamp of the last system poll preformed on the host.
    - contextPath: FireEyeHX.Hosts.initial_agent_checkin
      description: Timestamp of the initial agent check-in.
    - contextPath: FireEyeHX.Hosts.last_alert_timestamp
      description: The time stamp of the last alert for the host.
    - contextPath: FireEyeHX.Hosts.last_exploit_block_timestamp
      description: Time when the last exploit was blocked on the host. The value is
        null if no exploits have been blocked.
    - contextPath: FireEyeHX.Hosts.os.product_name
      description: Specific operating system
    - contextPath: FireEyeHX.Hosts.os.bitness
      description: OS Bitness.
    - contextPath: FireEyeHX.Hosts.os.platform
      description: Family of operating systems. Valid values are win, osx, and linux.
    - contextPath: FireEyeHX.Hosts.primary_mac
      description: The host MAC address.
  isfetch: true
  runonce: false
  script: |2-




    """

    IMPORTS

    """
    import requests
    import base64
    import time
    import json
    import os
    import re
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    """

    HANDLE PROXY

    """


    def set_proxies():

        if not demisto.params().get('proxy', False):
            del os.environ['HTTP_PROXY']
            del os.environ['HTTPS_PROXY']
            del os.environ['http_proxy']
            del os.environ['https_proxy']


    """

    GLOBAL VARS

    """
    SERVER_URL = demisto.params()['server']
    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    USE_SSL = not demisto.params()['insecure']
    VERSION = demisto.params()['version']
    GET_HEADERS = {
        'Accept': 'application/json'
    }
    POST_HEADERS = {
        'Accept': 'application/json',
        'Content-type': 'application/json'
    }
    PATCH_HEADERS = {
        'Content-Type': 'text/plain'
    }
    BASE_PATH = '{}/hx/api/{}'.format(SERVER_URL, VERSION)
    INDICATOR_MAIN_ATTRIBUTES = [
        'OS',
        'Name',
        'Created By',
        'Active Since',
        'Category',
        'Signature',
        'Active Condition',
        'Hosts With Alerts',
        'Source Alerts'
    ]
    ALERT_MAIN_ATTRIBUTES = [
        'Alert ID',
        'Reported',
        'Event Type',
        'Agent ID'
    ]
    HOST_MAIN_ATTRIBUTES = [
        'Host Name',
        'Host IP',
        'Agent ID',
        'Agent Version',
        'OS',
        'Last Poll',
        'Containment State',
        'Domain',
        'Last Alert'
    ]
    HOST_SET_MAIN_ATTRIBUTES = [
        'Name',
        'ID',
        'Type'
    ]
    # scripts for data acquisitions
    STANDART_INVESTIGATIVE_DETAILS_OSX = {
        "commands": [
            {
                "name": "sysinfo"
            },
            {
                "name": "disks"
            },
            {
                "name": "volumes"
            },
            {
                "name": "useraccounts"
            },
            {
                "name": "groups"
            },
            {
                "name": "files-api",
                "parameters": [
                    {
                        "name": "Path",
                        "value": "/"
                    },
                    {
                        "name": "Regex",
                        "value": "^(?:Applications|Library|System|User|bin|cores|opt|private|sbin|usr)+"
                    },
                    {
                        "name": "Include Remote Locations",
                        "value": False
                    },
                    {
                        "name": "Depth",
                        "value": -1
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": False
                    },
                    {
                        "name": "AND Operator",
                        "value": False
                    },
                    {
                        "name": "Include Files",
                        "value": True
                    },
                    {
                        "name": "Include Directories",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "persistence",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": False
                    }
                ]
            },
            {
                "name": "tasks",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "processes-api"
            },
            {
                "name": "urlhistory",
                "parameters": [
                    {
                        "name": "TargetBrowser",
                        "value": "Chrome"
                    },
                    {
                        "name": "TargetBrowser",
                        "value": "Firefox"
                    },
                    {
                        "name": "TargetBrowser",
                        "value": "Safari"
                    }
                ]
            },
            {
                "name": "quarantine-events"
            },
            {
                "name": "ports"
            },
            {
                "name": "services",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "stateagentinspector",
                "parameters": [
                    {
                        "name": "eventTypes",
                        "value": []
                    }
                ]
            },
            {
                "name": "syslog"
            }
        ]
    }
    STANDART_INVESTIGATIVE_DETAILS_LINUX = {
        "commands": [
            {
                "name": "sysinfo"
            },
            {
                "name": "files-api",
                "parameters": [
                    {
                        "name": "Path",
                        "value": "/"
                    },
                    {
                        "name": "Regex",
                        "value": "^(?:usr|lib|lib64|opt|home|sbin|bin|etc|root)+"
                    },
                    {
                        "name": "Include Remote Locations",
                        "value": False
                    },
                    {
                        "name": "Depth",
                        "value": -1
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "AND Operator",
                        "value": False
                    },
                    {
                        "name": "Include Files",
                        "value": True
                    },
                    {
                        "name": "Include Directories",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    }
                ]
            },
            {
                "name": "processes-api"
            },
            {
                "name": "ports"
            },
            {
                "name": "shell-history",
                "parameters": [
                    {
                        "name": "ShellList",
                        "value": [
                            "bash",
                            "zsh",
                            "ksh93"
                        ]
                    }
                ]
            }
        ]
    }
    STANDART_INVESTIGATIVE_DETAILS_WIN = {
        "commands": [
            {
                "name": "sysinfo"
            },
            {
                "name": "disks",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "volumes",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "useraccounts",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "prefetch",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "files-raw",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "Active Files",
                        "value": True
                    },
                    {
                        "name": "Deleted Files",
                        "value": True
                    },
                    {
                        "name": "Parse NTFS INDX Buffers",
                        "value": True
                    },
                    {
                        "name": "Path",
                        "value": "%systemdrive%"
                    },
                    {
                        "name": "Depth",
                        "value": -1
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Analyze Entropy",
                        "value": False
                    },
                    {
                        "name": "Enumerate Imports",
                        "value": False
                    },
                    {
                        "name": "Enumerate Exports",
                        "value": False
                    },
                    {
                        "name": "Analyze File Anomalies",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": False
                    },
                    {
                        "name": "Strings",
                        "value": False
                    },
                    {
                        "name": "AND Operator",
                        "value": False
                    },
                    {
                        "name": "Include Files",
                        "value": True
                    },
                    {
                        "name": "Include Directories",
                        "value": True
                    },
                    {
                        "name": "Get Resources",
                        "value": False
                    },
                    {
                        "name": "Get Resource Data",
                        "value": False
                    },
                    {
                        "name": "Get Version Info",
                        "value": False
                    }
                ]
            },
            {
                "name": "persistence",
                "parameters": [
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "Enumerate Imports",
                        "value": False
                    },
                    {
                        "name": "Enumerate Exports",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Analyze Entropy",
                        "value": False
                    },
                    {
                        "name": "Analyze File Anomalies",
                        "value": False
                    },
                    {
                        "name": "Get Resources",
                        "value": False
                    },
                    {
                        "name": "Get Version Info",
                        "value": False
                    },
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "registry-raw",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "Type",
                        "value": "All"
                    }
                ]
            },
            {
                "name": "tasks",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "raw mode",
                        "value": False
                    }
                ]
            },
            {
                "name": "eventlogs",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "processes-memory",
                "parameters": [
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "MemD5",
                        "value": False
                    },
                    {
                        "name": "enumerate imports",
                        "value": True
                    },
                    {
                        "name": "enumerate exports",
                        "value": True
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "sections",
                        "value": True
                    },
                    {
                        "name": "ports",
                        "value": True
                    },
                    {
                        "name": "handles",
                        "value": True
                    },
                    {
                        "name": "detect injected dlls",
                        "value": True
                    },
                    {
                        "name": "raw mode",
                        "value": False
                    },
                    {
                        "name": "strings",
                        "value": False
                    }
                ]
            },
            {
                "name": "urlhistory",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "GetThumbnails",
                        "value": False
                    },
                    {
                        "name": "GetIndexedPageContent",
                        "value": False
                    }
                ]
            },
            {
                "name": "ports",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    }
                ]
            },
            {
                "name": "services",
                "parameters": [
                    {
                        "name": "Prevent Hibernation",
                        "value": True
                    },
                    {
                        "name": "MD5",
                        "value": True
                    },
                    {
                        "name": "SHA1",
                        "value": False
                    },
                    {
                        "name": "SHA256",
                        "value": False
                    },
                    {
                        "name": "Verify Digital Signatures",
                        "value": True
                    },
                    {
                        "name": "Preserve Times",
                        "value": False
                    },
                    {
                        "name": "raw mode",
                        "value": False
                    }
                ]
            },
            {
                "name": "stateagentinspector",
                "parameters": [
                    {
                        "name": "eventTypes",
                        "value": []
                    }
                ]
            }
        ]
    }

    SYS_SCRIPT_MAP = {
        'osx': STANDART_INVESTIGATIVE_DETAILS_OSX,
        'win': STANDART_INVESTIGATIVE_DETAILS_WIN,
        'linux': STANDART_INVESTIGATIVE_DETAILS_LINUX
    }

    """

    COMMAND HANDLERS

    """


    def get_token_request():

        """
        returns a token on successful request
        """

        url = '{}/token'.format(BASE_PATH)

        # basic authentication
        try:
            response = requests.request(
                'GET',
                url,
                headers=GET_HEADERS,
                verify=USE_SSL,
                auth=(USERNAME, PASSWORD)
            )
        except requests.exceptions.SSLError as e:
            LOG(e)
            raise ValueError('An SSL error occurred when trying to connect to the server.\
            Consider configuring unsecure connection in the integration settings')

        # handle request failure
        if response.status_code not in range(200, 205):
            message = parse_error_response(response)
            raise ValueError('Token request failed with status code {}\n{}'.format(response.status_code, message))
        # successful request
        response_headers = response.headers
        token = response_headers.get('X-FeApi-Token')
        return token


    def get_token():

        token = get_token_request()
        if token:
            return token
        raise Exception('Failed to get a token, unexpected response structure from the server')


    """

    HOST INFORMATION

    """


    def get_host_by_agent_request(agent_id):

        """
        returns the response body

        raises an exception on:

            - http request failure
            - response status code different from 200
        """
        url = '{}/hosts/{}'.format(BASE_PATH, agent_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )

        # successful request
        try:
            return response.json()['data']
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to get host information - unexpected response structure from the server.')


    def get_host_information():

        """

        return the host information to the war room, given an agentId or hostName from input.

        """
        args = demisto.args()

        if not args.get('agentId') and not args.get('hostName'):
            raise ValueError('Please provide either agentId or hostName')

        host = {}  # type: Dict[str, str]
        if args.get('agentId'):
            host = get_host_by_agent_request(args.get('agentId'))
        else:
            host = get_host_by_name_request(args.get('hostName'))

        md_table = tableToMarkdown(
            'FireEye HX Get Host Information',
            host_entry(host),
            headers=HOST_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': host,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": host,
                "Endpoint(obj.ID==val.ID)": collect_endpoint_contxt(host)
            }
        }
        demisto.results(entry)


    def get_hosts_information():

        """

        return the host information to the war room, given an agentId or hostName from input.

        """

        offset = 0
        hosts = []  # type: List[Dict[str, str]]

        # get all hosts
        while True:
            hosts_partial_results = get_hosts_request(offset=offset, limit=1000)
            if not hosts_partial_results:
                break
            hosts.extend(hosts_partial_results)
            offset = len(hosts)

        hosts_entry = [host_entry(host) for host in hosts]
        md_table = tableToMarkdown(
            'FireEye HX Get Hosts Information',
            hosts_entry,
            headers=HOST_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': hosts,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": hosts_entry,
                "Endpoint(obj.ID==val.ID)": [collect_endpoint_contxt(host)for host in hosts]
            }
        }
        demisto.results(entry)


    def get_host_set_information():

        """
        return host set information to the war room according to given id or filters

        """
        args = demisto.args()

        url = '{}/host_sets/{}'.format(BASE_PATH, args.get('hostSetID', ''))
        url_params = {
            'limit': args.get('limit'),
            'offset': args.get('offset'),
            'search': args.get('search'),
            'sort': args.get('sort'),
            'name': args.get('name'),
            'type': args.get('type')
        }
        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS,
            url_params=url_params
        )
        host_set = []  # type: List[Dict[str, str]]
        try:
            if args.get('hostSetID'):
                data = response.json()['data']
                host_set = [data]
            else:
                data = response.json()['data']
                host_set = data.get('entries', [])
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to get host set information - unexpected response from the server.\n' + response.text)

        md_table = "No host sets found"
        if len(host_set) > 0:
            md_table = tableToMarkdown(
                'FireEye HX Get Host Sets Information',
                host_set_entry(host_set),
                headers=HOST_SET_MAIN_ATTRIBUTES
            )

        entry = {
            'Type': entryTypes['note'],
            'Contents': host_set,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.HostSets(obj._id==val._id)": host_set
            }
        }
        demisto.results(entry)


    def get_hosts_request(limit=None, offset=None, has_active_threats=None, has_alerts=None,
                          agent_version=None, containment_queued=None, containment_state=None,
                          host_name=None, os_platform=None, reported_clone=None, time_zone=None):

        """
        returns the response body

        raises an exception on:

            - http request failure
            - response status code different from 200
        """
        url = '{}/hosts'.format(BASE_PATH)
        url_params = {
            'limit': limit,
            'offset': offset,
            'has_active_threats': has_active_threats,
            'has_alerts': has_alerts,
            'agent_version': agent_version,
            'containment_queued': containment_queued,
            'containment_state': containment_state,
            'hostname': host_name,
            'os.platform': os_platform,
            'reported_clone': reported_clone,
            'time_zone': time_zone
        }
        # remove None values
        url_params = {k: v for k, v in url_params.items() if v is not None}

        response = http_request(
            'GET',
            url,
            url_params=url_params,
            headers=GET_HEADERS
        )
        # successful request
        try:
            return response.json()['data']['entries']
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to parse response body - unexpected response structure from the server.')


    def get_host_by_name_request(host_name):

        try:
            return get_hosts_request(host_name=host_name, limit=1)[0]
        except Exception as e:
            LOG(e)
            raise ValueError('Host {} not found.'.format(host_name))


    def get_all_agents_ids():

        """
        returns a list of all agents ids
        """
        offset = 0
        hosts = []  # type: List[Dict[str, str]]

        # get all hosts
        while True:
            hosts_partial_results = get_hosts_request(offset=offset, limit=1000)
            if not hosts_partial_results:
                break
            hosts.extend(hosts_partial_results)
            offset = len(hosts)
        return [host.get('_id') for host in hosts]


    def get_agent_id(host_name):

        """
        returns the agent id given the host name

        raises an exception on:
            - unexpected response structure
            - empty results

        """
        host = get_host_by_name_request(host_name)
        try:
            return host['_id']
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to get agent id for host {}'.format(host_name))


    def collect_endpoint_contxt(host):

        return {
            'Hostname': host['hostname'],
            'ID': host['_id'],
            'IPAddress': host['primary_ip_address'],
            'Domain': host['domain'],
            'MACAddress': host['primary_mac'],
            'OS': host['os']['platform'],
            'OSVersion': host['os']['product_name']
        }


    """

    HOST CONTAINMENT

    """


    def containment_request(agent_id):

        """

        no return value on successful request

        """
        url = '{}/hosts/{}/containment'.format(BASE_PATH, agent_id)
        body = {
            'state': 'contain'
        }

        http_request(
            'POST',
            url,
            body=body,
            headers=POST_HEADERS
        )
        # no exception raised - successful request


    def containment():

        """

        returns a success message to the war room

        """

        args = demisto.args()

        # validate one of the arguments was passed
        if not args:
            raise ValueError('Please provide either agentId or hostName')

        # in case a hostName was given, set the agentId accordingly
        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        containment_request(args['agentId'])
        # no exceptions raised->successful request

        host = get_host_by_agent_request(args['agentId'])
        entry = {
            'Type': entryTypes['note'],
            'Contents': 'Containment rquest for the host was sent and approved successfully',
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": host,
                "Endpoint(obj.ID==val.ID)": collect_endpoint_contxt(host)
            }
        }
        demisto.results(entry)


    def containment_cancellation_request(agent_id):

        """

        no return value on successful request

        """
        url = '{}/hosts/{}/containment'.format(BASE_PATH, agent_id)

        http_request(
            'DELETE',
            url,
            headers=GET_HEADERS
        )
        # no exceptions are raised - successful request


    def containment_cancellation():

        """

        returns a success message to the war room

        """

        args = demisto.args()

        # validate one of the arguments was passed
        if not args:
            raise ValueError('Please provide either agentId or hostName')

        # in case a hostName was given, set the agentId accordingly
        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        containment_cancellation_request(args['agentId'])
        # no exceptions raised->successful request

        host = get_host_by_agent_request(args['agentId'])
        entry = {
            'Type': entryTypes['note'],
            'Contents': 'The host is released from containment.',
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Hosts(obj._id==val._id)": host,
                "Endpoint(obj.ID==val.ID)": collect_endpoint_contxt(host)
            }
        }
        demisto.results(entry)


    """

    ALERTS

    """


    def get_alert_request(alert_id):

        url = '{}/alerts/{}'.format(BASE_PATH, alert_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )
        return response.json().get('data')


    def get_alert():

        alert_id = demisto.args().get('alertId')
        alert = get_alert_request(alert_id)

        alert_table = tableToMarkdown(
            'FireEye HX Get Alert # {}'.format(alert_id),
            alert_entry(alert),
            headers=ALERT_MAIN_ATTRIBUTES
        )

        event_type = alert.get('event_type')
        event_type = 'NewEvent' if not event_type else event_type
        event_type = re.sub("([a-z])([A-Z])", "\g<1> \g<2>", event_type).title()
        event_table = tableToMarkdown(
            event_type,
            alert.get('event_values')
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': alert,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '{}\n{}'.format(alert_table, event_table),
            'EntryContext': {
                "FireEyeHX.Alerts(obj._id==val._id)": alert
            }
        }
        demisto.results(entry)


    def get_alerts_request(has_share_mode=None, resolution=None, agent_id=None, host_name=None,
                           condition_id=None, limit=None, offset=None, sort=None, min_id=None,
                           event_at=None, alert_id=None, matched_at=None, reported_at=None, source=None):

        """

        returns the response body on successful request

        """
        url = '{}/alerts'.format(BASE_PATH)

        body = {
            'has_share_mode': has_share_mode,
            'resolution': resolution,
            'agent._id': agent_id,
            'condition._id': condition_id,
            'event_at': event_at,
            'min_id': min_id,
            '_id': alert_id,
            'matched_at': matched_at,
            'reported_at': reported_at,
            'source': source,
            'limit': limit,
            'offset': offset,
            'sort': sort
        }

        # remove None values
        body = {k: v for k, v in body.items() if v is not None}

        response = http_request(
            'GET',
            url,
            url_params=body,
            headers=GET_HEADERS
        )
        try:
            return response.json()['data']['entries']
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to parse response body')


    def get_all_alerts(has_share_mode=None, resolution=None, agent_id=None, condition_id=None, limit=None,
                       sort=None, min_id=None, event_at=None, alert_id=None, matched_at=None, reported_at=None, source=None):

        """

        returns a list of alerts, all results up to limit

        """
        offset = 0
        alerts = []  # type: List[Dict[str, str]]

        max_records = limit or float('inf')

        while len(alerts) < max_records:
            alerts_partial_results = get_alerts_request(
                has_share_mode=has_share_mode,
                resolution=resolution,
                agent_id=agent_id,
                condition_id=condition_id,
                event_at=event_at,
                alert_id=alert_id,
                matched_at=matched_at,
                reported_at=reported_at,
                source=source,
                min_id=min_id,
                offset=offset,
                limit=limit or 100,
                sort=sort
            )
            # empty list
            if not alerts_partial_results:
                break
            alerts.extend(alerts_partial_results)
            offset = len(alerts)

        # remove access results
        if len(alerts) > max_records:
            alerts[int(max_records) - 1: -1] = []

        return alerts


    def general_context_from_event(alert):

        def file_context(values):

            return {
                'Name': values.get('fileWriteEvent/fileName'),
                'MD5': values.get('fileWriteEvent/md5'),
                'Extension': values.get('fileWriteEvent/fileExtension'),
                'Path': values.get('fileWriteEvent/fullPath')
            }

        def ip_context(values):

            return {
                'Address': values.get('ipv4NetworkEvent/remoteIP')
            }

        def registry_key_context(values):

            return {
                'Path': values.get('regKeyEvent/path'),
                'Name': values.get('regKeyEvent/valueName'),
                'Value': values.get('regKeyEvent/value')
            }
        context_map = {
            'fileWriteEvent': file_context,
            'ipv4NetworkEvent': ip_context,
            'regKeyEvent': registry_key_context
        }

        if context_map.get(alert['event_type']) is not None:
            f = context_map[alert['event_type']]
            return f(alert['event_values'])
        return None


    def collect_context(alerts):

        # collect_context
        files = []
        ips = []
        registry_keys = []

        for alert in alerts:
            event_type = alert.get('event_type')
            context = general_context_from_event(alert)
            if event_type == 'fileWriteEvent':
                files.append(context)
            elif event_type == 'ipv4NetworkEvent':
                ips.append(context)
            elif event_type == 'regKeyEvent':
                registry_keys.append(context)
        return (files, ips, registry_keys)


    def get_alerts():

        """

        returns a list of alerts to the war room

        """

        args = demisto.args()
        source = []
        # add source type
        if args.get('MALsource'):
            source.append('mal')
        if args.get('EXDsource'):
            source.append('exd')
        if args.get('IOCsource'):
            source.append('ioc')

        sort_map = {
            'agentId': 'agent._id',
            'conditionId': 'condition._id',
            'eventAt': 'event_at',
            'alertId': '_id',
            'matchedAt': 'matched_at',
            'id': '_id',
            'reportedAt': 'reported_at'
        }

        if args.get('sort'):
            args['sort'] = '{}+{}'.format(sort_map.get(args['sort']), args.get('sortOrder', 'ascending'))

        if args.get('hostName'):
            args['agentId'] = get_agent_id(args.get('hostName'))

        if args.get('limit'):
            args['limit'] = int(args['limit'])

        alerts = get_all_alerts(
            has_share_mode=args.get("hasShareMode"),
            resolution=args.get('resolution'),
            agent_id=args.get('agentId'),
            condition_id=args.get('conditionId'),
            event_at=args.get('eventAt'),
            alert_id=args.get('alertId'),
            matched_at=args.get('matchedAt'),
            reported_at=args.get('reportedAt'),
            source=source,
            min_id=args.get('min_id'),
            limit=args.get('limit'),
            sort=args.get('sort')
        )

        # parse each alert to a record displayed in the human readable table
        alerts_entries = [alert_entry(alert) for alert in alerts]

        files, ips, registry_keys = collect_context(alerts)

        md_table = tableToMarkdown(
            'FireEye HX Get Alerts',
            alerts_entries,
            headers=ALERT_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': alerts,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Alerts(obj._id==val._id)": alerts,
                'File': files,
                'RegistryKey': registry_keys,
                'IP': ips
            }
        }
        demisto.results(entry)


    def suppress_alert_request(alert_id):

        """

        no return value on successful request

        """

        url = '{}/alerts/{}'.format(BASE_PATH, alert_id)

        http_request(
            'DELETE',
            url
        )


    def suppress_alert():

        """

        returns a success message to the war room

        """

        alert_id = demisto.args().get('alertId')

        suppress_alert_request(alert_id)
        # no exceptions raised->successful request

        entry = {
            'Type': entryTypes['note'],
            'Contents': 'Alert {} suppressed successfully.'.format(alert_id),
            'ContentsFormat': formats['text']
        }
        demisto.results(entry)


    """

    INDICATORS

    """


    def new_indicator_request(category):

        """
        Create a new indicator
        """
        url = '{}/indicators/{}'.format(BASE_PATH, category)

        response = http_request(
            'POST',
            url,
            headers=GET_HEADERS
        )
        try:
            return response.json().get('data')
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to parse response body, unexpected response structure from the server.')


    def create_indicator():

        """
        Get new indicator details
        returns a success message to the war room
        """

        category = demisto.args().get('category')

        response = new_indicator_request(category)

        md_table = {
            'ID': response.get('_id'),
        }
        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('FireEye HX New Indicator created successfully', md_table),
            'EntryContext': {
                "FireEyeHX.Indicators(obj._id===val._id)": response
            }
        }
        demisto.results(entry)


    def append_conditions_request(name, category, body):

        """
        Append conditions to indicator request
        """

        url = '{}/indicators/{}/{}/conditions'.format(BASE_PATH, category, name)

        response = http_request(
            'PATCH',
            url,
            conditions_params=body,
            headers=PATCH_HEADERS
        )

        return response.json()


    def append_conditions():

        """
        Append conditions to indicator
        no return value on successfull request
        """
        name = demisto.args().get('name')
        category = demisto.args().get('category')
        body = demisto.args().get('condition')

        body = body.replace(',', '\n')

        response = append_conditions_request(name, category, body)

        md_table = {
            'Name': name,
            'Category': category,
            'Conditions': body
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('The conditions were added successfully', md_table)
        }
        demisto.results(entry)


    def get_indicator_request(category, name):

        """

        returns a json object representing an indicator

        """

        url = '{}/indicators/{}/{}'.format(BASE_PATH, category, name)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS,
        )
        return response.json().get('data')


    def get_indicator_conditions_request(category, name, limit=None, offset=None, enabled=None, has_alerts=None):

        """

        returns a list of json objects, each representing an indicator condition
        if no results are found- returns None

        """
        url = '{}/indicators/{}/{}/conditions'.format(BASE_PATH, category, name)
        url_params = {
            'limit': limit,
            'offset': offset,
            'enabled': enabled,
            'has_alerts': has_alerts
        }
        # remove None values
        url_params = {k: v for k, v in url_params.items() if v is not None}

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS,
            url_params=url_params
        )
        try:
            return response.json()['data']['entries']
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to parse response body')


    def get_all_enabled_conditions(indicator_category, indicator_name):

        offset = 0
        conditions = []   # type: List[Dict[str, str]]

        # get all results
        while True:
            conditions_partial_results = get_indicator_conditions_request(
                indicator_category,
                indicator_name,
                enabled=True,
                offset=offset
            )
            if not conditions_partial_results:
                break
            conditions.extend(conditions_partial_results)
            offset = len(conditions)
        return conditions


    def get_indicator_conditions():

        """

        returns a list of enabled conditions assosiated with a specific indicator to the war room

        """

        args = demisto.args()

        conditions = get_all_enabled_conditions(
            args.get('category'),
            args.get('name')
        )

        conditions_entries = [condition_entry(condition) for condition in conditions]

        md_table = tableToMarkdown(
            'Indicator "{}" Alerts on'.format(args.get('name')),
            conditions_entries
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': conditions,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Conditions(obj._id==val._id)": conditions
            }
        }
        demisto.results(entry)


    def get_indicator():

        args = demisto.args()

        indicator = get_indicator_request(
            args.get('category'),
            args.get('name')
        )

        md_table = tableToMarkdown(
            'FireEye HX Get Indicator- {}'.format(args.get('name')),
            indicator_entry(indicator),
            headers=INDICATOR_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': indicator,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Indicators(obj._id==val._id)": indicator
            }
        }
        demisto.results(entry)


    def get_indicators_request(category=None, search=None, limit=None, offset=None,
                               share_mode=None, sort=None, created_by=None, alerted=None):

        url = '{}/indicators'.format(BASE_PATH)
        if category:
            url = url + '/' + category

        url_params = {
            'search': search,
            'limit': limit,
            'offset': offset,
            'category.share_mode': share_mode,
            'sort': sort,
            'created_by': created_by,
            'stats.alerted_agents': alerted
        }

        # remove None value
        url_params = {k: v for k, v in url_params.items() if v}

        response = http_request(
            'GET',
            url,
            url_params=url_params,
            headers=GET_HEADERS,
        )
        try:
            response_body = response.json()
            data = response_body['data']
            # no results found
            if data['total'] == 0:
                return None
            return data['entries']
        except Exception as e:
            LOG(e)
            raise ValueError('Failed to parse response body')


    def get_all_indicators(category=None, search=None, share_mode=None, sort=None, created_by=None, alerted=None, limit=None):

        max_records = limit or float('inf')
        offset = 0
        indicators = []   # type: List[Dict[str, str]]

        # get all results
        while len(indicators) < max_records:
            indicators_partial_results = get_indicators_request(
                category=category,
                search=search,
                offset=offset,
                share_mode=share_mode,
                sort=sort,
                created_by=created_by,
                alerted=alerted,
                limit=limit or 100
            )
            if not indicators_partial_results:
                break
            indicators.extend(indicators_partial_results)
            offset = len(indicators)

        # remove access results
        if len(indicators) > max_records:
            indicators[int(max_records) - 1: -1] = []

        return indicators


    def get_indicators():

        args = demisto.args()

        sort_map = {
            'category': 'category',
            'activeSince': 'active_since',
            'createdBy': 'created_by',
            'alerted': 'stats.alerted_agents'
        }

        if args.get('limit'):
            args['limit'] = int(args['limit'])
        if args.get('alerted'):
            args['alerted'] = args['alerted'] == 'yes'
        if args.get('sort'):
            args['sort'] = sort_map.get(args.get('sort'))

        # get all results
        indicators = get_all_indicators(
            category=args.get('category'),
            search=args.get('searchTerm'),
            share_mode=args.get('shareMode'),
            sort=args.get('sort'),
            created_by=args.get('createdBy'),
            alerted=args.get('alerted'),
            limit=args.get('limit')
        )

        indicators_entries = [indicator_entry(indicator) for indicator in indicators]

        md_table = tableToMarkdown(
            'FireEye HX Get Indicator- {}'.format(args.get('name')),
            indicators_entries,
            headers=INDICATOR_MAIN_ATTRIBUTES
        )

        entry = {
            'Type': entryTypes['note'],
            'Contents': indicators,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md_table,
            'EntryContext': {
                "FireEyeHX.Indicators(obj._id==val._id)": indicators
            }
        }
        demisto.results(entry)


    """

    SEARCH

    """


    def search_request(query, host_set=None, hosts=None, exhaustive=False):

        url = '{}/searches'.format(BASE_PATH)

        body = {'query': query}

        if host_set:
            body['host_set'] = {'_id': int(host_set)}
        elif hosts:
            body['hosts'] = [{'_id': host} for host in hosts]

        if exhaustive:
            body['exhaustive'] = True

        try:
            response = http_request(
                'POST',
                url,
                headers=POST_HEADERS,
                body=body
            )
        except Exception as e:
            raise e
        if response.status_code == 409:
            raise ValueError('Request unsuccessful because the search limits \
            (10 existing searches or 5 running searches) have been exceeded')
        return response.json().get('data')


    def get_search_information_request(search_id):

        """

        returns the search information represented by a json object.

        """

        url = '{}/searches/{}'.format(BASE_PATH, search_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )
        return response.json().get('data')


    def get_search_results_request(search_id):

        """

        returns the search results represented by a json object.

        """

        url = '{}/searches/{}/results'.format(BASE_PATH, search_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )
        return response.json().get('data', {}).get('entries', [])


    def stop_search_request(search_id):

        """

        returns the search information represented by a json object.

        """

        url = '{}/searches/{}/actions/stop'.format(BASE_PATH, search_id)

        response = http_request(
            'POST',
            url,
            headers=POST_HEADERS
        )
        return response.json()


    def delete_search_request(search_id):

        """

        no return value on successful request

        """

        url = '{}/searches/{}'.format(BASE_PATH, search_id)
        http_request(
            'DELETE',
            url
        )


    def search_results_to_context(results, search_id):

        for res in results:
            res["SearchID"] = search_id
            res["HostID"] = res.get("host", {}).get("_id")
            res["HostName"] = res.get("host", {}).get("hostname")
            res["HostUrl"] = res.get("host", {}).get("url")
            del res['host']
            res["Results"] = res.get("results")
            del res["results"]
            for resData in res.get("Results"):
                resData.update(resData.get("data", {}))
                del resData['data']
        return results


    def start_search():

        args = demisto.args()

        '''
        to search all hosts past none of the arguments?

        # validate at list one of the arguments 'agentsIds', 'hostsNames', 'hostSet' was passed
        if not any([args.get('agentsIds'), args.get('hostsNames'), args.get('hostSet'), args.get('searchAllHosts')]):
            raise ValueError('Please provide one of the followings: agentsIds, hostsNames, hostSet')
        '''

        agents_ids = []  # type: List[Dict[str, str]]
        if args.get('agentsIds'):
            agents_ids = args['agentsIds'].split(',')
        elif args.get('hostsNames'):
            names = args.get('hostsNames').split(',')
            for name in names:
                try:
                    agent_id = get_agent_id(name)
                    agents_ids.append(agent_id)
                except Exception as e:
                    LOG(e)
                    pass
            if not agents_ids:
                raise ValueError('None of the host names were matched with an agent')

        # limit can't exceed 1000.
        limit = args.get('limit')
        if not limit or limit > 1000:
            limit = 1000

        arg_to_query_field_map = {
            'dnsHostname': 'DNS Hostname',
            'fileFullPath': 'File Full Path',
            'fileMD5Hash': 'File MD5 Hash',
            'ipAddress': 'IP Address'
        }

        query = []
        for arg in arg_to_query_field_map.keys():
            if not args.get(arg):
                continue
            field_filter = {
                'field': arg_to_query_field_map[arg],
                'operator': args['{}Operator'.format(arg)],
                'value': args[arg]
            }
            query.append(field_filter)

        search = search_request(
            query,
            hosts=agents_ids,
            host_set=args.get('hostSet'),
            exhaustive=args.get('exhaustive') == 'yes'
        )

        search_id = search.get('_id')

        '''
        loop to get search status once a minute. break on: search has stopped, matched
        results exceeded limit, or no more pending hosts.
        '''

        while True:
            search_info = get_search_information_request(search_id)
            matched = search_info.get('stats', {}).get('search_state', {}).get('MATCHED', 0)
            pending = search_info.get('stats', {}).get('search_state', {}).get('PENDING', 0)
            if search_info.get('state') == 'STOPPED' or matched >= limit or pending == 0:
                break
            time.sleep(60)

        results = get_search_results_request(search_id)
        md_entries = [host_results_md_entry(host_results) for host_results in results]

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': '## Search Results\n' + '\n'.join(md_entries),
            'EntryContext': {
                "FireEyeHX.Search": search_results_to_context(results, search_id)
            }
        }
        demisto.results(entry)

        # finally stop or delete the search
        possible_error_message = None
        try:
            if args.get('stopSearch') == 'stop':
                possible_error_message = 'Failed to stop search'
                stop_search_request(search_id)
            # no need to stop a search before deleting it.
            if args.get('stopSearch') == 'stopAndDelete':
                possible_error_message = 'Failed to delete search'
                delete_search_request(search_id)
            possible_error_message = None
        except Exception as e:
            LOG('{}\n{}'.format(possible_error_message, e))
            pass
        # add warning entry if necessary
        if possible_error_message:
            warning_entry = {
                'Type': entryTypes['note'],
                'Contents': possible_error_message,
                'ContentsFormat': formats['text'],
            }
            demisto.results(warning_entry)


    """

    ACQUISITIONS

    """


    def file_acquisition_request(agent_id, file_name, file_path, comment=None, external_id=None, req_use_api=None):

        url = '{}/hosts/{}/files'.format(BASE_PATH, agent_id)

        body = {
            'req_path': file_path,
            'req_filename': file_name,
            'comment': comment,
            'external_id': external_id,
            'req_use_api': req_use_api
        }

        # remove None values
        body = {k: v for k, v in body.items() if v is not None}

        response = http_request(
            'POST',
            url,
            body=body,
            headers=POST_HEADERS
        )

        return response.json().get('data')


    def file_acquisition_package_request(acquisition_id):

        url = '{}/acqs/files/{}.zip'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url
        )

        return response.content


    def file_acquisition_information_request(acquisition_id):

        url = '{}/acqs/files/{}'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )

        return response.json().get('data')


    def delete_file_acquisition_request(acquisition_id):

        """

        no return value on successful request

        """

        url = '{}/acqs/files/{}'.format(BASE_PATH, acquisition_id)

        http_request(
            'DELETE',
            url
        )


    def delete_file_acquisition():

        """

        returns a success message to the war room

        """
        acquisition_id = demisto.args().get('acquisitionId')
        delete_file_acquisition_request(acquisition_id)
        # successful request

        return {
            'Type': entryTypes['note'],
            'Contents': 'file acquisition {} deleted successfully'.format(acquisition_id),
            'ContentsFormat': formats['text'],
        }


    def file_acquisition():

        args = demisto.args()

        if not args.get('hostName') and not args.get('agentId'):
            raise ValueError('Please provide either agentId or hostName')

        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        use_api = args.get('acquireUsing') == 'API'

        acquisition_info = file_acquisition_request(
            args.get('agentId'),
            args.get('fileName'),
            args.get('filePath'),
            req_use_api=use_api
        )

        acquisition_id = acquisition_info.get('_id')

        LOG('acquisition request was successful. Waiting for acquisition process to be complete.')
        while True:
            acquisition_info = file_acquisition_information_request(acquisition_id)
            if acquisition_info.get('state') == 'COMPLETE':
                break
            time.sleep(10)
        LOG('acquisition process has been complete. Fetching zip file.')

        acquired_file = file_acquisition_package_request(acquisition_id)

        message = '{} acquired successfully'.format(args.get('fileName'))
        if acquisition_info.get('error_message'):
            message = acquisition_info.get('error_message')

        entry = {
            'Type': entryTypes['note'],
            'Contents': '{}\nacquisition ID: {}'.format(message, acquisition_id),
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Acquisitions.Files(obj._id==val._id)": acquisition_info
            }
        }

        demisto.results(entry)
        demisto.results(fileResult('{}.zip'.format(os.path.splitext(args.get('fileName'))[0]), acquired_file))


    def data_acquisition_request(agent_id, script_name, script):

        url = '{}/hosts/{}/live'.format(BASE_PATH, agent_id)

        body = {
            'name': script_name,
            'script': {'b64': script}
        }

        response = http_request(
            'POST',
            url,
            body=body
        )

        return response.json()['data']


    def data_acquisition_information_request(acquisition_id):

        url = '{}/acqs/live/{}'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url,
            headers=GET_HEADERS
        )

        return response.json()['data']


    def data_collection_request(acquisition_id):

        url = '{}/acqs/live/{}.mans'.format(BASE_PATH, acquisition_id)

        response = http_request(
            'GET',
            url
        )

        return response.content


    def data_acquisition():
        """

        returns the mans file to the war room

        """

        args = demisto.args()

        # validate the host name or agent ID was passed
        if not args.get('hostName') and not args.get('agentId'):
            raise ValueError('Please provide either agentId or hostName')

        if not args.get('defaultSystemScript') and not args.get('script'):
            raise ValueError('If the script is not provided, defaultSystemScript must be specified.')

        if args.get('script') and not args.get('scriptName'):
            raise ValueError('If the script is provided, script name must be specified as well.')

        if args.get('hostName'):
            args['agentId'] = get_agent_id(args['hostName'])

        # determine whether to use the default script
        sys = args.get('defaultSystemScript')
        if sys:
            args['script'] = json.dumps(SYS_SCRIPT_MAP[sys])
            args['scriptName'] = '{}DefaultScript'.format(sys)

        acquisition_info = data_acquisition_request(
            args['agentId'],
            args['scriptName'],
            base64.b64encode(args['script'])
        )

        acquisition_id = acquisition_info.get('_id')

        LOG('Acquisition request was successful. Waiting for acquisition process to be complete.')
        # loop to inquire acquisition state every 30 seconds
        # break when state is complete
        while True:
            acquisition_info = data_acquisition_information_request(acquisition_id)
            if acquisition_info.get('state') == 'COMPLETE':
                break
            time.sleep(30)
        LOG('Acquisition process has been complete. Fetching mans file.')

        message = '{} acquired successfully'.format(args.get('fileName'))
        if acquisition_info.get('error_message'):
            message = acquisition_info.get('error_message')

        # output file and acquisition information to the war room
        data = data_collection_request(acquisition_id)
        entry = {
            'Type': entryTypes['note'],
            'Contents': '{}\nacquisition ID: {}'.format(message, acquisition_id),
            'ContentsFormat': formats['text'],
            'EntryContext': {
                "FireEyeHX.Acquisitions.Data(obj._id==val._id)": acquisition_info
            }
        }
        demisto.results(entry)
        demisto.results(fileResult('agent_{}_data.mans'.format(args['agentId']), data))


    def delete_data_acquisition_request(acquisition_id):

        """

        no return value on successful request

        """

        url = '{}/acqs/live/{}'.format(BASE_PATH, acquisition_id)

        http_request(
            'DELETE',
            url
        )


    def delete_data_acquisition():

        """

        returns a success message to the war room

        """
        acquisition_id = demisto.args().get('acquisitionId')
        delete_data_acquisition_request(acquisition_id)
        # successful request

        return {
            'Type': entryTypes['note'],
            'Contents': 'data acquisition {} deleted successfully'.format(acquisition_id),
            'ContentsFormat': formats['text'],
        }


    """

    FETCH INCIDENTS

    """


    def fetch_incidents():

        last_run = demisto.getLastRun()
        alerts = []  # type: List[Dict[str, str]]
        if last_run and last_run.get('min_id'):
            # get all alerts with id greater than min_id
            alerts = get_all_alerts(
                min_id=last_run.get('min_id'),
                sort='_id+ascending'
            )
            # results are sorted in ascending order - the last alert holds the greatest id
            min_id = alerts[-1].get('_id') if alerts else None
        else:
            # get the last 100 alerts
            alerts = get_all_alerts(
                sort='_id+descending',
                limit=100
            )
            # results are sorted in descending order - the first alert holds the greatest id
            min_id = alerts[0].get('_id') if alerts else None

        incidents = [parse_alert_to_incident(alert) for alert in alerts]
        demisto.incidents(incidents)
        if min_id is not None:
            demisto.setLastRun({'min_id': min_id})


    def parse_alert_to_incident(alert):

        event_type = alert.get('event_type')
        event_type = 'NewEvent' if not event_type else event_type
        event_values = alert.get('event_values', {})
        event_indicators_map = {
            'fileWriteEvent': 'fileWriteEvent/fileName',
            'ipv4NetworkEvent': 'ipv4NetworkEvent/remoteIP',
            'dnsLookupEvent': 'dnsLookupEvent/hostname',
            'regKeyEvent': 'regKeyEvent/valueName'
        }
        event_indicator = event_indicators_map.get(event_type)
        event_indicator = 'No Indicator' if not event_indicator else event_indicator

        incident_name = '{event_type_parsed}: {indicator}'.format(
            event_type_parsed=re.sub("([a-z])([A-Z])", "\g<1> \g<2>", event_type).title(),
            indicator=event_values.get(event_indicator)
        )

        incident = {
            'name': incident_name,
            'rawJSON': json.dumps(alert)
        }
        return incident


    """

    ENTRY ENTITIES

    """


    def indicator_entry(indicator):

        indicator_entry = {
            'OS': ', '.join(indicator.get('platforms', [])),
            'Name': indicator.get('name'),
            'Created By': indicator.get('created_by'),
            'Active Since': indicator.get('active_since'),
            'Category': indicator.get('category', {}).get('name'),
            'Signature': indicator.get('signature'),
            'Active Condition': indicator.get('stats', {}).get('active_conditions'),
            'Hosts With Alerts': indicator.get('stats', {}).get('alerted_agents'),
            'Source Alerts': indicator.get('stats', {}).get('source_alerts')
        }
        return indicator_entry


    def host_entry(host):

        host_entry = {
            'Host Name': host.get('hostname'),
            'Last Poll': host.get('last_poll_timestamp'),
            'Agent ID': host.get('_id'),
            'Agent Version': host.get('agent_version'),
            'Host IP': host.get('primary_ip_address'),
            'OS': host.get('os', {}).get('platform'),
            'Containment State': host.get('containment_state'),
            'Domain': host.get('domain'),
            'Last Alert': host.get('last_alert')
        }
        return host_entry


    def host_set_entry(host_sets):
        host_set_entries = [{
            'Name': host_set.get('name'),
            'ID': host_set.get('_id'),
            'Type': host_set.get('type')
        } for host_set in host_sets]
        return host_set_entries


    def alert_entry(alert):

        alert_entry = {
            'Alert ID': alert.get('_id'),
            'Reported': alert.get('reported_at'),
            'Event Type': alert.get('event_type'),
            'Agent ID': alert.get('agent', {}).get('_id')
        }
        return alert_entry


    def condition_entry(condition):

        indicator_entry = {
            'Event Type': condition.get('event_type'),
            'Operator': condition.get('tests', {})[0].get('operator'),
            'Value': condition.get('tests', {})[0].get('value'),

        }
        return indicator_entry


    def host_results_md_entry(host_entry):

        results = host_entry.get('results', [])
        host_info = host_entry.get('host', {})
        entries = []
        for result in results:
            data = result.get('data', {})
            entry = {
                'Item Type': result.get('type'),
                'Summary': ' '.join(['**{}** {}'.format(k, v) for k, v in data.items()])
            }
            entries.append(entry)

        md_table = tableToMarkdown(
            host_info.get('hostname'),
            entries,
            headers=['Item Type', 'Summary']
        )
        return md_table


    """

    ADDITIONAL FUNCTIONS

    """


    def http_request(method, url, body=None, headers={}, url_params=None, conditions_params=None):
        """

        returns the http response

        """

        # add token to headers
        headers['X-FeApi-Token'] = TOKEN

        request_kwargs = {
            'headers': headers,
            'verify': USE_SSL
        }

        # add optional arguments if specified
        if body:
            # request_kwargs['data'] = ' '.join(format(x, 'b') for x in bytearray(json.dumps(body)))
            request_kwargs['data'] = json.dumps(body)
        if url_params:
            request_kwargs['params'] = url_params
        if conditions_params:
            request_kwargs['data'] = conditions_params

        LOG('attempting {} request sent to {} with arguments:\n{}'.format(method, url, json.dumps(request_kwargs, indent=4)))
        try:
            response = requests.request(
                method,
                url,
                **request_kwargs
            )
        except requests.exceptions.SSLError as e:
            LOG(e)
            raise ValueError('An SSL error occurred when trying to connect to the server. Consider configuring unsecure connection in \
            the integration settings.')

        # handle request failure
        if response.status_code not in range(200, 205):
            message = parse_error_response(response)
            raise ValueError('Request failed with status code {}\n{}'.format(response.status_code, message))

        return response


    def logout():

        url = '{}/token'.format(BASE_PATH)

        try:
            http_request(
                'DELETE',
                url
            )
        except ValueError as e:
            LOG('Failed to logout with token')
            raise e
        LOG('logout successfully')


    def parse_error_response(response):

        try:
            res = response.json()
            msg = res.get('message')
            if res.get('details') is not None and res.get('details')[0].get('message') is not None:
                msg = msg + "\n" + json.dumps(res.get('details')[0])
        except Exception as e:
            LOG(e)
            return response.text
        return msg


    def return_error_entry(message):

        error_entry = {
            'Type': entryTypes['error'],
            'Contents': message,
            'ContentsFormat': formats['text']
        }

        demisto.results(error_entry)


    """

    EXECUTION

    """


    set_proxies()

    command = demisto.command()
    LOG('Running command "{}"'.format(command))

    # ask for a token using user credentials
    TOKEN = get_token()

    try:
        if command == 'test-module':
            # token generated - credentials are valid
            demisto.results('ok')
        elif command == 'fetch-incidents':
            fetch_incidents()
        elif command == 'fireeye-hx-get-alerts':
            get_alerts()
        elif command == 'fireeye-hx-cancel-containment':
            containment_cancellation()
        elif command == 'fireeye-hx-host-containment':
            containment()
        elif command == 'fireeye-hx-create-indicator':
            create_indicator()
        elif command == 'fireeye-hx-get-indicator':
            get_indicator()
            get_indicator_conditions()
        elif command == 'fireeye-hx-get-indicators':
            get_indicators()
        elif command == 'fireeye-hx-suppress-alert':
            suppress_alert()
        elif command == 'fireeye-hx-get-host-information':
            get_host_information()
        elif command == 'fireeye-hx-get-alert':
            get_alert()
        elif command == 'fireeye-hx-file-acquisition':
            file_acquisition()
        elif command == 'fireeye-hx-delete-file-acquisition':
            delete_file_acquisition()
        elif command == 'fireeye-hx-data-acquisition':
            data_acquisition()
        elif command == 'fireeye-hx-delete-data-acquisition':
            delete_data_acquisition()
        elif command == 'fireeye-hx-search':
            start_search()
        elif command == 'fireeye-hx-get-host-set-information':
            get_host_set_information()
        elif command == 'fireeye-hx-append-conditions':
            append_conditions()
        elif command == 'fireeye-hx-get-all-hosts-information':
            get_hosts_information()
    except ValueError as e:
        LOG(e)
        LOG.print_log()
        return_error(e)
    finally:
        logout()
  type: python
system: true
