category: Case Management
commonfields:
  id: ServiceNow
  version: -1
configuration:
- defaultvalue: ""
  display: ServiceNow URL, in the format https://company.service-now.com/
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: Username
  name: credentials
  required: false
  type: 9
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: incident
  display: Default ticket type for running ticket commands and fetching incidents
  name: ticket_type
  required: false
  type: 0
- defaultvalue: ""
  display: ServiceNow API Version (e.g. 'v1')
  name: api_version
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: stateNOT IN6,7
  display: The query to use when fetching incidents
  name: sysparm_query
  required: false
  type: 0
- defaultvalue: "10"
  display: How many incidents to fetch each time
  name: fetch_limit
  required: false
  type: 0
- defaultvalue: 10 minutes
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3
    months, 1 year)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: opened_at
  display: |-
    Timestamp field to filter by (e.g., `opened_at`)
    This is how the filter is applied to the query: â€œORDERBYopened_at^opened_at>[Last Run]. To prevent duplicate incidents, this field is mandatory for fetching incidents.
  name: timestamp_field
  required: false
  type: 0
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Get incident attachments
  name: get_attachments
  required: false
  type: 8
description: IT service management
display: ServiceNow
image: data:image/png;base64,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
name: ServiceNow
script:
  commands:
  - arguments:
    - default: true
      description: Ticket System ID
      name: id
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: Ticket number to retrieve
      name: number
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to retrieve ticket attachments, default false
      name: get_attachments
      predefined:
      - "true"
      - "false"
    description: Retrieve ticket information by specific ticket ID
    name: servicenow-get-ticket
    outputs:
    - contextPath: ServiceNow.Ticket.ID
      description: ServiceNow ticket ID
      type: string
    - contextPath: ServiceNow.Ticket.OpenedBy
      description: ServiceNow ticket opener ID
      type: string
    - contextPath: ServiceNow.Ticket.CreatedOn
      description: ServiceNow ticket creation date.
      type: date
    - contextPath: ServiceNow.Ticket.Assignee
      description: ServiceNow ticket assignee ID
      type: string
    - contextPath: ServiceNow.Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: ServiceNow.Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: ServiceNow.Ticket.Number
      description: ServiceNow ticket number
      type: string
    - contextPath: ServiceNow.Ticket.Active
      description: ServiceNow ticket active
      type: boolean
    - contextPath: ServiceNow.Ticket.AdditionalComments
      description: ServiceNow ticket comments
      type: string
    - contextPath: ServiceNow.Ticket.Priority
      description: ServiceNow ticket priority
      type: string
    - contextPath: ServiceNow.Ticket.OpenedAt
      description: ServiceNow ticket opening time
      type: date
    - contextPath: ServiceNow.Ticket.ResolvedBy
      description: ServiceNow ticket resolver ID
      type: string
    - contextPath: ServiceNow.Ticket.CloseCode
      description: ServiceNow ticket close code
      type: string
    - contextPath: File.Info
      description: Attachment file info
      type: string
    - contextPath: File.Name
      description: Attachment file name
      type: string
    - contextPath: File.Size
      description: Attachment file size
      type: number
    - contextPath: File.SHA1
      description: Attachment file SHA1
      type: string
    - contextPath: File.SHA256
      description: Attachment file SHA256
      type: string
    - contextPath: File.EntryID
      description: Attachment file entry ID
      type: string
    - contextPath: File.Type
      description: Attachment file type
      type: string
    - contextPath: File.MD5
      description: Attachment file MD5
      type: string
  - arguments:
    - default: true
      description: Ticket System ID to retrieve
      name: id
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: Ticket number to retrieve
      name: number
    - description: Whether to retrieve ticket attachments, default false
      name: get_attachments
    deprecated: true
    description: Deprecated. Use servicenow-get-ticket or servicenow-get-record instead
    name: servicenow-get
    outputs:
    - contextPath: Ticket.ID
      description: The unique ticket identifier(sys_id).
      type: string
    - contextPath: Ticket.Creator
      description: A string field that indicates the user who created the ticket.
      type: string
    - contextPath: Ticket.CreatedOn
      description: The date and time when the ticket was created.
      type: date
    - contextPath: Ticket.Assignee
      description: Specifies the user assigned to complete the ticket. By default,
        this field uses a reference qualifier to only display users with the itil
        role.
      type: string
    - contextPath: Ticket.State
      description: Status of the ticket.
      type: string
    - contextPath: Ticket.Summary
      description: A human-readable title for the record.
      type: string
    - contextPath: Ticket.Number
      description: The display value of the ticket.
      type: string
    - contextPath: Ticket.Active
      description: Specifies whether work is still being done on a task or whether
        the work for the task is complete.
      type: boolean
    - contextPath: Ticket.AdditionalComments
      description: Comments about the task record.
      type: Unknown
    - contextPath: Ticket.Priority
      description: Specifies how high a priority the ticket should be for the assignee.
      type: string
    - contextPath: Ticket.OpenedAt
      description: The date and time when the ticket was opened for the first time.
      type: date
    - contextPath: File.Info
      description: Attachment file info
      type: string
    - contextPath: File.Name
      description: Attachment file name
      type: string
    - contextPath: File.Size
      description: Attachment file size
      type: number
    - contextPath: File.SHA1
      description: Attachment file SHA1
      type: string
    - contextPath: File.SHA256
      description: Attachment file SHA256
      type: string
    - contextPath: File.EntryID
      description: Attachment file entry ID
      type: string
    - contextPath: File.Type
      description: Attachment file type
      type: string
    - contextPath: File.MD5
      description: Attachment file MD5
      type: string
  - arguments:
    - default: true
      description: Ticket System ID to retrieve
      name: id
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    - description: Ticket number to retrieve
      name: number
    deprecated: true
    description: Deprecated. Use servicenow-get-ticket or servicenow-get-record instead
    name: servicenow-incident-get
    outputs:
    - contextPath: Ticket.ID
      description: ServiceNow ticket System ID
      type: string
    - contextPath: Ticket.Creator
      description: ServiceNow ticket creator
      type: string
    - contextPath: Ticket.Assignee
      description: ServiceNow ticket assignee
      type: string
    - contextPath: Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: Ticket.Number
      description: ServiceNow ticket number
      type: string
  - arguments:
    - description: Short description of the ticket
      name: short_description
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - auto: PREDEFINED
      description: Ticket urgency
      name: urgency
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket severity
      name: severity
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket impact
      name: impact
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Set ticket as Active
      name: active
      predefined:
      - "true"
      - "false"
    - description: Set ticket ActivityDue - format "2016-07-02 21:51:11"
      name: activity_due
    - description: List of assigned users to the ticket
      name: additional_assignee_list
    - description: Ticket history approval
      name: approval_history
    - description: Set ticket ApprovalSet - format "2016-07-02 21:51:11"
      name: approval_set
    - description: To whom the ticket is assigned
      name: assigned_to
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: business_duration
    - description: Business service
      name: business_service
    - description: Business source
      name: business_stc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: calendar_duration
    - description: UID Format
      name: caller_id
    - description: Category of ticket
      name: category
    - description: UID Format
      name: caused_by
    - auto: PREDEFINED
      description: Ticket's close code
      name: close_code
      predefined:
      - Solved (Work Around)
      - Solved (Permanently)
      - Solved Remotely (Work Around)
      - Solved Remotely (Permanently)
      - Not Solved (Not Reproducible)
      - Not Solved (Too Costly)
      - Closed/Resolved by Caller
    - description: Close notes of the ticket
      name: close_notes
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: closed_at
    - description: User who closed the ticket
      name: closed_by
    - description: UID Format
      name: cmdb_ci
    - description: Format type journal input
      name: comments
    - description: Format type journal input
      name: comments_and_work_notes
    - description: UID Format
      name: company
    - description: Contact type
      name: contact_type
    - description: Correlation display
      name: correlation_display
    - description: Correlation id
      name: correlation_id
    - description: UID Format
      name: delivery_plan
    - auto: PREDEFINED
      description: If you want to display comments, work_notes...
      name: display
      predefined:
      - "true"
      - "false"
    - description: Ticket description
      name: description
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: due_date
    - description: Escalation
      name: escalation
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: expected_start
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: follow_up
    - description: UID format list
      name: group_list
    - auto: PREDEFINED
      description: Is the ticket solved in the knowledge base
      name: knowledge
      predefined:
      - "true"
      - "false"
    - description: Location of the ticket
      name: location
    - description: SLA of the ticket
      name: made_sla
    - auto: PREDEFINED
      description: Notify about this ticket
      name: notify
      predefined:
      - "1"
      - "0"
    - description: Order number
      name: order
    - description: UID Format
      name: parent
    - description: UID Format
      name: parent_incident
    - description: UID Format
      name: problem_id
    - description: How many users included in this ticket before
      name: reassignment_count
    - description: How many time the ticket has been reopened
      name: reopen_count
    - description: 'Resolving time, Format: YYYY-MM-DD HH:MM:SS'
      name: resolved_at
    - description: UID Format
      name: resolved_by
    - description: UID
      name: rfc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sla_due
    - description: Subcategory
      name: subcategory
    - description: Last updated by
      name: sys_updated_by
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sys_updated_on
    - description: Input from the end user
      name: user_input
    - description: A list of watched tickets
      name: watch_list
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: work_end
    - description: Format journal list
      name: work_notes
    - description: List with UIDs
      name: work_notes_list
    - description: Date when started to work on the ticket
      name: work_start
    - description: Set AssignmentGroup - sys_id of group
      name: assignment_group
    - description: integer
      name: incident_state
    - description: Ticket number
      name: number
    - auto: PREDEFINED
      description: Priority of the ticket
      name: priority
      predefined:
      - 5 - Planning
      - 4 - Low
      - 3 - Moderate
      - 2 - High
      - 1 - Critical
    - description: Template name to use as a base to create new tickets.
      name: template
    - description: 'Custom(user defined) fields in the format: fieldname1=value;fieldname2=value;
        custom fields start with a "u_".'
      name: custom_fields
    - auto: PREDEFINED
      defaultValue: normal
      description: Type of Change Request ticket
      name: change_type
      predefined:
      - normal
      - standard
      - emergency
    - description: State of the ticket, e.g., "Closed" or "7" or "7 - Closed".
      name: state
    - description: ' Ticket opening time, Format: YYYY-MM-DD HH:MM:SS'
      name: opened_at
    - description: Caller system ID
      name: caller
    description: Create new ServiceNow ticket
    name: servicenow-create-ticket
    outputs:
    - contextPath: ServiceNow.Ticket.ID
      description: ServiceNow ticket ID
      type: string
    - contextPath: ServiceNow.Ticket.OpenedBy
      description: ServiceNow ticket opener ID
      type: string
    - contextPath: ServiceNow.Ticket.CreatedOn
      description: ServiceNow ticket creation date.
      type: date
    - contextPath: ServiceNow.Ticket.Assignee
      description: ServiceNow ticket assignee ID
      type: string
    - contextPath: ServiceNow.Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: ServiceNow.Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: ServiceNow.Ticket.Number
      description: ServiceNow ticket number
      type: string
    - contextPath: ServiceNow.Ticket.Active
      description: ServiceNow ticket active
      type: boolean
    - contextPath: ServiceNow.Ticket.AdditionalComments
      description: ServiceNow ticket comments
      type: string
    - contextPath: ServiceNow.Ticket.Priority
      description: ServiceNow ticket priority
      type: string
    - contextPath: ServiceNow.Ticket.OpenedAt
      description: ServiceNow ticket opening time
      type: date
    - contextPath: ServiceNow.Ticket.ResolvedBy
      description: ServiceNow ticket resolver ID
      type: string
    - contextPath: ServiceNow.Ticket.CloseCode
      description: ServiceNow ticket close code
      type: string
  - arguments:
    - description: Short description of the ticket
      name: short_description
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - auto: PREDEFINED
      description: Ticket urgency
      name: urgency
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket severity
      name: severity
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket impact
      name: impact
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Set ticket as Active
      name: active
      predefined:
      - "true"
      - "false"
    - description: Set ticket ActivityDue - format "2016-07-02 21:51:11" glide_date_time
      name: activity_due
    - description: List of assigned users to the ticket
      name: additional_assignee_list
    - description: Ticket history approval
      name: approval_history
    - description: Set ticket ApprovalSet - format "2016-07-02 21:51:11" glide_date_time
      name: approval_set
    - description: To whom the ticket is assigned
      name: assigned_to
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: business_duration
    - description: Business service
      name: business_service
    - description: Business source
      name: business_stc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: calendar_duration
    - description: UID Format
      name: caller_id
    - description: Category of ticket
      name: category
    - description: UID Format
      name: caused_by
    - description: Ticket's close code
      name: close_code
    - description: Close notes of the ticket
      name: close_notes
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: closed_at
    - description: User who closed the ticket
      name: closed_by
    - description: UID Format
      name: cmdb_ci
    - description: Format type journal input
      name: comments
    - description: Format type journal input
      name: comments_and_work_notes
    - description: UID Format
      name: company
    - description: Contact type
      name: contact_type
    - description: Correlation display
      name: correlation_display
    - description: Correlation id
      name: correlation_id
    - description: UID Format
      name: delivery_plan
    - auto: PREDEFINED
      description: If you want to display comments, work_notes...
      name: display
      predefined:
      - "true"
      - "false"
    - description: Ticket description
      name: description
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: due_date
    - description: Escalation
      name: escalation
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: expected_start
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: follow_up
    - description: UID format list
      name: group_list
    - auto: PREDEFINED
      description: Is the ticket solved in the knowledge base
      name: knowledge
      predefined:
      - "true"
      - "false"
    - description: Location of the ticket
      name: location
    - description: SLA of the ticket
      name: made_sla
    - auto: PREDEFINED
      description: Notify about this ticket
      name: notify
      predefined:
      - "1"
      - "0"
    - description: Order number
      name: order
    - description: UID Format
      name: parent
    - description: UID Format
      name: parent_incident
    - description: UID Format
      name: problem_id
    - description: How many users included in this ticket before
      name: reassignment_count
    - description: How many time the ticket has been reopened
      name: reopen_count
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: resolved_at
    - description: UID Format
      name: resolved_by
    - description: UID
      name: rfc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sla_due
    - description: Subcategory
      name: subcategory
    - description: Last updated by
      name: sys_updated_by
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sys_updated_on
    - description: Input from the end user
      name: user_input
    - description: A list of watched tickets
      name: watch_list
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: work_end
    - description: Format journal list
      name: work_notes
    - description: List with UIDs
      name: work_notes_list
    - description: Date when started to work on the ticket
      name: work_start
    - description: Set AssignmentGroup - uuid of group like 46b87022a9fe198101a78787e40d7547
      name: assignment_group
    - description: integer
      name: incident_state
    - description: Ticket number
      name: number
    - auto: PREDEFINED
      description: Priority of the ticket (number)
      name: priority
      predefined:
      - 5 - Planning
      - 4 - Low
      - 3 - Moderate
      - 2 - High
      - 1 - Critical
    - description: Template name to use as a base to create new tickets.
      name: template
    - description: 'Custom(user defined) fields in the format: fieldname1=value;fieldname2=value;...'
      name: custom_fields
    - auto: PREDEFINED
      defaultValue: normal
      description: Type of Change Request ticket
      name: type
      predefined:
      - normal
      - standard
      - emergency
    - description: State of the ticket
      name: state
    deprecated: true
    description: Deprecated. Use servicenow-create-ticket or servicenow-create-record
      instead
    name: servicenow-create
    outputs:
    - contextPath: Ticket.ID
      description: ServiceNow ticket System ID
      type: string
    - contextPath: Ticket.Creator
      description: ServiceNow ticket creator
      type: string
    - contextPath: Ticket.Assignee
      description: ServiceNow ticket assignee
      type: string
    - contextPath: Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: Ticket.Number
      description: ServiceNow ticket number
      type: string
  - arguments:
    - description: Short description of the ticket
      name: short_description
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    - description: Ticket urgency
      name: urgency
    - description: Ticket severity
      name: severity
    - description: Ticket impact
      name: impact
    - auto: PREDEFINED
      description: Set ticket as Active
      name: active
      predefined:
      - "true"
      - "false"
    - description: Set ticket ActivityDue - format "2016-07-02 21:51:11" glide_date_time
      name: activity_due
    - description: List of assigned users to the ticket
      name: additional_assignee_list
    - description: Ticket history approval
      name: approval_history
    - description: Set ticket ApprovalSet - format "2016-07-02 21:51:11" glide_date_time
      name: approval_set
    - description: To whom the ticket is assigned
      name: assigned_to
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: business_duration
    - description: Business service
      name: business_service
    - description: Business source
      name: business_stc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: calendar_duration
    - description: UID Format
      name: caller_id
    - description: Category name
      name: category
    - description: UID Format
      name: caused_by
    - description: Ticket's close code
      name: close_code
    - description: Close notes of the ticket
      name: close_notes
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: closed_at
    - description: User who closed the ticket
      name: closed_by
    - description: UID Format
      name: cmdb_ci
    - description: Format type journal input
      name: comments
    - description: Format type journal input
      name: comments_and_work_notes
    - description: UID Format
      name: company
    - description: Contact type
      name: contact_type
    - description: Correlation display
      name: correlation_display
    - description: Correlation id
      name: correlation_id
    - description: UID Format
      name: delivery_plan
    - auto: PREDEFINED
      description: If you want to display comments, work_notes...
      name: display
      predefined:
      - "true"
      - "false"
    - description: Ticket description
      name: description
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: due_date
    - description: Escalation
      name: escalation
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: expected_start
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: follow_up
    - description: UID format list
      name: group_list
    - auto: PREDEFINED
      description: Is the ticket solved in the knowledge base
      name: knowledge
      predefined:
      - "true"
      - "false"
    - description: Location of the ticket
      name: location
    - description: SLA of the ticket
      name: made_sla
    - auto: PREDEFINED
      description: Notify about this ticket
      name: notify
      predefined:
      - "1"
      - "0"
    - description: Order number
      name: order
    - description: UID Format
      name: parent
    - description: UID Format
      name: parent_incident
    - description: UID Format
      name: problem_id
    - description: How many users included in this ticket before
      name: reassignment_count
    - description: How many time the ticket has been reopened
      name: reopen_count
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: resolved_at
    - description: UID Format
      name: resolved_by
    - description: UID
      name: rfc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sla_due
    - description: Subcategory
      name: subcategory
    - description: Last updated by
      name: sys_updated_by
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sys_updated_on
    - description: Input from the end user
      name: user_input
    - description: A list of watched tickets
      name: watch_list
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: work_end
    - description: Format journal list
      name: work_notes
    - description: List with UIDs
      name: work_notes_list
    - description: Date when started to work on the ticket
      name: work_start
    - description: Set AssignmentGroup - uuid of group like 46b87022a9fe198101a78787e40d7547
      name: assignment_group
    - description: integer
      name: incident_state
    - description: Ticket number
      name: number
    - description: Priority of the ticket (number)
      name: priority
    - description: Template name to use as a base to create new tickets.
      name: template
    deprecated: true
    description: Create a new ServiceNow ticket
    name: servicenow-incident-create
    outputs:
    - contextPath: Ticket.ID
      description: ServiceNow ticket System ID
      type: string
    - contextPath: Ticket.Creator
      description: ServiceNow ticket creator
      type: string
    - contextPath: Ticket.Assignee
      description: ServiceNow ticket assignee
      type: string
    - contextPath: Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: Ticket.Number
      description: ServiceNow ticket number
      type: string
  - arguments:
    - description: Short description of the ticket
      name: short_description
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - auto: PREDEFINED
      description: Ticket urgency
      name: urgency
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket severity
      name: severity
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket impact
      name: impact
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Does the ticket active(true/false)
      name: active
      predefined:
      - "true"
      - "false"
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: activity_due
    - description: List of assigned users to the ticket
      name: additional_assignee_list
    - description: Ticket history approval
      name: approval_history
    - description: Set ticket ApprovalSet - format "2016-07-02 21:51:11"
      name: approval_set
    - description: To whom the ticket is assigned
      name: assigned_to
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: business_duration
    - description: Business service
      name: business_service
    - description: Business source
      name: business_stc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: calendar_duration
    - description: UID Format
      name: caller_id
    - description: Category name
      name: category
    - description: UID Format
      name: caused_by
    - auto: PREDEFINED
      description: Ticket's close code
      name: close_code
      predefined:
      - Solved (Work Around)
      - Solved (Permanently)
      - Solved Remotely (Work Around)
      - Solved Remotely (Permanently)
      - Not Solved (Not Reproducible)
      - Not Solved (Too Costly)
      - Closed/Resolved by Caller
    - description: Close notes of the ticket
      name: close_notes
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: closed_at
    - description: User who closed the ticket
      name: closed_by
    - description: UID Format
      name: cmdb_ci
    - description: Format type journal input
      name: comments
    - description: Format type journal input
      name: comments_and_work_notes
    - description: UID Format
      name: company
    - description: Contact type
      name: contact_type
    - description: Correlation display
      name: correlation_display
    - description: Correlation id
      name: correlation_id
    - description: UID Format
      name: delivery_plan
    - auto: PREDEFINED
      description: If you want to display comments, work_notes...
      name: display
      predefined:
      - "true"
      - "false"
    - description: Ticket description
      name: description
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: due_date
    - description: Escalation
      name: escalation
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: expected_start
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: follow_up
    - description: UID format list
      name: group_list
    - auto: PREDEFINED
      description: Is the ticket solved in the knowledge base
      name: knowledge
      predefined:
      - "true"
      - "false"
    - description: Location of the ticket
      name: location
    - description: SLA of the ticket
      name: made_sla
    - auto: PREDEFINED
      description: Notify about this ticket
      name: notify
      predefined:
      - "1"
      - "0"
    - description: Order number
      name: order
    - description: UID Format
      name: parent
    - description: UID Format
      name: parent_incident
    - description: UID Format
      name: problem_id
    - description: How many users included in this ticket before
      name: reassignment_count
    - description: How many time the ticket has been reopened
      name: reopen_count
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: resolved_at
    - description: UID Format
      name: resolved_by
    - description: UID
      name: rfc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sla_due
    - description: Subcategory
      name: subcategory
    - description: Last updated by
      name: sys_updated_by
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sys_updated_on
    - description: Input from the end user
      name: user_input
    - description: A list of watched tickets
      name: watch_list
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: work_end
    - description: Format journal list
      name: work_notes
    - description: List with UIDs
      name: work_notes_list
    - description: Date when started to work on the ticket
      name: work_start
    - description: UID
      name: assignment_group
    - description: integer
      name: incident_state
    - description: Ticket number
      name: number
    - auto: PREDEFINED
      description: Priority of the ticket
      name: priority
      predefined:
      - 5 - Planning
      - 4 - Low
      - 3 - Moderate
      - 2 - High
      - 1 - Critical
    - description: System ID of the ticket to update
      name: id
      required: true
    - description: 'Custom(user defined) fields in the format: fieldname1=value;fieldname2=value;
        custom fields start with a "u_".'
      name: custom_fields
    - auto: PREDEFINED
      defaultValue: normal
      description: Type of Change Request ticket
      name: change_type
      predefined:
      - normal
      - standard
      - emergency
    - description: State of the ticket, e.g., "Closed" or "7" or "7 - Closed".
      name: state
    - description: Caller system ID
      name: caller
    description: Update specific ticket
    name: servicenow-update-ticket
  - arguments:
    - description: Short description of the ticket
      name: short_description
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - auto: PREDEFINED
      description: Ticket urgency
      name: urgency
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket severity
      name: severity
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Ticket impact
      name: impact
      predefined:
      - 3 - Low
      - 2 - Medium
      - 1 - High
    - auto: PREDEFINED
      description: Does the ticket active(true/false)
      name: active
      predefined:
      - "true"
      - "false"
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: activity_due
    - description: List of assigned users to the ticket
      name: additional_assignee_list
    - description: Ticket history approval
      name: approval_history
    - description: Set ticket ApprovalSet - format "2016-07-02 21:51:11" glide_date_time
      name: approval_set
    - description: To whom the ticket is assigned
      name: assigned_to
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: business_duration
    - description: Business service
      name: business_service
    - description: Business source
      name: business_stc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: calendar_duration
    - description: UID Format
      name: caller_id
    - description: Category name
      name: category
    - description: UID Format
      name: caused_by
    - description: Ticket's close code
      name: close_code
    - description: Close notes of the ticket
      name: close_notes
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: closed_at
    - description: User who closed the ticket
      name: closed_by
    - description: UID Format
      name: cmdb_ci
    - description: Format type journal input
      name: comments
    - description: Format type journal input
      name: comments_and_work_notes
    - description: UID Format
      name: company
    - description: Contact type
      name: contact_type
    - description: Correlation display
      name: correlation_display
    - description: Correlation id
      name: correlation_id
    - description: UID Format
      name: delivery_plan
    - auto: PREDEFINED
      description: If you want to display comments, work_notes...
      name: display
      predefined:
      - "true"
      - "false"
    - description: Ticket description
      name: description
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: due_date
    - description: Escalation
      name: escalation
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: expected_start
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: follow_up
    - description: UID format list
      name: group_list
    - auto: PREDEFINED
      description: Is the ticket solved in the knowledge base
      name: knowledge
      predefined:
      - "true"
      - "false"
    - description: Location of the ticket
      name: location
    - description: SLA of the ticket
      name: made_sla
    - auto: PREDEFINED
      description: Notify about this ticket
      name: notify
      predefined:
      - "1"
      - "0"
    - description: Order number
      name: order
    - description: UID Format
      name: parent
    - description: UID Format
      name: parent_incident
    - description: UID Format
      name: problem_id
    - description: How many users included in this ticket before
      name: reassignment_count
    - description: How many time the ticket has been reopened
      name: reopen_count
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: resolved_at
    - description: UID Format
      name: resolved_by
    - description: UID
      name: rfc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sla_due
    - description: Subcategory
      name: subcategory
    - description: Last updated by
      name: sys_updated_by
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sys_updated_on
    - description: Input from the end user
      name: user_input
    - description: A list of watched tickets
      name: watch_list
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: work_end
    - description: Format journal list
      name: work_notes
    - description: List with UIDs
      name: work_notes_list
    - description: Date when started to work on the ticket
      name: work_start
    - description: UID
      name: assignment_group
    - description: integer
      name: incident_state
    - description: Ticket number
      name: number
    - auto: PREDEFINED
      description: Priority of the ticket
      name: priority
      predefined:
      - 5 - Planning
      - 4 - Low
      - 3 - Moderate
      - 2 - High
      - 1 - Critical
    - description: System ID of the ticket to update
      name: id
      required: true
    - description: 'Custom(user defined) fields in the format: fieldname1=value;fieldname2=value;...'
      name: custom_fields
    - auto: PREDEFINED
      defaultValue: normal
      description: Type of Change Request ticket
      name: type
      predefined:
      - normal
      - standard
      - emergency
    - description: State of the ticket
      name: state
    deprecated: true
    description: Deprecated. Use servicenow-update-ticket or servicenow-update-record
      instead
    name: servicenow-update
  - arguments:
    - description: Short description of the ticket
      name: short_description
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    - description: Ticket urgency
      name: urgency
    - description: Ticket severity
      name: severity
    - description: Ticket impact
      name: impact
    - auto: PREDEFINED
      description: Does the ticket active(true/false)
      name: active
      predefined:
      - "true"
      - "false"
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: activity_due
    - description: List of assigned users to the ticket
      name: additional_assignee_list
    - description: Ticket history approval
      name: approval_history
    - description: Set ticket ApprovalSet - format "2016-07-02 21:51:11" glide_date_time
      name: approval_set
    - description: To whom the ticket is assigned
      name: assigned_to
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: business_duration
    - description: Business service
      name: business_service
    - description: Business source
      name: business_stc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: calendar_duration
    - description: UID Format
      name: caller_id
    - description: Category name
      name: category
    - description: UID Format
      name: caused_by
    - description: Ticket's close code
      name: close_code
    - description: Close notes of the ticket
      name: close_notes
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: closed_at
    - description: User who closed the ticket
      name: closed_by
    - description: UID Format
      name: cmdb_ci
    - description: Format type journal input
      name: comments
    - description: Format type journal input
      name: comments_and_work_notes
    - description: UID Format
      name: company
    - description: Contact type
      name: contact_type
    - description: Correlation display
      name: correlation_display
    - description: Correlation id
      name: correlation_id
    - description: UID Format
      name: delivery_plan
    - auto: PREDEFINED
      description: If you want to display comments, work_notes...
      name: display
      predefined:
      - "true"
      - "false"
    - description: Ticket description
      name: description
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: due_date
    - description: Escalation
      name: escalation
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: expected_start
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: follow_up
    - description: UID format list
      name: group_list
    - auto: PREDEFINED
      description: Is the ticket solved in the knowledge base
      name: knowledge
      predefined:
      - "true"
      - "false"
    - description: Location of the ticket
      name: location
    - description: SLA of the ticket
      name: made_sla
    - auto: PREDEFINED
      description: Notify about this ticket
      name: notify
      predefined:
      - "1"
      - "0"
    - description: Order number
      name: order
    - description: UID Format
      name: parent
    - description: UID Format
      name: parent_incident
    - description: UID Format
      name: problem_id
    - description: How many users included in this ticket before
      name: reassignment_count
    - description: How many time the ticket has been reopened
      name: reopen_count
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: resolved_at
    - description: UID Format
      name: resolved_by
    - description: UID
      name: rfc
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sla_due
    - description: Subcategory
      name: subcategory
    - description: Last updated by
      name: sys_updated_by
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: sys_updated_on
    - description: Input from the end user
      name: user_input
    - description: A list of watched tickets
      name: watch_list
    - description: 'Format: YYYY-MM-DD HH:MM:SS'
      name: work_end
    - description: Format journal list
      name: work_notes
    - description: List with UIDs
      name: work_notes_list
    - description: Date when started to work on the ticket
      name: work_start
    - description: UID
      name: assignment_group
    - description: integer
      name: incident_state
    - description: Ticket number
      name: number
    - description: Priority of the ticket (number)
      name: priority
    - description: System ID of the ticket to update
      name: id
      required: true
    deprecated: true
    description: Deprecated. Use servicenow-update-ticket or servicenow-update-record
      instead
    name: servicenow-incident-update
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    description: Delete a ticket from ServiceNow
    name: servicenow-delete-ticket
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: The actual link to publish in ServiceNow ticket, valid url format,
        like http://www.demisto.com
      name: link
      required: true
    - description: Publish the link as comment on the ticket, if false will publish
        the link as WorkNote, format bool
      name: post-as-comment
    - description: The text to represent the link
      name: text
    description: Add a link to specific ticket
    name: servicenow-add-link
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    - description: The actual link to publish in ServiceNow ticket, valid url format,
        like http://www.demisto.com
      name: link
      required: true
    - description: Publish the link as comment on the ticket, by default true, if
        false will publish the link as WorkNote, format bool
      name: post-as-comment
    - description: The text to represent the link
      name: text
    deprecated: true
    description: Deprecated. Use servicenow-add-link instead.
    name: servicenow-incident-add-link
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: Comment to add
      name: comment
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: Specify to publish the note as comment on the ticket.
      name: post-as-comment
      predefined:
      - "true"
      - "false"
    description: Add comment to specific ticket by providing ticket id
    name: servicenow-add-comment
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    - description: Comment to add
      name: comment
      required: true
    - description: Publish the link as comment on the ticket, if false will publish
        the link as WorkNote, format bool
      name: post-as-comment
    deprecated: true
    description: Deprecated. Use servicenow-add-comment instead.
    name: servicenow-incident-add-comment
  - arguments:
    - defaultValue: "10"
      description: Limit for how many tickets to retrieve
      name: limit
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: The query to run. To learn about querying in ServiceNow, see https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html
      name: query
    - defaultValue: "0"
      description: Starting record index to begin retrieving records from
      name: offset
    description: Retrieve ticket info with a query
    name: servicenow-query-tickets
    outputs:
    - contextPath: Ticket.ID
      description: The unique ticket identifier.
      type: string
    - contextPath: Ticket.Creator
      description: A string field that indicates the user who created the ticket.
      type: string
    - contextPath: Ticket.CreatedOn
      description: The date and time when the ticket was created.
      type: date
    - contextPath: Ticket.Assignee
      description: Specifies the user assigned to complete the ticket. By default,
        this field uses a reference qualifier to only display users with the itil
        role.
      type: string
    - contextPath: Ticket.State
      description: Status of the ticket.
      type: string
    - contextPath: Ticket.Summary
      description: A human-readable title for the record.
      type: string
    - contextPath: Ticket.Number
      description: The display value of the ticket.
      type: string
    - contextPath: Ticket.Active
      description: Specifies whether work is still being done on a task or whether
        the work for the task is complete.
      type: boolean
    - contextPath: Ticket.AdditionalComments
      description: Comments about the task record.
      type: Unknown
    - contextPath: Ticket.Priority
      description: Specifies how high a priority the ticket should be for the assignee.
      type: string
    - contextPath: Ticket.OpenedAt
      description: The date and time when the ticket was opened for the first time.
      type: date
    - contextPath: Ticket.Escalation
      description: Indicates how long the ticket has been open.
      type: string
  - arguments:
    - defaultValue: "10"
      description: Limit for how many tickets to retrieve
      name: limit
    - description: Query
      name: sysparm_query
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: The query to run. To learn about querying in ServiceNow, see https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html
      name: query
    deprecated: true
    description: Deprecated. Use servicenow-query-table or servicenow-query-tickets
      instead.
    name: servicenow-query
    outputs:
    - contextPath: Ticket.ID
      description: ServiceNow ticket System ID
      type: string
    - contextPath: Ticket.Creator
      description: ServiceNow ticket creator
      type: string
    - contextPath: Ticket.Assignee
      description: ServiceNow ticket assignee
      type: string
    - contextPath: Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: Ticket.Number
      description: ServiceNow ticket number
      type: string
  - arguments:
    - defaultValue: "10"
      description: Limit for how many tickets to retrieve
      name: limit
    - description: Query
      name: sysparm_query
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    deprecated: true
    description: Deprecated. Use servicenow-query-table or servicenow-query-tickets
      instead.
    name: servicenow-incidents-query
    outputs:
    - contextPath: Ticket.ID
      description: ServiceNow ticket System ID
      type: string
    - contextPath: Ticket.Creator
      description: ServiceNow ticket creator
      type: string
    - contextPath: Ticket.Assignee
      description: ServiceNow ticket assignee
      type: string
    - contextPath: Ticket.State
      description: ServiceNow ticket state
      type: string
    - contextPath: Ticket.Summary
      description: ServiceNow ticket short summary
      type: string
    - contextPath: Ticket.Number
      description: ServiceNow ticket number
      type: string
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
      - sc_request
      - sc_task
    - description: War-room entry ID that includes the file
      name: file_id
      required: true
    - description: Filename of uploaded file to override the existing file name in
        entry
      name: file_name
    description: Upload a file to a specific ticket
    name: servicenow-upload-file
    outputs:
    - contextPath: ServiceNow.Ticket.File.Filename
      description: Name of the file
      type: string
    - contextPath: ServiceNow.Ticket.File.Link
      description: Download link for the file
      type: string
    - contextPath: ServiceNow.Ticket.File.SystemID
      description: System ID of the file
      type: string
  - arguments:
    - description: Ticket System ID
      name: id
      required: true
    - auto: PREDEFINED
      defaultValue: incident
      description: Ticket type
      name: ticket_type
      predefined:
      - incident
      - problem
      - change_request
    - description: War-room entry ID that includes the file
      name: file_id
      required: true
    - description: Filename of uploaded file to override the existing file name in
        entry
      name: file_name
    deprecated: true
    description: Deprecated. Use servicenow-upload-file instead.
    name: servicenow-incident-upload-file
    outputs:
    - contextPath: Ticket.File.Filename
      description: Name of the file
      type: string
    - contextPath: Ticket.File.Link
      description: Download link for the file
      type: string
    - contextPath: Ticket.File.SystemID
      description: System ID of the file
      type: string
  - arguments:
    - description: Servicenow group name
      name: name
      required: true
    deprecated: true
    description: Deprecated. Use servicenow-query-groups instead.
    name: servicenow-get-groups
    outputs:
    - contextPath: ServiceNowGroups.GroupId
      description: Group Id
      type: string
    - contextPath: ServiceNowGroups.GroupName
      description: Group name
      type: string
  - arguments:
    - description: machine name
      name: computerName
      required: true
    deprecated: true
    description: Deprecated. Use servicenow-query-computers instead.
    name: servicenow-get-computer
    outputs:
    - contextPath: ServiceNowComputer.sys_id
      description: 'Id '
      type: string
    - contextPath: ServiceNowComputer.u_code
      description: Code
      type: string
    - contextPath: ServiceNowComputer.support_group
      description: Support group
      type: string
    - contextPath: ServiceNowComputer.os
      description: Operating System
      type: string
    - contextPath: ServiceNowComputer.comments
      description: Comments
      type: string
  - arguments:
    - description: Record system ID
      name: id
      required: true
    - description: Comma separated table fields to display and output to the context,
        e.g name,tag,company. ID field is added by default.
      name: fields
    - description: The name of the table to get the record from
      name: table_name
      required: true
    description: Retrieve record information by specific record ID
    name: servicenow-get-record
    outputs:
    - contextPath: ServiceNow.Record.ID
      description: The unique record identifier for the record.
      type: string
    - contextPath: ServiceNow.Record.UpdatedBy
      description: A string field that indicates the user who most recently updated
        the record.
      type: string
    - contextPath: ServiceNow.Record.UpdatedAt
      description: A time-stamp field that indicates the date and time of the most
        recent update.
      type: date
    - contextPath: ServiceNow.Record.CreatedBy
      description: A string field that indicates the user who created the record.
      type: string
    - contextPath: ServiceNow.Record.CreatedOn
      description: time-stamp field that indicates when a record was created.
      type: date
  - arguments:
    - description: The name of the table to query
      name: table_name
      required: true
    - defaultValue: "10"
      description: Limit for how many tickets to retrieve
      name: limit
    - description: The query to run. For more information about querying in ServiceNow,
        see https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html
      name: query
    - description: Comma separated table fields to display and output to the context,
        e.g name,tag,company. ID field is added by default.
      isArray: true
      name: fields
    - defaultValue: "0"
      description: Starting record index to begin retrieving records from
      name: offset
    description: Query a specified table in ServiceNow
    name: servicenow-query-table
    outputs:
    - contextPath: ServiceNow.Results.ID
      description: The unique record identifier for the record.
      type: string
    - contextPath: ServiceNow.Results.UpdatedBy
      description: A string field that indicates the user who most recently updated
        the record.
      type: string
    - contextPath: ServiceNow.Results.UpdatedAt
      description: A time-stamp field that indicates the date and time of the most
        recent update.
      type: date
    - contextPath: ServiceNow.Results.CreatedBy
      description: A string field that indicates the user who created the record.
      type: string
    - contextPath: ServiceNow.Results.CreatedOn
      description: time-stamp field that indicates when a record was created.
      type: date
  - arguments:
    - description: The name of the table to create a record in.
      name: table_name
      required: true
    - description: 'Fields and their values to create the record with, in the format:
        fieldname1=value;fieldname2=value;...'
      name: fields
    - description: 'Custom(user defined) fields in the format: fieldname1=value;fieldname2=value;...'
      name: custom_fields
    description: Create a new record in a specified ServiceNow table
    name: servicenow-create-record
    outputs:
    - contextPath: ServiceNow.Record.ID
      description: The unique record identifier for the record.
      type: string
    - contextPath: ServiceNow.Record.UpdatedBy
      description: A string field that indicates the user who most recently updated
        the record.
      type: string
    - contextPath: ServiceNow.Record.UpdatedAt
      description: A time-stamp field that indicates the date and time of the most
        recent update.
      type: date
    - contextPath: ServiceNow.Record.CreatedBy
      description: A string field that indicates the user who created the record.
      type: string
    - contextPath: ServiceNow.Record.CreatedOn
      description: time-stamp field that indicates when a record was created.
      type: date
  - arguments:
    - description: The name of the table to update the record in
      name: table_name
      required: true
    - description: The system ID of the ticket to update
      name: id
      required: true
    - description: 'Fields and their values to update in the record, in the format:
        fieldname1=value;fieldname2=value;...'
      name: fields
    - description: 'Custom(User defined) fields and their values to update in the
        record, in the format: fieldname1=value;fieldname2=value;...'
      name: custom_fields
    description: Update a record in a specified ServiceNow table
    name: servicenow-update-record
    outputs:
    - contextPath: ServiceNow.Record.ID
      description: The unique record identifier for the record.
      type: string
    - contextPath: ServiceNow.Record.UpdatedBy
      description: A string field that indicates the user who most recently updated
        the record.
      type: string
    - contextPath: ServiceNow.Record.UpdatedAt
      description: A time-stamp field that indicates the date and time of the most
        recent update.
      type: date
    - contextPath: ServiceNow.Record.CreatedBy
      description: A string field that indicates the user who created the record.
      type: string
    - contextPath: ServiceNow.Record.CreatedOn
      description: time-stamp field that indicates when a record was created.
      type: date
  - arguments:
    - description: The table name
      name: table_name
      required: true
    - description: The system ID of the ticket to delete
      name: id
      required: true
    description: Delete a record in a specified ServiceNow table
    name: servicenow-delete-record
  - arguments:
    - description: Table name
      name: table_name
      required: true
    description: List API fields for a specified ServiceNow table
    name: servicenow-list-table-fields
    outputs:
    - contextPath: ServiceNow.Field
      description: Table API field name
      type: string
  - arguments:
    - description: Query by computer sys_id
      name: computer_id
    - description: Query by computer name
      name: computer_name
    - description: Query by specified query, for more information about querying in
        ServiceNow, see https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html
      name: query
    - description: Query by asset tag
      name: asset_tag
    - defaultValue: "10"
      description: Query results limit
      name: limit
    - defaultValue: "0"
      description: Starting record index to begin retrieving records from
      name: offset
    description: Query the cmdb_ci_computer table in ServiceNow
    name: servicenow-query-computers
    outputs:
    - contextPath: ServiceNow.Computer.ID
      description: Computer sys_id
      type: string
    - contextPath: ServiceNow.Computer.AssetTag
      description: Computer Asset tag
      type: string
    - contextPath: ServiceNow.Computer.Name
      description: Computer name
      type: string
    - contextPath: ServiceNow.Computer.DisplayName
      description: Computer display name
      type: string
    - contextPath: ServiceNow.Computer.SupportGroup
      description: Computer support group
      type: string
    - contextPath: ServiceNow.Computer.OperatingSystem
      description: Computer operating system
      type: string
    - contextPath: ServiceNow.Computer.Company
      description: Computer company sys_id
      type: string
    - contextPath: ServiceNow.Computer.AssignedTo
      description: Computer assigned to user sys_id
      type: string
    - contextPath: ServiceNow.Computer.State
      description: Computer state
      type: string
    - contextPath: ServiceNow.Computer.Cost
      description: Computer cost
      type: string
    - contextPath: ServiceNow.Computer.Comments
      description: Computer comments
      type: string
  - arguments:
    - description: Query by group sys_id
      name: group_id
    - description: Query by group name
      name: group_name
    - description: Query by specified query, for more information about querying in
        ServiceNow, see https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html
      name: query
    - defaultValue: "10"
      description: Query results limit
      name: limit
    - defaultValue: "0"
      description: Starting record index to begin retrieving records from
      name: offset
    description: Query the sys_user_group table in ServiceNow
    name: servicenow-query-groups
    outputs:
    - contextPath: ServiceNow.Group.ID
      description: Group sys_id
      type: string
    - contextPath: ServiceNow.Group.Description
      description: Group description
      type: string
    - contextPath: ServiceNow.Group.Name
      description: Group name
      type: string
    - contextPath: ServiceNow.Group.Manager
      description: Group manager sys_id
      type: string
    - contextPath: ServiceNow.Group.Updated
      description: Group update time
      type: date
  - arguments:
    - description: Query by user sys_id
      name: user_id
    - description: Query by username
      name: user_name
    - description: Query by specified query, for more information about querying in
        ServiceNow, see https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html
      name: query
    - defaultValue: "10"
      description: Query results limit
      name: limit
    - defaultValue: "0"
      description: Starting record index to begin retrieving records from
      name: offset
    description: Query the sys_user table in ServiceNow
    name: servicenow-query-users
    outputs:
    - contextPath: ServiceNow.User.ID
      description: User sys_id
      type: string
    - contextPath: ServiceNow.User.Name
      description: User name (first + last)
      type: string
    - contextPath: ServiceNow.User.UserName
      description: User username
      type: string
    - contextPath: ServiceNow.User.Email
      description: User email
      type: string
    - contextPath: ServiceNow.User.Created
      description: User creation time
      type: date
    - contextPath: ServiceNow.User.Updated
      description: User update time
      type: date
  - arguments:
    - description: The table label, e.g Asset, Incident, IP address etc.
      name: label
      required: true
    - defaultValue: "10"
      description: Results limit
      name: limit
    - description: Starting record index to begin retrieving records from
      name: offset
    description: Get table names by a label to use in commands
    name: servicenow-get-table-name
    outputs:
    - contextPath: ServiceNow.Table.ID
      description: Table system ID
      type: string
    - contextPath: ServiceNow.Table.Name
      description: Table name to use in commands, e.g alm_asset
      type: string
    - contextPath: ServiceNow.Table.SystemName
      description: Table system name, e.g Asset
      type: string
  - arguments:
    - default: true
      description: Ticket System ID
      name: id
      required: true
    - defaultValue: "10"
      description: Limit for the ticket notes
      name: limit
    - defaultValue: "0"
      description: Offset of the ticket notes
      name: offset
    description: Get notes from the specified ServiceNow ticket - Read permissions
      are required for the sys_journal_field table.
    name: servicenow-get-ticket-notes
    outputs:
    - contextPath: ServiceNow.Ticket.ID
      description: Ticket ID
      type: string
    - contextPath: ServiceNow.Ticket.Note.Value
      description: Ticket note value
      type: unknown
    - contextPath: ServiceNow.Ticket.Note.CreatedOn
      description: Ticket note created on
      type: date
    - contextPath: ServiceNow.Ticket.Note.CreatedBy
      description: Ticket note created by
      type: string
    - contextPath: ServiceNow.Ticket.Note.Type
      description: Ticket note type
      type: string
  isfetch: true
  runonce: false
  script: |2-



    import re
    import requests
    import json
    from datetime import datetime
    import shutil

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    def get_server_url():
        url = demisto.params()['url']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    ''' GLOBAL VARIABLES '''

    DEFAULTS = {
        'limit': 10,
        'offset': 0,
        'fetch_limit': 10,
        'fetch_time': '10 minutes',
        'ticket_type': 'incident'
    }

    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    VERIFY_SSL = not demisto.params().get('insecure', False)
    API = '/api/now/'
    VERSION = demisto.params().get('api_version')
    PARAMS_TICKET_TYPE = demisto.params().get('ticket_type', DEFAULTS['ticket_type'])
    FETCH_TIME = demisto.params().get('fetch_time').strip()
    SYSPARM_QUERY = demisto.params().get('sysparm_query')
    SYSPARM_LIMIT = demisto.params().get('fetch_limit', DEFAULTS['fetch_limit'])
    TIMESTAMP_FIELD = demisto.params().get('timestamp_field', 'opened_at')
    TICKET_TYPE = demisto.params().get('ticket_type', DEFAULTS['ticket_type'])
    GET_ATTACHMENTS = demisto.params().get('get_attachments', False)

    if VERSION:
        API += VERSION + '/'

    SERVER_URL = get_server_url() + API

    TICKET_STATES = {
        'incident': {
            '1': '1 - New',
            '2': '2 - In Progress',
            '3': '3 - On Hold',
            '4': '4 - Awaiting Caller',
            '5': '5 - Awaiting Evidence',
            '6': '6 - Resolved',
            '7': '7 - Closed',
            '8': '8 - Canceled'
        },
        'problem': {
            '1': '1 - Open',
            '2': '2 - Known Error',
            '3': '3 - Pending Change',
            '4': '4 - Closed/Resolved'
        },
        'change_request': {
            '-5': '-5 - New',
            '-4': '-4 - Assess',
            '-3': '-3 - Authorize',
            '-2': '-2 - Scheduled',
            '-1': '-1 - Implement',
            '0': '0 - Review',
            '3': '3 - Closed',
            '4': '4 - Canceled'
        },
        'sc_task': {
            '-5': '-5 - Pending',
            '1': '1 - Open',
            '2': '2 - Work In Progress',
            '3': '3 - Closed Complete',
            '4': '4 - Closed Incomplete',
            '7': '7 - Closed Skipped'
        },
        'sc_request': {
            '1': '1 - Approved',
            '3': '3 - Closed',
            '4': '4 - Rejected'
        }
    }

    TICKET_SEVERITY = {
        '1': '1 - High',
        '2': '2 - Medium',
        '3': '3 - Low'
    }

    TICKET_PRIORITY = {
        '1': '1 - Critical',
        '2': '2 - High',
        '3': '3 - Moderate',
        '4': '4 - Low',
        '5': '5 - Planning'
    }

    COMPUTER_STATUS = {
        '1': 'In use',
        '2': 'On order',
        '3': 'On maintenance',
        '6': 'In stock/In transit',
        '7': 'Retired',
        '100': 'Missing'
    }

    # Map SNOW severity to Demisto severity for incident creation
    SEVERITY_MAP = {
        '1': 3,
        '2': 2,
        '3': 1
    }

    SNOW_ARGS = ['active', 'activity_due', 'opened_at', 'short_description', 'additional_assignee_list', 'approval_history',
                 'approval_set', 'assigned_to', 'assignment_group',
                 'business_duration', 'business_service', 'business_stc', 'calendar_duration', 'calendar_stc', 'caller_id',
                 'caused_by', 'close_code', 'close_notes',
                 'closed_at', 'closed_by', 'cmdb_ci', 'comments', 'comments_and_work_notes', 'company', 'contact_type',
                 'correlation_display', 'correlation_id',
                 'delivery_plan', 'delivery_task', 'description', 'due_date', 'expected_start', 'follow_up', 'group_list',
                 'hold_reason', 'impact', 'incident_state',
                 'knowledge', 'location', 'made_sla', 'notify', 'order', 'parent', 'parent_incident', 'priority',
                 'problem_id', 'resolved_at', 'resolved_by', 'rfc',
                 'severity', 'sla_due', 'state', 'subcategory', 'sys_tags', 'time_worked', 'urgency', 'user_input',
                 'watch_list', 'work_end', 'work_notes', 'work_notes_list',
                 'work_start', 'impact', 'incident_state', 'title', 'type', 'change_type', 'category', 'state', 'caller']

    # Every table in ServiceNow should have those fields
    DEFAULT_RECORD_FIELDS = {
        'sys_id': 'ID',
        'sys_updated_by': 'UpdatedBy',
        'sys_updated_on': 'UpdatedAt',
        'sys_created_by': 'CreatedBy',
        'sys_created_on': 'CreatedAt'
    }

    DEPRECATED_COMMANDS = ['servicenow-get', 'servicenow-incident-get',
                           'servicenow-create', 'servicenow-incident-create',
                           'servicenow-update', 'servicenow-query',
                           'servicenow-incidents-query', 'servicenow-incident-update']

    ''' HELPER FUNCTIONS '''


    def send_request(path, method='get', body=None, params=None, headers=None, file=None):
        body = body if body is not None else {}
        params = params if params is not None else {}

        url = '{}{}'.format(SERVER_URL, path)
        if not headers:
            headers = {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        if file:
            # Not supported in v2
            url = url.replace('v2', 'v1')
            try:
                file_entry = file['id']
                file_name = file['name']
                shutil.copy(demisto.getFilePath(file_entry)['path'], file_name)
                with open(file_name, 'rb') as f:
                    files = {'file': f}
                    res = requests.request(method, url, headers=headers, params=params, data=body, files=files,
                                           auth=(USERNAME, PASSWORD), verify=VERIFY_SSL)
                shutil.rmtree(demisto.getFilePath(file_entry)['name'], ignore_errors=True)
            except Exception as e:
                raise Exception('Failed to upload file - ' + str(e))
        else:
            res = requests.request(method, url, headers=headers, data=json.dumps(body) if body else {}, params=params,
                                   auth=(USERNAME, PASSWORD), verify=VERIFY_SSL)

        try:
            obj = res.json()
        except Exception as e:
            if not res.content:
                return ''
            raise Exception('Error parsing reply - {} - {}'.format(res.content, str(e)))

        if 'error' in obj:
            message = obj.get('error', {}).get('message')
            details = obj.get('error', {}).get('detail')
            if message == 'No Record found':
                return {
                    # Return an empty results array
                    'result': []
                }
            raise Exception('ServiceNow Error: {}, details: {}'.format(message, details))

        if res.status_code < 200 or res.status_code >= 300:
            raise Exception('Got status code {} with url {} with body {} with headers {}'
                            .format(str(res.status_code), url, str(res.content), str(res.headers)))

        return obj


    def get_table_name(ticket_type=None):
        if ticket_type:
            return ticket_type
        else:
            if PARAMS_TICKET_TYPE:
                return PARAMS_TICKET_TYPE
            else:
                return 'incident'


    def create_ticket_context(data, ticket_type):
        context = {
            'ID': data.get('sys_id'),
            'Summary': data.get('short_description'),
            'Number': data.get('number'),
            'CreatedOn': data.get('sys_created_on'),
            'Active': data.get('active'),
            'AdditionalComments': data.get('comments'),
            'CloseCode': data.get('close_code'),
            'OpenedAt': data.get('opened_at')
        }

        # These fields refer to records in the database, the value is their system ID.
        if 'closed_by' in data:
            context['ResolvedBy'] = data['closed_by']['value'] if 'value' in data['closed_by'] else ''
        if 'opened_by' in data:
            context['OpenedBy'] = data['opened_by']['value'] if 'value' in data['opened_by'] else ''
            context['Creator'] = data['opened_by']['value'] if 'value' in data['opened_by'] else ''
        if 'assigned_to' in data:
            context['Assignee'] = data['assigned_to']['value'] if 'value' in data['assigned_to'] else ''

        # Try to map fields
        if 'priority' in data:
            # Backward compatibility
            if demisto.command() in DEPRECATED_COMMANDS:
                context['Priority'] = data['priority']
            else:
                context['Priority'] = TICKET_PRIORITY.get(data['priority'], data['priority'])
        if 'state' in data:
            mapped_state = data['state']
            # Backward compatibility
            if demisto.command() not in DEPRECATED_COMMANDS:
                if ticket_type in TICKET_STATES:
                    mapped_state = TICKET_STATES[ticket_type].get(data['state'], mapped_state)
            context['State'] = mapped_state

        return createContext(context, removeNull=True)


    def get_ticket_context(data, ticket_type):
        if not isinstance(data, list):
            return create_ticket_context(data, ticket_type)

        tickets = []
        for d in data:
            tickets.append(create_ticket_context(d, ticket_type))
        return tickets


    def get_ticket_human_readable(tickets, ticket_type):
        if not isinstance(tickets, list):
            tickets = [tickets]

        result = []
        for ticket in tickets:

            hr = {
                'Number': ticket.get('number'),
                'System ID': ticket['sys_id'],
                'Created On': ticket.get('sys_created_on'),
                'Created By': ticket.get('sys_created_by'),
                'Active': ticket.get('active'),
                'Close Notes': ticket.get('close_notes'),
                'Close Code': ticket.get('close_code'),
                'Description': ticket.get('description'),
                'Opened At': ticket.get('opened_at'),
                'Due Date': ticket.get('due_date'),
                # This field refers to a record in the database, the value is its system ID.
                'Resolved By': ticket.get('closed_by', {}).get('value') if isinstance(ticket.get('closed_by'), dict)
                else ticket.get('closed_by'),
                'Resolved At': ticket.get('resolved_at'),
                'SLA Due': ticket.get('sla_due'),
                'Short Description': ticket.get('short_description'),
                'Additional Comments': ticket.get('comments')
            }

            # Try to map the fields
            if 'impact' in ticket:
                hr['Impact'] = TICKET_SEVERITY.get(ticket['impact'], ticket['impact'])
            if 'urgency' in ticket:
                hr['Urgency'] = TICKET_SEVERITY.get(ticket['urgency'], ticket['urgency'])
            if 'severity' in ticket:
                hr['Severity'] = TICKET_SEVERITY.get(ticket['severity'], ticket['severity'])
            if 'priority' in ticket:
                hr['Priority'] = TICKET_PRIORITY.get(ticket['priority'], ticket['priority'])
            if 'state' in ticket:
                mapped_state = ticket['state']
                if ticket_type in TICKET_STATES:
                    mapped_state = TICKET_STATES[ticket_type].get(ticket['state'], mapped_state)
                hr['State'] = mapped_state
            result.append(hr)
        return result


    def get_ticket_fields(template, ticket_type):
        # Inverse the keys and values of those dictionaries to map the arguments to their corresponding values in ServiceNow
        args = unicode_to_str_recur(demisto.args())
        inv_severity = {v: k for k, v in TICKET_SEVERITY.iteritems()}
        inv_priority = {v: k for k, v in TICKET_PRIORITY.iteritems()}
        states = TICKET_STATES.get(ticket_type)
        inv_states = {v: k for k, v in states.iteritems()} if states else {}

        body = {}
        for arg in SNOW_ARGS:
            input_arg = args.get(arg)
            if input_arg:
                if arg in ['impact', 'urgency', 'severity']:
                    body[arg] = inv_severity.get(input_arg, input_arg)
                elif arg == 'priority':
                    body[arg] = inv_priority.get(input_arg, input_arg)
                elif arg == 'state':
                    body[arg] = inv_states.get(input_arg, input_arg)
                else:
                    body[arg] = input_arg
            elif template and arg in template:
                body[arg] = template[arg]

        return body


    def get_body(fields, custom_fields):
        body = {}

        if fields:
            for field in fields:
                body[field] = fields[field]

        if custom_fields:
            for field in custom_fields:
                # custom fields begin with "u_"
                if field.startswith('u_'):
                    body[field] = custom_fields[field]
                else:
                    body['u_' + field] = custom_fields[field]

        return body


    def split_fields(fields):
        dic_fields = {}

        if fields:
            # As received by the command
            arr_fields = fields.split(';')

            for f in arr_fields:
                field = f.split('=')
                if len(field) > 1:
                    dic_fields[field[0]] = field[1]

        return dic_fields


    # Converts unicode elements of obj (incl. dictionary and list) to string recursively
    def unicode_to_str_recur(obj):
        if isinstance(obj, dict):
            obj = {unicode_to_str_recur(k): unicode_to_str_recur(v) for k, v in obj.iteritems()}
        elif isinstance(obj, list):
            obj = map(unicode_to_str_recur, obj)
        elif isinstance(obj, unicode):
            obj = obj.encode('utf-8')
        return obj


    # Converts to an str
    def convert_to_str(obj):
        if isinstance(obj, unicode):
            return obj.encode('utf-8')
        try:
            return str(obj)
        except ValueError:
            return obj


    ''' FUNCTIONS '''


    def get_template(name):
        query_params = {'sysparm_limit': 1, 'sysparm_query': 'name=' + name}

        ticket_type = 'sys_template'
        path = 'table/' + ticket_type
        res = send_request('GET', path, params=query_params)

        if len(res['result']) == 0:
            raise ValueError("Incorrect template name")

        template = res['result'][0]['template'].split('^')
        dic_template = {}

        for i in range(len(template) - 1):
            template_value = template[i].split('=')
            if len(template_value) > 1:
                dic_template[template_value[0]] = template_value[1]

        return dic_template


    def get_ticket_command():
        args = unicode_to_str_recur(demisto.args())
        ticket_type = get_table_name(args.get('ticket_type'))
        ticket_id = args.get('id')
        number = args.get('number')
        get_attachments = args.get('get_attachments', 'false')

        res = get(ticket_type, ticket_id, number)
        if not res or 'result' not in res:
            return 'Cannot find ticket'

        if isinstance(res['result'], list):
            if len(res['result']) == 0:
                return 'Cannot find ticket'
            ticket = res['result'][0]
        else:
            ticket = res['result']

        entries = []  # type: List[Dict]

        if get_attachments.lower() != 'false':
            entries = get_ticket_attachment_entries(ticket['sys_id'])

        hr = get_ticket_human_readable(ticket, ticket_type)
        context = get_ticket_context(ticket, ticket_type)

        headers = ['System ID', 'Number', 'Impact', 'Urgency', 'Severity', 'Priority', 'State', 'Created On', 'Created By',
                   'Active', 'Close Notes', 'Close Code',
                   'Description', 'Opened At', 'Due Date', 'Resolved By', 'Resolved At', 'SLA Due', 'Short Description',
                   'Additional Comments']

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow ticket', hr, headers=headers, removeNull=True),
            'EntryContext': {
                'Ticket(val.ID===obj.ID)': context,
                'ServiceNow.Ticket(val.ID===obj.ID)': context
            }
        }

        entries.append(entry)

        return entries


    def get_record_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = args['table_name']
        record_id = args['id']
        fields = args.get('fields')

        res = get(table_name, record_id)

        if not res or 'result' not in res:
            return 'Cannot find record'

        if isinstance(res['result'], list):
            if len(res['result']) == 0:
                return 'Cannot find record'
            record = res['result'][0]
        else:
            record = res['result']

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json']
        }

        if fields:
            fields = argToList(fields)
            if 'sys_id' not in fields:
                # ID is added by default
                fields.append('sys_id')
            # filter the record for the required fields
            record = dict(filter(lambda kv_pair: kv_pair[0] in fields, record.items()))
            for k, v in record.iteritems():
                if isinstance(v, dict):
                    # For objects that refer to a record in the database, take their value(system ID).
                    record[k] = v.get('value', record[k])
            record['ID'] = record.pop('sys_id')
            entry['ReadableContentsFormat'] = formats['markdown']
            entry['HumanReadable'] = tableToMarkdown('ServiceNow record', record, removeNull=True)
            entry['EntryContext'] = {
                'ServiceNow.Record(val.ID===obj.ID)': createContext(record)
            }
        else:
            mapped_record = {DEFAULT_RECORD_FIELDS[k]: record[k] for k in DEFAULT_RECORD_FIELDS if k in record}
            entry['ReadableContentsFormat'] = formats['markdown']
            entry['HumanReadable'] = tableToMarkdown('ServiceNow record' + record_id, mapped_record, removeNull=True)
            entry['EntryContext'] = {
                'ServiceNow.Record(val.ID===obj.ID)': createContext(mapped_record)
            }

        return entry


    def get(table_name, record_id, number=None):
        path = None
        query_params = {}  # type: Dict
        if record_id:
            path = 'table/' + table_name + '/' + record_id
        elif number:
            path = 'table/' + table_name
            query_params = {
                'number': number
            }
        else:
            # Only in cases where the table is of type ticket
            raise ValueError('servicenow-get-ticket requires either ticket ID (sys_id) or ticket number')

        return send_request(path, 'get', params=query_params)


    def get_ticket_attachments(ticket_id):
        path = 'attachment'
        query_params = {
            'sysparm_query': 'table_sys_id=' + ticket_id
        }

        return send_request(path, 'get', params=query_params)


    def get_ticket_attachment_entries(ticket_id):
        entries = []
        links = []  # type: List[Tuple[str, str]]
        attachments_res = get_ticket_attachments(ticket_id)
        if 'result' in attachments_res and len(attachments_res['result']) > 0:
            attachments = attachments_res['result']
            links = [(attachment['download_link'], attachment['file_name']) for attachment in attachments]

        for link in links:
            file_res = requests.get(link[0], auth=(USERNAME, PASSWORD), verify=VERIFY_SSL)
            if file_res is not None:
                entries.append(fileResult(link[1], file_res.content))

        return entries


    def update_ticket_command():
        args = unicode_to_str_recur(demisto.args())
        custom_fields = split_fields(args.get('custom_fields'))
        template = args.get('template')
        ticket_type = get_table_name(args.get('ticket_type'))
        ticket_id = args['id']

        if template:
            template = get_template(template)
        fields = get_ticket_fields(template, ticket_type)

        res = update(ticket_type, ticket_id, fields, custom_fields)

        if not res or 'result' not in res:
            return_error('Unable to retrieve response')

        hr = get_ticket_human_readable(res['result'], ticket_type)
        context = get_ticket_context(res['result'], ticket_type)

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow ticket updated successfully\nTicket type: ' + ticket_type,
                                             hr, removeNull=True),
            'EntryContext': {
                'ServiceNow.Ticket(val.ID===obj.ID)': context
            }
        }

        return entry


    def update_record_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = args['table_name']
        record_id = args['id']
        fields = args.get('fields', {})
        custom_fields = args.get('custom_fields')

        if fields:
            fields = split_fields(fields)
        if custom_fields:
            custom_fields = split_fields(custom_fields)

        res = update(table_name, record_id, fields, custom_fields)

        if not res or 'result' not in res:
            return 'Could not retrieve record'

        result = res['result']

        mapped_record = {DEFAULT_RECORD_FIELDS[k]: result[k] for k in DEFAULT_RECORD_FIELDS if k in result}
        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow record updated successfully', mapped_record, removeNull=True),
            'EntryContext': {
                'ServiceNow.Record(val.ID===obj.ID)': createContext(mapped_record)
            }
        }

        return entry


    def update(table_name, record_id, fields, custom_fields):
        body = get_body(fields, custom_fields)
        path = 'table/' + table_name + '/' + record_id

        return send_request(path, 'patch', body=body)


    def create_ticket_command():
        args = unicode_to_str_recur(demisto.args())
        custom_fields = split_fields(args.get('custom_fields'))
        template = args.get('template')
        ticket_type = get_table_name(args.get('ticket_type'))

        if template:
            template = get_template(template)
        fields = get_ticket_fields(template, ticket_type)

        res = create(ticket_type, fields, custom_fields)

        if not res or 'result' not in res:
            return_error('Unable to retrieve response')

        hr = get_ticket_human_readable(res['result'], ticket_type)
        context = get_ticket_context(res['result'], ticket_type)

        headers = ['System ID', 'Number', 'Impact', 'Urgency', 'Severity', 'Priority', 'State', 'Created On', 'Created By',
                   'Active', 'Close Notes', 'Close Code',
                   'Description', 'Opened At', 'Due Date', 'Resolved By', 'Resolved At', 'SLA Due', 'Short Description',
                   'Additional Comments']

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow ticket created successfully', hr,
                                             headers=headers, removeNull=True),
            'EntryContext': {
                'Ticket(val.ID===obj.ID)': context,
                'ServiceNow.Ticket(val.ID===obj.ID)': context
            }
        }

        return entry


    def create_record_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = args['table_name']
        fields = args.get('fields')
        custom_fields = args.get('custom_fields')

        if fields:
            fields = split_fields(fields)
        if custom_fields:
            custom_fields = split_fields(custom_fields)

        res = create(table_name, fields, custom_fields)

        if not res or 'result' not in res:
            return 'Could not retrieve record'

        result = res['result']

        mapped_record = {DEFAULT_RECORD_FIELDS[k]: result[k] for k in DEFAULT_RECORD_FIELDS if k in result}
        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow record created successfully', mapped_record, removeNull=True),
            'EntryContext': {
                'ServiceNow.Record(val.ID===obj.ID)': createContext(mapped_record)
            }
        }

        return entry


    def create(table_name, fields, custom_fields):
        body = get_body(fields, custom_fields)
        path = 'table/' + table_name

        return send_request(path, 'post', body=body)


    def delete_ticket_command():
        args = unicode_to_str_recur(demisto.args())
        ticket_id = args['id']
        ticket_type = get_table_name(args.get('ticket_type'))

        res = delete(ticket_type, ticket_id)

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Ticket with ID ' + ticket_id + ' was successfully deleted.'
        }

        return entry


    def delete_record_command():
        args = unicode_to_str_recur(demisto.args())
        record_id = args['id']
        table_name = args.get('table_name')

        res = delete(table_name, record_id)

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['text'],
            'HumanReadable': 'Record with ID ' + record_id + ' was successfully deleted.'
        }

        return entry


    def delete(table_name, record_id):
        path = 'table/' + table_name + '/' + record_id

        return send_request(path, 'delete')


    def add_link_command():
        args = unicode_to_str_recur(demisto.args())
        ticket_id = args['id']
        key = 'comments' if args.get('post-as-comment', 'false').lower() == 'true' else 'work_notes'
        text = args.get('text', args['link'])
        link = '[code]<a class="web" target="_blank" href="' + args['link'] + '" >' + text + '</a>[/code]'
        ticket_type = get_table_name(args.get('ticket_type'))

        res = add_link(ticket_id, ticket_type, key, link)

        if not res or 'result' not in res:
            return_error('Unable to retrieve response')

        headers = ['System ID', 'Number', 'Impact', 'Urgency', 'Severity', 'Priority', 'State', 'Created On', 'Created By',
                   'Active', 'Close Notes', 'Close Code',
                   'Description', 'Opened At', 'Due Date', 'Resolved By', 'Resolved At', 'SLA Due', 'Short Description',
                   'Additional Comments']

        hr = get_ticket_human_readable(res['result'], ticket_type)
        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Link successfully added to ServiceNow ticket', hr,
                                             headers=headers, removeNull=True)
        }

        return entry


    def add_link(ticket_id, ticket_type, key, link):
        body = {}
        body[key] = link
        path = 'table/' + ticket_type + '/' + ticket_id

        return send_request(path, 'patch', body=body)


    def add_comment_command():
        args = unicode_to_str_recur(demisto.args())
        ticket_id = args['id']
        key = 'comments' if args.get('post-as-comment', 'false').lower() == 'true' else 'work_notes'
        text = args['comment']
        ticket_type = get_table_name(args.get('ticket_type'))

        res = add_comment(ticket_id, ticket_type, key, text)

        if not res or 'result' not in res:
            return_error('Unable to retrieve response')

        headers = ['System ID', 'Number', 'Impact', 'Urgency', 'Severity', 'Priority', 'State', 'Created On', 'Created By',
                   'Active', 'Close Notes', 'Close Code',
                   'Description', 'Opened At', 'Due Date', 'Resolved By', 'Resolved At', 'SLA Due', 'Short Description',
                   'Additional Comments']

        hr = get_ticket_human_readable(res['result'], ticket_type)
        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Comment successfully added to ServiceNow ticket', hr,
                                             headers=headers, removeNull=True)
        }

        return entry


    def add_comment(ticket_id, ticket_type, key, text):
        body = {}
        body[key] = text
        path = 'table/' + ticket_type + '/' + ticket_id

        return send_request(path, 'patch', body=body)


    def get_ticket_notes_command():
        args = unicode_to_str_recur(demisto.args())
        ticket_id = args['id']
        limit = args.get('limit')
        offset = args.get('offset')

        comments_query = 'element_id=' + ticket_id + '^element=comments^ORelement=work_notes'

        res = query('sys_journal_field', limit, offset, comments_query)

        if not res or 'result' not in res:
            return 'No results found'

        headers = ['Value', 'CreatedOn', 'CreatedBy', 'Type']

        mapped_notes = [{
            'Value': n.get('value'),
            'CreatedOn': n.get('sys_created_on'),
            'CreatedBy': n.get('sys_created_by'),
            'Type': 'Work Note' if n.get('element', '') == 'work_notes' else 'Comment'
        } for n in res['result']]

        if not mapped_notes:
            return 'No results found'

        ticket = {
            'ID': ticket_id,
            'Note': mapped_notes
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow notes for ticket ' + ticket_id, mapped_notes, headers=headers,
                                             headerTransform=pascalToSpace, removeNull=True),
            'EntryContext': {
                'ServiceNow.Ticket(val.ID===obj.ID)': createContext(ticket, removeNull=True)
            }
        }

        return entry


    def query_tickets_command():
        args = unicode_to_str_recur(demisto.args())
        sysparm_limit = args.get('limit', DEFAULTS['limit'])
        sysparm_query = args.get('query')
        sysparm_offset = args.get('offset', DEFAULTS['offset'])

        if not sysparm_query:
            # backward compatibility
            sysparm_query = args.get('sysparm_query')
        ticket_type = get_table_name(args.get('ticket_type'))

        res = query(ticket_type, sysparm_limit, sysparm_offset, sysparm_query)

        if not res or 'result' not in res or len(res['result']) == 0:
            return 'No results found'

        hr = get_ticket_human_readable(res['result'], ticket_type)
        context = get_ticket_context(res['result'], ticket_type)

        headers = ['System ID', 'Number', 'Impact', 'Urgency', 'Severity', 'Priority', 'State', 'Created On', 'Created By',
                   'Active', 'Close Notes', 'Close Code',
                   'Description', 'Opened At', 'Due Date', 'Resolved By', 'Resolved At', 'SLA Due', 'Short Description',
                   'Additional Comments']

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow tickets', hr, headers=headers, removeNull=True),
            'EntryContext': {
                'Ticket(val.ID===obj.ID)': context,
                'ServiceNow.Ticket(val.ID===obj.ID)': context
            }
        }

        return entry


    def query_table_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = args['table_name']
        sysparm_limit = args.get('limit', DEFAULTS['limit'])
        sysparm_query = args.get('query')
        sysparm_offset = args.get('offset', DEFAULTS['offset'])
        fields = args.get('fields')

        res = query(table_name, sysparm_limit, sysparm_offset, sysparm_query)

        if not res or 'result' not in res or len(res['result']) == 0:
            return 'No results found'

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json']
        }

        result = res['result']

        if fields:
            fields = argToList(fields)
            if 'sys_id' not in fields:
                # ID is added by default
                fields.append('sys_id')
            # Filter the records according to the given fields
            records = [dict(filter(lambda kv_pair: kv_pair[0] in fields, r.iteritems())) for r in res['result']]
            for r in records:
                r['ID'] = r.pop('sys_id')
                for k, v in r.iteritems():
                    if isinstance(v, dict):
                        # For objects that refer to a record in the database, take their value (system ID).
                        r[k] = v.get('value', v)
            entry['ReadableContentsFormat'] = formats['markdown']
            entry['HumanReadable'] = tableToMarkdown('ServiceNow records', records, removeNull=True)
            entry['EntryContext'] = {
                'ServiceNow.Record(val.ID===obj.ID)': createContext(records)
            }
        else:
            mapped_records = [{DEFAULT_RECORD_FIELDS[k]: r[k] for k in DEFAULT_RECORD_FIELDS if k in r} for r in result]
            entry['ReadableContentsFormat'] = formats['markdown']
            entry['HumanReadable'] = tableToMarkdown('ServiceNow records', mapped_records, removeNull=True)
            entry['EntryContext'] = {
                'ServiceNow.Record(val.ID===obj.ID)': createContext(mapped_records)
            }

        return entry


    def query(table_name, sysparm_limit, sysparm_offset, sysparm_query):
        query_params = {}
        query_params['sysparm_limit'] = sysparm_limit
        query_params['sysparm_offset'] = sysparm_offset
        if sysparm_query:
            query_params['sysparm_query'] = sysparm_query

        path = 'table/' + table_name

        return send_request(path, 'get', params=query_params)


    def upload_file_command():
        args = unicode_to_str_recur(demisto.args())
        ticket_type = get_table_name(args.get('ticket_type'))
        ticket_id = args['id']
        file_id = args['file_id']
        file_name = args.get('file_name', demisto.dt(demisto.context(), "File(val.EntryID=='" + file_id + "').Name"))

        # in case of info file
        if not file_name:
            file_name = demisto.dt(demisto.context(), "InfoFile(val.EntryID=='" + file_id + "').Name")

        if not file_name:
            return_error('Could not find the file')

        file_name = file_name[0] if isinstance(file_name, list) else file_name

        res = upload_file(ticket_id, file_id, file_name, ticket_type)

        if not res or 'result' not in res or not res['result']:
            return_error('Unable to retrieve response')

        hr = {
            'Filename': res['result'].get('file_name'),
            'Download link': res['result'].get('download_link'),
            'System ID': res['result'].get('sys_id')
        }

        context = {
            'ID': ticket_id,
            'File': {}
        }
        context['File']['Filename'] = res['result'].get('file_name')
        context['File']['Link'] = res['result'].get('download_link')
        context['File']['SystemID'] = res['result'].get('sys_id')

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('File uploaded successfully', hr),
            'EntryContext': {
                'ServiceNow.Ticket(val.ID===obj.ID)': context,
                'Ticket(val.ID===obj.ID)': context
            }
        }

        return entry


    def upload_file(ticket_id, file_id, file_name, ticket_type):
        headers = {
            'Accept': 'application/json'
        }

        body = {
            'table_name': ticket_type,
            'table_sys_id': ticket_id,
            'file_name': file_name
        }

        path = 'attachment/upload'

        return send_request(path, 'post', headers=headers, body=body, file={'id': file_id, 'name': file_name})


    # Deprecated
    def get_computer_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = 'cmdb_ci_computer'
        computer_name = args['computerName']

        res = query(table_name, None, 0, 'u_code=' + computer_name)

        if not res or 'result' not in res:
            return 'Cannot find computer'
        elif isinstance(res['result'], list):
            if len(res['result']) == 0:
                return 'Cannot find computer'
            computer = res['result'][0]
        else:
            computer = res['result']

        if computer['u_code'] != computer_name:
            return 'Computer not found'

        hr = {
            'ID': computer['sys_id'],
            'u_code (computer name)': computer['u_code'],
            'Support group': computer['support_group'],
            'Operating System': computer['os'],
            'Comments': computer['comments']
        }

        ec = createContext(computer, removeNull=True)
        if 'support_group' in computer:
            ec['support_group'] = computer['support_group']['value'] if 'value' in computer['support_group'] else ''

        entry = {
            'Type': entryTypes['note'],
            'Contents': computer,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Computer', hr),
            'EntryContext': {
                'ServiceNowComputer(val.sys_id==obj.sys_id)': ec,
            }
        }

        return entry


    def query_computers_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = 'cmdb_ci_computer'
        computer_id = args.get('computer_id')
        computer_name = args.get('computer_name')
        asset_tag = args.get('asset_tag')
        computer_query = args.get('query', {})
        offset = args.get('offset', DEFAULTS['offset'])
        limit = args.get('limit', DEFAULTS['limit'])

        if computer_id:
            res = get(table_name, computer_id)
        else:
            if computer_name:
                computer_query = 'name=' + computer_name
            elif asset_tag:
                computer_query = 'asset_tag=' + asset_tag

            res = query(table_name, limit, offset, computer_query)

        if not res or 'result' not in res:
            return 'No computers found'

        computers = res['result']
        if not isinstance(computers, list):
            computers = [computers]

        if len(computers) == 0:
            return 'No computers found'

        headers = ['ID', 'AssetTag', 'Name', 'DisplayName', 'SupportGroup', 'OperatingSystem', 'Company', 'AssignedTo',
                   'State', 'Cost', 'Comments']

        mapped_computers = [{
            'ID': computer.get('sys_id'),
            'AssetTag': computer.get('asset_tag'),
            'Name': computer.get('name'),
            'DisplayName': '{} - {}'.format(computer.get('asset_tag', ''), computer.get('name', '')),
            'SupportGroup': computer.get('support_group'),
            'OperatingSystem': computer.get('os'),
            'Company': computer.get('company', {}).get('value')
            if isinstance(computer.get('company'), dict) else computer.get('company'),
            'AssignedTo': computer.get('assigned_to', {}).get('value')
            if isinstance(computer.get('assigned_to'), dict) else computer.get('assigned_to'),
            'State': COMPUTER_STATUS.get(computer.get('install_status', ''), computer.get('install_status')),
            'Cost': '{} {}'.format(computer.get('cost', ''), computer.get('cost_cc', '')).rstrip(),
            'Comments': computer.get('comments')
        } for computer in computers]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Computers', mapped_computers, headers=headers,
                                             removeNull=True, headerTransform=pascalToSpace),
            'EntryContext': {
                'ServiceNow.Computer(val.ID===obj.ID)': createContext(mapped_computers, removeNull=True),
            }
        }

        return entry


    def query_groups_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = 'sys_user_group'
        group_id = args.get('group_id')
        group_name = args.get('group_name')
        group_query = args.get('query', {})
        offset = args.get('offset', DEFAULTS['offset'])
        limit = args.get('limit', DEFAULTS['limit'])

        if group_id:
            res = get(table_name, group_id)
        else:
            if group_name:
                group_query = 'name=' + group_name
            res = query(table_name, limit, offset, group_query)

        if not res or 'result' not in res:
            return 'No groups found'

        groups = res['result']
        if not isinstance(groups, list):
            groups = [groups]

        if len(groups) == 0:
            return 'No groups found'

        headers = ['ID', 'Description', 'Name', 'Active', 'Manager', 'Updated']

        mapped_groups = [{
            'ID': group.get('sys_id'),
            'Description': group.get('description'),
            'Name': group.get('name'),
            'Active': group.get('active'),
            'Manager': group.get('manager', {}).get('value')
            if isinstance(group.get('manager'), dict) else group.get('manager'),
            'Updated': group.get('sys_updated_on'),
        } for group in groups]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Groups', mapped_groups, headers=headers,
                                             removeNull=True, headerTransform=pascalToSpace),
            'EntryContext': {
                'ServiceNow.Group(val.ID===obj.ID)': createContext(mapped_groups, removeNull=True),
            }
        }

        return entry


    def query_users_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = 'sys_user'
        user_id = args.get('user_id')
        user_name = args.get('user_name')
        user_query = args.get('query', {})
        offset = args.get('offset', DEFAULTS['offset'])
        limit = args.get('limit', DEFAULTS['limit'])

        if user_id:
            res = get(table_name, user_id)
        else:
            if user_name:
                user_query = 'user_name=' + user_name
            res = query(table_name, limit, offset, user_query)

        if not res or 'result' not in res:
            return 'No users found'
        res = unicode_to_str_recur(res)

        users = res['result']
        if not isinstance(users, list):
            users = [users]

        if len(users) == 0:
            return 'No users found'

        headers = ['ID', 'Name', 'UserName', 'Email', 'Created', 'Updated']

        mapped_users = [{
            'ID': user.get('sys_id'),
            'Name': '{} {}'.format(user.get('first_name', ''), user.get('last_name', '')).rstrip(),
            'UserName': user.get('user_name'),
            'Email': user.get('email'),
            'Created': user.get('sys_created_on'),
            'Updated': user.get('sys_updated_on'),
        } for user in users]
        mapped_users = unicode_to_str_recur(mapped_users)
        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Users', mapped_users, headers=headers, removeNull=True,
                                             headerTransform=pascalToSpace),
            'EntryContext': {
                'ServiceNow.User(val.ID===obj.ID)': createContext(mapped_users, removeNull=True),
            }
        }

        return entry


    # Deprecated
    def get_groups_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = 'sys_user_group'
        group_name = args['name']
        res = query(table_name, None, 0, 'name=' + group_name)

        if not res or 'result' not in res:
            return 'No groups found'

        hr_groups = []
        context_groups = []

        for group in res['result']:
            if group['name'] == group_name:
                hr_groups.append({
                    'ID': group['sys_id'],
                    'Name': group['name'],
                    'Description': group['description'],
                    'Email': group['email'],
                    'Active': group['active'],
                    'Manager': ['manager']
                })
                context_groups.append({
                    'GroupId': group['sys_id'],
                    'GroupName': group['name']
                })

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Group', hr_groups),
            'EntryContext': {
                'ServiceNowGroups(val.GroupId==obj.GroupId)': context_groups,
            }
        }

        return entry


    def list_table_fields_command():
        args = unicode_to_str_recur(demisto.args())
        table_name = args['table_name']

        res = get_table_fields(table_name)

        if not res or 'result' not in res:
            return 'Cannot find table'

        if len(res['result']) == 0:
            return 'Table contains no records'

        fields = [{'Name': k} for k, v in res['result'][0].iteritems()]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Table fields - ' + table_name, fields),
            'EntryContext': {
                'ServiceNow.Field': createContext(fields),
            }
        }

        return entry


    def get_table_fields(table_name):
        # Get one record
        path = 'table/' + table_name + '?sysparm_limit=1'
        res = send_request(path, 'GET')

        return res


    def get_table_name_command():
        args = unicode_to_str_recur(demisto.args())
        label = args['label']
        offset = args.get('offset', DEFAULTS['offset'])
        limit = args.get('limit', DEFAULTS['limit'])

        table_query = 'label=' + label

        res = query('sys_db_object', limit, offset, table_query)

        if not res or 'result' not in res:
            return 'Cannot find table'

        tables = res['result']

        if len(tables) == 0:
            return 'Cannot find table'

        headers = ['ID', 'Name', 'SystemName']

        mapped_tables = [{
            'ID': table.get('sys_id'),
            'Name': table.get('name'),
            'SystemName': table.get('sys_name')
        } for table in tables]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('ServiceNow Tables for label - ' + label, mapped_tables,
                                             headers=headers, headerTransform=pascalToSpace),
            'EntryContext': {
                'ServiceNow.Table(val.ID===obj.ID)': createContext(mapped_tables),
            }
        }

        return entry


    def fetch_incidents():
        query_params = {}
        incidents = []
        if FETCH_TIME:
            fetch_time = FETCH_TIME
        else:
            fetch_time = DEFAULTS['fetch_time']

        last_run = demisto.getLastRun()
        if 'time' not in last_run:
            snow_time, _ = parse_date_range(fetch_time, '%Y-%m-%d %H:%M:%S')
        else:
            snow_time = last_run['time']

        query = ''
        if SYSPARM_QUERY:
            query += SYSPARM_QUERY + '^'
        query += 'ORDERBY{0}^{0}>{1}'.format(TIMESTAMP_FIELD, snow_time)

        if query:
            query_params['sysparm_query'] = query

        query_params['sysparm_limit'] = SYSPARM_LIMIT

        path = 'table/' + TICKET_TYPE
        res = send_request(path, 'get', params=query_params)

        count = 0
        parsed_snow_time = datetime.strptime(snow_time, '%Y-%m-%d %H:%M:%S')

        for result in res.get('result', []):
            labels = []

            if TIMESTAMP_FIELD not in result:
                raise ValueError("The timestamp field [{}]"
                                 " does not exist in the ticket".format(TIMESTAMP_FIELD))

            if count > SYSPARM_LIMIT:
                break

            try:
                if datetime.strptime(result[TIMESTAMP_FIELD], '%Y-%m-%d %H:%M:%S') < parsed_snow_time:
                    continue
            except Exception:
                pass

            for k, v in result.iteritems():
                if isinstance(v, basestring):
                    labels.append({
                        'type': k,
                        'value': v
                    })
                else:
                    labels.append({
                        'type': k,
                        'value': json.dumps(v)
                    })

            severity = SEVERITY_MAP.get(result.get('severity', ''), 0)

            file_names = []
            if GET_ATTACHMENTS:
                file_entries = get_ticket_attachment_entries(result['sys_id'])
                for file_result in file_entries:
                    if file_result['Type'] == entryTypes['error']:
                        raise Exception('Error getting attachment: ' + str(file_result['Contents']))
                    file_names.append({
                        'path': file_result['FileID'],
                        'name': file_result['File']
                    })

            incidents.append({
                'name': 'ServiceNow Incident ' + result.get('number'),
                'labels': labels,
                'details': json.dumps(result),
                'severity': severity,
                'attachment': file_names,
                'rawJSON': json.dumps(result)
            })

            count += 1
            snow_time = result[TIMESTAMP_FIELD]

        demisto.incidents(incidents)
        demisto.setLastRun({'time': snow_time})


    def test_module():
        # Validate fetch_time parameter is valid (if not, parse_date_range will raise the error message)
        parse_date_range(FETCH_TIME, '%Y-%m-%d %H:%M:%S')

        path = 'table/' + TICKET_TYPE + '?sysparm_limit=1'
        res = send_request(path, 'GET')
        if 'result' not in res:
            return_error('ServiceNow error: ' + str(res))
        ticket = res['result']
        if ticket and demisto.params().get('isFetch'):
            if isinstance(ticket, list):
                ticket = ticket[0]
            if TIMESTAMP_FIELD not in ticket:
                raise ValueError("The timestamp field [{}]"
                                 " does not exist in the ticket".format(TIMESTAMP_FIELD))


    LOG('Executing command ' + demisto.command())
    raise_exception = False
    try:
        if demisto.command() == 'test-module':
            test_module()
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            raise_exception = True
            fetch_incidents()
        elif demisto.command() == 'servicenow-get' or \
                demisto.command() == 'servicenow-incident-update' or demisto.command() == 'servicenow-get-ticket':
            demisto.results(get_ticket_command())
        elif demisto.command() == 'servicenow-update' or \
                demisto.command() == 'servicenow-incident-update' or demisto.command() == 'servicenow-update-ticket':
            demisto.results(update_ticket_command())
        elif demisto.command() == 'servicenow-create' or \
                demisto.command() == 'servicenow-incident-create' or demisto.command() == 'servicenow-create-ticket':
            demisto.results(create_ticket_command())
        elif demisto.command() == 'servicenow-delete-ticket':
            demisto.results(delete_ticket_command())
        elif demisto.command() == 'servicenow-add-link' or demisto.command() == 'servicenow-incident-add-link':
            demisto.results(add_link_command())
        elif demisto.command() == 'servicenow-add-comment' or demisto.command() == 'servicenow-incident-add-comment':
            demisto.results(add_comment_command())
        elif demisto.command() == 'servicenow-query' or \
                demisto.command() == 'servicenow-incidents-query' or demisto.command() == 'servicenow-query-tickets':
            demisto.results(query_tickets_command())
        elif demisto.command() == 'servicenow-upload-file' or demisto.command() == 'servicenow-incident-upload-file':
            demisto.results(upload_file_command())
        elif demisto.command() == 'servicenow-query-table':
            demisto.results(query_table_command())
        elif demisto.command() == 'servicenow-get-computer':
            demisto.results(get_computer_command())
        elif demisto.command() == 'servicenow-query-computers':
            demisto.results(query_computers_command())
        elif demisto.command() == 'servicenow-query-groups':
            demisto.results(query_groups_command())
        elif demisto.command() == 'servicenow-query-users':
            demisto.results(query_users_command())
        elif demisto.command() == 'servicenow-get-groups':
            demisto.results(get_groups_command())
        elif demisto.command() == 'servicenow-get-record':
            demisto.results(get_record_command())
        elif demisto.command() == 'servicenow-update-record':
            demisto.results(update_record_command())
        elif demisto.command() == 'servicenow-create-record':
            demisto.results(create_record_command())
        elif demisto.command() == 'servicenow-delete-record':
            demisto.results(delete_record_command())
        if demisto.command() == 'servicenow-list-table-fields':
            demisto.results(list_table_fields_command())
        if demisto.command() == 'servicenow-get-table-name':
            demisto.results(get_table_name_command())
        if demisto.command() == 'servicenow-get-ticket-notes':
            demisto.results(get_ticket_notes_command())
    except Exception as e:
        LOG(e)
        LOG.print_log()
        if not raise_exception:
            return_error(str(e))
        else:
            raise
  subtype: python2
  type: python
system: true
