args:
- default: true
  description: The text date we should extract regex from
  name: data
  required: true
- description: The regex to match and extract
  name: regex
  required: true
- description: The matching group to return (if not provided the full match will be
    returned), group value should start at 1
  name: group
- description: The context key to populate with the result
  name: contextKey
- description: The regex flags to match. Default is -gim.
  name: flags
comment: Extract regex data from given text - supports groups and looping as well.
commonfields:
  id: MatchRegex
  version: -1
enabled: true
name: MatchRegex
outputs:
- contextPath: MatchRegex.results
  description: List of Regex matches
  type: string
runonce: false
script: |-
  var data = (typeof args.data) === 'string' ? args.data : JSON.stringify(args.data);
  var flags = args.flags ? args.flags : 'gim';
  var r = new RegExp(args.regex, flags);
  var m;
  var vals = [];
  while ((m = r.exec(data)) !== null) {
      if (m && m.length > 0) {
          var val = m[0];
          var group = parseInt(args.group);
          if (args.group && m.length > group) {
              val = m[group];
          }
          var ec = {};
          if (args.contextKey) {
              ec[args.contextKey] = val;
          }
          vals.push(val);

          if (flags.indexOf('g') === -1) {
            break;
          }
      }
  }
  if (vals.length == 1) {
    setContext('MatchRegex.results', vals[0])
    return {Type: entryTypes.note, Contents: vals[0], ContentsFormat: formats.text, EntryContext: ec};
  } else if (vals.length) {
    setContext('MatchRegex.results', vals)
    return {Type: entryTypes.note, Contents: vals, ContentsFormat: formats.text, EntryContext: ec};
  } else {
    setContext('MatchRegex.results', vals)
    return {Type: entryTypes.note, Contents: 'Regex does not match', ContentsFormat: formats.text};
  }
scripttarget: 0
system: true
tags:
- Utility
type: javascript
