category: Data Enrichment & Threat Intelligence
commonfields:
  id: Cisco Umbrella Investigate
  version: -1
configuration:
- defaultvalue: ""
  display: Cisco Umbrella API token
  name: APIToken
  required: true
  type: 4
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- defaultvalue: https://investigate.api.umbrella.com
  display: Base URL
  name: baseURL
  required: true
  type: 0
- defaultvalue: "-100"
  display: DBot Score Malicious Threshold (-100 to 100)
  name: dboscore_threshold
  required: false
  type: 0
description: Cisco Umbrella Investigate
display: Cisco Umbrella Investigate
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEkAAAAyCAYAAAAQlvbeAAAGx0lEQVR42u1Za2xURRTeOzPbYikPeWgRWx7y8JXwQ/3HDw2JxldMBDXGBIhiFF+AihDFhJDwA8KjElhLd/c+lkIRQhtRjPKIKIokCshD9s7c3S0FSgVFnilQlPW77ez2lr3VLs0uNt6TnGxzz8ycc78558w3tz5PPPHEE0888cQTTzz5T4lini5jYb6IBPaPy4c/svz4WKYfWqys/mNYtwGJ1tRNZypPUt38nFRxJdf+WDCxnmlmkhqHZ3cbkFgoGmEaT0KPMNUsyKkvwyRMN0WrP3N99wFJM8MSpDhTo7kFSecEfn6R/tZ4IHU3kJSTF4uZJl6hmrgvG5AUPT6QRaJTybLfR2bVnCPx4SitqUr5uZJsQKJqbAyLiFd9FaJP/pvzuvgc9Bs7sDqqix6dBQnAaraNquL7rPxFxJbWwyBe3VmQaFXMz3TBW2xBMT//JRU2y2VgJxB8n86DxDdK28Gs/Kn8R9mcv+o0SCrviWdHbZtf4ytzWPOiyL3v8MUysEa8QO8sQKqVtn3u68aKO/C3S877otMgabwIz+olSAF3+mAWdY2kaYeegoMGqlobSDDuzzVIROfT7MwkRnRmzkHad4rSDXVrWMg8Tqri47uSRZp0ftFviJJcg0Q1sd22Uc36IdcgsUqzH1rGOTlP78JRzivlImcKInkASRWbZVPfnnOQNN4P+pucF+wC3Td1uUhTgSEGXWNbJm2nsCPZgLRJNuBoZibx1kwK8Z0uIO2xbSiPrVk0bhukxhaQVB5yAemsbUPFXH8m0W3HJiNLLlJd7FAisUKnjXzZ+BzAuUxXWZuU2nraWZBomM9kutlMVyYqM/yFjsxj4egVUlu/IMMWjn4Ef1fop/UfdhYkpcok1OA1eN5MDGtyO9ta4YdtK2yX6MfRKV3jQ4Y1mEbMm9zvaKKUVNcVuJDJVC9L4KUz7dW8jCw9QdyzN1rmSl6D+xVaaWbYALgN0iHpb23GYbDGAhhWqTtB5YXYtNt9+RbZgCta05gnsFsst5fpuMJUgUwy0csso/t8Tyo/PZyFogHyTeOj+fBHIsfHoa8ElKW7R/k88cST/7XQtYlCNOk7QBVGM8O6uf2lNKrYXAXaE3a/+5dFPhDz74IOw0lT9M+XXDGAaeJOrDWE6ryg43Exmx+NxPgRYO89bhg4RKvrhWa5iBnCZrR/Qq9CT0Ofd1CBUnkLP+nX+evtj/QDJZi/ATZ5NcB8jFUCP5W5nJYPws82x9hmALXbt1IUt4uppqE/C/EVsDdA/5JxHcXYxcRI9M7v6bWsaQBTrT0AwQ74Wp3hAGmYDDQJkGal56+wCA2LzY45l6EXoEkltHd0uxff1jCJhfnVDD8gub6KeN/0mocvDGZVsShT3WICPdCtvT7twoD8lZgki5LSJ1hEvI/fl1AKS/FsggOkoTajlSDNbCsxMVTudJIaYiPIXn/7mgBONUZZuCOdHUq4bjiuP02Ol11HVfNlAPQmSrgSmZQGiYVFbRogne/F70yMm50mmlDMieSnzEL8Njhskrt5hKjWIPeRHYMEBl8GptySYQDsAPrGw3RVLIPV09XxeekX1OILOy59MSoFOjZrD10dK3LY+lKNR+U6l4gaL805SHD0UDrwsFjig2QFkhQarF/NdEdp6LyRRsSsa75+bkyVI0Ac2pEfZNf4tmwTUzLt/N10zFXWI7kHaV18XNqhYS24XpCUJacLmWHOha3e0WeSxDj8hmNDPktlAPpShxlAdfOZdEy6mOTydWF62l6dyP0tgFYfHtLSaFUbpFiMVB/rkz1IzheI+QH2E/JkRPnxXY4MWJgCj0ZiczqMqfLg3ehHV5GNSYD5HQ1y0lZuvDD1mQXaTLTYsPw07gCvcZweaJJiMvQx/D0Lp8jj/wYSCe4rpmHzAezwLZhXzHTrXvSSRll236bHreT3sJB5JU0RjNhyNPonMW8C+th8X6h1g8iGOoWtsbY4Trav4fsFgD8R6+1s62uiJn8UYMeZUpxocTh2pwDtQWqWIL2Xeu7XrFFy7AXoqfRcvCSJ1L/Yrilv+nUGelPShQI0+SqsNgpQe34EaMkxaXfTuBL4uTS/TLs6VoLgNTg/4wjkCnSyA6Qh0n4RIM1oA0nY/On8NS/RQMOJd9x7jvU01tqbOsGkWuBJvdoBqteVoT99kuJcUs9CI0S3Snw3QgDSrfZ/cZnewnIrqc4/AIca4biW9EZfmQZ9G/b7HeD1sjMOWg4NQZeghJ4l4Xp/x9wsOhbj5kKDyKJyGrEm+gIxlkEHDA6gxFsYVwENUFW8hrgG+TzxxBNPPPHEE0888eRGyN8R98jGg6pa+wAAAABJRU5ErkJggg==
name: Cisco Umbrella Investigate
script:
  commands:
  - arguments:
    - default: true
      description: Enter the domain you would like to categorize (e.g. amazon.com)
      name: domain
      required: true
    description: Returns the category of a domain. e.g. domain=amazon.com returns
      Ecommerce/Shopping
    name: umbrella-domain-categorization
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.SecurityCategories
      description: The Umbrella security category, or categories, that match this
        domain
      type: string
    - contextPath: Domain.ContentCategories
      description: The Umbrella content category or categories that match this domain
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: string
  - arguments:
    - default: true
      description: Enter the domain you would like to categorize (e.g. amazon.com)
      name: domain
      required: true
    deprecated: true
    description: Returns the category of a domain. e.g. domain=amazon.com returns
      Ecommerce/Shopping
    name: investigate-umbrella-domain-categorization
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.SecurityCategories
      description: The Umbrella security category, or categories, that match this
        domain
      type: Unknown
    - contextPath: Domain.ContentCategories
      description: The Umbrella content category or categories that match this domain
      type: Unknown
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: Unknown
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: Unknown
  - arguments:
    - default: true
      description: Enter a domain (e.g. www.cnn.com)
      name: domain
      required: true
    description: Get a list of related domains back and returns a list of co-occurences
      for the specified domain. A co-occurrence is when two or more domains are being
      accessed by the same users within a small window of time. Being a co-occurrence
      isn't necessarily a bad thing, legitimate sites co-occur with each other as
      a part of normal web activity. However, unusual or suspicious co-occurence can
      provide additional information regarding attacks
    name: umbrella-domain-co-occurrences
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.CoOccurrences.Score
      description: Domain score - value range between 0 and 1
      type: number
    - contextPath: Domain.CoOccurrences.Name
      description: Domain name
      type: string
  - arguments:
    - default: true
      description: Enter a domain (e.g. www.cnn.com)
      name: domain
      required: true
    deprecated: true
    description: Get a list of related domains back and returns a list of co-occurences
      for the specified domain. A co-occurrence is when two or more domains are being
      accessed by the same users within a small window of time. Being a co-occurrence
      isn't necessarily a bad thing, legitimate sites co-occur with each other as
      a part of normal web activity. However, unusual or suspicious co-occurence can
      provide additional information regarding attacks
    name: investigate-umbrella-domain-co-occurrences
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.Score
      description: Domain score - value range between 0 and 1
      type: Unknown
  - arguments:
    - default: true
      description: Enter a domain (e.g. www.cnn.com)
      name: domain
      required: true
    description: This will return a list of domain names that have been frequently
      seen requested b around the same time (up to 60 seconds before or after) as
      the given domain name, but that are not frequently associated with other domain
      names.
    name: umbrella-domain-related
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.Related.Score
      description: This is a score reflecting the number of client IPs looking up
        related sites within 60 seconds of the original request
      type: number
    - contextPath: Domain.Related.Name
      description: Related domain name
      type: string
  - arguments:
    - default: true
      description: Enter a domain (e.g. www.cnn.com)
      name: domain
      required: true
    deprecated: true
    description: This will return a list of domain names that have been frequently
      seen requested b around the same time (up to 60 seconds before or after) as
      the given domain name, but that are not frequently associated with other domain
      names.
    name: investigate-umbrella-domain-related
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.Score
      description: This is a score reflecting the number of client IPs looking up
        related sites within 60 seconds of the original request
      type: Unknown
  - arguments:
    - default: true
      description: Enter a domain like (www.cnn.com)
      name: domain
      required: true
    - defaultValue: "-100"
      description: Manually set a threshold instead of secure rank in order to determine
        if domain is malicious. from -100(malicious) to 100(good)
      name: threshold
    description: This contains multiple scores or security features, each of which
      can be used to determine relevant datapoints to build insight on the reputation
      or security risk posed by the site. See security information about this specific
      domain at https://investigate-api.readme.io/docs/security-information-for-a-domain-1
    name: umbrella-domain-security
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.Security.DGA
      description: Domain Generation Algorithm. This score is generated based on the
        likeliness of the domain name being generated by an algorithm rather than
        a human
      type: number
    - contextPath: Domain.Security.Perplexity
      description: A second score on the likeliness of the name to be algorithmically
        generated, on a scale from 0 to 1
      type: number
    - contextPath: Domain.Security.Entropy
      description: The number of bits required to encode the domain name, as a score
      type: number
    - contextPath: Domain.Security.SecureRank
      description: Suspicious rank for a domain that reviews based on the lookup behavior
        of client IP for the domain
      type: number
    - contextPath: Domain.Security.PageRank
      description: Popularity according to Google's pagerank algorithm
      type: number
    - contextPath: Domain.Security.ASNScore
      description: ASN reputation score, ranges from -100 to 0 with -100 being very
        suspicious
      type: Unknown
    - contextPath: Domain.Security.PrefixScore
      description: Prefix ranks domains given their IP prefixes (an IP prefix is the
        first three octets in an IP address) and the reputation score of these prefixes.
        Ranges from -100 to 0, -100 being very suspicious
      type: number
    - contextPath: Domain.Security.RipScore
      description: RIP ranks domains given their IP addresses and the reputation score
        of these IP addresses. Ranges from -100 to 0, -100 being very suspicious
      type: number
    - contextPath: Domain.Security.Popularity
      description: The number of unique client IPs visiting this site, relative to
        the all requests to all sites
      type: number
    - contextPath: Domain.Security.GeoScore
      description: A score that represents how far the different physical locations
        serving this name are from each other
      type: number
    - contextPath: Domain.Security.KolmoorovSmirnov
      description: olmogorov–Smirnov test on geodiversity. 0 means that the client
        traffic matches what is expected for this TLD
      type: number
    - contextPath: Domain.Security.AttackName
      description: The name of any known attacks associated with this domain, or blank
        if no known threat
      type: string
    - contextPath: Domain.Security.ThreatType
      description: The type of the known attack, such as botnet or APT, or blank if
        no known threat
      type: string
  - arguments:
    - default: true
      description: Enter a domain like (www.cnn.com)
      name: domain
      required: true
    deprecated: true
    description: This contains multiple scores or security features, each of which
      can be used to determine relevant datapoints to build insight on the reputation
      or security risk posed by the site. See security information about this specific
      domain at https://investigate-api.readme.io/docs/security-information-for-a-domain-1
    name: investigate-umbrella-domain-security
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.Security.DGA
      description: Domain Generation Algorithm. This score is generated based on the
        likeliness of the domain name being generated by an algorithm rather than
        a human
      type: Unknown
    - contextPath: Domain.Security.Perplexity
      description: A second score on the likeliness of the name to be algorithmically
        generated, on a scale from 0 to 1
      type: Unknown
    - contextPath: Domain.Security.Entropy
      description: The number of bits required to encode the domain name, as a score
      type: Unknown
    - contextPath: Domain.Security.SecureRank
      description: Suspicious rank for a domain that reviews based on the lookup behavior
        of client IP for the domain
      type: Unknown
    - contextPath: Domain.Security.PageRank
      description: Popularity according to Google's pagerank algorithm
      type: Unknown
    - contextPath: Domain.Security.ASNScore
      description: ASN reputation score, ranges from -100 to 0 with -100 being very
        suspicious
      type: Unknown
    - contextPath: Domain.Security.PrefixScore
      description: Prefix ranks domains given their IP prefixes (an IP prefix is the
        first three octets in an IP address) and the reputation score of these prefixes.
        Ranges from -100 to 0, -100 being very suspicious
      type: Unknown
    - contextPath: Domain.Security.RipScore
      description: RIP ranks domains given their IP addresses and the reputation score
        of these IP addresses. Ranges from -100 to 0, -100 being very suspicious
      type: Unknown
    - contextPath: Domain.Security.Popularity
      description: The number of unique client IPs visiting this site, relative to
        the all requests to all sites
      type: Unknown
    - contextPath: Domain.Security.GeoScore
      description: A score that represents how far the different physical locations
        serving this name are from each other
      type: Unknown
    - contextPath: Domain.Security.KolmoorovSmirnov
      description: olmogorov–Smirnov test on geodiversity. 0 means that the client
        traffic matches what is expected for this TLD
      type: Unknown
    - contextPath: Domain.Security.AttackName
      description: The name of any known attacks associated with this domain, or blank
        if no known threat
      type: Unknown
    - contextPath: Domain.Security.ThreatType
      description: The type of the known attack, such as botnet or APT, or blank if
        no known threat
      type: Unknown
  - arguments:
    - default: true
      description: Enter a domain like (www.cnn.com)
      name: domain
      required: true
    description: The DNS database can be used to query the history that Umbrella has
      seen for a given domain. The most common use case is to obtain the RRs (Resource
      Record) history for a given domain, passing in the record query type as a parameter,
      to help build intelligence around an domain.
    name: umbrella-domain-dns-history
    outputs:
    - contextPath: Domain.Address
      description: IP address
      type: Unknown
    - contextPath: Domain.DNSHistory.Age
      description: The day in days between now and the last request for this domain.
        This value is only useful if present
      type: Unknown
    - contextPath: Domain.DNSHistory.TtlsMin
      description: Minimum amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: Domain.DNSHistory.TtlsMax
      description: Maximum amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: Domain.DNSHistory.TtlsMean
      description: Average amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: Domain.DNSHistory.TtlsMedian
      description: Median amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: Domain.DNSHistory.TtlsStddev
      description: Standard deviation of the amount of time set that DNS records should
        be cached
      type: Unknown
    - contextPath: Domain.DNSHistory.CountryCodes
      description: 'List of country codes (ex: US, FR, TW) for the IPs the name maps
        to'
      type: Unknown
    - contextPath: Domain.DNSHistory.CountryCount
      description: Number of countries the IPs are hosted in
      type: Unknown
    - contextPath: Domain.DNSHistory.Asns
      description: List of ASN numbers the IPs are in
      type: Unknown
    - contextPath: Domain.DNSHistory.AsnsCount
      description: Number of ASNs the IPs map to
      type: Unknown
    - contextPath: Domain.DNSHistory.Prefixes
      description: List of network prefixes the IPs map to
      type: Unknown
    - contextPath: Domain.DNSHistory.PrefixesCount
      description: Number of network prefixes the IPs map to
      type: Unknown
    - contextPath: Domain.DNSHistory.Rips
      description: Number of IPs seen for the domain name
      type: Unknown
    - contextPath: Domain.DNSHistory.DivRips
      description: The number of prefixes over the number of IPs
      type: Unknown
    - contextPath: Domain.DNSHistory.Locations
      description: List of geo coordinates (WGS84 datum, decimal format) the IPs are
        mapping to
      type: Unknown
    - contextPath: Domain.DNSHistory.LocationsCount
      description: Number of distinct geo coordinates the IPs are mapping to
      type: Unknown
    - contextPath: Domain.DNSHistory.GeoDistanceSum
      description: Minimum sum of distance between locations, in kilometers
      type: Unknown
    - contextPath: Domain.DNSHistory.GeoDistancMean
      description: Mean distance between the geo median and each location, in kilometers
      type: Unknown
    - contextPath: Domain.DNSHistory.MailExchanger
      description: Boolean, If an MX query for this domain name has been seen
      type: Unknown
    - contextPath: Domain.DNSHistory.NonRoutable
      description: Boolean. If one of the IPs is in a reserved, non-routable IP range
      type: Unknown
    - contextPath: Domain.DNSHistory.FfCandidate
      description: Boolean. If the domain name looks like a candidate for fast flux.
        This does not necessarily mean the domain is in fast flux, but rather that
        the IP address the domain resolves to changes rapidly
      type: Unknown
    - contextPath: Domain.DNSHistory.RipsStability
      description: 1.0 divided by the number of times the set of IP addresses changed
      type: Unknown
    - contextPath: Domain.DNSHistory.BaseDomain
      description: The base domain of the requested domain
      type: Unknown
    - contextPath: Domain.DNSHistory.IsSubdomain
      description: Boolean. True if the requested domain is a subdomain of another
      type: Unknown
  - arguments:
    - default: true
      description: Enter a domain like (www.cnn.com)
      name: domain
      required: true
    deprecated: true
    description: The DNS database can be used to query the history that Umbrella has
      seen for a given domain. The most common use case is to obtain the RRs (Resource
      Record) history for a given domain, passing in the record query type as a parameter,
      to help build intelligence around an domain.
    name: investigate-umbrella-domain-dns-history
    outputs:
    - contextPath: IP.Address
      description: IP address
      type: Unknown
    - contextPath: IP.DNSHistory.Age
      description: The day in days between now and the last request for this domain.
        This value is only useful if present
      type: Unknown
    - contextPath: IP.DNSHistory.TtlsMin
      description: Minimum amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: IP.DNSHistory.TtlsMax
      description: Maximum amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: IP.DNSHistory.TtlsMean
      description: Average amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: IP.DNSHistory.TtlsMedian
      description: Median amount of time set that DNS records should be cached
      type: Unknown
    - contextPath: IP.DNSHistory.TtlsStddev
      description: Standard deviation of the amount of time set that DNS records should
        be cached
      type: Unknown
    - contextPath: IP.DNSHistory.CountryCodes
      description: 'List of country codes (ex: US, FR, TW) for the IPs the name maps
        to'
      type: Unknown
    - contextPath: IP.DNSHistory.CountryCount
      description: Number of countries the IPs are hosted in
      type: Unknown
    - contextPath: IP.DNSHistory.Asns
      description: List of ASN numbers the IPs are in
      type: Unknown
    - contextPath: IP.DNSHistory.AsnsCount
      description: Number of ASNs the IPs map to
      type: Unknown
    - contextPath: IP.DNSHistory.Prefixes
      description: List of network prefixes the IPs map to
      type: Unknown
    - contextPath: IP.DNSHistory.PrefixesCount
      description: Number of network prefixes the IPs map to
      type: Unknown
    - contextPath: IP.DNSHistory.Rips
      description: Number of IPs seen for the domain name
      type: Unknown
    - contextPath: IP.DNSHistory.DivRips
      description: The number of prefixes over the number of IPs
      type: Unknown
    - contextPath: IP.DNSHistory.Locations
      description: List of geo coordinates (WGS84 datum, decimal format) the IPs are
        mapping to
      type: Unknown
    - contextPath: IP.DNSHistory.LocationsCount
      description: Number of distinct geo coordinates the IPs are mapping to
      type: Unknown
    - contextPath: IP.DNSHistory.GeoDistanceSum
      description: Minimum sum of distance between locations, in kilometers
      type: Unknown
    - contextPath: IP.DNSHistory.GeoDistancMean
      description: Mean distance between the geo median and each location, in kilometers
      type: Unknown
    - contextPath: IP.DNSHistory.MailExchanger
      description: Boolean, If an MX query for this domain name has been seen
      type: Unknown
    - contextPath: IP.DNSHistory.NonRoutable
      description: Boolean. If one of the IPs is in a reserved, non-routable IP range
      type: Unknown
    - contextPath: IP.DNSHistory.FfCandidate
      description: Boolean. If the domain name looks like a candidate for fast flux.
        This does not necessarily mean the domain is in fast flux, but rather that
        the IP address the domain resolves to changes rapidly
      type: Unknown
    - contextPath: IP.DNSHistory.RipsStability
      description: 1.0 divided by the number of times the set of IP addresses changed
      type: Unknown
    - contextPath: IP.DNSHistory.BaseDomain
      description: The base domain of the requested domain
      type: Unknown
    - contextPath: IP.DNSHistory.IsSubdomain
      description: Boolean. True if the requested domain is a subdomain of another
      type: Unknown
  - arguments:
    - default: true
      description: 'Enter an IP Address:'
      name: ip
      required: true
    - defaultValue: "100"
      description: Limit fetched results, removing limit can fetch big amount of results
        into context.
      name: limit
    description: The DNS database can be used to query the history that Umbrella has
      seen for a given IP address. The most common use case is to obtain the DNS Resource
      Record (RR) history for a given IP, passing in the record query type as a parameter,
      to help build intelligence around an IP or a range of IPs. The information provided
      is from within the last 90 days.
    name: umbrella-ip-dns-history
    outputs:
    - contextPath: IP.Address
      description: IP address
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.Name
      description: The looked up IP addres
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.Class
      description: DNS class type
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.Type
      description: Query type
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.RR
      description: Resource record owner
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.TTL
      description: Time to live for this record
      type: Unknown
    - contextPath: IP.DNSHistory.Features.RrCount
      description: Number of records of that type mapping to the given IP
      type: Unknown
    - contextPath: IP.DNSHistory.Features.Ld2Count
      description: Number of 2-level names mapping to the given IP
      type: Unknown
    - contextPath: IP.DNSHistory.Features.Ld3Count
      description: Number of 3-level names mapping to the given IP
      type: Unknown
    - contextPath: IP.DNSHistory.Features.Ld21Count
      description: Number of 2-level names, without the TLD, mapping to the given
        IP
      type: Unknown
    - contextPath: IP.DNSHistory.Features.Ld22Count
      description: Number of 3-level names, without the TLD, mapping to the given
        IP
      type: Unknown
    - contextPath: IP.DNSHistory.Features.DivLd2
      description: ld2_count divided by the number of records
      type: Unknown
    - contextPath: IP.DNSHistory.Features.DivLd3
      description: ld3_count divided by the number of records
      type: Unknown
    - contextPath: IP.DNSHistory.Features.DivLd21
      description: ld2_1_count divided by the number of records
      type: Unknown
    - contextPath: IP.DNSHistory.Features.DivLd22
      description: ld2_2_count divided by the number of records
      type: Unknown
  - arguments:
    - default: true
      description: 'Enter an IP Address:'
      name: ip
      required: true
    deprecated: true
    description: The DNS database can be used to query the history that Umbrella has
      seen for a given IP address. The most common use case is to obtain the DNS Resource
      Record (RR) history for a given IP, passing in the record query type as a parameter,
      to help build intelligence around an IP or a range of IPs. The information provided
      is from within the last 90 days.
    name: investigate-umbrella-ip-dns-history
    outputs:
    - contextPath: IP.Address
      description: IP address
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.Name
      description: The looked up IP addres
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.Class
      description: DNS class type
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.Type
      description: Query type
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.RR
      description: Resource record owner
      type: Unknown
    - contextPath: IP.DNSHistory.RRS.TTL
      description: Time to live for this record
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.RrCount
      description: Number of records of that type mapping to the given IP
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.Ld2Count
      description: Number of 2-level names mapping to the given IP
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.Ld3Count
      description: Number of 3-level names mapping to the given IP
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.Ld21Count
      description: Number of 2-level names, without the TLD, mapping to the given
        IP
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.Ld22Count
      description: Number of 3-level names, without the TLD, mapping to the given
        IP
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.DivLd2
      description: ld2_count divided by the number of records
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.DivLd3
      description: ld3_count divided by the number of records
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.DivLd21
      description: ld2_1_count divided by the number of records
      type: Unknown
    - contextPath: IP.DNSHistory.Feature.DivLd22
      description: ld2_2_count divided by the number of records
      type: Unknown
  - arguments:
    - default: true
      description: An IP Address
      name: ip
      required: true
    deprecated: true
    description: This command  shows whether the IP address you’ve entered as input
      has any known malicious domains associated with it. The domains that appear
      when using this endpoint are those that currently exist in the Umbrella block
      list. This endpoint will return an array with a single domain name for each
      domain associated with the IP, along with an id number that can be ignored.
    name: investigate-umbrella-ip-malicious-domains
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: Unknown
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: Unknown
  - arguments:
    - default: true
      description: An IP Address
      name: ip
      required: true
    description: This command  shows whether the IP address you’ve entered as input
      has any known malicious domains associated with it. The domains that appear
      when using this endpoint are those that currently exist in the Umbrella block
      list. This endpoint will return an array with a single domain name for each
      domain associated with the IP, along with an id number that can be ignored.
    name: umbrella-ip-malicious-domains
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: Unknown
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: Unknown
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
  - arguments:
    - default: true
      description: Enter a domain regular expression (e.g. "cn.*\\\\.com"). Note to
        use double backslash ("\\\\")
      name: regex
      required: true
    - description: 'Example: -2weeks, -1 day, -1000minutes, EPOCH unix time, MAX:
        -31days'
      name: start
    - defaultValue: "100"
      description: Limit fetched results, removing limit can fetch big amount of results
        into context.
      name: limit
    description: This produces a list of matching domains based on a regular expression.
      You could use this for domain squatting. The pattern search functionality in
      Investigate uses regular expressions (RegEx) to search against the Investigate
      database. There are several excellent tools online such as http://regexr.com
      to help if you’re not familiar with building RegEx.
    name: umbrella-domain-search
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: string
    - contextPath: Domain.FirstSeen
      description: First seen time in Epoch format
      type: string
    - contextPath: Domain.FirstSeenISO
      description: First seen time in ISO format
      type: Unknown
    - contextPath: Domain. SecurityCategories
      description: Matching Umbrella Security Categories
      type: string
  - arguments:
    - default: true
      description: Enter a domain regular expression (e.g. "cn.*\\\\.com"). Note to
        use double backslash ("\\\\")
      name: regex
      required: true
    - description: 'Example: -2weeks, -1 day, -1000minutes, EPOCH unix time'
      name: start
    deprecated: true
    description: This produces a list of matching domains based on a regular expression.
      You could use this for domain squatting. The pattern search functionality in
      Investigate uses regular expressions (RegEx) to search against the Investigate
      database. There are several excellent tools online such as http://regexr.com
      to help if you’re not familiar with building RegEx.
    name: investigate-umbrella-domain-search
    outputs:
    - contextPath: Domain.Name
      description: Domain name
      type: Unknown
    - contextPath: Domain.FirstSeean
      description: First seen time in Epoch format
      type: Unknown
    - contextPath: Domain.FirstSeeanISO
      description: First seen time in ISO format
      type: Unknown
    - contextPath: Domain. SecurityCategories
      description: Matching Umbrella Security Categories
      type: Unknown
  - arguments:
    - default: true
      description: 'The domain name you would like to categorize. (e.g. : www.amazon.com)
        Comma separated list allowed. (e.g. : www.amazon.com,www.facebook.com,www.yahoo.com)'
      name: domain
      required: true
    description: Get Domain Reputation info using Cisco Umbrella Investigate. Domain
      reputation score is either true or false from the service and cannot be modified
      using a threshold.
    name: domain
    outputs:
    - contextPath: Domain.Name
      description: The domain's name.
      type: string
    - contextPath: Domain.Umbrella.RiskScore
      description: The status will be "-1" if the domain is believed to be malicious,
        "1" if the domain is believed to be benign, "0" if it hasn't been classified
        yet.
      type: number
    - contextPath: Domain.Umbrella.SecureRank 
      description: Suspicious rank for a domain that reviews based on the lookup behavior
        of client IP for the domain. Securerank is designed to identify hostnames
        requested by known infected clients but never requested by clean clients,
        assuming these domains are more likely to be bad. Scores returned range from
        -100 (suspicious) to 100 (benign).
      type: number
    - contextPath: Domain.Umbrella.FirstQueriedTime
      description: The time when the attribution for this Domain was made.
      type: number
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score.
      type: String
    - contextPath: Domain.Umbrella.ContentCategories
      description: The Umbrella content category or categories that match this domain.
        If none of them match, the return will be blank.
      type: string
    - contextPath: Domain.Umbrella.MalwareCategories
      description: The Umbrella security category, or categories, that match this
        domain or that this domain is associated with. If none match, the return will
        be blank.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: string
    - contextPath: Domain.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Phone
      description: The phone number of the registrant.
      type: String
    - contextPath: Domain.CreationDate
      description: The date on which the domain was created.
      type: Date
    - contextPath: Domain.DomainStatus
      description: The status of the domain.
      type: String
    - contextPath: Domain.UpdatedDate
      description: The date on which the domain was last updated.
      type: Date
    - contextPath: Domain.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.Registrar.Name
      description: The name of the registrar, such as "GoDaddy".
      type: String
  - arguments:
    - description: 'The domain name you would like see related domains for. (e.g.
        : www.cnn.com)'
      name: domain
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: Set to true to get a list of co-occurences. (A co-occurrence is
        when two or more domains are being accessed by the same users within a small
        window of time) By default, this value will be false.
      name: coOccurences
      predefined:
      - "false"
      - "true"
    description: Get a list of domain names that have been frequently seen requested
      around the same time (up to 60 seconds before or after) as the given domain
      name. And also a list of co-occurences.
    name: umbrella-get-related-domains
    outputs:
    - contextPath: Umbrella.RelatedDomains.Domain
      description: The domain's name.
      type: string
    - contextPath: Umbrella.RelatedDomains.Data.Name
      description: Domain names that have been frequently seen requested around the
        same time (up to 60 seconds before or after) as the given domain name.
      type: string
    - contextPath: Umbrella.CoOccurences.Data.Name
      description: All co-occurences of requests from client IPs are returned for
        the previous seven days whether the co-occurence is suspicious or not.
      type: string
    - contextPath: Umbrella.CoOccurences.Data.Score
      description: The values range between 0 and 1 and should not exceed 1.
      type: number
    - contextPath: Umbrella.RelatedDomains.Data.Score
      description: The score here is the number of client IP requests to the site
        around the same time as the site being looked up. This is a score reflecting
        the number of client IPs looking up related sites within 60 seconds of the
        original request
      type: number
    - contextPath: Umbrella.CoOccurences.Domain
      description: The domain's name.
      type: string
  - arguments:
    - description: 'The domain name you would like see classifiers for. (e.g. : www.cnn.com)'
      name: domain
      required: true
    description: List all the classifiers used for a particular domain to assign a
      particular security categorization or threat type (indicators of compromise).
    name: umbrella-get-domain-classifiers
    outputs:
    - contextPath: Umbrella.DomainClassifiers.Domain
      description: The domain's name.
      type: string
    - contextPath: Umbrella.DomainClassifiers.Data.MalwareCategories
      description: Which Umbrella security category, if any, matched the input
      type: string
    - contextPath: Umbrella.DomainClassifiers.Data.AttackNames
      description: Which named attacks, if any, matched the input
      type: string
    - contextPath: Umbrella.DomainClassifiers.Data.ThreatTypes
      description: Which threat type, if any, matched in the input.
      type: string
  - arguments:
    - description: 'The domain name you would like see volume for. (e.g. : www.cnn.com)'
      name: domain
      required: true
    - defaultValue: -7days
      description: 'Point in time in the past, expressed as a timestamp in the following
        format or relative time. Valid formats: start=-2days start=-2hours start=1997-07-16T19:20:30+01:00
        i.e YYYY-MM-DDThh:mm:ssTZD  Note the negative sign. The max is 30 days.'
      name: start
    - defaultValue: now
      description: 'Point in time in the past expressed as a timestamp in milliseconds
        or relative time. Also valid is ''now''. Valid formats: stop=-1days stop=now
        start=1997-07-16T19:20:30+01:00 i.e YYYY-MM-DDThh:mm:ssTZD  Note the negative
        sign. The max is 30 days.'
      name: stop
    - auto: PREDEFINED
      defaultValue: all
      description: 'Valid options are: exact, component, or all (default).     1.Using
        "cisco.com" as an example, "exact" only gives results for cisco.com.    2.
        Component gives results for every component of cisco.com, but not cisco.com.
        Examples are www.cisco.com, mail.cisco.com, wwwin.cisco.com, something.else.cisco.com.     3.All
        returns the sum of component and exact, this is the default.'
      name: match
      predefined:
      - all
      - exact
      - component
    - defaultValue: "100"
      description: Limit fetched results, removing limit can fetch big amount of results
        into context.
      name: limit
    description: The domain volume command shows the number of DNS queries made per
      hour to the specified domain by users of Umbrella's recursive DNS servers.
    name: umbrella-get-domain-queryvolume
    outputs:
    - contextPath: Umbrella.QueryVolume.Domain
      description: The domain's name.
      type: string
    - contextPath: Umbrella.QueryVolume.Data.StartDate
      description: Start date for which the volume data is returned.
      type: string
    - contextPath: Umbrella.QueryVolume.Data.StopDate
      description: Stop date for which the volume data is returned.
      type: string
    - contextPath: Umbrella.QueryVolume.Data.QueriesInfo.QueryHour
      description: Query hour for which the queries data is returned.
      type: string
    - contextPath: Umbrella.QueryVolume.Data.QueriesInfo.Queries
      description: Number of DNS queries per hour, in ascending order, to the specified
        domain.
      type: string
  - arguments:
    - description: 'The domain name you would like see the security info for. (e.g.
        : www.cnn.com)'
      name: domain
      required: true
    - defaultValue: "-100"
      description: Manually set a threshold instead of secure rank in order to determine
        if domain is malicious. from -100(malicious) to 100(good)
      name: threshold
    description: The security information API method contains multiple scores or security
      features, which can act as relevant datapoints to build insight on the reputation.
    name: umbrella-get-domain-details
    outputs:
    - contextPath: Umbrella.DomainDetails.Domain
      description: The domain's name.
      type: string
    - contextPath: Umbrella.DomainDetails.Data.DGA
      description: Domain Generation Algorithm. This score is generated based on the
        likeliness of the domain name being generated by an algorithm rather than
        a human. This score ranges from -100 (suspicious) to 0 (benign).
      type: string
    - contextPath: Umbrella.DomainDetails.Data.Entropy
      description: The number of bits required to encode the domain name, as a score.
        This score is to be used in conjunction with DGA and Perplexity.
      type: number
    - contextPath: Umbrella.DomainDetails.Data.SecureRank 
      description: Suspicious rank for a domain that reviews based on the lookup behavior
        of client IP for the domain. Securerank is designed to identify hostnames
        requested by known infected clients but never requested by clean clients,
        assuming these domains are more likely to be bad. Scores returned range from
        -100 (suspicious) to 100 (benign).
      type: number
    - contextPath: Umbrella.DomainDetails.Data.PrefixScore
      description: Prefix ranks domains given their IP prefixes (an IP prefix is the
        first three octets in an IP address) and the reputation score of these prefixes.
        Ranges from -100 to 0, -100 being very suspicious.
      type: number
    - contextPath: Umbrella.DomainDetails.Data.RipScore
      description: RIP ranks domains given their IP addresses and the reputation score
        of these IP addresses. Ranges from -100 to 0, -100 being very suspicious.
      type: number
    - contextPath: Umbrella.DomainDetails.Data.Popularity
      description: The number of unique client IPs visiting this site, relative to
        the all requests to all sites. A score of how many different client/unique
        IPs go to this domain compared to others.
      type: number
    - contextPath: Umbrella.DomainDetails.Data.Geodiversity
      description: A score representing the number of queries from clients visiting
        the domain, broken down by country. Score is a non-normalized ratio between
        0 and 1.
      type: number
    - contextPath: Umbrella.DomainDetails.Data.TldGeodiversity
      description: A score that represents the TLD country code geodiversity as a
        percentage of clients visiting the domain. Occurs most often with domains
        that have a ccTLD. Score is normalized ratio between 0 and 1.
      type: number
    - contextPath: Umbrella.DomainDetails.Data.KolmogorovSmirnovTest
      description: Kolmogorov–Smirnov test on geodiversity. 0 means that the client
        traffic matches what is expected for this TLD.
      type: number
    - contextPath: DBotScore.Indicator
      description: The Indicator
      type: string
    - contextPath: DBotScore.Score
      description: The DBot score
      type: number
    - contextPath: DBotScore.Type
      description: The Indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The DBot score vendor
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: string
  - arguments:
    - description: 'Email address following rfc5322 conventions. (e.g. : admin@google.com)
        Comma separated list allowed. (e.g. : admin@google.com, dns-admin@google.com,
        hostmaster@charter.com)'
      isArray: true
      name: emails
      required: true
    - description: For paging with offset for domains with more than 500 results,
        set the url-param limit. Default value is 10.
      name: offset
    - auto: PREDEFINED
      description: 'To sort the list of domains based on timestamp. By default, domains
        are simply sorted by name in alphabetical order.  Possible values are: ""created"",
        ""updated"", and ""expired"", each of which sorts from the most recent date
        for the value of the WHOIS entry.'
      name: sort
      predefined:
      - created
      - updated
    - defaultValue: "100"
      description: To limit the total number of results (domains).
      name: limit
    description: The command will return the domains associated with the email address
      or addresses of the registrar that are looked up.
    name: umbrella-get-domains-for-email-registrar
    outputs:
    - contextPath: Umbrella.AssociatedDomains.Email
      description: Email address.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.TotalResults
      description: Total number of results for this email.
      type: number
    - contextPath: Umbrella.AssociatedDomains.Data.MoreDataAvailable
      description: Whether or not there are more than 500 results for this email,
        either yes or no.
      type: boolean
    - contextPath: Umbrella.AssociatedDomains.Data.ResultLimit
      description: Total number of results for this page of results, default 500.
      type: number
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.Name
      description: Domains registered by this email
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.Name.SecurityCategories
      description: Security Categories associated with the domain.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.Name.ContentCategories
      description: Content Categories associated with the domain.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.LastObserved
      description: 'Whether the domain is current, meaning currently registered by
        this email address. Values : Past or Current'
      type: string
  - arguments:
    - description: 'Enter the Nameserver’s domain name. (e.g. : ns2.google.com) Comma
        separated list allowed. (e.g. : ns2.google.com, ns1.google.com)'
      isArray: true
      name: nameservers
      required: true
    - description: For paging with offset for domains with more than 500 results,
        set the url-param limit. Default value is 10.
      name: offset
    - auto: PREDEFINED
      description: '"To sort the list of domains based on timestamp. By default, domains
        are simply sorted by name in alphabetical order.  Possible values are: ""created"",
        ""updated"", and ""expired"", each of which sorts from the most recent date
        for the value of the WHOIS entry."'
      name: sort
      predefined:
      - created
      - updated
    - defaultValue: "100"
      description: To limit the total number of results (domains).
      name: limit
    description: The Nameserver command allows you to search a nameserver to find
      all domains registered by that nameserver. You can search against a single nameserver
      or multiple nameservers in a query.
    name: umbrella-get-domains-for-nameserver
    outputs:
    - contextPath: Umbrella.AssociatedDomains.Nameserver
      description: Nameserver's domain name.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.TotalResults
      description: Total number of results for this nameserver domain name.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.MoreDataAvailable
      description: Whether or not there are more than 500 results for this email,
        either yes or no.
      type: boolean
    - contextPath: Umbrella.AssociatedDomains.Data.ResultLimit
      description: Total number of results for this page of results, default 500.
      type: number
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.Name
      description: Domains registered by this nameserver.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.Name.SecurityCategories
      description: Security Categories associated with the domain.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.Name.ContentCategories
      description: Content Categories associated with the domain.
      type: string
    - contextPath: Umbrella.AssociatedDomains.Data.Domains.LastObserved
      description: 'Whether the domain is current, meaning currently registered by
        this email address. Values : Past or Current'
      type: string
  - arguments:
    - description: 'Domain name without wildcards and including TLD. (e.g. : www.cnn.com)'
      name: domain
      required: true
    description: This command will provide a standard WHOIS response record for a
      single domain with all available WHOIS data returned.
    name: umbrella-get-whois-for-domain
    outputs:
    - contextPath: Domain.Umbrella.Whois.Name
      description: Domain's name.
      type: string
    - contextPath: Domain.Umbrella.Whois.RegistrarName
      description: Domain registrar name
      type: string
    - contextPath: Domain.Umbrella.Whois.LastRetrieved
      description: Domain last retrieved date
      type: string
    - contextPath: Domain.Umbrella.Whois.Created
      description: Domain created date
      type: string
    - contextPath: Domain.Umbrella.Whois.Updated
      description: Domain updated date
      type: string
    - contextPath: Domain.Umbrella.Whois.Expires
      description: Domain expiry date
      type: string
    - contextPath: Domain.Umbrella.Whois.IANAID
      description: IANA ID
      type: string
    - contextPath: Domain.Umbrella.Whois.LastObserved
      description: Domain last observed
      type: string
    - contextPath: Domain.Umbrella.Whois.Nameservers.Name
      description: Domain's name servers
      type: string
    - contextPath: Domain.Umbrella.Whois.Emails.Name
      description: Domain's email
      type: string
    - contextPath: Domain.Name
      description: The domain name e.g. google.com
      type: Unknown
    - contextPath: Domain.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Phone
      description: The phone number of the registrant.
      type: String
    - contextPath: Domain.CreationDate
      description: The date on which the domain was created.
      type: Date
    - contextPath: Domain.DomainStatus
      description: The status of the domain.
      type: String
    - contextPath: Domain.UpdatedDate
      description: The date on which the domain was last updated.
      type: Date
    - contextPath: Domain.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.Registrar.Name
      description: The name of the registrar, such as "GoDaddy".
      type: String
  - arguments:
    - description: IP Address to check for malicious domains.
      name: ip
      required: true
    description: Test whether the IP address you’ve entered as input has any known
      malicious domains associated with it.
    name: umbrella-get-malicious-domains-for-ip
    outputs:
    - contextPath: Umbrella.MaliciousDomains.IP
      description: IP address.
      type: string
    - contextPath: Umbrella.MaliciousDomains.Data.Name
      description: The block list domain associated with the IP
      type: string
    - contextPath: Umbrella.MaliciousDomains.Data.LastObserved
      description: 'Whether the domain is current, meaning currently registered by
        this email address. Values : Past or Current'
      type: string
    - contextPath: Umbrella.MaliciousDomains.Data.MalwareCategories
      description: Security Categories associated with the domain.
      type: string
    - contextPath: Umbrella.MaliciousDomains.Data.ContentCategories
      description: Content Categories associated with the domain.
      type: string
  - arguments:
    - description: 'A standard RegEx search pattern, must be encoded in a double quoted
        bracket. e.g. :'
      name: expression
      required: true
    - defaultValue: -7days
      description: 'Can either be specified in relative or absolute time. Point in
        time in the past, expressed as a timestamp in the following format or relative
        time. Valid formats: start=-2days start=-2hours start=-1000minutes start=-3weeks
        start=1997-07-16T19:20:30+01:00 i.e YYYY-MM-DDThh:mm:ssTZD  Note the negative
        sign for relative time.  Max is -30days.'
      name: start
    - auto: PREDEFINED
      defaultValue: "true"
      description: Default is false, if set to true this will include security categories
        in the results and may slow the return times.
      name: includeCategory
      predefined:
      - "false"
      - "true"
    - defaultValue: now
      description: 'The exclusive end time in milliseconds absolute or relative time
        (eg: ''now'', ''-2days'',''1997-07-16T19:20:30+01:00'') for a query.'
      name: stop
    - defaultValue: "100"
      description: The maximum number of items to return - combine with offset for
        result pagination
      name: limit
    - auto: PREDEFINED
      defaultValue: HOST
      description: Search database node type (URL, IP, HOST).
      name: type
      predefined:
      - URL
      - IP
      - HOST
    description: Get the list of matching domains (Investigate Database) based on
      a regular expression.
    name: umbrella-get-domains-using-regex
    outputs:
    - contextPath: Umbrella.DomainSearch.TotalResults
      description: Total results from this search string. The default number of results
        is 100 and can be expanded using the limit parameter.
      type: number
    - contextPath: Umbrella.DomainSearch.Data.Name
      description: Name of the domain found.
      type: string
    - contextPath: Umbrella.DomainSearch.Data.FirstSeen
      description: First Seen of the domain found.
      type: string
    - contextPath: Umbrella.DomainSearch.Data.SecurityCategories
      description: Security Categories associated with the domain.
      type: string
  - arguments:
    - description: 'The domain name you would like see timeline for. (e.g. : www.cnn.com)'
      name: domain
      required: true
    description: The timeline command shows when a domain was given attribution of
      a particular security categorization or threat type (indicators of compromise).
    name: umbrella-get-domain-timeline
    outputs:
    - contextPath: Umbrella.Timeline.Domain
      description: Domain name
      type: string
    - contextPath: Umbrella.Timeline.Data.MalwareCategories
      description: Which Umbrella security category, if any, matched the input
      type: string
    - contextPath: Umbrella.Timeline.Data.Attacks
      description: Which named attacks, if any, matched the input
      type: string
    - contextPath: Umbrella.Timeline.Data.ThreatTypes
      description: Which threat type, if any, matched in the input.
      type: string
    - contextPath: Umbrella.Timeline.Data.Timestamp
      description: The time when the attribution for this Domain changed.
      type: string
  - arguments:
    - description: 'The IP you would like see timeline for. (e.g. : 8.8.8.8)'
      name: ip
      required: true
    description: The timeline command shows when a IP was given attribution of a particular
      security categorization or threat type (indicators of compromise).
    name: umbrella-get-ip-timeline
    outputs:
    - contextPath: Umbrella.Timeline.IP
      description: IP address
      type: string
    - contextPath: Umbrella.Timeline.Data.MalwareCategories
      description: Which Umbrella security category, if any, matched the input
      type: string
    - contextPath: Umbrella.Timeline.Data.Attacks
      description: Which named attacks, if any, matched the inputWhich threat type,
        if any, matched in the input.
      type: string
    - contextPath: Umbrella.Timeline.Data.ThreatTypes
      description: Which threat type, if any, matched in the input.
      type: string
    - contextPath: Umbrella.Timeline.Data.Timestamp
      description: The time when the attribution for this IP changed.
      type: string
  - arguments:
    - description: 'The URL you would like see timeline for. (e.g. : www.aws.amazon.com)'
      name: url
      required: true
    description: The timeline command shows when a URL was given attribution of a
      particular security categorization or threat type (indicators of compromise).
    name: umbrella-get-url-timeline
    outputs:
    - contextPath: Umbrella.Timeline.URL
      description: URL value
      type: string
    - contextPath: Umbrella.Timeline.Data.MalwareCategories
      description: Which Umbrella security category, if any, matched the input
      type: string
    - contextPath: Umbrella.Timeline.Data.Attacks
      description: Which named attacks, if any, matched the input
      type: string
    - contextPath: Umbrella.Timeline.Data.ThreatTypes
      description: Which threat type, if any, matched in the input.
      type: string
    - contextPath: Umbrella.Timeline.Data.Timestamp
      description: The time when the attribution for this URL changed.
      type: date
  runonce: false
  script: |2-




    ''' IMPORTS '''

    import sys
    import requests
    import json
    import time
    import re
    import urllib
    from urlparse import urlparse
    from distutils.util import strtobool
    from datetime import datetime, timedelta

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    API_TOKEN = demisto.params()['APIToken']
    BASE_URL = demisto.params()['baseURL']
    USE_SSL = not demisto.params().get('insecure', False)
    DEFAULT_HEADERS = {
        'Authorization': 'Bearer {}'.format(API_TOKEN),
        'Accept': 'application/json'
    }
    MALICIOUS_THRESHOLD = int(demisto.params().get('dboscore_threshold', -100))

    ''' MAPS '''

    # This object describe the result of the http request of getDomainSecurity function
    # each field has Name,Info & ContextKey  - thats just looks scarry
    SECURITY_RESULT_INFO = {
        'dga_score': {'Name': 'DGA', 'ContextKey': 'DGA',
                      'Info': 'Domain Generation Algorithm. This score is generated based on the likeliness of the domain '
                              'name being generated by an algorithm rather than a human. This algorithm is designed to '
                              'identify domains which have been created using an automated randomization strategy, '
                              'which is a common evasion technique in malware kits or botnets. This score ranges from '
                              '-100 (suspicious) to 0 (benign)'},
        'perplexity': {'Name': 'Perplexity',
                       'Info': 'A second score on the likeliness of the name to be algorithmically generated, on a scale '
                               'from 0 to 1. This score is to be used in conjunction with DGA'},
        'entropy': {'Name': 'Entropy',
                    'Info': 'The number of bits required to encode the domain name, as a score. This score is to be used '
                            'in conjunction with DGA and Perplexity'},
        'securerank2': {'Name': 'SecureRank',
                        'Info': 'Suspicious rank for a domain that reviews based on the lookup behavior of client IP for '
                                'the domain. Securerank is designed to identify hostnames requested by known infected '
                                'clients but never requested by clean clients, assuming these domains are more likely to '
                                'be bad. Scores returned range from -100 (suspicious) to 100 (benign)'},
        'pagerank': {'Name': 'PageRank', 'Info': 'Popularity according to Google\'s pagerank algorithm'},
        'asn_score': {'Name': 'ASN Score', 'ContextKey': 'ASNScore',
                      'Info': 'ASN reputation score, ranges from -100 to 0 with -100 being very suspicious'},
        'prefix_score': {'Name': 'Prefix Score', 'ContextKey': 'PrefixScore',
                         'Info': 'Prefix ranks domains given their IP prefixes (an IP prefix is the first three octets in '
                                 'an IP address) and the reputation score of these prefixes. Ranges from -100 to 0, '
                                 '-100 being very suspicious'},
        'rip_score': {'Name': 'RIP Score', 'ContextKey': 'RIPScore',
                      'Info': 'RIP ranks domains given their IP addresses and the reputation score of these IP addresses. '
                              'Ranges from -100 to 0, -100 being very suspicious'},
        'popularity': {'Name': 'Popularity',
                       'Info': 'The number of unique client IPs visiting this site, relative to the all requests to all '
                               'sites. A score of how many different client/unique IPs go to this domain compared to '
                               'others'},
        'geoscore': {'Name': 'GeoScore',
                     'Info': 'A score that represents how far the different physical locations serving this name are from '
                             'each other'},
        'ks_test': {'Name': 'Kolmogorov-Smirnov Test', 'ContextKey': 'KolmogorovSmirnovTest',
                    'Info': "Kolmogorov-Smirnov test on geodiversity. 0 means that the client traffic matches what is "
                            "expected for this TLD"},
        'attack': {'Name': 'Attack Name', 'ContextKey': 'AttackName',
                   'Info': 'The name of any known attacks associated with this domain. Returns blank if no known threat '
                           'associated with domain'},
        'threat_type': {'Name': 'Threat Type', 'ContextKey': 'ThreatType',
                        'Info': 'The type of the known attack, such as botnet or APT. Returns blank if no known threat '
                                'associated with domain'}
    }

    # used to describe result on getDomainDNSHistory function
    IP_DNS_FEATURE_INFO = {
        'rr_count': 'Number of records of that type mapping to the given IP',
        'ld2_count': 'Number of 2-level names mapping to the given IP',
        'ld3_count': 'Number of 3-level names mapping to the given IP',
        'ld2_1_count': 'Number of 2-level names, without the TLD, mapping to the given IP',
        'ld2_2_count': 'Number of 3-level names, without the TLD, mapping to a given IP',
        'div_ld2': 'ld2_count divided by the number of records',
        'div_ld3': 'ld3_count divided by the number of records',
        'div_ld2_1': 'ld2_1_count divided by the number of records',
        'div_ld2_2': 'ld2_2_count divided by the number of record'
    }

    ''' HELPER FUNCTIONS '''


    def extract_domain_name(url):
        return url.split("//")[-1].split("/")[0]


    def http_request(api_endpoint, params_dict=None, method='GET', data_list=None):
        req_params = {}  # type: dict
        # request does not accept lists, only string/dict
        if data_list and isinstance(data_list, list):
            data_list = json.dumps(data_list)
        if params_dict:
            req_params.update(params_dict)
        url = BASE_URL + api_endpoint
        LOG('running %s request with url=%s\tparams=%s\tdata=%s' % (method, url, json.dumps(req_params), data_list))
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=req_params,
                headers=DEFAULT_HEADERS,
                data=data_list
            )

            res.raise_for_status()
            return res.json()

        except Exception, e:
            LOG(e)
            raise


    def format_string_to_table_header_format(string):
        # example: "one_two" to "One Two"
        if type(string) in STRING_TYPES:
            return " ".join(word.capitalize() for word in string.replace("_", " ").split())
        else:
            return_error('The key is not a string: {}'.format(string))


    def format_string_to_context_key_format(string):
        # example: "one_two" to "OneTwo"
        if type(string) in STRING_TYPES:
            return "".join(word.capitalize() for word in string.split('_'))
        else:
            return_error('The key is not a string: {}'.format(string))


    def date_to_timestamp_func(date):
        # this helper function tries to parse a date time string according to a specific format
        # if it fails, it will just output the original value
        try:
            ts = datetime.strptime(date[0:16], '%Y-%m-%dT%H:%M')
        except ValueError:
            pass
        else:
            if date[19] == '+':
                ts += timedelta(hours=int(date[20:22]), minutes=int(date[22:24]))
            elif date[19] == '-':
                ts -= timedelta(hours=int(date[20:22]), minutes=int(date[22:24]))
            ts = time.mktime(ts.timetuple())  # type: ignore
            return str(int(ts) * 1000)  # type: ignore
        return date


    def timestamp_to_date(ts):
        if ts:
            # Gets a timestamp (either str or int, either in seconds or milliseconds) and converts it to a date.
            ts = str(ts)
            if len(ts) > 10:
                ts = ts[:10]
            ts = int(ts)
            return datetime.utcfromtimestamp(ts).strftime('%Y-%m-%dT%H:%M:%S')
        return ts


    def securerank_to_dbotscore(sr):
        # converts cisco umbrella score to dbotscore
        DBotScore = 0
        if sr > 0 and sr <= 100:
            DBotScore = 1
        elif sr < 0 and sr > MALICIOUS_THRESHOLD:
            DBotScore = 2
        elif sr <= MALICIOUS_THRESHOLD:
            DBotScore = 3
        return DBotScore


    ''' INTERNAL FUNCTIONS '''


    def get_co_occurences(domain):
        # Build & Send request
        endpoint_url = '/recommendations/name/' + domain + '.json'
        res_co_occurences = http_request(endpoint_url)

        # Assign and validate response
        co_occurences = res_co_occurences.get('pfs2', [])
        if not res_co_occurences['found'] or not co_occurences:
            return False
        table_co_occurences = []

        for co_occurence in co_occurences:
            table_co_occurences.append({
                'Name': co_occurence[0],
                'Score': co_occurence[1]
            })

        return table_co_occurences


    def get_domains_categorization(domains):
        # Build & Send request
        endpoint_url = '/domains/categorization?showLabels'
        res = http_request(endpoint_url, None, 'POST', domains)
        # Validate response
        if not res:
            return False
        return res


    ''' BUSINESS LOGIC / COMMANDS '''


    def get_domain_categorization_command():
        # Initialize
        contents = []  # type: ignore
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        # Fetch data
        categorization = get_domain_categorization(domain)
        if categorization:
            # Process response - build context and markdown table
            domain_context = {
                'Name': domain
            }

            contents = {  # type: ignore
                # Will be override in case result contains any
                'Content Categories': 'No Content Categories Were Found',
                'Malware Categories': 'No Security Categories Were Found'
            }

            if categorization:
                if categorization.get('status'):
                    contents['Status'] = categorization['status']  # type: ignore
            if categorization.get('content_categories'):
                content_categories = ",".join(categorization['content_categories'])
                contents['Content Categories'] = content_categories  # type: ignore
                domain_context['ContentCategories'] = content_categories
            if categorization.get('security_categories'):
                security_categories = ",".join(categorization['security_categories'])
                contents['Malware Categories'] = security_categories  # type: ignore
                domain_context['SecurityCategories'] = security_categories
            if categorization['status'] == -1:
                domain_context['Malicious'] = {
                    'Vendor': 'Cisco Umbrella Investigate',
                    'Description': security_categories
                }

            context[outputPaths['domain']] = domain_context

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Categorization:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_categorization(domain):
        # Build & Send request
        endpoint_url = '/domains/categorization/' + domain + '?showLabels'
        res = http_request(endpoint_url)

        # Validate and assign response
        categorization = res.get(domain, [])
        if not categorization:
            return False
        return categorization


    def get_domain_search_command():
        # Initialize
        contents = []  # type: ignore
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        regex = demisto.args()['regex']
        start = demisto.args().get('start', '')
        limit = int(demisto.args().get('limit'))
        # Fetch data
        matches = get_domain_search(regex, start)
        if matches:
            # Process response - build context and markdown table
            if limit:
                matches = matches[:limit]
            contents = matches[:]
            for index, row in enumerate(contents):
                contents[index] = {
                    'Name': row['name'],
                    'First Seen': row['firstSeenISO'],
                    'Security Categories': ",".join(row['securityCategories'])
                }

            domain_context = []
            for match in matches:
                security_categories_str = ",".join(match['securityCategories'])
                domain = {
                    'Name': match['name'],
                    'SecurityCategories': security_categories_str if security_categories_str else None,
                    'FirstSeen': match['firstSeen'],
                    'FirstSeenISO': match['firstSeenISO'],
                    'FirstSeean': match['firstSeen'],
                    'FirstSeeanISO': match['firstSeenISO']
                }
                if 'Malware' in security_categories_str:
                    domain['Malicious'] = {
                        'Vendor': 'Cisco Umbrella Investigate',
                        'Description': 'Tagged as malware'
                    }
                domain_context.append(domain)

            context[outputPaths['domain']] = domain_context

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Search Results:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_search(regex, start):
        # Build & Send request
        matches = {}  # type: ignore
        start = "".join(start.split()) if start else '-31days'
        endpoint_url = '/search/' + regex
        params = {
            'start': start,
            'includecategory': 'true'
        }
        res = http_request(endpoint_url, params)

        # Validate and assign response
        matches = res.get('matches')
        if not matches or not isinstance(matches, list):
            return False
        return matches


    def get_domain_co_occurrences_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        # Fetch data
        occurrences = get_domain_co_occurrences(domain)
        if occurrences:
            # Process response - build context and markdown table
            for occurrence in occurrences:
                contents.append({
                    'Name': occurrence[0],
                    'Score': occurrence[1]
                })

            if contents:
                context[outputPaths['domain']] = {
                    'Name': domain,
                    'CoOccurrences': contents
                }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Co-occurrences:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_co_occurrences(domain):
        # Build & Send request
        endpoint_url = '/recommendations/name/' + domain + '.json'
        res = http_request(endpoint_url)

        # Validate and assign response
        occurrences = res.get('pfs2')
        if not isinstance(occurrences, list) or not occurrences:
            return False
        return occurrences


    def get_domain_related_command():
        # Initialize
        contents = []
        context = {}  # type: ignore
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        # Fetch data
        related_list = get_domain_related(domain)
        if related_list:
            # Process response - build context and markdown table
            for related in related_list:
                contents.append({
                    'Name': related[0],
                    'Score': related[1]
                })

            context = {}
            if contents:
                context[outputPaths['domain']] = {
                    'Name': domain,
                    'Related': contents
                }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Related Domains:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_related(domain):
        # Build & Send request
        endpoint_url = '/links/name/' + domain + '.json'
        res = http_request(endpoint_url)

        # Validate and assign response
        related_list = res.get('tb1', [])
        if not isinstance(related_list, list) or not related_list:
            return False
        return related_list


    def get_domain_security_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        threshold = int(demisto.args().get('threshold', MALICIOUS_THRESHOLD))
        # Fetch data
        res = get_domain_security(domain)
        if res:
            # Process response - build context and markdown table
            # each key in SECURITY_RESULT_INFO corrispond to a key in 'res'
            # we get the score from 'res' & add Name & Info from SECURITY_RESULT_INFO
            for key in SECURITY_RESULT_INFO:
                info = SECURITY_RESULT_INFO[key]
                contents.append({
                    'Name': info['Name'],
                    'Score': res[key],
                    'Info': info['Info']
                })

            domain_security_context = {}

            for key in SECURITY_RESULT_INFO:
                context_key = SECURITY_RESULT_INFO[key].get('ContextKey', format_string_to_context_key_format(
                    SECURITY_RESULT_INFO[key]['Name']))
                domain_security_context[context_key] = res[key]

            if domain_security_context:
                secure_rank = res.get('securerank2', False)
                DBotScore = 0
                if secure_rank:
                    if secure_rank < threshold:
                        DBotScore = 3
                    else:
                        DBotScore = securerank_to_dbotscore(secure_rank)
                    context[outputPaths['dbotscore']] = {
                        'Indicator': domain,
                        'Type': 'domain',
                        'Vendor': 'Cisco Umbrella Investigate',
                        'Score': DBotScore
                    }

                context[outputPaths['domain']] = {
                    'Name': domain,
                    'Security': domain_security_context
                }

                if DBotScore == 3:
                    context[outputPaths['domain']]['Malicious'] = {
                        'Vendor': 'Cisco Umbrella Investigate',
                        'Description': 'Malicious domain found via umbrella-domain-security'
                    }
        else:
            context[outputPaths['dbotscore']] = {
                'Indicator': domain,
                'Type': 'domain',
                'Vendor': 'Cisco Umbrella Investigate',
                'Score': 0
            }
        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Domain Security Info:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_security(domain):
        # Build & Send request
        endpoint_url = '/security/name/' + domain + '.json'
        res = http_request(endpoint_url)

        # Validate and assign response
        if not res or res.get('errorMessage'):
            return False
        return res


    def get_domain_dns_history_command():
        # Initialize
        contents = {}  # type: ignore
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        # Fetch data
        features = get_domain_dns_history(domain)
        if features:
            # Process response - build context and markdown table
            dns_history_context = {}

            for feature in features:
                table_key = format_string_to_table_header_format(feature)
                context_key = format_string_to_context_key_format(feature)
                value = features.get(feature, '')
                dns_history_context[context_key] = value
                if feature in ('locations'):
                    contents[table_key] = []
                    for location in features[feature]:
                        contents[table_key].append("[ " + str(location['lat']) + ", " + str(location['lon']) + " ]")
                    contents[table_key] = ','.join(contents[table_key])
                else:
                    if isinstance(value, list):
                        contents[table_key] = ','.join(str(item) for item in value)
                    elif value:
                        contents[table_key] = value

            context[outputPaths['domain']] = {
                'Name': domain,
                'DNSHistory': dns_history_context
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('DNS History:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_dns_history(domain):
        # this command return 2 entries - but the context update is done with the 2nd entry
        # Build & Send request
        endpoint_url = '/dnsdb/name/a/' + domain + '.json'
        res = http_request(endpoint_url)

        # Validate and assign response
        features = res.get('features', {})
        if not features or not features.viewkeys() > {"base_domain", "is_subdomain"}:
            return False
        # this is the actual path for ip address
        address = res.get('rrs_tf')[0].get('rrs')[0].get('rr')
        features['ip'] = address
        return features


    def get_ip_dns_history_command():
        # Initialize
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        ip = demisto.args()['ip']
        limit = int(demisto.args().get('limit'))
        # Fetch data
        response_object = get_ip_dns_history(ip)
        if response_object:
            response = response_object['response']
            features = response_object['features']
            # Process response - build context and markdown table
            response_contents = []
            if limit:
                response = response[:limit]
            for item in response:
                response_contents.append({
                    'RR': item['rr'],
                    'TTL': item['ttl'],
                    'Class': item['class'],
                    'Type': item['type'],
                    'Name': item['name']
                })

            features_contents = {}
            features_context = {}
            for key in IP_DNS_FEATURE_INFO:
                # table_key = format_string_to_table_header_format(key)
                features_contents[IP_DNS_FEATURE_INFO[key]] = features[key]
                context_key = format_string_to_context_key_format(key)
                features_context[context_key] = features[key]

            context[outputPaths['ip']] = {
                'Address': ip,
                'DNSHistory': {
                    'RRS': response_contents,
                    'Features': features_context
                }
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': [response_contents, features_contents],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('RRS:', response_contents, headers) + tableToMarkdown('Features:',
                                                                                                   features_contents,
                                                                                                   headers),
            'EntryContext': context
        })

        return results


    def get_ip_dns_history(ip):
        # Build & Send request
        endpoint_url = '/dnsdb/ip/a/' + ip + '.json'
        res = http_request(endpoint_url)

        # Validate and assign response
        features = res.get('features', [])
        response = res.get('rrs', [])
        if not features or not response:
            return False
        return {'features': features, 'response': response}


    def get_ip_malicious_domains_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        context_dbotscore = []
        # Get vars
        ip = demisto.args()['ip']
        # Fetch data
        res = get_ip_malicious_domains(ip)
        if res:
            # Process response - build context and markdown table
            for domain in res:
                contents.append({
                    'Name': domain['name'],
                    'Malicious': {
                        'Vendor': 'Cisco Umbrella Investigate',
                        'Description': 'For IP ' + ip
                    }
                })
                context_dbotscore.append({
                    'Indicator': domain['name'],
                    'Type': 'domain',
                    'Vendor': 'Cisco Umbrella Investigate',
                    'Score': 3
                })

            if contents:
                context[outputPaths['domain']] = contents
                context[outputPaths['dbotscore']] = context_dbotscore

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Malicious Domains:', contents, headers),
            'EntryContext': context
        })

        return results


    def get_ip_malicious_domains(ip):
        # Build & Send request
        endpoint_url = '/ips/' + ip + '/latest_domains'
        res = http_request(endpoint_url)

        # Validate and assign response
        if not res:
            return False
        return res


    def get_domain_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []

        domain = extract_domain_name(demisto.args()['domain'])

        whois = get_whois_for_domain(domain)
        admin = {
            'Country': whois.get('administrativeContactCountry'),
            'Email': whois.get('administrativeContactEmail'),
            'Name': whois.get('administrativeContactName'),
            'Phone': whois.get('administrativeContactTelephone')
        }
        registrant = {
            'Country': whois.get('registrantCountry'),
            'Email': whois.get('registrantEmail'),
            'Name': whois.get('registrantName'),
            'Phone': whois.get('registrantTelephone')
        }
        first_queried = whois.get('created')
        name_servers = whois.get('nameServers')
        emails = whois.get('emails')
        registrar = {'Name': whois.get('registrarName')}
        creation_date = first_queried
        domain_status = whois.get('status')
        updated_date = whois.get('updated')
        expiration_date = whois.get('expires')

        whois = {
            'Name': whois.get('domainName'),
            'Registrar Name': whois.get('registrarName'),
            'Last Retrieved': timestamp_to_date(whois.get('timeOfLatestRealtimeCheck')),
            'Created': whois.get('created'),
            'Updated': whois.get('updated'),
            'Expires': whois.get('expires'),
            'IANAID': whois.get('registrarIANAID'),
            'Last Observed': whois.get('auditUpdatedDate')
        }

        domain_categorization = []  # type: ignore
        domain_categorization = get_domain_categorization(domain)
        content_categories = domain_categorization.get('content_categories')  # type: ignore
        malware_categories = domain_categorization.get('security_categories')  # type: ignore
        risk_score = domain_categorization.get('status')  # type: ignore
        domain_categorization_table = {
            'Content Categories': content_categories,
            'Malware Categories': malware_categories
        }

        domain_details = []  # type: ignore
        domain_details = get_domain_details(domain)
        popularity = domain_details.get('popularity')  # type: ignore
        secure_rank = domain_details.get('securerank2')  # type: ignore
        dbotscore = securerank_to_dbotscore(secure_rank)

        context[outputPaths['domain']] = {
            'Name': domain,
            'Admin': admin,
            'Registrant': registrant,
            'Registrar': registrar,
            'CreationDate': creation_date,
            'DomainStatus': domain_status,
            'UpdatedDate': updated_date,
            'ExpirationDate': expiration_date,
            'Umbrella': {
                'RiskScore': risk_score,
                'SecureRank': secure_rank,
                'FirstQueriedTime': first_queried,
                'ContentCategories': content_categories,
                'MalwareCategories': malware_categories
            }
        }

        # Add malicious if needed
        if risk_score == -1 or secure_rank < MALICIOUS_THRESHOLD:
            context[outputPaths['domain']]['Malicious'] = {
                'Vendor': 'Cisco Umbrella Investigate',
                'Description': 'Malicious domain found with risk score -1'
            }
            dbotscore = 3

        context[outputPaths['dbotscore']] = {
            'Indicator': domain,
            'Type': 'domain',
            'Vendor': 'Cisco Umbrella Investigate',
            'Score': dbotscore
        }

        contents.append({
            'Risk Score': risk_score,
            'Secure Rank': secure_rank,
            'Populairty': popularity,
            'Demisto Reputation': scoreToReputation(dbotscore),
            'First Queried time': first_queried,
        })

        # Domain reputation + [whois -> whois nameservers -> whois emails] + domain categorization
        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': [contents, whois, name_servers, emails, domain_categorization_table],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Domain Reputation for: ' + domain, contents,
                                             headers) + tableToMarkdown(
                '"Umbrella Investigate" WHOIS Record Data for: ' + domain, whois, headers) + tableToMarkdown(
                'Name Servers:', {'Name Servers': name_servers}, headers) + tableToMarkdown('Emails:', {'Emails': emails},
                                                                                            headers) + tableToMarkdown(
                'Domain Categorization:', domain_categorization_table, headers),
            'EntryContext': context
        })

        return results


    def get_related_domains_command():
        # Initialize
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        is_co_occurences = bool(strtobool(demisto.args().get('coOccurences', False)))
        domain = extract_domain_name(demisto.args()['domain'])
        # Fetch data
        related_domains = get_related_domains(domain, is_co_occurences)
        contents_related_domains = []
        contents_co_occurences = {}  # type: ignore
        co_occurences_md = ''
        if related_domains:
            # Process response - build context and markdown table
            for related_domain in related_domains:
                contents_related_domains.append({
                    'Name': related_domain[0],
                    'Score': related_domain[1]
                })

            if related_domains:
                context['Umbrella.RelatedDomains(val.Domain && val.Domain == obj.Domain)'] = {
                    'Data': contents_related_domains,
                    'Domain': domain
                }

            # Create another request in case co_occurences flag is raised, add the results with the main request
            if is_co_occurences:
                contents_co_occurences = get_co_occurences(domain)
                if contents_co_occurences:
                    co_occurences_md = tableToMarkdown('"Umbrella Investigate" Domain Co-occurences for: ' + domain,
                                                       contents_co_occurences, headers)
                    if related_domains:
                        context['Umbrella.CoOccurences(val.Domain && val.Domain == obj.Domain)'] = {
                            'Domain': domain,
                            'Data': contents_co_occurences
                        }
                    else:
                        context['Umbrella.CoOccurences(val.Domain && val.Domain == obj.Domain)'] = {
                            'Data': contents_co_occurences,
                            'Domain': domain
                        }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': [contents_related_domains, contents_co_occurences],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Related Domains for a Domain: ',
                                             contents_related_domains, headers) + co_occurences_md,
            'EntryContext': context
        })

        return results


    def get_related_domains(domain, is_co_occurences):
        # Main Request
        # Build & Send request
        endpoint_url = '/links/name/' + domain + '.json'
        res_related_domains = http_request(endpoint_url)

        # Assign and validate response
        related_domains = res_related_domains.get('tb1', [])
        if not related_domains:
            return False
        return related_domains


    def get_domain_classifiers_command():
        # Initialize
        contents = {}
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        # Fetch data
        res = get_domain_classifiers(domain)
        if res:
            # Process response - build context and markdown table
            security_categories = res.get('securityCategories', [])
            attacks = res.get('attacks', [])
            threat_types = res.get('threatTypes', [])
            contents['Security Categories'] = security_categories
            contents['Attacks'] = attacks
            contents['Threat Types'] = threat_types

            if contents:
                context['Umbrella.DomainClassifiers(val.Domain && val.Domain == obj.Domain)'] = {
                    'Data': {
                        'MalwareCategories': security_categories,
                        'Attacks': attacks,
                        'ThreatTypes': threat_types
                    },
                    'Domain': domain
                }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Domain Classifiers: ' + domain, contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_classifiers(domain):
        # Build & Send request
        endpoint_url = '/url/' + domain + '/classifiers'
        res = http_request(endpoint_url)

        # Assign and validate response
        if not res['securityCategories'] and not res['attacks'] and not res['threatTypes']:
            return False
        return res


    def get_domain_query_volume_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        queries_context = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        start_date_string = demisto.args()['start']
        stop_date_string = demisto.args()['stop']
        match = demisto.args()['match']
        limit = int(demisto.args().get('limit'))

        # validation and user input conversion
        if match != 'all' and match != 'exact' and match != 'component':
            return_error('Not a valid type. Valid options are all, exact, or component.')

        # Fetch data
        response_object = get_domain_query_volume(domain, start_date_string, stop_date_string, match)
        if response_object:
            dates = response_object.get('dates')
            queries = response_object.get('queries')

            # Process response - build context and markdown table
            start_date = dates[0]
            stop_date = dates[1]
            # Query timestamp/hour needs to be calculated manually, every entry represents 1 hour (3600 secods). ts is in
            # milliseconds
            query_ts = start_date / 1000
            if limit:
                queries = queries[:limit]
            for query in queries:
                contents.append({
                    'Queries': query,
                    'Query Hour': timestamp_to_date(query_ts)
                })
                queries_context.append({
                    'Queries': query,
                    'QueryHour': timestamp_to_date(query_ts)
                })
                query_ts = query_ts + 3600

            context['Umbrella.QueryVolume(val.Domain && val.Domain == obj.Domain)'] = {
                'Domain': domain,
                'Data': {
                    'StartDate': timestamp_to_date(start_date),
                    'StopDate': timestamp_to_date(stop_date),
                    'QueriesInfo': queries_context
                }
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(
                '"Umbrella Investigate" Domain Volume: ' + domain + '\nStart Date ' + timestamp_to_date(
                    start_date) + ' - Stop Date ' + timestamp_to_date(stop_date), contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_query_volume(domain, start_date_string, stop_date_string, match):
        # user input conversion
        start_ts = date_to_timestamp_func(start_date_string)
        stop_ts = date_to_timestamp_func(stop_date_string)

        # Build & Send request
        params = {
            'start': start_ts,
            'stop': stop_ts,
            'match': match
        }
        endpoint_url = '/domains/volume/' + domain
        res = http_request(endpoint_url, params)

        # Assign and validate response
        dates = res.get('dates', [])
        queries = res.get('queries', [])
        if not dates or not queries:
            return False
        return {'dates': dates, 'queries': queries}


    def get_domain_details_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        threshold = int(demisto.args().get('threshold', MALICIOUS_THRESHOLD))
        # Fetch data
        res = get_domain_details(domain)
        if res:
            # Process response - build context and markdown table
            # each key in SECURITY_RESULT_INFO corrispond to a key in 'res'
            # we get the score from 'res' & add Name & Info from SECURITY_RESULT_INFO
            for key in SECURITY_RESULT_INFO:
                info = SECURITY_RESULT_INFO[key]
                contents.append({
                    'Score': res[key],
                    'Name': info['Name'],
                    'Info': info['Info']
                })

            domain_security_context = {}

            for key in SECURITY_RESULT_INFO:
                context_key = SECURITY_RESULT_INFO[key].get('ContextKey', format_string_to_context_key_format(
                    SECURITY_RESULT_INFO[key]['Name']))
                domain_security_context[context_key] = res[key]

            if domain_security_context:
                context['Umbrella.DomainDetails(val.Domain && val.Domain == obj.Domain)'] = {
                    'Domain': domain,
                    'Data': domain_security_context
                }
                secure_rank = res.get('securerank2', False)
                if secure_rank:
                    if secure_rank < threshold:
                        dbotscore = 3
                    else:
                        dbotscore = securerank_to_dbotscore(secure_rank)
                    context[outputPaths['dbotscore']] = {
                        'Indicator': domain,
                        'Type': 'domain',
                        'Vendor': 'Cisco Umbrella Investigate',
                        'Score': dbotscore
                    }
                    if dbotscore == 3:
                        context[outputPaths['domain']] = {}
                        context[outputPaths['domain']]['Malicious'] = {
                            'Vendor': 'Cisco Umbrella Investigate',
                            'Description': 'Malicious domain found via get-domain-details'
                        }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Domain Reputation: ' + domain, contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_details(domain):
        # Build & Send request
        endpoint_url = '/security/name/' + domain
        res = http_request(endpoint_url)

        # Assign and validate response
        if not res:
            return False
        return res


    def get_domains_for_email_registrar_command():
        # Initialize
        contents = []  # type: ignore
        context = {}
        headers = []  # type: ignore
        results = []
        markdown = ''
        # Get vars
        emails = argToList(demisto.args()['emails'])
        offset = demisto.args().get('offset', '')
        sort = demisto.args().get('sort', '')
        limit = demisto.args().get('limit', '')
        # user input validation
        if not isinstance(emails, list):
            return_error('Emails list is not formatted correctly, please try again.')
        if sort:
            if sort != 'created' and sort != 'updated':
                return_error('The parameter sort accept only these values: created/updated/expired.')
        for email in emails:
            if re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', email) is None:
                return_error('The provided email is not valid: ' + email)
        # Fetch data
        res = get_domains_for_email_registrar(emails, offset, sort, limit)
        if res:
            # Process response - build context and markdown table
            domains = []  # type: ignore
            for email in emails:
                domains_contents = []
                emails_contents = []  # type: ignore
                domains_list = []
                emails_context = []
                # get the entry that matches the provided emails each time
                email_res = res[email]
                domains = email_res.get('domains', [])
                if not email_res or not domains:
                    continue

                # going over all the domains associated with this email, making POST request to get each categorization
                for domain in domains:
                    domains_list.append(domain['domain'])
                domains_info = get_domains_categorization(domains_list)
                if domains_info:
                    for domain in domains:
                        domains_contents.append({
                            'Name': domain['domain'],
                            'Security Categories': domains_info[domain['domain']]['security_categories'],
                            'Content Categories': domains_info[domain['domain']]['content_categories'],
                            'Is Current': domain['current']
                        })

                # each email has its own data + associated domains attached
                emails_context.append({
                    'TotalResults': email_res['totalResults'],
                    'MoreDataAvailable': email_res['moreDataAvailable'],
                    'ResultLimit': email_res['limit'],
                    'Domains': domains_contents
                })
                # each email represented by 2 tables
                # Build Output
                markdown = markdown + tableToMarkdown('Domains Associated with: ' + email, domains_contents, headers)
                contents.extend((emails_contents, domains_contents))

            context['Umbrella.AssociatedDomains(val.Email && val.Email == obj.Email)'] = {
                'Email': email,
                'Data': emails_context
            }

        if not markdown:
            markdown = tableToMarkdown('Domains Associated with: ' + email, domains_contents, headers)

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': markdown,
            'EntryContext': context
        })

        return results


    def get_domains_for_email_registrar(emails, offset, sort, limit):
        # Build & Send request
        params = {}  # type: ignore
        # single email has different api call over multiple emails
        if len(emails) == 1:
            endpoint_url = '/whois/emails/' + emails[0]
            if sort or limit or offset:
                params = {
                    'sortField': sort,
                    'limit': limit,
                    'offset': offset
                }

        elif len(emails) > 1:
            emails_string = ','.join(emails)
            endpoint_url = '/whois/emails'
            if sort or limit or offset:
                params = {
                    'emailList': emails_string,
                    'sortField': sort,
                    'limit': limit,
                    'offset': offset
                }
            else:
                params = {
                    'emailList': emails_string,
                }

        res = http_request(endpoint_url, params)
        if not res:
            return False
        return res


    def get_domains_for_nameserver_command():
        # Initialize
        contents = []  # type: ignore
        context = {}
        headers = []  # type: ignore
        results = []
        markdown = ''
        # Get vars
        nameservers = argToList(demisto.args()['nameservers'])
        offset = demisto.args().get('offset', '')
        sort = demisto.args().get('sort', '')
        limit = demisto.args().get('limit', '')
        # user input validation
        if not isinstance(nameservers, list):
            return_error('Name Servers list is not formatted correctly, please try again.')
        if sort:
            if sort != 'created' and sort != 'updated':
                return_error('The parameter sort accept only these values: created/updated')
        for nameserver in nameservers:
            if re.match('^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$',
                        nameserver) is None:
                return_error('The provided name server is not valid: ' + nameserver)
        # Fetch data
        res = get_domains_for_nameserver(nameservers, offset, sort, limit)
        if res:
            # Process response - build context and markdown table
            domains = []  # type: ignore
            for nameserver in nameservers:
                domains_contents = []
                nameservers_contents = []  # type: ignore
                domains_list = []
                nameservers_context = []
                # get the entry that matches the provided nameservers each time
                nameserver_res = res[nameserver]
                domains = nameserver_res.get('domains', [])
                if not nameserver_res or not domains:
                    continue

                # going over the domains associated with this nameserver, making POST request to get each categorization
                for domain in domains:
                    domains_list.append(domain['domain'])
                domains_info = get_domains_categorization(domains_list)
                if domains_info:
                    for domain in domains:
                        domains_contents.append({
                            'Name': domain['domain'],
                            'Security Categories': domains_info[domain['domain']]['security_categories'],
                            'Content Categories': domains_info[domain['domain']]['content_categories'],
                            'Is Current': domain['current']
                        })

                # each nameserver has its own data + associated domains attached
                nameservers_context.append({
                    'TotalResults': nameserver_res['totalResults'],
                    'MoreDataAvailable': nameserver_res['moreDataAvailable'],
                    'ResultLimit': nameserver_res['limit'],
                    'Domains': domains_contents
                })
                # each nameserver represented by 2 tables
                # Build Output
                markdown = markdown + tableToMarkdown('Domains Associated with: ' + nameserver, domains_contents, headers)
                contents.extend((nameservers_contents, domains_contents))

            context['Umbrella.AssociatedDomains(val.Nameserver && val.Nameserver == obj.Nameserver)'] = {
                'Nameserver': nameserver,
                'Data': nameservers_context
            }

        if not markdown:
            markdown = tableToMarkdown('Domains Associated with: ' + nameserver, domains_contents, headers)

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': markdown,
            'EntryContext': context
        })

        return results


    def get_domains_for_nameserver(nameservers, offset, sort, limit):
        # Build & Send request
        params = {}  # type: ignore
        # single name server has different api call over multiple name servers
        if len(nameservers) == 1:
            endpoint_url = '/whois/nameservers/' + nameservers[0]
            if sort or limit or offset:
                params = {
                    'sortField': sort,
                    'limit': limit,
                    'offset': offset
                }
        elif len(nameservers) > 1:
            nameservers_string = ','.join(nameservers)
            endpoint_url = '/whois/nameservers'
            if sort or limit or offset:
                params = {
                    'nameServerList': nameservers_string,
                    'sortField': sort,
                    'limit': limit,
                    'offset': offset
                }
            else:
                params = {
                    'nameServerList': nameservers_string,
                }

        res = http_request(endpoint_url, params)
        if not res:
            return False
        return res


    def get_whois_for_domain_command():
        # Initialize
        context = {}
        headers = []  # type: ignore
        results = []
        contents_nameserver = {}  # type: ignore
        contents_email = {}  # type: ignore

        original_domain = demisto.args()['domain']
        domain = extract_domain_name(original_domain)

        res = get_whois_for_domain(domain)
        if res:
            # Process response - build context and markdown table
            nameservers = res.get('nameServers')
            emails = res.get('emails')
            whois = {
                'Name': res.get('domainName'),
                'RegistrarName': res.get('registrarName'),
                'LastRetrieved': res.get('timeOfLatestRealtimeCheck'),
                'Created': res.get('created'),
                'Updated': res.get('updated'),
                'Expires': res.get('expires'),
                'IANAID': res.get('registrarIANAID'),
                'LastObserved': res.get('auditUpdatedDate')
            }

            table_whois = {
                'Name': whois.get('Name'),
                'Registrar Name': whois.get('RegistrarName'),
                'Last Retrieved': timestamp_to_date(whois.get('LastRetrieved')),
                'Created': whois.get('Created'),
                'Updated': whois.get('Updated'),
                'Expires': whois.get('Expires'),
                'IANAID': whois.get('IANAID'),
                'Last Observed': whois.get('LastObserved')
            }

            admin = {
                'Country': res.get('administrativeContactCountry', ),
                'Email': res.get('administrativeContactEmail', ),
                'Name': res.get('administrativeContactName'),
                'Phone': res.get('administrativeContactTelephone')
            }
            registrant = {
                'Country': res.get('registrantCountry'),
                'Email': res.get('registrantEmail'),
                'Name': res.get('registrantName'),
                'Phone': res.get('registrantTelephone'),
            }
            creation_date = res.get('created')
            registrar = {'Name': res.get('registrarName')}
            domain_status = res.get('status')
            updated_date = res.get('updated')
            expiration_date = res.get('expires')

            context[outputPaths['domain']] = {
                'Name': domain,
                'Admin': admin,
                'Registrant': registrant,
                'Registrar': registrar,
                'CreationDate': creation_date,
                'DomainStatus': domain_status,
                'UpdatedDate': updated_date,
                'ExpirationDate': expiration_date,
            }

            contents_nameserver = {'Nameservers': nameservers}
            contents_email = {'Emails': emails}

            whois.update({
                'Nameservers': nameservers,
                'Emails': emails
            })
            context['Domain.Umbrella.Whois(val.Name && val.Name == obj.Name)'] = whois

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': [table_whois, contents_nameserver, contents_email],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" WHOIS Record Data for: ' + whois['Name'], table_whois,
                                             headers) + tableToMarkdown('Nameservers: ', contents_nameserver,
                                                                        headers) + tableToMarkdown('Email Addresses: ',
                                                                                                   contents_email, headers),
            'EntryContext': context
        })

        return results


    def get_whois_for_domain(domain):
        # Build & Send request
        endpoint_url = '/whois/' + domain
        res = http_request(endpoint_url)

        # Assign and validate response
        if not res or res.get('errorMessage'):
            return False
        return res


    def get_malicious_domains_for_ip_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        context_dbotscore = []
        context_malicious = []
        # Get vars
        ip = demisto.args()['ip']
        # Fetch data
        res = get_malicious_domains_for_ip(ip)
        if res:
            # Process response - build context and markdown table
            domains = []
            for item in res:
                domains.append(item['name'])
            domains = get_domains_categorization(domains)
            domains_context = []
            if domains:
                for domain in domains:
                    domains_context.append({
                        'Name': domain,
                        'MalwareCategories': domains[domain]['security_categories'],
                        'ContentCategories': domains[domain]['content_categories']
                    })
                    contents.append({
                        'Name': domain,
                        'Malware Categories': domains[domain]['security_categories'],
                        'Content Categories': domains[domain]['content_categories']
                    })
                    context_dbotscore.append({
                        'Indicator': domain,
                        'Type': 'domain',
                        'Vendor': 'Cisco Umbrella Investigate',
                        'Score': 3
                    })
                    context_malicious.append({
                        'Name': domain,
                        'Malicious': {
                            'Vendor': 'Cisco Umbrella Investigate',
                            'Description': 'For IP ' + ip
                        }
                    })

            context['Umbrella.MaliciousDomains(val.IP && val.IP == obj.IP)'] = {
                'IP': ip,
                'Data': domains_context
            }
            context[outputPaths['domain']] = context_malicious  # type: ignore
            context[outputPaths['dbotscore']] = context_dbotscore  # type: ignore

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Malicious Domains for an IP: ' + ip, contents,
                                             headers),
            'EntryContext': context
        })

        return results


    def get_malicious_domains_for_ip(ip):
        # Build & Send request
        endpoint_url = '/ips/' + ip + '/latest_domains'
        res = http_request(endpoint_url)
        # Assign and validate response
        if not res:
            return False
        return res


    def get_domain_using_regex_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        title_contents = []  # type: ignore
        # Get vars
        regex = demisto.args()['expression']
        start = date_to_timestamp_func(demisto.args()['start'])
        stop = date_to_timestamp_func(demisto.args().get('stop'))
        is_include_category = bool(strtobool(demisto.args().get('includeCategory')))
        limit = demisto.args().get('limit')
        node_type = demisto.args().get('type')
        # Fetch data
        res = get_domain_using_regex(regex, start, is_include_category, stop, limit, node_type)
        if res:
            matches = res.get('matches', [])
            # Process response - build context and markdown table
            domain_context = []
            for match in matches:
                contents.append({
                    'Name': match['name'],
                    'First Seen': match['firstSeenISO'],
                    'Security Categories': match['securityCategories']
                })
                domain_context.append({
                    'Name': match['name'],
                    'FirstSeen': match['firstSeen'],
                    'SecurityCategories': match['securityCategories']
                })

            title_contents = [{
                'Total Results': res['totalResults'],
                'More Data Available': res['moreDataAvailable'],
                'Limit': res['limit']
            }]

            context['Umbrella.DomainSearch(val.Expression && val.Expression == obj.Expression)'] = {
                'Expression': res.get('expression', regex),
                'TotalResults': res.get('totalResults', None),
                'Data': domain_context
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': [title_contents, contents],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Domain Pattern Search for: ' + regex, title_contents,
                                             headers) + tableToMarkdown('Matches: ', contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_using_regex(regex, start, is_include_category, stop, limit, node_type):
        # Build params dict
        params = {
            'start': start,
            'includecategory': is_include_category,
            'stop': stop,
            'limit': limit,
            'type': node_type
        }

        # Build & Send request
        endpoint_url = '/search/' + regex
        res = http_request(endpoint_url, params)
        # Assign and validate response
        results = res.get('totalResults', 0)
        if not results:
            return False
        return res


    def get_domain_timeline_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        domain = extract_domain_name(demisto.args()['domain'])
        if re.match('[a-zA-Z\d-]{,63}(\.[a-zA-Z\d-]{,63})*', domain) is None:
            return_error('Domain is not valid')
        # Fetch data
        timeline = get_domain_timeline(domain)
        if timeline:
            # Process response - build context and markdown table
            timeline_context = []
            for item in timeline:
                contents.append({
                    'Malware Categories': item['categories'],
                    'Attacks': item['attacks'],
                    'Threat Types': item['threatTypes'],
                    'Timestamp': timestamp_to_date(item['timestamp']),
                })
                timeline_context.append({
                    'MalwareCategories': item['categories'],
                    'Attacks': item['attacks'],
                    'ThreatTypes': item['threatTypes'],
                    'Timestamp': timestamp_to_date(item['timestamp']),
                })

            context['Umbrella.Timeline(val.Domain && val.Domain == obj.Domain)'] = {
                'Domain': domain,
                'Data': timeline_context
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" Domain Timeline: ' + domain, contents, headers),
            'EntryContext': context
        })

        return results


    def get_domain_timeline(domain):
        # Build & Send request
        endpoint_url = '/timeline/' + domain
        timeline = http_request(endpoint_url)

        # Assign and validate response
        if not timeline:
            return False
        return timeline


    def get_ip_timeline_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        ip = demisto.args()['ip']
        is_valid = is_ip_valid(ip)
        if not is_valid:
            return_error('IP is not valid')
        # Fetch data
        timeline = get_ip_timeline(ip)
        if timeline:
            # Process response - build context and markdown table
            timeline_context = []
            for item in timeline:
                contents.append({
                    'Malware Categories': item['categories'],
                    'Attacks': item['attacks'],
                    'Threat Types': item['threatTypes'],
                    'Timestamp': timestamp_to_date(item['timestamp']),
                })
                timeline_context.append({
                    'MalwareCategories': item['categories'],
                    'Attacks': item['attacks'],
                    'ThreatTypes': item['threatTypes'],
                    'Timestamp': timestamp_to_date(item['timestamp']),
                })

            context['Umbrella.Timeline(val.IP && val.IP == obj.IP)'] = {
                'IP': ip,
                'Data': timeline_context
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" IP Timeline: ' + ip, contents, headers),
            'EntryContext': context
        })

        return results


    def get_ip_timeline(ip):
        # Build & Send request
        endpoint_url = '/timeline/' + ip
        timeline = http_request(endpoint_url)

        # Assign and validate response
        if not timeline:
            return False
        return timeline


    def get_url_timeline_command():
        # Initialize
        contents = []
        context = {}
        headers = []  # type: ignore
        results = []
        # Get vars
        url = demisto.args()['url']
        parsed_url = urlparse(url)
        if not bool(parsed_url.scheme) and not bool(parsed_url.netloc) and not bool(parsed_url.path):
            return_error('URL is not valid')
        # Fetch data
        timeline = get_url_timeline(url)
        if timeline:
            # Process response - build context and markdown table
            timeline_context = []
            for item in timeline:
                contents.append({
                    'Malware Categories': item['categories'],
                    'Attacks': item['attacks'],
                    'Threat Types': item['threatTypes'],
                    'Timestamp': timestamp_to_date(item['timestamp']),
                })
                timeline_context.append({
                    'MalwareCategories': item['categories'],
                    'Attacks': item['attacks'],
                    'ThreatTypes': item['threatTypes'],
                    'Timestamp': timestamp_to_date(item['timestamp']),
                })

            context['Umbrella.Timeline(val.URL && val.URL == obj.URL)'] = {
                'URL': url,
                'Data': timeline_context
            }

        results.append({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('"Umbrella Investigate" URL Timeline: ' + url, contents, headers),
            'EntryContext': context
        })

        return results


    def get_url_timeline(url):
        # percent encoding the url or else the API does not give response 200
        encoded_url = urllib.quote_plus(url.encode('utf-8'))

        # Build & Send request
        endpoint_url = '/timeline/' + encoded_url
        timeline = http_request(endpoint_url)

        # Assign and validate response
        if not timeline:
            return False
        return timeline


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('command is %s' % (demisto.command(),))
    try:
        handle_proxy()
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            http_request('/domains/categorization/google.com?showLabels')
            demisto.results('ok')
            sys.exit(0)
        elif demisto.command() == 'investigate-umbrella-domain-categorization' or demisto.command() == \
                'umbrella-domain-categorization':
            demisto.results(get_domain_categorization_command())
        elif demisto.command() == 'investigate-umbrella-domain-search' or demisto.command() == 'umbrella-domain-search':
            demisto.results(get_domain_search_command())
        elif demisto.command() == 'investigate-umbrella-domain-co-occurrences' or demisto.command() == \
                'umbrella-domain-co-occurrences':
            demisto.results(get_domain_co_occurrences_command())
        elif demisto.command() == 'investigate-umbrella-domain-related' or demisto.command() == 'umbrella-domain-related':
            demisto.results(get_domain_related_command())
        elif demisto.command() == 'investigate-umbrella-domain-security' or demisto.command() == 'umbrella-domain-security':
            demisto.results(get_domain_security_command())
        elif demisto.command() == 'investigate-umbrella-domain-dns-history' or demisto.command() == \
                'umbrella-domain-dns-history':
            demisto.results(get_domain_dns_history_command())
        elif demisto.command() == 'investigate-umbrella-ip-dns-history' or demisto.command() == 'umbrella-ip-dns-history':
            demisto.results(get_ip_dns_history_command())
        elif demisto.command() == 'investigate-umbrella-ip-malicious-domains' or demisto.command() == \
                'umbrella-ip-malicious-domains':
            demisto.results(get_ip_malicious_domains_command())
        # new-commands:
        elif demisto.command() == 'domain':
            demisto.results(get_domain_command())
        elif demisto.command() == 'umbrella-get-related-domains':
            demisto.results(get_related_domains_command())
        elif demisto.command() == 'umbrella-get-domain-classifiers':
            demisto.results(get_domain_classifiers_command())
        elif demisto.command() == 'umbrella-get-domain-queryvolume':
            demisto.results(get_domain_query_volume_command())
        elif demisto.command() == 'umbrella-get-domain-details':
            demisto.results(get_domain_details_command())
        elif demisto.command() == 'umbrella-get-domains-for-email-registrar':
            demisto.results(get_domains_for_email_registrar_command())
        elif demisto.command() == 'umbrella-get-domains-for-nameserver':
            demisto.results(get_domains_for_nameserver_command())
        elif demisto.command() == 'umbrella-get-whois-for-domain':
            demisto.results(get_whois_for_domain_command())
        elif demisto.command() == 'umbrella-get-malicious-domains-for-ip':
            demisto.results(get_malicious_domains_for_ip_command())
        elif demisto.command() == 'umbrella-get-domains-using-regex':
            demisto.results(get_domain_using_regex_command())
        elif demisto.command() == 'umbrella-get-domain-timeline':
            demisto.results(get_domain_timeline_command())
        elif demisto.command() == 'umbrella-get-ip-timeline':
            demisto.results(get_ip_timeline_command())
        elif demisto.command() == 'umbrella-get-url-timeline':
            demisto.results(get_url_timeline_command())

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
  subtype: python2
  type: python
system: true
